astError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    //
    // Need to send Daemon cmd and Control file header. We will allocate
    // buffer big enough for the bigger of the two
    //
    dwLen           = 1 + 15 + 1 + dwCFileNameLen + 1;
    dwDaemonCmdLen  = 1 + strlen(pszQueue) + 1;
    if ( dwLen < dwDaemonCmdLen + 1 )
        dwLen = dwDaemonCmdLen + 1;

    size_t cchHdr = dwLen + 1;
    if ( !(pszHdr = (LPSTR) LocalAlloc(LPTR, (cchHdr) * sizeof(CHAR))) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }
    //
    // Send the daemon command first
    //
    StringCchPrintfA (pszHdr, cchHdr, "%c%s\n", LPR_RECV_JOB, pszQueue);

    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwDaemonCmdLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // Form the Control File Header
    //
    StringCchPrintfA (pszHdr, cchHdr,
                    "%c%d %s\n",
                    LPR_CONTROL_HDR,
                    dwCFileLen * sizeof(CHAR),
                    pszCFileName);
    dwLen = strlen (pszHdr);
    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // Include \0 as part of the package here like lprmon
    //
    if ( (dwRet = CTcpJob::Write((unsigned char *)pszCFile,
                                  (dwCFileLen + 1) * sizeof(CHAR),
                                  &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    //
    // For the Data File header
    //
    pszCFileName[0] = 'd';
    if ( m_dwFlags & LPRJOB_SPOOL_FIRST ) {

        StringCchPrintfA (pszHdr, cchHdr,
                        "%c%d %s\n",
                        LPR_DATA_HDR,
                        m_dwJobSize,
                        pszCFileName);

    } else {

        StringCchPrintfA (pszHdr, cchHdr,
                        "%c125899906843000 %s\n",
                        '\3',           // Tells this is the Data File Header
                        pszCFileName);
    }
    dwLen = strlen (pszHdr);
    if ( (dwRet = CTcpJob::Write((unsigned char *)pszHdr,
                                 dwLen * sizeof(CHAR),
                                 &dwWritten))              ||
         (dwRet = ReadLpdReply()) )
        goto Done;

    m_dwFlags  |= LPRJOB_DATASIZESENT;

Done:
    if ( pszCFileName )
        LocalFree(pszCFileName);

    if ( pszCFile )
        LocalFree(pszCFile);

    if ( pszHdr )
        LocalFree(pszHdr);

    if ( pszQueue )
        LocalFree(pszQueue);

    return dwRet;
}


/*++
        StartDoc for the job object
--*/
DWORD
CLPRJob::
StartDoc(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;

    if ( !m_hPrinter && !OpenPrinter(m_sztPrinterName, &m_hPrinter, NULL) )
        return GetLastError();

    if ( m_dwFlags & LPRJOB_SPOOL_FIRST ) {

        UpdateJobStatus(IDS_STRING_SPOOLING);

        if ( (m_hFile = CreateSpoolFile()) == INVALID_HANDLE_VALUE ) {

            if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                dwRetCode = STG_E_UNKNOWN;

            goto Done;
        } else {

            m_dwFlags |= LPRJOB_SPOOLING;
        }
    } else {

        m_bFirstWrite = TRUE;

        dwRetCode = EstablishConnection ();
    }

Done:
    return dwRetCode;
}   //  :: StartDoc()


DWORD
CLPRJob::
Write(
    IN      LPBYTE      pBuf,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
/*++
        Write function for the job object.
        Will write to disk in case of double spooling in the first pass.
        Otherwise send the bits to the LPD server.
--*/
{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwWritten;

    if ( (m_dwFlags & LPRJOB_SPOOL_FIRST) && (m_dwFlags & LPRJOB_SPOOLING) ) {

        dwRet =  WriteFile(m_hFile, pBuf, cbBuf, &dwWritten, NULL)
                        ? ERROR_SUCCESS : GetLastError();

        if ( dwRet == ERROR_SUCCESS ) {
            *pcbWritten += dwWritten;
            m_dwJobSize += dwWritten;

            m_dwFlags &= ~LPRJOB_DISK_FULL;
        }
        else {
            if (dwRet == ERROR_DISK_FULL && !(m_dwFlags & LPRJOB_DISK_FULL)) {
                TCHAR szMsg[256];
                if (LoadString(g_hInstance, IDS_DISK_FULL, szMsg, sizeof (szMsg) / sizeof (TCHAR))){
                    m_dwFlags |= LPRJOB_DISK_FULL;
                    EVENT_LOG1 (EVENTLOG_ERROR_TYPE, HARD_DISK_FULL, szMsg);
                }
            }
        }
    } else {

        if (m_bFirstWrite)
        {
            m_bFirstWrite = FALSE;

            dwRet = StartJob();
        }

        if (dwRet == ERROR_SUCCESS)
        {
            dwRet = CTcpJob::Write(pBuf, cbBuf, pcbWritten);
        }
    }

    return dwRet;
}


DWORD
CLPRJob::
DeSpoolJob(
    )
{
#define  CONNECT_RETRIES  3
    BOOL        bJobAborted = FALSE;
    BOOL        bFirst = TRUE;
    CHAR        szBuf[1];
    DWORD       dwConnectAttempts = 0;
    DWORD       dwRet, dwTime, dwBufSize, dwJobSize, dwRead, dwWritten;
    LPBYTE      pBuf = NULL, pCur;

    m_dwFlags   &= ~LPRJOB_SPOOLING;
    m_dwFlags   |= LPRJOB_DESPOOLING;

    if ( dwRet = SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) )
        goto Done;

    dwJobSize = m_dwJobSize;
    dwBufSize = dwJobSize > READ_BUFFER_SIZE ? READ_BUFFER_SIZE : dwJobSize;

    if ( !(pBuf = (LPBYTE) LocalAlloc(LPTR, dwBufSize)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    while (TRUE) {

        dwRet = EstablishConnection();

        if (dwRet == NO_ERROR)
        {
            dwRet = StartJob ();
        }
        else if (dwRet == ERROR_NOT_CONNECTED)
        {
            dwConnectAttempts++;
            if (dwConnectAttempts >= CONNECT_RETRIES)
                goto Done;
        }

        if (dwRet == NO_ERROR)
        {
            //
            //  We have succeeded in calling startjob
            //
            break;
        }

        //
        // Every LPR_ABORTCHK_TIMEOUT we will check if user deleted the job
        // and every LPR_RETRY_TIMEOUT we will retry talking to the device
        //
        for ( dwTime = 0 ;
              dwTime < LPR_RETRY_TIMEOUT ;
              dwTime += LPR_ABORTCHK_TIMEOUT ) {

            bJobAborted = IsJobAborted (&dwRet);
            if (bJobAborted) {
                goto Done;
            }

            if ( bFirst ) {

                UpdateJobStatus(IDS_STRING_ERROR_OR_BUSY);
                bFirst = FALSE;
            }
            Sleep(LPR_ABORTCHK_TIMEOUT);
        }
    }

    UpdateJobStatus(IDS_STRING_PRINTING);

    while ( dwJobSize ) {

        //
        // Read from spool file
        //
        if ( !ReadFile(m_hFile, pBuf, dwBufSize, &dwRead, NULL) ) {

            dwRet = GetLastError();
            goto Done;
        }

        dwJobSize -= dwRead;

        //
        // Check if job has been cancelled
        //
        bJobAborted = IsJobAborted (&dwRet);
        if (bJobAborted)
        {
            goto Done;
        }

        //
        // Write data in the buffer to the port
        //
        for ( pCur = pBuf ; dwRead ; dwRead -= dwWritten, pCur += dwWritten ) {

            //
            //  Sun Workstation may send a NACK in the middle of the job submission,
            //  so we need to poll the back channel to see if there is anything to
            //  read.
            //
            dwRet = ReadLpdReply(0);

            if (dwRet == CS_E_NETWORK_ERROR)
            {

                goto Done;
            }

            dwWritten = 0;
            dwRet = CTcpJob::Write(pCur, dwRead, &dwWritten);

            if ( dwRet == ERROR_SUCCESS )
                m_dwSizePrinted += dwWritten;
            else if ( dwRet == WSAEWOULDBLOCK ) {
                bJobAborted = IsJobAborted (&dwRet);
                if (bJobAborted) {
                    goto Done; // else continue
                }

            } else
                goto Done;
        }
    }

Done:
    if ( pBuf )
        LocalFree(pBuf);

    //
    // Send the confirmation zero octet for succesful completion
    //
    if ( dwRet == ERROR_SUCCESS && !bJobAborted ) {

        szBuf[0] = '\0';
        if ( (dwRet = CTcpJob::Write((unsigned char *)szBuf,
                            1, &dwWritten)) == ERROR_SUCCESS )
            dwRet = ReadLpdReply (
                m_pParent->GetPortMgr ()->GetLprAckTimeout ()
                );
    }

    if ( dwRet != ERROR_SUCCESS && dwRet != ERROR_PRINT_CANCELLED )
        Restart();

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  EndDoc -- closes the previous connection w/ device
//  Error Codes:
//      NO_ERROR if successful

DWORD
CLPRJob::EndDoc(
    VOID
    )
{
    DWORD   dwRet = NO_ERROR;
    HANDLE  hToken;

    //
    // If we are double spooling then DeSpool if job size is not 0
    //
    if ( (m_dwFlags & LPRJOB_SPOOL_FIRST) && m_dwJobSize ) {

        dwRet = DeSpoolJob();
    }

    if ( m_dwFlags & LPRJOB_STATUS_SET )
        UpdateJobStatus(NULL);

    dwRet = CTcpJob::EndDoc();

    if ( m_hFile != INVALID_HANDLE_VALUE ) {

        dwRet = DeleteSpoolFile ();

    }

    return dwRet;

}   //  ::EndDoc()


CLPRJob::
~CLPRJob(
    VOID
    )
{
    if ( m_hPrinter ) {

        ClosePrinter(m_hPrinter);
        m_hPrinter = NULL;
    }
}

DWORD
CLPRJob::DeleteSpoolFile(
    VOID
    )
{
    DWORD   dwRet = NO_ERROR;
    HANDLE  hToken;

    hToken = RevertToPrinterSelf();

    CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;
    DeleteFile(m_szFileName);

    if (hToken && !ImpersonatePrinterClient(hToken)) {
        dwRet = GetLastError ();
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprjob.h ===
/*****************************************************************************
 *
 * $Workfile: lprjob.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_LPRJOB_H
#define INC_LPRJOB_H

#include "tcpjob.h"


#define     LPR_RECV_JOB                2
#define     LPR_CONTROL_HDR             '\2'
#define     LPR_DATA_HDR                '\3'

#define     LPR_READ_TIMEOUT            90
#define     LPR_ABORTCHK_TIMEOUT      1000
#define     LPR_RETRY_TIMEOUT         4000  // 4 seconds

#define             LPRJOB_SPOOL_FIRST          0x00000001
#define             LPRJOB_SPOOLING             0x00000002
#define             LPRJOB_DESPOOLING           0x00000004
#define             LPRJOB_DATASIZESENT         0x00000008
#define             LPRJOB_STATUS_SET           0x00000010
#define             LPRJOB_DISK_FULL            0x00000020

#define             READ_BUFFER_SIZE            (32 * 1024) //bytes per send for LPR with byte counting

class CLPRPort;

class CLPRJob : public CTcpJob
{
public:
    CLPRJob( LPTSTR psztPrinterName,
                DWORD   jobId,
                DWORD   level,
                LPBYTE  pDocInfo,
                BOOL    bSpoolFirst,
                CTcpPort    *pParent);

    ~CLPRJob(VOID);

    virtual DWORD
    StartDoc();

    virtual DWORD
    Write(
        LPBYTE    pBuf,
        DWORD     cbBuf,
        LPDWORD   pcbWritten);

    virtual DWORD
    EndDoc();

protected:
    BOOL    IsJobAborted(DWORD* pdwRet);

private:
    LPSTR       AllocateAnsiString(LPWSTR  pszUni);
    BOOL        UpdateJobStatus(DWORD   dwStatusId);
    DWORD       ReadLpdReply(DWORD dwTimeout = LPR_READ_TIMEOUT);
    HANDLE      CreateSpoolFile();
    DWORD       GetCFileAndName(LPSTR      *ppszCFileName,
                                LPDWORD     pdwFileNameLen,
                                LPSTR      *ppszCFile,
                                LPDWORD     pdwCFileLen
                                );
    DWORD       StartJob(VOID);
    DWORD       EstablishConnection(VOID);
    DWORD       DeSpoolJob();
    DWORD       DeleteSpoolFile(VOID);


    HANDLE      m_hFile;
    DWORD       m_dwFlags, m_dwJobSize, m_dwSizePrinted;
    TCHAR       m_szFileName[MAX_PATH];
    BOOL        m_bFirstWrite;

};


#endif // INC_LPRJOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprifc.cpp ===
/*****************************************************************************
 *
 * $Workfile: LPRifc.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "lprport.h"
#include "lprifc.h"

/*****************************************************************************
*
* CLPRInterface implementation
*
*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

//DWORD CLPRInterface::m_dwProtocol = PROTOCOL_LPR_TYPE;
//DWORD CLPRInterface::m_dwVersion = PROTOCOL_LPR_VERSION;
static DWORD dwLPRPorts[] = { LPR_PORT_1 };

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::CRawTcpInterface()

CLPRInterface::
CLPRInterface(
    CPortMgr *pPortMgr
    ) : CRawTcpInterface(pPortMgr)
{

    m_dwProtocol    = PROTOCOL_LPR_TYPE;
    m_dwVersion     = PROTOCOL_LPR_VERSION1;
    m_dwPort        = dwLPRPorts;

}   // ::CRawTcpInterface()

///////////////////////////////////////////////////////////////////////////////
//  CLPRInterface::~CLPRInterface()

CLPRInterface::
~CLPRInterface(
    VOID
    )
{
}   // ::~CLPRInterface()

///////////////////////////////////////////////////////////////////////////////
//  GetRegistryEntry

BOOL
CLPRInterface::
GetRegistryEntry(
    IN      LPTSTR              psztPortName,
    IN      DWORD               dwVersion,
    IN      CRegABC             *pRegistry,
    OUT     LPR_PORT_DATA_1     *pRegData1
    )
{
    BOOL    bRet = FALSE;
    BOOL    bKeySet = FALSE;
    DWORD   dwSize, dwRet;

    memset( pRegData1, 0, sizeof(RAWTCP_PORT_DATA_1) );

    if ( dwRet = pRegistry->SetWorkingKey(psztPortName) )
        goto Done;

    bKeySet = TRUE;
    //
    // Get host name
    //
    dwSize = sizeof(pRegData1->sztHostName);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HOSTNAME,
                                      (LPBYTE)pRegData1->sztHostName,
                                      &dwSize) )
        goto Done;

    //
    // Get IP Address
    //
    dwSize = sizeof(pRegData1->sztIPAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_IPADDR,
                                       (LPBYTE)pRegData1->sztIPAddress,
                                       &dwSize) )
        goto Done;

    //
    // Get Hardware address
    //
    dwSize = sizeof(pRegData1->sztHWAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HWADDR,
                                       (LPBYTE)pRegData1->sztHWAddress,
                                       &dwSize) )
        goto Done;

    //
    // Get the port number (ex: 9100, 9101)
    //
    dwSize = sizeof(pRegData1->dwPortNumber);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_PORTNUM,
                                       (LPBYTE)&(pRegData1->dwPortNumber),
                                       &dwSize) )
        goto Done;

    //
    // Get the lpr queue name
    //
    dwSize = sizeof(pRegData1->sztQueue);
    if (dwRet = pRegistry->QueryValue(PORTMONITOR_QUEUE,
                                       (LPBYTE)pRegData1->sztQueue,
                                       &dwSize)  )
        goto Done;


    //
    // Get Double spool enabled flag
    //
    dwSize = sizeof(pRegData1->dwDoubleSpool);
    if ( pRegistry->QueryValue(DOUBLESPOOL_ENABLED,
                               (LPBYTE)&(pRegData1->dwDoubleSpool),
                               &dwSize) ) {

        pRegData1->dwDoubleSpool = 0;
    }

    //
    // Get SNMP status enabled flag
    //
    dwSize = sizeof(pRegData1->dwSNMPEnabled);
    if ( dwRet = pRegistry->QueryValue(SNMP_ENABLED,
                                       (LPBYTE)&(pRegData1->dwSNMPEnabled),
                                       &dwSize) )
        goto Done;

    //
    // Get SNMP device index
    //
    dwSize = sizeof(pRegData1->dwSNMPDevIndex);
    if ( dwRet = pRegistry->QueryValue(SNMP_DEVICE_INDEX,
                                      (LPBYTE)&(pRegData1->dwSNMPDevIndex),
                                      &dwSize) )
        goto Done;

    //
    // Get SNMP community
    //
    dwSize = sizeof(pRegData1->sztSNMPCommunity);
    if ( dwRet = pRegistry->QueryValue(SNMP_COMMUNITY,
                                       (LPBYTE)&(pRegData1->sztSNMPCommunity),
                                       &dwSize) )
        goto Done;

    bRet = TRUE;

    Done:
       if ( bKeySet )
           pRegistry->FreeWorkingKey();

       if ( !bRet )
           SetLastError(dwRet);


    return bRet;

}   // GetRegistryEntry()



///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CLPRInterface::
CreatePort(
    IN      DWORD           dwProtocol,
    IN      DWORD           dwVersion,
    IN      PPORT_DATA_1    pData,
    IN      CRegABC         *pRegistry,
    IN OUT  CPortRefABC    **pPort )
{
    DWORD   dwRetCode = NO_ERROR;

    //
    //  Is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocol) )
        return  ERROR_NOT_SUPPORTED;

    //
    // Is the version supported
    //
    if ( !IsVersionSupported(dwVersion) )
        return  ERROR_INVALID_LEVEL;

    EnterCSection();

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:  {   // PORT_DATA_1
            CLPRPort *pLPRPort = new CLPRPort(pData->sztPortName,
                                  pData->sztHostAddress,
                                  pData->sztQueue,
                                  pData->dwPortNumber,
                                  pData->dwDoubleSpool,
                                  pData->dwSNMPEnabled,
                                  pData->sztSNMPCommunity,
                                  pData->dwSNMPDevIndex,
                                  pRegistry,
                                  m_pPortMgr);
            if (pLPRPort) {
                pLPRPort->SetRegistryEntry(pData->sztPortName,
                                              dwProtocol,
                                              dwVersion,
                                              (LPBYTE)pData );
                *pPort = pLPRPort;
            } else {
                *pPort = NULL;
            }

            if ( !*pPort && (dwRetCode = GetLastError() == ERROR_SUCCESS) )
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        default:
            dwRetCode = ERROR_NOT_SUPPORTED;

    }   // end::switch

    ExitCSection();

    return dwRetCode;

}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CLPRInterface::
CreatePort(
    IN      LPTSTR          psztPortName,
    IN      DWORD           dwProtocolType,
    IN      DWORD           dwVersion,
    IN      CRegABC         *pRegistry,
    IN OUT  CPortRefABC     **pPort )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    //
    // Is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocolType) )
        return  ERROR_NOT_SUPPORTED;

    //
    // Is the version supported?
    //
    if ( !IsVersionSupported(dwVersion) )
        return  ERROR_INVALID_LEVEL;

    EnterCSection();

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:      // LPR_PORT_DATA_1

            LPR_PORT_DATA_1 regData1;

            //
            // read the registry entry & parse the data then call the CLPRPort
            //
            if ( !GetRegistryEntry(psztPortName,
                                  dwVersion,
                                  pRegistry,
                                  &regData1)){
                if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                    dwRetCode = STG_E_UNKNOWN;
                    goto Done;
            }

            //
            // fill in the port name
            //
            lstrcpyn(regData1.sztPortName, psztPortName, MAX_PORTNAME_LEN); // fill in the port name
            if ( *pPort = new CLPRPort(regData1.sztPortName,
                                       regData1.sztHostName,
                                       regData1.sztIPAddress,
                                       regData1.sztHWAddress,
                                       regData1.sztQueue,
                                       regData1.dwPortNumber,
                                       regData1.dwDoubleSpool,
                                       regData1.dwSNMPEnabled,
                                       regData1.sztSNMPCommunity,
                                       regData1.dwSNMPDevIndex,
                                       pRegistry,
                                       m_pPortMgr ) )
                bRet = TRUE;
            break;
    }   // end::switch

Done:
    ExitCSection();

    if ( !bRet && (dwRetCode = GetLastError()) != ERROR_SUCCESS )
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

    return dwRetCode;
}   // ::CreatePort()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprport.cpp ===
/*****************************************************************************
 *
 * $Workfile: lprport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "lprdata.h"
#include "lprjob.h"
#include "lprifc.h"
#include "lprport.h"

///////////////////////////////////////////////////////////////////////////////
//  CLPRPort::CLPRPort()    -- called when creating a new port through the UI

CLPRPort::
CLPRPort(
    IN  LPTSTR      psztPortName,
    IN  LPTSTR      psztHostAddress,
    IN  LPTSTR      psztQueue,
    IN  DWORD       dPortNum,
    IN  DWORD       dDoubleSpool,
    IN  DWORD       dSNMPEnabled,
    IN  LPTSTR      sztSNMPCommunity,
    IN  DWORD       dSNMPDevIndex,
    IN  CRegABC     *pRegistry,
    IN  CPortMgr    *pPortMgr
    ) : m_dwDoubleSpool(dDoubleSpool),
        CTcpPort(psztPortName, psztHostAddress, dPortNum, dSNMPEnabled,
                 sztSNMPCommunity, dSNMPDevIndex, pRegistry, pPortMgr)
{
    lstrcpyn(m_szQueue, psztQueue, SIZEOF_IN_CHAR(m_szQueue));
}   // ::CLPRPort()


///////////////////////////////////////////////////////////////////////////////
//  CLPRPort::CLPRPort() -- called when creating a new port through the
//      registry entries.

CLPRPort::
CLPRPort(
    IN  LPTSTR      psztPortName,
    IN  LPTSTR      psztHostName,
    IN  LPTSTR      psztIPAddr,
    IN  LPTSTR      psztHWAddr,
    IN  LPTSTR      psztQueue,
    IN  DWORD       dPortNum,
    IN  DWORD       dDoubleSpool,
    IN  DWORD       dSNMPEnabled,
    IN  LPTSTR      sztSNMPCommunity,
    IN  DWORD       dSNMPDevIndex,
    IN  CRegABC     *pRegistry,
    IN  CPortMgr    *pPortMgr
    ) : m_dwDoubleSpool( dDoubleSpool ),
        CTcpPort(psztPortName, psztHostName, psztIPAddr, psztHWAddr, dPortNum,
                 dSNMPEnabled, sztSNMPCommunity, dSNMPDevIndex, pRegistry, pPortMgr)
{
    lstrcpyn(m_szQueue, psztQueue, SIZEOF_IN_CHAR(m_szQueue));
}   // ::CLPRPort()


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CLPRPort::
StartDoc(
    IN  LPTSTR  psztPrinterName,
    IN  DWORD   jobId,
    IN  DWORD   level,
    IN  LPBYTE  pDocInfo
    )
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT3(_CRT_WARN,
          "PORT -- (CLPRPort) StartDoc called for (%S,%S) w/ jobID %d\n",
          psztPrinterName, m_szName, jobId);

    if ( m_pJob == NULL ) {
        m_pJob = new CLPRJob(psztPrinterName, jobId, level, pDocInfo,
                             m_dwDoubleSpool, this);

        if ( m_pJob ) {

            if ( dwRetCode = m_pJob->StartDoc() ) {

                delete m_pJob;
                m_pJob = NULL;
            }
        } else if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS ) {

            dwRetCode = STG_E_UNKNOWN;
        }
    }
    else {
        _RPT0( _CRT_WARN, TEXT("PORT - (LPRPORT)Start Doc called withour EndDoc\n") );
    }

    return dwRetCode;

}   // ::StartDoc()


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry

DWORD
CLPRPort::
SetRegistryEntry(
    IN  LPCTSTR     psztPortName,
    IN  DWORD       dwProtocol,
    IN  DWORD       dwVersion,
    IN  LPBYTE      pData
    )
{
    DWORD           dwRetCode = NO_ERROR;
    PPORT_DATA_1    pPortData = (PPORT_DATA_1)pData;

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_LPR_VERSION1:      // ADDPORT_DATA_1

            _ASSERTE( _tcscmp(psztPortName, pPortData->sztPortName) == 0 );

            dwRetCode = UpdateRegistryEntry( psztPortName,
                                             dwProtocol,
                                             dwVersion );


            break;

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;
    }   // end::switch

    return dwRetCode;

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  UpdateRegistryEntry

DWORD
CLPRPort::
UpdateRegistryEntry( LPCTSTR    psztPortName,
                     DWORD      dwProtocol,
                     DWORD      dwVersion
    )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = CTcpPort::UpdateRegistryEntry( psztPortName,
                                               dwProtocol,
                                               dwVersion );

    if  ( dwRetCode == NO_ERROR ) {
        if( m_pRegistry->SetWorkingKey( psztPortName ) == NO_ERROR ) {
            dwRetCode = m_pRegistry->SetValue( PORTMONITOR_QUEUE,
                                                    REG_SZ,
                                                    (LPBYTE)m_szQueue,
                                                    (_tcslen(m_szQueue) +1) * sizeof(TCHAR));

            if( dwRetCode == NO_ERROR )
            {
                dwRetCode = m_pRegistry->SetValue( DOUBLESPOOL_ENABLED,
                                                REG_DWORD,
                                                (CONST BYTE *)&m_dwDoubleSpool,
                                                sizeof(DWORD));

            }
            m_pRegistry->FreeWorkingKey();
        }
    }

    return dwRetCode;

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CLPRPort::
InitConfigPortUI(
    const DWORD dwProtocolType,
    const DWORD dwVersion,
    LPBYTE      pData
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_DATA_1    pConfigPortData = (PPORT_DATA_1) pData;

    if ( NO_ERROR != (dwRetCode = CTcpPort::InitConfigPortUI(dwProtocolType, dwVersion, pData)))
        goto Done;

    lstrcpyn(pConfigPortData->sztQueue, m_szQueue, MAX_QUEUENAME_LEN);
    pConfigPortData->dwDoubleSpool = m_dwDoubleSpool;
    pConfigPortData->dwVersion = PROTOCOL_LPR_VERSION1;
    pConfigPortData->dwProtocol = PROTOCOL_LPR_TYPE;

Done:
    return dwRetCode;

}   // ::InitConfigPortUI()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprport.h ===
/*****************************************************************************
 *
 * $Workfile: lprport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_LPRPORT_H
#define INC_LPRPORT_H

#include "rawport.h"
#include "LPRData.h"
#include "regabc.h"

class CLPRJob;
class CLPRInterface;


class CLPRPort : public CTcpPort
{
	// methods
public:
    CLPRPort();

    CLPRPort(LPTSTR		psztPortName,		// called through the UI port creation
             LPTSTR		psztHostAddress, 
			 LPTSTR		psztQueue,
			 DWORD		dPortNum,
             DWORD      dDoubleSpool,
			 DWORD		dSNMPEnabled,
			 LPTSTR		sztSNMPCommunity,
			 DWORD		dSNMPDevIndex,
			 CRegABC	*pRegistry,
             CPortMgr   *pPortMgr);
	
    CLPRPort(LPTSTR		psztPortName,		// called through the registry port creation
  			 LPTSTR 	psztHostName, 
	  		 LPTSTR 	psztIPAddr, 
		  	 LPTSTR 	psztHWAddr, 
			 LPTSTR     psztQueue,
		  	 DWORD  	dPortNum,
             DWORD      dDoubleSpool,
			 DWORD		dSNMPEnabled,
  			 LPTSTR		sztSNMPCommunity,
	  		 DWORD		dSNMPDevIndex,
			 CRegABC	*pRegistry,
             CPortMgr   *pPortMgr);

    DWORD   StartDoc(const LPTSTR psztPrinterName,
                     const DWORD  jobId,
                     const DWORD  level,
                     const LPBYTE pDocInfo);

	DWORD	SetRegistryEntry(LPCTSTR		psztPortName, 
							 const DWORD	dwProtocol, 
                             const DWORD	dwVersion, 
							 const LPBYTE   pData);

	LPTSTR  GetQueue()	{ return m_szQueue;  }

	DWORD	InitConfigPortUI( const DWORD	dwProtocolType, 
							const DWORD	dwVersion, 
							LPBYTE		pData);

private:	// methods
    DWORD   UpdateRegistryEntry(LPCTSTR psztPortName,
								DWORD	 dwProtocol, 
								DWORD	 dwVersion);	
	

private:	// attributes					
	TCHAR		m_szQueue[MAX_QUEUENAME_LEN];
    DWORD       m_dwDoubleSpool;
};


#endif // INC_LPRPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\makefile.inc ===
message.h message.rc msg00001.bin: message.mc
    mc -v message.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\port.cpp ===
/*****************************************************************************
 *
 * $Workfile: Port.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 ****************************************************************************
 *
 *  To ensure that we don't have threads crashing on configuration and deletion
 *  we keep track of the current refrences to the threads.
 *
 *  Caution: be careful when making changes to refrences to m_pRealPort
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "portmgr.h"
#include "port.h"
#include "rawtcp.h"
#include "lprifc.h"


///////////////////////////////////////////////////////////////////////////////
//  CPort::CPort()
//      Called by CPortMgr when creating a new port through the registry entry

CPort::
CPort(
    IN  LPTSTR      psztPortName,
    IN  DWORD       dwProtocolType,
    IN  DWORD       dwVersion,
    IN  CPortMgr    *pParent,
    IN  CRegABC     *pRegistry
    ) : m_dwProtocolType(dwProtocolType), m_dwVersion(dwVersion),
        m_pParent(pParent), m_pRealPort(NULL),
        m_iState(CLEARED), m_bValid(FALSE),
        m_hPortSync(NULL), m_pRegistry( pRegistry ),m_bUsed(FALSE),
        m_dwLastError(NO_ERROR)
{
    InitPortSem();

    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);

    switch ( m_dwProtocolType ) {

        case PROTOCOL_RAWTCP_TYPE: {
            CRawTcpInterface    *pPort = new CRawTcpInterface(m_pParent);

            if ( !pPort )
                return;

            m_bValid = ERROR_SUCCESS == pPort->CreatePort(psztPortName,
                                                          m_dwProtocolType,
                                                          m_dwVersion,
                                                          m_pRegistry,
                                                          &m_pRealPort);
            _ASSERTE(m_pRealPort != NULL);
            delete pPort;
            break;
        }

        case PROTOCOL_LPR_TYPE: {
            CLPRInterface   *pPort = new CLPRInterface(m_pParent);

            if ( !pPort )
                return;

            m_bValid = ERROR_SUCCESS == pPort->CreatePort(psztPortName,
                                                          m_dwProtocolType,
                                                          m_dwVersion,
                                                          m_pRegistry,
                                                          &m_pRealPort);
            _ASSERTE(m_pRealPort != NULL);
            delete pPort;
            break;
        }

        default:
            // Nothig to do, m_bValid is FALSE
            break;
    }
}   // ::CPort()


///////////////////////////////////////////////////////////////////////////////
//  CPort::CPort()
//      Called by CPortMgr when creating a new port through the UI

CPort::
CPort(
    IN  DWORD       dwProtocolType,
    IN  DWORD       dwVersion,
    IN  LPBYTE      pData,
    IN  CPortMgr    *pParent,
    IN  CRegABC     *pRegistry
    ) : m_dwProtocolType(dwProtocolType), m_dwVersion(dwVersion),
        m_pParent(pParent), m_pRealPort(NULL), m_iState(CLEARED),
        m_bValid(FALSE), m_hPortSync( NULL ),
        m_pRegistry( pRegistry ),m_bUsed(FALSE),
        m_dwLastError(NO_ERROR)
{
    InitPortSem();

    lstrcpyn(m_szName, ((PPORT_DATA_1)pData)->sztPortName, MAX_PORTNAME_LEN );

    switch (m_dwProtocolType) {

        case PROTOCOL_RAWTCP_TYPE: {

            CRawTcpInterface *pRawInterface = new CRawTcpInterface(m_pParent);
            if ( !pRawInterface ) {

                m_dwLastError = ERROR_OUTOFMEMORY;
            } else {

                pRawInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                          (PPORT_DATA_1)pData,
                                          pRegistry,
                                          &m_pRealPort);
                _ASSERTE(m_pRealPort != NULL);

                delete pRawInterface;
            }
            break;
        }

        case PROTOCOL_LPR_TYPE: {

            CLPRInterface *pLPRInterface = new CLPRInterface(m_pParent);

            if( !pLPRInterface ) {

                m_dwLastError = ERROR_OUTOFMEMORY;
            } else {

                pLPRInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                          (PPORT_DATA_1)pData,
                                          pRegistry,
                                          &m_pRealPort);
                _ASSERTE(m_pRealPort != NULL);

                delete pLPRInterface;
            }
            break;
        }
        default:
            break; // Nothing to do

    }
}   // ::CPort()


///////////////////////////////////////////////////////////////////////////////
//  CPort::~CPort()
//      Called by CPortMgr when deleting a port

CPort::
~CPort(
    VOID
    )
{

    _ASSERTE(m_dwRefCount == 0);

    if( m_hPortSync)
        CloseHandle( m_hPortSync );

    if ( m_pRealPort ) {
        m_pRealPort->DecRef();
        m_pRealPort = NULL;

    }
}   // ::~CPort

DWORD
CPort::Configure(
    DWORD   dwProtocolType,
    DWORD   dwVersion,
    LPTSTR  psztPortName,
    LPBYTE  pData
    )
{
    DWORD dwRetCode = NO_ERROR;

    m_bValid = FALSE;
    m_iState = CLEARED;


    m_dwProtocolType = dwProtocolType;
    m_dwVersion = dwVersion;

    dwRetCode = LockRealPort();
    if ( dwRetCode == NO_ERROR ) {

        if (m_pRealPort)
        {
            m_pRealPort->DecRef();
            m_pRealPort = NULL;
        }

        // For testing only
        //

        //MessageBox (NULL, _T("The real port has been deleted"), _T("Click OK to continue"), MB_OK);

        switch (dwProtocolType) {
            case PROTOCOL_RAWTCP_TYPE: {

                CRawTcpInterface *pRawInterface = new CRawTcpInterface(m_pParent);
                if ( !pRawInterface ) {

                    dwRetCode = ERROR_OUTOFMEMORY;
                } else {

                    pRawInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                              (PPORT_DATA_1)pData,
                                              m_pRegistry,
                                              &m_pRealPort);
                    _ASSERTE(m_pRealPort != NULL);

                    delete pRawInterface;
                }
                break;
            }

            case PROTOCOL_LPR_TYPE: {

                CLPRInterface *pLPRInterface = new CLPRInterface(m_pParent);
                if ( !pLPRInterface ) {

                    dwRetCode = ERROR_OUTOFMEMORY;
                } else {

                    pLPRInterface->CreatePort(m_dwProtocolType, m_dwVersion,
                                              (PPORT_DATA_1)pData,
                                              m_pRegistry,
                                              &m_pRealPort);
                    _ASSERTE(m_pRealPort != NULL);

                    delete pLPRInterface;
                }
                break;
            }

            default:
                break; // Nothing to do
        }

        if ( m_pRealPort != NULL ) {

            m_pParent->EnterCSection();

            dwRetCode = m_pRealPort->SetRegistryEntry(psztPortName,
                                                      m_dwProtocolType,
                                                      m_dwVersion, pData);

            m_pParent->ExitCSection();

            ClearDeviceStatus();
        }

        UnlockRealPort();

    }

    return ( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CPort::StartDoc( const LPTSTR in psztPrinterName,
                 const DWORD  in jobId,
                 const DWORD  in level,
                 const LPBYTE in pDocInfo)
{
    DWORD   dwRetCode = NO_ERROR;

    // serialize access to the port
    m_pParent->EnterCSection();
    if (m_iState == INSTARTDOC)
    {
        m_pParent->ExitCSection();
        return ERROR_BUSY;
    }
    m_iState = INSTARTDOC;
    m_pParent->ExitCSection();

    dwRetCode = SetRealPortSem();

    if (dwRetCode == NO_ERROR ) {

        dwRetCode = m_pRealPort->StartDoc(psztPrinterName,
                                          jobId,
                                          level,
                                          pDocInfo);

        if (dwRetCode != NO_ERROR)
        {
            m_pParent->EnterCSection();
            m_iState = CLEARED;         // start doc failed
            m_pParent->ExitCSection();

            UnSetRealPortSem();
        }
    }
    return (dwRetCode);

}   // ::StartDoc()


///////////////////////////////////////////////////////////////////////////////
//  Write
//      Error codes:
//          NO_ERROR if succesfull
//  FIX: complete Write processing & define how it relates to a job

DWORD
CPort::Write(   LPBYTE  in      pBuffer,
                DWORD   in      cbBuf,
                LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pRealPort->Write(pBuffer, cbBuf, pcbWritten);

    return(dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  EndDoc
//      Error codes:
//          NO_ERROR if succesfull

DWORD
CPort::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pRealPort->EndDoc();

    // serialize access to the port
    m_pParent->EnterCSection();
    m_iState = CLEARED;
    m_pParent->ExitCSection();

    UnSetRealPortSem();

    return(dwRetCode);

}   // ::EndDoc()


///////////////////////////////////////////////////////////////////////////////
//  GetInfo -- returns port info w/ the PORT_INFO_x information. It is assumed
//      that pPort points to a buffer large enough for port info. Each time it is
//      called, it adds the PORT_INFO structures at the beginning of the buffer, and
//      strings at the end.
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_INVALID_LEVEL if level is invalid
//          ERROR_INSUFFICIENT_BUFFER if pPortBuf is not big enough

DWORD
CPort::GetInfo( const DWORD   in    level,    // PORT_INFO_1/2
                      LPBYTE inout  &pPortBuf, // buffer to place the PORT_INFO_x struct
                      LPTCH  inout  &pEnd)    // pointer to end of the buffer where the
                                              // any strings should be placed
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_INFO_1    pInfo1 = (PPORT_INFO_1)pPortBuf;
    PPORT_INFO_2    pInfo2 = (PPORT_INFO_2)pPortBuf;
    TCHAR           szPortName[MAX_PORTNAME_LEN+1];
    size_t          cchString = 0;

    lstrcpyn(szPortName, GetName(), MAX_PORTNAME_LEN);
    switch (level)
    {
        case 1:
            {
                cchString = _tcslen(szPortName) + 1;
                pEnd -= cchString;
                if (pPortBuf < (LPBYTE) pEnd)
                {
                    StringCchCopy((LPTSTR)pEnd, cchString, szPortName );
                    pInfo1->pName = (LPTSTR)pEnd;
                }
                else
                {
                    pInfo1->pName = NULL;
                }

                ++pInfo1;
                pPortBuf = (LPBYTE) pInfo1;
            }
            break;

        case 2:
            cchString = _tcslen(PORTMONITOR_DESC) + 1;
            pEnd -= cchString;
            if (pPortBuf < (LPBYTE) pEnd)
            {
                StringCchCopy ( (LPTSTR)pEnd, cchString, PORTMONITOR_DESC);
                pInfo2->pDescription = (LPTSTR)pEnd;
            }
            else
            {
                pInfo2->pDescription = NULL;
            }

            cchString = _tcslen(PORTMONITOR_NAME) + 1;
            pEnd -= cchString;
            if (pPortBuf < (LPBYTE) pEnd)
            {
                StringCchCopy ((LPTSTR)pEnd, cchString, PORTMONITOR_NAME);
                pInfo2->pMonitorName = (LPTSTR)pEnd;
            }
            else
            {
                pInfo2->pMonitorName = NULL;
            }

            pInfo2->fPortType = PORT_TYPE_READ | PORT_TYPE_WRITE;
    #ifdef WINNT
            // Don't mark ports as net attached for Windows 95, since this
            // will prevent them from being shared!!!!
            pInfo2->fPortType |= /*PORT_TYPE_REDIRECTED |*/ PORT_TYPE_NET_ATTACHED;
    #endif
            cchString = _tcslen(szPortName) + 1;
            pEnd -= cchString;
            if (pPortBuf < (LPBYTE) pEnd)
            {
                StringCchCopy ((LPTSTR)pEnd, cchString, szPortName);
                pInfo2->pPortName = (LPTSTR)pEnd;
            }
            else
            {
                pInfo2->pPortName = NULL;
            }

            ++pInfo2;
            pPortBuf = (LPBYTE) pInfo2;
            break;

        default:
            dwRetCode = ERROR_INVALID_LEVEL;
            break;
    }

    return (dwRetCode);

}   // ::GetInfo()


///////////////////////////////////////////////////////////////////////////////
//  GetInfoSize -- calculates the size of buffer needed for PORT_INFO_x struct.
//      Called by CPortMgr::EnumPorts()
//
//      Return:
//          # bytes needed for PORT_INFO_x struct
//  FIX: complete GetInfoSize processing

DWORD
CPort::GetInfoSize( const DWORD in level )
{
    DWORD   dwPortInfoSize = 0;
    TCHAR   sztPortName[MAX_PORTNAME_LEN+1];

    lstrcpyn( sztPortName, GetName(), MAX_PORTNAME_LEN );
    switch (level)
    {
        case 1:
            dwPortInfoSize = sizeof(PORT_INFO_1) + STRLENN_IN_BYTES(sztPortName);
            break;

        case 2:
            dwPortInfoSize = ( sizeof(PORT_INFO_2)  +
                    STRLENN_IN_BYTES(sztPortName) +
                    STRLENN_IN_BYTES(PORTMONITOR_NAME) +
                    STRLENN_IN_BYTES(PORTMONITOR_DESC) );
            break;
    }

    return (dwPortInfoSize);

}   // ::GetInfoSize()


///////////////////////////////////////////////////////////////////////////////
//  GetName

LPCTSTR
CPort::GetName()
{
    return (LPCTSTR) m_szName;
}   // ::GetName()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CPort::InitConfigPortUI( const DWORD    in  dwProtocolType,
                         const DWORD    in  dwVersion,
                         LPBYTE         out pConfigPortData)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->InitConfigPortUI(dwProtocolType, dwVersion, pConfigPortData);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::InitConfigPortUI()


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry -- writes the information to the register

DWORD
CPort::SetRegistryEntry( LPCTSTR      in    psztPortName,
                         const DWORD  in    dwProtocol,
                         const DWORD  in    dwVersion,
                         const LPBYTE in    pData )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->SetRegistryEntry(psztPortName, dwProtocol, dwVersion, pData);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::Register()

///////////////////////////////////////////////////////////////////////////////
//  DelRegistryEntry -- deletes the information to the register

DWORD
CPort::DeleteRegistryEntry( LPTSTR    in    psztPortName )
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = LockRealPort();

    if( dwRetCode == NO_ERROR ) {
        if (! m_pRegistry->DeletePortEntry(psztPortName))
            dwRetCode = GetLastError ();
        UnlockRealPort();
    }

    return (dwRetCode);

}   // ::Register()

///////////////////////////////////////////////////////////////////////////////
//  operator== -- determines whether two ports are equal, or not.
//      Comparasions on the port name, and device mac address are done.
//      For the same type of printing protocol, there cannot be created more than
//      one port to the same device -- i.e. check MAC address, and ensure it prints
//      to a different port if it is an JetDirect Ex box.
//      Return:
//          TRUE if two ports are equal
//          FALSE if two ports are not equal
//      FIX: operator== function


BOOL
CPort::operator==(CPort &newPort )
{
    // compare the port name
    if (_tcscmp(this->GetName(), newPort.GetName()) == 0)
        return TRUE;        // port name matches

    return FALSE;

}   // ::operator==()


///////////////////////////////////////////////////////////////////////////////
//  operator== -- determines whether two port names are equal, or not.
//      Return:
//          TRUE if two port names are equal
//          FALSE if two port names are not equal
//      FIX: operator== function


BOOL
CPort::operator==( const LPTSTR psztPortName )
{
    if (_tcscmp(this->GetName(), psztPortName) == 0)
        return TRUE;        // port name matches

    return FALSE;

}   // ::operator==()

BOOL
CPort::ValidateRealPort()
{
    return (m_pRealPort != NULL);

}   //  ::ValidateRealPort()

///////////////////////////////////////////////////////////////////////////////
//  GetSNMPInfo --

DWORD
CPort::GetSNMPInfo( PSNMP_INFO pSnmpInfo)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        dwRetCode = m_pRealPort->GetSNMPInfo(pSnmpInfo);
        UnSetRealPortSem();
    }

    return (dwRetCode);

}   // ::InitConfigPortUI()

DWORD
CPort::SetDeviceStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    CPortRefABC *pRealPort;

    dwRetCode = SetRealPortSem();

    if( dwRetCode == NO_ERROR ) {
        pRealPort = m_pRealPort;
        pRealPort->IncRef();
        UnSetRealPortSem();

        // For Testing only
        //
        // MessageBox (NULL, _T("I'm settting device status"), _T("Click OK to continue"), MB_OK);

        dwRetCode =  pRealPort->SetDeviceStatus();

        pRealPort->DecRef();
    }

    return (dwRetCode);
}

//
// Private Sync Fuctions
//

DWORD
CPort::InitPortSem()
{

    m_hPortSync = CreateSemaphore( NULL, MAX_SYNC_COUNT,
                                   MAX_SYNC_COUNT, NULL );
    if( m_hPortSync ==  NULL ) {
        return( GetLastError() );
    }

    return( NO_ERROR );
}

BOOL
CPort::EndPortSem()
{
    if( m_hPortSync != NULL ) {
        return( CloseHandle( m_hPortSync ));
    }
    return(FALSE);
}

DWORD
CPort::SetRealPortSem()
{
    LONG cRetry = 0;
    DWORD dwRetCode = NO_ERROR;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    do {
        dwRetCode = WaitForSingleObject( m_hPortSync, SYNC_TIMEOUT );

        if (dwRetCode == WAIT_FAILED ) {
            return( GetLastError());
        } else if (dwRetCode == WAIT_TIMEOUT ) {
            dwRetCode = ERROR_BUSY;
        } else {
            dwRetCode = NO_ERROR;
        }
        cRetry ++;
    } while( dwRetCode != NO_ERROR && cRetry < MAX_SYNC_RETRIES );

    return( NO_ERROR );
}

DWORD
CPort::UnSetRealPortSem()
{

    BOOL  bSemSet = FALSE;
    LONG cCur;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    bSemSet = ReleaseSemaphore( m_hPortSync, 1, &cCur );
    if( !bSemSet )
        return( GetLastError() );

    return( NO_ERROR );
}

DWORD
CPort::LockRealPort()
{
    DWORD dwRetCode = 0;
    LONG cLock = 0;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    while ( cLock < MAX_SYNC_COUNT ) {
        dwRetCode = WaitForSingleObject( m_hPortSync, SYNC_TIMEOUT );

        if (dwRetCode == WAIT_FAILED ) {
            ReleaseSemaphore( m_hPortSync, cLock, NULL );
            return( GetLastError());
        } else if (dwRetCode == WAIT_TIMEOUT ) {
            ReleaseSemaphore( m_hPortSync, cLock, NULL );
            return( ERROR_BUSY );
        }
        cLock++;
    }

    return( NO_ERROR );
}

DWORD
CPort::UnlockRealPort()
{

    BOOL  bSemSet = FALSE;

    if ( m_hPortSync == NULL ) {
        return( ERROR_INVALID_HANDLE );
    }

    bSemSet = ReleaseSemaphore( m_hPortSync, MAX_SYNC_COUNT, NULL );

    if( !bSemSet )
        return( GetLastError() );

    return( NO_ERROR );
}


DWORD
CPort::
ClearDeviceStatus(
    )
{
    return m_pRealPort->ClearDeviceStatus();
}


time_t
CPort::
NextUpdateTime(
    )
{
    time_t tUpdateTime = 60*60; // equal to SmallestUpdateTime
                                // from CDeviceStatus::CheckAndUpdateAllPrinters
    CPortRefABC *pRealPort;

    if( SetRealPortSem() == NO_ERROR ) {
        pRealPort = m_pRealPort;
        pRealPort->IncRef();
        UnSetRealPortSem();

        tUpdateTime =  pRealPort->NextUpdateTime();

        pRealPort->DecRef();
    }

    return tUpdateTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\port.h ===
/*****************************************************************************
 *
 * $Workfile: Port.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 ****************************************************************************
 *
 *	To ensure that we don't have threads crashing on configuration and deletion
 *	we keep track of the current refrences to the threads.
 *	
 *	Caution: be careful when making changes to refrences to m_pRealPort
 *
 *****************************************************************************/

#ifndef INC_PORT_H
#define INC_PORT_H

#include "portABC.h"
#include "portrefABC.h"
#include "mglist.h"
#include "devabc.h"

class CPortMgr;

enum PORTSTATE	{ CLEARED, INSTARTDOC };

#define MAX_SYNC_COUNT		10
#define SYNC_TIMEOUT		10000		// 10 s
#define MAX_SYNC_RETRIES    3

typedef class CPort* PCPORT;

class CPort : public CPortABC, public TRefNodeABC <PCPORT, LPTSTR>
{
	// methods
public:
	CPort( DWORD	dwProtocolType,
		   DWORD	dwVersion,
		   LPBYTE	pData,
		   CPortMgr *pParent,
		   CRegABC	*pRegistry);
    CPort( LPTSTR	psztPortName,
		   DWORD	dwProtocolType,
		   DWORD	dwVersion,
		   CPortMgr *pParent,
		   CRegABC	*pRegistry);

    DWORD Configure( DWORD	dwProtocolType,
					 DWORD	dwVersion,
					 LPTSTR	psztPortName,
					 LPBYTE	pData );


    BOOL operator==( CPort &newPort);
    BOOL operator==( const LPTSTR psztPortName);

    //
    // required for the list implementation
    //
    BOOL operator!=(const CPort &lhs) const;
    BOOL operator<(const CPort &lhs);
    BOOL operator>(const CPort &lhs) const;

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("%ws", m_szName));
        return TRefNodeABC <PCPORT, LPTSTR>::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("%ws", m_szName));
        return TRefNodeABC <PCPORT, LPTSTR>::DecRef();
    };
#endif

    INT Compare (PCPORT &k) {
        BOOL bDel;

        if (!IsPendingDeletion (bDel) || bDel) {
            return 1;
        }
        else
            return lstrcmpi (m_szName, k->m_szName);
    };

    INT Compare (LPTSTR &pszName) {
        BOOL bDel;

        if (!IsPendingDeletion (bDel) || bDel) {
            return 1;
        }
        else {
            return lstrcmpi (m_szName, pszName);
        }
    };

    BOOL PartialDelete (VOID) {
        BOOL bRet = TRUE;
        DWORD dwRet = DeleteRegistryEntry (m_szName);

        if (dwRet != ERROR_SUCCESS) {
            SetLastError (dwRet);
            bRet = FALSE;
        }

        return bRet;
    }


    DWORD	StartDoc    (const  LPTSTR psztPrinterName,
                         const  DWORD  jobId,
                         const  DWORD  level,
                         const  LPBYTE pDocInfo );
    DWORD	Write       (LPBYTE	 pBuffer,
                         DWORD	 cbBuf,
                         LPDWORD pcbWritten);
    DWORD   EndDoc();
    DWORD   GetInfo(DWORD   level,	
                    LPBYTE  &pPortBuf,
                    LPTCH  &pEnd);	
    DWORD   GetInfoSize	(DWORD level);
    DWORD   SetRegistryEntry(LPCTSTR psztPortName,
							 const  DWORD   dwProtocol,
                             const  DWORD   dwVersion,
                             const  LPBYTE pData );

	DWORD	DeleteRegistryEntry( LPTSTR psztPortName );

    DWORD   InitConfigPortUI(const  DWORD	dwProtocolType,
                             const  DWORD	dwVersion,
                                    LPBYTE  pConfigPortData);

    DWORD   SetDeviceStatus( );
    DWORD   ClearDeviceStatus();

    DWORD GetSNMPInfo(PSNMP_INFO pSnmpInfo);

    LPCTSTR	GetName();

    BOOL	ValidateRealPort();
    BOOL    Valid() { return m_bValid; }

    time_t  NextUpdateTime();

    BOOL    m_bDeleted;

    BOOL    m_bUsed;

    ~CPort();
private:	// methods
	DWORD	InitPortSem();
	BOOL	EndPortSem();
	DWORD	SetRealPortSem();
	DWORD	UnSetRealPortSem();
	DWORD	LockRealPort();
	DWORD	UnlockRealPort();
	

private:	// attributes
	TCHAR		m_szName[MAX_PORTNAME_LEN+1];			// port name
    BOOL        m_bValid;
    DWORD		m_dwProtocolType;		// indicates what type of printing protocol
    DWORD		m_dwVersion;			// version of the data being passed in to create the port

    CPortMgr	*m_pParent;			// points to the PortMgr object
    CPortRefABC	*m_pRealPort;		// points to the actual port object
	CRegABC		*m_pRegistry;		// points to the registry object

    PORTSTATE	m_iState;			// port state
    DWORD		m_dwLastError;		

	HANDLE		m_hPortSync;
};

#endif // INC_PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\mglist.h ===
#ifndef _MANAGED_LIST
#define _MANAGED_LIST

/***************************************************************************************

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mglist.h

Abstract:

    Managed List Class

Author:

    Weihai Chen  (WeihaiC) 04/10/00

Revision History:


The purpose of several classes in this file is to convert traditional a list
data-structure without reference count into a robust multithread data structure.
There are many port monitors / providers uses link list as a data structure.
However, since there are not reference count for the individual node, it is very
hard to controll the life time of the node.


TRefCount:

    TRefCount is a class used to keep track of the ref count of a class.
    When the refcount becomes zero, it deletes itself.

TRefNodeABC - TRefCount

    TRefNodeABC is an abstract class to keep track of the lifetime of a node in
    a double linked list.

    It uses TRefCount to keep track of the referece count. It uses a pending-deletion
    state to tell if the node is being deleted. The opereation "Delete" marks the node
    as pending-deletion node after it calls "PartialDelete" function to delete all
    the persistent storage of the node. This is to make sure that no conflict occurs
    when you create a new node with the same name while the old node is not deleted.

    This class has a tight relationship to TManagedList. When users add a new node
    to TManagedList, TMangedClass calls  SetContextPtr () to set the critical section
    pointer and double link list. The double link list is used to delete the Node when
    the refcount becomes 0

TMangedList - TRefCount

    TManagedList is use to manage a double link list in a multi-threading environemnt.
    The code is designed so that clients do not have to enter critical section for
    any operations. This class has an internal critical section to serialize operations.


TEnumManagedList - TRefCount

    TEnumManagedList is an iterator for TMangedList. The iterator will go through
    all the non-pending deletion node in the list without holding the critical section.

***************************************************************************************/

class TRefCount
{
public:
    TRefCount ():m_cRef(1) {};
    virtual ~TRefCount () {
        DBGMSG (DBG_TRACE, ("TRefCount deleted\n"));
    };

    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("+Ref (%d)\n", m_cRef));
        return InterlockedIncrement(&m_cRef) ;
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("-Ref (%d)\n", m_cRef));
        if (InterlockedDecrement(&m_cRef) == 0) {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }
private:
    LONG m_cRef;
};

template <class T, class KEYTYPE> class TRefNodeABC:
    public TRefCount
{
public:
    TRefNodeABC ():
        m_pCritSec  (NULL),
        m_bPendingDeletion (FALSE) {};

    virtual ~TRefNodeABC () {
        DBGMSG (DBG_TRACE, ("TRefNodeABC deleted\n"));
    };

    virtual DWORD
    DecRef () {
        DWORD dwRef;

        if (m_pCritSec) {
            TAutoCriticalSection CritSec (*m_pCritSec);
            if (CritSec.bValid ()) {

                dwRef = TRefCount::DecRef();

                if (m_bPendingDeletion && dwRef == 1) {
                    // Delete

                    DBGMSG (DBG_TRACE, ("Deleting this node\n"));
                    m_pList->DeleteNode(m_pThisNode);
                    //
                    // Delete this pointer
                    //
                    TRefCount::DecRef();
                }
            }
        }
        else
            dwRef = TRefCount::DecRef();

        return dwRef;
    };

    VOID SetContextPtr (
        TCriticalSection *pCritSec,
        TSrchDoubleList<T, KEYTYPE> * pList,
        TDoubleNode <T, KEYTYPE> *pThisNode) {
            m_pCritSec = pCritSec;
            m_pList = pList;
            m_pThisNode = pThisNode;
    };

    BOOL Delete () {
        BOOL bRet = FALSE;

        if (m_pCritSec) {
            TAutoCriticalSection CritSec (*m_pCritSec);

            if (CritSec.bValid ()) {

                if (PartialDelete ()) {
                    m_bPendingDeletion = TRUE;
                    bRet = TRUE;
                }
            }
        }
        return bRet;
    };

    // This function is to delete all the persistent storage related to the node, such as
    // registry settings etc.
    //

    virtual BOOL
    PartialDelete (VOID) = 0;

    // Return whether the node is in the pending deletion state
    //

    inline BOOL
    IsPendingDeletion (BOOL &refPending)  CONST {
        BOOL bRet = FALSE;

        TAutoCriticalSection CritSec (*m_pCritSec);

        if (CritSec.bValid ()) {

            refPending = m_bPendingDeletion;
            bRet = TRUE;
        };
        return bRet;
    };

private:
    BOOL m_bPendingDeletion;
    TCriticalSection *m_pCritSec;
    TSrchDoubleList<T, KEYTYPE> * m_pList;
    TDoubleNode <T, KEYTYPE> *m_pThisNode;
};

template <class T, class KEYTYPE> class TManagedList;


template <class T, class KEYTYPE> class TEnumManagedList:
    public TRefCount
{
public:

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("TEnumManagedList"));
        return TRefCount::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("TEnumManagedList"));
        return TRefCount::DecRef();
    }
#endif

    BOOL bValid (VOID) CONST { return TRUE;};
    TEnumManagedList (
        TManagedList<T, KEYTYPE> *pList,
        TSrchDoubleList<T, KEYTYPE> *pSrchList);
    ~TEnumManagedList ();
    BOOL Next (T *ppItem);
    VOID Reset ();
private:
    TDoubleNode <T, KEYTYPE> *m_pCurrent;
    TManagedList<T, KEYTYPE> *m_pList;
    TSrchDoubleList<T, KEYTYPE> * m_pSrchList;
};


template <class T, class KEYTYPE> class TManagedList:
    public TRefCount
{
public:

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("TManagedList"));
        return TRefCount::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("TManagedList"));
        return TRefCount::DecRef();
    }
#endif

    TManagedList ();
    virtual ~TManagedList ();

    BOOL
    AppendItem (
        T &item);

    BOOL
    FindItem (
        CONST KEYTYPE t,
        T &refItem);

    BOOL
    FindItem (
        CONST T &t,
        T &refItem);

    BOOL
    NewEnum (
        TEnumManagedList<T, KEYTYPE> **ppIterator);

    BOOL
    Lock () {
        return m_CritSec.Lock ();
    } ;

    BOOL
    Unlock () {
        return m_CritSec.Unlock ();
    };

    TCriticalSection*
    GetCS(
        VOID) CONST {
        return (TCriticalSection*) &m_CritSec;
    };

    inline BOOL
    bValid () CONST {
        return m_bValid;
    }

private:
    BOOL m_bValid;

    TSrchDoubleList<T, KEYTYPE> * m_pList;
    TCriticalSection m_CritSec;

};

#include "mglist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portabc.h ===
/*****************************************************************************
 *
 * $Workfile: portabc.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_PORTABC_H
#define INC_PORTABC_H

#ifndef	DllExport
#define	DllExport	__declspec(dllexport)
#endif

#include "devabc.h"
#include "regabc.h"

class DllExport CPortABC			
{
public:
	CPortABC() { };
	virtual	~CPortABC() { };

	virtual	DWORD	StartDoc	( const LPTSTR psztPrinterName,
								  const DWORD  jobId,
								  const DWORD  level,
								  const LPBYTE pDocInfo ) = 0;

	virtual DWORD	Read		( const HANDLE  handle,
								  LPBYTE  pBuffer,
							      const DWORD   cbBuffer,
								  LPDWORD pcbRead) {  return ( ERROR_INVALID_PARAMETER ); }

	virtual	DWORD	Write		( LPBYTE	 pBuffer,
								  DWORD	 cbBuf,
								  LPDWORD pcbWritten) = 0;
	virtual	DWORD	EndDoc() = 0;
	virtual LPCTSTR	GetName() = 0;
	virtual	DWORD	SetRegistryEntry( LPCTSTR		psztPortName,
									  const DWORD	dwProtocol,
									  const DWORD	dwVersion,
									  const LPBYTE  pData) = 0;
	virtual DWORD	InitConfigPortUI( const DWORD	dwProtocolType,
									  const DWORD	dwVersion,
									  LPBYTE		pConfigPortData) = 0;

	virtual DWORD	GetSNMPInfo( PSNMP_INFO pSnmpInfo) = 0;

	virtual DWORD	SetDeviceStatus( ) = 0;

    virtual DWORD   ClearDeviceStatus() = 0;

    virtual time_t  NextUpdateTime() = 0;
private:

};


#endif	// INC_PORTABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\mglist.inl ===
template <class T, class KEYTYPE>
TManagedList<T, KEYTYPE>::TManagedList<T, KEYTYPE>(void):
    m_bValid (FALSE), m_pList (NULL)
{
    if (m_CritSec.bValid ()) {
        m_pList = new TSrchDoubleList<T, KEYTYPE>;

        if (m_pList) {
            if (m_pList->bValid ()) {
                m_bValid = TRUE;
            }
            else  {
                delete m_pList;
                m_pList = NULL;
            }
        }
    }
}

template <class T, class KEYTYPE>
TManagedList<T, KEYTYPE>::~TManagedList<T, KEYTYPE>(void)
{
    DBGMSG (DBG_TRACE, ("TManagedList deleted\n"));
    if (m_pList) {
        delete m_pList;
    }
}


template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::AppendItem (T &item)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {

        TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);

        if (pNewNode) {
            if (m_pList->AppendNode (pNewNode)) {
                item->SetContextPtr (&m_CritSec, m_pList, pNewNode);
                bRet = TRUE;
            }
        }
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::FindItem (
    CONST KEYTYPE t, T&refItem)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {
        if (refItem = m_pList->FindItemFromKey (t)) {

            refItem->IncRef ();

            bRet = TRUE;
        }
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::FindItem (
    CONST T &t,
    T &refItem)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {
        if (refItem = m_pList->FindItemFromItem (t)) {

            refItem->IncRef ();

            bRet = TRUE;
        }
    }
    return bRet;
}



template <class T, class KEYTYPE>
BOOL
TManagedList<T, KEYTYPE>::NewEnum (TEnumManagedList<T, KEYTYPE> **ppIterator)
{
    BOOL bRet = FALSE;

    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ()) {

        TEnumManagedList<T, KEYTYPE> *pItem
            = new TEnumManagedList<T, KEYTYPE> (this, m_pList);

        if (pItem) {
            if (pItem->bValid ()) {
                *ppIterator = pItem;
                bRet = TRUE;
            }
            else
                delete pItem;
        }
    }
    return bRet;
}


template <class T, class KEYTYPE>
TEnumManagedList<T, KEYTYPE>::TEnumManagedList<T, KEYTYPE> (
    TManagedList<T, KEYTYPE> *pList,
    TSrchDoubleList<T, KEYTYPE> *pSrchList):
    m_pList (pList),
    m_pCurrent (NULL),
    m_pSrchList (pSrchList)
{
    m_pList->IncRef ();
}

template <class T, class KEYTYPE>
TEnumManagedList<T, KEYTYPE>::~TEnumManagedList<T, KEYTYPE> ()
{
    T pItem;

    if (m_pList->Lock ()) {
        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->DecRef ();
        }
        m_pList->Unlock ();
    }
    m_pList->DecRef ();

    DBGMSG (DBG_TRACE, ("TEnumManagedList deleted\n"));
}

template <class T, class KEYTYPE>
BOOL
TEnumManagedList<T, KEYTYPE>::Next (T *ppItem)
{

    T pItem;
    BOOL bRet = FALSE;
    BOOL bDel;
    TDoubleNode <T, KEYTYPE> * pTmp;
    TDoubleNode <T, KEYTYPE> * pOld;

    TAutoCriticalSection CritSec (*m_pList->GetCS());

    if (CritSec.bValid ()) {

        if (!m_pCurrent) {
            // First call
            if (m_pCurrent = m_pSrchList->GetHead ()) {
                pItem = m_pCurrent->GetData ();
                pItem->IncRef ();


                if (pItem->IsPendingDeletion (bDel) && !bDel) {
                    pItem ->IncRef ();
                    *ppItem = pItem;

                    return TRUE;
                }
            }
            else {
                // There is no element
                return FALSE;
            }
        }

        pOld = m_pCurrent;
        pTmp = m_pCurrent;

        while (pTmp = pTmp->GetNext ()) {

            pItem = pTmp->GetData ();

            if (pItem->IsPendingDeletion (bDel) && !bDel) {
                pItem->IncRef ();
                *ppItem = pItem;
                bRet = TRUE;
                break;
            }
        }

        m_pCurrent = pTmp;
        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->IncRef ();
        }

        if (pOld) {
            pItem = pOld->GetData ();
            pItem->DecRef ();
        }

    }
    return bRet;
}


template <class T, class KEYTYPE>
VOID
TEnumManagedList<T, KEYTYPE>:: Reset ()
{
    TAutoCriticalSection CritSec (*m_pList->GetCS());
    T pItem;

    if (CritSec.bValid ()) {

        if (m_pCurrent) {
            pItem = m_pCurrent->GetData ();
            pItem->DecRef ();
        }
        m_pCurrent = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portmgr.h ===
/*****************************************************************************
 *
 * $Workfile: PortMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_PORTMGR_H
#define INC_PORTMGR_H

typedef int (CALLBACK *ADDPARAM)(HWND);
typedef int (CALLBACK *CONFIGPARAM)(HWND, PPORT_DATA_1);

#include "port.h"

typedef TManagedList<PCPORT, LPTSTR> TManagedListImp;
typedef TEnumManagedList<PCPORT, LPTSTR> TEnumManagedListImp;

class CMemoryDebug;
class CPort;
class CPortMgr;
class CDeviceStatus;

#define MAX_SUPPORTED_LEVEL     2   // maximum supported level


// A pointer to this structure is passed back as a port handle to
// the spooler during an OpenPort.  Subsequent WritePort, ...
// calls from the spooler pass back this handle/pointer.
// The dSignature is used to ensure the handle is a valid one
// that this monitor created.  The pPort points to a CPort
// object in our list of ports.
//
//  marks port structures as an HP port structure
//
#define     HPPORT_SIGNATURE        (0x504F5254)
typedef struct _HPPORT {
    DWORD       cb;
    DWORD       dSignature;
    ACCESS_MASK grantedAccess;
    CPort       *pPort;
    CPortMgr    *pPortMgr;
} HPPORT, *PHPPORT;

class CPortMgr
#if defined _DEBUG || defined DEBUG
    : public CMemoryDebug
#endif
{
    // methods
public:
    CPortMgr();
    ~CPortMgr();

    DWORD   InitializeMonitor ();

    DWORD   InitializeRegistry(HANDLE hcKey,
                               HANDLE hSpooler,
                               PMONITORREG  pMonitorReg,
                               LPCTSTR psztServerName );

    DWORD   OpenPort        (LPCTSTR    psztPName,
                             PHANDLE    pHandle);
    DWORD   OpenPort        (PHANDLE    phXcv );
    DWORD   ClosePort       (const HANDLE   handle);
    DWORD   StartDocPort    (const HANDLE   handle,
                             const LPTSTR   psztPrinterName,
                             const DWORD    jobId,
                             const DWORD    level,
                             const LPBYTE   pDocInfo);
    DWORD   WritePort       (const HANDLE  handle,
                              LPBYTE  pBuffer,
                              DWORD   cbBuf,
                              LPDWORD pcbWritten);
    DWORD   ReadPort        ( const HANDLE  handle,
                                    LPBYTE  pBuffer,
                              const DWORD   cbBuffer,
                                    LPDWORD pcbRead);
    DWORD   EndDocPort      ( const HANDLE  handle);
    DWORD   DeletePort      ( const LPTSTR  psztPortName);
    DWORD   EnumPorts       ( const LPTSTR  psztName,
                              const DWORD   level,
                              const LPBYTE  pPorts,
                                    DWORD   cbBuf,
                                    LPDWORD pcbNeeded,
                                    LPDWORD pcReturned);
    DWORD ConfigPortUIEx( LPBYTE pData );

    DWORD XcvOpenPort( LPCTSTR      pszObject,
                       ACCESS_MASK  GrantedAccess,
                       PHANDLE      phXcv);
    DWORD XcvClosePort( HANDLE  hXcv );
    DWORD XcvDataPort(HANDLE        hXcv,
                      PCWSTR        pszDataName,
                      PBYTE     pInputData,
                      DWORD     cbInputData,
                      PBYTE     pOutputData,
                      DWORD     cbOutputData,
                      PDWORD        pcbOutputNeeded);

    VOID    EnterCSection();
    VOID    ExitCSection();

    DWORD   GetStatusUpdateInterval() { return m_dStatusUpdateInterval; }
    BOOL    IsStatusUpdateEnabled() { return m_bStatusUpdateEnabled; }

    DWORD   CreatePortObj( const LPTSTR psztPortName,       // port name
                           const DWORD  dwProtocolType,     // protocol type
                           const DWORD  dwVersion);         // version number

    DWORD   UpdatePortEntry( LPCTSTR    psztPortName);

    VOID    InitMonitor2( LPMONITOR2    *ppMonitor);

    inline LPCTSTR GetServerName(void) const;       // Some of our port calls need the server
                                                    // name and hence have to be passed the
                                                    // port manager object

    inline BOOL bValid(VOID) CONST { return m_bValid;};

    // instance methods
private:

    DWORD CreatePortObj( LPCTSTR psztPortName,      // port name
                           const DWORD   dwPortType,        // port number
                           const DWORD   dwVersion,         // version number
                           const LPBYTE  pData);            // data

    DWORD   CreatePort( const DWORD     dwProtocolType,
                        const DWORD     dwVersion,
                        LPCTSTR         psztPortName,
                        const LPBYTE    pData);

    DWORD   ValidateHandle( const HANDLE handle,
                                  CPort  **ppPort);
    DWORD   EncodeHandle( PHANDLE   pHandle );
    CPort*  FindPort ( LPCTSTR psztPortName);
    BOOL    FindPort ( CPort  *pNewPort);
    DWORD   PortExists( LPCTSTR psztPortName);
    DWORD   GetEnumPortsBuffer( const DWORD   level,
                                      LPBYTE  pPorts,
                                const DWORD   bBuf,
                                      LPDWORD pcbNeeded,
                                      LPDWORD pcReturned);
    DWORD   EnumSystemProtocols( void );
    DWORD   EnumSystemPorts    ( void );
    DWORD   InitConfigPortStruct(PPORT_DATA_1 pConfigPortData,
                                 CPort              *pPort);
    DWORD   AddPortToList(CPort *pPort);

    DWORD   EncodeHandle( CPort *pPort,
                         PHANDLE phXcv);

    DWORD   FreeHandle( HANDLE hXcv );

    BOOL    HasAdminAccess( HANDLE hXcv );
    // attributes
    static void EndPortData1Strings(PPORT_DATA_1 pPortData);
    static void EndDeletePortData1Strings(PDELETE_PORT_DATA_1 pDeleteData);
    static inline void EndConfigInfoData1Strings(PCONFIG_INFO_DATA_1 pConfigData);

public:
    DWORD
    GetLprAckTimeout (
        VOID
        ) const;

private:
    VOID
    InitializeLprAckTimeout (
        VOID
        );


 protected:
    friend CDeviceStatus;

    TManagedListImp *m_pPortList;

private:
    static  CONST   DWORD   cdwMaxXcvDataNameLen;

    BOOL                m_bValid;

    MONITOREX           m_monitorEx;        // monitor ex structure
    MONITOR2            m_monitor2;
    CRITICAL_SECTION    m_critSect;

    DWORD               m_dStatusUpdateInterval;
    BOOL                m_bStatusUpdateEnabled;
    CRegABC            *m_pRegistry;       // pointers to the needed objects
    TCHAR               m_szServerName[MAX_PATH];

    DWORD               m_dwLprAckTimeout;
    static DWORD const  s_dwDefaultLprAckTimeout;
    static WCHAR        s_szLprAckTimeoutRegVal [];
};

/////////////////////////////////////////////////////////////////////////////////////////////
// INLINE METHODS
/////////////////////////////////////////////////////////////////////////////////////////////
inline LPCTSTR CPortMgr::GetServerName(void) const {
    return m_szServerName;
}

inline void CPortMgr::EndConfigInfoData1Strings(PCONFIG_INFO_DATA_1 pConfigData) {
    pConfigData->sztPortName[MAX_PORTNAME_LEN-1] = NULL;
}

#endif // INC_PORTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portmgr.cpp ===
/****************************************************************************
 *
 * $Workfile: PortMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "port.h"
#include "devstat.h"
#include "portmgr.h"
#include "cluster.h"

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

CONST DWORD CPortMgr::cdwMaxXcvDataNameLen = 64;
DWORD const CPortMgr::s_dwDefaultLprAckTimeout = 180;//sec
WCHAR CPortMgr::s_szLprAckTimeoutRegVal [] = L"LprAckTimeout";

///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::CPortMgr()
//      Performs any needed initialization for the Port Manager

CPortMgr::
CPortMgr(
    VOID) :
    m_bValid (FALSE),
    m_bStatusUpdateEnabled( DEFAULT_STATUSUPDATE_ENABLED ),
    m_dStatusUpdateInterval( DEFAULT_STATUSUPDATE_INTERVAL ),
    m_dwLprAckTimeout (s_dwDefaultLprAckTimeout),
    m_pPortList(NULL)

{
    //
    // initialize member variables
    //
    *m_szServerName = TEXT('\0');
    memset(&m_monitorEx, 0, sizeof(m_monitorEx));

    CDeviceStatus::gDeviceStatus().RegisterPortMgr(this);

    if (m_pPortList = new TManagedListImp ()) {
        m_bValid = m_pPortList-> bValid ();
    }

}   // ::CPortMgr()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::~CPortMgr()
//      Performs the necessary clean up for the Port Manager

CPortMgr::
~CPortMgr(
    VOID
    )
{
    CDeviceStatus::gDeviceStatus().UnregisterPortMgr(this);

    if (m_pPortList) {
        m_pPortList->DecRef ();
    }

}   // ::~CPortMgr()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::InitializeMonitor()
//      Initializes the Port Manager:
//              1. Check for TCP/IP support
//              2. Initialize CRegistry and fill in LPMONITOREX structure
//              4. Enumerate installed ports
//              5. Start up a thread for the printer status object
//      Error codes:
//          ERROR_INVALID_PARAMETER if pMonitorEx is NULL
//          ERROR_NOT_SUPPORTED if TCP/IP not installed in the system -- FIX!

DWORD
CPortMgr::
InitializeMonitor(
//    IN      LPTSTR          psztRegisterRoot,
//    IN OUT  LPMONITOREX    *ppMonitorEx
    )
{
    DWORD   dwRetCode = NO_ERROR;
    OSVERSIONINFO   osVersionInfo;

//    if ( !ppMonitorEx   || !psztRegisterRoot )
//        return ERROR_INVALID_PARAMETER;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetVersionEx(&osVersionInfo) )
        return GetLastError();

    //
    // Check for TCP/IP support
    //
    if ( dwRetCode = EnumSystemProtocols() )
        return dwRetCode;

    //
    // Enumerate the installed ports
    //
    if ( dwRetCode = EnumSystemPorts() )
        return dwRetCode;

    return ERROR_SUCCESS;

}   // ::Initialize()


DWORD
CPortMgr::
InitializeRegistry(
    IN HANDLE hcKey,
    IN HANDLE hSpooler,
    IN PMONITORREG  pMonitorReg,
    IN LPCTSTR  pszServerName
    )
{
    DWORD dwRetCode = NO_ERROR;

    m_pRegistry = new CCluster(hcKey, hSpooler, pMonitorReg);
    if ( !m_pRegistry ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }
    //
    // Initialize m_dwLprAckTimeout from the registry.
    //
    InitializeLprAckTimeout ();
    //
    // If this call fails, m_dwLprAckTimeout still has default value
    // equal to s_dwDefaultLprAckTimeoutin.
    //
    // get the registry settings
    //
    if ( m_pRegistry->GetPortMgrSettings(&m_dStatusUpdateInterval,
                                         &m_bStatusUpdateEnabled) != NO_ERROR )
    {
        m_dStatusUpdateInterval = DEFAULT_STATUSUPDATE_INTERVAL;
        m_bStatusUpdateEnabled = DEFAULT_STATUSUPDATE_ENABLED;
    }
    if( pszServerName != NULL )
    {
        lstrcpyn( m_szServerName, pszServerName, SIZEOF_IN_CHAR( m_szServerName));
    }

    return ERROR_SUCCESS;

}   // ::InitializeRegistry()


///////////////////////////////////////////////////////////////////////////////
//  CPortMgr::InitMonitor()
//      Initializes the MONITOREX strucutre

void
CPortMgr::
InitMonitor2(
        IN OUT LPMONITOR2   *ppMonitor2
    )
{
    memset( &m_monitor2, '\0', sizeof( MONITOR2 ) );

    m_monitor2.cbSize = sizeof(MONITOR2);

    m_monitor2.pfnEnumPorts     = ::ClusterEnumPorts;   // functions are in the global space
    m_monitor2.pfnOpenPort      = ::ClusterOpenPort;
    m_monitor2.pfnOpenPortEx    = NULL;
    m_monitor2.pfnStartDocPort  = ::StartDocPort;
    m_monitor2.pfnWritePort     = ::WritePort;
    m_monitor2.pfnReadPort      = ::ReadPort;
    m_monitor2.pfnEndDocPort    = ::EndDocPort;
    m_monitor2.pfnClosePort     = ::ClosePort;
    m_monitor2.pfnAddPort       = NULL;
    m_monitor2.pfnAddPortEx     = NULL;
    m_monitor2.pfnConfigurePort = NULL;
    m_monitor2.pfnDeletePort    = NULL;
    m_monitor2.pfnGetPrinterDataFromPort = NULL;
    m_monitor2.pfnSetPortTimeOuts = NULL;
    m_monitor2.pfnXcvOpenPort   = ::ClusterXcvOpenPort;
    m_monitor2.pfnXcvDataPort   = ::XcvDataPort;
    m_monitor2.pfnXcvClosePort  = ::XcvClosePort;
    m_monitor2.pfnShutdown      = ::ClusterShutdown;

    *ppMonitor2 = &m_monitor2;

}   // ::InitMonitor2()


///////////////////////////////////////////////////////////////////////////////
//  OpenPort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_PARAMETER if port object doesn't exist
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//          ERROR_INVALID_HANDLE if pPort is null

DWORD
CPortMgr::
OpenPort(
    IN      LPCTSTR     psztPName,
    IN OUT  PHANDLE     pHandle
    )
{
    DWORD   dwRet = ERROR_INVALID_PARAMETER;

    //
    // Get a handle to the port object and get the port handle
    //
    CPort   *pPort = FindPort(psztPName);

    if ( pPort ) {

        dwRet = EncodeHandle(pPort, pHandle);

        //
        // Start the device status update thread if it is not already started:
        //
        if ( dwRet == ERROR_SUCCESS && m_bStatusUpdateEnabled == TRUE )
            CDeviceStatus::gDeviceStatus().RunThread();
    }

    return dwRet;
}   // ::OpenPort()


///////////////////////////////////////////////////////////////////////////////
//  OpenPort -- used for the remote OpenPort calls
//  Error codes:
//      NO_ERROR if success
//      ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
CPortMgr::
OpenPort(
    OUT PHANDLE phXcv
    )
{
    //
    // Create Dummy Handle for add port
    //
    return EncodeHandle(NULL, phXcv);

}   // ::OpenPort()


///////////////////////////////////////////////////////////////////////////////
//  ClosePort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid

DWORD
CPortMgr::
ClosePort(
    IN  HANDLE handle
    )
{
    DWORD dwRetCode = NO_ERROR;
    CPort *pPort = NULL;

    //
    // Validate the handle before freeing it
    //
    if ( (dwRetCode = ValidateHandle(handle, &pPort)) == ERROR_SUCCESS ) {
        if (pPort)
            pPort->DecRef ();

        dwRetCode = FreeHandle(handle);
    }

    return dwRetCode;

}   // ::ClosePort()


///////////////////////////////////////////////////////////////////////////////
//  StartDocPort --
//  Error codes:
//      NO_ERROR if success
//      ERROR_INVALID_HANDLE if handle is invalid
//      ERROR_INVALID_PARAMETER if a passed parameter is invalid
//      ERROR_BUSY if the requested port is already busy
//      ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//      ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CPortMgr::
StartDocPort(
    IN  HANDLE      handle,
    IN  LPTSTR      psztPrinterName,
    IN  DWORD       jobId,
    IN  DWORD       level,
    IN  LPBYTE      pDocInfo
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    //
    // Validate the handle
    //
    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;


    if ( !pPort || !psztPrinterName || !pDocInfo )
        return ERROR_INVALID_PARAMETER;

    return pPort->StartDoc(psztPrinterName, jobId, level,
                           pDocInfo);
}   // ::StartDocPort()


///////////////////////////////////////////////////////////////////////////////
//  WritePort
//      Error codes:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid
//          ERROR_INVALID_PARAMETER if a passed parameter is invalid

DWORD
CPortMgr::
WritePort(
    IN      HANDLE      handle,
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;

    if ( !pPort || !pBuffer || !pcbWritten )
        return ERROR_INVALID_PARAMETER;;

    return pPort->Write(pBuffer, cbBuf, pcbWritten);
}   // ::WritePort()


///////////////////////////////////////////////////////////////////////////////
//  ReadPort -- Not supported
//      Return code:
//          NO_ERROR if success
//      FIX: should this return ERROR_NOT_SUPPORTED??

DWORD
CPortMgr::
ReadPort(
    IN      HANDLE  handle,
    IN OUT  LPBYTE  pBuffer,
    IN      DWORD   cbBuffer,
    IN OUT  LPDWORD pcbRead
    )
{
    return ERROR_NOT_SUPPORTED;
}   // ::ReadPort()


///////////////////////////////////////////////////////////////////////////////
//  EndDocPort
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_HANDLE if handle is invalid
//          ERROR_INVALID_PARAMETER if port object is invalid

DWORD
CPortMgr::
EndDocPort(
    IN  HANDLE  handle
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CPort   *pPort = NULL;

    if ( dwRetCode = ValidateHandle(handle, &pPort) )
        return dwRetCode;

    return pPort ? pPort->EndDoc() : ERROR_INVALID_PARAMETER;
}   // ::EndDocPort()


///////////////////////////////////////////////////////////////////////////////
//  EnumPorts
//      Enumerates the ports using the port list structure kept in the memory
//      If the buffer size needed is not enough, it will return the buffer
//      size needed.
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_LEVEL if level is not supported
//          ERROR_INSUFFICIENT_BUFFER if buffer size is small
//          ERROR_INVALID_HANDLE if the passed in pointers are invalid

DWORD
CPortMgr::
EnumPorts(
    IN      LPTSTR  psztName,
    IN      DWORD   level,          // 1/2(PORT_INFO_1/2)
    IN OUT  LPBYTE  pPorts,         // port data is written to
    IN OUT  DWORD   cbBuf,          // buffer size of pPorts points to
    IN OUT  LPDWORD pcbNeeded,      // needed buffer size
    IN OUT  LPDWORD pcReturned      // number of structs written to pPorts
    )
{
    DWORD   dwRetCode = NO_ERROR;
    LPBYTE  pPortsBuf = pPorts;
    LPTCH   pEnd = (LPTCH) (pPorts + cbBuf);    // points to the end of the buffer

    if ( pcbNeeded == NULL || pcReturned == NULL )
        return ERROR_INVALID_PARAMETER;

    *pcbNeeded  = 0;
    *pcReturned = 0;

    if ( level > SPOOLER_SUPPORTED_LEVEL )
        return ERROR_INVALID_LEVEL;

    CPort *pPort;

    if (m_pPortList->Lock ()) {
        // We don't need to enter critical section to enumerate port since the portlist itself
        // is protected by the same critical section, but it is easier.

        TEnumManagedListImp *pEnum;
        if (m_pPortList->NewEnum (&pEnum)) {

            BOOL bRet = TRUE;

            while (bRet) {

                bRet = pEnum->Next (&pPort);
                if (bRet) {
                    *pcbNeeded += pPort->GetInfoSize(level);
                    pPort->DecRef ();
                }
            }


            if ( cbBuf >= *pcbNeeded ) {

                pEnum->Reset ();

                //
                // fill in the actual buffer
                //
                bRet = TRUE;
                while (bRet) {
                    bRet = pEnum->Next (&pPort);
                    if (bRet) {
                        *pcbNeeded += pPort->GetInfo(level, pPortsBuf, pEnd);
                        (*pcReturned)++;
                        pPort->DecRef ();
                    }
                }

            }
            else {
                dwRetCode = ERROR_INSUFFICIENT_BUFFER;
            }

            pEnum->DecRef ();
        }
        else
            dwRetCode = GetLastError ();
    }
    m_pPortList->Unlock ();


    return dwRetCode;
}   // ::EnumPorts()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortStruct
//
//  Purpose: To initialize a structure to hand to the User Interface so
//      the user can configure the port information.
//
//  Arguments: A pointer to the structure to be filled.
//
DWORD
CPortMgr::
InitConfigPortStruct(
    OUT PPORT_DATA_1    pConfigPortData,
    IN  CPort          *pPort
    )
{
    DWORD   dwProtocolType = PROTOCOL_RAWTCP_TYPE;
    DWORD   dwVersion   = PROTOCOL_RAWTCP_VERSION, dwRet;

    //
    // initialize the structure needed to communicate w/ the UI
    //
    memset(pConfigPortData, 0, sizeof(PORT_DATA_1));

    pConfigPortData->cbSize = sizeof(PORT_DATA_1);

    //pConfigPortData->dwCoreUIVersion = 0;

    dwRet = pPort->InitConfigPortUI(
                          dwProtocolType,
                          dwVersion,
                          (LPBYTE)pConfigPortData);


    return dwRet;

} // InitConfigPortStruct

///////////////////////////////////////////////////////////////////////////////
//  ConfigPortUIEx
//      Return code:
//          NO_ERROR if success
//      FIX: error codes
//      This function is called by the ui when information has been changed
//      on the device configuration page, or in an extension dll config page.

DWORD
CPortMgr::
ConfigPortUIEx(
    LPBYTE pData
    )
{
    DWORD dwRetCode = NO_ERROR;
    PPORT_DATA_1 pPortData = (PPORT_DATA_1)pData;
    CPort *pPort;

    EndPortData1Strings(pPortData);

    if( _tcscmp( pPortData->sztPortName, TEXT("") )) {
        pPort = FindPort(pPortData->sztPortName);
        if ( pPort ==  NULL )
            return ERROR_INVALID_PARAMETER;

        dwRetCode = pPort->Configure(pPortData->dwProtocol,
                                pPortData->dwVersion,
                                pPortData->sztPortName,
                                (LPBYTE)pData);
    }

    return dwRetCode;
} // ConfigPortUIEx

///////////////////////////////////////////////////////////////////////////////
//  DeletePort
//      Return code:
//          NO_ERROR if success
//          ERROR_INVALID_PARAMETER if a passed parameter is invalid
//          ERROR_KEY_DELETED   if error deleting the registry entry

DWORD
CPortMgr::
DeletePort(
    IN  LPTSTR  psztPortName
    )
{
    DWORD       dwRetCode = NO_ERROR;
    BOOL        bFound = FALSE;

    CPort *pPort;

    if (m_pPortList->FindItem (psztPortName, pPort)) {

        bFound = TRUE;

        if (!pPort->Delete()) {
            if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                dwRetCode = ERROR_KEY_DELETED;
        }
        pPort-> DecRef ();
    }

    return bFound ? dwRetCode : ERROR_UNKNOWN_PORT;
}   // ::DeletePort()


DWORD
CPortMgr::
AddPortToList(
    CPort *pPort
    )
{

    if (m_pPortList->AppendItem (pPort)) {
        return ERROR_SUCCESS;
    }
    else {
        pPort->Delete();
        return ERROR_OUTOFMEMORY;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  CreatePortObj -- creates the port obj & adds it to the end of the port list
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePortObj(
    IN  LPCTSTR     psztPortName,       // port name
    IN  DWORD       dwPortType,         // port to be add; (rawTCP, lpr, etc.)
    IN  DWORD       dwVersion,          // level/version number of the data
    IN  LPBYTE      pData               // data being passed in
    )               // data being passed in
{
    CPort      *pPort = NULL;
    DWORD       dwRetCode = NO_ERROR;

    //
    // Is there port with this name already present?
    //
    if ( pPort =  FindPort(psztPortName) ) {
        pPort->DecRef ();
        return ERROR_INVALID_PARAMETER;
    }


    if ( !(pPort = new CPort(dwPortType, dwVersion, pData,
                             this, m_pRegistry)) ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }

    if ( !pPort->ValidateRealPort() ) {

        pPort->Delete();

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;

        return dwRetCode;
    }

    if ( dwRetCode = AddPortToList(pPort) )
        return dwRetCode;

    return ERROR_SUCCESS;
}   // ::CreatePortObj()


///////////////////////////////////////////////////////////////////////////////
//  CreatePortObj -- creates the port obj & adds it to the end of the port list
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePortObj(
    IN  LPTSTR      psztPortName,   // port name
    IN  DWORD       dwProtocolType, // port to be add; (rawTCP, lpr, etc.)
    IN  DWORD       dwVersion       // level/version number of the data
    )
{
    CPort   *pPort = NULL;
    DWORD   dwRetCode = NO_ERROR;

    if ( !(pPort = new CPort(psztPortName, dwProtocolType, dwVersion,
                             this, m_pRegistry)) ) {

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }


    if ( !pPort->ValidateRealPort() ) {

        pPort->Delete ();

        if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
            dwRetCode = STG_E_UNKNOWN;
        return dwRetCode;
    }

    if ( FindPort(pPort) ) {

        _ASSERTE(pPort == NULL); // How could we hit this? -- MuhuntS

        pPort->Delete();
        pPort->DecRef ();

        return ERROR_INVALID_PARAMETER;
    }


    //
    // Now we have a unique port, add it to the list
    //
    if ( dwRetCode = AddPortToList(pPort) )
        return dwRetCode;

    return ERROR_SUCCESS;

}   // ::CreatePortObj()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort -- creates a port & adds it to the end of the port list & sets
//      the registry entry for that port
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INSUFFICIENT_BUFFER if port object isn't created
//          ERROR_INVALID_PARAMETER if port object is duplicate
//      FIX! error codes

DWORD
CPortMgr::
CreatePort(
    IN  DWORD       dwPortType,         // port type to be created; i.e. protocol type
    IN  DWORD       dwVersion,          // version/level number of the data passed in
    IN  LPCTSTR     psztPortName,       // port name
    IN  LPBYTE      pData
    )
{
    DWORD   dwRetCode = NO_ERROR;

    // This is the place where new ports are create via the UI.


    dwRetCode = PortExists(psztPortName );

    if( dwRetCode == NO_ERROR )
    {
        EnterCSection();

        dwRetCode = CreatePortObj( psztPortName, dwPortType, dwVersion, pData);

        ExitCSection();
    }
    return dwRetCode;

}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  ValidateHandle -- Checks to see if the handle is for an HP Port
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
CPortMgr::
ValidateHandle(
    IN      HANDLE      handle,
    IN OUT  CPort     **ppPort
    )
{
    PHPPORT pHPPort = (PHPPORT) handle;
    DWORD   dwRetCode = NO_ERROR;

    if ( ppPort )  {

        *ppPort = NULL;
        //
        // verify the port handle & the signature
        //
        if ( pHPPort                                    &&
             pHPPort->dSignature == HPPORT_SIGNATURE ) {

            //
            // Note if pHPPort->pPort being NULL is
            // XcvOpenPort for generic Add case (and is still success)
            //
            if ( pHPPort->pPort )
                *ppPort = pHPPort->pPort;
        } else {

            dwRetCode = ERROR_INVALID_HANDLE;
        }
    } else  {

        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return dwRetCode;
}   // ::ValidateHandle()



///////////////////////////////////////////////////////////////////////////////
//  FindPort -- finds a port given a port name (FIX)
//      Return:
//          pointer to CPort object or HANDLE to CPort object if success
//          NULL if port is not found
//      FIX: how to handle this

CPort *
CPortMgr::
FindPort(
    IN  LPCTSTR psztPortName
    )
{
    CPort      *pPort = NULL;

    if (m_pPortList->FindItem ((LPTSTR) psztPortName, pPort)) {
        return pPort;
    }
    else
        return NULL;

}   // ::FindPort()


///////////////////////////////////////////////////////////////////////////////
//  FindPort -- finds a port given a port object or port HANDLE? (FIX)
//      Return:
//          TRUE if port exists
//          FALSE if port !exists


BOOL
CPortMgr::
FindPort(
    IN  CPort   *pNewPort
    )
{
    CPort      *pPort = NULL;

    if (m_pPortList->FindItem (pNewPort, pPort)) {
        pPort->DecRef ();
        return TRUE;
    }
    else
        return FALSE;

}   // ::FindPort()



///////////////////////////////////////////////////////////////////////////////
//  EnumSystemProtocols
//      Enumerates the system protocols using WSAEnumProtocols or EnumProtocols
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_SUPPORTED if TCP/IP networking is not supported
//      FIX: how to handle this

DWORD
CPortMgr::
EnumSystemProtocols(
    VOID
    )
{
    DWORD dwRetCode = NO_ERROR;

    // call WSAEnumProtocols or EnumProtocols
    // if TCP protocol ! available, return ERROR_NOT_SUPPORTED

    return dwRetCode;
}   // ::EnumSystemProtocols()


///////////////////////////////////////////////////////////////////////////////
//  EnumSystemPorts
//      Enumerates the installed ports in the system using the registry
//      Error codes:
//          NO_ERROR if success
//          FIX: Error codes

DWORD
CPortMgr::
EnumSystemPorts(
    VOID
    )
{
    DWORD dwRetCode = NO_ERROR;

    EnterCSection();
    dwRetCode = m_pRegistry->EnumeratePorts( this );
    ExitCSection();

    return dwRetCode;

}   // ::EnumSystemPorts()

///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

VOID
CPortMgr::
EnterCSection()
{
    m_pPortList->Lock ();
    //EnterCriticalSection(&m_critSect);

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

VOID
CPortMgr::
ExitCSection()
{
    m_pPortList->Unlock ();

    //_ASSERTE(m_critSect.OwningThread == (LPVOID)GetCurrentThreadId());

    //LeaveCriticalSection(&m_critSect);

}   //  ::ExitCSection()

///////////////////////////////////////////////////////////////////////////////
//  XcvOpenPort -- used for remote port administration
//  Error Codes:
//          NO_ERROR if success
//          ERROR_NOT_SUPPORTED if port object doesn't exist
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//          ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

DWORD
CPortMgr::
XcvOpenPort(
    IN  LPCTSTR         pszObject,
    IN  ACCESS_MASK     GrantedAccess,
    OUT PHANDLE         phXcv)
{
    DWORD   dwRetCode = NO_ERROR;

    if ( !pszObject || !*pszObject ) {

        //
        // A generic session to the monitor is being opened for AddPort.
        // create a new handle and return it.
        //
        dwRetCode = OpenPort(phXcv);
    } else if( _tcscmp(pszObject, PORTMONITOR_DESC ) == 0) {

        //
        // A generic session to the monitor is being opened for AddPort.
        // create a new handle and return it.
        //
        dwRetCode = OpenPort(phXcv);
    } else if ( pszObject != NULL ) {

        //
        // A specific port is being requested for configure or delete
        // and the port was found by the call to OpenPort.
        //
        dwRetCode = OpenPort( pszObject, phXcv);
    }

    if ( dwRetCode == NO_ERROR )
    {
        ((PHPPORT)(*phXcv))->grantedAccess = GrantedAccess;
        ((PHPPORT)(*phXcv))->pPortMgr = this;
    }


    return dwRetCode;
} // ::XcvOpenPort()


///////////////////////////////////////////////////////////////////////////////
//  XcvClosePort --
//  Error codes:
//      NO_ERROR if success
//      ERROR_INVALID_HANDLE if handle is invalid

DWORD
CPortMgr::
XcvClosePort(
    IN  HANDLE  hXcv
    )
{
    return ClosePort(hXcv);
} // ::XcvClosePort()


///////////////////////////////////////////////////////////////////////////////
//  XcvDataPort -- remote port management function
//  Error Codes:
//      NO_ERROR if success
//      ERROR_INVALID_DATA if the Input data is missing
//      ERROR_BAD_COMMAND if the pszDataName is not supported
//      ERROR_INSUFFICIENT_BUFFER if buffer size is invalid
//      ACCESS_DENIED if doesn't have sufficient rights
//      ERROR_INVALID_HANDLE if the handle is invalid

DWORD
CPortMgr::
XcvDataPort(
    IN  HANDLE      hXcv,
    IN  PCWSTR      pszDataName,
    IN  PBYTE       pInputData,
    IN  DWORD       cbInputData,
    IN  PBYTE       pOutputData,
    IN  DWORD       cbOutputData,
    OUT PDWORD      pcbOutputNeeded
    )
{
    DWORD   dwSize;
    DWORD   dwRetCode = NO_ERROR;
    CPort  *pPort;

    if ( (dwRetCode = ValidateHandle(hXcv, &pPort)) != ERROR_SUCCESS )
        return dwRetCode;

    // Valid input parameters

    if ((pszDataName && IsBadStringPtr (pszDataName, sizeof (TCHAR) * cdwMaxXcvDataNameLen)) ||

        (pInputData && cbInputData && IsBadReadPtr (pInputData, cbInputData)) ||

        (pOutputData && cbOutputData && IsBadWritePtr (pOutputData, cbOutputData)) ||

        (pcbOutputNeeded && IsBadWritePtr (pcbOutputNeeded, sizeof (DWORD)))) {

        return  ERROR_INVALID_PARAMETER;
    }


    PHPPORT pHpPort = (PHPPORT)hXcv;

    // We have a valid handle, check the validity of the passed parameters

    if ( pszDataName == NULL ) {
        dwRetCode = ERROR_INVALID_PARAMETER;
    } else

    if ( _tcscmp(pszDataName, TEXT("AddPort")) == 0 ) {

        if ( !HasAdminAccess(hXcv) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData < sizeof(PORT_DATA_1)) {

            dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((PPORT_DATA_1)pInputData)->dwVersion != 1 ) {
          dwRetCode = ERROR_INVALID_LEVEL;

        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                EndPortData1Strings((PPORT_DATA_1)pInputData);

                dwRetCode = CreatePort(((PPORT_DATA_1)pInputData)->dwProtocol,
                                   ((PPORT_DATA_1)pInputData)->dwVersion,
                                   ((PPORT_DATA_1)pInputData)->sztPortName,
                                   pInputData);

                ImpersonatePrinterClient( hPrintAccess );

            } else {

                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if ( _tcscmp(pszDataName, TEXT("DeletePort")) == 0 )  {

        if ( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData != sizeof (DELETE_PORT_DATA_1)) {
                    dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((DELETE_PORT_DATA_1 *)pInputData)->dwVersion != 1 ) {

            dwRetCode = ERROR_INVALID_LEVEL;
        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                EndDeletePortData1Strings((DELETE_PORT_DATA_1 *)pInputData);

                dwRetCode = DeletePort(((DELETE_PORT_DATA_1 *)pInputData)
                                                        ->psztPortName);
                ImpersonatePrinterClient( hPrintAccess );
            } else {
                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("MonitorUI")) == 0 ) {

        if( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else {
            dwSize = sizeof(PORTMONITOR_UI_NAME);

            //
            // This returns the name of the UI DLL "tcpmonui.dll"
            //
            if ( cbOutputData < dwSize ) {
                if (pcbOutputNeeded == NULL) {

                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    dwRetCode = HRESULT_CODE (
                        StringCbCopy ((TCHAR *)pOutputData, cbOutputData, PORTMONITOR_UI_NAME)
                        );
                }
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("ConfigPort")) == 0 ) {

        if( !HasAdminAccess( hXcv ) ) {

            dwRetCode = ERROR_ACCESS_DENIED;
        } else if ( pInputData == NULL || cbInputData < sizeof(PORT_DATA_1) ) {

            dwRetCode = ERROR_INVALID_DATA;

        } else if ( ((PPORT_DATA_1)pInputData)->dwVersion != 1 ) {

            dwRetCode = ERROR_INVALID_LEVEL;
        } else {

            HANDLE hPrintAccess = RevertToPrinterSelf();

            if( hPrintAccess ) {

                dwRetCode = ConfigPortUIEx( pInputData );  // This terminates strings internally

                ImpersonatePrinterClient( hPrintAccess );

            } else {
                dwRetCode = ERROR_ACCESS_DENIED;
            }
        }
    } else if( _tcscmp(pszDataName, TEXT("GetConfigInfo")) == 0 ) {

        dwSize = sizeof( PORT_DATA_1 );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }
        } else if ( pInputData == NULL || cbInputData < sizeof(CONFIG_INFO_DATA_1) ) {
            dwRetCode = ERROR_INVALID_DATA;
        } else if ( ((CONFIG_INFO_DATA_1 *)pInputData)->dwVersion != 1 ) {
            dwRetCode = ERROR_INVALID_LEVEL;
        } else if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                InitConfigPortStruct((PPORT_DATA_1) pOutputData, pHpPort->pPort);
                dwRetCode = NO_ERROR;
            }
        }
    } else if(_tcsicmp(pszDataName, TEXT("SNMPEnabled")) == 0)  {

        SNMP_INFO snmpInfo;

        dwSize = sizeof( DWORD );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }

        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else if (!pHpPort->pPort) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                pHpPort->pPort->GetSNMPInfo( &snmpInfo);
                memcpy( (TCHAR *)pOutputData, &snmpInfo.dwSNMPEnabled, dwSize );
                dwRetCode = NO_ERROR;
            }
        }
    } else if ( _tcsicmp(pszDataName, TEXT("IPAddress")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {

            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztAddress ) + 1) * sizeof( TCHAR )) ;
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztAddress, dwSize );
                    dwRetCode = NO_ERROR;
                }
            }
        }

    } else if ( _tcsicmp(pszDataName, TEXT("HostAddress")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {
            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztAddress ) + 1) * sizeof( TCHAR )) ;
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztAddress, dwSize );
                    dwRetCode = NO_ERROR;
                }
            }
        }

    } else if ( _tcsicmp(pszDataName, TEXT("SNMPCommunity")) == 0 )  {

        SNMP_INFO snmpInfo;

        if (!pHpPort->pPort) {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }
        else {
            pHpPort->pPort->GetSNMPInfo( &snmpInfo);

            dwSize = ((_tcslen( snmpInfo.sztSNMPCommunity ) + 1 ) * sizeof( TCHAR ));
            if ( cbOutputData < dwSize ) {

                if (pcbOutputNeeded == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    *pcbOutputNeeded = dwSize;
                    dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
                }

            } else {

                if (pOutputData == NULL) {
                    dwRetCode = ERROR_INVALID_PARAMETER;
                } else {
                    memcpy( (TCHAR *)pOutputData, snmpInfo.sztSNMPCommunity, dwSize );
                    dwRetCode = NO_ERROR;
                }
           }
        }
    } else if( _tcsicmp(pszDataName, TEXT("SNMPDeviceIndex")) == 0 )  {

        SNMP_INFO snmpInfo;

        dwSize= sizeof( DWORD );

        if ( cbOutputData < dwSize ) {

            if (pcbOutputNeeded == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                *pcbOutputNeeded = dwSize;
                dwRetCode =  ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            if (pOutputData == NULL) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            }
            else if (!pHpPort->pPort) {
                dwRetCode = ERROR_INVALID_PARAMETER;
            } else {
                pHpPort->pPort->GetSNMPInfo( &snmpInfo);
                memcpy( (TCHAR *)pOutputData, &snmpInfo.dwSNMPDeviceIndex, dwSize );
                dwRetCode = NO_ERROR;
            }
        }
    } else {

        dwRetCode = ERROR_INVALID_PARAMETER;
    }

    return dwRetCode;

} // ::XcvDataPort()

 ///////////////////////////////////////////////////////////////////////////////
//  EndPortData1Strings -- Ensures that all of the PPORT_DATA_1 strings passed
//                      -- in are NULL Terminated

void CPortMgr::EndPortData1Strings(PPORT_DATA_1 pPortData) {
    pPortData->sztPortName[MAX_PORTNAME_LEN - 1]                = NULL;
    pPortData->sztHostAddress[MAX_NETWORKNAME_LEN - 1]          = NULL;
    pPortData->sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN - 1] = NULL;
    pPortData->sztQueue[MAX_QUEUENAME_LEN - 1]                  = NULL;
    pPortData->sztIPAddress[MAX_IPADDR_STR_LEN - 1]             = NULL;
    pPortData->sztDeviceType[MAX_DEVICEDESCRIPTION_STR_LEN - 1] = NULL;
}

 ///////////////////////////////////////////////////////////////////////////////
//  EndDeletePortData1Strings -- Ensures that all of the PPORT_DATA_1 strings passed
//                            -- in are NULL Terminated
void CPortMgr::EndDeletePortData1Strings(PDELETE_PORT_DATA_1 pDeleteData) {
    pDeleteData->psztName[SIZEOF_IN_CHAR(pDeleteData->psztPortName) - 1]        = NULL;
    pDeleteData->psztPortName[SIZEOF_IN_CHAR(pDeleteData->psztPortName) - 1] = NULL;
}

///////////////////////////////////////////////////////////////////////////////
//  EncodeHandle -- Encodes the HPPORT handle
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
CPortMgr::
EncodeHandle(
    CPort *pPort,
    PHANDLE phXcv
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PHPPORT pHPPort = NULL;

    size_t size = sizeof(HPPORT);
    if ( pHPPort = (PHPPORT) LocalAlloc( LPTR, sizeof(HPPORT) ) ) {

        pHPPort->cb = sizeof(HPPORT);
        pHPPort->dSignature = HPPORT_SIGNATURE;
        pHPPort->grantedAccess = SERVER_ACCESS_ADMINISTER;
        pHPPort->pPort = pPort;
        pHPPort->pPortMgr = this;

        *phXcv = pHPPort;
    }  else {

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRetCode;
}   // ::EncodeHandle()

///////////////////////////////////////////////////////////////////////////////
//  FreeHandle -- Frees the HPPORT handle
//      Error codes:
//          NO_ERROR if success

DWORD
CPortMgr::
FreeHandle(
    HANDLE hXcv
    )
{
    DWORD   dwRetCode = NO_ERROR;

    LocalFree( hXcv );

    return( dwRetCode );
}   // ::FreeHandle()


BOOL
CPortMgr::
HasAdminAccess(
    HANDLE hXcv
    )
{
    return ((((PHPPORT)hXcv)->grantedAccess & SERVER_ACCESS_ADMINISTER) != 0);
}

//
// Function - PortExists()
//
// returns - true when the port exists false otherwise
//
//
DWORD
CPortMgr::
PortExists(
    IN  LPCTSTR psztPortName
    )
{
    DWORD dwRetCode = NO_ERROR;

    PORT_INFO_1 *pi1 = NULL;
    DWORD pcbNeeded = 0;
    DWORD pcReturned = 0;
    BOOL res;

    // Should never happen but well be safe
    if( g_pfnEnumPorts == NULL )
    {
        return( TRUE );
    }

    // Get the required buffer size
    res = g_pfnEnumPorts((m_szServerName[0] == TEXT('\0')) ? NULL : m_szServerName,
        1,
        (LPBYTE)pi1,
        0,
        &pcbNeeded,
        &pcReturned
        );
    // Alloc the space for the port list and check to make sure that
    // this port does not already exist.

    while(dwRetCode == NO_ERROR &&
          res == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {

        if(pi1 != NULL)
        {
            free( pi1 );
            pi1 = NULL;
        }

        pi1 = (PORT_INFO_1 *) malloc(pcbNeeded);
        if(pi1 == NULL)
        {
            pcbNeeded = 0;
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            res = g_pfnEnumPorts(
                (m_szServerName[0] == '\0') ? NULL : m_szServerName,
                1,
                (LPBYTE)pi1,
                pcbNeeded,
                &pcbNeeded,
                &pcReturned);

            if( res )
            {
                for(DWORD i=0;i<pcReturned; i++)
                {
                    if(0 == _tcsicmp(pi1[i].pName, psztPortName))
                    {
                        dwRetCode = ERROR_DUP_NAME;
                        break;
                    }
                }
            }
        }
    }

    if(pi1 != NULL)
    {
        free(pi1);
        pi1 = NULL;
    }

    return(dwRetCode);
}

DWORD CPortMgr::
GetLprAckTimeout (
    VOID
    ) const
{
    return m_dwLprAckTimeout;
}//end GetLprAckTimeout

VOID CPortMgr::
InitializeLprAckTimeout (
    VOID
    )
{
    DWORD dwRetVal = ERROR_SUCCESS;
    DWORD dwLprAckTimeout = s_dwDefaultLprAckTimeout;

    if (m_pRegistry)
    {
        dwRetVal = m_pRegistry->SetWorkingKey(NULL);
        if (dwRetVal == ERROR_SUCCESS)
        {
            DWORD dwSize = sizeof (dwLprAckTimeout);
            dwRetVal = m_pRegistry-> QueryValue (s_szLprAckTimeoutRegVal,
                                                 (LPBYTE) &dwLprAckTimeout,
                                                 &dwSize);
            if (dwRetVal == ERROR_FILE_NOT_FOUND ||
               (dwRetVal == ERROR_SUCCESS && dwLprAckTimeout == 0))
            {
                //
                // Write default value
                //
                dwSize = sizeof (s_dwDefaultLprAckTimeout);
                (VOID) m_pRegistry-> SetValue (s_szLprAckTimeoutRegVal,
                                               REG_DWORD,
                                               (LPBYTE) &s_dwDefaultLprAckTimeout,
                                               dwSize);
                dwLprAckTimeout = s_dwDefaultLprAckTimeout;
            }
        }
        m_pRegistry->FreeWorkingKey ();
    }

    if (dwRetVal == ERROR_SUCCESS)
    {
        m_dwLprAckTimeout = dwLprAckTimeout;
    }
    else
    {
        m_dwLprAckTimeout = s_dwDefaultLprAckTimeout;
    }
}//end InitializeLprAckTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\portrefabc.h ===
/*****************************************************************************
 *
 * $Workfile: portrefabc.h $
 *
 * Copyright (C) 2000 Microsoft Corporation.
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef INC_PORTREFABC_H
#define INC_PORTREFABC_H

#include "mglist.h"

class TRefCount;
class CPortABC;

class CPortRefABC: public CPortABC, public TRefCount
{
public:
	CPortRefABC() { };
	virtual	~CPortRefABC() { };

#ifdef DBG
    virtual DWORD
    IncRef () {
        DBGMSG (DBG_TRACE, ("PortRefABC %p ", this));
        return TRefCount::IncRef();
    };

    virtual DWORD
    DecRef () {
        DBGMSG (DBG_TRACE, ("PortRefABC %p ", this));
        return TRefCount::DecRef();
    };
#endif

};


#endif	// INC_PORTREFABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\precomp.h ===
/*****************************************************************************
 *
 * $Workfile: pch_spp.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/pch_spp.h $
 *
 * 2     7/14/97 2:27p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:19p Binnur
 * Initial File
 *
 *****************************************************************************/

#ifndef INC_PCH_SPP_H
#define INC_PCH_SPP_H

#include <windows.h>

//  Include the correct spooler definitions, etc
#include <winspool.h>

#include <tchar.h>

#include <windows.h>
#include <winsock2.h>
#include <time.h>
#include <winerror.h>

#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <winsplp.h>
#include <strsafe.h>

// event messages
#include "message.h"	
#include "event.h"	
#include "spllib.hxx"

//
//  Files at ..\Common
//
#include "tcpmon.h"
#include "rtcpdata.h"
#include "CoreUI.h"
#include "regabc.h"
#include "mibabc.h"

#endif	// INC_PCH_SPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawport.cpp ===
/*****************************************************************************
 *
 * $Workfile: rawport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "rawdev.h"
#include "tcpjob.h"
#include "rawtcp.h"
#include "rawport.h"

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::CRawTcpPort()  -- called when creating a new port through the UI

CRawTcpPort::CRawTcpPort( LPTSTR    IN      psztPortName,
                          LPTSTR    IN      psztHostAddress,
                          DWORD     IN      dPortNum,
                          DWORD     IN      dSNMPEnabled,
                          LPTSTR    IN      sztSNMPCommunity,
                          DWORD     IN      dSNMPDevIndex,
                          CRegABC   IN      *pRegistry,
                          CPortMgr  IN      *pPortMgr) :
                                CTcpPort(psztPortName, psztHostAddress,
                                dPortNum, dSNMPEnabled, sztSNMPCommunity,
                                dSNMPDevIndex, pRegistry, pPortMgr)
{
// Let the base class do the work;
}   // ::CRawTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::CRawTcpPort() -- called when creating a new port through the
//      registry entries.

CRawTcpPort::CRawTcpPort( LPTSTR    IN      psztPortName,
                          LPTSTR    IN      psztHostName,
                          LPTSTR    IN      psztIPAddr,
                          LPTSTR    IN      psztHWAddr,
                          DWORD     IN      dPortNum,
                          DWORD     IN      dSNMPEnabled,
                          LPTSTR    IN      sztSNMPCommunity,
                          DWORD     IN      dSNMPDevIndex,
                          CRegABC   IN      *pRegistry,
                          CPortMgr  IN      *pPortMgr ) :
                                CTcpPort( psztPortName, psztHostName,
                                psztIPAddr, psztHWAddr, dPortNum, dSNMPEnabled,
                                sztSNMPCommunity, dSNMPDevIndex,  pRegistry, pPortMgr)
{
// Let The base class do the work;
}   // ::CRawTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpPort::~CRawTcpPort()
//      Called by CPortMgr when deleting a port

CRawTcpPort::~CRawTcpPort()
{
    //
    // Delete the job class first because it access the device class.
    //
    if (m_pJob)
    {
        delete m_pJob;
        m_pJob = NULL;
    }
    if (m_pDevice)
    {
        delete m_pDevice;
        m_pDevice = NULL;
    }

}   // ::~CPort


///////////////////////////////////////////////////////////////////////////////
//  StartDoc
//      Error codes:
//          NO_ERROR if succesfull
//          ERROR_BUSY if port is already busy
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CRawTcpPort::StartDoc( const LPTSTR in psztPrinterName,
                       const DWORD  in jobId,
                       const DWORD  in level,
                       const LPBYTE in pDocInfo )
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT3(_CRT_WARN,
          "PORT -- (CRawPort)StartDoc called for (%S,%S) w/ jobID %d\n",
          psztPrinterName, m_szName, jobId);

    if( m_pJob == NULL ) {

        //
        // Create a new job
        //
        m_pJob = new CTcpJob(psztPrinterName, jobId, level, pDocInfo, this, CTcpJob::kRawJob);
        if ( m_pJob ) {

            if ( (dwRetCode = m_pJob->StartDoc()) != NO_ERROR ) {

                //
                // startdoc failed
                //
                delete m_pJob;
                m_pJob = NULL;
            }
        } else {

            dwRetCode = ERROR_OUTOFMEMORY;
        }
    } else {

        _ASSERTE(m_pJob == NULL);
        dwRetCode = STG_E_UNKNOWN;
    }

    return (dwRetCode);

}   // ::StartDoc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawdev.h ===
/*****************************************************************************
 *
 * $Workfile: rawdev.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPDEVICE_H
#define INC_TCPDEVICE_H

#include "devABC.h"
#include "tcpport.h"

class CMemoryDebug;
class CTCPTransport;
class CTcpMibABC;


typedef DWORD	 (CALLBACK *PFN_PING) ( LPCSTR );


class CRawTcpDevice : public CDeviceABC
#if defined _DEBUG || defined DEBUG
	 , public CMemoryDebug
#endif
{
	// methods
public:
	CRawTcpDevice();

	CRawTcpDevice(	
        LPTSTR		    psztHostAddress,
        DWORD		    dPortNum,
        DWORD		    dSNMPEnabled,
        LPTSTR		    psztSNMPCommunity,
        DWORD		    dSNMPDevIndex,
        CTcpPort        *pParent);

	CRawTcpDevice(
        LPTSTR		    psztHostName,
        LPTSTR		    psztIPAddr,
        LPTSTR		    psztHWAddr,
        DWORD		    dPortNum,
        DWORD		    dSNMPEnabled,
        LPTSTR		    psztSNMPCommunity,
        DWORD		    dSNMPDevIndex,
        CTcpPort        *pParent);
	
	~CRawTcpDevice();

    DWORD   ReadDataAvailable();

	DWORD   Read(LPBYTE	        pBuffer,
                 DWORD	        cbBufSize,
                 INT            iTimeout,
                 LPDWORD        pcbRead);

	DWORD   Write(LPBYTE        pBuffer,
                  DWORD	        cbBuf,
                  LPDWORD       pcbWritten);

	DWORD   Connect();

    DWORD   GetAckBeforeClose(DWORD     dwTimeInSeconds);

    DWORD   PendingDataStatus(DWORD     dwTimeInMilliSeconds,
                              LPDWORD   pcbNeeded);
	DWORD	Close();
	DWORD	Ping();
	DWORD	ResolveAddress();
	DWORD	CheckAddress( );
	LPTSTR	GetHostAddress()	{ return (*m_sztHostName == '\0' ?
								(LPTSTR)m_sztIPAddress : (LPTSTR)m_sztHostName);  }
	LPTSTR	GetHostName()	{ return (LPTSTR)m_sztHostName;  }
	LPTSTR	GetIPAddress()	{ return (LPTSTR)m_sztIPAddress; }
	LPTSTR	GetHWAddress()	{ return (LPTSTR)m_sztHWAddress; }
	LPTSTR  GetSNMPCommunity()	{ return (LPTSTR)m_sztSNMPCommunity; }
	DWORD	GetSNMPEnabled()	{ return m_dSNMPEnabled; }
	DWORD	GetSNMPDevIndex()	{ return m_dSNMPDevIndex; }
	LPTSTR	GetDescription();
	DWORD	GetPortNumber() { return m_dPortNumber; }
	DWORD	GetStatus();
	DWORD	GetJobStatus();
	DWORD	SetStatus( LPTSTR psztPortName );
    DWORD   SetStatusNT3( LPTSTR psztPortName );
	DWORD	GetDeviceInfo();
	DWORD	ResolveTransportPath( LPSTR	 pszHostAddress,
								  DWORD  dwSize );

protected:		// members
	void	InitializeTcpMib();
	void	DeInitialize( );
	DWORD	SetHWAddress();
	
private:		// attributes
	CTcpPort     *m_pParent;
	CTcpMibABC		*m_pTcpMib;
	RPARAM_1		m_pfnGetTcpMibPtr;	// points to RecognizeFrame()

	DWORD			m_dwLastError;

protected:
	CTCPTransport	*m_pTransport;			// the actual transport path

	// device address
	TCHAR		m_sztAddress[MAX_NETWORKNAME_LEN];			// host address (name or IP)
	TCHAR		m_sztHostName[MAX_NETWORKNAME_LEN];			// host name
	TCHAR		m_sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR		m_sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR		m_sztDescription[MAX_DEVICEDESCRIPTION_STR_LEN];
	TCHAR		m_sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD		m_dPortNumber;
	DWORD		m_dSNMPEnabled;
	DWORD		m_dSNMPDevIndex;
    BOOL        m_bFirstWrite;


/*	CMACAddress	*m_pHWAddress;
	CIPAddress	*m_pIPAddress;
*/
};


#endif // INC_TCPDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawdev.cpp ===
/*****************************************************************************
 *
 * $Workfile: rawdev.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "tcptrans.h"
#include "rawdev.h"


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpDevice::CRawTcpDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice() :
                                m_pTransport(NULL), m_pParent(NULL),
                                m_pfnGetTcpMibPtr(NULL), m_pTcpMib(NULL),
                                m_dwLastError(NO_ERROR), m_dPortNumber(0),
                                m_dSNMPEnabled(FALSE),
                                m_bFirstWrite (TRUE)
{
    *m_sztAddress   = '\0';
    *m_sztIPAddress = '\0';
    *m_sztHWAddress = '\0';
    *m_sztHostName  = '\0';
    *m_sztDescription = '\0';
    *m_sztSNMPCommunity = '\0';

    InitializeTcpMib();

}   // ::CRawTcpDevice()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpDevice::CRawTcpDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice( LPTSTR    in psztHostAddress,
                              DWORD     in dPortNum,
                              DWORD     in dSNMPEnabled,
                              LPTSTR    in psztSNMPCommunity,
                              DWORD     in dSNMPDevIndex,
                              CTcpPort  in *pParent) :
                                                     m_pTransport( NULL ),
                                                     m_bFirstWrite (TRUE)


{
    lstrcpyn(m_sztAddress, psztHostAddress, SIZEOF_IN_CHAR( m_sztAddress));
    lstrcpyn(m_sztSNMPCommunity, psztSNMPCommunity, SIZEOF_IN_CHAR( m_sztSNMPCommunity) );

    *m_sztIPAddress = '\0';
    *m_sztHWAddress = '\0';
    *m_sztHostName  = '\0';
    *m_sztDescription = '\0';

    m_dSNMPEnabled = dSNMPEnabled;
    m_dSNMPDevIndex = dSNMPDevIndex;
    m_dPortNumber = dPortNum;
    m_pParent = pParent;

    InitializeTcpMib();

    ResolveAddress( );      // gets the hostName & IP Address
//  SetHWAddress();         // gets the hardware address
//  GetDescription();


}   // ::CRawTcpDevice()


///////////////////////////////////////////////////////////////////////////////
//  CDevice::CDevice()
//      Initializes the device

CRawTcpDevice::CRawTcpDevice( LPTSTR in psztHostName,
                              LPTSTR in psztIPAddr,
                              LPTSTR in psztHWAddr,
                              DWORD  in dPortNum,
                              DWORD  in dSNMPEnabled,
                              LPTSTR in psztSNMPCommunity,
                              DWORD  in dSNMPDevIndex,
                              CTcpPort  in *pParent) :
                                                     m_pTransport(NULL),
                                                     m_bFirstWrite (TRUE)
{
    lstrcpyn(m_sztHostName, psztHostName, SIZEOF_IN_CHAR( m_sztHostName));
    lstrcpyn(m_sztIPAddress, psztIPAddr, SIZEOF_IN_CHAR( m_sztIPAddress));
    lstrcpyn(m_sztHWAddress, psztHWAddr, SIZEOF_IN_CHAR( m_sztHWAddress));
    lstrcpyn(m_sztSNMPCommunity, psztSNMPCommunity, SIZEOF_IN_CHAR( m_sztSNMPCommunity ) );

    if ( *m_sztHostName == '\0' )
    {
        if ( *m_sztIPAddress != '\0' )
        {
            lstrcpyn(m_sztAddress, m_sztIPAddress, SIZEOF_IN_CHAR( m_sztAddress) );
        }
        else
        {
            StringCchCopy (m_sztAddress, COUNTOF (m_sztAddress), TEXT(""));
        }
    }
    else
    {
        lstrcpyn(m_sztAddress, m_sztHostName, SIZEOF_IN_CHAR(m_sztAddress));
    }

    m_dPortNumber = dPortNum;
    m_pParent = pParent;


    *m_sztDescription = '\0';

    m_dSNMPEnabled = dSNMPEnabled;
    m_dSNMPDevIndex = dSNMPDevIndex;

    InitializeTcpMib();

//  Type();     // FIX:     for debug only.
//  Ping();
//  SetHWAddress();
//  GetDeviceInfo();


}   // ::CDevice()


///////////////////////////////////////////////////////////////////////////////
//  CDevice::~CDevice()
//

CRawTcpDevice::~CRawTcpDevice()
{
    if (m_pTransport)   delete m_pTransport;
}   // ::~CDevice()


///////////////////////////////////////////////////////////////////////////////
//  InitializeTcpMib -- loads the TcpMib.dll & gets a handle to the CTcpMibABC
//      class

void
CRawTcpDevice::InitializeTcpMib( )
{
    // load & assign the m_pTcpMib pointer
    m_pTcpMib = NULL;

    if( g_hTcpMib == NULL )
    {
        g_hTcpMib = ::LoadLibrary(TCPMIB_DLL_NAME);
        if (g_hTcpMib == NULL)
        {
            _RPT0(_CRT_WARN, "TCPMIB.DLL Not Found\n");
            m_dwLastError = ERROR_DLL_NOT_FOUND;
        }
    }

    if( g_hTcpMib != NULL )
    {
        // initialize the proc address
        m_pfnGetTcpMibPtr=(RPARAM_1)::GetProcAddress(g_hTcpMib, "GetTcpMibPtr");

        m_pTcpMib = (CTcpMibABC *)(*m_pfnGetTcpMibPtr)();
        if ( m_pTcpMib == NULL)
        {
            m_dwLastError = GetLastError();
        }
    }
}   // ::InitializeTcpMib()

///////////////////////////////////////////////////////////////////////////////
//  ReadDataAvailable -- check if there are data available to read
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::ReadDataAvailable()
{
    DWORD dwRetCode = NO_ERROR;

    if ( m_pTransport )
    {
        dwRetCode = m_pTransport->ReadDataAvailable();
    }
    else
    {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return (dwRetCode);

}   // ::ReadDataAvailable()


///////////////////////////////////////////////////////////////////////////////
//  Read -- recv the print data from the device
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::Read( LPBYTE in      pBuffer,
                      DWORD     in      cbBufSize,
                      INT       in      iTimeout,
                      LPDWORD   inout   pcbRead)
{
    DWORD dwRetCode = NO_ERROR;

    if ( m_pTransport )
    {
        dwRetCode = m_pTransport->Read(pBuffer, cbBufSize, iTimeout, pcbRead);
    }
    else
    {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return (dwRetCode);

}   // ::Read()

///////////////////////////////////////////////////////////////////////////////
//  Write -- sends the print data to the device
//  Error Codes
//      NO_ERROR if everything is OK.
//      RC_CONNECTION_RESET if connection is reset
//      ERROR_INVALID_HANDLE    if transport connection is not valid

DWORD
CRawTcpDevice::Write( LPBYTE    in      pBuffer,
                      DWORD     in      cbBuf,
                      LPDWORD   inout   pcbWritten)
{
    DWORD dwRetCode = NO_ERROR;

    if (dwRetCode == NO_ERROR)
    {
        if ( m_pTransport )
        {
            dwRetCode = m_pTransport->Write(pBuffer, cbBuf, pcbWritten);
        }
        else
        {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    }

    if (m_bFirstWrite && dwRetCode == ERROR_CONNECTION_ABORTED)
    {
        if ( m_pTransport ) {
            delete m_pTransport;
            m_pTransport = NULL;
        }

        //
        // When users print large images, there will be a long delay between StartDocPrinter
        // and the frist WritePrinter call. TCPMon used to open the TCP/IP connection
        // to the printer at the StartDocPrinter time, but since there is no data
        // coming, the printer closeed the connection when TCPMon tried to write the data.
        //
        // So we have to re-establish connection open to the first WritePrinter call.
        //

        char    szHostAddress[MAX_NETWORKNAME_LEN];

        //
        // resolve the address to use
        //
        dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );

        if (dwRetCode == NO_ERROR && strcmp(szHostAddress, "") == 0 )
        {
            dwRetCode = ERROR_INVALID_PARAMETER;
        }

        if (dwRetCode == NO_ERROR) {

            m_pTransport = new CTCPTransport(szHostAddress, static_cast<USHORT>(m_dPortNumber));

            if (!m_pTransport)
            {
                dwRetCode = ERROR_OUTOFMEMORY;
            }
        }

        if (dwRetCode == NO_ERROR)
        {
            dwRetCode = m_pTransport->Connect();
        }

        if (dwRetCode != NO_ERROR)
        {
            //
            //  Operation failed, we need to free the m_Transport
            //
            delete m_pTransport;
            m_pTransport = NULL;
        }

        if ( m_pTransport )
        {
            dwRetCode = m_pTransport->Write(pBuffer, cbBuf, pcbWritten);
        }
        else
        {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    }

    m_bFirstWrite = FALSE;

    return (dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  Connect -- creates a new transport connection
//  Error Codes
//      NO_ERROR if everything is OK
//      PRINTER_STATUS_BUSY if connection refused
//      ERROR_INVALID_PARAMETER if the address is not valid

DWORD
CRawTcpDevice::Connect()
{
    DWORD   dwRetCode = NO_ERROR;

    if ( m_pTransport ) {
        delete m_pTransport;
        m_pTransport = NULL;
    }

    m_bFirstWrite = TRUE;

    //
    // We must verify if the HostName is available, if not we should return error
    // right away.
    //
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    //
    // resolve the address to use
    //
    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );

    if (dwRetCode == NO_ERROR && strcmp(szHostAddress, "") == 0 )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
    }

    if (dwRetCode == NO_ERROR) {

        m_pTransport = new CTCPTransport(szHostAddress, static_cast<USHORT>(m_dPortNumber));

        if (!m_pTransport)
        {
            dwRetCode = ERROR_OUTOFMEMORY;
        }
    }

    if (dwRetCode == NO_ERROR)
    {
        dwRetCode = m_pTransport->Connect();
    }

    if (dwRetCode != NO_ERROR)
    {
        //
        //  Operation failed, we need to free the m_Transport
        //
        delete m_pTransport;
        m_pTransport = NULL;
    }

    return dwRetCode;

}   // ::Connect()


DWORD
CRawTcpDevice::
GetAckBeforeClose(
    DWORD   dwTimeInSeconds
    )
{
    return m_pTransport ? m_pTransport->GetAckBeforeClose(dwTimeInSeconds)
                        : ERROR_INVALID_PARAMETER;

}


DWORD
CRawTcpDevice::
PendingDataStatus(
    DWORD       dwTimeout,
    LPDWORD     pcbNeeded
    )
{
   return m_pTransport ? m_pTransport->PendingDataStatus(dwTimeout, pcbNeeded)
                       :  NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
//  Close

DWORD
CRawTcpDevice::Close()
{
    DWORD   dwRetCode = NO_ERROR;

    if ( m_pTransport ) delete m_pTransport;
    m_pTransport = NULL;

    return (dwRetCode);

}   // ::Close()


///////////////////////////////////////////////////////////////////////////////
//  ResolveTransportPath -- m_sztAddress contains the host address to be used
//      to talk to the device

DWORD
CRawTcpDevice::ResolveTransportPath( LPSTR      out     pszHostAddress,
                                     DWORD      in      dwSize ) // Size in characters of the host address
{
    DWORD   dwRetCode = NO_ERROR;

    if ( *m_sztHostName == '\0' )                   // host name is NULL -- no DNS entry
    {
        if ( *m_sztIPAddress != '\0' )              // ip address is entered
        {
            lstrcpyn(m_sztAddress, m_sztIPAddress, SIZEOF_IN_CHAR( m_sztAddress) );
        }
        else
        {
            StringCchCopy (m_sztAddress, COUNTOF (m_sztAddress), TEXT(""));
        }
    }
    else
    {
        lstrcpyn(m_sztAddress, m_sztHostName, SIZEOF_IN_CHAR(m_sztAddress));    // use the host name
    }

    UNICODE_TO_MBCS( pszHostAddress, dwSize, m_sztAddress, -1);

    return (dwRetCode);

}   // ::CreateTransport()


///////////////////////////////////////////////////////////////////////////////
//  Ping
//      Error codes:
//          NO_ERROR            if ping is successfull
//          DEVICE_NOT_FOUND    if device is not found
//          ERROR_INVALID_PARAMETER if address is not valid

DWORD
CRawTcpDevice::Ping()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];
    PFN_PING    pfnPing;

    if( g_hTcpMib == NULL )
    {
        g_hTcpMib = ::LoadLibrary(TCPMIB_DLL_NAME);
        if (g_hTcpMib == NULL)
        {
            _RPT0(_CRT_WARN, "TCPMIB.DLL Not Found\n");
            m_dwLastError = ERROR_DLL_NOT_FOUND;
        }
    }

    if( g_hTcpMib != NULL )
    {
        // resolve the address to use
        dwRetCode = ResolveTransportPath( szHostAddress,
                                          SIZEOF_IN_CHAR(szHostAddress) );
        if ( strcmp(szHostAddress, "") == 0 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        // initialize the proc address
        pfnPing = (PFN_PING)::GetProcAddress(g_hTcpMib, "Ping");
        _ASSERTE(pfnPing != NULL);
        if ( pfnPing )
        {
            dwRetCode = (*pfnPing)(szHostAddress);      // ping the device
        }
    }

    return (dwRetCode);

}   // ::Ping()

///////////////////////////////////////////////////////////////////////////////
//  SetHWAddress -- get's device hardware address, and sets the m_sztHWAddress
//  Error Codes:
//      NO_ERROR if successful
//      ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//      ERROR_INVALID_HANDLE        if can't build the variable bindings
//          SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//          SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//          SNMP_ERRORSTATUS_BADVALUE
//          SNMP_ERRORSTATUS_READONLY
//          SNMP_ERRORSTATUS_GENERR
//          SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//          SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()
//          ERROR_INVALID_PARAMETER if address is not valid

DWORD
CRawTcpDevice::SetHWAddress()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
    if ( strcmp(szHostAddress, "") == 0 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( m_pTcpMib )
    {
        char buf[MAX_SNMP_COMMUNITY_STR_LEN];

        UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR(buf), m_sztSNMPCommunity, -1);
        dwRetCode = m_pTcpMib->GetDeviceHWAddress(szHostAddress, buf, m_dSNMPDevIndex, SIZEOF_IN_CHAR(m_sztHWAddress), m_sztHWAddress);     // get the OT_DEVICE_INFO
    }

    return (dwRetCode);

}   // ::SetHWAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDescription -- returns the device description -- this is either the
//      sysDescr field, or the hrDeviceDescr if Printer MIB is implemented
//  ERROR CODES
//      Returns the manufacturer information or NULL if error

LPTSTR
CRawTcpDevice::GetDescription()
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
    if ( strcmp(szHostAddress, "") == 0 )
    {
        *m_sztDescription = '\0';
        return (m_sztDescription);
    }

    if ( m_pTcpMib )
    {
        char buf[MAX_SNMP_COMMUNITY_STR_LEN];

        UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
        dwRetCode = m_pTcpMib->GetDeviceName(szHostAddress, buf, m_dSNMPDevIndex,SIZEOF_IN_CHAR(m_sztDescription), m_sztDescription);           // get the OT_DEVICE_INFO
    }

    if ( dwRetCode != NO_ERROR )
    {
        *m_sztDescription = '\0';
    }

    return (m_sztDescription);

}   // ::GetDescription()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- given an Address, resolves the host name, and IP address
//          Add MacAddress, here
//      Error Codes:    FIX!!

DWORD
CRawTcpDevice::ResolveAddress( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    hostAddress[MAX_NETWORKNAME_LEN];
    char    szHostName[MAX_NETWORKNAME_LEN];
    char    szIPAddress[MAX_IPADDR_STR_LEN];

    CTCPTransport *pTransport;
    memset(szHostName, '\0', sizeof( szHostName ));
    memset(szIPAddress, '\0', sizeof( szIPAddress ));

    UNICODE_TO_MBCS(hostAddress, SIZEOF_IN_CHAR(hostAddress), m_sztAddress, -1);        // convert from UNICODE

    pTransport = new CTCPTransport();
    if( pTransport )
    {
        dwRetCode = pTransport->ResolveAddress(hostAddress, MAX_NETWORKNAME_LEN, szHostName, MAX_IPADDR_STR_LEN, szIPAddress );

        // convert to unicode
        MBCS_TO_UNICODE(m_sztHostName, SIZEOF_IN_CHAR(m_sztHostName), szHostName);
        MBCS_TO_UNICODE(m_sztIPAddress, SIZEOF_IN_CHAR(m_sztIPAddress), szIPAddress);

        delete pTransport;
    }
    return (dwRetCode);

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  CheckAddress -- double check the valadity of the addresses
//      Error Codes:    FIX!! -- solve for the DNS problem w/ hostname is invalid ( host name doens't work, ip address does)
//          (, and w/ no DNS

DWORD
CRawTcpDevice::CheckAddress( )
{
    DWORD   dwRetCode = NO_ERROR;
    return (dwRetCode);

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetStatus -- gets the printer status
//      Return Code: the spooler status codes, see PRINTER_INFO_2

DWORD
CRawTcpDevice::GetStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    hostName[MAX_NETWORKNAME_LEN];
    char buf[MAX_SNMP_COMMUNITY_STR_LEN];

    if (m_dSNMPEnabled)
    {
        CheckAddress();
        if ( *m_sztHostName != '\0' )
        {
            UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName ), m_sztHostName, -1);
        }
        else if ( *m_sztIPAddress != '\0' )
        {
            UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName ), m_sztIPAddress, -1);
        }

        if ( m_pTcpMib )
        {
            // get the OT_DEVICE_STATUS
            UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
            dwRetCode = m_pTcpMib->GetDeviceStatus(hostName, buf, m_dSNMPDevIndex);
        }
        return dwRetCode;
    }
    else
        return ERROR_NOT_SUPPORTED;

}   // ::GetStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus -- gets the job status
//      Return Code: the spooler status codes, see JOB_INFO_2

DWORD
CRawTcpDevice::GetJobStatus( )
{
    DWORD   dwRetCode = NO_ERROR;
    char    szHostAddress[MAX_NETWORKNAME_LEN];

    if (m_dSNMPEnabled)
    {
        dwRetCode = ResolveTransportPath( szHostAddress, SIZEOF_IN_CHAR( szHostAddress) );      // resolve the address to use -- m_sztAddress
        if ( strcmp(szHostAddress, "") == 0 )
        {
            return JOB_STATUS_ERROR;        // can't communicate w/ the device
        }

        if ( m_pTcpMib )
        {
            char buf[MAX_SNMP_COMMUNITY_STR_LEN];

            UNICODE_TO_MBCS( buf, SIZEOF_IN_CHAR( buf ), m_sztSNMPCommunity, -1);
            dwRetCode = m_pTcpMib->GetJobStatus(szHostAddress,  buf, m_dSNMPDevIndex);      // get the OT_DEVICE_STATUS
        }

        return dwRetCode;
    }
    else
        return ERROR_NOT_SUPPORTED;

}   // ::GetStatus()

///////////////////////////////////////////////////////////////////////////////
//  SetStatus -- sets the printer status
//              Returns the last printer status 0 for no - error
DWORD
CRawTcpDevice::SetStatus( LPTSTR psztPortName )
{
    DWORD          dwStatus   = NO_ERROR;
    DWORD          dwRetCode  = NO_ERROR;
    PORT_INFO_3    PortStatus = {0, NULL, 0};
    const CPortMgr *pPortMgr  = NULL;


    if( g_pfnSetPort && (pPortMgr = m_pParent->GetPortMgr()) != NULL )
    {
        if (m_dSNMPEnabled)
        {
            // GetStatus() here
            LPCTSTR lpszServer = pPortMgr->GetServerName();

            dwStatus = GetStatus();


            if ( m_pTcpMib )
            {
                m_pTcpMib->SNMPToPortStatus(dwStatus, &PortStatus );

                //
                // This calls happens in a newly created thread, which already has admin access,
                // so we do not need to impersonate client when calling SetPort ()
                //

                if (!SetPort((LPTSTR)lpszServer, psztPortName, 3, (LPBYTE)&PortStatus ))
                    return GetLastError ();

            }
            return PortStatus.dwStatus;
        }
        else
            return ERROR_NOT_SUPPORTED;

    } else
    {
        return( ERROR_INVALID_FUNCTION );
    }
}       // ::SetStatus()

///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- given an address, gets the device information: IP address,
//      host name, HW address, device type
//      Error Codes:    FIX!!

DWORD
CRawTcpDevice::GetDeviceInfo()
{
    DWORD   dwRetCode = NO_ERROR;
/*  char    hostName[MAX_NETWORKNAME_LEN];

    _tcscpy(m_sztAddress, m_sztHostName);
    ResolveAddress();       // update the IP address based on the hostname
    HWAddress();            // update the HW address based on the hostname

    if ( *m_sztHostName != '\0' )
    {
        UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName), m_sztHostName, -1);
    }
    else if ( *m_sztAddress != '\0' )
    {
        UNICODE_TO_MBCS(hostName, SIZEOF_IN_CHAR( hostName), m_sztAddress, -1);
    }

    // get the OT_DEVICE_INFO
    dwRetCode = (CPortMgr::GetTransportMgr())->GetDeviceInfo(hostName, m_sztDescription);
*/
    return (dwRetCode);

}   // ::GetDeviceInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawport.h ===
/*****************************************************************************
 *
 * $Workfile: rawport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_RAWTCPPORT_H
#define INC_RAWTCPPORT_H

#include "tcpport.h"
#include "RTcpData.h"

class CRawTcpJob;
class CRawTcpDevice;
class CRawTcpInterface;

class CRawTcpPort : public CTcpPort
#if defined _DEBUG || defined DEBUG
//	, public CMemoryDebug
#endif
{
	// methods
public:

	CRawTcpPort( );
	CRawTcpPort( LPTSTR	  IN	psztPortName,		// called through the UI port creation
				 LPTSTR	  IN	psztHostAddress, 
				 DWORD	  IN	dPortNum,
				 DWORD	  IN    dSNMPEnabled,
				 LPTSTR   IN    sztSNMPCommunity,
                 DWORD    IN    dSNMPDevIndex,
				 CRegABC  IN    *pRegistry,
                 CPortMgr IN    *pPortMgr);

	CRawTcpPort( LPTSTR	  IN	psztPortName,		// called through the registry port creation
				 LPTSTR   IN	psztHostName, 
				 LPTSTR   IN	psztIPAddr, 
				 LPTSTR   IN	psztHWAddr, 
				 DWORD    IN	dPortNum,
				 DWORD	  IN    dSNMPEnabled,
				 LPTSTR   IN    sztSNMPCommunity,
                 DWORD    IN    dSNMPDevIndex,
				 CRegABC  IN	*pRegistry,
                 CPortMgr IN    *pPortMgr);
	~CRawTcpPort();

	DWORD	StartDoc	( const LPTSTR psztPrinterName,
						  const DWORD  jobId,
						  const DWORD  level,
						  const LPBYTE pDocInfo );


private:	// attributes					
};


#endif // INC_RAWTCPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawtcp.h ===
/*****************************************************************************
 *
 * $Workfile: RawTCP.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_RAWTCP_H
#define INC_RAWTCP_H

#include "ipdata.h"
#include "rtcpdata.h"
#include "regabc.h"

#define	MAX_SUPPORTED_PORTS			4
#define SUPPORTED_PORT_1			9100
#define SUPPORTED_PORT_2			9101
#define SUPPORTED_PORT_3			9102
#define SUPPORTED_PORT_4			2501

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations


class	CPortRefABC;


// the interface for CRawTcpInterface class
class CRawTcpInterface
#if defined _DEBUG || defined DEBUG
//	, public CMemoryDebug
#endif
{
public:
    CRawTcpInterface(CPortMgr *pPortMgr);
    ~CRawTcpInterface();

    DWORD	Type();									// supported protocol information
    BOOL	IsProtocolSupported( DWORD	dwProtocol );
    BOOL	IsVersionSupported( DWORD dwVersion);

    DWORD	CreatePort( DWORD			dwProtocolType,					// port related functions
						DWORD			dwVersion,
						PPORT_DATA_1	pData,
						CRegABC			*pRegistry,
						CPortRefABC	    **pPort );					
    DWORD	CreatePort( LPTSTR		psztPortName,
						DWORD		dwProtocolType,				
						DWORD		dwVersion,
						CRegABC		*pRegistry,
						CPortRefABC	**pPort );					

    VOID	EnterCSection();
    VOID	ExitCSection();


protected:

    BOOL    GetRegistryEntry(LPTSTR		psztPortName,
							 DWORD	in	dwVersion,
                             CRegABC *pRegistry,
							 RAWTCP_PORT_DATA_1	in	*pRegData1
							 );


    DWORD	            *m_dwPort;
    DWORD	            m_dwProtocol;			// protocol type
    DWORD	            m_dwVersion;			// supported version
    CPortMgr            *m_pPortMgr;            // Port Manager that created this
private:
    CRITICAL_SECTION	m_critSect;

};	// class CRawTcpInterface


#endif	// INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\regabc.h ===
/*****************************************************************************
 *
 * $Workfile: RegABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_REGABC_H
#define INC_REGABC_H

//////////////////////////////////////////////////////////////////////////////
// registry settings

#define	DEFAULT_STATUSUPDATE_INTERVAL		10L			// 10 minutes
#define DEFAULT_STATUSUPDATE_ENABLED		TRUE		

// port manager entries
#define	PORTMONITOR_STATUS_INT		TEXT("StatusUpdateInterval")
#define	PORTMONITOR_STATUS_ENABLED  TEXT("StatusUpdateEnabled")

// per port entries
#define	PORTMONITOR_PORT_PROTOCOL    TEXT("Protocol")
#define	PORTMONITOR_PORT_VERSION     TEXT("Version")

// Port Key
#define	PORTMONITOR_PORTS			TEXT("Ports")
#define REG_CLASS					TEXT("STDTCPMON")

class CPortMgr;

class CRegABC
{
public:
//	CRegistry();
//	CRegistry(	CPortMgr  *pParent);
//	CRegistry(	const LPTSTR	pRegisterRoot, 
//				      CPortMgr  *pParent);
//	~CRegistry();

	virtual DWORD EnumeratePorts(CPortMgr *pPortMgr) = 0;

	virtual DWORD SetPortMgrSettings(const DWORD  dStatusUpdateInterval,
							         const BOOL	  bStatusUpdateEnabled ) = 0;

	virtual DWORD GetPortMgrSettings(DWORD  *dStatusUpdateInterval,
									 BOOL   *bStatusUpdateEnabled ) = 0;

	virtual DWORD SetWorkingKey( LPCTSTR	lpKey) = 0;

	virtual DWORD SetValue( LPCTSTR lpValueName,
								DWORD dwType, 
								CONST BYTE *lpData, 
								DWORD cbData ) = 0; 

	virtual DWORD QueryValue(LPTSTR lpValueName, 
							 LPBYTE  lpData, 
								 LPDWORD lpcbData ) = 0; 

	virtual DWORD FreeWorkingKey() = 0;

	virtual BOOL DeletePortEntry( LPTSTR in psztPortName) = 0;

};

#endif // INC_REGABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\rawtcp.cpp ===
/*****************************************************************************
 *
 * $Workfile: RawTCP.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "rawport.h"
#include "rawtcp.h"


///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization

//DWORD CRawTcpInterface::m_dwProtocol = PROTOCOL_RAWTCP_TYPE;
//DWORD CRawTcpInterface::m_dwVersion = PROTOCOL_RAWTCP_VERSION;
static DWORD    dwRawPorts[] = { SUPPORTED_PORT_1,
                                         SUPPORTED_PORT_2,
                                         SUPPORTED_PORT_3,
                                         SUPPORTED_PORT_4 };


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::CRawTcpInterface()

CRawTcpInterface::
CRawTcpInterface(
    CPortMgr *pPortMgr
    ) : m_dwProtocol(PROTOCOL_RAWTCP_TYPE), m_dwPort(dwRawPorts),
        m_dwVersion(PROTOCOL_RAWTCP_VERSION), m_pPortMgr(pPortMgr)
{

    InitializeCriticalSection(&m_critSect);

}   // ::CRawTcpInterface()


///////////////////////////////////////////////////////////////////////////////
//  CRawTcpInterface::~CRawTcpInterface()

CRawTcpInterface::
~CRawTcpInterface(
    VOID
    )
{
    DeleteCriticalSection(&m_critSect);

}   // ::~CRawTcpInterface()


///////////////////////////////////////////////////////////////////////////////
//  Type --

DWORD
CRawTcpInterface::
Type(
    )
{
    return m_dwProtocol;

}   // ::Type()

///////////////////////////////////////////////////////////////////////////////
//  IsProtocolSupported --

BOOL
CRawTcpInterface::
IsProtocolSupported(
    const   DWORD   dwProtocol
    )
{
    return ( (m_dwProtocol == dwProtocol) ? TRUE : FALSE );

}   // ::IsProtocolSupported()


///////////////////////////////////////////////////////////////////////////////
//  IsVersionSupported --

BOOL
CRawTcpInterface::IsVersionSupported(
    const   DWORD dwVersion
    )
{
    return ( (m_dwVersion >= dwVersion) ? TRUE : FALSE );

}   // ::IsVersionSupported()

///////////////////////////////////////////////////////////////////////////////
//  GetRegistryEntry

BOOL
CRawTcpInterface::
GetRegistryEntry(
    IN      LPTSTR              psztPortName,
    IN      DWORD               dwVersion,
    IN      CRegABC             *pRegistry,
    OUT     RAWTCP_PORT_DATA_1  *pRegData1
    )
{
    BOOL    bRet = FALSE;
    BOOL    bKeySet = FALSE;
    DWORD   dSize, dwRet;

    memset( pRegData1, 0, sizeof(RAWTCP_PORT_DATA_1) );

    if ( dwRet = pRegistry->SetWorkingKey(psztPortName) )
        goto Done;

    bKeySet = TRUE;
    //
    // Get host name
    //
    dSize = sizeof(pRegData1->sztHostName);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HOSTNAME,
                                      (LPBYTE)pRegData1->sztHostName,
                                      &dSize) )
        goto Done;

    //
    // Get IP Address
    //
    dSize = sizeof(pRegData1->sztIPAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_IPADDR,
                                       (LPBYTE)pRegData1->sztIPAddress,
                                       &dSize) )
        goto Done;

    //
    // Get Hardware address
    //
    dSize = sizeof(pRegData1->sztHWAddress);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_HWADDR,
                                       (LPBYTE)pRegData1->sztHWAddress,
                                       &dSize) )
        goto Done;

    //
    // Get the port number (ex: 9100, 9101)
    //
    dSize = sizeof(pRegData1->dwPortNumber);
    if ( dwRet = pRegistry->QueryValue(PORTMONITOR_PORTNUM,
                                       (LPBYTE)&(pRegData1->dwPortNumber),
                                       &dSize) )
        goto Done;

    //
    // Get SNMP status enabled flag
    //
    dSize = sizeof(pRegData1->dwSNMPEnabled);
    if ( dwRet = pRegistry->QueryValue(SNMP_ENABLED,
                                       (LPBYTE)&(pRegData1->dwSNMPEnabled),
                                       &dSize) )
        goto Done;

    //
    // Get SNMP device index
    //
    dSize = sizeof(pRegData1->dwSNMPDevIndex);
    if ( dwRet = pRegistry->QueryValue(SNMP_DEVICE_INDEX,
                                      (LPBYTE)&(pRegData1->dwSNMPDevIndex),
                                      &dSize) )
        goto Done;

    //
    // Get SNMP community
    //
    dSize = sizeof(pRegData1->sztSNMPCommunity);
    if ( dwRet = pRegistry->QueryValue(SNMP_COMMUNITY,
                                       (LPBYTE)&(pRegData1->sztSNMPCommunity),
                                       &dSize) )
        goto Done;

    bRet = TRUE;

    Done:
       if ( bKeySet )
           pRegistry->FreeWorkingKey();

       if ( !bRet )
           SetLastError(dwRet);


    return bRet;

}   // GetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CRawTcpInterface::CreatePort(
    IN      DWORD           dwProtocol,
    IN      DWORD           dwVersion,
    IN      PPORT_DATA_1    pData,
    IN      CRegABC         *pRegistry,
    OUT     CPortRefABC     **pPort )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    //
    // is the protocol type supported?
    //
    if ( !IsProtocolSupported(dwProtocol) ) {

        dwRetCode = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    //
    // Is the version supported??
    //
    if ( !IsVersionSupported(dwVersion) ) {

        dwRetCode = ERROR_INVALID_LEVEL;
        goto Done;
    }

    //
    // create the port
    //
    switch (dwVersion) {

        case    PROTOCOL_RAWTCP_VERSION: {

            CRawTcpPort *pRawTcpPort = new CRawTcpPort( pData->sztPortName,
                                                        pData->sztHostAddress,
                                                        pData->dwPortNumber,
                                                        pData->dwSNMPEnabled,
                                                        pData->sztSNMPCommunity,
                                                        pData->dwSNMPDevIndex,
                                                        pRegistry,
                                                        m_pPortMgr);
            if (pRawTcpPort) {
                pRawTcpPort->SetRegistryEntry(pData->sztPortName,
                                              dwProtocol,
                                              dwVersion,
                                              (LPBYTE)pData );
                *pPort = pRawTcpPort;
            } else {
                pPort = NULL;
            }
            break;
        }

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;

    }   // end::switch

Done:
    ExitCSection();

    return dwRetCode;
}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  CreatePort
//  Error Codes:
//      ERROR_NOT_SUPPORTED if the port type is not supported
//      ERROR_INVALID_LEVEL if the version numbers doesn't match

DWORD
CRawTcpInterface::
CreatePort(
    IN      LPTSTR      psztPortName,
    IN      DWORD       dwProtocolType,
    IN      DWORD       dwVersion,
    IN      CRegABC     *pRegistry,
    OUT     CPortRefABC **pPort
    )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    EnterCSection();

    if ( !IsProtocolSupported(dwProtocolType) ) {
        dwRetCode = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    if ( !IsVersionSupported(dwVersion) ) {

        dwRetCode = ERROR_INVALID_LEVEL;
        goto Done;
    }

    switch (dwVersion) {

        case    PROTOCOL_RAWTCP_VERSION: {

            RAWTCP_PORT_DATA_1  regData1;

            //
            // read the registry entry & parse the data
            // then call the CRawTcpPort
            //
            if ( !GetRegistryEntry(psztPortName,
                                   dwVersion,
                                   pRegistry,
                                   &regData1) ) {

                if ( (dwRetCode = GetLastError()) == ERROR_SUCCESS )
                    dwRetCode = STG_E_UNKNOWN;
                    goto Done;
            }

            //
            // fill in the port name
            //
            StringCchCopy (regData1.sztPortName, COUNTOF (regData1.sztPortName), psztPortName);
            *pPort = new CRawTcpPort(
                                               regData1.sztPortName,
                                               regData1.sztHostName,
                                               regData1.sztIPAddress,
                                               regData1.sztHWAddress,
                                               regData1.dwPortNumber,
                                               regData1.dwSNMPEnabled,
                                               regData1.sztSNMPCommunity,
                                               regData1.dwSNMPDevIndex,
                                               pRegistry,
                                               m_pPortMgr);

                bRet = TRUE;
            break;
        }

        default:
            dwRetCode = ERROR_INVALID_PARAMETER;

    }   // end::switch

Done:
    ExitCSection();

    if ( !bRet && (dwRetCode = GetLastError()) != ERROR_SUCCESS )
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;


    return dwRetCode;
}   // ::CreatePort()


///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

void
CRawTcpInterface::
EnterCSection()
{
    EnterCriticalSection(&m_critSect);

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

void
CRawTcpInterface::
ExitCSection()
{
    LeaveCriticalSection(&m_critSect);
}   //  ::ExitCSection()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HPSPPMon.rc
//
#define     IDS_STRING_SPOOLING                             1001
#define     IDS_STRING_PRINTING                             1002
#define     IDS_STRING_ERROR_OR_BUSY                        1003
#define     IDS_DISK_FULL                   2044

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpjob.h ===
/*****************************************************************************
 *
 * $Workfile: tcpjob.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPJOB_H
#define INC_TCPJOB_H

#include "jobABC.h"

#define DEFAULT_TIMEOUT_DELAY       10000L      // 10 sec
#define DEFAULT_CONNECT_DELAY       5000L       // 5 Sec
#define CONNECT_TIMEOUT             60L         // 60 Sec

#define WAIT_FOR_ACK_TIMEOUT        5*60        // 5 minutes
#define WAIT_FOR_ACK_INTERVAL       5           // 5 seconds

#define WRITE_TIMEOUT               90 * 1000   // 90 seconds
#define WRITE_CHECK_INTERVAL        5  * 1000   // 5 seconds

#define STATUS_CONNECTED            0x01
#define STATUS_ABORTJOB             0x02

class CTcpPort;
class CMemoryDebug;

class CTcpJob : public CJobABC
#if defined _DEBUG || defined DEBUG
    , public CMemoryDebug
#endif
{
public:
    enum EJobType
    {
        kRawJob,
        kLPRJob
    };

    CTcpJob();
    CTcpJob(LPTSTR      psztPrinterName,
            DWORD       jobId,
            DWORD       level,
            LPBYTE      pDocInfo,
            CTcpPort   *pParent,
            EJobType    kJobType);
    ~CTcpJob();

    virtual DWORD
    Write(
        LPBYTE  pBuffer,
        DWORD     cbBuf,
          LPDWORD pcbWritten);

    virtual DWORD
    StartDoc();

    virtual DWORD
    EndDoc();

protected:
    VOID    Restart();
    DWORD   SetStatus(DWORD dwStatus);
    BOOL    IsJobAborted (VOID);
    DWORD GetJobStatus (PDWORD pdwJobStatus);

    //
    // Member variables
    //
    CTcpPort    *m_pParent;
    DWORD   m_dwFlags;
    DWORD   m_dJobId;
    DWORD   m_cbSent;        // count of bytes sent

    TCHAR   m_sztPrinterName[MAX_PRINTERNAME_LEN];
    HANDLE  m_hPrinter;     // printer handle

    LPBYTE  m_pDocInfo;
    DWORD   m_dwCurrJobStatus;

private:
    DWORD   WaitForAllPendingDataToBeSent(DWORD       dwEndTime,
                                          LPDWORD     pcbPending);

    EJobType    m_kJobType;
};


#endif // INC_TCPJOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpjob.cpp ===
/*****************************************************************************
 *
 * $Workfile: tcpjob.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "tcpport.h"
#include "tcpjob.h"
#include "rawdev.h"

///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::CTcpJob()

CTcpJob::CTcpJob()
{
    m_pParent = NULL;

}   // ::CTcpJob()


///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::CTcpJob()
//      Called by CPort when StartDocPort is called
//  FIX: necessary constructors for creating new jobs

CTcpJob::CTcpJob(LPTSTR in psztPrinterName,
                 DWORD  in jobId,
                 DWORD  in level,
                 LPBYTE  in pDocInfo,
                 CTcpPort   in *pParent,
                 EJobType in kJobType) :
    m_pParent(pParent), m_dJobId(jobId), m_dwFlags(0),
    m_hPrinter(NULL), m_dwCurrJobStatus(0), m_cbSent(0), m_pDocInfo(pDocInfo),
    m_kJobType (kJobType)
{
    lstrcpyn(m_sztPrinterName, psztPrinterName, MAX_PRINTERNAME_LEN);
}   // ::CTcpJob()


///////////////////////////////////////////////////////////////////////////////
//  CTcpJob::~CTcpJob()
//      Called by CPort when EndDocPort is called
//  FIX: clean up CTcpJob

CTcpJob::~CTcpJob()
{
    if ( m_dwFlags & STATUS_CONNECTED ) {
        (m_pParent->GetDevice())->Close();      // close device connection
    }

    if ( m_hPrinter ) {
        //
        // Quit before the job was done.
        //
        ClosePrinter( m_hPrinter );
        m_hPrinter = NULL;
    }

}   // ::~CTcpJob()
BOOL
CTcpJob::
IsJobAborted(
    VOID
    )
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted.

--*/
{
    DWORD dwStatus = 0;
    return (GetJobStatus (&dwStatus) == ERROR_SUCCESS) &&
           ((dwStatus & JOB_STATUS_DELETING) || (dwStatus & JOB_STATUS_DELETED));

    //
    //  The previous code treated restart as cancel, which caused big restarted job
    //  being aborted, so let's remove the following
    //
    //  (pJobInfo->Status & JOB_STATUS_RESTART);
    //
}

DWORD
CTcpJob::WaitForAllPendingDataToBeSent(
    DWORD       dwEndTime,
    LPDWORD     pcbPending
    )
{
    DWORD   dwRet = NO_ERROR;

    *pcbPending = 0;

    do {

        //
        // From WritePort or EndDocPort?
        //
        if ( dwEndTime != INFINITE ) {

            //
            // If we hit the timeout need to return to spooler
            //
            if ( GetTickCount() >= dwEndTime ) {

                dwRet = WSAEWOULDBLOCK;
                //
                // This means our write is timing out. To guarantee users can
                // delete jobs within the WRITE_TIMEOUT period, and more
                // importantly we can shutdown the cluster we should not
                // wait any longer to close the connection if spooler has
                // marked the job for aborting
                //
                if ( IsJobAborted() )
                    m_dwFlags |= STATUS_ABORTJOB;
                goto Done;
            }
        } else {

            //
            // During EndDoc if job is deleted OR RESTARTED no need to wait. Last WritePort
            // would have already waited for timeout period
            //
            DWORD dwJobStatus = 0;
            if (GetJobStatus (&dwJobStatus) == ERROR_SUCCESS &&
                (dwJobStatus & (JOB_STATUS_DELETING | JOB_STATUS_DELETED | JOB_STATUS_RESTART)))
            {
                dwRet = ERROR_PRINT_CANCELLED;
                goto Done;
            }
        }


        dwRet = m_pParent->GetDevice()->PendingDataStatus(
                                    WRITE_CHECK_INTERVAL, pcbPending);


        //
        //  If it is a LPR job, we need to check if there is anything
        //  coming back in the middle of writing.
        //
        if (m_kJobType == kLPRJob && dwRet == ERROR_SUCCESS && *pcbPending != 0)
        {
            //
            // This is the loop condition, we need to check if there is anything to
            // receive, if so, we need to set the correct return code and break the
            // loop
            //

            //
            // Check if there is any data to receive
            //
            if (NO_ERROR == m_pParent->GetDevice()->ReadDataAvailable ()) {

                //
                //  This is the case where there are more pending data
                //  to wait, so we must set the return code to WSAEWOULDBLOCK
                //
                dwRet = WSAEWOULDBLOCK;
            }
        }

    } while ( dwRet == ERROR_SUCCESS && *pcbPending != 0 );

Done:
    return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
//  Write -- Called by CPort->Write()
//      Error codes:
//          NO_ERROR if no error
//          TIMEOUT if timed out
//  FIX: setup Write operation & error codes

DWORD
CTcpJob::Write( LPBYTE  in      pBuffer,
                DWORD   in      cbBuf,
                LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR, dwPending, dwEndTime;

    *pcbWritten = 0;

    if ( m_dwFlags & STATUS_ABORTJOB )
        return ERROR_PRINT_CANCELLED;

    if ( !(m_dwFlags & STATUS_CONNECTED) ) {

        Restart();
        dwRetCode = ERROR_PRINT_CANCELLED;
        goto Done;
    }

    dwEndTime = GetTickCount() + WRITE_TIMEOUT;

    //
    // First check for any pending I/O from last call to Write
    //
    dwRetCode = WaitForAllPendingDataToBeSent(dwEndTime, &dwPending);

    if ( dwRetCode != ERROR_SUCCESS )
        goto Done;

    _ASSERTE(dwPending == 0);

    dwRetCode = (m_pParent->GetDevice())->Write(pBuffer, cbBuf, pcbWritten);

    m_cbSent += *pcbWritten;

    if ( dwRetCode == NO_ERROR ) {

        SetStatus(JOB_STATUS_PRINTING);
        dwRetCode = WaitForAllPendingDataToBeSent(dwEndTime, &dwPending);
    }


Done:
    if ( dwRetCode != ERROR_SUCCESS ) {

        SetStatus(JOB_STATUS_ERROR);

        //
        // This would cause job to be restarted
        //
        if ( dwRetCode != WSAEWOULDBLOCK )
            m_dwFlags &= ~STATUS_CONNECTED;
    }

    return dwRetCode;
}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  StartDoc -- connects to the device. If the connect failes, it retries
//
//      Error Codes -- FIX
//          NO_ERROR if no error
//          ERROR_WRITE_FAULT   if Winsock returns WSAECONNREFUSED
//          ERROR_BAD_NET_NAME   if cant' find the printer on the network

DWORD
CTcpJob::StartDoc()
{
    DWORD   dwRetCode = NO_ERROR;
    time_t  lStartConnect = time( NULL );

    if ( !m_hPrinter && !OpenPrinter(m_sztPrinterName, &m_hPrinter, NULL) )
        return GetLastError();

    if ( m_dwFlags & STATUS_CONNECTED ) {

        m_dwFlags &= ~STATUS_CONNECTED;
        m_pParent->GetDevice()->Close();
    }

    do {

        if ( (dwRetCode = (m_pParent->GetDevice())->Connect()) == NO_ERROR ) {

            m_dwFlags  |= STATUS_CONNECTED;
            goto Done;
        }

        //
        // Map known errors to meaningful messages
        //
        if ( dwRetCode == ERROR_INVALID_PARAMETER )
            dwRetCode = ERROR_BAD_NET_NAME;     // bad network name

        //
        // We will try a job for upto CONNECT_TIMEOUT time without retry/cancel
        // but checking for the case user decided to restart the job
        //
        if ( time(NULL) > lStartConnect + CONNECT_TIMEOUT )
            goto Done;

        if ( IsJobAborted() ) {

            dwRetCode = ERROR_PRINT_CANCELLED;
            break;
        }
        Sleep(DEFAULT_CONNECT_DELAY);
    } while ( TRUE );

Done:
    if ( dwRetCode != NO_ERROR )
        SetStatus(JOB_STATUS_ERROR);

    m_cbSent = 0;

    return dwRetCode;

}   //  :: StartDoc()

///////////////////////////////////////////////////////////////////////////////
//  EndDoc -- closes the previous connection w/ device
//  Error Codes:
//      NO_ERROR if successful

DWORD
CTcpJob::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR, dwWaitTime, dwPending;

    if ( !(m_dwFlags & STATUS_ABORTJOB) )
        dwRetCode = WaitForAllPendingDataToBeSent(INFINITE, &dwPending);
    else
        dwRetCode = ERROR_PRINT_CANCELLED;

    //
    // Unless the job got cancelled we need to wait for ACK from printer
    // to complete the job ok
    //
    if ( m_cbSent != 0  && dwRetCode == ERROR_SUCCESS ) {

        for ( dwWaitTime = 0 ;
              !IsJobAborted() && dwWaitTime < WAIT_FOR_ACK_TIMEOUT ;
              dwWaitTime += WAIT_FOR_ACK_INTERVAL ) {

            dwRetCode = m_pParent->GetDevice()->GetAckBeforeClose(WAIT_FOR_ACK_INTERVAL);

            //
            // Normal case is ERROR_SUCCESS
            // WSAEWOULDBLOCK means printer is taking longer to process the job
            // other cases mean we need to resubmit the job. If the other side simply
            // resets the connection, however, since we have made sure we have sent all of
            // the data (if we are not aborting the job), then we shouldn't restart it.
            //
            if ( dwRetCode == ERROR_SUCCESS || dwRetCode == WSAECONNRESET)
                break;
            else if ( dwRetCode != WSAEWOULDBLOCK ) {

                Restart();
                break;
            }
        }
    }

    dwRetCode = (m_pParent->GetDevice())->Close();      // close device connection
    m_dwFlags &= ~STATUS_CONNECTED;

    // delete the job from the spooler
    if (m_hPrinter)
    {

        //
        // Clear any job bits we set before
        //
        SetStatus(0);

        SetJob( m_hPrinter, m_dJobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER );
        ClosePrinter(m_hPrinter);
        m_hPrinter = NULL;
    }

    return dwRetCode;
}   //  ::EndDoc()


///////////////////////////////////////////////////////////////////////////////
//  SetStatus -- gets & sets the printer job status
//
DWORD
CTcpJob::SetStatus( DWORD   in  dwStatus )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD               cbNeeded = 0;
    JOB_INFO_1  *pJobInfo;

    if( m_dwCurrJobStatus != dwStatus ) {

        //
        // We need to kick off SNMP status
        // Also this gets called at the first write of the job so the status
        // thread knows it needs to wake up earlier than 10 minutes
        //
        CDeviceStatus::gDeviceStatus().SetStatusEvent();

        m_dwCurrJobStatus = dwStatus;

        // Get the current job info.  Use this info to set the new job status.
        GetJob( m_hPrinter, m_dJobId, 1, NULL, 0, &cbNeeded );

        if( pJobInfo = (JOB_INFO_1 *)malloc( cbNeeded ) )
        {
            if (GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, cbNeeded, &cbNeeded))
            {
                pJobInfo->Position = JOB_POSITION_UNSPECIFIED;
                pJobInfo->Status = dwStatus;

                SetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, 0);
            }
            free( pJobInfo );
        }
    }

    return dwRetCode;

}   // ::SetStatus()

///////////////////////////////////////////////////////////////////////////////
//  Restart -- restarts the job
//
void
CTcpJob::Restart()
{
    if ( m_hPrinter && (m_dJobId != 0) )
    {// FIX check the return code of the set job
        SetJob(m_hPrinter, m_dJobId, 0, NULL, JOB_CONTROL_RESTART);

        _RPT1(_CRT_WARN, "TcpJob -- Restarting the Job (ID %d)\n", m_dJobId );

    }

}   // ::Restart()

DWORD CTcpJob::
GetJobStatus (
    OUT PDWORD pdwJobStatus
    )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    DWORD dwNeeded = 0;
    LPJOB_INFO_1 pJobInfo = NULL;
    if (!GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwNeeded))
    {
        if ((dwRetVal = GetLastError ()) == ERROR_INSUFFICIENT_BUFFER)
        {
            dwRetVal = (pJobInfo = (LPJOB_INFO_1) LocalAlloc(LPTR, dwNeeded)) ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
        }
    }
    if (dwRetVal == ERROR_SUCCESS &&
        !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded))
    {
        dwRetVal = GetLastError ();
    }
    if (dwRetVal == ERROR_SUCCESS && pdwJobStatus)
    {
        *pdwJobStatus = pJobInfo->Status;
    }
    if ( pJobInfo )
    {
        LocalFree(pJobInfo);
    }
    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpport.cpp ===
/*****************************************************************************
 *
 * $Workfile: tcpport.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "rawdev.h"
#include "rawtcp.h"
#include "tcpport.h"

///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::CTcpPort()    -- called when creating a new port through the UI

CTcpPort::CTcpPort( LPTSTR in   psztPortName,
                          LPTSTR in psztHostAddress,
                          DWORD  in dPortNum,
                          DWORD  in dSNMPEnabled,
                          LPTSTR in sztSNMPCommunity,
                          DWORD  in dSNMPDevIndex,
                          CRegABC in *pRegistry,
                          CPortMgr in *pPortMgr ) :
                                        m_dwStatus( NO_ERROR ),
                                        m_pJob( NULL ),
                                        m_pDevice( NULL ),
                                        m_lLastUpdateTime(0),
                                        m_pRegistry( pRegistry ),
                                        m_pPortMgr(pPortMgr)
{
    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);
    m_pDevice = new CRawTcpDevice(psztHostAddress,
                                  dPortNum,
                                  dSNMPEnabled,
                                  sztSNMPCommunity,
                                  dSNMPDevIndex,
                                  this);
}   // ::CTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::CTcpPort() -- called when creating a new port through the
//      registry entries.

CTcpPort::CTcpPort( LPTSTR in   psztPortName,
                    LPTSTR in   psztHostName,
                    LPTSTR in   psztIPAddr,
                    LPTSTR in   psztHWAddr,
                    DWORD  in   dPortNum,
                    DWORD    in dSNMPEnabled,
                    LPTSTR in sztSNMPCommunity,
                    DWORD  in dSNMPDevIndex,
                    CRegABC in *pRegistry,
                    CPortMgr in *pPortMgr) :
                                        m_dwStatus( NO_ERROR ),
                                        m_pJob( NULL ),
                                        m_pDevice( NULL ),
                                        m_lLastUpdateTime( 0 ),
                                        m_pRegistry( pRegistry ),
                                        m_pPortMgr(pPortMgr)
{
    lstrcpyn(m_szName, psztPortName, MAX_PORTNAME_LEN);
    m_pDevice = new CRawTcpDevice(psztHostName,
                                  psztIPAddr,
                                  psztHWAddr,
                                  dPortNum,
                                  dSNMPEnabled,
                                  sztSNMPCommunity,
                                  dSNMPDevIndex,
                                  this);
}   // ::CTcpPort()


///////////////////////////////////////////////////////////////////////////////
//  CTcpPort::~CTcpPort()
//      Called by CPortMgr when deleting a port

CTcpPort::~CTcpPort()
{
    if (m_pJob)
    {
        delete m_pJob;
        m_pJob = NULL;
    }
    if (m_pDevice)
    {
        delete m_pDevice;
        m_pDevice = NULL;
    }
}   // ::~CPort

///////////////////////////////////////////////////////////////////////////////
//  Write
//      Error codes:
//          NO_ERROR if succesfull
//  FIX: complete Write processing & define how it relates to a job

DWORD
CTcpPort::Write( LPBYTE in      pBuffer,
                    DWORD   in      cbBuf,
                    LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = m_pJob->Write(pBuffer, cbBuf, pcbWritten);

    return(dwRetCode);

}   // ::Write()


///////////////////////////////////////////////////////////////////////////////
//  EndDoc
//      Error codes:
//          NO_ERROR if succesfull

DWORD
CTcpPort::EndDoc()
{
    DWORD   dwRetCode = NO_ERROR;

    _RPT1(_CRT_WARN, "PORT -- (CTcpPort) EndDoc called for (%S)\n",m_szName );

    if ( m_pJob ) {

        dwRetCode = m_pJob->EndDoc();       // finish processing the print job
        delete m_pJob;
        m_pJob = NULL;
    }

    return(dwRetCode);

}   // ::EndDoc


///////////////////////////////////////////////////////////////////////////////
//  SetRegistryEntry

DWORD
CTcpPort::SetRegistryEntry( LPCTSTR     in  psztPortName,
                            const DWORD in  dwProtocol,
                            const DWORD in  dwVersion,
                            const LPBYTE in pData)
{
    DWORD   dwRetCode = NO_ERROR;

    // create the port
    switch (dwVersion)
    {
        case    PROTOCOL_RAWTCP_VERSION:        // ADDPORT_DATA_1
        {
            PPORT_DATA_1 pPortData = (PPORT_DATA_1)pData;

            _ASSERTE( _tcscmp(psztPortName, pPortData->sztPortName) == 0 );

            UpdateRegistryEntry( psztPortName,
                                 dwProtocol,
                                 dwVersion );


            break;
        }

    }   // end::switch

    return (dwRetCode);

}   // ::SetRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  UpdateRegistryEntry

DWORD
CTcpPort::UpdateRegistryEntry( LPCTSTR psztPortName,
                               DWORD dwProtocol,
                               DWORD dwVersion )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwSize = 0;
    BOOL    bKeySet = FALSE;
    TCHAR   *psztTemp = NULL;
    DWORD   dwSNMPDevIndex = 0;
    DWORD   dwSNMPEnabled = 0;
    DWORD   dwPortNum = 0;

    if( dwRetCode = m_pRegistry->SetWorkingKey(psztPortName))
        goto Done;

    bKeySet = TRUE;

    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORT_PROTOCOL,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwProtocol,
                                          sizeof(DWORD)))
        goto Done;

    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORT_VERSION,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwVersion,
                                          sizeof(DWORD)))
        goto Done;


    psztTemp = m_pDevice->GetHostName();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_HOSTNAME,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                           dwSize))
        goto Done;

    psztTemp = m_pDevice->GetIPAddress();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_IPADDR,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    psztTemp = m_pDevice->GetHWAddress();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_HWADDR,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    dwPortNum = m_pDevice->GetPortNumber();
    if( dwRetCode = m_pRegistry->SetValue(PORTMONITOR_PORTNUM,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwPortNum,
                                          sizeof(DWORD)))
        goto Done;

    // Snmp Status keys
    psztTemp = m_pDevice->GetSNMPCommunity();
    dwSize = ( (_tcslen(psztTemp) +1) * sizeof(TCHAR));
    if( dwRetCode = m_pRegistry->SetValue(SNMP_COMMUNITY,
                                          REG_SZ,
                                          (LPBYTE)psztTemp,
                                          dwSize ))
        goto Done;

    dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    if( dwRetCode = m_pRegistry->SetValue(SNMP_ENABLED,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwSNMPEnabled,
                                          sizeof(DWORD) ))
        goto Done;

    dwSNMPDevIndex = m_pDevice->GetSNMPDevIndex();
    if( dwRetCode = m_pRegistry->SetValue(SNMP_DEVICE_INDEX,
                                          REG_DWORD,
                                          (CONST BYTE *)&dwSNMPDevIndex,
                                          sizeof(DWORD)))
        goto Done;

Done:
   if ( bKeySet )
       m_pRegistry->FreeWorkingKey();

   if ( dwRetCode )
       SetLastError(dwRetCode);

    return (dwRetCode);

}   // ::UpdateRegistryEntry()


///////////////////////////////////////////////////////////////////////////////
//  InitConfigPortUI --

DWORD
CTcpPort::InitConfigPortUI( const DWORD in  dwProtocolType,
                               const DWORD  in  dwVersion,
                               LPBYTE       out pData)
{
    DWORD   dwRetCode = NO_ERROR;
    PPORT_DATA_1    pPortData = (PPORT_DATA_1) pData;

    lstrcpyn(pPortData->sztIPAddress, m_pDevice->GetIPAddress(), MAX_IPADDR_STR_LEN);
//  _tcscpy(pPortData->sztHardwareAddress, m_pDevice->GetHWAddress());
//  _tcscpy(pPortData->sztDeviceType, m_pDevice->GetDescription());

    lstrcpyn(pPortData->sztSNMPCommunity, m_pDevice->GetSNMPCommunity(), MAX_SNMP_COMMUNITY_STR_LEN);
    lstrcpyn(pPortData->sztPortName, GetName(), MAX_PORTNAME_LEN);
    lstrcpyn(pPortData->sztHostAddress, m_pDevice->GetHostAddress(), MAX_NETWORKNAME_LEN);
    pPortData->dwVersion = dwVersion;
    pPortData->dwProtocol = dwProtocolType;
    pPortData->dwPortNumber = m_pDevice->GetPortNumber();
    pPortData->dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    pPortData->dwSNMPDevIndex = m_pDevice->GetSNMPDevIndex();

    return (dwRetCode);

}   // ::InitConfigPortUI()

///////////////////////////////////////////////////////////////////////////////
//  SetDeviceStatus --

DWORD
CTcpPort::SetDeviceStatus( )
{
    m_dwStatus = m_pDevice->SetStatus( m_szName );

    m_lLastUpdateTime = time(NULL);

    return( m_dwStatus );
}

///////////////////////////////////////////////////////////////////////////////
// NextStatusUpdate --

time_t
CTcpPort::NextUpdateTime()
{
    LONG lUpdateInterval = CDeviceStatus::gDeviceStatus().GetStatusUpdateInterval();
    time_t lNextUpdateTime;
    CHAR    buf[250];

    //
    // If snmp is not enabled then return 1 hour (something very big)
    //
    if ( !m_pDevice->GetSNMPEnabled() )
        return  60 * 60; // One hour


    if( m_lLastUpdateTime == 0 )
        return 0;
    //
    // Calculate the next time a status is needed
    //

    if ( m_dwStatus )
        lUpdateInterval /= STATUS_ERROR_TIMEOUT_FACTOR;
    else if ( m_pJob )
        lUpdateInterval /= STATUS_PRINTING_TIMEOUT_FACTOR;

    lNextUpdateTime = lUpdateInterval + m_lLastUpdateTime - time(NULL);

    //
    // if the next update time has passed then pass a zero indicating that
    // an update should occur now.
    //
    if( lNextUpdateTime < 0 )
        lNextUpdateTime = 0;

    return lNextUpdateTime;
}

///////////////////////////////////////////////////////////////////////////////
//  SNMP Port Info --

DWORD
CTcpPort::GetSNMPInfo( PSNMP_INFO pData )
{
    DWORD   dwRetCode = NO_ERROR;

    lstrcpyn(pData->sztAddress, m_pDevice->GetHostAddress(), MAX_NETWORKNAME_LEN);
    lstrcpyn(pData->sztSNMPCommunity, m_pDevice->GetSNMPCommunity(), MAX_SNMP_COMMUNITY_STR_LEN);
    pData->dwSNMPEnabled = m_pDevice->GetSNMPEnabled();
    pData->dwSNMPDeviceIndex = m_pDevice->GetSNMPDevIndex();

    return (dwRetCode);

}   // ::InitConfigPortUI()


DWORD
CTcpPort::
ClearDeviceStatus(
    )
{
    DWORD   dwRet = NO_ERROR;
    PORT_INFO_3             PortStatus = {0, NULL, 0};

    if( !m_pDevice->GetSNMPEnabled() && m_pPortMgr)
    {
        BOOL bRet = FALSE;
        HANDLE hToken = RevertToPrinterSelf();

        if (hToken) {
            if (SetPort((LPTSTR)m_pPortMgr->GetServerName(), m_szName, 3, (LPBYTE)&PortStatus ))
                bRet = TRUE;

            if (!ImpersonatePrinterClient(hToken))
                bRet = FALSE;
        }

        if (!bRet)
            dwRet = GetLastError ();
    }

    return( dwRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpmon.cpp ===
/*****************************************************************************
 *
 * $Workfile: TcpMon.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company & Microsoft.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/
#include "precomp.h"    // pre-compiled header
#include "event.h"
#include "portmgr.h"
#include "message.h"



///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

#ifndef MODULE

#define MODULE "TCPMON: "

#endif


#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_PORT, DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif

HINSTANCE                       g_hInstance = NULL;
CPortMgr                        *g_pPortMgr = NULL;

int g_cntGlobalAlloc=0;         // used for debugging purposes
int g_csGlobalCount=0;

// TcpMib Library Instance
HINSTANCE       g_hTcpMib = NULL;
HINSTANCE   g_hSpoolLib = NULL;
SETPORTPARAM g_pfnSetPort = NULL;
ENUMPORTPARAM g_pfnEnumPorts = NULL;

///////////////////////////////////////////////////////////////////////////////
//  DllMain
//

BOOL APIENTRY
DllMain (       HANDLE in hInst,
            DWORD  in dwReason,
            LPVOID in lpReserved )
{
    WSADATA wsaData;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInst );

//          InitDebug(MON_DEBUG_FILE);            // initialize debug file

            g_hInstance = (HINSTANCE) hInst;

            // Start up Winsock.
            if ( WSAStartup(WS_VERSION_REQUIRED, (LPWSADATA)&wsaData) != NO_ERROR)
            {
                _RPT1(_CRT_WARN, "CSSOCKET -- CStreamSocket() WSAStartup failed! Error( %d )\n", WSAGetLastError());
                return FALSE;
            }

            // See if the DLL and the app each support a common version.
            // Check to make sure that the version the DLL returns in wVersion
            // is at least enough to satisfy the applications needs.
            if ( HIBYTE(wsaData.wVersion) < WS_VERSION_MINOR ||
                (HIBYTE(wsaData.wVersion) == WS_VERSION_MAJOR &&
                 LOBYTE(wsaData.wVersion) < WS_VERSION_MINOR) )
            {
                _RPT0(_CRT_WARN, "CSSOCKET -- CStreamSocket()  -- DLL version not supported\n");
                return FALSE;
            }

            g_hSpoolLib = ::LoadLibrary(TEXT("spoolss.dll"));
            if(g_hSpoolLib == NULL)
            {
                _RPT0(_CRT_WARN, "spoolss.dll Not Found\n");
                return FALSE;
            }

            // Note that these can be NULL we accept this here and check later
            // When they are used.
            g_pfnSetPort = (SETPORTPARAM)::GetProcAddress(g_hSpoolLib, "SetPortW");
            g_pfnEnumPorts = (ENUMPORTPARAM)::GetProcAddress(g_hSpoolLib, "EnumPortsW");

            // startup the event log
            EventLogOpen( SZEVENTLOG_NAME, LOG_SYSTEM, TEXT("%SystemRoot%\\System32\\tcpmon.dll") );

            return TRUE;

        case DLL_PROCESS_DETACH:
            if (WSACleanup() == SOCKET_ERROR)
            {
                EVENT_LOG0(EVENTLOG_INFORMATION_TYPE, SOCKETS_CLEANUP_FAILED);
            }

            if( g_hTcpMib != NULL )
            {
                FreeLibrary(g_hTcpMib);
            }

            if( g_hSpoolLib != NULL )
            {
                FreeLibrary(g_hSpoolLib);
            }
            DeInitDebug();          // close the debug file

            EventLogClose();        // close the event log

            return TRUE;

    }

    return FALSE;

}       // DllMain()


///////////////////////////////////////////////////////////////////////////////
//  ValidateHandle -- Checks to see if the handle is for an HP Port
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
ValidateHandle(
    IN      HANDLE      handle)
{
    PHPPORT pHPPort = (PHPPORT) handle;
    DWORD   dwRetCode = NO_ERROR;

    //
    // verify the port handle & the signature
    //

    if (!pHPPort ||
        IsBadReadPtr (pHPPort, sizeof (PHPPORT)) ||
        pHPPort->dSignature != HPPORT_SIGNATURE) {

        dwRetCode = ERROR_INVALID_HANDLE;

    }

    return dwRetCode;
}   // ::ValidateHandle()


///////////////////////////////////////////////////////////////////////////////
//  InitializePrintMonitor2
//              Returns a MONITOR2 structure or NULL if failure
//      Error Codes:
//

LPMONITOR2
InitializePrintMonitor2( PMONITORINIT pMonitorInit,
                         PHANDLE      phMonitor )
{
    DWORD           dwRetCode=NO_ERROR;
    LPMONITOR2      pMonitor2 = NULL;
    CPortMgr        *pPortMgr = NULL;
    HANDLE          hMonitor  = NULL;
    //
    // Create the port manager if necessary
    //
    pPortMgr = new CPortMgr();    // create the port manager object
    if (!pPortMgr)
    {
        dwRetCode = ERROR_OUTOFMEMORY;
    }
    if (dwRetCode == NO_ERROR && !pPortMgr-> bValid ())
    {
        dwRetCode = ERROR_INVALID_DATA;
    }
    if (dwRetCode == NO_ERROR)
    {
        dwRetCode = pPortMgr->InitializeRegistry(pMonitorInit->hckRegistryRoot,
                                                 pMonitorInit->hSpooler,
                                                 pMonitorInit->pMonitorReg,
                                                 pMonitorInit->pszServerName);
    }
    if (dwRetCode == NO_ERROR)
    {
        dwRetCode = pPortMgr->InitializeMonitor();
    }
    if (dwRetCode == NO_ERROR)
    {
        dwRetCode = EncodeMonitorHandle( &hMonitor, pPortMgr );
    }
    if (dwRetCode == NO_ERROR)
    {
        pPortMgr->InitMonitor2( &pMonitor2 );
        *phMonitor = hMonitor;
    }
    else
    {
        pMonitor2 = NULL;
        (VOID)FreeMonitorHandle (hMonitor);
        delete pPortMgr;
        SetLastError (dwRetCode);
    }
    return (pMonitor2);

}       // InitializePrintMonitor()

///////////////////////////////////////////////////////////////////////////////
//  EncodeMoniorHandle -- Encodes the monitor handle
//      Error codes:
//          NO_ERROR if success
//          ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle

DWORD
EncodeMonitorHandle(
    PHANDLE phHandle,
    CPortMgr *pPortMgr
    )
{
    DWORD   dwRetCode = NO_ERROR;
    PMONITOR_HANDLE phMonitor = NULL;

    size_t size = sizeof(MONITOR_HANDLE);
    if ( phMonitor = (PMONITOR_HANDLE) LocalAlloc( LPTR, sizeof(MONITOR_HANDLE) ) ) {

        phMonitor->cb = sizeof(MONITOR_HANDLE);
        phMonitor->dSignature = MONITOR_SIGNATURE;
        phMonitor->pPortMgr = pPortMgr;

        *phHandle = phMonitor;
    }  else {

        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRetCode;
}   // ::EncodeMonitorHandle()

///////////////////////////////////////////////////////////////////////////////
//  ValidateMonitorHandle -- Checks to see if the handle is valid
//      Error codes:
//          NO_ERROR if successful
//          ERROR_INVALID_HANDLE if not HP port

DWORD
ValidateMonitorHandle(
    IN      HANDLE      hMonitor
    )
{
    PMONITOR_HANDLE pMonitor = (PMONITOR_HANDLE) hMonitor;
    DWORD   dwRetCode = NO_ERROR;

    if ( pMonitor )  {

        if ( pMonitor->dSignature != MONITOR_SIGNATURE ) {
            dwRetCode = ERROR_INVALID_HANDLE;
        }
    } else  {
        dwRetCode = ERROR_INVALID_HANDLE;
    }

    return dwRetCode;
}   // ::ValidateMonitorHandle()


///////////////////////////////////////////////////////////////////////////////
//  FreeHandle -- Frees the monitor handle
//      Error codes:
//          NO_ERROR if success

DWORD
FreeMonitorHandle(
    HANDLE hMonitor
    )
{
    DWORD   dwRetCode = NO_ERROR;

    LocalFree( hMonitor );

    return( dwRetCode );
}   // ::FreeHandle()

///////////////////////////////////////////////////////////////////////////////
//  ClosePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid

BOOL
ClosePort( HANDLE in hPort )
{
    DWORD           dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)
        dwRetCode = g_pPortMgr->ClosePort(hPort);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // ClosePort()


///////////////////////////////////////////////////////////////////////////////
//  StartDocPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid
//              ERROR_BUSY if the requested port is already busy
//              ERROR_WRITE_FAULT       if Winsock returns WSAECONNREFUSED
//              ERROR_BAD_NET_NAME   if cant' find the printer on the network

BOOL WINAPI
StartDocPort(   HANDLE in hPort,                        // handle of the port the job sent to
                LPTSTR in psztPrinterName,      // name of the printer the job sent to
                DWORD  in JobId,                        // ids the job
                DWORD  in Level,        // level of the struct pointed by pDocInfo
                LPBYTE in pDocInfo)     // points to DOC_INFO_1 or DOC_INFO_2 structure
 {
    DWORD   dwRetCode = NO_ERROR;

    if ( Level != 1 ) {

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)

        dwRetCode = ((PHPPORT)hPort)->pPortMgr->StartDocPort(hPort,
                                                    psztPrinterName,
                                                    JobId,
                                                    Level,
                                                    pDocInfo);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // StartDocPort()


///////////////////////////////////////////////////////////////////////////////
//  WritePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid

BOOL
WritePort(      HANDLE  in              hPort,
            LPBYTE  in              pBuffer,
            DWORD   in              cbBuf,
            LPDWORD inout   pcbWritten)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->WritePort(hPort,
                                                          pBuffer,
                                                          cbBuf,
                                                          pcbWritten);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // WritePort()


///////////////////////////////////////////////////////////////////////////////
//  ReadPort
//              Returns TRUE if success, FALSE otherwise
//      Note: ReadPort() function is not supported

BOOL
ReadPort(       HANDLE  in              hPort,
            LPBYTE  inout   pBuffer,
            DWORD   in              cbBuffer,
            LPDWORD inout   pcbRead)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->ReadPort(hPort,
                                                pBuffer,
                                                cbBuffer,
                                                pcbRead);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // ReadPort()


///////////////////////////////////////////////////////////////////////////////
//  EndDocPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE    if handle is invalid
//              ERROR_INVALID_PARAMETER if a passed paramter is invalid

BOOL WINAPI
EndDocPort( HANDLE in hPort)
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = ValidateHandle (hPort);

    if (dwRetCode == NO_ERROR)
        dwRetCode = ((PHPPORT)hPort)->pPortMgr->EndDocPort(hPort);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

}       // EndDocPort()

///////////////////////////////////////////////////////////////////////////////
//  EnumPorts
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_LEVEL             if level is not supported
//              ERROR_INVALID_HANDLE            if the passed in pointers are invalid
//              ERROR_INSUFFICIENT_BUFFER       if buffer size is small

BOOL WINAPI
EnumPorts(      LPTSTR  in              psztName,
            DWORD   in              Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
            LPBYTE  inout   pPorts, // port data is written to
            DWORD   inout   cbBuf,  // buffer size of pPorts points to
            LPDWORD inout   pcbNeeded,      // needed buffer size
            LPDWORD inout   pcReturned)     // number of structs written to pPorts
{
    DWORD   dwRetCode = NO_ERROR;

    dwRetCode = g_pPortMgr->EnumPorts(psztName, Level, pPorts, cbBuf, pcbNeeded,
                                      pcReturned);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // EnumPorts()


///////////////////////////////////////////////////////////////////////////////
//  XcvOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_NOT_SUPPORTED if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

BOOL
XcvOpenPort( LPCTSTR     in             pszObject,
             ACCESS_MASK in         GrantedAccess,
             PHANDLE         out    phXcv)
{
    DWORD dwRetCode = NO_ERROR;

    dwRetCode = g_pPortMgr->XcvOpenPort(pszObject, GrantedAccess, phXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvOpenPort()


///////////////////////////////////////////////////////////////////////////////
//  XcvClosePort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_HANDLE if handle is invalid

BOOL
XcvClosePort( HANDLE in hXcv )
{
    DWORD dwRetCode = NO_ERROR;

    dwRetCode = g_pPortMgr->XcvClosePort(hXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvClosePort()


///////////////////////////////////////////////////////////////////////////////
//  XcvDataPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_BAD_COMMAND if the pszDataName is not supported
//              ERROR_INSUFFICIENT_BUFFER if buffer size is invalid
//              ACCESS_DENIED if doesn't have sufficient rights
//              ERROR_INVALID_HANDLE if the handle is invalid

DWORD
XcvDataPort(HANDLE in       hXcv,
            PCWSTR in       pszDataName,
            PBYTE  in       pInputData,
            DWORD  in       cbInputData,
            PBYTE  out      pOutputData,
            DWORD  out      cbOutputData,
            PDWORD out      pcbOutputNeeded)
{
    DWORD dwRetCode = NO_ERROR;


    _ASSERTE(hXcv != NULL && hXcv != INVALID_HANDLE_VALUE);

    if (hXcv == NULL || hXcv == INVALID_HANDLE_VALUE) {
        dwRetCode = ERROR_INVALID_HANDLE;
    } else {
        // These should be never be possible except from a bad spooler or another bad port monitor

        dwRetCode = ((PHPPORT)hXcv)->pPortMgr->XcvDataPort(hXcv,
                                    pszDataName,
                                    pInputData,
                                    cbInputData,
                                    pOutputData,
                                    cbOutputData,
                                    pcbOutputNeeded);
    }

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
    }

    return( dwRetCode );


} // XcvDataPort()


//
//
// Clustering EntryPoints
//
//

///////////////////////////////////////////////////////////////////////////////
//  ClusterOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_PARAMETER if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null

BOOL
ClusterOpenPort( HANDLE hMonitor,
                LPTSTR  in    psztPName,
          PHANDLE inout pHandle)
{
    DWORD   dwRetCode = NO_ERROR;

    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->OpenPort(psztPName,
                                                               pHandle);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // ClusterOpenPort()

///////////////////////////////////////////////////////////////////////////////
//  ClusterEnumPorts
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_INVALID_LEVEL             if level is not supported
//              ERROR_INVALID_HANDLE            if the passed in pointers are invalid
//              ERROR_INSUFFICIENT_BUFFER       if buffer size is small

BOOL
ClusterEnumPorts( HANDLE     in     hMonitor,
                     LPTSTR  in     psztName,
                     DWORD   in     Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
                     LPBYTE  inout  pPorts, // port data is written to
                     DWORD   inout  cbBuf,  // buffer size of pPorts points to
                     LPDWORD inout  pcbNeeded,      // needed buffer size
                     LPDWORD inout  pcReturned)     // number of structs written to pPorts
{
    DWORD   dwRetCode = NO_ERROR;

    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->EnumPorts(psztName,
                                                            Level,
                                                            pPorts,
                                                            cbBuf,
                                                            pcbNeeded,
                                                            pcReturned);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }
    return TRUE;

}       // EnumPorts()

///////////////////////////////////////////////////////////////////////////////
//  ClusteringXcvOpenPort
//              Returns TRUE if success, FALSE otherwise
//      Error Codes:
//              ERROR_NOT_SUPPORTED if port object doesn't exist
//              ERROR_NOT_ENOUGH_MEMORY if can't allocate memory for handle
//              ERROR_INVALID_HANDLE if pPort is null (not used for AddPort case)

BOOL
ClusterXcvOpenPort( HANDLE      in  hMonitor,
                       LPCTSTR      in  pszObject,
                       ACCESS_MASK  in  GrantedAccess,
                       PHANDLE      out phXcv)
{
    DWORD dwRetCode = NO_ERROR;

    if( (dwRetCode = ValidateMonitorHandle( hMonitor )) != NO_ERROR)
    {
        SetLastError( dwRetCode );
        return( FALSE );
    }

    dwRetCode = ((PMONITOR_HANDLE)hMonitor)->pPortMgr->XcvOpenPort(pszObject,
                                                       GrantedAccess,
                                                       phXcv);
    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // XcvOpenPort()

VOID
ClusterShutdown( HANDLE hMonitor )
{
    if ( ((PMONITOR_HANDLE)hMonitor)->pPortMgr != NULL )
        delete ((PMONITOR_HANDLE)hMonitor)->pPortMgr;

    FreeMonitorHandle(hMonitor);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcptrans.h ===
/*****************************************************************************
 *
 * $Workfile: TCPTrans.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPTRANSPORT_H
#define INC_TCPTRANSPORT_H

class CStreamSocket;

class CTCPTransport
{
public:
    CTCPTransport();
    CTCPTransport(  const char *pHost,
					const USHORT port );
    ~CTCPTransport();

    DWORD	Connect();
    DWORD   GetAckBeforeClose(DWORD dwSeconds);
    DWORD   PendingDataStatus(DWORD     dwTimeoutInMilliseconds,
                              LPDWORD   pcbPending);

    DWORD	Write(LPBYTE	pBuffer,		
                  DWORD	cbBuf,
                  LPDWORD pcbWritten);

    DWORD   ReadDataAvailable();
    DWORD	Read(LPBYTE	pBuffer,		
                 DWORD	cbBufSize,
                 INT     iTimeOut,
                 LPDWORD pcbRead);


    BOOL	ResolveAddress();
    BOOL	ResolveAddress(LPSTR	pHostName,
                           LPSTR	pIPAddress );
    BOOL 	ResolveAddress( char   *pHost,
                            DWORD   dwHostNameBufferLength,
                            char   *pHostName,
                            DWORD   dwIpAddressBufferLength,
                            char   *pIPAddress);

private:
    DWORD	MapWinsockToAppError(const DWORD dwErrorCode );

private:
	CStreamSocket *m_pSSocket;		// stream socket class

	USHORT	m_iPort;
	char	m_szHost[MAX_NETWORKNAME_LEN];	
	struct sockaddr_in	m_remoteHost;
};


#endif // INC_TCPTRANSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcptrans.cpp ===
/*****************************************************************************
 *
 * $Workfile: TCPTrans.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "cssocket.h"
#include "csutils.h"
#include "tcptrans.h"


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::CTCPTransport()

CTCPTransport::
CTCPTransport(
    const char   *pHost,
    const USHORT port
    ) :  m_iPort(port), m_pSSocket(NULL)
{
    strncpyn(m_szHost, pHost, MAX_NETWORKNAME_LEN);

}   // ::CTCPTransport()


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::CTCPTransport()

CTCPTransport::
CTCPTransport(
    VOID
    ) : m_pSSocket(NULL)
{

    m_szHost[0] = NULL;

}   // ::CTCPTransport()


///////////////////////////////////////////////////////////////////////////////
//  CTCPTransport::~CTCPTransport()

CTCPTransport::
~CTCPTransport(
    VOID
    )
{
    if ( m_pSSocket )
        delete m_pSSocket;

}   // ::~CTCPTransport()


DWORD
CTCPTransport::
GetAckBeforeClose(
    DWORD   dwTimeInSeconds
    )
{
   return m_pSSocket ? m_pSSocket->GetAckBeforeClose(dwTimeInSeconds)
                     :  ERROR_INVALID_PARAMETER;
}


DWORD
CTCPTransport::
PendingDataStatus(
    DWORD       dwTimeInMilliSeconds,
    LPDWORD     pcbPending
    )
{
   return m_pSSocket ? m_pSSocket->PendingDataStatus(dwTimeInMilliSeconds,
                                                     pcbPending)
                     :  ERROR_INVALID_PARAMETER;
}

///////////////////////////////////////////////////////////////////////////////
//  Connect
//      Error Codes:
//          NO_ERROR if connection established
//          WinSock error if connect() failed
//          ERROR_INVALID_HANDLE if ResolveAddress failed       // FIX: error code

DWORD
CTCPTransport::
Connect(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;
    BOOL    bRet = FALSE;

    if ( !ResolveAddress() )
        return ERROR_INCORRECT_ADDRESS;

    if ( m_pSSocket )
        delete m_pSSocket;

    if ( m_pSSocket = new CStreamSocket() ) {

        //
        // Success case is if we connected
        if ( m_pSSocket->Connect(&m_remoteHost) )
            m_pSSocket->SetOptions();
        else {

            dwRetCode = ERROR_NOT_CONNECTED;
            delete m_pSSocket;
            m_pSSocket = NULL;
        }
    } else
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;


    return dwRetCode;

}   // ::Connect()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

BOOL
CTCPTransport::
ResolveAddress(
    VOID
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet =  pUSocket->ResolveAddress(m_szHost, m_iPort, &m_remoteHost);
        delete pUSocket;
    }

    return bRet;

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

BOOL
CTCPTransport::
ResolveAddress(
    IN  LPSTR   pHostName,
    OUT LPSTR   pIPAddress
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet = pUSocket->ResolveAddress(pHostName, pIPAddress);
        delete pUSocket;
    }

    return bRet;

}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress
//      Error Codes: FIX!!

BOOL
CTCPTransport::
ResolveAddress(
    IN      char   *pHost,
    IN      DWORD   dwHostNameBufferLength,
    IN OUT  char   *szHostName,
    IN      DWORD   dwIpAddressBufferLength,
    IN OUT  char   *szIPAddress
    )
{
    BOOL            bRet = FALSE;
    CSocketUtils   *pUSocket;

    if ( pUSocket = new CSocketUtils() ) {

        bRet =  pUSocket->ResolveAddress(pHost, dwHostNameBufferLength, szHostName,  dwIpAddressBufferLength, szIPAddress);
        delete pUSocket;
    }

    return bRet;
}   // ::ResolveAddress()


///////////////////////////////////////////////////////////////////////////////
//  Write --
//      Error codes
//          NO_ERROR if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
Write(
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN OUT  LPDWORD     pcbWritten
    )
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->Send((char FAR *)pBuffer, cbBuf,
                                             pcbWritten))
                      : ERROR_INVALID_HANDLE;

}   // ::Print()

///////////////////////////////////////////////////////////////////////////////
//  Read --
//      Error codes
//          RC_SUCCESS if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
ReadDataAvailable()
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->ReceiveDataAvailable())
                      : ERROR_INVALID_HANDLE;
}   // ::Read()

///////////////////////////////////////////////////////////////////////////////
//  Read --
//      Error codes
//          RC_SUCCESS if no error
//          RC_CONNECTION_RESET if connection reset
//          ERROR_INVALID_HANDLE if the socket object ! exists

DWORD
CTCPTransport::
Read(
    IN      LPBYTE      pBuffer,
    IN      DWORD       cbBuf,
    IN      INT         iTimeout,
    IN OUT  LPDWORD     pcbRead
    )
{
    //
    // pass the buffer to the Send call
    //
    return m_pSSocket ? MapWinsockToAppError(
                            m_pSSocket->Receive((char FAR *)pBuffer, cbBuf,
                                             0, iTimeout, pcbRead))
                      : ERROR_INVALID_HANDLE;
}   // ::Read()



///////////////////////////////////////////////////////////////////////////////
//  MapWinsockToAppError -- maps a given WinSock error to the application error
//          codes.
//      Error codes:
//              RC_SUCCESS no error
//              RC_CONNECTION_RESET if WSAECONNRESET

DWORD
CTCPTransport::
MapWinsockToAppError(
    IN  DWORD   dwErrorCode
    )
{
    DWORD   dwRetCode= NO_ERROR;

    switch (dwErrorCode) {

        case    NO_ERROR:
            dwRetCode = NO_ERROR;
            break;

        case    WSAECONNRESET:
        case    WSAECONNABORTED:
        case    WSAENOTSOCK:
        case    WSANOTINITIALISED:
        case    WSAESHUTDOWN:
            dwRetCode = ERROR_CONNECTION_ABORTED;
            _RPT1(_CRT_WARN,
                  "TCPTRANS -- Connection is reset for (%s)\n", m_szHost);
            break;

        case    WSAENOBUFS:
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;

        default:
            _RPT2(_CRT_WARN,
                  "TCPTRANS -- Unhandled Error (%d) for (%s)\n",
                  dwErrorCode, m_szHost);
            dwRetCode = dwErrorCode;
    }

    return dwRetCode;

}   //  ::MapWinsockToMapError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\adddone.h ===
/*****************************************************************************
 *
 * $Workfile: AddDone.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_ADDDONE_H
#define INC_ADDDONE_H

// Global Variables
extern HINSTANCE g_hInstance;

#define MAX_YESNO_SIZE 10
#define MAX_PROTOCOL_AND_PORTNUM_SIZE 20

class CSummaryDlg
{
public:
	CSummaryDlg();
	~CSummaryDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	BOOL OnFinish();
	DWORD RemoteTellPortMonToCreateThePort();
	DWORD LocalTellPortMonToCreateThePort();
	void FillTextFields(HWND hDlg);

private:
	ADD_PARAM_PACKAGE *m_pParams;

}; // CSummaryDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
INT_PTR CALLBACK SummaryDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDDONE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\adddone.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddDone.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "UIMgr.h"
#include "AddDone.h"
#include "Resource.h"
#include "TCPMonUI.h"

//
//  FUNCTION: CSummaryDlg constructor
//
//  PURPOSE:  initialize a CSummaryDlg class
//
CSummaryDlg::CSummaryDlg()
{
} // constructor


//
//  FUNCTION: CSummaryDlg destructor
//
//  PURPOSE:  deinitialize a CSummaryDlg class
//
CSummaryDlg::~CSummaryDlg()
{
} // destructor


//
//  FUNCTION: SummaryDialog(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK SummaryDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CSummaryDlg *wndDlg = NULL;

    wndDlg = (CSummaryDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CSummaryDlg;
            if( wndDlg == NULL )
                return FALSE;

            //
            // If the function succeeds, the return value is the previous value of the specified offset.
            //
            // If the function fails, the return value is zero. To get extended error
            // information, call GetLastError.
            //
            // If the previous value is zero and the function succeeds, the return value is zero,
            // but the function does not clear the last error information. To determine success or failure,
            // clear the last error information by calling SetLastError(0), then call SetWindowLongPtr.
            // Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            //

            SetLastError (0);
            if (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) && GetLastError()) {
                delete wndDlg;
                return FALSE;
            }
            else
                return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            if (wndDlg)
                delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CSummaryDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    FillTextFields(hDlg);

    m_pParams->UIManager->SetControlFont(hDlg, IDC_TITLE);

    return TRUE;

} // OnInitDialog


//
// Function: FillTextFields()
//
// Purpose: To load strings and set the text for all the output fields
//          on the Summary page.
//
void CSummaryDlg::FillTextFields(HWND hDlg)
{
    TCHAR ptcsYesNo[MAX_YESNO_SIZE] = NULLSTR;
    TCHAR ptcsProtocolAndPortNum[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;

    // Fill in the protocol field
    TCHAR ptcsProtocol[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;
    TCHAR ptcsPort[MAX_PROTOCOL_AND_PORTNUM_SIZE] = NULLSTR;

    if(m_pParams->pData->dwProtocol == PROTOCOL_RAWTCP_TYPE) {
        LoadString(g_hInstance,
                   IDS_STRING_RAW,
                   ptcsProtocol,
                   MAX_PROTOCOL_AND_PORTNUM_SIZE);
        LoadString(g_hInstance,
                   IDS_STRING_PORT,
                   ptcsPort,
                   MAX_PROTOCOL_AND_PORTNUM_SIZE);
        StringCchPrintf (ptcsProtocolAndPortNum, COUNTOF (ptcsProtocolAndPortNum),
                  TEXT("%s, %s %d"),
                  ptcsProtocol,
                  ptcsPort,
                  m_pParams->pData->dwPortNumber);
    } else {
        if(m_pParams->pData->dwProtocol == PROTOCOL_LPR_TYPE) {
            LoadString(g_hInstance,
                       IDS_STRING_LPR,
                       ptcsProtocol,
                       MAX_PROTOCOL_AND_PORTNUM_SIZE);
            StringCchPrintf (ptcsProtocolAndPortNum, COUNTOF (ptcsProtocolAndPortNum),
                      TEXT("%s, %s"),
                      ptcsProtocol,
                      m_pParams->pData->sztQueue);
        }
    }
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PROTOCOL_AND_PORTNUM),
                  ptcsProtocolAndPortNum);

    // Fill in the SNMP Field
    if(m_pParams->pData->dwSNMPEnabled != FALSE) {
        LoadString(g_hInstance, IDS_STRING_YES, ptcsYesNo, MAX_YESNO_SIZE);
    } else {
        LoadString(g_hInstance, IDS_STRING_NO, ptcsYesNo, MAX_YESNO_SIZE);
    }
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_SNMP_YESNO), ptcsYesNo);

    // Fill in the Address field:
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_ADDRESS), m_pParams->pData->sztHostAddress);

    // Fill in the PortName field
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORTNAME), m_pParams->pData->sztPortName);

    // Fill in the Detected type
    SetWindowText(GetDlgItem( hDlg, IDC_EDIT_SYSTEMID), m_pParams->sztPortDesc);

} // FillTextFields

//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CSummaryDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_RESET:
            // reset to the original values
#ifdef _WIN64
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
#else
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
#endif
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            FillTextFields(hDlg);
            PostMessage(GetDlgItem(hDlg, IDC_EDIT_SNMP_YESNO), EM_SETSEL,0,0);
            return FALSE;
            break;

        case PSN_WIZBACK:
            // To jump to a page other than the previous or next one,
            // an application should set DWL_MSGRESULT to the identifier
            // of the dialog box to be displayed.
            if(m_pParams->dwDeviceType == SUCCESS_DEVICE_SINGLE_PORT) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);
            } else if (m_pParams->bMultiPort ==  FALSE  ) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MORE_INFO);
            }

            break;

        case PSN_WIZFINISH:
            OnFinish();
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnNotify


//
//  FUNCTION: OnFinish()
//
//  PURPOSE:  Create the Port
//
BOOL CSummaryDlg::OnFinish()
{
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor ) {

        hOldCursor = SetCursor(hNewCursor);
    }

    if ( m_pParams->hXcvPrinter != NULL ) {

        RemoteTellPortMonToCreateThePort();
    } else {
        LocalTellPortMonToCreateThePort();
    }

    //
    // Make sure the port name is returned to the calling module.
    //
    lstrcpyn(m_pParams->sztPortName,
             m_pParams->pData->sztPortName,
             MAX_PORTNAME_LEN);

    //
    // Change the cursor back from an hour glass.
    //
    if ( hNewCursor ) {

        SetCursor(hOldCursor);
    }

    return TRUE;

} // OnFinish


//
//  FUNCTION: RemoteTellPortMonToCreateThePort
//
//  PURPOSE:  Loads winspool.dll and calls XcvData
//
DWORD CSummaryDlg::RemoteTellPortMonToCreateThePort()
{
    DWORD dwReturn = NO_ERROR;
    HINSTANCE hLib = NULL;
    XCVDATAPARAM pfnXcvData = NULL;
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor ) {

        hOldCursor = SetCursor(hNewCursor);
    }

    //
    // load & assign the function pointer
    //
    hLib = ::LoadLibrary(TEXT("WinSpool.drv"));
    if( hLib != NULL ) {

        //
        // initialize the library
        //
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(hLib, "XcvDataW");
        if ( pfnXcvData != NULL ) {

            DWORD dwOutputNeeded = 0;
            DWORD dwStatus = NO_ERROR;
            //
            // here's the call we've all been waiting for:
            //
            DWORD dwRet = (*pfnXcvData)(m_pParams->hXcvPrinter,
                                        (PCWSTR)TEXT("AddPort"),
                                        (PBYTE)(m_pParams->pData),
                                        m_pParams->pData->cbSize,
                                        NULL,
                                        0,
                                        &dwOutputNeeded,
                                        &dwStatus);

            if ( !dwRet ) {

                dwReturn = GetLastError();
                DisplayErrorMessage(NULL, dwReturn);
            } else {

                if ( dwStatus != NO_ERROR )
                    DisplayErrorMessage(NULL, dwStatus);
            }
        } else {

            dwReturn = ERROR_DLL_NOT_FOUND;
        }

    } else {

        dwReturn = ERROR_DLL_NOT_FOUND;
    }

    //
    // --- Cleanup ---
    //
    if ( hLib )
        FreeLibrary(hLib);

    if ( hNewCursor )
        SetCursor(hOldCursor);

    return(dwReturn);

} // RemoteTellPortMonToCreateThePort


//
//  FUNCTION: TellPortMonToCreateThePort
//
//  Purpose: To load the port monitor dll and call AddPortUIEx
//
//  Return Value:
//
DWORD CSummaryDlg::LocalTellPortMonToCreateThePort()
{
    DWORD dwReturn = NO_ERROR;
    UIEXPARAM pfnAddPortUIEx = NULL;
    HCURSOR hOldCursor = NULL;
    HCURSOR hNewCursor = NULL;

    hNewCursor = LoadCursor(NULL, IDC_WAIT);
    if ( hNewCursor )
        hOldCursor = SetCursor(hNewCursor);

    //
    // load & assign the function pointer
    //
    if ( g_hPortMonLib != NULL) {

        //
        // initialize the library
        //
        pfnAddPortUIEx = (UIEXPARAM)::GetProcAddress(g_hPortMonLib,
                                                     "AddPortUIEx");
        if ( pfnAddPortUIEx != NULL ) {

            //
            // here's the call we've all been waiting for:
            //
            BOOL bReturn = (*pfnAddPortUIEx)(m_pParams->pData);
            if(bReturn == FALSE) {

                dwReturn = GetLastError();
                DisplayErrorMessage(NULL, dwReturn);
            }
        } else {

            dwReturn = ERROR_DLL_NOT_FOUND;
        }
    } else {

        dwReturn = ERROR_DLL_NOT_FOUND;
    }

    //
    // Cleanup
    //
    if ( hNewCursor )
        SetCursor(hOldCursor);

    return dwReturn;

} // LocalTellPortMonToCreateThePort
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\tcpport.h ===
/*****************************************************************************
 *
 * $Workfile: tcpport.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_TCPPORT_H
#define INC_TCPPORT_H

#include "portABC.h"
#include "portrefABC.h"
#include "jobabc.h"
#include "devstat.h"

#define STATUS_ERROR_TIMEOUT_FACTOR     20   // 1/20 status update interval
#define STATUS_PRINTING_TIMEOUT_FACTOR  10   // 1/10 status update interval

class CRawTcpDevice;

class CTcpPort : public CPortRefABC
#if defined _DEBUG || defined DEBUG
//  , public CMemoryDebug
#endif
{
    // methods
public:
    CTcpPort(LPTSTR     psztPortName,       // called through the UI port creation
             LPTSTR     psztHostAddress,
             DWORD      dPortNum,
             DWORD      dSNMPEnabled,
             LPTSTR     sztSNMPCommunity,
             DWORD      dSNMPDevIndex,
             CRegABC    *pRegistry,
             CPortMgr   *pPortMgr);

    CTcpPort(LPTSTR     psztPortName,       // called through the registry port creation
             LPTSTR     psztHostName,
             LPTSTR     psztIPAddr,
             LPTSTR     psztHWAddr,
             DWORD      dPortNum,
             DWORD      dSNMPEnabled,
             LPTSTR     sztSNMPCommunity,
             DWORD      dSNMPDevIndex,
             CRegABC    *pRegistry,
             CPortMgr   *pPortMgr);

    ~CTcpPort();

    DWORD   Write(LPBYTE     pBuffer,
                  DWORD  cbBuf,
                  LPDWORD pcbWritten);
    DWORD   EndDoc();


    LPCTSTR GetName ( ) { return (LPCTSTR) m_szName; }
    CDeviceABC *GetDevice() { return (CDeviceABC *)m_pDevice; }

    BOOL    IsSamePort(LPTSTR pszName) { return _tcscmp(m_szName, pszName); }
    DWORD   SetRegistryEntry(LPCTSTR        psztPortName,
                             const DWORD    dwProtocol,
                             const DWORD    dwVersion,
                             const LPBYTE   pData);
    DWORD   SetDeviceStatus( );

    DWORD   ClearDeviceStatus();

    DWORD   InitConfigPortUI( const DWORD   dwProtocolType,
                            const DWORD dwVersion,
                            LPBYTE      pData);
    DWORD   GetSNMPInfo( PSNMP_INFO pSnmpInfo);

    time_t  NextUpdateTime();

    BOOL    m_bUsed;

    inline const CPortMgr *GetPortMgr(void) const;

protected:  // methods
    DWORD   UpdateRegistryEntry( LPCTSTR        psztPortName,
                                 const DWORD    dwProtocol,
                                 const DWORD    dwVersion );

    DWORD   m_dwStatus;
protected:
    CRawTcpDevice   *m_pDevice;         // device that is attached to
    CJobABC         *m_pJob;
    CRegABC         *m_pRegistry;
    CPortMgr        *m_pPortMgr;        //  The Port Manager that this port belongs to

    TCHAR       m_szName[MAX_PORTNAME_LEN+1];           // port name

private:    // attributes

    time_t  m_lLastUpdateTime;

};

//////////////////////////////////////////////////////////////////////////
// INLINE METHODS
//////////////////////////////////////////////////////////////////////////
inline const CPortMgr *CTcpPort::GetPortMgr(void) const {
    return m_pPortMgr;
}



#endif // INC_TCPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addgetad.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddGetAd.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "AddGetAd.h"
#include "Resource.h"
#include "TCPMonUI.h"
#include "RTcpData.h"
#include "LprData.h"
#include "inisection.h"

//
//  FUNCTION: CGetAddrDlg constructor
//
//  PURPOSE:  initialize a CGetAddrDlg class
//
CGetAddrDlg::CGetAddrDlg()
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // constructor


//
//  FUNCTION: CGetAddrDlg destructor
//
//  PURPOSE:  deinitialize a CGetAddrDlg class
//
CGetAddrDlg::~CGetAddrDlg()
{
} // destructor


//
//  FUNCTION: GetAddressDialog(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the main dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK GetAddressDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL bRc = FALSE;
    CGetAddrDlg *wndDlg = NULL;
    wndDlg = (CGetAddrDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CGetAddrDlg;
            if( wndDlg != NULL )
            {
                SetLastError(ERROR_SUCCESS);
                if ( (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) ) &&
                     GetLastError() != ERROR_SUCCESS )
                {
                    delete wndDlg;
                    bRc = TRUE;
                }
                else
                    bRc = wndDlg->OnInitDialog(hDlg, wParam, lParam);
            }
            break;

       case WM_COMMAND:
            if (wndDlg)
                bRc = wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            if (wndDlg)
                bRc = wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            bRc = TRUE;
            break;

        default:
            return FALSE;
    }
    return bRc;

} // AddPortDialog

//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CGetAddrDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    TCHAR sztAddPortInfo[ADD_PORT_INFO_LEN] = NULLSTR;

    LoadString(g_hInstance, IDS_STRING_ADD_PORT, sztAddPortInfo, ADD_PORT_INFO_LEN);

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_ADD_PORT), sztAddPortInfo);
    // initialize data members
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;
    m_pParams->pData->sztHostAddress[0] = '\0';
    m_pParams->pData->sztPortName[0] = '\0';

    // Set limits on the address and port name lengths
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), MAX_ADDRESS_LENGTH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), MAX_PORTNAME_LEN - 1);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CGetAddrDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case EN_UPDATE:
            // one of the text controls had text changed in it.
            return OnEnUpdate(hDlg, wParam, lParam);
            break;
        default:
            return FALSE;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CGetAddrDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return 1;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            TCHAR szTemp[MAX_PATH];
            lstrcpyn( szTemp, m_pParams->pData->sztHostAddress,
                 SIZEOF_IN_CHAR(szTemp) );
            m_InputChkr.MakePortName( szTemp, COUNTOF (szTemp) );
            if((_tcscmp(m_pParams->pData->sztHostAddress,
                m_pParams->pData->sztPortName) == 0) ||
                (_tcscmp( m_pParams->pData->sztPortName, szTemp ) == 0 ))
            {
                m_InputChkr.LinkPortNameAndAddressInput();
            } else {
                m_InputChkr.UnlinkPortNameAndAddressInput();
            }
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), m_pParams->pData->sztHostAddress);
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), m_pParams->pData->sztPortName);
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK /* | PSWIZB_FINISH */);
            break;

        case PSN_WIZNEXT:
            // the Next button was pressed
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            OnNext(hDlg);

            // To jump to a page other than the previous or next one,
            // an application should set DWL_MSGRESULT to the identifier
            // of the dialog box to be displayed.

            switch ( m_pParams->dwDeviceType ) {
            case  SUCCESS_DEVICE_SINGLE_PORT:
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                break;

            case SUCCESS_DEVICE_MULTI_PORT:
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MULTIPORT);
                break;

            default:
                //
                // No action necessary
                //
                break;
            }

            break;

        case PSN_WIZBACK:
            m_bDontAllowThisPageToBeDeactivated = FALSE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:
//
//
BOOL CGetAddrDlg::OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int idEditCtrl = (int) LOWORD(wParam);
    HWND hwndEditCtrl = NULL;

    hwndEditCtrl = (HWND)lParam;

    switch(idEditCtrl) {
        case IDC_EDIT_PORT_NAME:

            m_InputChkr.OnUpdatePortName(idEditCtrl, hwndEditCtrl);
            break;

        case IDC_EDIT_DEVICE_ADDRESS:

            if (SendMessage(hwndEditCtrl, EM_GETMODIFY, 0, 0)) {
                // The port address has changed
                // so we need to probe the network again
                //
                m_pParams->bBypassNetProbe = FALSE;

            }

            m_InputChkr.OnUpdateAddress(hDlg, idEditCtrl, hwndEditCtrl, m_pParams->pszServer);
            break;

        default:
            //
            // Should never get here
            //
            break;
    }
    return TRUE;

} // OnEnUpdate


//
//  FUNCTION: OnNext(HWND hDlg)
//
//  PURPOSE:  When the user clicks Next this function does all the necessary
//              things to create a port.  Verify the address, check to see if there
//              is already a port existing with the given name/address, get the
//              device type, and set the values in the m_PortData structure.
//
void CGetAddrDlg::OnNext(HWND hDlg)
{
    HCURSOR         hNewCursor = NULL;
    HCURSOR         hOldCursor = NULL;
    IniSection      *pIniSection = NULL;
    TCHAR           ptcsAddress[MAX_ADDRESS_LENGTH] = NULLSTR;
    TCHAR           ptcsPortName[MAX_PORTNAME_LEN] = NULLSTR;
    TCHAR           sztSystemDesc[MAX_PORT_DESCRIPTION_LEN] = NULLSTR;
    DWORD           dwDeviceType = SUCCESS_DEVICE_UNKNOWN;
    DWORD           dwPortNum = DEFAULT_PORT_NUMBER;
    DWORD           dwNumMultiPorts = 0;
    DWORD           dwRet = ERROR_DEVICE_NOT_FOUND;


    if ( hNewCursor = LoadCursor(NULL, IDC_WAIT) )
        hOldCursor = SetCursor(hNewCursor);

    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), ptcsAddress, MAX_ADDRESS_LENGTH);
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), ptcsPortName, MAX_PORTNAME_LEN);

    if(! m_InputChkr.AddressIsLegal(ptcsAddress)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ADDRESS_NOT_VALID);
        return;
    }

    if(! m_InputChkr.PortNameIsLegal(ptcsPortName)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_PORTNAME_NOT_VALID);
        return;
    }

    if(! m_InputChkr.PortNameIsUnique(ptcsPortName, m_pParams->pszServer)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_PORTNAME_NOT_UNIQUE);
        return;
    }

    memset( m_pParams->sztPortDesc, '\0', sizeof( m_pParams->sztPortDesc ));
    memset( m_pParams->sztSectionName, '\0', sizeof( m_pParams->sztSectionName ) );
    m_pParams->bMultiPort = FALSE;
    dwRet = GetDeviceDescription(ptcsAddress, sztSystemDesc, SIZEOF_IN_CHAR(sztSystemDesc));

    switch( dwRet ) {
        case NO_ERROR:

            if ( pIniSection = new IniSection() ) {
                if ( pIniSection->GetIniSection( sztSystemDesc )) {

                    if ( pIniSection->GetDWord(PORTS_KEY, &dwNumMultiPorts)   &&
                         dwNumMultiPorts > 1 ) {

                        dwDeviceType = SUCCESS_DEVICE_MULTI_PORT;
                        m_pParams->bMultiPort = TRUE;
                        lstrcpyn(m_pParams->sztSectionName,
                                 pIniSection->GetSectionName(),
                                 MAX_SECTION_NAME);
                    } else {

                        dwDeviceType = SUCCESS_DEVICE_SINGLE_PORT;
                        if (! pIniSection->GetPortInfo( ptcsAddress, m_pParams->pData, 1 , m_pParams->bBypassNetProbe)) {
                            if (GetLastError () == ERROR_DEVICE_NOT_FOUND) {

                                // The IP address is incorrect, we should by pass network probe from now on
                                //

                                m_pParams->bBypassNetProbe = TRUE;

                            }
                        }
                    }

                    pIniSection->GetString( PORT_NAME_KEY, m_pParams->sztPortDesc, SIZEOF_IN_CHAR(m_pParams->sztPortDesc));

                }

                delete pIniSection;
                pIniSection = NULL;
            }
            break;

        case SUCCESS_DEVICE_UNKNOWN:
            dwDeviceType = SUCCESS_DEVICE_UNKNOWN;
            break;

        default:
            dwDeviceType = ERROR_DEVICE_NOT_FOUND;
            m_pParams->bBypassNetProbe = TRUE;

            break;
    }

    if ( hNewCursor )
        SetCursor(hOldCursor);

    // Set values in the outgoing structure
    lstrcpyn(m_pParams->pData->sztPortName, ptcsPortName, MAX_PORTNAME_LEN);
    lstrcpyn(m_pParams->pData->sztHostAddress, ptcsAddress, MAX_NETWORKNAME_LEN);
    m_pParams->dwDeviceType = dwDeviceType;
} // OnNext


//
// FUNCTION: GetDeviceDescription()
//
// PURPOSE: Get the description of the user requested printer.
//
// Return Value Error Codes:
//  NO_ERROR
//  ERROR_DLL_NOT_FOUND
//
// Return Values in dwType:
//  ERROR_DEVICE_NOT_FOUND
//  SUCCESS_DEVICE_SINGLE_PORT
//  SUCCESS_DEVICE_MULTI_PORT
//  SUCCESS_DEVICE_UNKNOWN

DWORD
CGetAddrDlg::
GetDeviceDescription(
    LPCTSTR     pAddress,
    LPTSTR      pszPortDesc,
    DWORD       cBytes
    )
{

//  Here is the essence of the code below without all the load
//  library stuff in addition:
//
//  CTcpMibABC *pTcpMib = NULL;
//  pTcpMib = (CTcpMibABC *) GetTcpMibPtr();
//
//  char HostName[MAX_NETWORKNAME_LEN];
//  UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
//  *dwType = pTcpMib->GetDeviceType(HostName, pdwPortNum);
//
//  return (NO_ERROR);
//
    DWORD            dwRet = ERROR_DEVICE_NOT_FOUND;
    CTcpMibABC     *pTcpMib = NULL;
    FARPROC         pfnGetTcpMibPtr = NULL;

    if ( !g_hTcpMibLib ) {
        goto Done;
    }

    pfnGetTcpMibPtr = ::GetProcAddress(g_hTcpMibLib, "GetTcpMibPtr");

    if ( !pfnGetTcpMibPtr ) {
        goto Done;
    }

    if ( pTcpMib = (CTcpMibABC *) pfnGetTcpMibPtr() ) {

        char HostName[MAX_NETWORKNAME_LEN] = "";

        UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
        dwRet = pTcpMib->GetDeviceDescription(HostName,
                                             DEFAULT_SNMP_COMMUNITYA,
                                             DEFAULT_SNMP_DEVICE_INDEX,
                                             pszPortDesc,
                                             cBytes);
    }

Done:
    return dwRet;
} // GetDeviceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addgetad.h ===
/*****************************************************************************
 *
 * $Workfile: AddGetAd.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDGETADDRESS_H
#define INC_ADDGETADDRESS_H


const int ADD_PORT_INFO_LEN = 512;


// Global Variables
extern HINSTANCE g_hInstance;

class CGetAddrDlg
{
public:
        CGetAddrDlg();
        ~CGetAddrDlg();

public:
        BOOL    OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        BOOL    OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        BOOL    OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
        BOOL    OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        VOID    OnNext(HWND hDlg);
        DWORD   GetDeviceDescription(LPCTSTR   pHost,
                                 LPTSTR    pszPortDesc,
                                                                 DWORD     cBytes);

private:
        ADD_PARAM_PACKAGE *m_pParams;
        BOOL m_bDontAllowThisPageToBeDeactivated;
        CInputChecker m_InputChkr;

}; // CGetAddrDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
INT_PTR CALLBACK GetAddressDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDGETADDRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addminfo.h ===
/*****************************************************************************
 *
 * $Workfile: AddMInfo.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDMOREINFO_H
#define INC_ADDMOREINFO_H

#define DEFAULT_COMBO_SELECTION TEXT("<")

// Global Variables
extern HINSTANCE g_hInstance;

// Constants
const int MAX_LISTBOX_STRLEN = 50;
const int MAX_REASON_STRLEN = 512;

class CMoreInfoDlg
{
public:
	CMoreInfoDlg();
	~CMoreInfoDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	BOOL OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void FillComboBox(HWND hDlg);
	void OnSetActive(HWND hDlg);
	BOOL OnSelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void GetPrinterData(HWND hwndControl, LPCTSTR pszAddress);

private:
	ADD_PARAM_PACKAGE *m_pParams;
	CDevicePortList m_DPList;
	PORT_DATA_1 m_PortDataStandard;
	PORT_DATA_1 m_PortDataCustom;
	TCHAR m_szCurrentSelection[MAX_SECTION_NAME];
}; // CMoreInfoDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
INT_PTR CALLBACK MoreInfoDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDMOREINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addminfo.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddMInfo.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "UIMgr.h"
#include "DevPort.h"
#include "AddMInfo.h"
#include "Resource.h"
#include "MibABC.h"
#include "TcpMonUI.h"

//
//  FUNCTION: CMoreInfoDlg constructor
//
//  PURPOSE:  initialize a CMoreInfoDlg class
//
CMoreInfoDlg::CMoreInfoDlg() : m_DPList( )
{
    memset(&m_PortDataStandard, 0, sizeof(m_PortDataStandard));
    memset(&m_PortDataCustom, 0, sizeof(m_PortDataCustom));

    lstrcpyn(m_szCurrentSelection, DEFAULT_COMBO_SELECTION, MAX_SECTION_NAME);

} // constructor


//
//  FUNCTION: CMoreInfoDlg destructor
//
//  PURPOSE:  deinitialize a CMoreInfoDlg class
//
CMoreInfoDlg::~CMoreInfoDlg()
{
} // destructor


//
//  FUNCTION: MoreInfoDialog(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK MoreInfoDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CMoreInfoDlg *wndDlg = NULL;

    wndDlg = (CMoreInfoDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CMoreInfoDlg;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CMoreInfoDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_STANDARD);

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), FALSE);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CMoreInfoDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
    case BN_CLICKED:
        return OnButtonClicked(hDlg, wParam, lParam);
        break;

/*
    case LBN_SELCHANGE:
        return OnSelChange(hDlg, wParam, lParam);
        break;
*/
    default:
        return FALSE;
    }

    return TRUE;

} // OnCommand

#if 0
//
//  FUNCTION: OnSelChange()
//
//  PURPOSE:  Process WM_COMMAND's LBN_SELCHANGE message
//
BOOL CMoreInfoDlg::OnSelChange(HWND hDlg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    // The selection in the combo box changed.
    HWND hwndComboBox = NULL;

    hwndComboBox = (HWND) lParam;       // handle of list box
    GetPrinterData(hwndComboBox, m_pParams->pData->sztHostAddress);

    return TRUE;

} // OnSelChange

#endif

//
//  FUNCTION: GetPrinterData(HWND hwndControl, BOOL *Unknown)
//
//  PURPOSE:  Gets the socket number of the selected item.
//
//  Arguments: hwndControl is the handle of the combo box.
//
//  Return Value: Returns the socket number associated with the selected item
//
void CMoreInfoDlg::GetPrinterData(HWND hwndControl,
                                  LPCTSTR pszAddress
                                  )
{
    LRESULT iSelectedIndex = 0;
    CDevicePort *pPortInfo = NULL;

    iSelectedIndex = SendMessage(hwndControl,
                                 CB_GETCURSEL,
                                 (WPARAM)0,
                                 (LPARAM)0);

    pPortInfo = (CDevicePort *) SendMessage(hwndControl,
                                            CB_GETITEMDATA,
                                            (WPARAM)iSelectedIndex,
                                            (LPARAM)0);
    if ( (DWORD_PTR)pPortInfo != CB_ERR) {

        pPortInfo->ReadPortInfo(pszAddress, &m_PortDataStandard, m_pParams->bBypassNetProbe);
        lstrcpyn( m_szCurrentSelection, pPortInfo->GetName(), MAX_SECTION_NAME);
        m_pParams->bMultiPort = ( pPortInfo->GetPortIndex() == 0);
        lstrcpyn(m_pParams->sztSectionName,pPortInfo->GetPortKeyName(), MAX_SECTION_NAME);
    } else {

        //
        // DSN Fill out the default structure
        //
        m_PortDataStandard.dwPortNumber = DEFAULT_PORT_NUMBER;
        lstrcpyn(m_PortDataStandard.sztSNMPCommunity,
                 DEFAULT_SNMP_COMUNITY,
                 MAX_SNMP_COMMUNITY_STR_LEN);
        m_PortDataStandard.dwSNMPDevIndex = 1;
    }
} // GetPrinterData


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CMoreInfoDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:

            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return 1;

        case PSN_RESET:
            //
            // reset to the original values
            //
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            OnSetActive(hDlg);
            break;

        case PSN_WIZBACK:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);

            memcpy(m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1));
            break;

        case PSN_WIZNEXT:
            //
            // the Next button was pressed
            //
            if( IsDlgButtonChecked(hDlg, IDC_RADIO_STANDARD) == BST_CHECKED ) {

                HWND hList = NULL;
                HCURSOR         hNewCursor = NULL;
                HCURSOR         hOldCursor = NULL;

                if ( hNewCursor  = LoadCursor(NULL, IDC_WAIT) )
                    hOldCursor = SetCursor(hNewCursor);

                hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);

                GetPrinterData(hList, m_pParams->pData->sztHostAddress);

                if ( m_pParams->bMultiPort == FALSE ) {
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                }
                memcpy(m_pParams->pData,
                       &m_PortDataStandard,
                       sizeof(PORT_DATA_1));

                lstrcpyn(m_pParams->sztPortDesc,
                         m_szCurrentSelection,
                         SIZEOF_IN_CHAR(m_pParams->sztPortDesc));

                if ( hNewCursor )
                    SetCursor(hOldCursor);

            } else {

                //
                // if(IsDlgButtonChecked(hDlg, IDC_RADIO_CUSTOM) == BST_CHECKED)
                //
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_SUMMARY);
                memcpy(m_pParams->pData, &m_PortDataCustom, sizeof(PORT_DATA_1));
                m_pParams->bMultiPort = FALSE;
                *m_pParams->sztPortDesc = '\0';
            }
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;
} // OnCommand

HRESULT
DynamicLoadString (
    IN  HINSTANCE hInst,
    IN  UINT      uID,
    IN  UINT      cchInitialCount,
    OUT LPWSTR*   ppszString
    )
/*++
    This function allocates memory using 'new' operator and loads string using LoadString call.
    Caller is responsible for deleting the allocated memory.
    The buffer space is insufficient if there is no extra character left after terminating char.
    In this case, it releases the memory, allocates new bigger buffer and calls LoadString again.
--*/
{
    HRESULT hr = S_OK;
    UINT cchCount = cchInitialCount + 1;

    for (;;)
    {
        LPWSTR pszString = new WCHAR [cchCount];
        if (pszString == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        UINT cchLoadStringCount = LoadString (hInst,
                                              uID,
                                              pszString,
                                              cchCount);
        if (cchLoadStringCount == 0)
        {
            //
            // String does not exist
            //
            *pszString = L'\0';
            *ppszString = pszString;
            hr = S_FALSE;
            break;
        }
        //
        // If the buffer is full (string content plus terminating char)
        // we need to increase the buffer to be sure the whole string is loaded
        //
        if (cchLoadStringCount + 1 < cchCount)
        {
            //
            // After terminating char of the copied string must remain at least one empty place
            // This is a sign that we have whole string
            //
            *ppszString = pszString;
            hr = S_OK;
            break;
        }
        //
        // Increase the size of the buffer and load string again
        //
        delete [] pszString;
        cchCount *= 2;
    }

    return hr;
}//end DynamicLoadString

//
//  FUNCTION: OnSetActive()
//
//  PURPOSE:  Process PSN_SETACTIVE part of the WM_NOTIFY message
//
void CMoreInfoDlg::OnSetActive(HWND hDlg)
{
    WCHAR* pszMoreInfoReason = NULL;

    memcpy( &m_PortDataStandard, m_pParams->pData, sizeof(PORT_DATA_1) );
    memcpy( &m_PortDataCustom, m_pParams->pData, sizeof(PORT_DATA_1) );

    FillComboBox(hDlg);

    switch(m_pParams->dwDeviceType) {
        case ERROR_DEVICE_NOT_FOUND:
            (VOID) DynamicLoadString (g_hInstance,
                                      IDS_STRING_DEV_NOT_FOUND,
                                      MAX_REASON_STRLEN,
                                      &pszMoreInfoReason);
            break;

        case SUCCESS_DEVICE_UNKNOWN:
            (VOID) DynamicLoadString (g_hInstance,
                                      IDS_STRING_UNKNOWN_DEV,
                                      MAX_REASON_STRLEN,
                                      &pszMoreInfoReason);
            break;

        default:
            break;
    }

    if (pszMoreInfoReason)
    {
        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_MOREINFO_REASON), pszMoreInfoReason);
    }
    else
    {
        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_MOREINFO_REASON), L"");
    }
    delete [] pszMoreInfoReason;
} // OnSetActive


//
//  FUNCTION: OnButtonClicked()
//
//  PURPOSE:  Process BN_CLICKED message
//
BOOL CMoreInfoDlg::OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM)
{
    int  idButton = (int) LOWORD(wParam);    // identifier of button
    // HWND hwndButton = (HWND) lParam;

    switch(idButton)
    {
        case IDC_BUTTON_SETTINGS:
            m_pParams->UIManager->ConfigPortUI(hDlg,
                                               &m_PortDataCustom,
                                               m_pParams->hXcvPrinter,
                                               m_pParams->pszServer,
                                               TRUE);
            break;

        case IDC_RADIO_STANDARD:
            CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_STANDARD);

            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), FALSE);
            SetFocus(GetDlgItem(hDlg, IDC_COMBO_DEVICES));
            break;

        case IDC_RADIO_CUSTOM:
            CheckRadioButton(hDlg, IDC_RADIO_STANDARD, IDC_RADIO_CUSTOM, IDC_RADIO_CUSTOM);

            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS), TRUE);
            SetFocus(GetDlgItem(hDlg, IDC_BUTTON_SETTINGS));
            break;

        default:
            return FALSE;
            break;
    }
    return TRUE;

} // OnButtonClicked


//
//  FUNCTION: FillComboBox(HWND hDlg)
//
//  PURPOSE:  Fills the combo box with values gotten from the ini file.
//              The associated item data is used to pair the port number with the
//              device types.
//
//  Arguments: hDlg is the handle of the dialog box.
//
void CMoreInfoDlg::FillComboBox(HWND hDlg)
{
    LRESULT index = 0;
    HWND hList = NULL;
    CDevicePort *pDP = NULL;
    TCHAR sztGenericNetworkCard[MAX_TITLE_LENGTH];

    hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);
    // Possible Values in m_pParams->dwDeviceType:
    //  ERROR_DEVICE_NOT_FOUND
    //  SUCCESS_DEVICE_MULTI_PORT
    //  SUCCESS_DEVICE_UNKNOWN

    index = SendMessage(hList,
                        CB_GETCURSEL,
                        (WPARAM)0,
                        (LPARAM)0);

    if (index == CB_ERR) {
        // This is the first time, initiliaze the list

        index = SendMessage(hList, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

        //
        // Initialize the list of variables
        //
        if(m_pParams->dwDeviceType == ERROR_DEVICE_NOT_FOUND ||
            m_pParams->dwDeviceType == SUCCESS_DEVICE_UNKNOWN) {
            m_DPList.GetDevicePortsList(NULL);
        } else { // SUCCESS_DEVICE_MULTI_PORT
            m_DPList.GetDevicePortsList(m_pParams->sztSectionName);
        }

        for(pDP = m_DPList.GetFirst(); pDP != NULL; pDP = m_DPList.GetNext()) {

            index = SendMessage(hList,
                                CB_ADDSTRING,
                                (WPARAM)0,
                                (LPARAM)pDP->GetName());
            SendMessage(hList,
                        CB_SETITEMDATA,
                        (WPARAM)index,
                        (LPARAM)pDP);
        }

        index = SendMessage(hList,
                            CB_SETCURSEL,
                            (WPARAM)0,
                            (LPARAM)0);

        if((m_pParams->dwDeviceType == ERROR_DEVICE_NOT_FOUND ||
            m_pParams->dwDeviceType == SUCCESS_DEVICE_UNKNOWN) &&
            (*m_szCurrentSelection != '\0') ) {

            index = SendMessage(hList,
                                CB_SELECTSTRING,
                                (WPARAM)-1,
                                (LPARAM)m_szCurrentSelection);
        }

        SendMessage(hList, CB_SETCURSEL, (WPARAM)index, (LPARAM)0);

        if (LoadString(g_hInstance, IDS_GENERIC_NETWORK_CARD, sztGenericNetworkCard, MAX_TITLE_LENGTH))
            SendMessage(hList, CB_SELECTSTRING, 0, (LPARAM)sztGenericNetworkCard);
    }


} // FillComboBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addmulti.h ===
/*****************************************************************************
 *
 * $Workfile: AddMulti.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_ADDMULTIPORT_H
#define INC_ADDMULTIPORT_H

// Global Variables
extern HINSTANCE g_hInstance;

// Constants
const int MAX_MULTILISTBOX_STRLEN = 50;
const int MAX_MULTIREASON_STRLEN = 512;

class CMultiPortDlg
{
public:
	CMultiPortDlg();
	~CMultiPortDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void FillComboBox(HWND hDlg);
	void OnSetActive(HWND hDlg);
	BOOL OnSelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void GetPrinterData(HWND hwndControl, LPCTSTR pszAddress);

private:
	ADD_PARAM_PACKAGE *m_pParams;
	CDevicePortList m_DPList;
	PORT_DATA_1 m_PortDataStandard;
	TCHAR m_szCurrentSelection[MAX_SECTION_NAME];

}; // CMultiPortDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
INT_PTR CALLBACK MultiPortDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDMULTIPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addwelcm.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddWelcm.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 * 
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "UIMgr.h"
#include "AddWelcm.h"
#include "resource.h"

//
//  FUNCTION: CWelcomeDlg constructor
//
//  PURPOSE:  initialize a CWelcomeDlg class
//
CWelcomeDlg::CWelcomeDlg()
{
} // constructor


//
//  FUNCTION: CWelcomeDlg destructor
//
//  PURPOSE:  deinitialize a CWelcomeDlg class
//
CWelcomeDlg::~CWelcomeDlg()
{
} // destructor


//
//  FUNCTION: WelcomeDialog(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the welcome dialog for adding a port.
//
//  MESSAGES:
//	
//	WM_INITDIALOG - intializes the page
//	WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK WelcomeDialog(
	HWND    hDlg,
	UINT    message,
	WPARAM  wParam,
	LPARAM  lParam)
{
	CWelcomeDlg *wndDlg = NULL;
	wndDlg = (CWelcomeDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	switch (message)
	{
        case WM_INITDIALOG:

            //
            // Remove the system menu and context help for the wizard
            //
            {
                HWND hPropSheet = GetParent(hDlg);

                LONG_PTR lStyle = GetWindowLongPtr(hPropSheet, GWL_STYLE);
                lStyle &= ~(WS_SYSMENU | DS_CONTEXTHELP);
                SetWindowLongPtr(hPropSheet, GWL_STYLE, lStyle);
            }
            
            wndDlg = new CWelcomeDlg;
            if( wndDlg == NULL )
                return( FALSE );

			SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
			return wndDlg->OnInitDialog(hDlg, wParam, lParam);
			break;

		case WM_COMMAND:
			return wndDlg->OnCommand(hDlg, wParam, lParam);
			break;

		case WM_NOTIFY:
			return wndDlg->OnNotify(hDlg, wParam, lParam);
			break;

		case WM_DESTROY:
			delete wndDlg;
			break;

		default:
			return FALSE;
	}
	return TRUE;

} // WelcomeDialog

//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CWelcomeDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
	m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

	// Initialize the outgoing structure
	m_pParams->dwDeviceType = 0;
	m_pParams->pData->cbSize = sizeof(PORT_DATA_1);
	m_pParams->pData->dwCoreUIVersion = COREUI_VERSION;
	lstrcpyn(m_pParams->pData->sztPortName, TEXT(""), MAX_PORTNAME_LEN);
	lstrcpyn(m_pParams->pData->sztHostAddress, TEXT(""), MAX_NETWORKNAME_LEN);
	m_pParams->pData->dwPortNumber = DEFAULT_PORT_NUMBER;
	m_pParams->pData->dwVersion = DEFAULT_VERSION;
	m_pParams->pData->dwProtocol = DEFAULT_PROTOCOL;
	
	lstrcpyn(m_pParams->pData->sztQueue, TEXT(""), MAX_QUEUENAME_LEN);
	lstrcpyn(m_pParams->pData->sztIPAddress, TEXT(""), MAX_IPADDR_STR_LEN);
	lstrcpyn(m_pParams->pData->sztHardwareAddress, TEXT(""), MAX_ADDRESS_STR_LEN);

	lstrcpyn(m_pParams->pData->sztSNMPCommunity, DEFAULT_SNMP_COMUNITY, MAX_SNMP_COMMUNITY_STR_LEN);
	m_pParams->pData->dwSNMPEnabled = FALSE;
    m_pParams->pData->dwSNMPDevIndex = DEFAULT_SNMP_DEVICE_INDEX;

    m_pParams->UIManager->SetControlFont(hDlg, IDC_TITLE);

	return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CWelcomeDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	switch(HIWORD(wParam)) {
		case BN_CLICKED:
			// return OnButtonClicked(hDlg, wParam);
			break;
		
		case EN_UPDATE:
			// one of the text controls had text changed in it.
			// return OnEnUpdate(hDlg, wParam, lParam);
			break;
		default:
			return FALSE;
			break;
	}

	return TRUE;

} // OnCommand


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CWelcomeDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	switch (((NMHDR FAR *) lParam)->code) {
  		case PSN_KILLACTIVE:
			SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
			return TRUE;
			break;

		case PSN_RESET:
			// reset to the original values
			SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
			break;

 		case PSN_SETACTIVE:
			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT /*| PSWIZB_BACK | PSWIZB_FINISH */);
			break;

		case PSN_WIZNEXT:
			// the Next button was pressed
     		break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

		default:
			return FALSE;

    }

	return TRUE;

} // OnCommand
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgall.h ===
/*****************************************************************************
 *
 * $Workfile: CfgAll.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon2/TcpMonUI/CfgAll.h $
 *
 * 7     3/05/98 11:23a Dsnelson
 * Removed redundant code.
 *
 * 5     10/03/97 10:56a Becky
 * Removed OnHelp()
 *
 * 4     10/02/97 3:45p Becky
 * Changed FT_MIN (Failure Timeout Minimum) from 5 minutes to 1 minute.
 *
 * 3     9/16/97 2:44p Becky
 * Added OnOk() to actually set the data in the port monitor when the ok
 * button is clicked.
 *
 * 2     9/09/97 4:35p Becky
 * Updated to use the new Monitor UI data structure.
 *
 * 1     8/19/97 3:46p Becky
 * Redesign of the Port Monitor UI.
 *
 *****************************************************************************/

#ifndef INC_ALLPORTS_PAGE_H
#define INC_ALLPORTS_PAGE_H

// Values for Failure Timeout
#define FT_MIN		  1
#define FT_MAX		 60
#define FT_PAGESIZE	 10

// Includes:
//#include "UIMgr.h"


class CAllPortsPage
{
public:
	CAllPortsPage();
	BOOL OnInitDialog(HWND hDlg, WPARAM, LPARAM);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void OnHscroll(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnWMNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam);
	void SetupTrackBar(HWND hDlg,
						int iChildWindowID,
						int iPositionCtrl,
						int iRangeMin,
						int iRangeMax,
						long lPosition,
						long lPageSize,
						int iAssociatedDigitalReadout);

private:
	CFG_PARAM_PACKAGE *m_pParams;

}; // class CAllPortsPage

#ifdef __cplusplus
extern "C"
{
#endif

// Property sheet page function
BOOL APIENTRY AllPortsPage(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ALLPORTS_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgall.cpp ===
/*****************************************************************************
 *
 * $Workfile: CfgAll.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  * 
  * This file contains the dialog for configuring an existing port for the port monitor.
  */
#include "precomp.h"
#include "CoreUI.h"
#include "resource.h"    // includes the definitions for the resources
#include "RTcpData.h"
#include "CfgAll.h"     // includes the application-specific information
#include "TcpMonUI.h"

// Global variables:
extern HINSTANCE g_hInstance;


//
//  FUNCTION: AllPortsPage(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  To process messages from the page for configuring all
//              the tcp monitor ports in the system.
//
//  MESSAGES:
//  
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handle button clicks
//  WM_NOTIFY - handle reset
//  WM_HSCROLL - handle scroll events from the 2 trackbars
//
BOOL APIENTRY AllPortsPage(HWND hDlg,
                           UINT message,
                           WPARAM wParam,
                           LPARAM lParam)
{
    CAllPortsPage *wndDlg = NULL;
    wndDlg = (CAllPortsPage *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch(message)
    {
        case WM_INITDIALOG:
            wndDlg = (CAllPortsPage *) new CAllPortsPage;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnWMNotify(hDlg, wParam, lParam);
            break;

        case WM_HSCROLL:
            wndDlg->OnHscroll(hDlg, wParam, lParam);
            break;

        case WM_HELP:
            OnHelp(IDD_DIALOG_CONFIG_ALL, hDlg, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }

    return TRUE;

} // AllPortsPage


//
//  FUNCTION: CAllPortsPage Constructor
//
//  PURPOSE:
//
CAllPortsPage::CAllPortsPage()
{
} // Constructor


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  To initialize the allports dialog.  Calls SetupTrackBar for each dialog
//              and checks or unchecks the Status Update enabled check box as appropriate.
//
BOOL CAllPortsPage::OnInitDialog(HWND hDlg,
                                 WPARAM,
                                 LPARAM lParam)
{
    m_pParams = (CFG_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;
    
    SetupTrackBar(hDlg, IDC_TRACKBAR_FAILURE_TIMEOUT, IDC_TRACKBAR_TOP, FT_MIN, FT_MAX, m_pParams->pData->FailureTimeout, FT_PAGESIZE, IDC_DIGITAL_FAILURE_TIMEOUT);
    SendMessage(GetDlgItem(hDlg, IDC_CHECK_STATUSUPDATE), BM_SETCHECK, (WPARAM)BST_CHECKED, (LPARAM)0);
    
    if(m_pParams->pData->SUEnabled == FALSE) {
        // EnableStatusUpdate(hDlg, FALSE);
        CheckDlgButton(hDlg, IDC_CHECK_STATUSUPDATE, BST_UNCHECKED);
    } else {
        CheckDlgButton(hDlg, IDC_CHECK_STATUSUPDATE, BST_CHECKED);
    }

    return TRUE;

} // OnAllPortsInitDialog


//
//  FUNCTION: OnCommand
//
//  PURPOSE: To process windows WM_COMMAND messages
//
BOOL CAllPortsPage::OnCommand(HWND hDlg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    if(HIWORD(wParam) == BN_CLICKED) {
        // a button is being clicked.
        OnBnClicked(hDlg, wParam, lParam);
    }
    return TRUE;

} // OnCommand



//
// FUNCTION: OnWMNotify
//
// PURPOSE:  This function is called by the page in response to a WM_NOTIFY message.
// 
// lParam - second message parameter of the WM_NOTIFY message
//
BOOL CAllPortsPage::OnWMNotify(HWND hDlg, WPARAM, LPARAM lParam)
{
    switch(((NMHDR FAR *) lParam)->code) {
        case PSN_APPLY:
// 
//      The settings will be written by the apply in cfgport.cpp
//          OnOk(hDlg);
            break;
        case PSN_SETACTIVE:
            {
            }
            break;
        case PSN_RESET:
            {
            }
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            break;// do nothing
    }

    return TRUE;

} // OnWMNotify


//
//  FUNCTION: OnHscroll(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  To set the Digital Readout window text when either of the
//              trackbar thumbs are moved by the user.
//
void CAllPortsPage::OnHscroll(HWND hDlg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    TCHAR strValue[15] = NULLSTR;
    long idTrackbar = 0;
    long idDigitalReadout = 0;

    // I need the child window ID of this trackbar to get the id
    // of the corresponding static display control.
    idTrackbar = GetWindowLong((HWND)lParam, GWL_ID);
    
    if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT) {
        idDigitalReadout = IDC_DIGITAL_FAILURE_TIMEOUT;
    }

    switch(LOWORD(wParam)) // loword of wparam is the notification code.
    {
        case TB_BOTTOM: // VK_END
        case TB_ENDTRACK: // WM_KEYUP (the user released a key that sent a relevant virtual-key code)
        case TB_LINEDOWN: // VK_RIGHT or VK_DOWN
        case TB_LINEUP: // VK_LEFT or VK_UP
        case TB_PAGEDOWN: // VK_NEXT (the user clicked the channel below or to the right of the slider)
        case TB_PAGEUP: // VK_PRIOR (the user clicked the channel above or to the left of the slider)
        case TB_TOP: // VK_HOME
            {
                int iPosition = SendMessage(GetDlgItem(hDlg, idTrackbar), TBM_GETPOS, 0, 0);
                if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT)
                {
                    m_pParams->pData->FailureTimeout = iPosition;
                }
                _stprintf(strValue, TEXT("%d"), iPosition);
            }
            break;
        case TB_THUMBPOSITION: // WM_LBUTTONUP following a TB_THUMBTRACK notification message
            {
                // this is the only case where we don't have to do anything.
                // int iPosition = HIWORD(wParam);
            }
            break;
        case TB_THUMBTRACK: // Slider movement (the user dragged the slider)
            {
                int iPosition = HIWORD(wParam);
                if(idTrackbar == IDC_TRACKBAR_FAILURE_TIMEOUT)
                {
                    m_pParams->pData->FailureTimeout = iPosition;
                }

                _stprintf(strValue, TEXT("%d"), iPosition);
            }
            break;
        default:
            break;
    }

    SetWindowText(GetDlgItem(hDlg, idDigitalReadout), strValue);


} // OnHscroll


//
//  FUNCTION: OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  When the enable Status Update checkbox is checked or unchecked
//              the status update controls are enabled or disabled respectively.
//
void CAllPortsPage::OnBnClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    if(LOWORD(wParam) == IDC_CHECK_STATUSUPDATE) {
        // the Enable Status Update button was clicked.
        UINT state = IsDlgButtonChecked(hDlg, LOWORD(wParam));
        if(state == BST_UNCHECKED) {
            m_pParams->pData->SUEnabled = FALSE;
        } else {
            m_pParams->pData->SUEnabled = TRUE;
        }
    }

} // OnBnClicked


//
//  FUNCTION: SetupTrackBar(...)
//
//  PURPOSE:  To get the window position, create the track bar and setup it's range
//              and current thumb position.
//
//  Arguments: hDlg is the dialog box that will be the parent of the track bar.
//              iChildWindowID is the id given to the Track Bar
//              iPositionCtrl is the id of a picture frame on the dialog that will
//                  be used to position the track bar.
//              iRangeMin is the minimum value the track bar can be set to.
//              iRangeMax is the maximum value the track bar can be set to.
//              lPosition is the current thumb position.
//              lPageSize is the amount the thumb will jump by when the user clicks
//                  on the track bar instead of dragging the thumb around.
//              iAssociatedDigitalReadout is the static text control that displays
//                  the current value the thumb is indicating.
//              hToolTip is the tool tip control to register a tool tip with.
//
void CAllPortsPage::SetupTrackBar(HWND hDlg,
                   int iChildWindowID,
                   int iPositionCtrl,
                   int iRangeMin, 
                   int iRangeMax, 
                   long lPosition, 
                   long lPageSize, 
                   int iAssociatedDigitalReadout)
{
    HWND    hTrackBar = NULL;
    RECT    r;
    POINT   pt1;
    POINT   pt2;

    GetWindowRect(GetDlgItem(hDlg, iPositionCtrl), &r);
    pt1.x = r.left;
    pt1.y = r.top;
    pt2.x = r.right;
    pt2.y = r.bottom;
    ScreenToClient(hDlg, &pt1);
    ScreenToClient(hDlg, &pt2);     

    hTrackBar = CreateWindowEx(0, TRACKBAR_CLASS, TEXT(""), WS_VISIBLE | WS_CHILD | WS_GROUP | WS_TABSTOP |
            TBS_HORZ, pt1.x, pt1.y, pt2.x - pt1.x,
            pt2.y - pt1.y, hDlg, (HMENU)iChildWindowID, g_hInstance, NULL);
    
    SendMessage(hTrackBar, TBM_SETRANGE, TRUE, MAKELONG(iRangeMin, iRangeMax));
    SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, lPageSize);
    SendMessage(hTrackBar, TBM_SETPOS, TRUE, lPosition);

    TCHAR strValue[5];
    _stprintf(strValue, TEXT("%d"), lPosition);
    SetWindowText(GetDlgItem(hDlg, iAssociatedDigitalReadout), strValue);

} // SetupTrackBar
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addwelcm.h ===
/*****************************************************************************
 *
 * $Workfile: AddWelcm.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/TcpMonUI/AddWelcm.h $
 * 
 * 2     9/12/97 9:43a Becky
 * Added Variable m_pParams
 * 
 * 1     8/19/97 3:45p Becky
 * Redesign of the Port Monitor UI.
 * 
 *****************************************************************************/

#ifndef INC_ADDWELCOME_H
#define INC_ADDWELCOME_H

// Global Variables
extern HINSTANCE g_hInstance;

class CWelcomeDlg
{
public:
	CWelcomeDlg();
	~CWelcomeDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

private:
	ADD_PARAM_PACKAGE *m_pParams;

}; // CWelcomeDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs
INT_PTR CALLBACK WelcomeDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // INC_ADDWELCOME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\addmulti.cpp ===
/*****************************************************************************
 *
 * $Workfile: AddMulti.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "UIMgr.h"
#include "DevPort.h"
#include "AddMulti.h"
#include "Resource.h"
#include "MibABC.h"
#include "TcpMonUI.h"

//
//  FUNCTION: CMultiPortDlg constructor
//
//  PURPOSE:  initialize a CMultiPortDlg class
//
CMultiPortDlg::CMultiPortDlg() : m_DPList( )
{
    memset(&m_PortDataStandard, 0, sizeof(m_PortDataStandard));

    memset(m_szCurrentSelection, '\0', sizeof( m_szCurrentSelection ));
} // constructor


//
//  FUNCTION: CMultiPortDlg destructor
//
//  PURPOSE:  deinitialize a CMultiPortDlg class
//
CMultiPortDlg::~CMultiPortDlg()
{
} // destructor


//
//  FUNCTION: MoreInfoDialog(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK MultiPortDialog(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CMultiPortDlg *wndDlg = NULL;
    wndDlg = (CMultiPortDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);


    switch (message)
    {
        case WM_INITDIALOG:
            wndDlg = new CMultiPortDlg;
            if( wndDlg == NULL )
                return( FALSE );

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg);
            return wndDlg->OnInitDialog(hDlg, wParam, lParam);
            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            delete wndDlg;
            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CMultiPortDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (ADD_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEVICES), TRUE);

    return TRUE;

} // OnInitDialog


//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CMultiPortDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case LBN_SELCHANGE:
            return OnSelChange(hDlg, wParam, lParam);
            break;

        default:
            return FALSE;
            break;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnSelChange()
//
//  PURPOSE:  Process WM_COMMAND's LBN_SELCHANGE message
//
BOOL CMultiPortDlg::OnSelChange(HWND hDlg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    // The selection in the combo box changed.
    HWND hwndComboBox = NULL;       // handle of list box

    hwndComboBox = (HWND) lParam;
    GetPrinterData(hwndComboBox, m_pParams->pData->sztHostAddress);

    return TRUE;

} // OnSelChange


//
//  FUNCTION: GetPrinterData(HWND hwndControl, BOOL *Unknown)
//
//  PURPOSE:  Gets the socket number of the selected item.
//
//  Arguments: hwndControl is the handle of the combo box.
//
//  Return Value: Returns the socket number associated with the selected item
//
void CMultiPortDlg::GetPrinterData(HWND hwndControl,
                                   LPCTSTR pszAddress
                                   )
{
    LRESULT iSelectedIndex = 0;
    CDevicePort *pPortInfo = NULL;

    iSelectedIndex = SendMessage(hwndControl,
                                CB_GETCURSEL,
                                (WPARAM)0,
                                (LPARAM)0);

    pPortInfo = (CDevicePort *) SendMessage(hwndControl,
                                            CB_GETITEMDATA,
                                            (WPARAM)iSelectedIndex,
                                            (LPARAM)0);
    if( (DWORD_PTR)pPortInfo != CB_ERR) {
        pPortInfo->ReadPortInfo( pszAddress, &m_PortDataStandard, m_pParams->bBypassNetProbe);
        lstrcpyn( m_szCurrentSelection, pPortInfo->GetName(), MAX_SECTION_NAME);
    } else {
        m_PortDataStandard.dwPortNumber = DEFAULT_PORT_NUMBER;
        lstrcpyn(m_PortDataStandard.sztSNMPCommunity, DEFAULT_SNMP_COMUNITY, MAX_SNMP_COMMUNITY_STR_LEN);
        m_PortDataStandard.dwSNMPDevIndex = 1;
    }

} // GetPrinterData


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CMultiPortDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code) {
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return TRUE;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            OnSetActive(hDlg);
            break;

        case PSN_WIZBACK:
            if ( m_pParams->dwDeviceType == SUCCESS_DEVICE_MULTI_PORT ) {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_ADDPORT);
            } else {
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, IDD_DIALOG_MORE_INFO);
            }

            memcpy( m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1) );

            break;
        case PSN_WIZNEXT:
                // the Next button was pressed
            memcpy( m_pParams->pData, &m_PortDataStandard, sizeof(PORT_DATA_1) );

            return FALSE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnSetActive()
//
//  PURPOSE:  Process PSN_SETACTIVE part of the WM_NOTIFY message
//
void CMultiPortDlg::OnSetActive(HWND hDlg)
{
    TCHAR sztMoreInfoReason[MAX_MULTIREASON_STRLEN] = NULLSTR;

    memcpy( &m_PortDataStandard, m_pParams->pData, sizeof(PORT_DATA_1) );

    FillComboBox(hDlg);

    LoadString(g_hInstance, IDS_STRING_MULTI_PORT_DEV, sztMoreInfoReason, MAX_MULTIREASON_STRLEN);

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_MOREINFO_REASON), sztMoreInfoReason);
} // OnSetActive



//
//  FUNCTION: FillComboBox(HWND hDlg)
//
//  PURPOSE:  Fills the combo box with values gotten from the ini file.
//              The associated item data is used to pair the port number with the
//              device types.
//
//  Arguments: hDlg is the handle of the dialog box.
//
void CMultiPortDlg::FillComboBox(HWND hDlg)
{
    LRESULT index = 0;
    HWND hList = NULL;
    CDevicePort *pDP = NULL;

    hList = GetDlgItem(hDlg, IDC_COMBO_DEVICES);
    // Possible Values in m_pParams->dwDeviceType:
    //  ERROR_DEVICE_NOT_FOUND
    //  SUCCESS_DEVICE_MULTI_PORT
    //  SUCCESS_DEVICE_UNKNOWN


    index = SendMessage(hList, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    //
    // Initialize the list of variables
    //
    m_DPList.GetDevicePortsList(m_pParams->sztSectionName);

    for(pDP = m_DPList.GetFirst(); pDP != NULL; pDP = m_DPList.GetNext())
    {
        index = SendMessage(hList,
                            CB_ADDSTRING,
                            (WPARAM)0,
                            (LPARAM)pDP->GetName());
        SendMessage(hList,
                    CB_SETITEMDATA,
                    (WPARAM)index,
                    (LPARAM)pDP);
    }

    if( *m_szCurrentSelection != '\0' ) {
        index = SendMessage(hList,
                            CB_SELECTSTRING,
                            (WPARAM)-1,
                            (LPARAM)m_szCurrentSelection);
        if (index == CB_ERR) {
            // Error the selected string is not in the list, which implies that the user has
            // selected a different network card, so we set the choice to the first one

            index = 0;
        }

    }
    else
        index = 0;

    SendMessage(hList, CB_SETCURSEL, (WPARAM)index, (LPARAM)0);

    GetPrinterData( hList, m_pParams->pData->sztHostAddress );

} // FillComboBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgport.h ===
/*****************************************************************************
 *
 * $Workfile: CfgPort.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_CONFIG_PORT_H
#define INC_CONFIG_PORT_H

// Global Variables
extern HINSTANCE g_hInstance;

class CConfigPortDlg
{
public:
	CConfigPortDlg();
	~CConfigPortDlg();

public:
	BOOL OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
	BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

protected:
	void CheckProtocolAndEnable(HWND hDlg, int idButton);
	void CheckSNMPAndEnable(HWND hDlg, BOOL Check);
	void OnOk(HWND hDlg);
	void SaveSettings(HWND hDlg);
	BOOL OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM);
	void OnSetActive(HWND hDlg);
	BOOL OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);

	void HostAddressOk(HWND hDlg);
	void PortNumberOk(HWND hDlg);
	void QueueNameOk(HWND hDlg);
	void CommunityNameOk(HWND hDlg);
	void DeviceIndexOk(HWND hDlg);

	DWORD RemoteTellPortMonToModifyThePort();
	DWORD LocalTellPortMonToModifyThePort();

private:
	CFG_PARAM_PACKAGE *m_pParams;
	CInputChecker m_InputChkr;
	BOOL m_bDontAllowThisPageToBeDeactivated;

}; // CConfigPortDlg

#ifdef __cplusplus
extern "C" {
#endif

// Dialogs

INT_PTR CALLBACK ConfigurePortPage(
	HWND hDlg,
	UINT message,
	WPARAM wParam,
	LPARAM lParam);


#ifdef __cplusplus
}
#endif

#endif // INC_CONFIG_PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\cfgport.cpp ===
/*****************************************************************************
 *
 * $Workfile: CfgPort.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "CfgPort.h"
#include "Resource.h"

#include "LPRData.h"
#include "RTcpData.h"
#include "..\TcpMon\LPRIfc.h"

//
//  FUNCTION: CConfigPortDlg constructor
//
//  PURPOSE:  initialize a CConfigPortDlg class
//
CConfigPortDlg::CConfigPortDlg()
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // constructor


//
//  FUNCTION: CConfigPortDlg destructor
//
//  PURPOSE:  deinitialize a CConfigPortDlg class
//
CConfigPortDlg::~CConfigPortDlg()
{
} // destructor


//
//  FUNCTION: ConfigurePortPage(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  To process messages from the summary dialog for adding a port.
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_COMMAND - handles button presses and text changes in edit controls.
//
//
INT_PTR CALLBACK ConfigurePortPage(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    CConfigPortDlg *wndDlg = NULL;
    wndDlg = (CConfigPortDlg *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            wndDlg = new CConfigPortDlg;
            if( wndDlg == NULL )
                return( FALSE );

            //
            // If the function succeeds, the return value is the previous value of the specified offset.
            //
            // If the function fails, the return value is zero. To get extended error
            // information, call GetLastError.
            //
            // If the previous value is zero and the function succeeds, the return value is zero,
            // but the function does not clear the last error information. To determine success or failure,
            // clear the last error information by calling SetLastError(0), then call SetWindowLongPtr.
            // Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            //

            SetLastError (0);
            if (!SetWindowLongPtr(hDlg, GWLP_USERDATA, (UINT_PTR)wndDlg) && GetLastError()) {
                delete wndDlg;
                return FALSE;
            }
            else
                return wndDlg->OnInitDialog(hDlg, wParam, lParam);

            break;

        case WM_COMMAND:
            return wndDlg->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return wndDlg->OnNotify(hDlg, wParam, lParam);
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            OnHelp(IDD_PORT_SETTINGS, hDlg, message, wParam, lParam);
            break;

        case WM_DESTROY:
            if (wndDlg)
                delete wndDlg;

            break;

        default:
            return FALSE;
    }
    return TRUE;

} // AddPortDialog


//
//  FUNCTION: OnInitDialog(HWND hDlg)
//
//  PURPOSE:  Initialize the dialog.
//
BOOL CConfigPortDlg::OnInitDialog(HWND hDlg, WPARAM, LPARAM lParam)
{
    m_pParams = (CFG_PARAM_PACKAGE *) ((PROPSHEETPAGE *) lParam)->lParam;

    if(m_pParams->bNewPort == FALSE) {
        SendMessage(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), EM_SETREADONLY, TRUE, 0);
    }

    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), MAX_ADDRESS_LENGTH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), MAX_PORTNAME_LEN - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), MAX_PORTNUM_STRING_LENGTH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), MAX_QUEUENAME_LEN - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), MAX_SNMP_COMMUNITY_STR_LEN);
    Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), MAX_SNMP_DEVICENUM_STRING_LENGTH - 1);

    OnSetActive(hDlg);

    return TRUE;

} // OnInitDialog


//
// Function: OnSetActive()
//
// Purpose: To Set all the text fields and make sure the proper buttons are checked.
//
void CConfigPortDlg::OnSetActive(HWND hDlg)
{
    TCHAR psztPortNumber[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    TCHAR psztSNMPDevIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    TCHAR szTemp[MAX_PATH];

    lstrcpyn(szTemp, m_pParams->pData->sztHostAddress, SIZEOF_IN_CHAR(szTemp));
    m_InputChkr.MakePortName( szTemp, COUNTOF (szTemp) );
    if ( m_pParams->bNewPort    &&
         ((_tcscmp(m_pParams->pData->sztHostAddress,
                   m_pParams->pData->sztPortName) == 0) ||
          (_tcscmp(m_pParams->pData->sztPortName, szTemp) == 0 ))) {

        m_InputChkr.LinkPortNameAndAddressInput();
    } else {

        m_InputChkr.UnlinkPortNameAndAddressInput();
    }

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS),
                  m_pParams->pData->sztHostAddress);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME),
                  m_pParams->pData->sztPortName);

    switch (m_pParams->pData->dwProtocol) {

        case PROTOCOL_LPR_TYPE :
            CheckProtocolAndEnable(hDlg, IDC_RADIO_LPR);
            break;
        case PROTOCOL_RAWTCP_TYPE:
            CheckProtocolAndEnable(hDlg, IDC_RADIO_RAW);
            break;
        default:
            break;
    }

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME),
                  m_pParams->pData->sztQueue);

    if( m_pParams->pData->dwDoubleSpool )
    {
        CheckDlgButton(hDlg, IDC_CHECK_LPR_DOUBLESPOOL, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_CHECK_LPR_DOUBLESPOOL, BST_UNCHECKED);
    }


    StringCchPrintf (psztPortNumber, COUNTOF (psztPortNumber), TEXT("%d"), m_pParams->pData->dwPortNumber);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM),
                  psztPortNumber);

    CheckSNMPAndEnable(hDlg, m_pParams->pData->dwSNMPEnabled);

    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME),
                  m_pParams->pData->sztSNMPCommunity);

    StringCchPrintf (psztSNMPDevIndex, COUNTOF (psztSNMPDevIndex), TEXT("%d"), m_pParams->pData->dwSNMPDevIndex);
    SetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), psztSNMPDevIndex);

    m_bDontAllowThisPageToBeDeactivated = FALSE;

} // OnSetActive


//
//  FUNCTION: CheckProtocolAndEnable()
//
//  PURPOSE:  Check the radio button whose id is passed in
//      in idButton.  Enable the corresponding set of controls
//      and disable the controls corresponding to the other
//      radio button.
//
void CConfigPortDlg::CheckProtocolAndEnable(HWND hDlg, int idButton)
{
    CheckRadioButton(hDlg, IDC_RADIO_RAW, IDC_RADIO_LPR, idButton);

    switch ( idButton ) {

        case IDC_RADIO_LPR:
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RAW_PORT_NUM), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_LPR_QNAME), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_LPR_DOUBLESPOOL), TRUE);
            break;

    case IDC_RADIO_RAW: {
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RAW_PORT_NUM), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), TRUE);

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_LPR_QNAME), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_LPR_DOUBLESPOOL), FALSE);

            const int iSize = 6;
            TCHAR pString[iSize] = NULLSTR;
            TCHAR pCompareString[iSize] = NULLSTR;

            StringCchPrintf (pCompareString, COUNTOF (pCompareString), TEXT("%d"), LPR_PORT_1);
            GetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), pString, iSize);
            if( _tcscmp(pString, pCompareString) == 0 ) {

                StringCchPrintf (pString, COUNTOF (pString), TEXT("%d"), SUPPORTED_PORT_1);
                SetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM), pString);
            }
        }
        break;

    default:
        break;
    }

} // CheckProtocolAndEnable


//
//  FUNCTION: CheckSNMPAndEnable()
//
//  PURPOSE:  Check the SNMP CheckBox and Enable the corresponding controls
//          or uncheck and disable.
//
void CConfigPortDlg::CheckSNMPAndEnable(HWND hDlg, BOOL Check)
{
    if(Check != FALSE) {
        CheckDlgButton(hDlg, IDC_CHECK_SNMP, BST_CHECKED);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_COMMUNITY_NAME), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE_INDEX), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), TRUE);
    } else {
        CheckDlgButton(hDlg, IDC_CHECK_SNMP, BST_UNCHECKED);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_COMMUNITY_NAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE_INDEX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_DEVICE_INDEX), FALSE);
    }

} // CheckSNMPAndEnable

//
//  FUNCTION: OnCommand()
//
//  PURPOSE:  Process WM_COMMAND message
//
BOOL CConfigPortDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch(HIWORD(wParam)) {
        case BN_CLICKED:
            return OnButtonClicked(hDlg, wParam, lParam);
            break;

        case EN_UPDATE:
            // one of the text controls had text changed in it.
            return OnEnUpdate(hDlg, wParam, lParam);
            break;

        default:
            break;
    }

    return TRUE;

} // OnCommand


//
//  FUNCTION: OnEnUpdate()
//
//  PURPOSE:  Process EN_UPDATE message
//
BOOL CConfigPortDlg::OnEnUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int idEditCtrl = (int) LOWORD(wParam);
    HWND hwndEditCtrl = NULL;

    hwndEditCtrl = (HWND) lParam;

    if(idEditCtrl == IDC_EDIT_DEVICE_ADDRESS) {
        m_InputChkr.OnUpdateAddress(hDlg, idEditCtrl, hwndEditCtrl, m_pParams->pszServer);
    }

    //
    // Port name is a read-only field
    //
    //  if(idEditCtrl == IDC_EDIT_PORT_NAME)
    //      m_InputChkr.OnUpdatePortName(idEditCtrl, hwndEditCtrl);
    //

    if(idEditCtrl == IDC_EDIT_RAW_PORT_NUM) {
        m_InputChkr.OnUpdatePortNumber(idEditCtrl, hwndEditCtrl);
    }

    if(idEditCtrl == IDC_EDIT_LPR_QNAME) {
        m_InputChkr.OnUpdateQueueName(idEditCtrl, hwndEditCtrl);
    }

    if(idEditCtrl == IDC_EDIT_COMMUNITY_NAME) {
        // No function needed since any character is ok.
    }

    if(idEditCtrl == IDC_EDIT_DEVICE_INDEX) {
        m_InputChkr.OnUpdateDeviceIndex(idEditCtrl, hwndEditCtrl);
    }

    return TRUE;

} // OnEnUpdate


//
//  FUNCTION: OnButtonClicked()
//
//  PURPOSE:  Process BN_CLICKED message
//
BOOL CConfigPortDlg::OnButtonClicked(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int  idButton = (int) LOWORD(wParam);    // identifier of button
    HWND hwndButton = NULL;

    hwndButton = (HWND) lParam;

    switch(idButton) {
        case IDC_CHECK_SNMP:
        {
            LRESULT iCheck = SendMessage(hwndButton, BM_GETCHECK, 0, 0);
            switch( iCheck ) {
                case BST_UNCHECKED:
                    CheckSNMPAndEnable(hDlg, FALSE);
                    break;

                case BST_CHECKED:
                    CheckSNMPAndEnable(hDlg, TRUE);
                    break;

                default:
                    //
                    // False by Default
                    CheckSNMPAndEnable(hDlg, FALSE);
                    break;
            }
        }
        break;

        case IDC_RADIO_RAW:
        case IDC_RADIO_LPR:
            CheckProtocolAndEnable(hDlg, idButton);
            break;

        default:
            break;

    }
    return TRUE;

} // OnButtonClicked


//
//  FUNCTION: OnNotify()
//
//  PURPOSE:  Process WM_NOTIFY message
//
BOOL CConfigPortDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((NMHDR FAR *) lParam)->code)
    {
        case PSN_APPLY:
            OnOk(hDlg);
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return TRUE;
            break;

        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;

        case PSN_SETACTIVE:
            OnSetActive(hDlg);
            break;

        case PSN_KILLACTIVE:
            SaveSettings(hDlg);
            // If the page requires additional user input before losing the
            // activation, it should use the SetWindowLong function to set the
            // DWL_MSGRESULT value of the page to TRUE. Also, the page should
            // display a message box that describes the problem and provides
            // the recommended action. The page should set DWL_MSGRESULT to FALSE
            // when it is okay to lose the activation.
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, m_bDontAllowThisPageToBeDeactivated);
            return TRUE;
            break;

        case PSN_QUERYCANCEL:
            m_pParams->dwLastError = ERROR_CANCELLED;
            return FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

} // OnCommand


//
// FUNCTION: RemoteTellPortMonToModifyThePort
//
// PURPOSE:  Loads the spooler drv and calls XcvData.
//
DWORD CConfigPortDlg::RemoteTellPortMonToModifyThePort()
{
    DWORD dwRet = NO_ERROR;
    XCVDATAPARAM pfnXcvData = NULL;

    // load & assign the function pointer
    if(g_hWinSpoolLib != NULL) {

        // initialize the library
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
        if(pfnXcvData != NULL) {

            DWORD dwOutputNeeded = 0;
            DWORD dwStatus = 0;

            // here's the call we've all been waiting for:
            DWORD dwReturn = (*pfnXcvData)(m_pParams->hXcvPrinter,
                                (PCWSTR)TEXT("ConfigPort"),
                                (PBYTE)m_pParams->pData,
                                m_pParams->pData->cbSize,
                                NULL,
                                0,
                                &dwOutputNeeded,
                                &dwStatus
                                );
            if(!dwReturn) {
                dwRet = GetLastError();
            } else {
                if(dwStatus != NO_ERROR) {
                    dwRet = dwStatus;
                }
            }
        } else {
            dwRet = ERROR_DLL_NOT_FOUND; // TODO: change to an appropriate error code.
        }
    } else {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    m_pParams->dwLastError = dwRet;
    return dwRet;

} // RemoteTellPortMonToModifyThePort


//
//  FUNCTION: LocalTellPortMonToModifyThePort
//
//  Purpose: To load the port monitor dll and call ConfigPortUIEx
//
DWORD CConfigPortDlg::LocalTellPortMonToModifyThePort()
{
    DWORD dwRet = NO_ERROR;
    UIEXPARAM pfnConfigPortUIEx = NULL ;

    if(g_hPortMonLib != NULL) {
        // initialize the library
        pfnConfigPortUIEx = (UIEXPARAM)::GetProcAddress(g_hPortMonLib, "ConfigPortUIEx");
        if(pfnConfigPortUIEx != NULL) {
            // here's the call we've all been waiting for:
            BOOL bReturn = (*pfnConfigPortUIEx)(m_pParams->pData);
            if(bReturn == FALSE) {
                dwRet = GetLastError();
            }
        } else {
            dwRet = ERROR_DLL_NOT_FOUND;
        }
    } else {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    m_pParams->dwLastError = dwRet;
    return dwRet;

} // LocalTellPortMonToModifyThePort


//
//  FUNCTION OnOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::OnOk(HWND hDlg)
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

    HostAddressOk(hDlg);

    if(IsDlgButtonChecked(hDlg, IDC_RADIO_LPR) == BST_CHECKED) {
        m_pParams->pData->dwProtocol = PROTOCOL_LPR_TYPE;
        m_pParams->pData->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;
        QueueNameOk(hDlg);
    } else { // IDC_RADIO_RAW
        m_pParams->pData->dwProtocol = PROTOCOL_RAWTCP_TYPE;
        PortNumberOk(hDlg);
    }

    if(IsDlgButtonChecked(hDlg, IDC_CHECK_SNMP) == BST_CHECKED) {
        m_pParams->pData->dwSNMPEnabled = TRUE;
        CommunityNameOk(hDlg);
        DeviceIndexOk(hDlg);
    } else {
        m_pParams->pData->dwSNMPEnabled = FALSE;
    }


    if(m_pParams->bNewPort == FALSE &&
        m_bDontAllowThisPageToBeDeactivated == FALSE) {

        HCURSOR hOldCursor = NULL;
        HCURSOR hNewCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if( hNewCursor )
        {
            hOldCursor = SetCursor(hNewCursor);
        }
        // The port is not just being created so we can tell the PortMon to
        // modify the port... it is an existing port.

        // There were no errors, so we can go ahead and modify this port.
        if(m_pParams->hXcvPrinter != NULL) {
            RemoteTellPortMonToModifyThePort();
        } else {
            LocalTellPortMonToModifyThePort();
        }

        if( hNewCursor )
        {
            SetCursor(hOldCursor);
        }
    }

} // OnOk

//
//  FUNCTION OnOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::SaveSettings(HWND hDlg)
{
    m_bDontAllowThisPageToBeDeactivated = FALSE;

    HostAddressOk(hDlg);

    if(IsDlgButtonChecked(hDlg, IDC_RADIO_LPR) == BST_CHECKED) {
        m_pParams->pData->dwProtocol = PROTOCOL_LPR_TYPE;
        m_pParams->pData->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;
        if( IsDlgButtonChecked(hDlg, IDC_CHECK_LPR_DOUBLESPOOL) == BST_CHECKED )
        {
            m_pParams->pData->dwDoubleSpool = TRUE;
        }
        else
        {
            m_pParams->pData->dwDoubleSpool = FALSE;
        }
        QueueNameOk(hDlg);
    } else {// IDC_RADIO_RAW
        m_pParams->pData->dwProtocol = PROTOCOL_RAWTCP_TYPE;
        PortNumberOk(hDlg);
    }

    if(IsDlgButtonChecked(hDlg, IDC_CHECK_SNMP) == BST_CHECKED) {
        m_pParams->pData->dwSNMPEnabled = TRUE;
        CommunityNameOk(hDlg);
        DeviceIndexOk(hDlg);
    } else {
        m_pParams->pData->dwSNMPEnabled = FALSE;
    }

} // SaveSettings

//
//  FUNCTION HostAddressOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::HostAddressOk(HWND hDlg)
{
    TCHAR ptcsAddress[MAX_ADDRESS_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_DEVICE_ADDRESS), ptcsAddress, MAX_ADDRESS_LENGTH);

    if(! m_InputChkr.AddressIsLegal(ptcsAddress)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ADDRESS_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztHostAddress, ptcsAddress, MAX_NETWORKNAME_LEN);

} // HostAddressOk


//
//  FUNCTION PortNumberOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::PortNumberOk(HWND hDlg)
{
    TCHAR psztPortNumber[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_RAW_PORT_NUM),
                  psztPortNumber,
                  MAX_PORTNUM_STRING_LENGTH);

    if(! m_InputChkr.PortNumberIsLegal(psztPortNumber)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_PORT_NUMBER_NOT_VALID);
        return;
    }

    m_pParams->pData->dwPortNumber = _ttol(psztPortNumber);

} // PortNumberOk


//
//  FUNCTION QueueNameOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::QueueNameOk(HWND hDlg)
{
    TCHAR ptcsQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_LPR_QNAME),
                  ptcsQueueName,
                  MAX_QUEUENAME_LEN);

    if(! m_InputChkr.QueueNameIsLegal(ptcsQueueName))
    {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_QNAME_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztQueue, ptcsQueueName, MAX_QUEUENAME_LEN);

} // QueueNameOk


//
//  FUNCTION CommunityNameOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::CommunityNameOk(HWND hDlg)
{
    TCHAR ptcsCommunityName[MAX_SNMP_COMMUNITY_STR_LEN] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg, IDC_EDIT_COMMUNITY_NAME),
                  ptcsCommunityName,
                  MAX_SNMP_COMMUNITY_STR_LEN);

    if(! m_InputChkr.CommunityNameIsLegal(ptcsCommunityName)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_COMMUNITY_NAME_NOT_VALID);
        return;
    }

    lstrcpyn(m_pParams->pData->sztSNMPCommunity, ptcsCommunityName, MAX_SNMP_COMMUNITY_STR_LEN);

} // CommunityNameOk


//
//  FUNCTION DeviceIndexOk()
//
//  PURPOSE:    To validate the input and set the values in m_pParams->pData
//
void CConfigPortDlg::DeviceIndexOk(HWND hDlg)
{
    TCHAR psztSNMPDevIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(GetDlgItem(hDlg,
                             IDC_EDIT_DEVICE_INDEX),
                             psztSNMPDevIndex,
                             MAX_SNMP_DEVICENUM_STRING_LENGTH);

    if(! m_InputChkr.SNMPDevIndexIsLegal(psztSNMPDevIndex)) {
        m_bDontAllowThisPageToBeDeactivated = TRUE;
        DisplayErrorMessage(hDlg,
                            IDS_STRING_ERROR_TITLE,
                            IDS_STRING_ERROR_SNMP_DEVINDEX_NOT_VALID);
        return;
    }

    m_pParams->pData->dwSNMPDevIndex = _ttol(psztSNMPDevIndex);

} // DeviceIndexOk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\devport.cpp ===
/*****************************************************************************
 *
 * $Workfile: DevPort.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "DevPort.h"
#include "winreg.h"
#include "TcpMonUI.h"
#include "rtcpdata.h"
#include "lprdata.h"
#include "inisection.h"

//
//  FUNCTION: CDevicePortList Constructor
//
//  PURPOSE: to construct a list of devices and their associated ports
//          from the registry, an ini file or from a static table in the code.
//
CDevicePortList::CDevicePortList() : m_pList( NULL ), m_pCurrent( NULL )
{
} // Constructor


//
//  FUNCTION: CDevicePortList Destructor
//
//  PURPOSE: clean up
//
CDevicePortList::~CDevicePortList()
{
    DeletePortList();
} // Destructor

void
CDevicePortList::DeletePortList()
{
    while(m_pList != NULL)
    {
        m_pCurrent = m_pList->GetNextPtr();
        delete m_pList;
        m_pList = m_pCurrent;
    }
}

//
//  FUNCTION: GetDevicePortsList
//
//  PURPOSE: To create a Device types list getting values from the ini file.
//
BOOL CDevicePortList::GetDevicePortsList(LPTSTR pszDeviceName)
{
    BOOL    bRet = FALSE;
    TCHAR   szSystemPath[MAX_PATH] = NULLSTR;
    TCHAR   szFileName[MAX_PATH] = NULLSTR;
    size_t  cchFileName = COUNTOF (szFileName);

    DeletePortList();

    GetSystemDirectory(szSystemPath, sizeof(szSystemPath) / sizeof (TCHAR));
    StringCchCopy (szFileName, cchFileName, szSystemPath);
    StringCchCat (szFileName, cchFileName, PORTMONITOR_INI_FILE );

    //
    // Get the section names from the ini file:
    //
    if( pszDeviceName == NULL ) { // Get all the devices

        DWORD nSize = 0;
        TCHAR *lpszReturnBuffer = NULL;

        if ( !GetSectionNames(szFileName, &lpszReturnBuffer, nSize) )
            goto Done;

        //
        // For each section name Load up the number of ports
        //
        TCHAR *lpszSectionName = lpszReturnBuffer;
        LPCTSTR lpKeyName = PORTS_KEY;
        while( lpszSectionName && *lpszSectionName ) {

            TCHAR KeyName[26] = NULLSTR;
            LPCTSTR lpPortsKeyName = PORTS_KEY;
            UINT NumberOfPorts = GetPrivateProfileInt(lpszSectionName,
                                                      lpPortsKeyName,
                                                      0,
                                                      szFileName);
            //
            // Name
            //
            StringCchPrintf (KeyName, COUNTOF (KeyName), PORT_NAME_KEY);
            TCHAR tcsPortName[MAX_PORTNAME_LEN] = NULLSTR;
            if ( GetPrivateProfileString(lpszSectionName,
                                         KeyName,
                                         TEXT(""),
                                         tcsPortName,
                                         MAX_PORTNAME_LEN,
                                         szFileName)    ) {

                //
                // Setup a new DevicePort struct
                //
                if ( m_pCurrent  = new CDevicePort() ) {

                    m_pCurrent->Set(tcsPortName,
                                    _tcslen(tcsPortName),
                                    lpszSectionName,
                                    _tcslen(lpszSectionName),
                                    (NumberOfPorts == 1));

                   m_pCurrent->SetNextPtr(m_pList);
                   m_pList = m_pCurrent;
                }
                else
                    // Out of memory, abort
                    //
                    goto Done;
            }
            /* else
                If the call fails, we continue to the next adapter name */

            lpszSectionName = _tcschr(lpszSectionName, '\0'); // find the end of the current string.
            lpszSectionName = _tcsinc(lpszSectionName); // increment to the beginning of the next string.
        }

        //
        // free memory
        //
        free(lpszReturnBuffer);

    } else  {// Just the names in multiport section

        TCHAR     KeyName[26];

        //
        // Name
        //
        LPCTSTR lpKeyName = PORTS_KEY;
        UINT NumberOfPorts = GetPrivateProfileInt(pszDeviceName,
                                                  lpKeyName,
                                                  0,
                                                  szFileName);

        for ( UINT i=0; i<NumberOfPorts; i++ ) {

            StringCchPrintf (KeyName, COUNTOF (KeyName), PORT_NAMEI_KEY, i+1);
            TCHAR tcsPortName[50] = NULLSTR;
            GetPrivateProfileString(pszDeviceName, KeyName,
                                    TEXT(""), tcsPortName, 50, szFileName);

            //
            // Setup a new DevicePort struct
            //
            if ( m_pCurrent = new CDevicePort() ) {

                m_pCurrent->Set(tcsPortName,
                                _tcslen(tcsPortName),
                                pszDeviceName,
                               _tcslen(pszDeviceName), i+1);
                m_pCurrent->SetNextPtr(m_pList);

                m_pList = m_pCurrent;
            }
            else
                goto Done;
        }
    }

    bRet = TRUE;
Done:
    //
    // Do not leave with a partial list
    //
    if ( !bRet )
        DeletePortList();

    return bRet;
} // GetDevicePortsList


//
//  FUNCTION: ReadPortInfo
//
//  PURPOSE: To read information about a device from the ini file.
//
void CDevicePort::ReadPortInfo( LPCTSTR pszAddress, PPORT_DATA_1 pPortInfo, BOOL bBypassNetProbe)
{
    IniSection *pIniSection;

    if ( m_psztPortKeyName ) {

        if ( pIniSection = new IniSection() ) {

            pIniSection->SetIniSection( m_psztPortKeyName );

            pIniSection->GetPortInfo( pszAddress, pPortInfo, m_dwPortIndex, bBypassNetProbe);
            delete( pIniSection );
        }
    }
} // ReadPortInfo


//
//  FUNCTION: GetSectionNames
//
//  PURPOSE:
//
BOOL
CDevicePortList::
GetSectionNames(
    LPCTSTR lpFileName,
    TCHAR **lpszReturnBuffer,
    DWORD &nSize
)
{
    DWORD   nReturnSize = 0;
    LPTSTR  pNewBuf;

    do
    {
        nSize += 512;
        pNewBuf = (TCHAR *)realloc(*lpszReturnBuffer, nSize * sizeof(TCHAR));

        if ( pNewBuf == NULL )
        {
            if ( *lpszReturnBuffer )
            {
                free(*lpszReturnBuffer);
                *lpszReturnBuffer = NULL;
            }
            return FALSE;
        }

        *lpszReturnBuffer = pNewBuf;

        nReturnSize = GetPrivateProfileSectionNames(*lpszReturnBuffer, nSize, lpFileName);

    } while(nReturnSize >= nSize-2);

    return TRUE;

} // GetSectionNames


//
//  FUNCTION: CDevicePort Constructor
//
//  PURPOSE:
//
CDevicePort::CDevicePort()
{
    m_psztName = NULL;
    m_psztPortKeyName = NULL;
    m_pNext = NULL;

} // Constructor


//
//  FUNCTION: CDevicePort Destructor
//
//  PURPOSE:
//
CDevicePort::~CDevicePort()
{
    if(m_psztName != NULL)
    {
        delete m_psztName;
    }
    if(m_psztPortKeyName != NULL)
    {
        delete m_psztPortKeyName;
    }

} // destructor


//
//  FUNCTION: Set
//
//  PURPOSE:
//
void CDevicePort::Set(TCHAR *psztNewName,
        DWORD dwNameSize,
        TCHAR *psztNewKeyName,
        DWORD dwNewKeyNameSize,
        DWORD dwPortIndex)
{
    if ( psztNewName != NULL ) {

        if ( m_psztName != NULL ) {

            delete m_psztName;
            m_psztName = NULL;
        }

        if ( dwNameSize == 0 )
            dwNameSize = _tcslen(psztNewName);

        m_psztName = new TCHAR[(dwNameSize + 1) * sizeof(TCHAR)];
        if ( m_psztName )
            lstrcpyn(m_psztName, psztNewName, dwNameSize+1);
    }

    if ( psztNewKeyName != NULL ) {

        if ( m_psztPortKeyName != NULL ) {

            delete m_psztPortKeyName;
            m_psztPortKeyName = NULL;
        }

        if ( dwNewKeyNameSize == 0 ) {

            dwNewKeyNameSize = _tcslen(psztNewKeyName);
        }

        m_psztPortKeyName = new TCHAR[(dwNewKeyNameSize + 1) * sizeof(TCHAR)];
        if ( m_psztPortKeyName ) {

            lstrcpyn(m_psztPortKeyName, psztNewKeyName, dwNewKeyNameSize+1);
        }
    }

    m_dwPortIndex = dwPortIndex;

} // Set
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\devport.h ===
/*****************************************************************************
 *
 * $Workfile: DevPort.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_DEV_PORT_INFO_H
#define INC_DEV_PORT_INFO_H

// This class' purpose is to store Name and PortNum pairs.
class CDevicePort
{
public:
    CDevicePort();
    ~CDevicePort();

    VOID Set(TCHAR *psztNewName,
             DWORD dwNameSize,
             TCHAR *psztKeyName = NULL,
             DWORD dwKeyNameSize = 0,
             DWORD dwPortIndex = 1);

    LPCTSTR GetName() {return (LPCTSTR)m_psztName;}
    const DWORD	GetPortIndex() { return (const DWORD )m_dwPortIndex; }
    LPCTSTR GetPortKeyName() {return (LPCTSTR)m_psztPortKeyName;}
    VOID ReadPortInfo(LPCTSTR pszAddress, PPORT_DATA_1 pPortInfo, BOOL bBypassNetProbe);
    VOID SetNextPtr(CDevicePort *ptr) { m_pNext = ptr; }
    CDevicePort *GetNextPtr() { return m_pNext; }

private:
    TCHAR *m_psztPortKeyName;
    TCHAR *m_psztName;
    DWORD m_dwPortIndex;
    CDevicePort *m_pNext;
    TCHAR m_psztFileName[MAX_PATH];
};

// This class manages the list of DevicePorts.
class CDevicePortList
{
public:
    CDevicePortList();
    ~CDevicePortList();

    VOID DeletePortList();

    BOOL GetDevicePortsList(LPTSTR pszDeviceName);
    CDevicePort *GetFirst() {m_pCurrent = m_pList; return(m_pCurrent);}
    CDevicePort *GetNext() {m_pCurrent = m_pCurrent->GetNextPtr(); return(m_pCurrent);}
    CDevicePort *GetCurrent() { return m_pCurrent; }

protected:
    BOOL GetSectionNames(LPCTSTR lpFileName, TCHAR **lpszReturnBuffer, DWORD &nSize);

private:
    CDevicePort *m_pList;
    CDevicePort *m_pCurrent;
};

#endif // INC_DEV_PORT_INFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\hostname.h ===
/*****************************************************************************
 *
 * $Workfile: HostName.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_HOSTNAME_H
#define INC_HOSTNAME_H

#define MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH 128
#define MAX_HOSTNAME_LEN MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH

class CHostName
{
public:
	CHostName();
	CHostName(LPTSTR psztHostName);
	~CHostName();

		// if the string passed in to IsValid in AddressString param is not a valid
		// host name then the returnVal is filled with the last valid HostName from
		// the previous time this method was called.  This facilitates validation for
		// each keystroke the user makes.
	BOOL IsValid(TCHAR * psztAddressString, TCHAR * psztReturnVal = NULL, DWORD cRtnVal = 0);
	BOOL IsValid();

	void SetAddress(TCHAR *psztAddressString);
	void ToString(TCHAR *psztBuffer, int iSize);

private:
	TCHAR m_psztAddress[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH];
	TCHAR m_psztStorageString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH];

};


#endif // INC_HOSTNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inisection.cpp ===
/*++

Copyright (c) 97 Microsoft Corporation
All rights reserved.

Module Name:

    IniSection.cpp

Abstract:

    Standard TCP/IP Port Monitor class to handle INI file settings

Author:
    Muhunthan Sivapragasam (MuhuntS) 19-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "tcpmonui.h"
#include "rtcpdata.h"
#include "lprdata.h"
#include "IniSection.h"

BOOL
StringMatch(
    LPCTSTR     psz1,
    LPCTSTR     psz2    // * is a wild char in this
    )
{
    LPCTSTR  p1 = NULL, p2 = NULL;

    for ( p1 = psz1, p2 = psz2 ; *p1 && *p2 ; ) {

        //
        // A * matches any sub-string
        //
        if ( *p2 == TEXT('*') ) {

            ++p2;
            if ( !*p2 ) {
                return TRUE;
            }

            for ( ; *p1 ; ++p1 )
                if ( StringMatch(p1, p2) ) {
                    return TRUE;
                }

            break;
        } else if ( *p1 == *p2 ) {

            ++p1;
            ++p2;
        } else
            break;
    }

    if( !*p1 && *p2 == TEXT( '*' ))
    {
        ++p2;
        if (!*p2 ) {
            return TRUE;
        }
    }

    return !*p1 && !*p2;
}


BOOL
IniSection::
FindINISectionFromPortDescription(
    LPCTSTR   pszPortDesc
    )
/*++

--*/
{
    LPTSTR      pszBuf = NULL, pszKey = NULL;
    DWORD       rc = 0,  dwLen = 0, dwBufLen = 1024;
    BOOL        bRet = FALSE;

    pszBuf  = (LPTSTR) malloc(dwBufLen*sizeof(TCHAR));

    //
    // Read all the key names in the ini file
    //
    while ( pszBuf ) {

        rc = GetPrivateProfileString(PORT_SECTION,
                                     NULL,
                                     NULL,
                                     pszBuf,
                                     dwBufLen,
                                     m_szIniFileName);

        if ( rc == 0 ) {
            goto Done;
        }

        if ( rc < dwBufLen - 2 ) {
            break; // Succesful exit; Read all port descriptions
        }

        free(pszBuf);
        dwBufLen *= 2;

        pszBuf = (LPTSTR) malloc(dwBufLen*sizeof(TCHAR));
    }

    if ( !pszBuf )
        goto Done;

    //
    // Go through the list of key names in the .INI till we find a match
    //
    for ( pszKey = pszBuf ; *pszKey ; pszKey += dwLen + 1 ) {

        //
        // Keys start and end with " we need to do match w/o them
        //
        dwLen = _tcslen(pszKey);
        pszKey[dwLen-1] = TCHAR('\0');

        if ( StringMatch(pszPortDesc, pszKey+1) ) {

            pszKey[dwLen-1] = TCHAR('\"');
            GetPrivateProfileString(PORT_SECTION,
                                    pszKey,
                                    NULL,
                                    m_szSectionName,
                                    MAX_SECTION_NAME,
                                    m_szIniFileName);
            bRet = TRUE;
            goto Done;
        }
    }

Done:
    if ( pszBuf ) {
        free(pszBuf);
    }

    return( bRet );
}


IniSection::
IniSection(
    void
    )
{
    DWORD   dwLen = 0, dwSize = 0;

    m_szSectionName[0] = TEXT('\0');
    m_szIniFileName[0] = TEXT('\0');

    dwSize = sizeof(m_szIniFileName)/sizeof(m_szIniFileName[0]);
    dwLen = GetSystemDirectory(m_szIniFileName, dwSize);

    if ( dwLen + _tcslen(PORTMONITOR_INI_FILE) > dwSize ) {
        return;
    }
    StringCchCat (m_szIniFileName, dwSize, PORTMONITOR_INI_FILE);

}


IniSection::
~IniSection(
    )
{
    // Nothing to do
}

BOOL
IniSection::
GetString(
    IN  LPTSTR  pszKey,
    OUT TCHAR   szBuf[],
    IN  DWORD   cchBuf
    )
{
    DWORD   rc = 0;

    rc = GetPrivateProfileString(m_szSectionName,
                                 pszKey,
                                 NULL,
                                 szBuf,
                                 cchBuf,
                                 m_szIniFileName);

    return rc > 0 && rc < cchBuf - 1;
}


BOOL
IniSection::
GetDWord(
    IN  LPTSTR  pszKey,
    OUT LPDWORD pdwValue
    )
{
    UINT    uVal;

    uVal = GetPrivateProfileInt(m_szSectionName,
                                pszKey,
                                -1,
                                m_szIniFileName);

    if ( uVal != -1 ) {

        *pdwValue = (DWORD) uVal;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IniSection::
SetIniSection(
    LPTSTR   pszPortSection
    )
{
    lstrcpyn( m_szSectionName, pszPortSection, MAX_SECTION_NAME );

    return( TRUE );
}

BOOL
IniSection::
GetIniSection(
    LPTSTR   pszPortDescription
    )
{
    BOOL bRet = FALSE;

    if ( m_szIniFileName[0] != 0 ) {
        bRet = FindINISectionFromPortDescription(pszPortDescription);
    }

    return( bRet );
}

//
//  FUNCTION: GetPortInfo
//
//  PURPOSE: To read information about a device from the ini file.
//

BOOL
IniSection::
GetPortInfo(LPCTSTR pAddress,
            PPORT_DATA_1 pPortInfo,
            DWORD   dwPortIndex,
            BOOL    bBypassMibProbe)
{
    BOOL bRet = TRUE;
    TCHAR KeyName[26];

    if( !Valid() ) {
        bRet = FALSE;
        goto Done;
    }

    //
    // Protocol
    //
    StringCchPrintf (KeyName, COUNTOF (KeyName), PROTOCOL_KEY, dwPortIndex);
    TCHAR tcsProtocol[50];
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            TEXT(""),
                            tcsProtocol,
                            50,
                            m_szIniFileName);

    if( !_tcsicmp( RAW_PROTOCOL_TEXT, tcsProtocol)) {
        pPortInfo->dwProtocol = PROTOCOL_RAWTCP_TYPE;

        //
        // Port Number
        //
        StringCchPrintf (KeyName, COUNTOF (KeyName), PORT_NUMBER_KEY, dwPortIndex);
        pPortInfo->dwPortNumber = GetPrivateProfileInt(m_szSectionName,
                                                       KeyName,
                                                       DEFAULT_PORT_NUMBER,
                                                       m_szIniFileName);


    } else if( !_tcsicmp( LPR_PROTOCOL_TEXT, tcsProtocol)) {
        pPortInfo->dwProtocol = PROTOCOL_LPR_TYPE;
        pPortInfo->dwPortNumber = LPR_DEFAULT_PORT_NUMBER;

        //
        // LPR QUEUE
        //
        StringCchPrintf (KeyName, COUNTOF (KeyName), QUEUE_KEY, dwPortIndex);
        GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            DEFAULT_QUEUE,
                            pPortInfo->sztQueue,
                            MAX_QUEUENAME_LEN,
                            m_szIniFileName);

        //
        // LPR Double Spool - default 0
        //
        StringCchPrintf (KeyName, COUNTOF (KeyName), DOUBLESPOOL_KEY, dwPortIndex);
        pPortInfo->dwDoubleSpool = GetPrivateProfileInt(m_szSectionName,
                                                    KeyName,
                                                    0,
                                                    m_szIniFileName);



    }

    //
    // CommunityName
    //
    StringCchPrintf (KeyName, COUNTOF (KeyName), COMMUNITY_KEY, dwPortIndex);
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            DEFAULT_SNMP_COMUNITY,
                            pPortInfo->sztSNMPCommunity,
                            MAX_SNMP_COMMUNITY_STR_LEN,
                            m_szIniFileName);

    //
    // DeviceIndex - default 1
    //
    StringCchPrintf (KeyName, COUNTOF (KeyName), DEVICE_KEY, dwPortIndex);
    pPortInfo->dwSNMPDevIndex = GetPrivateProfileInt(m_szSectionName,
                                                    KeyName,
                                                    1,
                                                    m_szIniFileName);

    //
    // SNMP Status Enabled - default ON
    //
    TCHAR szTemp[50];
    StringCchPrintf (KeyName, COUNTOF (KeyName), PORT_STATUS_ENABLED_KEY, dwPortIndex);
    GetPrivateProfileString(m_szSectionName,
                            KeyName,
                            YES_TEXT,
                            szTemp,
                            SIZEOF_IN_CHAR(szTemp),
                            m_szIniFileName);

    if ( !(_tcsicmp( szTemp, YES_TEXT ))){
        pPortInfo->dwSNMPEnabled = TRUE;
    } else if (!(_tcsicmp( szTemp, NO_TEXT ))) {
        pPortInfo->dwSNMPEnabled = FALSE;
    } else {

        if (bBypassMibProbe)
            pPortInfo->dwSNMPEnabled = FALSE;
        else {

            BOOL bSupported;

            if (SupportsPrinterMIB( pAddress, &bSupported)) {
                pPortInfo->dwSNMPEnabled = bSupported;
            }
            else {

                // Error case, we have to disable SNMP

                pPortInfo->dwSNMPEnabled = FALSE;

                // The caller can check the returned error code to determine
                // whether the last error is "Device Not Found". If so,
                // the client should by pass Mib Probe in the next call
                //

                bRet = FALSE;
            }

        }

    }


Done:
    return( bRet );

} // GetPortInfo


//
BOOL
IniSection::
SupportsPrinterMIB(
    LPCTSTR     pAddress,
    PBOOL       pbSupported
    )
{
    BOOL            bRet = FALSE;
    CTcpMibABC     *pTcpMib = NULL;
    FARPROC         pfnGetTcpMibPtr = NULL;

    if ( !g_hTcpMibLib ) {
        goto Done;
    }

    pfnGetTcpMibPtr = ::GetProcAddress(g_hTcpMibLib, "GetTcpMibPtr");

    if ( !pfnGetTcpMibPtr ) {
        goto Done;
    }

    if ( pTcpMib = (CTcpMibABC *) pfnGetTcpMibPtr() ) {

        char HostName[MAX_NETWORKNAME_LEN] = "";

        UNICODE_TO_MBCS(HostName, MAX_NETWORKNAME_LEN, pAddress, -1);
        bRet = pTcpMib->SupportsPrinterMib(HostName,
                                           DEFAULT_SNMP_COMMUNITYA,
                                           DEFAULT_SNMP_DEVICE_INDEX,
                                           pbSupported);
    }

Done:
    return bRet;
} // GetDeviceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inisection.h ===
/*++

Copyright (c) 97 Microsoft Corporation
All rights reserved.

Module Name:

    IniSection.h

Abstract:

    Standard TCP/IP Port Monitor class to handle INI file settings

Author:
    Muhunthan Sivapragasam (MuhuntS) 19-Nov-1997

Revision History:

--*/

// INI file Key names and values
#define RAW_PROTOCOL_TEXT TEXT("RAW")
#define LPR_PROTOCOL_TEXT TEXT("LPR")

#define YES_TEXT TEXT("YES")
#define NO_TEXT TEXT("NO")

#define PORT_SECTION TEXT("Ports")

#define PORTS_KEY TEXT("PORTS")
#define PORT_NAME_KEY TEXT("NAME")
#define PORT_NAMEI_KEY TEXT("NAME%d")
#define PROTOCOL_KEY TEXT("PROTOCOL%d")
#define PORT_NUMBER_KEY TEXT("PORTNUMBER%d")
#define COMMUNITY_KEY TEXT("COMMUNITYNAME%d")
#define DEVICE_KEY TEXT("DEVICE%d")
#define QUEUE_KEY TEXT("QUEUE%d")
#define DOUBLESPOOL_KEY TEXT("LPRDSPOOL%d")
#define PORT_STATUS_ENABLED_KEY TEXT("SNMP%d")


class IniSection {

public:
    IniSection();

    ~IniSection();

    BOOL    GetString(LPTSTR pszKey, TCHAR szBuf[], DWORD  cchBuf);
    BOOL    GetDWord(LPTSTR pszKey, LPDWORD    pdwValue);

    BOOL    GetPortInfo(LPCTSTR pAddress, PPORT_DATA_1 pPortInfo, DWORD dwPortIndex, BOOL bBypassMibProbe);

    BOOL    GetIniSection(LPTSTR    pszPortDesc);

    BOOL    SetIniSection(LPTSTR    pszPortSection);

    LPTSTR  GetSectionName() { return( (LPTSTR)m_szSectionName ); }

private:
    TCHAR   m_szSectionName[MAX_SECTION_NAME];
    TCHAR   m_szIniFileName[MAX_PATH];

    BOOL    SupportsPrinterMIB( LPCTSTR     pAddress, PBOOL bSupported);

    BOOL    FindINISectionFromPortDescription(LPCTSTR   pszAnsiPortDesc);
    BOOL    Valid() { return m_szSectionName[0] != 0 && m_szIniFileName[0] != 0; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\helpids.h ===
// This file was not created with DBHE.  I cut and pasted material from a "dummy" file
// so I could organize the info in a way that helps me find information.

//The file contains Help IDs for the Configure TCP/IP Port Monitor dialog, tcpmn_cs.rtf

#define IDH_NOHELP	((DWORD) -1) // Disables Help for a control (for help compiles)

// "Port Settings" Dialog Box

#define IDH_PORT_NAME	11001	// Port Settings: "&Port Name:" (Static) (Edit) (ctrl id 1001, 1026)
#define IDH_PRINTER_NAME_IP_ADDRESS	11002	// Port Settings: "Printer Name or IP &Address:" (Static) (Edit) (ctrl id 1000, 1027)
#define IDH_PROTOCOL_RAW	11003	// Port Settings: "&Raw" (Button) (ctrl id 1006)
#define IDH_PROTOCOL_LPR	11004	// Port Settings: "&LPR" (Button) (ctrl id 1007)
#define IDH_RAW_SETTINGS_PORT_NUMBER	11005	// Port Settings: "Port &Number:" (Static) (Edit) (ctrl id 1008, 1017)
#define IDH_LPR_SETTINGS_QNAME	11006	// Port Settings: "&Queue Name:" (Static) (Edit) (ctrl id 1009, 1020)
#define IDH_LPR_BYTE_COUNTING_ENABLED	11007	// Port Settings: "LPR &Byte Counting Enabled" (Button) (ctrl id 1035)
#define IDH_SNMP_STATUS_ENABLED	11008	// Port Settings: "&SNMP Status Enabled" (Button) (ctrl id 1010)
#define IDH_SNMP_COMMUNITY_NAME	11009	// Port Settings: "&Community Name:" (Static) (Edit) (ctrl id 1011, 1021)
#define IDH_SNMP_DEVICE_INDEX	11010	// Port Settings: "SNMP &Device Index:" (Static) (Edit) (ctrl id 1012, 1022)

const DWORD g_a110HelpIDs[]=
{
	1000,	IDH_PRINTER_NAME_IP_ADDRESS,	// Port Settings: "" (Edit)
	1001,	IDH_PORT_NAME,	// Port Settings: "" (Edit)
	1006,	IDH_PROTOCOL_RAW,	// Port Settings: "&Raw" (Button)
	1007,	IDH_PROTOCOL_LPR,	// Port Settings: "&LPR" (Button)
	1008,	IDH_RAW_SETTINGS_PORT_NUMBER,	// Port Settings: "" (Edit)
	1009,	IDH_LPR_SETTINGS_QNAME,	// Port Settings: "" (Edit)
	1010,	IDH_SNMP_STATUS_ENABLED,	// Port Settings: "&SNMP Status Enabled" (Button)
	1011,	IDH_SNMP_COMMUNITY_NAME,	// Port Settings: "" (Edit)
	1012,	IDH_SNMP_DEVICE_INDEX,	// Port Settings: "" (Edit)
	1017,	IDH_RAW_SETTINGS_PORT_NUMBER,	// Port Settings: "Port &Number:" (Static)
	1020,	IDH_LPR_SETTINGS_QNAME,	// Port Settings: "&Queue Name:" (Static)
	1021,	IDH_SNMP_COMMUNITY_NAME,	// Port Settings: "&Community Name:" (Static)
	1022,	IDH_SNMP_DEVICE_INDEX,	// Port Settings: "SNMP &Device Index:" (Static)
	1026,	IDH_PORT_NAME,	// Port Settings: "&Port Name:" (Static)
	1027,	IDH_PRINTER_NAME_IP_ADDRESS,	// Port Settings: "Printer Name or IP &Address:" (Static)
	1035,	IDH_LPR_BYTE_COUNTING_ENABLED,	// Port Settings: "LPR &Byte Counting Enabled" (Button)
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inptchkr.cpp ===
/*****************************************************************************
 *
 * $Workfile: InptChkr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "Resource.h"
#include "IPAddr.h"
#include "HostName.h"

//
//  FUNCTION: CInputChecker constructor
//
//  PURPOSE:  initialize a CInputChecker class
//
CInputChecker::CInputChecker()
{
    m_bLinked = FALSE;
    m_InputStorageStringAddress[0] = '\0';
    m_InputStorageStringPortNumber[0] = '\0';
    m_InputStorageStringDeviceIndex[0] = '\0';
    m_InputStorageStringQueueName[0] = '\0';

} // constructor


//
//  FUNCTION: CInputChecker destructor
//
//  PURPOSE:  deinitialize a CInputChecker class
//
CInputChecker::~CInputChecker()
{
} // destructor


//
//  FUNCTION: OnUpdatePortName(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Port Name input.
//
void CInputChecker::OnUpdatePortName(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Name had text changed in it.
    BOOL bModified = static_cast<BOOL> (SendMessage(hwndEditCtrl, EM_GETMODIFY, 0,0));
    if(bModified)
    {
        TCHAR tcsAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
        TCHAR tcsLastValidAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
        GetWindowText(hwndEditCtrl, tcsAddr, MAX_ADDRESS_LENGTH);

        if(! IsValidPortNameInput(tcsAddr,
                                  tcsLastValidAddr,
                                  SIZEOF_IN_CHAR(tcsLastValidAddr)))
        {
            // the port name that was entered is not valid so beep and set the text
            // back to the last valid entry.  This test for validity does not
            // include testing for the right length just proper character set.
            MessageBeep((UINT)-1);
            DWORD dwSel = Edit_GetSel(hwndEditCtrl);
            SetWindowText(hwndEditCtrl, tcsLastValidAddr);
            Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
        }

        m_bLinked = FALSE;
    }

} // OnUpdatePortName


//
//  FUNCTION: OnUpdatePortNumber(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Port Number input.
//
void CInputChecker::OnUpdatePortNumber(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Number had text changed in it.
    TCHAR tcsPortNum[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    TCHAR tcsLastValidPortNum[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsPortNum, MAX_PORTNUM_STRING_LENGTH);

    if(! IsValidPortNumberInput(tcsPortNum,
                                tcsLastValidPortNum,
                                SIZEOF_IN_CHAR(tcsLastValidPortNum)))
    {
        // the port number that was entered is not valid so beep and set the text
        // back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidPortNum);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdatePortNumber


//
//  FUNCTION: OnUpdateDeviceIndex(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Device Index input.
//
void CInputChecker::OnUpdateDeviceIndex(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for Port Number had text changed in it.
    TCHAR tcsDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    TCHAR tcsLastValidDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsDeviceIndex, MAX_SNMP_DEVICENUM_STRING_LENGTH);

    if(! IsValidDeviceIndexInput(tcsDeviceIndex,
                                 tcsLastValidDeviceIndex,
                                 SIZEOF_IN_CHAR(tcsLastValidDeviceIndex)))
    {
        // the device index that was entered is not valid so beep and set the
        // text back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidDeviceIndex);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdateDeviceIndex



//
//  FUNCTION: OnUpdateAddress(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the Address input.
//
void CInputChecker::OnUpdateAddress(HWND hDlg, int idEditCtrl, HWND hwndEditCtrl, LPTSTR psztServerName)
{
    // the edit control for IP Address or Device Name had text changed in it.
    TCHAR tcsAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
    TCHAR tcsLastValidAddr[MAX_ADDRESS_LENGTH] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsAddr, MAX_ADDRESS_LENGTH);

    BOOL bValid = IsValidAddressInput(tcsAddr,
                                      tcsLastValidAddr,
                                      SIZEOF_IN_CHAR(tcsLastValidAddr));
    if(! bValid)
    {
        // the address that was entered is not valid so beep and set the text
        // back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidAddr);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }
    else // The address is valid.
    {
        if(m_bLinked)
        {
            MakePortName(tcsAddr, COUNTOF (tcsAddr));
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_PORT_NAME), tcsAddr);
        }
    }

} // OnUpdateAddress


//
//  FUNCTION: OnUpdateQueueName(idEditCtrl, hwndEditCtrl)
//
//  PURPOSE:  to handle EN_UPDATE message when the edit control is the QueueName input.
//
void CInputChecker::OnUpdateQueueName(int idEditCtrl, HWND hwndEditCtrl)
{
    // the edit control for QueueName had text changed in it.
    TCHAR tcsQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    TCHAR tcsLastValidQueueName[MAX_QUEUENAME_LEN] = NULLSTR;
    GetWindowText(hwndEditCtrl, tcsQueueName, MAX_QUEUENAME_LEN);

    if(! IsValidQueueNameInput(tcsQueueName,
                               tcsLastValidQueueName,
                               SIZEOF_IN_CHAR(tcsLastValidQueueName)))
    {
        // the device index that was entered is not valid so beep and set the
        // text back to the last valid entry.  This test for validity does not
        // include testing for the right length just proper character set.
        MessageBeep((UINT)-1);
        DWORD dwSel = Edit_GetSel(hwndEditCtrl);
        SetWindowText(hwndEditCtrl, tcsLastValidQueueName);
        Edit_SetSel(hwndEditCtrl, LOWORD(dwSel) - 1, HIWORD(dwSel) - 1);
    }

} // OnUpdateQueueName


//
//  FUNCTION: IsValidPortNameInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidPortNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  Any input is valid until I hear otherwise.
//
BOOL CInputChecker::IsValidPortNameInput(TCHAR *ptcsAddressInput,
                                         TCHAR *ptcsReturnLastValid,
                                         DWORD CRtnValSize)
{
    DWORD   dwLen = 0;
    BOOL    bValid = FALSE;

    //
    // Valid port name is non-blank and does not include ,
    //
    if ( ptcsAddressInput ) {

        while ( ptcsAddressInput[dwLen] != TEXT('\0')   &&
                ptcsAddressInput[dwLen] != TEXT(',') )
            ++dwLen;

        bValid = dwLen && ptcsAddressInput[dwLen] != TEXT(',');
    }

    if ( CRtnValSize ) {

        if ( dwLen + 1 > CRtnValSize )
            dwLen = CRtnValSize - 1;

        lstrcpyn(ptcsReturnLastValid, ptcsAddressInput ? ptcsAddressInput : L"", dwLen+1);
    }

    return bValid;
} // IsValidPortNameInput


//
//  FUNCTION: IsValidCommunityNameInput(TCHAR ptcsCommunityNameInput[MAX_SNMP_COMMUNITY_STR_LEN], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidCommunityNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsCommunityNameInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  Any input is valid until I hear otherwise.
//
BOOL CInputChecker::IsValidCommunityNameInput(TCHAR *ptcsCommunityNameInput,
                                              TCHAR *ptcsReturnLastValid,
                                              DWORD CRtnValSize)
{
    return TRUE;

} // IsValidCommunityNameInput


//
//  FUNCTION: IsValidPortNumberInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidPortNumberInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  The input is valid if it contains only digit characters.
//
BOOL CInputChecker::IsValidPortNumberInput(TCHAR *ptcsPortNumInput,
                                           TCHAR *ptcsReturnLastValid,
                                           DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_PORTNUM_STRING_LENGTH] = NULLSTR;

    lstrcpyn(ptcsString, ptcsPortNumInput, MAX_PORTNUM_STRING_LENGTH );
    bIsValid = (_tcslen(ptcsString) <= MAX_PORTNUM_STRING_LENGTH);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)'0':
            case (TCHAR)'1':
            case (TCHAR)'2':
            case (TCHAR)'3':
            case (TCHAR)'4':
            case (TCHAR)'5':
            case (TCHAR)'6':
            case (TCHAR)'7':
            case (TCHAR)'8':
            case (TCHAR)'9':
                bIsValid = TRUE;
                break;

            default:
                bIsValid = FALSE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringPortNumber,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringPortNumber,
                 ptcsString,
                 MAX_ADDRESS_LENGTH);
    }
    return(bIsValid);

} // IsValidPortNumberInput


//
//  FUNCTION: IsValidDeviceIndexInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidDeviceIndexInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//                  from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise, with ptcsReturnLastValid set.
//
//  Comments:  The input is valid if it contains only digit characters.
//
BOOL CInputChecker::IsValidDeviceIndexInput(TCHAR *ptcsDeviceIndexInput,
                                            TCHAR *ptcsReturnLastValid,
                                            DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_SNMP_DEVICENUM_STRING_LENGTH] = NULLSTR;

    lstrcpyn(ptcsString,
             ptcsDeviceIndexInput,
             MAX_SNMP_DEVICENUM_STRING_LENGTH);
    bIsValid = (_tcslen(ptcsString) <= MAX_SNMP_DEVICENUM_STRING_LENGTH);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)'0':
            case (TCHAR)'1':
            case (TCHAR)'2':
            case (TCHAR)'3':
            case (TCHAR)'4':
            case (TCHAR)'5':
            case (TCHAR)'6':
            case (TCHAR)'7':
            case (TCHAR)'8':
            case (TCHAR)'9':
                bIsValid = TRUE;
                break;

            default:
                bIsValid = FALSE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringDeviceIndex,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringDeviceIndex,
                 ptcsString,
                 MAX_SNMP_DEVICENUM_STRING_LENGTH);
    }
    return(bIsValid);

} // IsValidDeviceIndexInput


//
//  FUNCTION: IsValidAddressInput(TCHAR ptcsAddressInput[MAX_ADDRESS_LENGTH], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidAddressInput is used for validation while the user is typing.
//
//  Arguments:  ptcsAddressInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//              from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise.
//
//  Comments:  The input is valid if it contains characters that are either valid for
//              an IP Address or a Host Name or both.
//
BOOL CInputChecker::IsValidAddressInput(TCHAR *ptcsAddressInput,
                                        TCHAR *ptcsReturnLastValid,
                                        DWORD CRtnValSize)
{
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_ADDRESS_LENGTH] = NULLSTR;
    BOOL bIsValid = FALSE;

    lstrcpyn(ptcsString, ptcsAddressInput, MAX_ADDRESS_LENGTH);

    bIsValid = (_tcslen(ptcsString) <= MAX_ADDRESS_LENGTH);
    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {
            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
            // other invalid character cases here
                    bIsValid = FALSE;
                    break;

            default:
                    break;
        }
    }
    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringAddress,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringAddress,
                 ptcsString,
                 MAX_ADDRESS_LENGTH);
    }
    return(bIsValid);

} // IsValidAddressInput



//
//  FUNCTION: IsValidQueueNameInput(TCHAR ptcsAddressInput[MAX_QUEUENAME_LEN], TCHAR *ptcsReturnLastValid)
//
//  PURPOSE:  IsValidQueueNameInput is used for validation while the user is typing.
//
//  Arguments:  ptcsQueueNameInput is the user input.
//              ptcsReturnLastValid is the last valid user input
//              from the last time this function was called.
//              CRtnValSize size in chars ( or wide chars) of the destination
//                  buffer.
//
//  Return Value:  Returns TRUE if the input is valid.  FALSE otherwise.
//
//  Comments:  The name is limited to 14 characters and must consist entirely of the
//              characters A-Z, a-z, 0-9, and _ (underscore).
//
BOOL CInputChecker::IsValidQueueNameInput(TCHAR *ptcsQueueNameInput,
                                          TCHAR *ptcsReturnLastValid,
                                          DWORD CRtnValSize)
{
    BOOL bIsValid = TRUE;
    TCHAR *charPtr = NULL;
    TCHAR ptcsString[MAX_QUEUENAME_LEN] = NULLSTR;

    lstrcpyn(ptcsString, ptcsQueueNameInput, MAX_QUEUENAME_LEN );
    bIsValid = (_tcslen(ptcsString) <= MAX_QUEUENAME_LEN);

    for (charPtr = ptcsString; bIsValid && *charPtr; charPtr++)
    {
        switch (*charPtr)
        {

            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
                bIsValid = FALSE;
                break;

            default:
                bIsValid = TRUE;
                break;
        }
    }

    if (!bIsValid)
    {
        if(ptcsReturnLastValid != NULL)
        {
            lstrcpyn(ptcsReturnLastValid,
                     m_InputStorageStringQueueName,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_InputStorageStringQueueName,
                 ptcsString,
                 MAX_QUEUENAME_LEN);
    }
    return(bIsValid);

} // IsValidQueueNameInput


//
//  FUNCTION: MakePortName(TCHAR *strAddr)
//
//  PURPOSE:  To return a string that will be a unique port
//              name when the port is added.
//
void CInputChecker::MakePortName(TCHAR *strAddr, size_t cchAddr)
{
    _ASSERTE(m_bLinked == TRUE);

    if(GetAddressType(strAddr) == IPAddress)
    {
        // The address is an IP address
        TCHAR NameString[10] = NULLSTR;

        if (LoadString(g_hInstance, IDS_STRING_NAME_IP, NameString, COUNTOF (NameString)))
        {
            TCHAR szTemp[MAX_ADDRESS_LENGTH+1] = NULLSTR;
            HRESULT hr =
                StringCchPrintf (szTemp, COUNTOF (szTemp),
                    TEXT( "%s%.*s" ),
                    NameString,
                    MAX_ADDRESS_LENGTH - _tcslen(NameString),
                    strAddr);

            if (SUCCEEDED (hr))
            {
                StringCchCopy (
                    strAddr,
                    cchAddr,
                    szTemp
                    );
            }
        }
    }


} // MakePortName


//
//  FUNCTION: PortNumberIsLegal(TCHAR *ptcsPortNumber)
//
//  PURPOSE:  To determine if the PortNum passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::PortNumberIsLegal(TCHAR *ptcsPortNumber)
{
    if(IsValidPortNumberInput(ptcsPortNumber, NULL, 0) &&
        _tcslen(ptcsPortNumber) >= 1 &&
        _tcslen(ptcsPortNumber) <= MAX_PORTNUM_STRING_LENGTH)
    {
        return TRUE;
    }
    return FALSE;

} // PortNumberIsLegal


//
//  FUNCTION: CommunityNameIsLegal(TCHAR *ptcsCommunityName)
//
//  PURPOSE:  To determine if the Community Name passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::CommunityNameIsLegal(TCHAR *ptcsCommunityName)
{
    if(IsValidCommunityNameInput(ptcsCommunityName) &&
        _tcslen(ptcsCommunityName) >= 1 &&
        _tcslen(ptcsCommunityName) <= MAX_SNMP_COMMUNITY_STR_LEN)
    {
        return TRUE;
    }
    return FALSE;

} // CommunityNameIsLegal


//
//  FUNCTION: QueueNameIsLegal(TCHAR *ptcsQueueName)
//
//  PURPOSE:  To determine if the PortNum passed in in the parameter ptcsAddress
//              is legal.
//
BOOL CInputChecker::QueueNameIsLegal(TCHAR *ptcsQueueName)
{
    if(IsValidQueueNameInput(ptcsQueueName) &&
        _tcslen(ptcsQueueName) >= 1 &&
        _tcslen(ptcsQueueName) <= MAX_QUEUENAME_LEN)
    {
        return TRUE;
    }
    return FALSE;

} // QueueNameIsLegal

//
//  FUNCTION: GetAddressType(TCHAR *ptcsAddress)
//
//  PURPOSE:  To determine if the address passed in in the parameter ptcsAddress
//              is an ip address or a host name.
//
AddressType CInputChecker::GetAddressType(TCHAR *ptcsAddress)
{
    // determine if we are dealing with a name or an ip address
    // if it's an IP Address it will start with a number, otherwise
    // it will start with a letter or other character.

    if( ptcsAddress[0] == '0' ||
        ptcsAddress[0] == '1' ||
        ptcsAddress[0] == '2' ||
        ptcsAddress[0] == '3' ||
        ptcsAddress[0] == '4' ||
        ptcsAddress[0] == '5' ||
        ptcsAddress[0] == '6' ||
        ptcsAddress[0] == '7' ||
        ptcsAddress[0] == '8' ||
        ptcsAddress[0] == '9')
    {
        CIPAddress IPAddr;
        if (IPAddr.IsValid(ptcsAddress))
            return(IPAddress);
        else
            return (HostName);
    }
    else
    {
        return(HostName);
    }

} // GetAddressType

//
//  FUNCTION: AddressIsLegal(TCHAR *ptcsAddress)
//
//  PURPOSE:  To determine if the address passed in in the parameter ptcsAddress
//              is legal -- That is not too short and either a legal ip address or
//              a legal host name.
//
BOOL CInputChecker::AddressIsLegal(TCHAR *ptcsAddress)
{
    BOOL bLegalAddress = TRUE;

    // determine if the input is at least 2 characters long.
    if((_tcslen(ptcsAddress) > 1))
    {
        if( GetAddressType(ptcsAddress) == IPAddress )
        {
            CIPAddress IPAddr;
            bLegalAddress = IPAddr.IsValid(ptcsAddress);
        }
        else
        {
            CHostName HostName(ptcsAddress);
            bLegalAddress = HostName.IsValid();
        }
    }
    else
    {
        bLegalAddress = FALSE;
    }

    return bLegalAddress;

} // AddressIsLegal


//
//  FUNCTION: PortNameIsLegal(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the PortName passed in in the parameter ptcsPortName
//              is legal
//
//  Return Value:  True if the port name is legal. False if it is not.
//
//  Parameters:  ptcsPortName - the name of the port to check for legality.
//
BOOL CInputChecker::PortNameIsLegal(TCHAR *ptcsPortName)
{
    DWORD   dwLen;

    dwLen = ptcsPortName && *ptcsPortName ? _tcslen(ptcsPortName) : 0;

    //
    // Remove trailing spaces
    //
    while ( dwLen && ptcsPortName[dwLen-1] == ' ' )
        --dwLen;

    if ( dwLen == 0 )
        return FALSE;

    ptcsPortName[dwLen] = TEXT('\0');

    for ( ; *ptcsPortName ; ++ptcsPortName )
        if ( *ptcsPortName == TEXT(',') ||
             *ptcsPortName == TEXT('\\') ||
             *ptcsPortName == TEXT('/') )
            return FALSE;

    return TRUE;
} // PortNameIsLegal


//
//  FUNCTION: SNMPDevIndexIsLegal(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the SNMPDevIndex passed in in the parameter psztSNMPDevIndex
//              is legal
//
//  Return Value:  True if the index is legal. False if it is not.
//
//  Parameters:  psztSNMPDevIndex - the device index to check for legality.
//
BOOL CInputChecker::SNMPDevIndexIsLegal(TCHAR *psztSNMPDevIndex)
{
    if((! IsValidDeviceIndexInput(psztSNMPDevIndex)) ||
        (_tcslen(psztSNMPDevIndex) < 1))
    {
        return FALSE;
    }

    return TRUE;

} // SNMPDevIndexIsLegal


//
//  FUNCTION: PortNameIsUnique(TCHAR *ptcsPortName)
//
//  PURPOSE:  To determine if the PortName passed in in the parameter ptcsPortName
//              is Unique.
//
//  Return Value:  True if the port does not exist. False if it does.
//
//  Parameters:  psztPortName - the name of the port to check for prior existance.
//
//  Note:  The spooler must be running on the system in order for this function
//          to work properly.
//
BOOL CInputChecker::PortNameIsUnique(TCHAR *ptcsPortName, LPTSTR psztServerName)
{
    return(! PortExists(ptcsPortName, psztServerName));

} // PortNameIsUnique


//
//  FUNCTION: PortExists()
//
//  PURPOSE:  Enumerate ports and search for the given port name
//
//  Return Value:  True if the port exists. False if it does not.
//
//  Parameters:  psztPortName - the name of the port to check for existance.
//              psztServerName - The Name of the server to check on.
//
//  Note:  The spooler must be running on the system in order for this function
//          to work properly.
//
BOOL CInputChecker::PortExists(LPTSTR psztPortName, LPTSTR psztServerName)
{
    BOOL Exists = FALSE;

    PORT_INFO_1 *pi1 = NULL;
    DWORD pcbNeeded = 0;
    DWORD pcReturned = 0;
    BOOL res = EnumPorts((psztServerName[0] == '\0') ? NULL : psztServerName,
        1, // specifies type of port info structure
        (LPBYTE)pi1, // pointer to buffer to receive array of port info. structures
        0, // specifies size, in bytes, of buffer
        &pcbNeeded, // pointer to number of bytes stored into buffer (or required buffer size)
        &pcReturned // pointer to number of PORT_INFO_*. structures stored into buffer
        );

    DWORD err = GetLastError();
    if(res == 0 && ERROR_INSUFFICIENT_BUFFER == err)
    {
        pi1 = (PORT_INFO_1 *) malloc(pcbNeeded);
        if(pi1 == NULL)
        {
            pcbNeeded = 0;
        }

        res = EnumPorts((psztServerName[0] == '\0') ? NULL : psztServerName,
            1,
            (LPBYTE)pi1,
            pcbNeeded,
            &pcbNeeded,
            &pcReturned);

        for(DWORD i=0;i<pcReturned; i++)
        {
            if(0 == _tcsicmp(pi1[i].pName, psztPortName))
            {
                Exists = TRUE;
                break;
            }
        }
    }
    if(pi1 != NULL)
    {
        free(pi1);
        pi1 = NULL;
    }

    return(Exists);

} // PortExists
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\hostname.cpp ===
/*****************************************************************************
 *
 * $Workfile: HostName.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header

#include "HostName.h"


//
//  FUNCTION: CHostName constructor
//
//  PURPOSE:
//
CHostName::CHostName()
{
}


//
//  FUNCTION: CHostName constructor
//
//  PURPOSE:
//
CHostName::CHostName(LPTSTR psztHostName)
{
    SetAddress(psztHostName);
}


//
//  FUNCTION: CHostName destructor
//
//  PURPOSE:
//
CHostName::~CHostName()
{
}


//
//  FUNCTION: IsValid
//
//  PURPOSE: Used for validation while the user is typing.
//          It is less strict then IsValid()  (The no argument version)
//
BOOL CHostName::IsValid(TCHAR *psztStringOriginal,
                        TCHAR *psztReturnVal,
                        DWORD   cRtnVal)
{
    TCHAR *pctPtr = NULL;
    TCHAR psztString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH] = NULLSTR;
    BOOL bIsValid = FALSE;

    lstrcpyn(psztString, psztStringOriginal, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

    // Check the total length of the string.
    bIsValid = (_tcslen(psztString) <= MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

    if(bIsValid)
    {
        // Find the first dot and check the length of the part before the first dot.
        TCHAR psztSubString[MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH] = NULLSTR;
        lstrcpyn(psztSubString, psztString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);
        TCHAR *pDotIndex = NULL;

        pDotIndex = _tcschr(psztSubString, '.');
        if(pDotIndex != NULL) {
            *pDotIndex = TCHAR('\0');
        }
        bIsValid = (_tcslen(psztSubString) <= MAX_HOSTNAME_LEN);
    }

    // Check for invalid characters.
    for (pctPtr = psztString; bIsValid && *pctPtr; pctPtr++)
    {
        switch (*pctPtr)
        {
            case (TCHAR)' ':
            case (TCHAR)'"':
            case (TCHAR)'&':
            case (TCHAR)'*':
            case (TCHAR)'(':
            case (TCHAR)')':
            case (TCHAR)'+':
            case (TCHAR)',':
            case (TCHAR)'/':
            case (TCHAR)':':
            case (TCHAR)';':
            case (TCHAR)'<':
            case (TCHAR)'=':
            case (TCHAR)'>':
            case (TCHAR)'?':
            case (TCHAR)'[':
            case (TCHAR)'\\':
            case (TCHAR)']':
            case (TCHAR)'|':
            case (TCHAR)'~':
            case (TCHAR)'@':
            case (TCHAR)'#':
            case (TCHAR)'$':
            case (TCHAR)'%':
            case (TCHAR)'^':
            case (TCHAR)'!':
                bIsValid = FALSE;
                break;

            default:
                if ( ( *pctPtr < ((TCHAR)'!') ) || ( *pctPtr > (TCHAR)'~' ) ) {
                    bIsValid = FALSE;
                }
                break;
        }
    }
    if (!bIsValid) {
        if(psztReturnVal != NULL) {
            StringCchCopy (psztReturnVal, cRtnVal, m_psztStorageString);
        }
    } else {
        lstrcpyn(m_psztStorageString, psztString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);
        // _ASSERTE( _tcsicmp(psztString, psztStringOriginal) == 0 );
    }
    return(bIsValid);
}

//
//  FUNCTION: IsValid
//
//  PURPOSE: Strict validation of a host name.
//
BOOL CHostName::IsValid()
{
    if(!IsValid(m_psztAddress)) {
        return(FALSE);
    }

    // We know that it is mostly valid now do the final more exact test.

    // check to be sure the first character is an alphanumeric character:
    if(! ((m_psztAddress[0] >= TCHAR('0') && m_psztAddress[0] <= TCHAR('9')) ||
           (m_psztAddress[0] >= TCHAR('A') && m_psztAddress[0] <= TCHAR('Z')) ||
           (m_psztAddress[0] >= TCHAR('a') && m_psztAddress[0] <= TCHAR('z'))) )   {
        return(FALSE);
    }

    // check to be sure the name is longer then 1 character.
    int length = _tcslen(m_psztAddress);
    if(length <= 1) {
        return(FALSE);
    }

    // check to be sure the last character is not a minus sign or period.
    if( m_psztAddress[length - 1] == TCHAR('-') ||
        m_psztAddress[length - 1] == TCHAR('.')) {
        return(FALSE);
    }

    return(TRUE);

} // IsValid


//
//  FUNCTION: SetAddress
//
//  PURPOSE: Sets the host name.
//
void CHostName::SetAddress(TCHAR *AddressString)
{
    IsValid(AddressString);
    lstrcpyn(m_psztAddress, AddressString, MAX_FULLY_QUALIFIED_HOSTNAME_LENGTH);

} // SetAddress


//
//  FUNCTION: ToString
//
//  PURPOSE: Returns the address in the given buffer.
//
void CHostName::ToString(TCHAR *Buffer, int size)
{
    lstrcpyn(Buffer, m_psztAddress, size);

} // ToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\inptchkr.h ===
/*****************************************************************************
 *
 * $Workfile: InptChkr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *
 *****************************************************************************/

#ifndef INC_INPUTCHECKER_H
#define INC_INPUTCHECKER_H

typedef enum _tagAddressType
{
    Undefined,
    IPAddress,
    HostName
} AddressType;

class CInputChecker
{
public:
    CInputChecker();
    ~CInputChecker();

public:
    void LinkPortNameAndAddressInput() { m_bLinked = TRUE; }
    void UnlinkPortNameAndAddressInput() { m_bLinked = FALSE; }

    BOOL AddressIsLegal(TCHAR *ptcsAddress);
    BOOL PortNameIsLegal(TCHAR *ptcsPortName);
    BOOL PortNameIsUnique(TCHAR *ptcsPortName, LPTSTR psztServerName);
    BOOL PortNumberIsLegal(TCHAR *ptcsPortNumber);
    BOOL QueueNameIsLegal(TCHAR *ptcsQueueName);
    BOOL CommunityNameIsLegal(TCHAR *ptcsCommunityName);
    BOOL SNMPDevIndexIsLegal(TCHAR *psztSNMPDevIndex);

    void OnUpdatePortName(int idEditCtrl, HWND hwndEditCtrl);
    void OnUpdateAddress(HWND hDlg, int idEditCtrl, HWND hwndEditCtrl, LPTSTR psztServerName);
    void OnUpdatePortNumber(int idEditCtrl, HWND hwndEditCtrl);
    void OnUpdateDeviceIndex(int idEditCtrl, HWND hwndEditCtrl);
    void OnUpdateQueueName(int idEditCtrl, HWND hwndEditCtrl);
    void MakePortName(TCHAR *strAddr, size_t cchAddr);

protected:
    BOOL IsValidAddressInput(TCHAR *ptcsAddressInput,
                             TCHAR *ptcsReturnLastValid,
                             DWORD CRtnValSize);
    BOOL IsValidPortNameInput(TCHAR *ptcsPortNameInput,
                              TCHAR *ptcsReturnLastValid,
                              DWORD CRtnValSize);
    BOOL IsValidPortNumberInput(TCHAR *ptcsPortNumInput,
                                TCHAR *ptcsReturnLastValid = NULL ,
                                DWORD cRtnVal = 0);
    BOOL IsValidDeviceIndexInput(TCHAR *ptcsDeviceIndexInput,
                                 TCHAR *ptcsReturnLastValid = NULL,
                                 DWORD CRtnValSize = 0);
    BOOL IsValidQueueNameInput(TCHAR *ptcsQueueNameInput,
                               TCHAR *ptcsReturnLastValid = NULL,
                               DWORD CRtnValSize = 0);
    BOOL IsValidCommunityNameInput(TCHAR *ptcsCommunityNameInput,
                                   TCHAR *ptcsReturnLastValid = NULL,
                                   DWORD CRtnValSize = 0);

    BOOL PortExists(LPTSTR psztPortName, LPTSTR psztServerName);

    AddressType GetAddressType(TCHAR *ptcsAddress);

private:
    BOOL m_bLinked; // Is the port name linked to the Address input?
    TCHAR m_InputStorageStringAddress[MAX_ADDRESS_LENGTH];
    TCHAR m_InputStorageStringPortNumber[MAX_PORTNUM_STRING_LENGTH];
    TCHAR m_InputStorageStringDeviceIndex[MAX_SNMP_DEVICENUM_STRING_LENGTH];
    TCHAR m_InputStorageStringQueueName[MAX_QUEUENAME_LEN];

}; // CGetAddrDlg

#endif // INC_INPUTCHECKER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\nt5uimgr.h ===
/*****************************************************************************
 *
 * $Workfile: NT5UIMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_NT5_UI_MANAGER_H
#define INC_NT5_UI_MANAGER_H

class CNT5UIManager : public CUIManager
{
public:
	CNT5UIManager();
	~CNT5UIManager() {}

	DWORD AddPortUI(HWND hWndParent, HANDLE hXcvPrinter, TCHAR pszServer[], TCHAR sztPortName[]);
	DWORD ConfigPortUI(HWND hWndParent, PPORT_DATA_1 pData, HANDLE hXcvPrinter, TCHAR szServerName[], BOOL bNewPort = FALSE);

protected:

private:

}; // CNT5UIManager

#endif // INC_NT5_UI_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\precomp.h ===
/*****************************************************************************
 *
 * Copyright (C) 2000 Hewlett-Packard Company.
 * Copyright (C) 2000 Microsoft Corporation.
 * All rights reserved.
 *
 *
 *****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <winspool.h>
#include <tchar.h>

#include <stdlib.h>
#include <winsock.h>
#include <wininet.h>
#include <ipaddr.h>
#include <stdio.h>
#include <commctrl.h>    // includes track bar
#include <winsplp.h>
#include <strsafe.h>

//
//  Header files in ..\Common
//
#include "debug.h"		// debug functions
#include "tcpmon.h"
#include "mibabc.h"
#include "RTcpData.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\ipaddr.h ===
/*****************************************************************************
 *
 * $Workfile: IPAddr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_IPADDR_H
#define INC_IPADDR_H

class CMemoryDebug;

#define MAX_IPCOMPONENT_STRLEN 3 + 1
#define STORAGE_STRING_LEN 64

class CIPAddress
{
public:
	CIPAddress();
	CIPAddress(LPTSTR psztIPAddr);
	~CIPAddress();

		// the string passed in to IsValid in AddressString param is _one_ of the 4
		// bytes.  The caller is responsible for breaking apart the IP Address into
		// its 4 (or 6) components.
		// if the string passed in to IsValid in AddressString param is not a valid
		// IP Address then the returnVal is filled with the last valid IP Address from
		// the previous time this method was called.  This facilitates validation for
		// each keystroke the user makes.

	BOOL IsValid(BYTE Address[4]);
	BOOL IsValid() { return IsValid(m_bAddress); }
	BOOL IsValid(TCHAR *psztStringAddress,
                 TCHAR *psztReturnVal = NULL,
                 DWORD CRtnValSize = 0);

	void SetAddress(TCHAR *AddressString);
	void SetAddress(TCHAR *psztAddr1, TCHAR *psztAddr2, TCHAR *psztAddr3, TCHAR *psztAddr4);

	void ToString(TCHAR *psztBuffer, int iSize);
	void ToComponentStrings(TCHAR *str1, TCHAR *str2, TCHAR *str3, TCHAR *str4, size_t cchStr);

private:
	BYTE	m_bAddress[4];
	TCHAR   m_psztStorageString[STORAGE_STRING_LEN];
	TCHAR	m_psztStorageStringComponent[STORAGE_STRING_LEN]; // last valid string entered in the text entry box.
};


#endif // INC_IPADDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\ipaddr.cpp ===
/*****************************************************************************
 *
 * $Workfile: IPAddr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"    // pre-compiled header


///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::CIPAddress()
//      Initializes the IP address

CIPAddress::CIPAddress()
{
    m_psztStorageStringComponent[0] = '\0';
    m_psztStorageString[0] = '\0';

}   // ::CIPAddress()


///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::CIPAddress(someString)
//      Initializes the IP address given a string

CIPAddress::CIPAddress(LPTSTR in psztIPAddr)
{
    int num0 = 0;
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    if (_stscanf(psztIPAddr, _TEXT("%d.%d.%d.%d"), &num0, &num1, &num2, &num3) == 4)
    {
        m_bAddress[0] = (BYTE)num0;
        m_bAddress[1] = (BYTE)num1;
        m_bAddress[2] = (BYTE)num2;
        m_bAddress[3] = (BYTE)num3;
    }
    else
    {
        ZeroMemory (m_bAddress, sizeof m_bAddress);
    }

}   // ::CIPAddress()



///////////////////////////////////////////////////////////////////////////////
//  CIPAddress::~CIPAddress()
//

CIPAddress::~CIPAddress()
{
}   // ::~CIPAddress()

///////////////////////////////////////////////////////////////////////////////
//  IsValid -- validate an ip address
//
BOOL CIPAddress::IsValid(TCHAR *psztStringAddress,
                         TCHAR *psztReturnVal,
                         DWORD  CRtnValSize)
{
    BOOL bIsValid = TRUE;
    CHAR szHostName[MAX_NETWORKNAME_LEN];

    UNICODE_TO_MBCS(szHostName, MAX_NETWORKNAME_LEN, psztStringAddress, -1);
    if ( inet_addr(szHostName) ==  INADDR_NONE ) {

        bIsValid = FALSE;
    }
    else
    {
        int num0 = 0;
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;

        //
        // Scan for correct dotted notation
        //
        if( _stscanf(psztStringAddress, _TEXT("%d.%d.%d.%d"),
                &num0,
                &num1,
                &num2,
                &num3) != 4 )
        {
            bIsValid = FALSE;
        }
        if( num0 == 0 )
        {
            bIsValid = FALSE;
        }
    }

    // Finish
    if (!bIsValid)
    {
        if(psztReturnVal != NULL)
        {
            lstrcpyn(psztReturnVal,
                     m_psztStorageString,
                     CRtnValSize);
        }
    }
    else
    {
        lstrcpyn(m_psztStorageString,
                 psztStringAddress,
                 STORAGE_STRING_LEN);
    }
    return(bIsValid);

} // IsValid


///////////////////////////////////////////////////////////////////////////////
//  IsValid -- validate an ip number entered in an edit control.
//

BOOL CIPAddress::IsValid(BYTE Address[4])
{
    for(int i=0; i<4; i++)
    {
        if ((Address[i] > 255) || (Address[i] < 0))
        {
            return FALSE;
        }
    }

    // if we got through all that stuff:
    return TRUE;

} // IsValid


///////////////////////////////////////////////////////////////////////////////
//  SetAddress -- set the value of this IPAddress object given 4 strings
//

void CIPAddress::SetAddress(TCHAR *psztAddr1,
                            TCHAR *psztAddr2,
                            TCHAR *psztAddr3,
                            TCHAR *psztAddr4)
{
    m_bAddress[0] = (BYTE) _ttoi( psztAddr1 );
    m_bAddress[1] = (BYTE) _ttoi( psztAddr2 );
    m_bAddress[2] = (BYTE) _ttoi( psztAddr3 );
    m_bAddress[3] = (BYTE) _ttoi( psztAddr4 );

} // SetAddress


///////////////////////////////////////////////////////////////////////////////
//  SetAddress -- Set the address given a string
//

void CIPAddress::SetAddress(TCHAR *psztAddress)
{
    int num0 = 0;
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    if(IsValid(psztAddress) &&
       _stscanf(psztAddress, _TEXT("%d.%d.%d.%d"), &num0, &num1, &num2, &num3) == 4
       )
    {
        m_bAddress[0] = (BYTE)num0;
        m_bAddress[1] = (BYTE)num1;
        m_bAddress[2] = (BYTE)num2;
        m_bAddress[3] = (BYTE)num3;
    }
    else
    {
        ZeroMemory (m_bAddress, sizeof m_bAddress);
    }

} // SetAddress


///////////////////////////////////////////////////////////////////////////////
//  ToString -- fill the given buffer with a string representing the IP address.
//

void CIPAddress::ToString(TCHAR *psztBuffer,
                          int iSize)
{
    TCHAR strAddr[MAX_IPADDR_STR_LEN] = NULLSTR;
    StringCchPrintf (strAddr, COUNTOF (strAddr), _TEXT("%d.%d.%d.%d"), m_bAddress[0], m_bAddress[1], m_bAddress[2], m_bAddress[3]);
    lstrcpyn(psztBuffer, strAddr, iSize);

} // ToString


///////////////////////////////////////////////////////////////////////////////
//  ToComponentStrings -- fill the given buffers with 4 strings representing the IP address.
//
void CIPAddress::ToComponentStrings(TCHAR *str1,
                                    TCHAR *str2,
                                    TCHAR *str3,
                                    TCHAR *str4,
                                    size_t cchStr)
{
    StringCchPrintf (str1, cchStr, TEXT("%d"), m_bAddress[0]);
    StringCchPrintf (str2, cchStr, TEXT("%d"), m_bAddress[1]);
    StringCchPrintf (str3, cchStr, TEXT("%d"), m_bAddress[2]);
    StringCchPrintf (str4, cchStr, TEXT("%d"), m_bAddress[3]);

} // ToComponentStrings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\nt5uimgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: NT5UIMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

/*
 * Author: Becky Jacobsen
 */

#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "NT5UIMgr.h"

#include "Prsht.h"
#include "resource.h"

// includes for ConfigPort
#include "DevPort.h"
#include "CfgPort.h"
#include "CfgAll.h"

// includes for AddPort
#include "AddWelcm.h"
#include "AddGetAd.h"
#include "AddMInfo.h"
#include "AddMulti.h"
#include "AddDone.h"

// NOTICE-DavePr@2002/05/27
//   remove STRICT_DLGPROC once printscan remove NO_STRICT from sources files
//   Win64 works better relying on strict typing rather than serendipity.
// 
typedef INT_PTR (CALLBACK* STRICT_DLGPROC)(HWND, UINT, WPARAM, LPARAM);

static void FillInPropertyPage( PROPSHEETPAGE* psp, // a pointer to the structure to be filled in.
                                int idDlg,                      // the id of the dialog template
                                LPTSTR pszProc,         // Title of the dialog.
                                LPTSTR pszHeaderTitle,          // Title displayed in the header.
                                LPTSTR pszHeaderSubTitle,       // SubTitle displayed in the header.
                                DWORD dwFlags,          // Flags used by the page.
                                STRICT_DLGPROC pfnDlgProc,     // dialog procedure that handles window messages.
                                LPARAM lParam);         // data that will appear in the lParam field of the struct passed to the dialog procedure.

//
//  FUNCTION: CNT5UIManager
//
//  PURPOSE: Constructor
//
CNT5UIManager::CNT5UIManager()
{
} // Constructor

//
//  FUNCTION: AddPortUI
//
//  PURPOSE: Main function called when the User Interface for adding a port is called.
//
DWORD CNT5UIManager::AddPortUI(HWND hWndParent,
                               HANDLE hXcvPrinter,
                               TCHAR pszServer[],
                               TCHAR sztPortName[])
{
    INT_PTR iReturnVal;
    PROPSHEETPAGE psp[MaxNumAddPages];
    PROPSHEETHEADER psh;
    PORT_DATA_1 PortData;
    ADD_PARAM_PACKAGE Params;

    TCHAR sztPropSheetTitle[MAX_TITLE_LENGTH];
    TCHAR sztWelcomePageTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztAddPortHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztMoreInfoHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortPageTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortHeaderTitle[MAX_TITLE_LENGTH];
    TCHAR sztMultiPortHeaderSubTitle[MAX_TITLE_LENGTH];
    TCHAR sztSummaryPageTitle[MAX_TITLE_LENGTH];

    memset(&PortData, 0, sizeof(PortData));

    PortData.dwVersion = 1;
    Params.pData = &PortData;
    Params.hXcvPrinter = hXcvPrinter;
    Params.UIManager = this;
    Params.dwLastError = NO_ERROR;
    if (pszServer != NULL) {
        lstrcpyn(Params.pszServer, pszServer, MAX_NETWORKNAME_LEN);
    } else {
        Params.pszServer[0] = '\0';
    }
    if (sztPortName != NULL) {
        lstrcpyn(Params.sztPortName, sztPortName, MAX_PORTNAME_LEN);
    } else {
        Params.sztPortName[0] = '\0';
    }

    // NOTICE-DavePr@2002/05/27
    //   g_hInstance is linked to what?
    // 
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztWelcomePageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztAddPortPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_HEADER, sztAddPortHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_SUBTITLE, sztAddPortHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztMoreInfoPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_MOREINFO_HEADER, sztMoreInfoHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_MOREINFO_SUBTITLE, sztMoreInfoHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztMultiPortPageTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_MULTIPORT_HEADER, sztMultiPortHeaderTitle, MAX_TITLE_LENGTH);
    LoadString(g_hInstance, IDS_MULTIPORT_SUBTITLE, sztMultiPortHeaderSubTitle, MAX_SUBTITLE_LENGTH);
    LoadString(g_hInstance, IDS_STRING_ADDPORT_TITLE, sztSummaryPageTitle, MAX_TITLE_LENGTH);

    FillInPropertyPage( &psp[0], IDD_WELCOME_PAGE, sztWelcomePageTitle, sztWelcomePageTitle, NULL, PSP_HIDEHEADER, WelcomeDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[1], IDD_DIALOG_ADDPORT, sztAddPortPageTitle, sztAddPortHeaderTitle, sztAddPortHeaderSubTitle, 0, GetAddressDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[2], IDD_DIALOG_MORE_INFO, sztMoreInfoPageTitle, sztMoreInfoHeaderTitle, sztMoreInfoHeaderSubTitle, 0, MoreInfoDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[3], IDD_DIALOG_MULTIPORT, sztMultiPortHeaderTitle, sztMultiPortHeaderTitle, sztMultiPortHeaderSubTitle, 0, MultiPortDialog, (LPARAM)&Params);
    FillInPropertyPage( &psp[4], IDD_DIALOG_SUMMARY, sztSummaryPageTitle, NULL, NULL, PSP_HIDEHEADER, SummaryDialog, (LPARAM)&Params);

    LoadString(g_hInstance, IDS_STRING_CONFIG_TITLE, sztPropSheetTitle, MAX_TITLE_LENGTH);

    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.hInstance       = g_hInstance;
    psh.dwFlags         = PSH_WIZARD | PSH_PROPSHEETPAGE | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    psh.hwndParent      = hWndParent;
    psh.pszCaption      = sztPropSheetTitle;
    psh.nPages          = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage      = 0;
    psh.ppsp            = psp;
    psh.pszbmWatermark  = MAKEINTRESOURCE( IDB_WATERMARK );
    psh.pszbmHeader     = MAKEINTRESOURCE( IDB_BANNER );

    iReturnVal = PropertySheet(&psh);

    if (iReturnVal < 0) {
        return(ERROR_INVALID_FUNCTION);
    }

    return(Params.dwLastError);

} // AddPortUI


//
//  FUNCTION: ConfigPortUI
//
//  PURPOSE: Main function called when the User Interface for configuring a port is called.
//
DWORD CNT5UIManager::ConfigPortUI(HWND hWndParent,
                                  PPORT_DATA_1 pData,
                                  HANDLE hXcvPrinter,
                                  TCHAR *szServerName,
                                  BOOL bNewPort)
{
    INT_PTR iReturnVal = NO_ERROR;
    PROPSHEETPAGE psp[MaxNumCfgPages];
    PROPSHEETHEADER psh;

    TCHAR sztPropSheetTitle[MAX_TITLE_LENGTH];
    TCHAR sztPortPageTitle[MAX_TITLE_LENGTH];


    CFG_PARAM_PACKAGE Params;
    Params.pData = pData;
    pData->dwVersion = 1;
    Params.hXcvPrinter = hXcvPrinter;
    Params.bNewPort = bNewPort;
    Params.dwLastError = NO_ERROR;
    if (szServerName != NULL) {
        lstrcpyn(Params.pszServer, szServerName, MAX_NETWORKNAME_LEN);
    } else {
        Params.pszServer[0] = '\0';
    }

    LoadString(g_hInstance, IDS_STRING_PORTPAGE_TITLE, sztPortPageTitle, MAX_TITLE_LENGTH);

    FillInPropertyPage( &psp[0], IDD_PORT_SETTINGS, sztPortPageTitle, NULL, NULL, 0, ConfigurePortPage, (LPARAM)&Params);
#if 0
    if (!bNewPort) {
        // It's not a brand new port so show the AllPorts Page.
        FillInPropertyPage( &psp[1], IDD_DIALOG_CONFIG_ALL, sztAllPortsPageTitle, NULL, NULL, 0, AllPortsPage, (LPARAM)&Params);
    }
#endif
    LoadString(g_hInstance, IDS_STRING_CONFIG_TITLE, sztPropSheetTitle, MAX_TITLE_LENGTH);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE;
    psh.hwndParent = hWndParent;
    psh.hInstance = g_hInstance;
    psh.pszCaption = sztPropSheetTitle;
    psh.nStartPage = 0;
    psh.ppsp = psp;
    psh.pfnCallback = NULL;
    psh.nPages = MaxNumCfgPages;

    iReturnVal = PropertySheet(&psh);

    if (iReturnVal < 0) {
        return(ERROR_INVALID_FUNCTION);
    }

    return(Params.dwLastError);

} // ConfigPortUI


//
//
//  FUNCTION: FillInPropertyPage(PROPSHEETPAGE *, int, LPSTR, LPFN)
//
//  PURPOSE: Fills in the given PROPSHEETPAGE structure
//
//  COMMENTS:
//
//      This function fills in a PROPSHEETPAGE structure with the
//      information the system needs to create the page.
//
static void FillInPropertyPage( PROPSHEETPAGE* psp, int idDlg, LPTSTR pszProc, LPTSTR pszHeaderTitle, LPTSTR pszHeaderSubTitle, DWORD dwFlags, STRICT_DLGPROC pfnDlgProc, LPARAM lParam)
{
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = PSP_USETITLE |
                   ((pszHeaderTitle != NULL) ? PSP_USEHEADERTITLE : 0) |
                   ((pszHeaderSubTitle != NULL) ? PSP_USEHEADERSUBTITLE : 0) |
                   dwFlags;
    psp->hInstance = g_hInstance;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = (DLGPROC)pfnDlgProc;
    psp->pszTitle = pszProc;
    psp->lParam = lParam;
    psp->pszHeaderTitle = pszHeaderTitle;
    psp->pszHeaderSubTitle = pszHeaderSubTitle;

} // FillInPropertyPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\tcpmonui.cpp ===
/*****************************************************************************
 *
 * $Workfile: TCPMonUI.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/
#include "precomp.h"
#include "TCPMonUI.h"
#include "UIMgr.h"
#include "resource.h"
#include "splcom.h"
#include "helpids.h"

HINSTANCE g_hInstance = NULL;
MONITORUI g_monitorUI;

// library handles:
HINSTANCE g_hWinSpoolLib = NULL;
HINSTANCE g_hPortMonLib = NULL;
HINSTANCE g_hTcpMibLib = NULL;

///////////////////////////////////////////////////////////////////////////////
//  LoadGlobalLibraries
//
BOOL LoadGlobalLibraries()
{
    BOOL bReturn = TRUE;

    g_hWinSpoolLib = ::LoadLibrary(TEXT("WinSpool.drv"));
    if(g_hWinSpoolLib == NULL)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_LOADING_WINSPOOL_LIB);
        bReturn = FALSE;
    }

    // In either case load the tcpmib dll.
    g_hTcpMibLib = ::LoadLibrary(TCPMIB_DLL_NAME);
    if(g_hTcpMibLib == NULL)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_LOADING_TCPMIB_LIB);
        bReturn = FALSE;
    }

    return(bReturn);

} // LoadGlobalLibraries


///////////////////////////////////////////////////////////////////////////////
//  DllMain
//
BOOL APIENTRY
DllMain (       HANDLE in hInst,
            DWORD  in dwReason,
            LPVOID in lpReserved )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            //
            // Initialize common controls.
            //
            INITCOMMONCONTROLSEX icc;
            InitCommonControls();
            icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
            icc.dwICC = ICC_STANDARD_CLASSES|ICC_BAR_CLASSES;
            InitCommonControlsEx(&icc);

            DisableThreadLibraryCalls( hInst );

            InitDebug(MONUI_DEBUG_FILE);            // initialize debug file

            g_hInstance = (HINSTANCE) hInst;
            memset(&g_monitorUI, 0, sizeof(g_monitorUI));

            return TRUE;

        case DLL_PROCESS_DETACH:
            {
                // The UI sets the last error for the spooler to use later
                // we are keeping a copy to make sure that it is not over
                // written by the dlls as they unload
                //

                DWORD dwLastError = GetLastError();

                if( g_hWinSpoolLib != NULL )
                {
                   ::FreeLibrary(g_hWinSpoolLib);
                }
                if( g_hPortMonLib != NULL )
                {
                   ::FreeLibrary(g_hPortMonLib);
                }
                if( g_hTcpMibLib != NULL )
                {
                    ::FreeLibrary(g_hTcpMibLib);
                }

                if (WSACleanup() == SOCKET_ERROR)
                {
                      _RPT0(_CRT_WARN,"\t> Unable to clean up windows sockets\n");
                }

                // This resets the application last error if one
                // exists.  We cannot allow the UI last error to
                // be overwritten by the dlls being unloaded
                //
                if( dwLastError != NO_ERROR ) {
                    SetLastError( dwLastError );
                }
           }

            // perform any necessary clean up process
            return TRUE;

        case DLL_THREAD_ATTACH:

            return TRUE;

        case DLL_THREAD_DETACH:

            return TRUE;
    }

    return FALSE;

} // DllMain


///////////////////////////////////////////////////////////////////////////////
//  InitializePrintMonitorUI
//              Returns a MONITOREX structure or NULL if failure
//
PMONITORUI WINAPI
InitializePrintMonitorUI(VOID)
{
    DWORD           dwRetCode = NO_ERROR;
    PMONITORUI      pMonitorUI = NULL;
    WSADATA wsaData;

    if(! LoadGlobalLibraries())
        return NULL;

    // Start up Winsock.
    if ( WSAStartup(WS_VERSION_REQUIRED, (LPWSADATA)&wsaData) != NO_ERROR)
    {
        _RPT1(_CRT_WARN, "CSSOCKET -- CStreamSocket() WSAStartup failed! Error( %d )\n", WSAGetLastError());
        return NULL;
    }

    g_monitorUI.dwMonitorUISize = sizeof(MONITORUI);
    g_monitorUI.pfnAddPortUI                = ::AddPortUI;
    g_monitorUI.pfnConfigurePortUI  = ::ConfigurePortUI;
    g_monitorUI.pfnDeletePortUI             = ::DeletePortUI;

    pMonitorUI = &g_monitorUI;


    return (pMonitorUI);

} // InitializePrintMonitorUI


///////////////////////////////////////////////////////////////////////////////
//  RemoteAddPortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
AddPortUI(PCWSTR pszServer, HWND hWnd, PCWSTR pszMonitorNameIn, PWSTR *ppszPortNameOut)
{
    CUIManager manager;
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    DWORD dwRetCode = NO_ERROR;
    BOOL bReturn = TRUE;
    TCHAR szServerName[MAX_NETWORKNAME_LEN] = {0};

    if ( ppszPortNameOut )
        *ppszPortNameOut = NULL;

    if (hWnd == NULL)
    {
        return TRUE;
    }

    TCHAR *psztPortName = (TCHAR *)malloc(sizeof(TCHAR) * MAX_PORTNAME_LEN);
    if( psztPortName == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );
    }

    if(pszServer != NULL)
    {
        lstrcpyn(szServerName, pszServer, MAX_NETWORKNAME_LEN);
    }

    // Construct the OpenPrinter String
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];
    if(pszServer == NULL)
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT(",XcvMonitor %s"), pszMonitorNameIn);
    }
    else
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT("%s\\,XcvMonitor %s"), pszServer, pszMonitorNameIn);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);

    if(bReturn)
    {
        if(hXcvPrinter != NULL)
        {
            dwRetCode = manager.AddPortUI(hWnd,
                                          hXcvPrinter,
                                          szServerName,
                                          psztPortName);
        }

        if ( ppszPortNameOut )
        {
            _ASSERTE(psztPortName != NULL);
            *ppszPortNameOut = psztPortName;
            psztPortName = NULL;
        }
    }
    else
    {
        dwRetCode = GetLastError();
    }

    if( psztPortName != NULL)
    {

        free( psztPortName );
        psztPortName = NULL;
    }

    if( hXcvPrinter != NULL )
    {
        ClosePrinter(hXcvPrinter);
    }

    if( dwRetCode != NO_ERROR )
    {
        // something went wrong
        bReturn = FALSE;
    }

    SetLastError( dwRetCode );
    return bReturn;

} // ExtAddPortUI


///////////////////////////////////////////////////////////////////////////////
//  Load and Call XcvData in order to get Configuration Information.
//              Returns TRUE if success, FALSE otherwise
//
DWORD GetConfigInfo(PORT_DATA_1 *pData, HANDLE hXcvPrinter, PCWSTR pszPortName)
{
    XCVDATAPARAM pfnXcvData = NULL;
    DWORD dwRet = NO_ERROR;
    DWORD dwDataSize = 0;
    DWORD dwOutputNeeded = 0;
    DWORD dwStatus = 0;
    BOOL bReturn = TRUE;
    CONFIG_INFO_DATA_1 cfgData;

    memset( &cfgData, 0, sizeof( cfgData ));
    cfgData.dwVersion = 1;

    // load & assign the function pointer
    if(g_hWinSpoolLib != NULL)
    {
        // initialize the library
        pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
        if(pfnXcvData != NULL)
        {
            dwDataSize = sizeof(PORT_DATA_1);

            //
            // Set the UI version
            //
            pData->dwVersion = 1;

            // here's the call we've all been waiting for:
            bReturn = (*pfnXcvData)(hXcvPrinter,
                                (PCWSTR)TEXT("GetConfigInfo"),
                                (LPBYTE)&cfgData, // Input Data
                                sizeof( cfgData ),      // Input Data Size
                                (LPBYTE)pData, // Output Data
                                dwDataSize, // Output Data Size
                                &dwOutputNeeded, // size of output buffer server wants to return
                                &dwStatus // return status value from remote component
                                );
            if(!bReturn)
            {
                dwRet = GetLastError();
                DisplayErrorMessage(NULL, dwRet);
            }
            else
            {
                if(dwStatus != NO_ERROR)
                {
                    DisplayErrorMessage(NULL, dwStatus);
                }
            }

        }
        else
        {
            dwRet = ERROR_DLL_NOT_FOUND; // TODO: change to an appropriate error code.
        }

    }
    else
    {
        dwRet = ERROR_DLL_NOT_FOUND;
    }

    return(dwRet);

} // GetConfigInfo


///////////////////////////////////////////////////////////////////////////////
//  RemoteConfigurePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
ConfigurePortUI(PCWSTR pszServer, HWND hWnd, PCWSTR pszPortName)
{
    PORT_DATA_1 Data;
    memset(&Data, 0, sizeof(PORT_DATA_1));
    CUIManager manager;
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };

    DWORD dwResult = NO_ERROR;
    BOOL bReturn = TRUE;
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];
    TCHAR szServerName[MAX_NETWORKNAME_LEN] = {0};
    if(pszServer && *pszServer)
    {
        lstrcpyn(szServerName, pszServer, MAX_NETWORKNAME_LEN);
    }

    if(hWnd == NULL)
    {
        return bReturn;
    }

    // Construct the OpenPrinter String
    if(pszServer && *pszServer)
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT("%s\\,XcvPort %s"), pszServer, pszPortName);
    }
    else
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT(",XcvPort %s"), pszPortName);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);

    if(bReturn != FALSE && hXcvPrinter != NULL)
    {
        HCURSOR hNewCursor = NULL;
        HCURSOR hOldCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if( hNewCursor )
        {
            hOldCursor = SetCursor(hNewCursor);
        }

        dwResult = GetConfigInfo(&Data, hXcvPrinter, pszPortName);

        if( hNewCursor )
        {
            SetCursor(hOldCursor);
        }

        if(dwResult != NO_ERROR)
        {
            SetLastError(dwResult);
            bReturn = FALSE;
        }

        if(bReturn == TRUE)
        {
            dwResult = manager.ConfigPortUI(hWnd, &Data, hXcvPrinter, szServerName);
            if(dwResult != NO_ERROR)
            {
                SetLastError(dwResult);
                bReturn = FALSE;
            }
        }
    }

    if( hXcvPrinter != NULL )
    {
        ClosePrinter(hXcvPrinter);
    }
    if (!bReturn && dwResult != NO_ERROR)
    {
        SetLastError (dwResult);
    }
    return(bReturn);

} // ConfigurePortUI


///////////////////////////////////////////////////////////////////////////////
//  RemoteDeletePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
DeletePortUI(PCWSTR pszServer,
             HWND hwnd,
             PCWSTR pszPortName)
{
    HANDLE hXcvPrinter = NULL;
    PRINTER_DEFAULTS Default = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    BOOL bReturn = TRUE;
    XCVDATAPARAM pfnXcvData = NULL;
    DELETE_PORT_DATA_1 delData;
    memset(&delData, 0, sizeof(DELETE_PORT_DATA_1));
    DWORD dwDataSize = 0;
    DWORD dwOutputNeeded = 0;
    DWORD dwStatus = 0;
    TCHAR OpenPrinterString[MAX_UNC_PRINTER_NAME];

    // Construct the OpenPrinter String
    if(pszServer == NULL || pszServer[0] == TEXT('\0'))
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT(",XcvPort %s"), pszPortName);
    }
    else
    {
        StringCchPrintf (OpenPrinterString, COUNTOF (OpenPrinterString), TEXT("%s\\,XcvPort %s"), pszServer, pszPortName);
    }

    bReturn = OpenPrinter(OpenPrinterString, &hXcvPrinter, &Default);
    if(bReturn)
    {
        // load & assign the function pointer
        if(g_hWinSpoolLib != NULL)
        {
            // initialize the library
            pfnXcvData = (XCVDATAPARAM)::GetProcAddress(g_hWinSpoolLib, "XcvDataW");
            if(pfnXcvData != NULL)
            {
                // Set the data members of delData.
                if(pszServer && *pszServer )
                {
                    lstrcpyn(delData.psztName, pszServer, MAX_NETWORKNAME_LEN);
                }
                else
                {
                    delData.psztName[0] = '\0';
                }
                //delData.hWnd = 0;  This field si not used anywhere
                delData.dwVersion = 1;

                if(pszPortName != NULL)
                {
                    lstrcpyn(delData.psztPortName, pszPortName, MAX_PORTNAME_LEN);
                }
                else
                {
                    delData.psztPortName[0] = '\0';
                }
                dwDataSize = sizeof(DELETE_PORT_DATA_1);

                // here's the call we've all been waiting for:
                bReturn = (*pfnXcvData)(hXcvPrinter,
                                        (PCWSTR)TEXT("DeletePort"),
                                        (BYTE *)(& delData),    // Input Data
                                        dwDataSize,             // Input Data Size
                                        NULL,                   // Output Data
                                        0,                      // Output Data Size
                                        &dwOutputNeeded,        // size of output buffer server wants to return
                                        &dwStatus               // return status value from remote component
                                        );

                if(bReturn)
                {
                    if(dwStatus != NO_ERROR)
                    {
                        DisplayErrorMessage(NULL, dwStatus);

                        //
                        // The call actually failed. Since we already displayed the error message
                        // we need to disable the popup from printui.
                        //

                        SetLastError (ERROR_CANCELLED);
                        bReturn = FALSE;
                    }
                }
                else {
                    DisplayErrorMessage(NULL, GetLastError ());

                    //
                    // The call actually failed. Since we already displayed the error message
                    // we need to disable the popup from printui.
                    //

                    SetLastError (ERROR_CANCELLED);
                    bReturn = FALSE;
                }
            }
            else // pfnXcvData == NULL
            {
                bReturn = FALSE;
                SetLastError(ERROR_DLL_NOT_FOUND);
            }
        }
        else // g_hWinSpoolLib == NULL
        {
            SetLastError(ERROR_DLL_NOT_FOUND);
        }

        if( hXcvPrinter != NULL )
        {
            DWORD dwLastError = GetLastError ();
            ClosePrinter(hXcvPrinter);
            SetLastError (dwLastError);
        }
    }

    return(bReturn);

} // DeletePortUI


///////////////////////////////////////////////////////////////////////////////
//  LocalAddPortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
LocalAddPortUI(HWND in hWnd)
{
    DWORD dwRetCode = NO_ERROR;

    CUIManager manager;
    dwRetCode = manager.AddPortUI(hWnd, NULL, NULL, NULL);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // LocalAddPortUI


///////////////////////////////////////////////////////////////////////////////
//  LocalConfigurePortUI
//              Returns TRUE if success, FALSE otherwise
//
extern "C" BOOL WINAPI
LocalConfigurePortUI(HWND   in hWnd,
                     PORT_DATA_1 in *pConfigPortData)
{
    DWORD dwRetCode = NO_ERROR;
    CUIManager manager;

    // call ConfigurePortUI()
    dwRetCode = manager.ConfigPortUI(hWnd, pConfigPortData, NULL, NULL);

    if (dwRetCode != NO_ERROR)
    {
        SetLastError(dwRetCode);
        return FALSE;
    }

    return TRUE;

} // LocalConfigurePortUI


///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: DisplayErrorMessage()
//
//  PURPOSE:  To load a string resource, the error message, and put up a message box.
//
void DisplayErrorMessage(HWND hDlg, UINT uErrorTitleResource, UINT uErrorStringResource)
{
    TCHAR   ptcsErrorTitle[MAX_PATH];
    TCHAR   ptcsErrorMessage[MAX_PATH];
    LoadString(g_hInstance, uErrorTitleResource, ptcsErrorTitle, MAX_PATH);
    LoadString(g_hInstance, uErrorStringResource, ptcsErrorMessage, MAX_PATH);
    MessageBox(hDlg, ptcsErrorMessage, ptcsErrorTitle, MB_ICONERROR);

} // DisplayErrorMessage


///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: DisplayErrorMessage()
//
//  PURPOSE:  To load a string resource, the error message, and put up a message box.
//
void DisplayErrorMessage(HWND hDlg, DWORD dwLastError)
{
    const int iMaxErrorMsgSize = 75;
    TCHAR ptcsErrorTitle[iMaxErrorMsgSize];
    LoadString(g_hInstance, IDS_STRING_ERROR_TITLE, ptcsErrorTitle, iMaxErrorMsgSize);

    LPVOID lpMsgBuf = NULL;
    DWORD NumCharsInBuffer;

    NumCharsInBuffer = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
    );

    if(NumCharsInBuffer <= 0)
    {
        DisplayErrorMessage(NULL, IDS_STRING_ERROR_TITLE, IDS_STRING_ERROR_ERRMSG);
    }
    else
    {
        // Process any inserts in lpMsgBuf.
        // ...
        // Display the string.
        MessageBox( hDlg, (TCHAR *)lpMsgBuf, ptcsErrorTitle, MB_OK | MB_ICONERROR );

    }

    // Free the buffer.
    LocalFree( lpMsgBuf );


} // DisplayErrorMessage

///////////////////////////////////////////////////////////////////////////////
//  FUNCTION: OnHelp()
//
//  PURPOSE:  Process WM_HELP and WM_CONTEXTMENU messages
//
BOOL OnHelp(UINT iDlgID, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
        case WM_HELP:
            {
                bStatus = WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                                   PORTMONITOR_HELP_FILE,
                                   HELP_WM_HELP,
                                   (ULONG_PTR)g_a110HelpIDs );
            }
            break;

        case WM_CONTEXTMENU:
            {
                bStatus = WinHelp( (HWND)wParam,
                                   PORTMONITOR_HELP_FILE,
                                   HELP_CONTEXTMENU,
                                   (ULONG_PTR)g_a110HelpIDs );
            }
            break;

        default:
            bStatus= FALSE;
            break;
    }

    return bStatus;
} // OnHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\tcpmonui.h ===
/*****************************************************************************
 *
 * $Workfile: TCPMonUI.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

//
// defines
//

// MAX_ADDRESS_LENGTH should be set to max(MAX_FULLY_QUALIFIED_HOSTNAME_LEN-1, MAX_IPADDR_STR_LEN-1);
#define		MAX_ADDRESS_LENGTH			MAX_NETWORKNAME_LEN

#define MAX_PORTNUM_STRING_LENGTH 6+1
#define MAX_SNMP_DEVICENUM_STRING_LENGTH   128+1

//
// function prototypes
//
void DisplayErrorMessage(HWND hDlg, UINT uErrorTitleResource, UINT uErrorStringResource);
void DisplayErrorMessage(HWND hDlg, DWORD dwLastError);
BOOL OnHelp(UINT iDlgID, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//
// typedef's
//
typedef BOOL (* XCVDATAPARAM)(HANDLE, PCWSTR, PBYTE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
typedef DWORD (* UIEXPARAM)(PPORT_DATA_1);

//
// exported functions
//
BOOL APIENTRY DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved);
PMONITORUI WINAPI InitializePrintMonitorUI(VOID);
extern "C" BOOL WINAPI LocalAddPortUI(HWND hWnd);
extern "C" BOOL WINAPI LocalConfigurePortUI(HWND hWnd, PORT_DATA_1 *pConfigPortData);


//
// Global Variables
//
extern HINSTANCE g_hWinSpoolLib;
extern HINSTANCE g_hPortMonLib;
extern HINSTANCE g_hTcpMibLib;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcpmonui.rc
//
#define IDS_STRING_CONFIG_TITLE         1
#define IDS_STRING_ALLPORTS_TITLE       2
#define IDS_STRING_PORTPAGE_TITLE       3
#define IDS_STRING_ADDPORT_TITLE        4
#define IDS_STRING_ERROR_ADDRESS_NOT_VALID 5
#define IDS_STRING_ERROR_TITLE          6
#define IDS_STRING_ERROR_PORTNAME_NOT_VALID 7
#define IDS_STRING_ERROR_PORTNAME_NOT_UNIQUE 8
#define IDS_STRING_ERROR_LOADING_TCPMIB_LIB 9
#define IDS_STRING_YES                  10
#define IDS_STRING_NO                   11
#define IDS_STRING_RAW                  12
#define IDS_STRING_LPR                  13
#define IDS_STRING_PORT                 14
#define IDS_STRING_UNKNOWN_DEVICE       15
#define IDS_STRING_ERROR_PORT_NUMBER_NOT_VALID 16
#define IDS_STRING_ERROR_QNAME_NOT_VALID 17
#define IDS_STRING_ERROR_COMMUNITY_NAME_NOT_VALID 18
#define IDS_STRING_ERROR_SNMP_DEVINDEX_NOT_VALID 19
#define IDS_STRING_ADDPORT_HEADER       20
#define IDS_STRING_ADDPORT_SUBTITLE     21
#define IDS_STRING_MOREINFO_HEADER      22
#define IDS_STRING_MOREINFO_SUBTITLE    23
#define IDS_STRING_DEV_NOT_FOUND        24
#define IDS_STRING_MULTI_PORT_DEV       25
#define IDS_STRING_UNKNOWN_DEV          26
#define IDS_STRING_ERROR_LOADING_TCPMON_LIB 27
#define IDS_STRING_ERROR_LOADING_WINSPOOL_LIB 28
#define IDS_STRING_NAME_IP              29
#define IDS_ERROR_ACCESS                30
#define IDS_STRING_ERROR_ERRMSG         30
#define IDS_ERROR_DATA                  31
#define IDS_STRING_ADD_PORT             31
#define IDS_ERROR_MEMORY                32
#define IDS_LARGEFONTNAME               32
#define IDS_LARGEFONTSIZE               33
#define IDS_MULTIPORT_HEADER            34
#define IDS_MULTIPORT_SUBTITLE          35
#define IDD_DIALOG_ADDPORT              101
#define IDC_TRACKBAR_FAILURE_TIMEOUT    101
#define IDD_WELCOME_PAGE                102
#define IDD_DIALOG_SUMMARY              103
#define IDD_DIALOG_PORT_SETTINGS        104
#define IDD_DIALOG_MORE_INFO            105
#define IDD_DIALOG_CONFIG_ALL           106
#define IDB_WATERMARK                   108
#define IDB_BANNER                      109
#define IDD_PORT_SETTINGS               110
#define IDD_DIALOG_MULTIPORT            111
#define IDC_EDIT_DEVICE_ADDRESS         1000
#define IDC_EDIT_PORT_NAME              1001
#define IDC_CHECK_STATUSUPDATE          1001
#define IDC_EDIT_SNMP_YESNO             1002
#define IDC_TRACKBAR_TOP                1002
#define IDC_EDIT_PROTOCOL_AND_PORTNUM   1003
#define IDC_EDIT_IPADDRESS              1004
#define IDC_DIGITAL_FAILURE_TIMEOUT     1004
#define IDC_EDIT_ADDRESS                1004
#define IDC_EDIT_PORTNAME               1005
#define IDC_RADIO1                      1006
#define IDC_RADIO_RAW                   1006
#define IDC_EDIT_SYSTEMID               1006
#define IDC_RADIO_LPR                   1007
#define IDC_EDIT_RAW_PORT_NUM           1008
#define IDC_EDIT2                       1009
#define IDC_EDIT_LPR_QNAME              1009
#define IDC_CHECK_SNMP                  1010
#define IDC_EDIT3                       1011
#define IDC_EDIT_COMMUNITY_NAME         1011
#define IDC_EDIT4                       1012
#define IDC_EDIT_DEVICE_INDEX           1012
#define IDC_RADIO_STANDARD              1013
#define IDC_RADIO_CUSTOM                1014
#define IDC_BUTTON1                     1015
#define IDC_BUTTON_SETTINGS             1015
#define IDC_COMBO_DEVICES               1016
#define IDC_STATIC_RAW_PORT_NUM         1017
#define IDC_STATIC_LPR_QNAME            1020
#define IDC_STATIC_COMMUNITY_NAME       1021
#define IDC_STATIC_DEVICE_INDEX         1022
#define IDC_STATIC_MOREINFO_REASON      1024
#define IDC_STATIC_PORT_NAME            1026
#define IDC_STATIC_DEVICE_ADDRESS       1027
#define IDC_STATIC_ALL_PORTS_TITLE      1028
#define IDC_STATIC_FT_LABEL             1029
#define IDC_STATIC_MINUTES              1030
#define IDC_STATIC_MORE_OFTEN           1031
#define IDC_STATIC_LESS_OFTEN           1032
#define IDC_STATIC_ADD_PORT             1033
#define IDC_TITLE                       1034
#define IDC_CHECK_LPR_DOUBLESPOOL       1035
#define IDS_GENERIC_NETWORK_CARD        2000
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\usbmon\enumports.h ===
BOOL WINAPI USBMON_EnumPorts(LPWSTR pName, DWORD Level, LPBYTE  pPorts, DWORD cbBuf,LPDWORD pcbNeeded, LPDWORD pcReturned);

#define MAX_PORT_LEN 20	 //chars, this is the max port len of a USB printer
#define MAX_PORT_DESC_LEN 60 //chars This will probably need to get bigger or be made dynamic if we want port-unique descriptions
#define MAX_MONITOR_NAME_LEN 40
//#define PORT_NAME_BASE L"USB"
//#define PORT_NAME_BASE_A "USB"
#define MAX_PRINTER_NAME_LEN 222 
#define MONITOR_NAME L"USB Print Monitor"
#define STANDARD_PORT_DESC L"Virtual printer port for USB"
#define MAX_ENUM_PRINTER_BUFFER_SIZE 1024*512


#define MAX_WRITE_CHUNK 10240

typedef struct USBMON_PRINTER_INFO_DEF
{
	WCHAR DevicePath[256];
	BOOL bLinked;
	DWORD dwVidPid;
	struct USBMON_PRINTER_INFO_DEF *pNext;

} USBMON_PRINTER_INFO, *PUSBMON_PRINTER_INFO;

typedef struct USBMON_PORT_INFO_DEF
{
	WCHAR szPortName[MAX_PORT_LEN];
	WCHAR szPortDescription[MAX_PORT_DESC_LEN];
	WCHAR DevicePath[256];
	int iRefCount;
    DWORD ReadTimeoutMultiplier;
    DWORD ReadTimeoutConstant;
    DWORD WriteTimeoutMultiplier;
    DWORD WriteTimeoutConstant;
	HANDLE hDeviceHandle;
	HANDLE hPrinter; //handle to print queue
	DWORD dwCurrentJob;
	DWORD dwDeviceFlags;
	struct USBMON_PORT_INFO_DEF *pNext;
} USBMON_PORT_INFO, *PUSBMON_PORT_INFO;

typedef struct USBMON_BASENAME_DEF
{
	WCHAR wcBaseName[MAX_PORT_LEN];
	struct USBMON_BASENAME_DEF *pNext;
} USBMON_BASENAME, * PUSBMON_BASENAME;

typedef struct USBMON_QUEUE_INFO_DEF
{
	WCHAR wcPortName[MAX_PORT_LEN];
	WCHAR wcPrinterName[MAX_PRINTER_NAME_LEN];
	struct USBMON_QUEUE_INFO_DEF *pNext;
} USBMON_QUEUE_INFO, *PUSBMON_QUEUE_INFO;

extern PUSBMON_PORT_INFO pPortInfoG;
extern PUSBMON_PRINTER_INFO pPrinterInfoG;
extern char szDebugBuff[];
extern HKEY hPortsKeyG; //global, declared in EnumPorts.
extern PUSBMON_BASENAME GpBaseNameList;

// {28D78FAD-5A12-11d1-AE5B-0000F803A8C2}
static const GUID USB_PRINTER_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\usbmon\enumports.c ===
#include <nt.h>																		
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
//#include <wchar.h>
#include <setupapi.h>
//#include <stdlib.h>
#include "enumports.h"
#include "usbmon.h"

void vOldAddItemToPortList(PUSBMON_PORT_INFO *pHead,PUSBMON_PORT_INFO pNew); 
PUSBMON_PRINTER_INFO pOldGetPrinterList();
LONG UpdateAssociations(PUSBMON_PORT_INFO *ppPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG AllocateNewPorts(PUSBMON_PORT_INFO *ppPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG DoBestEffortMatches(PUSBMON_PORT_INFO pPortList,PUSBMON_PRINTER_INFO pPrinterList);
LONG ReattachExactMatches(PUSBMON_PORT_INFO pPortList,PUSBMON_PRINTER_INFO pPrinterList);
//void InitPortBits(PUSBMON_PORT_INFO pPortList);
//PUSBMON_PORT_INFO pGetNewPortNode(PUSBMON_PORT_INFO *ppListHead);
LONG WriteNewAssociations(int *iNumberOfPorts,PUSBMON_PORT_INFO pPortList,HKEY hPortRoot);
void FreePrinterList(PUSBMON_PRINTER_INFO pPrinterList);
LONG BuildReturnTable(int iNumberOfPorts,PUSBMON_PORT_INFO pPortList,DWORD Level,LPBYTE Ports,DWORD cBuf,LPDWORD pcbNeeded,LPDWORD pcReturned);
char szDebugBuff[512];
char *WtoA(WCHAR *pInString);
long lAddPrinterToList(PUSBMON_PORT_INFO *ppHead,HDEVINFO hDeviceList,PSP_DEVICE_INTERFACE_DATA prDeviceInfo,PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,PUSBMON_BASENAME *ppBaseNames);
int iCountPresentPrinters(PUSBMON_PORT_INFO pHead);
LONG lGetPrintersAndPorts(PUSBMON_PORT_INFO *ppHead,PUSBMON_BASENAME *);
LONG lGetQueues(PUSBMON_QUEUE_INFO *ppQueueList,PUSBMON_BASENAME pBaseNames);
LONG lAddQueueToList(LPWSTR pPortName,LPWSTR pPrinterName,PUSBMON_QUEUE_INFO *ppQueueHead);
void vDestroyQueueList(PUSBMON_QUEUE_INFO pQueueList);
void vCleanUpQueuesAndPorts(PUSBMON_PORT_INFO  * pPortInfo,int iNumberOfPorts,PUSBMON_BASENAME pBaseNames);
DWORD WINAPI CleanupThread(LPVOID pParam);
void vEliminateOldQueuesAndPorts(PUSBMON_QUEUE_INFO pQueueInfo,PUSBMON_PORT_INFO * fpPortInfo);
void vDeletePort(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList);
void vGreyOutQueue(PUSBMON_QUEUE_INFO pQueue);
void vUnGreyQueue(PUSBMON_QUEUE_INFO pQueue);
HANDLE hGetPortRegKey(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList);
void vAddNameToBaseNameList(PUSBMON_BASENAME *ppBaseNames,WCHAR *wcPortBaseName);
BOOL bCheckPortName(LPTSTR pPortName,PUSBMON_BASENAME pBaseNames);
int iGetNumberOfPorts(PUSBMON_PORT_INFO pHead);


int iCleanupThreads=0;
HKEY hPortsKeyG; //global
PUSBMON_PORT_INFO pPortInfoG=NULL;
int iLastPrintersHere=-1;



typedef struct CLEANUP_THREAD_PARAMS_DEF
{
	PUSBMON_PORT_INFO * ppPortInfo;
	PUSBMON_BASENAME pBaseNames;
	int iPortCount;
	HANDLE hSemaphore;
} CLEANUP_THREAD_PARAMS,*PCLEANUP_THREAD_PARAMS;



BOOL WINAPI USBMON_EnumPorts(LPWSTR pName, DWORD Level, LPBYTE  pPorts, DWORD cbBuf,LPDWORD pcbNeeded, LPDWORD pcReturned)
{
	PUSBMON_PRINTER_INFO pPrinterList;
	LONG lResult;
	DWORD dwStatus;
	int iNumberOfPorts;
	static int iOldNumberOfPorts=0;
	static int iNumCalls=0;
	int iThisCall;
	int iPrintersHere;
	

	OutputDebugStringD2("USBMON ++=Head of EnumPorts, before WaitForSingleObject\n");
	iThisCall=++iNumCalls;
	wsprintfA(szDebugBuff,"USBMON:  +++++++++++++++++++++++++++++++++++++++++++++++++EnumPorts call # %d, handle = %x\n",iThisCall,hMonitorSemaphore);
	OutputDebugStringD2(szDebugBuff);	
	dwStatus=WaitForSingleObject(hMonitorSemaphore,INFINITE);
	if(dwStatus==WAIT_FAILED)
	{
    OutputDebugStringD1("USBMON: WaitForSingleObject failed!\n");
	}
	wsprintfA(szDebugBuff,"USBMON Head of EnumPrts, ++++++++++++++++++++++++++++++++++++ Instance # %d, after WaitForSingleObject, return code=%d\n",iThisCall,dwStatus);
	OutputDebugStringD2(szDebugBuff);

	
	lResult=lGetPrintersAndPorts(&pPortInfoG,&GpBaseNameList);
	iNumberOfPorts=iGetNumberOfPorts(pPortInfoG);
	
	  if(iCleanupThreads==0)
		{
		  iPrintersHere=iCountPresentPrinters(pPortInfoG);
		  if(iPrintersHere!=iLastPrintersHere)
		  {
		  	iLastPrintersHere=iPrintersHere;
			iCleanupThreads++;
			OutputDebugStringD3("USBMON: About to clean up queues and ports\n");

 			vCleanUpQueuesAndPorts(&pPortInfoG,iNumberOfPorts,GpBaseNameList);	

		  } //end printer count changed
		}
  

	lResult=BuildReturnTable(iNumberOfPorts,pPortInfoG,Level,pPorts,cbBuf,pcbNeeded,pcReturned);
	
	if(lResult!=ERROR_SUCCESS)
	{
		OutputDebugStringD2("USBMON: Unable to build return buffer (this is normal for first call)\n");
		goto EnumPortsError;
	}
	
  OutputDebugStringD3("USBMON tail of EnumPorts, before ReleaseSemaphore\n");

  ReleaseSemaphore(hMonitorSemaphore,1,NULL);	
	return TRUE;
EnumPortsError:
	wsprintfA(szDebugBuff,"USBMON tail of EnumPorts, error path, before ReleaseSemaphore, *pcbNeeded=%d\n",*pcbNeeded);
	OutputDebugStringD3(szDebugBuff);


	if(!ReleaseSemaphore(hMonitorSemaphore,1,NULL))
	{
		  wsprintfA(szDebugBuff,"USBMON: EnumPorts Release sempahore failed for instance %d \n",iThisCall);
		  OutputDebugStringD1(szDebugBuff);
	}
	else
	{
		  wsprintfA(szDebugBuff,"USBMON: EnumPortsRelease sempahore succeeded for instance %d \n",iThisCall);
		  OutputDebugStringD2(szDebugBuff);
	}
	SetLastError(ERROR_INSUFFICIENT_BUFFER);
	return FALSE;
} /*End EnumPorts*/


int iGetNumberOfPorts(PUSBMON_PORT_INFO pHead)
{
	PUSBMON_PORT_INFO pWalk;
	int iCount=0;

	pWalk=pHead;
	while(pWalk!=NULL)
	{
		iCount++;
		pWalk=pWalk->pNext;
	}/*end while*/
    return iCount;
} /*end function iGetNumberOfPorts*/

/***********************************
 * lGetQueues
 *
 * This function builds a linked list of print queues
 * who's port names start with a registered basename.
 *
 * This list is used to grey out queues who's printers are 
 * Unavailable, and to delete ports who's printers are gone
 ************************************************************/
LONG lGetQueues(PUSBMON_QUEUE_INFO *ppQueueList,PUSBMON_BASENAME pBaseNames)
{
  DWORD dwBufferSize=1024;
	DWORD dwBufferNeeded=0;
	DWORD dwNumStructs;
	LPBYTE lpBuffer;
	BOOL bStatus;
	DWORD dwLoop;
	PRINTER_INFO_5 *pEnumInfo;
	LONG lStatus;

	OutputDebugStringD2("USBMON: Head of lGetQueues \n");
	lpBuffer=(LPBYTE)GlobalAlloc(0,dwBufferSize);
	if(lpBuffer==NULL)
	{
  	OutputDebugStringD1("USBMON: Unable to allocate memory in lGetQueues\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	OutputDebugStringD3("USBMON: Before EnumPrinters \n");

	bStatus=EnumPrinters(PRINTER_ENUM_LOCAL,NULL,5,lpBuffer,dwBufferSize,&dwBufferNeeded,&dwNumStructs);

	OutputDebugStringD3("USBMON: After EnumPrinters \n");
	if(dwBufferNeeded>dwBufferSize)
	{
		dwBufferSize=dwBufferNeeded;
		lpBuffer=GlobalReAlloc(lpBuffer,dwBufferSize,0);
		if(lpBuffer==NULL)
		{
  	  OutputDebugStringD1("USBMON: Unable to re-allocate memory in lGetQueues\n");
		  return ERROR_NOT_ENOUGH_MEMORY;
		}
		OutputDebugStringD3("USBMON: Before EnumPrinters2 \n");
		bStatus=EnumPrinters(PRINTER_ENUM_LOCAL,NULL,5,lpBuffer,dwBufferSize,&dwBufferNeeded,&dwNumStructs);
		OutputDebugStringD3("USBMON: After EnumPrinters2 \n");
	} 
	if(bStatus==FALSE)
	{
		OutputDebugStringD1("USBMON: lGetQueues: EnumPrinters failed\n");
		return GetLastError();
	}
  OutputDebugStringD3("USBMON: lGetQueues: Before for loop \n");	
	pEnumInfo=(PRINTER_INFO_5 *)lpBuffer;
	for(dwLoop=0;dwLoop<dwNumStructs;dwLoop++)
	{
		OutputDebugStringD3("USBMON: lGetQueues: Head of for loop \n");
		if(pEnumInfo->pPortName!=NULL)
		{
			OutputDebugStringD2("USBMON: lGetQueues: Valid port name \n");
//		  if(wcsncmp(pEnumInfo->pPortName,PORT_NAME_BASE,wcslen(PORT_NAME_BASE))==0)
		  if(bCheckPortName(pEnumInfo->pPortName,pBaseNames))
			{
			  OutputDebugStringD3("USBMON: lGetQueues: Valid port name, that starts with registered base name, add it to list \n");
			  lStatus=lAddQueueToList(pEnumInfo->pPortName,pEnumInfo->pPrinterName,ppQueueList);
			  if(lStatus!=ERROR_SUCCESS)
				{
				  GlobalFree(lpBuffer);
				  return lStatus;
				}
			} /*end if found a USB print queue*/
		} /*end if pPortName not NULL*/
		pEnumInfo++;
	}	/*end for loop*/
	GlobalFree(lpBuffer);
  return ERROR_SUCCESS;
} /*end function lGetQueues*/



BOOL bCheckPortName(LPTSTR pPortName,PUSBMON_BASENAME pBaseNames)
{
	BOOL bFound=FALSE;
	PUSBMON_BASENAME pWalk;

	OutputDebugStringD3("USBMON: Head of bCheckPortName\n");
	pWalk=pBaseNames;
    while((pWalk!=NULL)&&(!bFound))
	{
		
	    wsprintf((WCHAR *)szDebugBuff,L"USBMON:   PortBaseName==%s\n",pWalk->wcBaseName);
	    OutputDebugStringWD3((WCHAR *)szDebugBuff);						 

		if(wcsncmp(pPortName,pWalk->wcBaseName,wcslen(pWalk->wcBaseName))==0)
		{
			bFound=TRUE;
		}
		else
		{
			pWalk=pWalk->pNext;
		}
	} /*end while not found*/
	return bFound;
} /*end function bCheckPortName*/





LONG lAddQueueToList(LPWSTR pPortName,LPWSTR pPrinterName,PUSBMON_QUEUE_INFO *ppQueueHead)
{
	PUSBMON_QUEUE_INFO pNew,pWalk;
	BOOL bFound;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Head of lAddQueueToList, about to add queue with port %s\n",pPortName);
	OutputDebugStringWD3((WCHAR *)szDebugBuff);


	pNew=(PUSBMON_QUEUE_INFO)GlobalAlloc(0,sizeof(USBMON_QUEUE_INFO));
	if(pNew==NULL)
	{
	  OutputDebugStringD1("USBMON: vAddQueueToList, Out of memory\n");	
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	wcscpy(pNew->wcPortName,pPortName);
	if(pPrinterName!=NULL)
	  wcscpy(pNew->wcPrinterName,pPrinterName);
	else
		pNew->wcPrinterName[0]=L'\0';

	if(*ppQueueHead==NULL)
	{
		*ppQueueHead=pNew;
		pNew->pNext=NULL;
	}
	else if(lstrcmp(pNew->wcPortName,(*ppQueueHead)->wcPortName)<0)
	{
		pNew->pNext=*ppQueueHead;
		*ppQueueHead=pNew;
	}
	else
	{
		pWalk=*ppQueueHead;
		bFound=FALSE;
		while((!bFound)&&(pWalk->pNext!=NULL))
		{
			if(lstrcmp(pNew->wcPortName,pWalk->pNext->wcPortName)<0)
				bFound=TRUE;
			else
				pWalk=pWalk->pNext;
		}
		pNew->pNext=pWalk->pNext;
		pWalk->pNext=pNew;
	} /*end else, we need to walk the list*/
  return ERROR_SUCCESS;
} /*end function vAddQueueToList*/

void vDestroyQueueList(PUSBMON_QUEUE_INFO pQueueList)
{
	PUSBMON_QUEUE_INFO pWalk,pLast;
	
	pWalk=pQueueList;
	while(pWalk!=NULL)
	{
		pLast=pWalk;
		pWalk=pWalk->pNext;
		GlobalFree(pLast);
	} /*end while pWalk!=NULL*/
} /*end function vDestroyQueueList*/



LONG BuildReturnTable(int iNumberOfPorts,        // Internal variable, 
					  PUSBMON_PORT_INFO pPortList,// List of ports
					  DWORD Level,               // IN  specifies structure type to return
					  LPBYTE Ports,              // OUT Buffer to write to
					  DWORD cBuf,                // IN  size of buffer provided
					  LPDWORD pcbNeeded,         // OUT specifies bytes written to buffer, or the size the buffer should have been if it's to small
					  LPDWORD pcReturned)        // OUT specifies the number of structures (ports) stored in the buffer
{
	PORT_INFO_1 *pInfo1;
	PORT_INFO_2 *pInfo2;

	VOID *pNextStruct;
	WCHAR *pszNextString;

	
	int iNodeSize;
	LONG lResult;
	unsigned int iStringsSize;
	unsigned int iStaticSize; //size of "overhead" strings that are only created once for all ports
	
	unsigned int iAllStructsSize;
	unsigned int iAllStringsSize;	 
	unsigned int iTotalSize;
	PUSBMON_PORT_INFO pPortWalk;
	
    OutputDebugStringD2("USBMON: Head of BuildReturnTable\n"); 
	wsprintfA(szDebugBuff,"USBMON: iNumberOfPorts==%d, iLevel=%d\n",iNumberOfPorts,Level);
	OutputDebugStringD3(szDebugBuff);
	if(Level==1)
	{
		iNodeSize=sizeof(PORT_INFO_1);
		iStringsSize=MAX_PORT_LEN*2;
		iStaticSize=0;
	}
	else if(Level==2)
	{
		iNodeSize=sizeof(PORT_INFO_2);
		iStaticSize=(wcslen(MONITOR_NAME)+1)*2;
		iStringsSize=(MAX_PORT_LEN*2)+(MAX_PORT_DESC_LEN*2)+iStaticSize;
		
	}
	else
	{
		OutputDebugStringD1("USBMON: Unsupported structure level in BuildReturnTable\n");
		lResult=ERROR_INVALID_LEVEL; 
		goto BuildTableError;
	} /*end else it's a level we don't support*/
	iAllStructsSize=iNodeSize*iNumberOfPorts;
	iAllStringsSize=iStringsSize*iNumberOfPorts;
	iTotalSize=iAllStructsSize+iAllStringsSize;
	wsprintfA(szDebugBuff,"USBMON: spooler gave us a %lu byte buffer at %X, we need a %lu byte buffer\n",cBuf,Ports,iTotalSize);
	OutputDebugStringD3(szDebugBuff);
	*pcbNeeded=iTotalSize;
	if(iTotalSize>cBuf)
	{
		OutputDebugStringD3("USBMON: Buffer provided by spooler is not large enough\n");
		lResult=ERROR_INSUFFICIENT_BUFFER; 
	
		goto BuildTableError;

	}
	pNextStruct=(VOID *)Ports;
	pszNextString=(WCHAR *)(Ports+cBuf-iAllStringsSize); //ports+cbuff == end of the buffer, - iAllStringsSize == start of the strings
//	if(Level==2)
//	{
//		pszMonitorName=(WCHAR *)pszNextString;
//		wcscpy(pszMonitorName,MONITOR_NAME);
//		pszNextString+=(iStaticSize);
//	}
	pPortWalk=pPortList;
	if(iNumberOfPorts>0)
	  while(pPortWalk!=NULL)
	  {
		
		if(Level==1)
		{
			

			pInfo1=(PORT_INFO_1 *)pNextStruct;
			pInfo1->pName=pszNextString;  //crashing line
			
			wcscpy((WCHAR *)(pInfo1->pName),pPortWalk->szPortName);
			pszNextString+=(MAX_PORT_LEN);
			
			
						
		} /*end if level == 1*/
		else				 
		{
			OutputDebugStringD2("USBMON: Head of build PORT_INFO 2\n"); //yy
			pInfo2=(PORT_INFO_2 *)pNextStruct;
			pInfo2->pPortName=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pPortName),pPortWalk->szPortName);
			pszNextString+=(MAX_PORT_LEN);
			pInfo2->pDescription=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pDescription),pPortWalk->szPortDescription);
			pszNextString+=MAX_PORT_DESC_LEN;
			pInfo2->pMonitorName=pszNextString;
			wcscpy((WCHAR *)(pInfo2->pMonitorName),MONITOR_NAME);
			pszNextString+=(iStaticSize/2); //iStaticSize is bytes, pszNextString in WCHARs
			pInfo2->Reserved=0;
			pInfo2->fPortType=PORT_TYPE_WRITE; 
			wsprintfW((WCHAR *)szDebugBuff,L"pInfo2=0x%x\n",pInfo2);
			OutputDebugStringWD3((WCHAR *)szDebugBuff);
			wsprintfW((WCHAR *)szDebugBuff,L"USBMON in BuildBuff, PortName=%s|\n, Description=%s|\n, MonitorName=%s|\n",pInfo2->pPortName,pInfo2->pDescription,pInfo2->pMonitorName);
			OutputDebugStringWD3((WCHAR *)szDebugBuff);
			wsprintfW((WCHAR *)szDebugBuff,L"USBMON in BuildBuff, PortName=0x%x\n, Description=0x%x\n, MonitorName=0x%x\n",pInfo2->pPortName,pInfo2->pDescription,pInfo2->pMonitorName);
			OutputDebugStringWD3((WCHAR *)szDebugBuff); //yy
			
		} /*else level == 2*/
		((PBYTE)pNextStruct)+=iNodeSize;
		pPortWalk=pPortWalk->pNext;
	  } /*end while iLoop*/
	*pcReturned=iNumberOfPorts;
	return ERROR_SUCCESS;
BuildTableError:
	return lResult;
}	/*end function BuildReturnTable*/


void FreePrinterList(PUSBMON_PRINTER_INFO pPrinterList)
{
	PUSBMON_PRINTER_INFO pWalk,pNext;

	pWalk=pPrinterList;
	while(pWalk!=NULL)
	{
		pNext=pWalk->pNext;
		GlobalFree(pWalk);
		pWalk=pNext;
	}
} /*end function vFreePrinterList*/


int iCountPresentPrinters(PUSBMON_PORT_INFO pHead)
{
  int iReturn=0;
  PUSBMON_PORT_INFO pWalk;
  pWalk=pHead;
  OutputDebugStringD3("USBMON:   ************************************* Head of iCountPresentPrinters\n");
  while(pWalk!=NULL)
  {
		if((pWalk->dwDeviceFlags)&SPINT_ACTIVE)
  	  iReturn++;
	  pWalk=pWalk->pNext;
  }
  return iReturn;
} /*end function iCountPrinters*/
		 

/*******************************************************
 * FUNCTION: pGetPrintersAndPorts
 *   Uses SetupDi calls to obtain list of USB printers   
 *   present in the system, and reads the port name
 *   of the printer from the registry.  This function
 *   replaces pGetPrinterList, UpdateAssociations,
 *   AllocateNewPorts, DoBestEffortMatches, and 
 *   ReattachExactMatches
 *
 *   This function is called initially with a null pointer
 *   And is then called again on each EnumPorts
 * PARAMETERS:
 *   PUSBMON_PORT_INFO *ppHead
 *     Pointer to the head pointer of the list to by modified
 *     or Created
 * RETURN:
 *   status code
 ********************************************************/

LONG lGetPrintersAndPorts(PUSBMON_PORT_INFO *ppHead,PUSBMON_BASENAME *ppBaseNames)
{
    int iLoop;
	LONG lStatus;
	HDEVINFO hDeviceList;
	SP_DEVICE_INTERFACE_DATA rDeviceInfo;
	PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail;
		GUID *pPrinterGuid;
	BOOL bMoreDevices;
	DWORD dwRequiredSize;
	PUSBMON_PRINTER_INFO pPrinterList=NULL,pNew;
	HKEY hDeviceKey;
	DWORD dwError = ERROR_SUCCESS;
	

	OutputDebugStringD2("USBMON: Head of pGetPrinterAndPortList\n");
	pPrinterGuid=(GUID *)&USB_PRINTER_GUID;
    OutputDebugStringD3("USBMON: before SetupDiGetClassDevs\n");
	hDeviceList=SetupDiGetClassDevs(pPrinterGuid,NULL,NULL,DIGCF_INTERFACEDEVICE);
	OutputDebugStringD3("USBMON: after SetupDiGetClassDevs\n");
									

	if(hDeviceList==INVALID_HANDLE_VALUE)
	{
        dwError = GetLastError();
		OutputDebugStringD1("USBMON: SetupDiGetClassDevs failed\n");
		goto SetupDiPrinterAndPortError;
	}
	else
	{	
		iLoop=0;
		rDeviceInfo.cbSize=sizeof(rDeviceInfo);
		bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,iLoop,&rDeviceInfo);
		wsprintfA(szDebugBuff,"USBMON: SetupDiEnumDeviceInterfaces, data.flags=%u\n",rDeviceInfo.Flags);
	    OutputDebugStringD3(szDebugBuff);
		while(bMoreDevices)
		{
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,NULL,0,&dwRequiredSize,NULL))
		  {
			  dwError=GetLastError();
			  wsprintfA(szDebugBuff,"USBMON: SetupDiGetDeviceInterfaceDetail first call failed, error=%x\n",dwError);
			  OutputDebugStringD3(szDebugBuff);
//			  goto SetupDiPrinterAndPortError;  //the first call is just to get this size, so of course it should fail.  Don't goto anywhere
		  }
	 	  pDeviceDetail=(PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(0,dwRequiredSize);
		  if(pDeviceDetail==NULL)
		  {
		      OutputDebugStringD1("USBMON: Unable to allocate memory in pGetPrinterList\n");
			  SetupDiDestroyDeviceInfoList(hDeviceList);
              dwError = ERROR_NOT_ENOUGH_MEMORY;
			  goto SetupDiPrinterAndPortError;
		  }
		  pDeviceDetail->cbSize=sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,pDeviceDetail,dwRequiredSize,&dwRequiredSize,NULL))
		  {
              dwError = GetLastError();
			  OutputDebugStringD1("USBMON: SetupDiGetDeviceInterfaceDetail (second call) failed\n");
			  SetupDiDestroyDeviceInfoList(hDeviceList);
			  goto SetupDiPrinterAndPortError;
		  }
		  else
			  OutputDebugStringD3("USBMON: SetupDiGetDeviceInterfaceDetail (second call) OK\n");

		  lStatus=lAddPrinterToList(ppHead,hDeviceList,&rDeviceInfo,pDeviceDetail,ppBaseNames);
		  GlobalFree(pDeviceDetail);
		  OutputDebugStringD3("USBMON: Before end of loop SetupDiEnumDeviceInterfaces\n"); //yy
		  bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,++iLoop,&rDeviceInfo);
  		  wsprintfA(szDebugBuff,"USBMON: SetupDiEnumDeviceInterfaces, data.flags=%u\n",rDeviceInfo.Flags);
	      OutputDebugStringD3(szDebugBuff);

		} /*end while more devices*/
	   SetupDiDestroyDeviceInfoList(hDeviceList);
	   return STATUS_SUCCESS;
	} /*end else*/
SetupDiPrinterAndPortError:;
    if ( dwError == ERROR_SUCCESS )
        dwError = ERROR_INVALID_DATA;
	    OutputDebugStringD1("USBMON: Erroring out of pGetPrinterList\n");
		return dwError;
} /*end function lGetPrintersAndPorts*/


long lAddPrinterToList(PUSBMON_PORT_INFO *ppHead,HDEVINFO hDeviceList,SP_DEVICE_INTERFACE_DATA * prDeviceInfo,PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,PUSBMON_BASENAME *ppBaseNames)
{
  PUSBMON_PORT_INFO pWalk,pTemp,pNew = NULL;
  BOOL bFound=FALSE;
  HANDLE hDeviceKey = INVALID_HANDLE_VALUE;
  DWORD dwPortNumberSize;
  WCHAR wcPortName[MAX_PORT_LEN+1];
  WCHAR wcPortBaseName[MAX_PORT_LEN]; //arbitrary size, bigger than it needs to be
  DWORD dwPortNumber,dwStringSize;
  DWORD dwReturn = ERROR_SUCCESS;
  int iResult;

  pWalk=*ppHead;
  while((pWalk!=NULL)&&(!bFound))
  {
	if(lstrcmp(pWalk->DevicePath,pDeviceDetail->DevicePath)==0)
	  bFound=TRUE;
	else
	  pWalk=pWalk->pNext;
  }
  
  if(pWalk!=NULL) //it's not a new node
	{
	    if((!((pWalk->dwDeviceFlags)&SPINT_ACTIVE))  && ((prDeviceInfo->Flags)&SPINT_ACTIVE)) //If we just became active
		{
	      hDeviceKey=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,prDeviceInfo,0,KEY_ALL_ACCESS);
	      if(hDeviceKey==INVALID_HANDLE_VALUE)
		  {
	        OutputDebugStringD1("USBMON: reactivation: SetupDiOpenDeviceInterfaceRegKey failed\n");
	        return ERROR_ACCESS_DENIED;
		  }
		  RegDeleteValue(hDeviceKey,L"recyclable");
          dwStringSize = sizeof(pWalk->szPortDescription);
    	  if(RegQueryValueEx(hDeviceKey,L"Port Description",0,NULL,(LPBYTE)(pWalk->szPortDescription),&dwStringSize)!=ERROR_SUCCESS)
		  {
		    OutputDebugStringD2("USBMON: RegQueryValueEx, get \"Port Description\" in lAddPrinterToList (refresh) failed, defaulting to \"Virtual printer port for USB\"\n");
            wcscpy(pWalk->szPortDescription,L"Virtual printer port for USB");
		  }
		  
 	      RegCloseKey(hDeviceKey);
          hDeviceKey=INVALID_HANDLE_VALUE;
		}	 /*end if re-activated port*/
		pWalk->dwDeviceFlags=prDeviceInfo->Flags; //even if we don't need to reload the whole device detail, we need to recheck the flags
  	}
	else
	{
	  pNew=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
	  if(pNew==NULL)
	    return ERROR_NOT_ENOUGH_MEMORY;
      wcscpy(pNew->DevicePath,pDeviceDetail->DevicePath);
	  pNew->iRefCount=0;
	  hDeviceKey=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,prDeviceInfo,0,KEY_ALL_ACCESS);
	  if(hDeviceKey==INVALID_HANDLE_VALUE)
	  {
        dwReturn = GetLastError();
	    OutputDebugStringD1("USBMON: SetupDiOpenDeviceInterfaceRegKey failed\n");
        goto Done;
	  }
	  dwPortNumberSize=sizeof(dwPortNumber);
      dwReturn = RegQueryValueEx(hDeviceKey,L"Port Number",0,NULL,(LPBYTE)&dwPortNumber, &dwPortNumberSize);
      if ( dwReturn != ERROR_SUCCESS )
	  {
	    OutputDebugStringD2("USBMON: RegQueryValueEx get \"Port Number\" in lAddPrinterToList failed\n");
        goto Done;
	  }
	  dwStringSize=sizeof(wcPortBaseName);
	  if(RegQueryValueEx(hDeviceKey,L"Base Name",0,NULL,(LPBYTE)wcPortBaseName,&dwStringSize)!=ERROR_SUCCESS)
	  {
		OutputDebugStringD2("USBMON: RegQueryValueEx, get \"Base Name\" in lAddPrinterToList failed, defaulting to USB\n");
        wcscpy(wcPortBaseName,L"USB");
	  }
	  vAddNameToBaseNameList(ppBaseNames,wcPortBaseName);
	  dwStringSize=sizeof(pNew->szPortDescription);
  	  dwReturn=RegQueryValueEx(hDeviceKey,L"Port Description",0,NULL,(LPBYTE)(pNew->szPortDescription),&dwStringSize);
	
	  if(dwReturn!=ERROR_SUCCESS)
	  {
	 	wsprintfA(szDebugBuff,"USBMON:  RegQueryValueEx returned (signed) %d, (unsigned) %u\n",dwReturn,dwReturn);
	    OutputDebugStringD2(szDebugBuff);						 

		OutputDebugStringD2("USBMON: *************************************************RegQueryValueEx, get \"Port Description\" in lAddPrinterToList failed, defaulting to \"Virtual printer port for USB\"\n");
        wcscpy(pNew->szPortDescription,L"Virtual printer port for USB");

	  }
	  else
	  {
		  OutputDebugStringD2("USBMON: *****************************************RegQueryValueEx on baseName OK\n");
	  }
	
	  wsprintf(wcPortName,L"%s%03u",wcPortBaseName,dwPortNumber);
	  OutputDebugStringD3("USBMON: computed port name ==");
	  OutputDebugStringWD3(wcPortName);
	  wcscpy(pNew->szPortName,wcPortName);
	  pNew->dwDeviceFlags=prDeviceInfo->Flags;
	  if((pNew->dwDeviceFlags)&SPINT_ACTIVE)
		  RegDeleteValue(hDeviceKey,L"recyclable");


	  OutputDebugStringD3("USBMON: AddPrinterToList Start of insertion\n");
	  pWalk=*ppHead;
	  if(pWalk==NULL)
		{
	    *ppHead=pNew;
	    pNew->pNext=NULL;
        pNew = NULL;
		}
	  else if(lstrcmp(pNew->szPortName,pWalk->szPortName)<0)
	  {
	    OutputDebugStringD3("USBMON: AddPrinterToList New Head\n");
	    pNew->pNext=*ppHead;
	    (*ppHead)=pNew;
        pNew = NULL;
	  }
	  else if(lstrcmp(pNew->szPortName,pWalk->szPortName)==0)
	  {
		  pNew->pNext=(*ppHead)->pNext;
		  (*ppHead)=pNew;
 		  GlobalFree(pWalk);
          pNew = NULL;
	  }
	  else
	  {
	    if(pWalk->pNext!=NULL)
		{
	      iResult=lstrcmp(pNew->szPortName,pWalk->pNext->szPortName);
		}
	    while((iResult>0)&&(pWalk->pNext!=NULL))
		{	
		    pWalk=pWalk->pNext;
		    if(pWalk->pNext!=NULL)
			{
		      iResult=lstrcmp(pNew->szPortName,pWalk->pNext->szPortName);
			}
		} /*end while*/
		if(pWalk->pNext!=NULL)
			if(iResult==0) //they match
			{
				pTemp=pWalk->pNext;
				pWalk->pNext=pWalk->pNext->pNext;
				GlobalFree(pTemp);

			}
	    pNew->pNext=pWalk->pNext;
	    pWalk->pNext=pNew;
        pNew = NULL;
	} /*end else*/
  } /*end else pWalk==NULL, therefore it's a new node*/

  dwReturn = ERROR_SUCCESS;
Done:
    if ( pNew )
        GlobalFree(pNew);

    if ( hDeviceKey != INVALID_HANDLE_VALUE )
	  RegCloseKey(hDeviceKey);
  return dwReturn;
} /*end function lAddPrinterToList*/


void vAddNameToBaseNameList(PUSBMON_BASENAME *ppBaseNames,WCHAR *wcPortBaseName)
{
	BOOL bFound;
	PUSBMON_BASENAME pWalk,pNew;

	pWalk=*ppBaseNames;
	bFound=FALSE;
	while((pWalk!=NULL)&&(!bFound))
	{
		if(wcscmp(pWalk->wcBaseName,wcPortBaseName)==0)
			bFound=TRUE;
    	pWalk=pWalk->pNext;	
	} /*end while more items*/
	if(!bFound)
	{
		pWalk=*ppBaseNames;
		pNew=GlobalAlloc(0,sizeof(USBMON_BASENAME));
		if(pNew==NULL)
			return;
		wcscpy(pNew->wcBaseName,wcPortBaseName);
		if(*ppBaseNames==NULL)
		{
			*ppBaseNames=pNew;
			pNew->pNext=NULL;
		}
		else if(wcscmp(pNew->wcBaseName,pWalk->wcBaseName)<0)
		{
			pNew->pNext=*ppBaseNames;
			*ppBaseNames=pNew;
		}
		else
		{
		  while((!bFound)&&(pWalk->pNext!=NULL))
		  {
			if(wcscmp(pNew->wcBaseName,pWalk->pNext->wcBaseName)>0)
				bFound=TRUE;
			else
				pWalk=pWalk->pNext;
		  }
		  pNew->pNext=pWalk->pNext;
		  pWalk->pNext=pNew;
		} /*end else we need to insert it (not new head)*/
	} /*end if need to add*/
}	 /*end function vAddNameToBaseNameList*/



char *WtoA(WCHAR *pInString)
{
	static char szDest[256];
	char *pSourceWalk;
	char *pszDestWalk;

	pszDestWalk=szDest;
	pSourceWalk=(char *)pInString;
	while(*pSourceWalk!='\0')
	{
		*(pszDestWalk++)=*pSourceWalk;
		pSourceWalk+=2;
	}
	(*pszDestWalk)='\0';
	wsprintfA(szDebugBuff,"USBMON, WtoA, About to return %s\n",szDest);
	OutputDebugStringD3(szDebugBuff); //yy
	return szDest;
}

 
void vCleanUpQueuesAndPorts(PUSBMON_PORT_INFO * ppPortInfo,int iNumberOfPorts,PUSBMON_BASENAME pBaseNames)
{		
	DWORD dwThreadID;
	PCLEANUP_THREAD_PARAMS pCleanupParams;

	pCleanupParams=(PCLEANUP_THREAD_PARAMS)GlobalAlloc(0,sizeof(CLEANUP_THREAD_PARAMS));
	if(pCleanupParams==NULL)
	{
			OutputDebugStringD1("USBMON: failed to allocate memory in vCleanupQueuesAndPorts\n");
    	return;
	}
	pCleanupParams->ppPortInfo=ppPortInfo;
	pCleanupParams->iPortCount=iNumberOfPorts;
	pCleanupParams->hSemaphore=hMonitorSemaphore;
	pCleanupParams->pBaseNames=pBaseNames;
	CreateThread(NULL,0,CleanupThread,pCleanupParams,0,&dwThreadID);
}

DWORD WINAPI CleanupThread(LPVOID pParam)
{
	PCLEANUP_THREAD_PARAMS pParams;
	PUSBMON_QUEUE_INFO pQueueList;
	DWORD dwStatus;
		
	pParams=(PCLEANUP_THREAD_PARAMS)pParam;
	pQueueList=NULL;
	lGetQueues(&pQueueList,pParams->pBaseNames);
	if(pQueueList==NULL)
	{
	  OutputDebugStringD3("USBMON:  CleanupThread, pQueueList==NULL\n");
	}
	else
	{
	  OutputDebugStringD3("USBMON:  CleanupThread, pQueueList!=NULL\n");
	}
	wsprintfA(szDebugBuff,"USBMON:+++++++++++++++++++++++++++++++++++++++ Head of CleanupThread, before WaitForSingleObject, hMonitorSemaphore=%x\n",hMonitorSemaphore);
	OutputDebugStringD2(szDebugBuff);
	dwStatus=WaitForSingleObject(hMonitorSemaphore,INFINITE);
	if(dwStatus==WAIT_FAILED)
	  OutputDebugStringD1("USBMON: WaitForSingleObject failed!\n");
	wsprintfA(szDebugBuff,"USBMON: CleanupThread: WaitForSingleObject returned %d\n",dwStatus);
	OutputDebugStringD3(szDebugBuff);
	OutputDebugStringD2("USBMON: Head of CleanupThread, after WaitForSingleObject\n");
	vEliminateOldQueuesAndPorts(pQueueList,pParams->ppPortInfo);
	vDestroyQueueList(pQueueList);
	GlobalFree(pParams);
  OutputDebugStringD2("USBMON: tail of CleanupThread, about to release semaphore++++++++++++++++++++++++++++++++++++++++++++\n");
	iCleanupThreads--;
	ReleaseSemaphore(hMonitorSemaphore,1,NULL);
	return 0;
}

void vEliminateOldQueuesAndPorts(PUSBMON_QUEUE_INFO pQueueInfo,PUSBMON_PORT_INFO * ppPortHead)
{
	PUSBMON_QUEUE_INFO pQueueWalk;
	PUSBMON_PORT_INFO pPortWalk;
    HDEVINFO            hDevInfo;
	int iCompare;
	BOOL bNull=FALSE;

	hDevInfo=SetupDiGetClassDevs((GUID *)&USB_PRINTER_GUID,NULL,NULL,DIGCF_INTERFACEDEVICE);
    if ( hDevInfo == INVALID_HANDLE_VALUE )
        return;

	pQueueWalk=pQueueInfo;
	pPortWalk= *ppPortHead;
	pPortWalk=*ppPortHead;
	if((pPortWalk!=NULL)&&(pQueueWalk!=NULL))
	{
	  iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
	  wsprintf((WCHAR *)szDebugBuff,L"USBMON:  About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
	  OutputDebugStringWD2((WCHAR *)szDebugBuff);
	}
	else
	  bNull=TRUE;
	while(!bNull)
	{
		//Walk through matching items loop
		while((iCompare==0)&&(!bNull))
		{
  		wsprintfA(szDebugBuff,"USBMON: in cleanup loop, flags=%d\n",pPortWalk->dwDeviceFlags);	
		  OutputDebugStringD2(szDebugBuff);

			if((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE)
			  vUnGreyQueue(pQueueWalk);
			else
				vGreyOutQueue(pQueueWalk);
			pPortWalk=pPortWalk->pNext;
			pQueueWalk=pQueueWalk->pNext;
			if((pPortWalk!=NULL)&&(pQueueWalk!=NULL))
			{
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			} /*end if no nulls*/
			else
				bNull=TRUE;
		} /*end while matching items*/

		// grey out "detached" printers loop
		while((iCompare>0)&&(!bNull))
		{
			
			OutputDebugStringD3("USBMON: About to grey out queue inside the \"grey queue\" inner loop\n");
			//vGreyOutQueue(pQueueWalk);  //perhaps something else should happen here.  What does it mean if a port is gone but the queue is still around?
		
			pQueueWalk=pQueueWalk->pNext;
			if(pQueueWalk!=NULL)
			{
				wsprintf((WCHAR *)szDebugBuff,L"USBMON: About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
            	OutputDebugStringWD2((WCHAR *)szDebugBuff);
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			}
			else
				bNull=TRUE;
		} /*end grey out loop*/

		// delete orphaned port names loop
		while((iCompare<0)&&(!bNull))
		{
			if(!((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE))
			  vDeletePort(pPortWalk, hDevInfo);
			pPortWalk=pPortWalk->pNext;
			if(pPortWalk!=NULL)
			{
				wsprintf((WCHAR *)szDebugBuff,L"USBMON: About to compare %s and %s\n",pPortWalk->szPortName,pQueueWalk->wcPortName);
            	OutputDebugStringWD2((WCHAR *)szDebugBuff);
				iCompare=lstrcmp(pPortWalk->szPortName,pQueueWalk->wcPortName);
			}
			else
				bNull=TRUE;
		} /*end delete ports loop*/
	} /*end while both lists not null (outer loop)*/

	//grey out "detached" printers at end of list loop
	while(pQueueWalk!=NULL)
	{
		OutputDebugStringD2("USBMON:  About to grey out queue inside the \"grey queue\" cleanup loop\n");
		vGreyOutQueue(pQueueWalk); //perhaps something else should happen here.  What does it mean if a port is gone but the queue is still around?
		pQueueWalk=pQueueWalk->pNext;
	} //end end of list disable queues list

	//delete orphaned ports names at end of list loop
	while(pPortWalk!=NULL)
	{
		if(!((pPortWalk->dwDeviceFlags)&SPINT_ACTIVE))
  		  vDeletePort(pPortWalk, hDevInfo);
		pPortWalk=pPortWalk->pNext;
	} //end end of list delete ports loop

    SetupDiDestroyDeviceInfoList(hDevInfo);
} /*end function vEliminateOldQueuesAndPorts*/

 
void vGreyOutQueue(PUSBMON_QUEUE_INFO pQueue)
{
#define SET_PRINTER_BUFFER_SIZE 1024
	HANDLE hPrinterHandle;
	PRINTER_DEFAULTS rPrinterDefaults;
	BYTE bPrinterInfo[SET_PRINTER_BUFFER_SIZE];
	int iSizeNeeded;
	PRINTER_INFO_5 *pPrinterInfo;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GreyOut Queue %s attached to %s\n",pQueue->wcPrinterName,pQueue->wcPortName);
	OutputDebugStringWD2((WCHAR *)szDebugBuff);

	rPrinterDefaults.pDatatype=NULL;
	rPrinterDefaults.pDevMode=NULL;
	rPrinterDefaults.DesiredAccess=PRINTER_ACCESS_ADMINISTER|STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL;
	if(!OpenPrinter(pQueue->wcPrinterName,&hPrinterHandle,&rPrinterDefaults))
		OutputDebugStringD1("USBMON: Unable to OpenPrinter in vGreyOutQueue\n");
	if(!GetPrinter(hPrinterHandle,5,bPrinterInfo,SET_PRINTER_BUFFER_SIZE,&iSizeNeeded))
	{
		wsprintfA(szDebugBuff,"USBMON:  GetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	if(iSizeNeeded>SET_PRINTER_BUFFER_SIZE)
		OutputDebugStringD1("USBMON:  Buffer size not big enough in vGreyOutQueue\n");	
	pPrinterInfo=(PRINTER_INFO_5 *)bPrinterInfo;
	(pPrinterInfo->Attributes)|=PRINTER_ATTRIBUTE_WORK_OFFLINE;
	OutputDebugStringD2("USBMON:  about to SetPrinter\n");	
	if(!SetPrinter(hPrinterHandle,5,bPrinterInfo,0))
	{
		wsprintfA(szDebugBuff,"USBMON:  SetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	ClosePrinter(hPrinterHandle);

} /*end function vGreyOutQueue*/

void vUnGreyQueue(PUSBMON_QUEUE_INFO pQueue)
{
	HANDLE hPrinterHandle;
	PRINTER_DEFAULTS rPrinterDefaults;
	BYTE bPrinterInfo[SET_PRINTER_BUFFER_SIZE];
	int iSizeNeeded;
	PRINTER_INFO_5 *pPrinterInfo;

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UnGrey Queue %s attached to %s\n",pQueue->wcPrinterName,pQueue->wcPortName);
	OutputDebugStringWD3((WCHAR *)szDebugBuff);

	rPrinterDefaults.pDatatype=NULL;
	rPrinterDefaults.pDevMode=NULL;
	rPrinterDefaults.DesiredAccess=PRINTER_ACCESS_ADMINISTER|STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL;
	if(!OpenPrinter(pQueue->wcPrinterName,&hPrinterHandle,&rPrinterDefaults))
		OutputDebugStringD1("USBMON:  Unable to OpenPrinter in vGreyOutQueue\n");
	if(!GetPrinter(hPrinterHandle,5,bPrinterInfo,SET_PRINTER_BUFFER_SIZE,&iSizeNeeded))
	{
		wsprintfA(szDebugBuff,"USBMON:  GetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	if(iSizeNeeded>SET_PRINTER_BUFFER_SIZE)
		OutputDebugStringD1("USBMON:  Buffer size not big enough in vUnGreyQueue\n");	
	pPrinterInfo=(PRINTER_INFO_5 *)bPrinterInfo;
	(pPrinterInfo->Attributes)&=(~PRINTER_ATTRIBUTE_WORK_OFFLINE);
	OutputDebugStringD3("USBMON:  about to SetPrinter\n");	
	if(!SetPrinter(hPrinterHandle,5,bPrinterInfo,0))
	{
		wsprintfA(szDebugBuff,"USBMON:  SetPrinter failed, error code==%d\n",GetLastError());	
		OutputDebugStringD1(szDebugBuff);
	}

	ClosePrinter(hPrinterHandle);



} /*end function vUnGreyQueue*/

/*******************************************
 * vDletePort -- marks a port struct as    *
 * Deleted by setting it's device name to  *
 * Null and deleting the port name value   *
 * from the registry                       *
 *******************************************/
void vDeletePort(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList)
{
	HANDLE hDeviceKey;

//	 DebugBreak();

	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: /********************Head of vDeletePort for %s.\n",pPort->szPortName);	
	OutputDebugStringWD2((WCHAR *)szDebugBuff);
	

	hDeviceKey=hGetPortRegKey(pPort, hDeviceList);
	if(hDeviceKey!=INVALID_HANDLE_VALUE)
	{
		wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Opened key for port %s.\n",pPort->szPortName);	
		OutputDebugStringWD3((WCHAR *)szDebugBuff);
//		if(RegDeleteValue(hDeviceKey,L"Port Number")==ERROR_SUCCESS)
        if(RegSetValueEx(hDeviceKey,L"recyclable",0,REG_NONE,0,0)==ERROR_SUCCESS)
		{
		  OutputDebugStringD3("USBMON: RegSetValue Success\n");
		}
		else
		{
		  OutputDebugStringD2("USBMON: RegSetValue Failure\n");
		}
	    RegCloseKey(hDeviceKey);
	} /*end if hGetProtRegKey worked*/
	else
	{
		wsprintfW((WCHAR *)szDebugBuff,L"USBMON:  Unable to locate and delete reg key for %s\n",pPort->szPortName);	
		OutputDebugStringWD1((WCHAR *)szDebugBuff);
	}
} /*end function vDeletePort*/


BOOL
MatchingRegKey(
    HKEY                hKey,
    PUSBMON_PORT_INFO   pPort
    )
{
    WCHAR wcBaseName[MAX_PORT_LEN];
	WCHAR wcPortName[MAX_PORT_LEN];
	DWORD dwPortNumber;
	DWORD dwReadSize;

    dwReadSize=sizeof(DWORD);
    if(RegQueryValueEx(hKey,L"Port Number",0,NULL,(LPBYTE)&dwPortNumber,&dwReadSize)==ERROR_SUCCESS)
    {
        dwReadSize=sizeof(wcBaseName);
		if(RegQueryValueEx(hKey,L"Base Name",0,NULL,(LPBYTE)wcBaseName,&dwReadSize)!=ERROR_SUCCESS)
		{
           OutputDebugStringD2("USBMON:  Unable to locate basename.  Defaulting to \"USB\"\n"); //yy
	wcscpy(wcBaseName,L"USB");
    }

    wsprintf(wcPortName,L"%s%03u",wcBaseName,dwPortNumber);
    return wcscmp(wcPortName,pPort->szPortName)==0;
    }

    return 0;
}


HANDLE hGetPortRegKey(PUSBMON_PORT_INFO pPort, HDEVINFO hDeviceList)
{
	GUID *pPrinterGuid;
	int iLoop=0;
	SP_DEVICE_INTERFACE_DATA rDeviceInfo;
	BOOL bMoreDevices,bFound=FALSE;
	DWORD dwRequiredSize;
	HANDLE hRegHandle;
	PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail;
	WCHAR wcBaseName[MAX_PORT_LEN];
	
    rDeviceInfo.cbSize=sizeof(rDeviceInfo);

    if ( !SetupDiOpenDeviceInterface(hDeviceList, pPort->DevicePath,
                                     DIODI_NO_ADD,  &rDeviceInfo) )
        return INVALID_HANDLE_VALUE;

    hRegHandle = SetupDiOpenDeviceInterfaceRegKey(hDeviceList,
                                                  &rDeviceInfo,
                                                  0,
                                                  KEY_ALL_ACCESS);
   
    if ( hRegHandle != INVALID_HANDLE_VALUE ) {

        if ( MatchingRegKey(hRegHandle, pPort) )
            return hRegHandle;

        CloseHandle(hRegHandle);
    }

	pPrinterGuid=(GUID *)&USB_PRINTER_GUID;
    bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,iLoop,&rDeviceInfo);
    while((bMoreDevices)&&(!bFound))
		{

		  SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,NULL,0,&dwRequiredSize,NULL);
	 	  pDeviceDetail=(PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(0,dwRequiredSize);
		  if(pDeviceDetail==NULL)
		  {
		      OutputDebugStringD1("USBMON: Unable to allocate memory in pGetPrinterList\n");
			  return INVALID_HANDLE_VALUE;
		  }
		  pDeviceDetail->cbSize=sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		  if(!SetupDiGetDeviceInterfaceDetail(hDeviceList,&rDeviceInfo,pDeviceDetail,dwRequiredSize,&dwRequiredSize,NULL))
		  {
			  OutputDebugStringD1("USBMON: SetupDiGetDeviceInterfaceDetail (second call) failed\n");
			  return INVALID_HANDLE_VALUE;
		  } /*end if SetupDiGetDeviceInterfaceDetail, call2 failed*/

		  hRegHandle=SetupDiOpenDeviceInterfaceRegKey(hDeviceList,&rDeviceInfo,0,KEY_ALL_ACCESS);
		  if(hRegHandle!=INVALID_HANDLE_VALUE)
		  {
                if ( MatchingRegKey(hRegHandle, pPort) )
					bFound=TRUE;
				else
					CloseHandle(hRegHandle);
		  }		 /*end if SetupDiOpenDeviceInterfaceRegKey successful*/
		  GlobalFree(pDeviceDetail);
		  bMoreDevices=SetupDiEnumDeviceInterfaces(hDeviceList,0,pPrinterGuid,++iLoop,&rDeviceInfo);
		} /*end while more devices & !found*/

	if(!bFound)
		hRegHandle=INVALID_HANDLE_VALUE;
	return hRegHandle;
} /*end function hGetPortRegKey*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\uimgr.h ===
/*****************************************************************************
 *
 * $Workfile: UIMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_UI_MANAGER_H
#define INC_UI_MANAGER_H

#define COREUI_VERSION 1
#define MAX_TITLE_LENGTH 256
#define MAX_SUBTITLE_LENGTH 256
const int MaxNumCfgPages = 1;
const int MaxNumAddPages = 5;

class CUIManager
{
public:
    CUIManager();
    ~CUIManager();

    DWORD AddPortUI(HWND hWndParent,
                            HANDLE hXcvPrinter,
                            TCHAR pszServer[],
                            TCHAR sztPortName[]);
    DWORD ConfigPortUI(HWND hWndParent,
                               PPORT_DATA_1 pData,
                               HANDLE hXcvPrinter, TCHAR szServerName[],
                               BOOL bNewPort = FALSE);

    VOID SetControlFont(HWND hwnd, INT nId) const;

protected:

private:

    VOID CreateWizardFont();
    VOID DestroyWizardFont();

    HFONT m_hBigBoldFont;

}; // CUIManager


typedef struct _CFG_PARAM_PACKAGE
{
    PPORT_DATA_1 pData;
    HANDLE hXcvPrinter;
    TCHAR pszServer[MAX_NETWORKNAME_LEN];
    BOOL bNewPort;
    DWORD dwLastError;
} CFG_PARAM_PACKAGE, *PCFG_PARAM_PACKAGE;

typedef struct _ADD_PARAM_PACKAGE
{
    PPORT_DATA_1 pData;
    CUIManager *UIManager;
    HANDLE hXcvPrinter;
    DWORD dwLastError;
    DWORD dwDeviceType;
    DWORD bMultiPort;
    BOOL  bBypassNetProbe;
    TCHAR pszServer[MAX_NETWORKNAME_LEN];
    TCHAR sztPortName[MAX_PORTNAME_LEN];
    TCHAR sztSectionName[MAX_SECTION_NAME];
    TCHAR sztPortDesc[MAX_PORT_DESCRIPTION_LEN + 1];
} ADD_PARAM_PACKAGE, *PADD_PARAM_PACKAGE;


#endif // INC_UI_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmonui\uimgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: UIMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMonUI/UIMgr.cpp $
 *
 * 9     9/23/97 3:56p Becky
 * Corrected small bug for NT 5.0
 *
 * 8     9/23/97 3:35p Becky
 * Split functionality into NT4UIMgr and NT5UIMgr files.  This main class
 * is only responsible, now, for making a decision on which of these
 * classes to create and call.
 *
 * 7     9/19/97 11:26a Becky
 * Added Wizard 97 flags and function parameters.
 *
 * 6     9/12/97 3:25p Becky
 * Added bNewPort to the params structure.
 *
 * 5     9/11/97 9:55a Becky
 * Added parameter to the ConfigPortUI call to let us know if the call is
 * for a new port or an existing one.
 *
 * 4     9/10/97 3:16p Becky
 * Split out Input Checking functionality into the class CInptChkr.
 *
 * 3     9/09/97 4:35p Becky
 * Updated to use the new Monitor UI data structure.
 *
 * 2     9/09/97 11:58a Becky
 * Added a UIManager field to the AddParamsPackage so the Add UI will know
 * how to call the Config UI (it's a member function of the UIManager).
 *
 * 1     8/19/97 3:46p Becky
 * Redesign of the Port Monitor UI.
 *
 *****************************************************************************/

 /*
  * Author: Becky Jacobsen
  */

#include "precomp.h"
#define _PRSHT_H_

#include "TCPMonUI.h"
#include "UIMgr.h"
#include "InptChkr.h"
#include "resource.h"
#include "NT5UIMgr.h"

// includes for ConfigPort
#include "CfgPort.h"
#include "CfgAll.h"

// includes for AddPort
#include "DevPort.h"
#include "AddWelcm.h"
#include "AddGetAd.h"
#include "AddMInfo.h"
#include "AddDone.h"

#undef _PRSHT_H_

//
//  FUNCTION: CUIManager
//
//  PURPOSE: Constructor
//
CUIManager::CUIManager() : m_hBigBoldFont(NULL)
{
    CreateWizardFont();
} // Constructor

//
//  FUNCTION: CUIManager
//
//  PURPOSE: Destructor
//
CUIManager::~CUIManager()
{
    DestroyWizardFont();
} // Destructor

//
//  FUNCTION: AddPortUI
//
//  PURPOSE: Main function called when the User Interface for adding a port is called.
//
DWORD CUIManager::AddPortUI(HWND hWndParent,
							HANDLE hXcvPrinter,
							TCHAR pszServer[],
							TCHAR sztPortName[])
{
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( GetVersionEx(&osVersionInfo) )			// get the OS version
	{
		if ( osVersionInfo.dwMajorVersion >= 5 )	// check if we are NT 5.0 & later
		{
			CNT5UIManager UI97;
			return UI97.AddPortUI(hWndParent, hXcvPrinter, pszServer, sztPortName);
		}
		else
		{
            return ERROR_NOT_SUPPORTED;
		}
	}

	return NO_ERROR;

} // AddPortUI


//
//  FUNCTION: ConfigPortUI
//
//  PURPOSE: Main function called when the User Interface for configuring a port is called.
//
DWORD CUIManager::ConfigPortUI(HWND hWndParent,
							   PPORT_DATA_1 pData,
							   HANDLE hXcvPrinter,
							   TCHAR *szServerName,
							   BOOL bNewPort)
{
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( GetVersionEx(&osVersionInfo) )			// get the OS version
	{
		if ( osVersionInfo.dwMajorVersion >= 5 )	// check if we are NT 5.0 & later
		{
			CNT5UIManager UI97;
			return UI97.ConfigPortUI(hWndParent, pData, hXcvPrinter, szServerName, bNewPort);
		}
		else
		{
            return ERROR_NOT_SUPPORTED;
		}
	}

	return NO_ERROR;

} // ConfigPortUI

//
//
//  FUNCTION: CreateWizardFont()
//
//  PURPOSE: Create the large bold font for the wizard 97 style.
//
//  COMMENTS:
//
VOID CUIManager::CreateWizardFont()
{
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
    // Create the Big Bold Font
    //
    BigBoldLogFont.lfWeight = FW_BOLD;

    INT FontSize;
    TCHAR szLargeFontName[MAX_PATH];
    TCHAR szLargeFontSize[MAX_PATH];

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    
    // NOTICE-DavePr@2002/05/27
    //  g_hInstance is linked to what?
    //

    if( LoadString( g_hInstance, IDS_LARGEFONTNAME, szLargeFontName, sizeof(szLargeFontName)/sizeof(szLargeFontName[0]) ) &&
        LoadString( g_hInstance, IDS_LARGEFONTSIZE, szLargeFontSize, sizeof(szLargeFontName)/sizeof(szLargeFontName[0]) ) )
    {
        lstrcpyn( BigBoldLogFont.lfFaceName, szLargeFontName, sizeof(BigBoldLogFont.lfFaceName)/sizeof(BigBoldLogFont.lfFaceName[0]) );

        FontSize = _tcstoul( szLargeFontSize, NULL, 10 );

    	HDC hdc = GetDC( NULL );

        if( hdc )
        {
            BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

            m_hBigBoldFont = CreateFontIndirect( &BigBoldLogFont );

            ReleaseDC( NULL, hdc);
        }
    }
} // CreateWizardFont

//
//
//  FUNCTION: DestroyWizardFont()
//
//  PURPOSE: Destroys the wizard font created with CreateWizardFont
//
//  COMMENTS:
//
VOID CUIManager::DestroyWizardFont()
{
    if(m_hBigBoldFont)
    {
        DeleteObject(m_hBigBoldFont);
    }
} // DestroyWizardFont

//
//
//  FUNCTION: SetControlFont(HWND hwnd, INT nId)
//
//  PURPOSE: Set font of the specified control
//
//  COMMENTS:
//
VOID CUIManager::SetControlFont(HWND hwnd, INT nId)  const
{
	if(m_hBigBoldFont)
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if(hwndControl)
        {
        	SetWindowFont(hwndControl, m_hBigBoldFont, TRUE);
        }
    }
} // SetControlFont
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\usbmon\usbmon.h ===
extern int iGMessageLevel;
extern int iTest1;
extern HANDLE hMonitorSemaphore;
extern HANDLE hReadWriteSemaphore;
extern int iTest2;


UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult);


#ifdef DBG

#define OutputDebugStringD(_x_) \
{\
  OutputDebugStringA("Old OutputDebugStringD\n");\
  OutputDebugStringA(_x_); \
}

#define OutputDebugStringD0(_x_) \
  OutputDebugStringA(_x_);

#define OutputDebugStringD1(_x_) \
{\
  if(iGMessageLevel>=1) \
    OutputDebugStringA(_x_); \
}

#define OutputDebugStringD2(_x_) \
{\
  if(iGMessageLevel>=2) \
    OutputDebugStringA(_x_);\
}

#define OutputDebugStringD3(_x_) \
{\
  if(iGMessageLevel>=3) \
    OutputDebugStringA(_x_);\
}

#define OutputDebugStringWD0(_x_) \
  OutputDebugStringW(_x_);

#define OutputDebugStringWD1(_x_) \
{\
  if(iGMessageLevel>=1) \
    OutputDebugStringW(_x_);\
}

#define OutputDebugStringWD2(_x_) \
{	 \
  if(iGMessageLevel>=2) \
    OutputDebugStringW(_x_);\
}

#define OutputDebugStringWD3(_x_) \
{		\
  if(iGMessageLevel>=3) \
    OutputDebugStringW(_x_);\
}


#define printfD wsprintf

#define OuptutDebigStringWD(_x_) \
{	 \
  OutputDebugStringW("Old OutputDebugStringWD\n");	\
  OutputDebugStringW(_x_); \
}

#else

#define OutputDebugStringWD0
#define OutputDebugStringWD1
#define OutputDebugStringWD2
#define OutputDebugStringWD3
#define OutputDebugStringD0
#define OutputDebugStringD
#define OutputDebugStringD1
#define OutputDebugStringD2
#define OutputDebugStringD3
#define printfD


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\usbmon\usbmonexp.h ===
LPMONITOREX WINAPI InitializePrintMonitor(LPWSTR pRegistryRoot);
LPMONITOREX WINAPI JobyInitializePrintMonitor(LPWSTR pRegistryRoot);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\usbmon\usbmon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>

#include <winbase.h>
#include "enumports.h"
#include "usbmon.h"


int iGMessageLevel;
PUSBMON_BASENAME GpBaseNameList;
HANDLE hMonitorSemaphore=NULL;
HANDLE hReadWriteSemaphore=NULL;

BOOL WINAPI USBMON_OpenPort(LPWSTR pName, PHANDLE pHandle);
BOOL WINAPI USBMON_StartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE  pDocInfo);
BOOL WINAPI USBMON_WritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten);
BOOL WINAPI USBMON_ReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer,LPDWORD pcbRead);
BOOL WINAPI USBMON_EndDocPort(HANDLE hPort);
BOOL WINAPI USBMON_ClosePort(HANDLE hPort);
BOOL WINAPI USBMON_SetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved);
BOOL WINAPI USBMON_XcvOpenPort(LPCWSTR pszObject, ACCESS_MASK GrantedAccess, PHANDLE phXcv);
DWORD WINAPI USBMON_XcvDataPort(HANDLE  hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded);
BOOL WINAPI USBMON_XcvClosePort(HANDLE  hXcv);
BOOL USBMON_GetPrinterDataFromPort(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned);
void vLoadBaseNames(HKEY hPortsKey,PUSBMON_BASENAME *ppHead);
void vInterlockedClosePort(PUSBMON_PORT_INFO pPortInfo);
void vInterlockedOpenPort(PUSBMON_PORT_INFO pPortInfo);
void vInterlockedReOpenPort(PUSBMON_PORT_INFO pPortInfo);
LPMONITOREX WINAPI JobyInitializePrintMonitor(LPWSTR pRegistryRoot);
VOID CALLBACK ReadWriteCallback(DWORD dwErrorCode,DWORD dwNumberOfBytesTranfsered,LPOVERLAPPED lpOverlapped);

int iGetMessageLevel();

typedef struct OverlappedResults_def
{
    DWORD dwErrorCode;
    DWORD dwBytesTransfered;
} OverlappedResults,*pOverlappedResults;



BOOL APIENTRY DllMain(HANDLE hModule, 
		      DWORD  ul_reason_for_call, 
		      LPVOID lpReserved)
{

	return TRUE;
}; /*end function DllMain*/




int iGetMessageLevel()
{
  HKEY hRegKey;
  int iReturn=1; //default value is 1; "errors only"
  DWORD dwValue,dwSize;

  dwSize=sizeof(dwValue);
  if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"SOFTWARE\\Microsoft\\USBPRINT",0,KEY_QUERY_VALUE,&hRegKey)==ERROR_SUCCESS)
    if(RegQueryValueEx(hRegKey,L"MonitorMessageLevel",0,NULL,(LPBYTE)&dwValue,&dwSize)==ERROR_SUCCESS)  
      iReturn=(int)dwValue;
  return iReturn;
  

} /*end function iGetMessageLevel*/


LPMONITOREX WINAPI InitializePrintMonitor(LPWSTR pRegistryRoot)
{
	LPMONITOREX lpMonitorInfo=NULL;
	LONG lResult;
	HKEY hRootKey,hPortsKey;
	DWORD dwDisp;

  
	iGMessageLevel=iGetMessageLevel();
    OutputDebugStringD2("USBMON: Head of InitializePrintMonitor\n");

	hMonitorSemaphore=CreateSemaphore(NULL,1,1,NULL);
	if(hMonitorSemaphore==NULL)
	{
		OutputDebugStringD1("USBMON: Unable to initialize Monitor semaphore\n");
		return FALSE;
	}

	hReadWriteSemaphore=CreateSemaphore(NULL,1,1,NULL);
	if(hReadWriteSemaphore==NULL)
	{
		OutputDebugStringD1("USBMON: Unable to initialize ReadWrite semaphore\n");
		return FALSE;
	}



	OutputDebugStringD3("USBMON: Registry root: ");
	OutputDebugStringWD3(pRegistryRoot);
    OutputDebugStringD3("\n");

	pPortInfoG=NULL;
//	lResult=RegOpenKeyExW(HKEY_LOCAL_MACHINE,pRegistryRoot,0,KEY_ALL_ACCESS,&hRootKey);
	lResult=RegCreateKeyExW(HKEY_LOCAL_MACHINE,pRegistryRoot,0,NULL,0,KEY_ALL_ACCESS,NULL,&hRootKey,&dwDisp);
	if(lResult==ERROR_SUCCESS)
	{
		lResult=RegCreateKeyExW(hRootKey,L"PORTS",0,NULL,0,KEY_ALL_ACCESS,NULL,&hPortsKey,&dwDisp);
		RegCloseKey(hRootKey);
	}
	if(lResult==ERROR_SUCCESS)      
	{
	  OutputDebugStringD3("USBMON: hPortsKeyG is good\n");
	  hPortsKeyG=hPortsKey;
	  GpBaseNameList=NULL;
	  vLoadBaseNames(hPortsKey,&GpBaseNameList);
	  lpMonitorInfo=(LPMONITOREX)GlobalAlloc(0,sizeof(MONITOREX));
	  if(lpMonitorInfo!=NULL)
	  {
	    lpMonitorInfo->dwMonitorSize=sizeof(MONITOR);
	    lpMonitorInfo->Monitor.pfnEnumPorts=USBMON_EnumPorts;
	    lpMonitorInfo->Monitor.pfnOpenPort=USBMON_OpenPort;
	    lpMonitorInfo->Monitor.pfnOpenPortEx=NULL; //Not required for port monitors
	    lpMonitorInfo->Monitor.pfnStartDocPort=USBMON_StartDocPort;
	    lpMonitorInfo->Monitor.pfnWritePort=USBMON_WritePort;
	    lpMonitorInfo->Monitor.pfnReadPort=USBMON_ReadPort;
	    lpMonitorInfo->Monitor.pfnEndDocPort=USBMON_EndDocPort;
	    lpMonitorInfo->Monitor.pfnClosePort=USBMON_ClosePort;
	    lpMonitorInfo->Monitor.pfnAddPort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnAddPortEx=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnConfigurePort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnDeletePort=NULL; //Obsolete
	    lpMonitorInfo->Monitor.pfnGetPrinterDataFromPort=USBMON_GetPrinterDataFromPort;
	    lpMonitorInfo->Monitor.pfnSetPortTimeOuts=USBMON_SetPortTimeOuts;
    //	lpMonitorInfo->Monitor.pfnXcvOpenPort=USBMON_XcvOpenPort;
	    lpMonitorInfo->Monitor.pfnXcvOpenPort=NULL;
 //	    lpMonitorInfo->Monitor.pfnXcvDataPort=USBMON_XcvDataPort;
		lpMonitorInfo->Monitor.pfnXcvDataPort=NULL;
//	    lpMonitorInfo->Monitor.pfnXcvClosePort=USBMON_XcvClosePort;
		lpMonitorInfo->Monitor.pfnXcvClosePort=NULL;
	  }
	  else
	  {
	    OutputDebugStringD1("USBMON: Error, Out of memory\n");
	  }
	} /*end if reg keys OK*/
	else
	{
      OutputDebugStringD1("USBMON: Error, Unable to get reg keys!\n");
	}
	
	GpBaseNameList=NULL;
	return lpMonitorInfo; 
};



BOOL USBMON_GetPrinterDataFromPort(
    HANDLE hPort,
    DWORD ControlID,
    LPWSTR pValueName,
    LPWSTR lpInBuffer,
    DWORD cbInBuffer,
    LPWSTR lpOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbReturned)
{

	BOOL bStatus;
    PUSBMON_PORT_INFO pPortInfo;
	HANDLE hPrinter;


	if(ControlID==0)
	{
		OutputDebugStringD2("USBMON: GetPrinterDataFromPort Control ID==0, bailing.  requested value==");
		OutputDebugStringWD2(pValueName);
		OutputDebugStringD2("\n");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE; //need to set last error here.
	}


	pPortInfo=(PUSBMON_PORT_INFO)hPort;
	hPrinter=pPortInfo->hPrinter;

	OutputDebugStringD3("USBMON: Before DeviceIoControl\n");
	bStatus=DeviceIoControl(hPrinter,ControlID,lpInBuffer,cbInBuffer,lpOutBuffer,cbOutBuffer,lpcbReturned,NULL);
	if(!bStatus)
	{
		OutputDebugStringD2("USBMON:  USBMON_GetPrinterDataFromPort failing\n");
		SetLastError(ERROR_INVALID_PARAMETER);
		
	}
	else
	{
		OutputDebugStringD2("USBMON: USBMON_GetPrinterDataFromPort Success\n");
		SetLastError(ERROR_SUCCESS);
	}
	return bStatus;		
} /*end function USBMON_GetPrinterDataFromPort*/





BOOL WINAPI USBMON_OpenPort(LPWSTR pName, PHANDLE pHandle)
{
	PUSBMON_PORT_INFO pWalkPorts;
	BOOL bFound=FALSE;
	
	
	OutputDebugStringD2("USBMON: Head of USBMON_OpenPort\n");
	pWalkPorts=pPortInfoG;
	wsprintfW((WCHAR *)szDebugBuff,L"USBMON: OpenPort Looking for \"%s\"\n",pName);
	OutputDebugStringWD2((WCHAR *)szDebugBuff);
	while((bFound==FALSE)&&(pWalkPorts!=NULL))
	{
  	    wsprintfW((WCHAR *)szDebugBuff,L"USBMON: Looking at node \"%s\"\n",pWalkPorts->szPortName);
	    OutputDebugStringWD3((WCHAR *)szDebugBuff);

		if(lstrcmp(pName,pWalkPorts->szPortName)==0)
			bFound=TRUE;
		else
			pWalkPorts=pWalkPorts->pNext;
	}
	if(bFound)
	{

	    wsprintfW((WCHAR *)szDebugBuff,L"USBMON:  About to open path: \"%s\"\n",pWalkPorts->DevicePath);
	    OutputDebugStringD3(szDebugBuff);

//		pWalkPorts->hDeviceHandle=CreateFile(pWalkPorts->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
//		if(pWalkPorts->hDeviceHandle!=INVALID_HANDLE_VALUE)
//		{
		  *pHandle=(HANDLE)pWalkPorts;
          pWalkPorts->ReadTimeoutMultiplier=0;
          pWalkPorts-> ReadTimeoutConstant=60000;
          pWalkPorts->WriteTimeoutMultiplier=0;
          pWalkPorts->WriteTimeoutConstant=60000;

		  OutputDebugStringD3("USBMON: USBMON_OpenPort returning TRUE\n");
		  return TRUE;
//		}
	}
	*pHandle=INVALID_HANDLE_VALUE;
	wsprintfA(szDebugBuff,"USBMON: USBMON_OpenPort returning FALSE, error=%d\n",GetLastError());
	OutputDebugStringD1(szDebugBuff);
	return FALSE;
}

BOOL WINAPI USBMON_StartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE  pDocInfo)
{
	BOOL bResult;
	HANDLE hPrinter;
	PUSBMON_PORT_INFO pPortInfo;

	OutputDebugStringD2("USBMON: Head of StartDocPort\n");
	pPortInfo=(PUSBMON_PORT_INFO)hPort;
	bResult=OpenPrinterW(pPrinterName,&hPrinter,NULL);
	if(bResult==FALSE)
	{
		OutputDebugStringD1("USBMON: OpenPrinter failed\n");
		return FALSE;
	}
	else
	{
  	  pPortInfo->hPrinter=hPrinter;
	  pPortInfo->dwCurrentJob=JobId;
 //	 pWalkPorts->hDeviceHandle=CreateFile(pWalPorts->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
     wsprintfW((WCHAR *)szDebugBuff,L"USBMON:---------------------------------- About to open path: \"%s\"\n",pPortInfo->DevicePath);
	 OutputDebugStringD3(szDebugBuff);

//	  pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
	  vInterlockedOpenPort(pPortInfo);
 	  OutputDebugStringD3("USBMON: CreateFile in StartDocPort\n");
	  if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
	  {
        OutputDebugStringD1("USBMON: CreateFile on printer device object failed\n");
		return FALSE;
	  }
	  return TRUE;
	} /*end else bResult OK*/

}


BOOL WINAPI USBMON_ReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten)
{
    
    DWORD dwBytesToRead;
    PUSBMON_PORT_INFO pPortInfo;
    DWORD dwTimeout;
    OVERLAPPED rOverlappedInfo;
    BOOL bTimeOut=FALSE,bSuccess=TRUE;
    OverlappedResults Results;
    
    OutputDebugStringD3("USBMON: Head of ReadPort\n");
    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    
    dwBytesToRead=cbBuf;
    
    vInterlockedOpenPort(pPortInfo);
    if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
    {
        OutputDebugStringD1("USBMON: CreateFile on printer device object (inside ReadPort) failed\n");
        return FALSE;
    } /*end else CreateFile failed*/
    
    dwTimeout=(pPortInfo->ReadTimeoutMultiplier)*dwBytesToRead;
    dwTimeout+=pPortInfo->ReadTimeoutConstant;
    memset(&rOverlappedInfo,0,sizeof(rOverlappedInfo));
    rOverlappedInfo.hEvent=(HANDLE)&Results;
    
    if(ReadFileEx(pPortInfo->hDeviceHandle,pBuffer,dwBytesToRead,&rOverlappedInfo,ReadWriteCallback)==FALSE)
    {
        bSuccess=FALSE;
    }
    else
    {
      	wsprintfA(szDebugBuff,"USBMON: Sleep time=%d\n",dwTimeout);
	    OutputDebugStringD3(szDebugBuff);

        if(SleepEx(dwTimeout,TRUE)==0)
        {
            OutputDebugStringD1("USBMON:  SleepEx failed or timed out\n");
            CancelIo(pPortInfo->hDeviceHandle);
            bSuccess=FALSE;
            SetLastError(ERROR_TIMEOUT);
        }
        else
        {
            if(Results.dwErrorCode==0)
            {

                 wsprintfA(szDebugBuff,"USBMON:  bytes read=%u\n",*pcbWritten);
                OutputDebugStringD3(szDebugBuff);
                SetLastError(ERROR_SUCCESS);
                OutputDebugStringD3(szDebugBuff);
            }
            else
            {
                OutputDebugStringD1("USBMON:  callback reported error\n");
                SetLastError(Results.dwErrorCode);
                bSuccess=FALSE;
                
            } /*end else callback reported error*/
        }  /*end else did not time out*/
        *pcbWritten=Results.dwBytesTransfered;
    }  /*end able to start read*/
    
    if(!bSuccess)
    {
        OutputDebugStringD2("USBMON: Re-opening port\n");
        vInterlockedReOpenPort(pPortInfo);
    }

        vInterlockedClosePort(pPortInfo);
        return bSuccess;
} /*end function ReadPort*/



BOOL WINAPI USBMON_WritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf,LPDWORD pcbWritten)
{
    
    DWORD dwBytesToWrite;
    PUSBMON_PORT_INFO pPortInfo;
    DWORD dwTimeout;
    OVERLAPPED rOverlappedInfo;
    BOOL bTimeOut=FALSE,bSuccess=TRUE;
    OverlappedResults Results;
    
    OutputDebugStringD3("USBMON: Head of WritePort\n");
    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    
    if(cbBuf>MAX_WRITE_CHUNK)
        dwBytesToWrite=MAX_WRITE_CHUNK;
    else
        dwBytesToWrite=cbBuf;
    
    //	pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
    vInterlockedOpenPort(pPortInfo);
    if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
    {
        OutputDebugStringD1("USBMON: CreateFile on printer device object (inside WritePort) failed\n");
        return FALSE;
    } /*end else CreateFile failed*/
    
    dwTimeout=(pPortInfo->WriteTimeoutMultiplier)*dwBytesToWrite;
    dwTimeout+=pPortInfo->WriteTimeoutConstant;
    memset(&rOverlappedInfo,0,sizeof(rOverlappedInfo));
    rOverlappedInfo.hEvent=(HANDLE)&Results;

    //wsprintfA(szDebugBuff,"USBMON:/*dd About to WriteFileEx; pPortInfo->hDeviceHandle=%x, pBuffer=%x, dwBytesToWrite=%x\n",pPortInfo->hDeviceHandle,
      //  pBuffer,dwBytesToWrite);
	//OutputDebugStringD1(szDebugBuff);
    
    if(WriteFileEx(pPortInfo->hDeviceHandle,pBuffer,dwBytesToWrite,&rOverlappedInfo,ReadWriteCallback)==FALSE)
    {
        bSuccess=FALSE;
    }
    else
    {
      	wsprintfA(szDebugBuff,"USBMON:  Sleep time=%d\n",dwTimeout);
	    OutputDebugStringD2(szDebugBuff);

        if(SleepEx(dwTimeout,TRUE)==0)
        {
            OutputDebugStringD2("USBMON: SleepEx failed or timed out\n");
            CancelIo(pPortInfo->hDeviceHandle);
            bSuccess=FALSE;
            SetLastError(ERROR_TIMEOUT);
        }
        else
        {
            if(Results.dwErrorCode==0)
            {

                 wsprintfA(szDebugBuff,"USBMON:  bytes written=%u\n",*pcbWritten);
                OutputDebugStringD3(szDebugBuff);
                SetLastError(ERROR_SUCCESS);
                OutputDebugStringD3(szDebugBuff);
            }
            else
            {
                OutputDebugStringD3("USBMON:  callback reported error\n");
                SetLastError(Results.dwErrorCode);
                bSuccess=FALSE;
                
            } /*end else callback reported error*/
        }  /*end else did not time out*/
        *pcbWritten=Results.dwBytesTransfered;
    }  /*end able to start write*/
    
    if(!bSuccess)
    {
        OutputDebugStringD2("USBMON:  Re-opening port\n");
        vInterlockedReOpenPort(pPortInfo);
    }

        vInterlockedClosePort(pPortInfo);
        return bSuccess;
} /*end function WritePort*/

    




VOID CALLBACK ReadWriteCallback(DWORD dwErrorCode,DWORD dwNumberOfBytesTransfered,LPOVERLAPPED lpOverlapped)
{
    pOverlappedResults pResults;
   	OutputDebugStringD2("  USBMON:  ReadWriteCallback\n");
    pResults=(pOverlappedResults)(lpOverlapped->hEvent);
    pResults->dwErrorCode=dwErrorCode;
    pResults->dwBytesTransfered=dwNumberOfBytesTransfered;
} /*end function ReadWriteCallback*/


BOOL WINAPI USBMON_EndDocPort(HANDLE hPort)
{
	PUSBMON_PORT_INFO pPortInfo;

	OutputDebugStringD3("USBMON: Head of EndDocPort\n");

	pPortInfo=(PUSBMON_PORT_INFO)hPort;

	SetJob(pPortInfo->hPrinter,pPortInfo->dwCurrentJob,0,NULL,JOB_CONTROL_SENT_TO_PRINTER);
	ClosePrinter(pPortInfo->hPrinter);

	vInterlockedClosePort(pPortInfo);
    return TRUE;
}


BOOL WINAPI USBMON_ClosePort(HANDLE hPort)
{
	OutputDebugStringD3("USBMON:  Head of ClosePort\n");
//	CloseHandle( ((PUSBMON_PORT_INFO)hPort)->hDeviceHandle);
    return TRUE;
}

BOOL WINAPI USBMON_SetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved)
{
    PUSBMON_PORT_INFO pPortInfo;

   	OutputDebugStringD3("  USBMON: Head of SetPortTimeOuts\n");

    pPortInfo=(PUSBMON_PORT_INFO)hPort;
    wsprintfA(szDebugBuff,"USBMON:   SetPortTimeOut, ReadMultiplier=%u, ReadConstant=%u\n",
        lpCTO->ReadTotalTimeoutMultiplier,lpCTO->ReadTotalTimeoutConstant);
	OutputDebugStringD2(szDebugBuff);
    pPortInfo->ReadTimeoutMultiplier=lpCTO->ReadTotalTimeoutMultiplier;
    pPortInfo->ReadTimeoutConstant=lpCTO->ReadTotalTimeoutConstant;
    pPortInfo->WriteTimeoutMultiplier=lpCTO->WriteTotalTimeoutMultiplier;
    pPortInfo->WriteTimeoutConstant=lpCTO->WriteTotalTimeoutConstant;
    return TRUE;
}

BOOL WINAPI USBMON_XcvOpenPort(LPCWSTR pszObject, ACCESS_MASK GrantedAccess, PHANDLE phXcv)
{
	OutputDebugStringD2("USBMON: Head of XcvOpenPort\n");

    return FALSE;
}

DWORD WINAPI USBMON_XcvDataPort(HANDLE  hXcv, 
								LPCWSTR pszDataName, 
								PBYTE pInputData,
								DWORD cbInputData, 
								PBYTE pOutputData, 
								DWORD cbOutputData,
								PDWORD pcbOutputNeeded)
{
	OutputDebugStringD2("USBMON: Head of XcvDataPort\n");

    return ERROR_INVALID_FUNCTION;
}

BOOL WINAPI USBMON_XcvClosePort(HANDLE  hXcv)
{
	OutputDebugStringD2("USBMON: Head of XcvClosePort\n");

    return FALSE;
}
 
/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult)
{
    UINT r = 0;
    UINT Sign = 0;
    UCHAR c;
    UINT d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (UINT)(-(INT)r);
    *pResult = r;

    return 1;                       // Success!
}

void vLoadBaseNames(HKEY hRegKey, PUSBMON_BASENAME *ppHead)
{
	PUSBMON_BASENAME pNew,pWalk;
	WCHAR wcName[MAX_PORT_LEN];
	int iIndex=0;
	LONG lStatus;
	LONG lDataSize;
	int iCompare;
	
	*ppHead=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
	if(*ppHead==NULL)
		return;
	(*ppHead)->pNext=NULL;
	wcscpy((*ppHead)->wcBaseName,L"USB");
	
	lDataSize=MAX_PORT_LEN;
	lStatus=RegEnumValue(hRegKey,iIndex++,wcName,&lDataSize,NULL,NULL,NULL,NULL);
    while(lStatus==ERROR_SUCCESS)
	{
		pNew=GlobalAlloc(0,sizeof(USBMON_PORT_INFO));
		if(pNew==NULL)
			return;
		wcscpy(pNew->wcBaseName,wcName);
		if(wcscmp(pNew->wcBaseName,(*ppHead)->wcBaseName)<0)
		{
			pNew->pNext=*ppHead;
			*ppHead=pNew;
		} /*end if new first node*/
		else
		{
			pWalk=*ppHead;
			iCompare=-1;
			while((iCompare<0)&&(pWalk->pNext!=NULL))
			{
				iCompare=wcscmp(pNew->wcBaseName,pWalk->pNext->wcBaseName);
				if(iCompare<0)
					pWalk=pWalk->pNext;
			} /*end while walk*/
			if(iCompare>0)
			{
				pNew->pNext=pWalk->pNext;
				pWalk->pNext=pNew;
			}
			else if(iCompare==0)
			{
				GlobalFree(pNew);
			} /*end if collision*/
		} /*else not new first node*/
		lDataSize=MAX_PORT_LEN;
		lStatus=lStatus=RegEnumValue(hRegKey,iIndex++,wcName,&lDataSize,NULL,NULL,NULL,NULL);
	}	//end while more reg items
} //end function vLoadBaseNames



  

void vInterlockedOpenPort(PUSBMON_PORT_INFO pPortInfo)
{ 
	OutputDebugStringD2("USBMON: Head of vInterlockedOpenPort\n");

	WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
	if((pPortInfo->iRefCount==0)||(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE))
	{
        OutputDebugStringD3("USBMON: vInterlockedOpenPort, Really opening:");
        OutputDebugStringWD3(pPortInfo->DevicePath);
        OutputDebugStringD3("\n");
		pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_FLAG_OVERLAPPED,NULL);
	    if(pPortInfo->hDeviceHandle!=INVALID_HANDLE_VALUE)
		  (pPortInfo->iRefCount)++;
	}
	else
	{
        OutputDebugStringD3("USBMON:  vInterlockedOpenPort, Just incrementing ref count\n");
		(pPortInfo->iRefCount)++;
	}
	wsprintfA(szDebugBuff,"USBMON: vInterlockedOpenPort, iRefCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);

} /*end function vInterlockedOpenPort*/




void vInterlockedClosePort(PUSBMON_PORT_INFO pPortInfo)
{
	OutputDebugStringD2("USBMON: Head of vInterlockedClosePort\n");
	
    WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
	(pPortInfo->iRefCount)--;
	if(pPortInfo<0) {
        DebugBreak();
		pPortInfo=0;
    }
	if(pPortInfo->iRefCount==0)
	{
		CloseHandle(pPortInfo->hDeviceHandle);
		pPortInfo->hDeviceHandle=INVALID_HANDLE_VALUE;
	}
	wsprintfA(szDebugBuff,"USBMON:  vInterlockedClosePort, iRefCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);
} /*end function vInterlockedClosePort*/


void vInterlockedReOpenPort(PUSBMON_PORT_INFO pPortInfo)
{
	OutputDebugStringD2("USBMON: Head of vInterlockedReOpenPort\n");
	WaitForSingleObjectEx(hReadWriteSemaphore,INFINITE,FALSE);
    //
    // big problem. what if another thread is using the handle
    //
	CloseHandle(pPortInfo->hDeviceHandle);
    OutputDebugStringD3("USBMON: vInterlockedReOpenPort, Really opening----------------------------------------------:\n");
    OutputDebugStringWD3(pPortInfo->DevicePath);
    OutputDebugStringD3("\n");
    pPortInfo->hDeviceHandle=CreateFile(pPortInfo->DevicePath,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
	if(pPortInfo->hDeviceHandle==INVALID_HANDLE_VALUE)
//		--pPortInfo->iRefCount;
	wsprintfA(szDebugBuff,"USBMON: vInterlockedReOpenPort, iRefcCount=%d\n",pPortInfo->iRefCount);
	OutputDebugStringD2(szDebugBuff);
	ReleaseSemaphore(hReadWriteSemaphore,1,NULL);
} /*end function vInterlockedReOpenPort*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\asphelp.h ===
/*****************************************************************************\
* MODULE:       asphelp.h
*
* PURPOSE:      Declaration of the Casphelp
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*
\*****************************************************************************/

#ifndef __ASPHELP_H_
#define __ASPHELP_H_

#include <asptlb.h>         // Active Server Pages Definitions

#define LENGTHOFPAPERNAMES  64  // From DeviceCapabilities DC_PAPERNAMES
#define STANDARD_SNMP_MONITOR_NAME L"TCPMON.DLL"    // The dll name of the Universal SNMP monitor.
#define PAGEPERJOB  1
#define BYTEPERJOB  2

typedef struct ErrorMapping {
    DWORD   dwError;
    DWORD   dwErrorDscpID;
} ErrorMapping;

/////////////////////////////////////////////////////////////////////////////
// Casphelp
class ATL_NO_VTABLE Casphelp :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<Casphelp, &CLSID_asphelp>,
    public ISupportErrorInfoImpl<&IID_Iasphelp>,
    public IDispatchImpl<Iasphelp, &IID_Iasphelp, &LIBID_OLEPRNLib>
{
public:
    Casphelp();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ASPHELP)

BEGIN_COM_MAP(Casphelp)
    COM_INTERFACE_ENTRY(Iasphelp)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Iasphelp
public:
     ~Casphelp();

    // These properties do not require calling Open at first
    STDMETHOD(get_ErrorDscp)        (long lErrCode, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_MediaReady)       (/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_MibErrorDscp)     (DWORD dwError, /*[out, retval]*/ BSTR *pVal);

    STDMETHOD(Open)                 (BSTR bstrPrinterName);
    STDMETHOD(Close)();
	
    // Printer information
    STDMETHOD(get_AspPage)          (DWORD dwPage, /*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_Color)            (/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Community)        (/*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_ComputerName)     (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DriverName)       (/*[out, retval]*/ BSTR * pbstrVal);
    STDMETHOD(get_Duplex)           (/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_IPAddress)        (/*[out, retval]*/ BSTR *pbstrVal);
    STDMETHOD(get_IsHTTP)           (/*[out, retval]*/ BOOL *pbVal);
    STDMETHOD(get_IsTCPMonSupported)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_LongPaperName)    (BSTR bstrShortName, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_MaximumResolution)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PageRate)         (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PageRateUnit)     (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PaperNames)       (/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_PortName)         (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SNMPDevice)       (/*[out, retval]*/ DWORD *pdwVal);
    STDMETHOD(get_SNMPSupported)    (/*[out, retval]*/ BOOL *pbVal);
    STDMETHOD(get_Status)           (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_ShareName)        (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_IsCluster)        (/*[out, retval]*/ BOOL *pbVal);

    // Job completion time estimate
    STDMETHOD(CalcJobETA)           ();
    STDMETHOD(get_AvgJobSize)       (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_AvgJobSizeUnit)   (/*[out, retval]*/ long *pVal);
    STDMETHOD(get_JobCompletionMinute)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_PendingJobCount)  (/*[out, retval]*/ long *pVal);

    //Active Server Pages Methods
    STDMETHOD(OnStartPage)(IUnknown* IUnk);
    STDMETHOD(OnEndPage)();

private:

    void    Cleanup();
    BOOL    DecodeString (LPTSTR pPrinterName, LPTSTR pDecodedName, TCHAR chMark);
    BOOL    DecodeStringA (LPSTR pPrinterName, LPSTR pDecodedName, char chMark);
    DWORD   GetPPM();
    DWORD   GetWaitingMinutesPPM (DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob);

    HRESULT AllocGetPrinterInfo2(PPRINTER_INFO_2 *ppInfo2);
    HRESULT GetPaperAndMedia(VARIANT * pVal, WORD wDCFlag);
    HRESULT GetXcvDataBstr(LPCTSTR pszId, BSTR *bStr);
    HRESULT GetXcvDataDword (LPCTSTR pszId, DWORD *dwVal);
    HRESULT SetAspHelpScriptingError(DWORD dwError);

    // The following block is for ASP customization.
    BOOL    GetMonitorName( LPTSTR pMonitorName, DWORD cchBufSize );
    BOOL    GetModel( LPTSTR pModel, DWORD cchBufSize );
    BOOL    GetManufacturer( LPTSTR pManufacturer, DWORD cchBufSize );
    BOOL    IsCustomASP( BOOL bDeviceASP, LPTSTR pASPPage, DWORD cchBufSize );
    BOOL    IsSnmpSupportedASP( LPTSTR pASPPage, DWORD cchBufSize );
    BOOL    GetASPPageForUniversalMonitor( LPTSTR pASPPage, DWORD cchBufSize );
    BOOL    GetASPPageForOtherMonitors( LPTSTR pMonitorName, LPTSTR pASPPage, DWORD cchBufSize );
    BOOL    GetASPPage( LPTSTR pASPPage, DWORD cchBufSize );

    static  const DWORD         cdwBufSize      = 512;

    CComPtr<IRequest> m_piRequest;                  //Request Object
    CComPtr<IResponse> m_piResponse;                //Response Object
    CComPtr<ISessionObject> m_piSession;            //Session Object
    CComPtr<IServer> m_piServer;                    //Server Object
    CComPtr<IApplicationObject> m_piApplication;    //Application Object
    BOOL m_bOnStartPageCalled;                      //OnStartPage successful?
    TCHAR m_szComputerName[MAX_COMPUTERNAME_LENGTH+1];

    HANDLE  m_hPrinter;                              //Handle to the printer
    HANDLE  m_hXcvPrinter;
    DWORD   m_dwAvgJobSize;
    DWORD   m_dwAvgJobSizeUnit;
    DWORD   m_dwJobCompletionMinute;
    DWORD   m_dwPendingJobCount;
    DWORD   m_dwSizePerJob;
    BOOL    m_bCalcJobETA;
    BOOL    m_bTCPMonSupported;
    class CPrinter  *m_pPrinter;
    PPRINTER_INFO_2 m_pInfo2;
};

#endif //__ASPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\cpinst.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_InstallEvent
template <class T>
class CProxy_InstallEvents : public IConnectionPointImpl<T, &DIID__InstallEvent, CComDynamicUnkArray>
{
public:
//methods:
//_InstallEvent : IDispatch
public:
	void Fire_OnProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];

        if (pvars != NULL) {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= lProgress;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
	}
	void Fire_InstallError(
		long lErrCode)
	{
		VARIANTARG* pvars = new VARIANTARG[1];

        if (pvars != NULL) {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= lErrCode;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\asphelp.cpp ===
/*****************************************************************************\
* MODULE:       asphelp.cpp
*
* PURPOSE:      Implementation of the printer helper library
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*
\*****************************************************************************/

#include "stdafx.h"
#include <strsafe.h>
#include "gensph.h"

#include "oleprn.h"
#include "printer.h"
#include "asphelp.h"

Casphelp::Casphelp()
{
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    m_bOnStartPageCalled    = FALSE;
    m_bTCPMonSupported      = FALSE;
    m_hPrinter              = NULL;
    m_hXcvPrinter           = NULL;
    m_pInfo2                = NULL;
    m_bCalcJobETA           = FALSE;
    m_pPrinter              = NULL;

    if ( ! GetComputerName (m_szComputerName, &dwSize) )
        // Set the first char to '\0'.
        m_szComputerName[0] = 0;
}



/////////////////////////////////////////////////////////////////////////////
// Casphelp

STDMETHODIMP Casphelp::OnStartPage (IUnknown* pUnk)
{
    if ( !pUnk )
        return E_POINTER;

    CComPtr<IScriptingContext> spContext;
    HRESULT hr;

    // Get the IScriptingContext Interface
    hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
    if ( FAILED(hr) )
        return hr;

    // Get Request Object Pointer
    hr = spContext->get_Request(&m_piRequest);
    if ( FAILED(hr) ) {
        spContext.Release();
        return hr;
    }

    // Get Response Object Pointer
    hr = spContext->get_Response(&m_piResponse);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        return hr;
    }

    // Get Server Object Pointer
    hr = spContext->get_Server(&m_piServer);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        return hr;
    }

    // Get Session Object Pointer
    hr = spContext->get_Session(&m_piSession);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        m_piServer.Release();
        return hr;
    }

    // Get Application Object Pointer
    hr = spContext->get_Application(&m_piApplication);
    if ( FAILED(hr) ) {
        m_piRequest.Release();
        m_piResponse.Release();
        m_piServer.Release();
        m_piSession.Release();
        return hr;
    }
    m_bOnStartPageCalled = TRUE;
    return S_OK;
}

STDMETHODIMP Casphelp::OnEndPage ()
{
    m_bOnStartPageCalled = FALSE;
    // Release all interfaces
    m_piRequest.Release();
    m_piResponse.Release();
    m_piServer.Release();
    m_piSession.Release();
    m_piApplication.Release();

    return S_OK;
}


/*****************************************************************************\
* FUNCTION:         Open
*
* PURPOSE:          Open method, try to open a printer and get the printer info2
*
* ARGUMENTS:
*
*   pPrinterName:   Printer Name
*
* RETURN VALUE:
*   S_OK:           If succeed.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode are
*                   ERROR_INVALID_PRINTER_NAME:     Invalid printer name
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::Open(BSTR pPrinterName)
{
    static  const TCHAR cszPrefix[]   = TEXT(",XcvPort ");
    static  const TCHAR cszPattern[]  = TEXT("%s\\,XcvPort %s");

    LPTSTR      pszXcvPortName          = NULL;
    DWORD       dwXcvPortNameLength     = 0;
    TCHAR       szMonitorName[MAX_PATH] = TEXT("");
    BOOL        bRet                    = FALSE;

    if ( ! (m_pPrinter = new CPrinter) ) {
        SetLastError (ERROR_INVALID_PRINTER_NAME);
        goto CleanOut;
    }

    if ( ! (m_pPrinter->Open (pPrinterName, &m_hPrinter))) {
        goto CleanOut;
    }

    if ( ! (m_pInfo2 = m_pPrinter->GetPrinterInfo2 ()) ) {
        goto CleanOut;
    }

    // Open the XcvPrinter

    // Compose the openprinter string
    if ( m_pInfo2->pServerName && lstrcmp(m_pInfo2->pServerName, TEXT ("")) ) {
        // Alloc the memeory for open printer string with server name
        dwXcvPortNameLength = lstrlen(cszPattern) + lstrlen (m_pInfo2->pServerName) + lstrlen (m_pInfo2->pPortName) + 1;
        if ( ! (pszXcvPortName = (LPTSTR) LocalAlloc (LPTR, sizeof(TCHAR) * dwXcvPortNameLength)) ) {
            goto CleanOut;
        }

        // Construct the OpenPrinter String with the server name
        StringCchPrintf(pszXcvPortName, dwXcvPortNameLength, cszPattern, m_pInfo2->pServerName, m_pInfo2->pPortName);
    } else {
        // Alloc the memeory for open printer string without server name
        dwXcvPortNameLength = lstrlen(cszPrefix) + lstrlen (m_pInfo2->pPortName) + 1;
        if ( ! (pszXcvPortName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwXcvPortNameLength)) ) {
            goto CleanOut;
        }

        // Construct the OpenPrinter String with the server name
        StringCchCopy (pszXcvPortName, dwXcvPortNameLength, cszPrefix);
        StringCchCat (pszXcvPortName, dwXcvPortNameLength, m_pInfo2->pPortName);
    }

    // Now the openprinter string is ready, call the openprinter

    // We open the port using the default access previlige, because that is
    // enought for getting all the XcvData we need.
    if ( !OpenPrinter(pszXcvPortName, &m_hXcvPrinter, NULL) ) {
        // Reset the handle
        m_hXcvPrinter = NULL;
    }

    // Check if we're using the standard universal monitor "TCPMON.DLL"
    if ( GetMonitorName(szMonitorName, ARRAYSIZE(szMonitorName)) )
        m_bTCPMonSupported = !(lstrcmpi(szMonitorName, STANDARD_SNMP_MONITOR_NAME));
    else
        m_bTCPMonSupported = FALSE;

    bRet = TRUE;

CleanOut:
    if (pszXcvPortName)
        LocalFree (pszXcvPortName);

    if (bRet) {
        return S_OK;
    }
    else {
        Cleanup ();
        return SetAspHelpScriptingError(GetLastError ());
    }
}

/*****************************************************************************\
* FUNCTION:         Close
*
* PURPOSE:          Close method, cleanup the allocated handle/memory
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           always.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::Close()
{
    Cleanup();
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_IPAddress
*
* PURPOSE:          Get operation for IPAddress property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the IpAddress.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_IPAddress(BSTR * pbstrVal)
{
    return GetXcvDataBstr (L"IPAddress", pbstrVal);
}

/*****************************************************************************\
* FUNCTION:         get_Community
*
* PURPOSE:          Get operation for Community property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the Community.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Community(BSTR * pbstrVal)
{
    return GetXcvDataBstr (L"SNMPCommunity", pbstrVal);
}

/*****************************************************************************\
* FUNCTION:         get_SNMPDevice
*
* PURPOSE:          Get operation for SNMPDevice property
*
* ARGUMENTS:
*
*   pbstrVal:       Return value for the SNMPDevice.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_SNMPDevice(DWORD * pdwVal)
{
    return GetXcvDataDword (L"SNMPDeviceIndex", pdwVal);
}

/*****************************************************************************\
* FUNCTION:         get_SNMPSupported
*
* PURPOSE:          Get operation for SNMPSupported property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the SNMPSupported. (TRUE or FALSE)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_SNMPSupported(BOOL * pbVal)
{
    DWORD dwVal;
    HRESULT hr;

    *pbVal = FALSE;

    // Find out if it is an SNMP monitor
    hr = GetXcvDataDword (L"SNMPEnabled", &dwVal);
    if ( SUCCEEDED (hr) )
        *pbVal = dwVal;

    return hr;
}

STDMETHODIMP Casphelp::get_IsHTTP(BOOL * pbVal)
{
    static const TCHAR c_szHttp[]   = TEXT("http://");
    static const TCHAR c_szHttps[]  = TEXT("https://");

    *pbVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    //
    // Check if it is a masq printer and connected to an http port
    // then the port name is the url.
    //
    if ( ( m_pInfo2->Attributes & PRINTER_ATTRIBUTE_LOCAL ) &&
         ( m_pInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK ) ) {

        if ( m_pInfo2->pPortName ) {
            //
            // Compare the port name prefex to see if it is an HTTP port.
            //
            if ( !_tcsnicmp( m_pInfo2->pPortName, c_szHttp, _tcslen( c_szHttp ) ) ||
                 !_tcsnicmp( m_pInfo2->pPortName, c_szHttps, _tcslen( c_szHttps ) ) ) {
                //
                // Masq printers connected via a http print provider do have not
                // useful job status information therefor the standard win32
                // queue view is not the preferred view.
                //
                *pbVal = TRUE;
            }
        }
    }

    return S_OK;
}

VOID Casphelp::Cleanup()
{

    if ( m_hXcvPrinter != NULL ) {
        ClosePrinter (m_hXcvPrinter);
        m_hXcvPrinter = NULL;
    }

    if ( m_pPrinter ) {
        delete (m_pPrinter);
        m_pPrinter = NULL;
    }

    m_bTCPMonSupported        = FALSE;
    return;
}

Casphelp::~Casphelp()
{
    Cleanup();
}


HRESULT Casphelp::GetXcvDataBstr(LPCTSTR pszId, BSTR *pbstrVal)
{
    *pbstrVal = NULL;

    if ( !m_bTCPMonSupported ) {
        *pbstrVal = SysAllocString (TEXT (""));
        return S_OK;
    } else {
        if ( m_hXcvPrinter == NULL )
            return Error(IDS_NO_XCVDATA, IID_Iasphelp, E_HANDLE);
        else { // Real case
            DWORD dwNeeded = 0;
            DWORD dwStatus = ERROR_SUCCESS;
            LPTSTR pszBuffer = NULL;

            XcvData(m_hXcvPrinter,
                    pszId,
                    NULL,            // Input Data
                    0,               // Input Data Size
                    (LPBYTE)NULL,    // Output Data
                    0,               // Output Data Size
                    &dwNeeded,       // size of output buffer server wants to return
                    &dwStatus);      // return status value from remote component

            if ( dwStatus !=  ERROR_INSUFFICIENT_BUFFER ) {
                return SetAspHelpScriptingError(dwStatus);
            } else {
                pszBuffer = (LPTSTR) LocalAlloc (LPTR, dwNeeded);

                if ( !XcvData(m_hXcvPrinter,
                              pszId,
                              NULL,                // Input Data
                              0,                   // Input Data Size
                              (LPBYTE)pszBuffer,   // Output Data
                              dwNeeded,            // Output Data Size
                              &dwNeeded,           // size of output buffer server wants to return
                              &dwStatus)
                     || dwStatus != ERROR_SUCCESS ) {         // return status value from remote component
                    if ( pszBuffer )
                        LocalFree (pszBuffer);
                    return SetAspHelpScriptingError(dwStatus);
                }

                *pbstrVal = SysAllocString(pszBuffer);
                LocalFree (pszBuffer);

                if ( ! *pbstrVal )
                    return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
                else
                    return S_OK;
            }
        }
    }
}

HRESULT Casphelp::GetXcvDataDword(LPCTSTR pszId, DWORD * pdwVal)
{
    *pdwVal = 0;

    if ( m_hXcvPrinter == NULL )
        return Error(IDS_NO_XCVDATA, IID_Iasphelp, E_HANDLE);
    else { // Real case
        DWORD dwStatus = ERROR_SUCCESS;
        DWORD dwBuffer;
        DWORD dwNeeded = sizeof (dwBuffer);
        if ( !XcvData(m_hXcvPrinter,
                      pszId,
                      NULL,                // Input Data
                      0,                   // Input Data Size
                      (LPBYTE)&dwBuffer,   // Output Data
                      sizeof (dwBuffer),            // Output Data Size
                      &dwNeeded,           // size of output buffer server wants to return
                      &dwStatus)
             || dwStatus != ERROR_SUCCESS ) {         // return status value from remote component
            return SetAspHelpScriptingError(dwStatus);
        }

        *pdwVal = dwBuffer;
        return S_OK;
    }
}


/*****************************************************************************\
* FUNCTION:         get_IsTCPMonSupported
*
* PURPOSE:          Get operation for IsTCPMonSupported property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the IsTCPMonSupported. (TRUE  if the specified
*                   printer is using TCP Monitor, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_IsTCPMonSupported(BOOL * pbVal)
{
    *pbVal = FALSE;

    if ( m_hPrinter == NULL )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    *pbVal = m_bTCPMonSupported;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_Color
*
* PURPOSE:          Get operation for Color property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the Color. (TRUE  if the specified
*                   printer supports Color, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Color(BOOL * pVal)
{
    *pVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_COLORDEVICE,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (BOOLEAN) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_Duplex
*
* PURPOSE:          Get operation for Duplex property
*
* ARGUMENTS:
*
*   pbVal:          Return value for the Duplex. (TRUE  if the specified
*                   printer supports Duplex, FALSE otherwise)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Duplex(BOOL * pVal)
{
    *pVal = FALSE;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_DUPLEX,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (BOOL) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_MaximumResolution
*
* PURPOSE:          Get operation for MaximumResolution property
*
* ARGUMENTS:
*
*   pVal:           Return value of Maximum Resolution (in DPI)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_MaximumResolution(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD cbNeeded;

    DWORD dwRet = GetPrinterDataEx(m_hPrinter,
                                   SPLDS_DRIVER_KEY,
                                   SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                                   NULL,
                                   (LPBYTE) pVal,
                                   sizeof(DWORD),
                                   &cbNeeded);
    if ( dwRet != ERROR_SUCCESS ) {
        *pVal = 0;
        return SetAspHelpScriptingError(dwRet);
    }

    return S_OK;
}

STDMETHODIMP Casphelp::get_MediaReady(VARIANT * pVal)
{
    return GetPaperAndMedia(pVal, DC_MEDIAREADY);
}

/*****************************************************************************\
* FUNCTION:         get_PaperNames
*
* PURPOSE:          Get operation for PaperNames property
*
* ARGUMENTS:
*
*   pVal:           Return a list of supported paper names (in an array of BSTR)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PaperNames(VARIANT * pVal)
{
    return GetPaperAndMedia(pVal, DC_PAPERNAMES);
}

HRESULT Casphelp::GetPaperAndMedia(VARIANT * pVal, WORD wDCFlag)
{
    SAFEARRAY           *psa = NULL;
    SAFEARRAYBOUND      rgsabound[1];
    long                ix[1];
    VARIANT             var;
    DWORD               i;
    HRESULT             hr = E_FAIL;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     wDCFlag,
                                     NULL,
                                     NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    LPTSTR lpMedia = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR) * dwRet * LENGTHOFPAPERNAMES);

    if ( !lpMedia )
        return SetAspHelpScriptingError(GetLastError());

    dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                               m_pInfo2->pPortName,
                               wDCFlag,
                               lpMedia,
                               NULL);
    if ( dwRet == DWERROR ) {
        hr = SetAspHelpScriptingError(GetLastError());
        goto BailOut;
    }

    // Paper Names are now in MULTI_SZ lpMedia
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwRet;

    // Create a SafeArray to eventually return
    if ( ! (psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound)) ) {
        hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
        goto BailOut;
    }

    VariantInit(&var);

    // Fill in the SafeArray
    for ( i = 0; i < dwRet; i++ ) {
        var.vt = VT_BSTR;
        if ( ! (var.bstrVal = SysAllocString(lpMedia + (i*LENGTHOFPAPERNAMES))) ) {
            hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            goto BailOut;
        }
        ix[0] = i;
        hr = SafeArrayPutElement(psa, ix, &var);
        if (FAILED ( hr )) {
            hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            goto BailOut;
        }
        VariantClear(&var);
    }

    // Assign good stuff to Out param
    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = psa;
    LocalFree(lpMedia);
    return S_OK;

    BailOut:
    LocalFree(lpMedia);
    if ( psa )
        SafeArrayDestroy(psa);

    return hr;
}

/*****************************************************************************\
* FUNCTION:         get_PageRate
*
* PURPOSE:          Get operation for PageRate property
*
* ARGUMENTS:
*
*   pVal:           Return a PageRate of the specified printer
*                   (Unit: PPM / CPS / LPM / IPM)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PageRate(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet;

    dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                               m_pInfo2->pPortName,
                               DC_PRINTRATE,
                               NULL,
                               NULL);
    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (long) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_PageRateUnit
*
* PURPOSE:          Get operation for PageRate property
*
* ARGUMENTS:
*
*   pVal:           Return a Unit of the Page Rate of a specified printer
*                   (Unit: PPM / CPS / LPM / IPM)
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PageRateUnit (long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    DWORD dwRet = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     m_pInfo2->pPortName,
                                     DC_PRINTRATEUNIT,
                                     NULL,
                                     NULL);

    if ( dwRet == DWERROR )
        return SetAspHelpScriptingError(GetLastError());

    *pVal = (long) dwRet;
    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_PortName
*
* PURPOSE:          Get operation for PortName property
*
* ARGUMENTS:
*
*   pVal:           Return the port name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PortName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pPortName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}

/*****************************************************************************\
* FUNCTION:         get_DriverName
*
* PURPOSE:          Get operation for DriverName property
*
* ARGUMENTS:
*
*   pVal:           Return the driver name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_DriverName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pDriverName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}


/*****************************************************************************\
* FUNCTION:         get_ComputerName
*
* PURPOSE:          Get operation for ComputerName property
*
* ARGUMENTS:
*
*   pVal:           Return the computer name of the server
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ComputerName(BSTR * pVal)
{
    if ( !(*pVal = SysAllocString (m_szComputerName)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

HRESULT Casphelp::SetAspHelpScriptingError(DWORD dwError)
{
    return (SetScriptingError(CLSID_asphelp, IID_Iasphelp, dwError));
}


/*****************************************************************************\
* FUNCTION:         get_LongPaperName
*
* PURPOSE:          Get operation for LongPaperName property
*                   Translate the short paper name to the long paper name
*
* ARGUMENTS:
*
*   bstrShortName:  The short paper name
*   pVal:           Pointer to the long paper name
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_LongPaperName(BSTR bstrShortName, BSTR * pVal)
{
    struct PaperNameMapping {
        LPCWSTR     pShortName;
        DWORD       dwLongNameID;
    };

    static const WCHAR      cHyphen         = L'-';
    static const WCHAR      cszUnknown[]    = L"Unknown";
    static const LPCWSTR    pMediaArray[]   = {
        L"-envelope", L"-white", L"-transparent", L"-coloured", NULL};

    static const PaperNameMapping nameMapping[] = {
        {L"iso-a0",             IDS_A0_841_X_1189_MM},
        {L"iso-a1",             IDS_A1_594_X_841_MM},
        {L"iso-a2",             IDS_A2_420_X_594_MM},
        {L"iso-a3",             IDS_A3_297_X_420_MM},
        {L"iso-a4",             IDS_A4_210_X_297_MM},
        {L"iso-a5",             IDS_A5_148_X_210_MM},
        {L"iso-a6",             IDS_A6_105_X_148_MM},
        {L"iso-a7",             IDS_A7_74_X_105_MM},
        {L"iso-a8",             IDS_A8_52_X_74_MM},
        {L"iso-a9",             IDS_A9_37_X_52_MM},
        {L"iso-a10",            IDS_A10_26_X_37_MM},
        {L"iso-b0",             IDS_B0_1000_X_1414_MM},
        {L"iso-b1",             IDS_B1_707_X_1000_MM},
        {L"iso-b2",             IDS_B2_500_X_707_MM},
        {L"iso-b3",             IDS_B3_353_X_500_MM},
        {L"iso-b4",             IDS_B4_250_X_353_MM},
        {L"iso-b5",             IDS_B5_176_X_250_MM},
        {L"iso-b6",             IDS_B6_125_X_176_MM},
        {L"iso-b7",             IDS_B7_88_X_125_MM},
        {L"iso-b8",             IDS_B8_62_X_88_MM},
        {L"iso-b9",             IDS_B9_44_X_62_MM},
        {L"iso-b10",            IDS_B10_31_X_44_MM},
        {L"iso-c0",             IDS_C0_917_X_1297_MM},
        {L"iso-c1",             IDS_C1_648_X_917_MM},
        {L"iso-c2",             IDS_C2_458_X_648_MM},
        {L"iso-c3",             IDS_C3_324_X_458_MM},
        {L"iso-c4",             IDS_C4_ENVELOPE_229_X_324_MM},
        {L"iso-c5",             IDS_C5_ENVELOPE_162_X_229_MM},
        {L"iso-c6",             IDS_C6_114_X_162_MM},
        {L"iso-c7",             IDS_C7_81_X_114_MM},
        {L"iso-c8",             IDS_C8_57_X_81_MM},
        {L"iso-designated",     IDS_DL_ENVELOPE_110_X_220_MM},
        {L"jis-b0",             IDS_B0_1030_X_1456_MM},
        {L"jis-b1",             IDS_B1_728_X_1030_MM},
        {L"jis-b2",             IDS_B2_515_X_728_MM},
        {L"jis-b3",             IDS_B3_364_X_515_MM},
        {L"jis-b4",             IDS_B4_257_X_364_MM},
        {L"jis-b5",             IDS_B5_182_X_257_MM},
        {L"jis-b6",             IDS_B6_128_X_182_MM},
        {L"jis-b7",             IDS_B7_91_X_128_MM},
        {L"jis-b8",             IDS_B8_64_X_91_MM},
        {L"jis-b9",             IDS_B9_45_X_64_MM},
        {L"jis-b10",            IDS_B10_32_X_45_MM},
        {L"na-letter",          IDS_LETTER_8_5_X_11_IN},
        {L"letter",             IDS_LETTER_8_5_X_11_IN},
        {L"na-legal",           IDS_LEGAL_8_5_X_14_IN},
        {L"legal",              IDS_LEGAL_8_5_X_14_IN},
        {L"na-10x13",           IDS_ENVELOPE_10X13},
        {L"na-9x12x",           IDS_ENVELOPE_9X12},
        {L"na-number-10",       IDS_ENVELOPE_10},
        {L"na-7x9",             IDS_ENVELOPE_7X9},
        {L"na-9x11x",           IDS_ENVELOPE_9X11},
        {L"na-10x14",           IDS_ENVELOPE_10X14},
        {L"na-number-9",        IDS_ENVELOPE_9},
        {L"na-6x9",             IDS_ENVELOPE_6X9},
        {L"na-10x15",           IDS_ENVELOPE_10X15},
        {L"a",                  IDS_ENGINEERING_A_8_5_X_11_IN},
        {L"b",                  IDS_ENGINEERING_B_11_X_17_IN},
        {L"c",                  IDS_ENGINEERING_C_17_X_22_IN},
        {L"d",                  IDS_ENGINEERING_D_22_X_34_IN},
        {L"e",                  IDS_ENGINEERING_E_34_X_44_IN},
        {NULL, 0}
    };

    const PaperNameMapping  *pMapping           = nameMapping;
    LPWSTR                  pTail               = NULL ;
    DWORD                   dwLongNameID        = 0;
    WCHAR                   szBuffer [cdwBufSize];
    PWSTR                   pBuffer             = szBuffer;
    HRESULT                 hr                  = S_OK;

    if ( !bstrShortName ) {
        hr =  E_POINTER;
    }

    if (SUCCEEDED (hr))
    {
        //
        //  find the last char '-'
        //
        pTail = wcsrchr(bstrShortName, cHyphen );
        if ( pTail ) {

            const LPCWSTR *pMedia = pMediaArray;

            while ( *pMedia ) {
                if ( !lstrcmpi (*pMedia, pTail) ) {
                    //
                    // Mark it to be NULL;
                    //
                    *pTail = 0;
                    break;
                }
                pMedia++;
            }
        }

        while ( pMapping->pShortName ) {
            if ( !lstrcmpi (pMapping->pShortName, bstrShortName) ) {
                //
                // Found a match
                //
                dwLongNameID = pMapping->dwLongNameID;
                break;
            }
            pMapping++;
        }

        if ( pTail )
            *pTail = cHyphen;

        if (dwLongNameID)
        {
            if ( !LoadString( _Module.GetResourceInstance(),
                              dwLongNameID, szBuffer, cdwBufSize) )
            {
                hr = SetAspHelpScriptingError(GetLastError());
            }

            if (SUCCEEDED (hr))
            {
                if ( !(*pVal = SysAllocString (pBuffer)) )
                {
                    hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
                }
            }
        }
        else
        {
            if ( !(*pVal = SysAllocString (cszUnknown)) )
            {
                hr = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
* FUNCTION:         get_MibErrorDscp
*
* PURPOSE:          Get operation for MibErrorDscp property
*                   Map the mib error code to the error description
*
* ARGUMENTS:
*
*   dwError:        The error code
*   pVal:           Pointer to the error description
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/

STDMETHODIMP Casphelp::get_MibErrorDscp(DWORD dwError, BSTR * pVal)
{
    static ErrorMapping errorMapping[] = {
        {1,     IDS_MIBERR_OTHER},
        {2,     IDS_MIBERR_UNKNOWN},
        {3,     IDS_MIBERR_COVEROPEN},
        {4,     IDS_MIBERR_COVERCLOSED},
        {5,     IDS_MIBERR_INTERLOCKOPEN},
        {6,     IDS_MIBERR_INTERLOCKCLOSED},
        {7,     IDS_MIBERR_CONFIGURATIONCHANGE},
        {8,     IDS_MIBERR_JAM},
        {501,   IDS_MIBERR_DOOROPEN},
        {502,   IDS_MIBERR_DOORCLOSED},
        {503,   IDS_MIBERR_POWERUP},
        {504,   IDS_MIBERR_POWERDOWN},
        {801,   IDS_MIBERR_INPUTMEDIATRAYMISSING},
        {802,   IDS_MIBERR_INPUTMEDIASIZECHANGE},
        {803,   IDS_MIBERR_INPUTMEDIAWEIGHTCHANGE},
        {804,   IDS_MIBERR_INPUTMEDIATYPECHANGE},
        {805,   IDS_MIBERR_INPUTMEDIACOLORCHANGE},
        {806,   IDS_MIBERR_INPUTMEDIAFORMPARTSCHANGE},
        {807,   IDS_MIBERR_INPUTMEDIASUPPLYLOW},
        {808,   IDS_MIBERR_INPUTMEDIASUPPLYEMPTY},
        {901,   IDS_MIBERR_OUTPUTMEDIATRAYMISSING},
        {902,   IDS_MIBERR_OUTPUTMEDIATRAYALMOSTFULL},
        {903,   IDS_MIBERR_OUTPUTMEDIATRAYFULL},
        {1001,  IDS_MIBERR_MARKERFUSERUNDERTEMPERATURE},
        {1002,  IDS_MIBERR_MARKERFUSEROVERTEMPERATURE},
        {1101,  IDS_MIBERR_MARKERTONEREMPTY},
        {1102,  IDS_MIBERR_MARKERINKEMPTY},
        {1103,  IDS_MIBERR_MARKERPRINTRIBBONEMPTY},
        {1104,  IDS_MIBERR_MARKERTONERALMOSTEMPTY},
        {1105,  IDS_MIBERR_MARKERINKALMOSTEMPTY},
        {1106,  IDS_MIBERR_MARKERPRINTRIBBONALMOSTEMPTY},
        {1107,  IDS_MIBERR_MARKERWASTETONERRECEPTACLEALMOSTFULL},
        {1108,  IDS_MIBERR_MARKERWASTEINKRECEPTACLEALMOSTFULL},
        {1109,  IDS_MIBERR_MARKERWASTETONERRECEPTACLEFULL},
        {1110,  IDS_MIBERR_MARKERWASTEINKRECEPTACLEFULL},
        {1111,  IDS_MIBERR_MARKEROPCLIFEALMOSTOVER},
        {1112,  IDS_MIBERR_MARKEROPCLIFEOVER},
        {1113,  IDS_MIBERR_MARKERDEVELOPERALMOSTEMPTY},
        {1114,  IDS_MIBERR_MARKERDEVELOPEREMPTY},
        {1301,  IDS_MIBERR_MEDIAPATHMEDIATRAYMISSING},
        {1302,  IDS_MIBERR_MEDIAPATHMEDIATRAYALMOSTFULL},
        {1303,  IDS_MIBERR_MEDIAPATHMEDIATRAYFULL},
        {1501,  IDS_MIBERR_INTERPRETERMEMORYINCREASE},
        {1502,  IDS_MIBERR_INTERPRETERMEMORYDECREASE},
        {1503,  IDS_MIBERR_INTERPRETERCARTRIDGEADDED},
        {1504,  IDS_MIBERR_INTERPRETERCARTRIDGEDELETED},
        {1505,  IDS_MIBERR_INTERPRETERRESOURCEADDED},
        {1506,  IDS_MIBERR_INTERPRETERRESOURCEDELETED},
        {1507,  IDS_MIBERR_INTERPRETERRESOURCEUNAVAILABLE},
        {0,     0}
    };

    ErrorMapping *pMapping = errorMapping;
    DWORD   dwErrorDscpID = 0;
    TCHAR   szBuffer [cdwBufSize];

    if ( !pVal )
        return E_POINTER;

    szBuffer[0] = 0;

    while ( pMapping->dwError ) {
        if ( pMapping->dwError == dwError ) {
            // Found a match
            dwErrorDscpID = pMapping->dwErrorDscpID;
            break;
        }
        pMapping++;
    }

    if ( dwErrorDscpID ) {
        if ( !LoadString( _Module.GetResourceInstance(),
                          dwErrorDscpID, szBuffer, cdwBufSize) )
            return SetAspHelpScriptingError(GetLastError());
    }

    if ( !(*pVal = SysAllocString (szBuffer)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         CalcJobETA
*
* PURPOSE:          Calculate Job Completion Time
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::CalcJobETA()
{
    if (m_pPrinter &&
        (m_pPrinter->CalJobEta() || GetLastError () == ERROR_INVALID_DATA) &&
        // If the error is ERROR_INVALID_DATA, m_dwJobCompletionMinute = -1
        (m_pPrinter->GetJobEtaData (m_dwJobCompletionMinute,
                                    m_dwPendingJobCount,
                                    m_dwAvgJobSize,
                                    m_dwAvgJobSizeUnit))) {
        m_bCalcJobETA = TRUE;
        return S_OK;
    }
    else
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
}

/*****************************************************************************\
*
* FUNCTION:         get_PendingJobCount
*
* PURPOSE:          Get the number of pending jobs. This value is calculated in
*                   CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The number of pending jobs
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_PendingJobCount(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwPendingJobCount;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_JobCompletionMinute
*
* PURPOSE:          Get the minute when the pending jobs are expected to complete.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the minute
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_JobCompletionMinute(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwJobCompletionMinute;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_AvgJobSizeUnit
*
* PURPOSE:          Get the unit (either PagePerJob or BytePerJob) of the
*                   average job size.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the unit
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_AvgJobSizeUnit(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwAvgJobSizeUnit;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_AvgJobSize
*
* PURPOSE:          Get the average job size.
*                   This value is calculated in CalcJobETA()
*
* ARGUMENTS:
*
*   pVal:           The value of the average job size
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_AvgJobSize(long * pVal)
{
    HRESULT hr = E_HANDLE;

    if (pVal)
        if ( m_bCalcJobETA ) {
            *pVal = m_dwAvgJobSize;
            hr = S_OK;
        }
        else
            *pVal = 0;

    if (hr != S_OK)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, hr);
    else
        return S_OK;

}

/*****************************************************************************\
*
* FUNCTION:         get_Status
*
* PURPOSE:          Get the printer status.
*                   The difference between Status and the one got
*                   from PRINTER_INFO_2 is that when the printer is offline
*                   This function return a status with PRINTE_STATUS_OFFLINE
*                   set.
*
* ARGUMENTS:
*
*   pVal:           The value of the average job size
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_Status(long * pVal)
{
    *pVal = 0;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    *pVal = m_pInfo2->Status;
    return S_OK;
}

/*****************************************************************************\
*
* FUNCTION:         get_ErrorDscp
*
* PURPOSE:          Convert the error code to a descriptive string.
*
* ARGUMENTS:
*
*   lErrCode:       The error code
*   pVal:           Pointer to the descriptive string.
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ErrorDscp(long lErrCode, BSTR * pVal)
{

    static ErrorMapping errorMapping[] = {
        {ERROR_NOT_SUPPORTED,       IDS_ERROR_CPUNOTSUPPORTED},
        {ERROR_DRIVER_NOT_FOUND,    IDS_ERROR_DRIVERNOTFOUND},
        {ERROR_WPNPINST_TERMINATED, IDS_ERROR_WPNPINST_TERMINATED},
        {ERROR_INTERNAL_SERVER,     IDS_ERROR_INTERNAL_SERVER},
        {ERROR_SERVER_DISK_FULL,    IDS_ERROR_SERVER_DISK_FULL},
        {ERROR_TRUST_E_NOSIGNATURE, IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_SPAPI_E_NO_CATALOG,  IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_TRUST_E_BAD_DIGEST,  IDS_ERROR_TRUST_E_NOSIGNATURE},
        {ERROR_LOCAL_PRINTER_ACCESS,IDS_ERROR_LOCAL_PRINTER_ACCESS},
        {ERROR_IE_SECURITY_DENIED,  IDS_ERROR_IE_SECURITY_DENIED},
        {CRYPT_E_FILE_ERROR,        IDS_CRYPT_E_FILE_ERROR},
        {0, 0}
    };

    ErrorMapping *pMapping = errorMapping;
    DWORD   dwErrorDscpID = 0;
    DWORD   dwError = ((DWORD)lErrCode) & 0xFFFF;
    TCHAR   szBuffer [cdwBufSize];

    if ( !pVal )
        return E_POINTER;

    szBuffer[0] = 0;

    while ( pMapping->dwError ) {
        if ( pMapping->dwError == dwError ) {
            // Found a match
            dwErrorDscpID = pMapping->dwErrorDscpID;
            break;
        }
        pMapping++;
    }

    if ( dwErrorDscpID ) {
        if ( !LoadString( _Module.GetResourceInstance(),
                          dwErrorDscpID, szBuffer, cdwBufSize) )
            return SetAspHelpScriptingError(GetLastError());
    }
    else {

        if ( !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwError,
                            0,
                            szBuffer,
                            cdwBufSize,
                            NULL) ) {
            return SetAspHelpScriptingError(GetLastError());
        }
    }

    if ( !(*pVal = SysAllocString (szBuffer)) )
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return S_OK;
}

/*****************************************************************************\
* FUNCTION:         get_ShareName
*
* PURPOSE:          Get operation for ShareName property
*
* ARGUMENTS:
*
*   pVal:           Return the share name of the specified printer
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_HANDLE:       Open method has not been called.
*   E_OUTOFMEMORY:  Out of memory.
*
*   0x8007000 | Win32Error Code:
*                   If any call to win32 API fails, we return the 32 bit error
*                   including the Severity Code, Facility Code and the Win32 Error
*                   Code.
*                   A possible list of Win32ErrorCode is
*                   ERROR_NOT_ENOUGH_MEMORY:        Out of memory.
*
*
\*****************************************************************************/
STDMETHODIMP Casphelp::get_ShareName(BSTR * pbstrVal)
{
    HRESULT             hRet = S_OK;

    if ( !m_pInfo2 )
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if ( !(*pbstrVal = SysAllocString (m_pInfo2->pShareName)) )
        hRet = Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_OUTOFMEMORY);

    return hRet;
}

STDMETHODIMP Casphelp::get_IsCluster(BOOL * pbVal)
{
    DWORD dwClusterState;

    *pbVal = FALSE;

    if ((GetNodeClusterState (NULL, &dwClusterState) == ERROR_SUCCESS) &&
        (dwClusterState == ClusterStateRunning)) {

        *pbVal = TRUE;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\asptlb.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ASPTypeLibrary */

#ifndef _ASPTypeLibrary_H_
#define _ASPTypeLibrary_H_

DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0L,0xA85C,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IStringList,0xD97A6DA0L,0xA85D,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IStringList */
#undef INTERFACE
#define INTERFACE IStringList

DECLARE_INTERFACE_(IStringList, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IStringList methods */
    STDMETHOD(get_Item)(THIS_ VARIANT i, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* cStrRet) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0L,0xA85F,0x11DF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequestDictionary */
#undef INTERFACE
#define INTERFACE IRequestDictionary

DECLARE_INTERFACE_(IRequestDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequestDictionary methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequest,0xD97A6DA0L,0xA861,0x11CF,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequest */
#undef INTERFACE
#define INTERFACE IRequest

DECLARE_INTERFACE_(IRequest, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequest methods */
    STDMETHOD(get_Item)(THIS_ BSTR bstrVar, IDispatch * FAR* ppObjReturn) PURE;
    STDMETHOD(get_QueryString)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Form)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Body)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ServerVariables)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ClientCertificate)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
};

DEFINE_GUID(CLSID_Request,0x920C25D0L,0x25D9,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Request;
#endif

DEFINE_GUID(IID_IReadCookie,0x71EAF260L,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

/* Definition of interface: IReadCookie */
#undef INTERFACE
#define INTERFACE IReadCookie

DECLARE_INTERFACE_(IReadCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IReadCookie methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0L,0xA862,0x11CF,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IWriteCookie */
#undef INTERFACE
#define INTERFACE IWriteCookie

DECLARE_INTERFACE_(IWriteCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWriteCookie methods */
    STDMETHOD(put_Item)(THIS_ VARIANT key, BSTR bstrValue) PURE;
    STDMETHOD(put_Expires)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(put_Domain)(THIS_ BSTR bstrDomain) PURE;
    STDMETHOD(put_Path)(THIS_ BSTR bstrPath) PURE;
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL fSecure) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IResponse,0xD97A6DA0L,0xA864,0x11CF,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IResponse */
#undef INTERFACE
#define INTERFACE IResponse

DECLARE_INTERFACE_(IResponse, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IResponse methods */
    STDMETHOD(get_Buffer)(THIS_ VARIANT_BOOL FAR* fIsBuffering) PURE;
    STDMETHOD(put_Buffer)(THIS_ VARIANT_BOOL fIsBuffering) PURE;
    STDMETHOD(get_ContentType)(THIS_ BSTR FAR* pbstrContentTypeRet) PURE;
    STDMETHOD(put_ContentType)(THIS_ BSTR bstrContentType) PURE;
    STDMETHOD(get_Expires)(THIS_ VARIANT FAR* pvarExpiresMinutesRet) PURE;
    STDMETHOD(put_Expires)(THIS_ long lExpiresMinutes) PURE;
    STDMETHOD(get_ExpiresAbsolute)(THIS_ VARIANT FAR* pvarExpiresRet) PURE;
    STDMETHOD(put_ExpiresAbsolute)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppCookies) PURE;
    STDMETHOD(get_Status)(THIS_ BSTR FAR* pbstrStatusRet) PURE;
    STDMETHOD(put_Status)(THIS_ BSTR bstrStatus) PURE;
    STDMETHOD(Add)(THIS_ BSTR bstrHeaderValue, BSTR bstrHeaderName) PURE;
    STDMETHOD(AddHeader)(THIS_ BSTR bstrHeaderName, BSTR bstrHeaderValue) PURE;
    STDMETHOD(AppendToLog)(THIS_ BSTR bstrLogEntry) PURE;
    STDMETHOD(BinaryWrite)(THIS_ VARIANT varInput) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
    STDMETHOD(Redirect)(THIS_ BSTR bstrURL) PURE;
    STDMETHOD(Write)(THIS_ VARIANT varText) PURE;
    STDMETHOD(WriteBlock)(THIS_ short iBlockNumber) PURE;
};

DEFINE_GUID(CLSID_Response,0x46E19BA0L,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Response;
#endif

DEFINE_GUID(IID_ISessionObject,0xD97A6DA0L,0xA865,0x11CF,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: ISessionObject */
#undef INTERFACE
#define INTERFACE ISessionObject

DECLARE_INTERFACE_(ISessionObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ISessionObject methods */
    STDMETHOD(get_SessionID)(THIS_ BSTR FAR* pbstrRet) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plvar) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lvar) PURE;
    STDMETHOD(Abandon)(THIS) PURE;
};

DEFINE_GUID(CLSID_Session,0x509F8F20L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Session;
#endif

DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0L,0xA866,0x11CF,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IApplicationObject */
#undef INTERFACE
#define INTERFACE IApplicationObject

DECLARE_INTERFACE_(IApplicationObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationObject methods */
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(Lock)(THIS) PURE;
    STDMETHOD(UnLock)(THIS) PURE;
};

DEFINE_GUID(CLSID_Application,0x7C3BAF00L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Application;
#endif

DEFINE_GUID(IID_IServer,0xD97A6DA0L,0xA867,0x11CF,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IServer */
#undef INTERFACE
#define INTERFACE IServer

DECLARE_INTERFACE_(IServer, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IServer methods */
    STDMETHOD(get_ScriptTimeout)(THIS_ long FAR* plTimeoutSeconds) PURE;
    STDMETHOD(put_ScriptTimeout)(THIS_ long lTimeoutSeconds) PURE;
    STDMETHOD(CreateObject)(THIS_ BSTR bstrProgID, IDispatch * FAR* ppDispObject) PURE;
    STDMETHOD(HTMLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
    STDMETHOD(MapPath)(THIS_ BSTR bstrLogicalPath, BSTR FAR* pbstrPhysicalPath) PURE;
    STDMETHOD(URLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
};

DEFINE_GUID(CLSID_Server,0xA506D160L,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Server;
#endif

DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IScriptingContext */
#undef INTERFACE
#define INTERFACE IScriptingContext

DECLARE_INTERFACE_(IScriptingContext, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptingContext methods */
    STDMETHOD(get_Request)(THIS_ IRequest FAR* FAR* ppRequest) PURE;
    STDMETHOD(get_Response)(THIS_ IResponse FAR* FAR* ppResponse) PURE;
    STDMETHOD(get_Server)(THIS_ IServer FAR* FAR* ppServer) PURE;
    STDMETHOD(get_Session)(THIS_ ISessionObject FAR* FAR* ppSession) PURE;
    STDMETHOD(get_Application)(THIS_ IApplicationObject FAR* FAR* ppApplication) PURE;
};

DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus
class ScriptingContext;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\dsprintq.cpp ===
// DSPrintQueue.cpp : Implementation of CDSPrintQueue
#include "stdafx.h"
#include <strsafe.h>

#include "oleprn.h"
#include "DSPrintQ.h"
#include "winsprlp.h"

/////////////////////////////////////////////////////////////////////////////
// CDSPrintQueue

STDMETHODIMP CDSPrintQueue::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IDSPrintQueue,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



CDSPrintQueue::CDSPrintQueue()
{
	m_bstrContainer         = NULL;
	m_bstrName		        = NULL;
	m_bstrUNCName	        = NULL;
	m_bstrADsPath	        = NULL;
    m_pfnPublishPrinter     = (BOOL (*)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD)) NULL;
    m_hWinspool             = NULL;
}


CDSPrintQueue::~CDSPrintQueue()
{
	SysFreeString(m_bstrContainer);
	SysFreeString(m_bstrName);
	SysFreeString(m_bstrUNCName);
	SysFreeString(m_bstrADsPath);

    if (!m_hWinspool)
        FreeLibrary(m_hWinspool);
}



STDMETHODIMP CDSPrintQueue::get_UNCName(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrUNCName) {
        if (!(*ppVal = SysAllocString(m_bstrUNCName)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_UNCName(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrUNCName = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}

STDMETHODIMP CDSPrintQueue::get_Name(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrName) {
        if (!(*ppVal = SysAllocString(m_bstrName)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_Name(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrName = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}

STDMETHODIMP CDSPrintQueue::get_Container(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrContainer) {
        if (!(*ppVal = SysAllocString(m_bstrContainer)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}

STDMETHODIMP CDSPrintQueue::put_Container(BSTR newVal)
{
	HRESULT hr = S_OK;

	if (!newVal)
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

	if (!(m_bstrContainer = SysAllocString(newVal)))
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

	return hr;
}


STDMETHODIMP CDSPrintQueue::Publish(DWORD dwAction)
{
    DWORD   dwRet = ERROR_SUCCESS;
    PWSTR   pszADsPath = NULL;

    // Load PublishPrinter
    if (!m_pfnPublishPrinter) {

        if (!m_hWinspool && !(m_hWinspool = LoadLibraryFromSystem32(L"Winspool.drv")))
            return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, GetLastError());

        if (!(m_pfnPublishPrinter = (BOOL (*)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD))
                                    GetProcAddress(m_hWinspool, (LPCSTR) 217)))
            return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, GetLastError());
    }

    // Publish the Printer
    if (!m_pfnPublishPrinter((HWND) NULL, m_bstrUNCName, m_bstrContainer, m_bstrName, &pszADsPath, dwAction)) {

        dwRet = GetLastError();

        if (pszADsPath) {
            if (dwAction == PUBLISHPRINTER_FAIL_ON_DUPLICATE && dwRet == ERROR_FILE_EXISTS)
                m_bstrADsPath = SysAllocString(pszADsPath);

            GlobalFree(pszADsPath);
        }

    } else if (pszADsPath) {

        m_bstrADsPath = SysAllocString(pszADsPath);
        GlobalFree(pszADsPath);
    }

    return SetScriptingError(CLSID_DSPrintQueue, IID_IDSPrintQueue, dwRet);
}


STDMETHODIMP CDSPrintQueue::get_Path(BSTR * ppVal)
{
    HRESULT hr = S_OK;

    if (!ppVal) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);

    } else if (m_bstrADsPath) {
        if (!(*ppVal = SysAllocString(m_bstrADsPath)))
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_ENOUGH_MEMORY);

    } else {
        *ppVal = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\dsprintq.h ===
// DSPrintQueue.h : Declaration of the CDSPrintQueue

#ifndef __DSPRINTQUEUE_H_
#define __DSPRINTQUEUE_H_

/////////////////////////////////////////////////////////////////////////////
// CDSPrintQueue
class ATL_NO_VTABLE CDSPrintQueue :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDSPrintQueue, &CLSID_DSPrintQueue>,
	public ISupportErrorInfo,
	public IDispatchImpl<IDSPrintQueue, &IID_IDSPrintQueue, &LIBID_OLEPRNLib>
{
public:
	CDSPrintQueue();
	~CDSPrintQueue();

DECLARE_REGISTRY_RESOURCEID(IDR_DSPRINTQUEUE)

BEGIN_COM_MAP(CDSPrintQueue)
	COM_INTERFACE_ENTRY(IDSPrintQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDSPrintQueue
public:
	STDMETHOD(get_Path)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Publish)(DWORD dwAction);
	STDMETHOD(get_Container)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Container)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_UNCName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UNCName)(/*[in]*/ BSTR newVal);

private:
	BSTR	    m_bstrContainer;
	BSTR	    m_bstrName;
	BSTR	    m_bstrUNCName;
	BSTR	    m_bstrADsPath;
    HINSTANCE   m_hWinspool;
    BOOL        (*m_pfnPublishPrinter)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD);
};

#endif //__DSPRINTQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\custom.cpp ===
/*****************************************************************************\
* MODULE:       custom.cpp
*
* PURPOSE:      OEM Customization support
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     10/10/97  babakj    Created
*
\*****************************************************************************/

#include "stdafx.h"
#include <strsafe.h>
#include "gensph.h"

#include "oleprn.h"
#include "asphelp.h"


TCHAR cszEverestVirRoot[]    = TEXT("\\web\\printers");
TCHAR cszManufacturerKey[]   = TEXT("PnPData");
TCHAR cszManufacturerValue[] = TEXT("Manufacturer");

#define DEFAULTASPPAGE         TEXT("Page1.asp")


//
// Caller allocs memory for pMonitorname.
//
// pMonitorName untouched if failure.
//
BOOL Casphelp::GetMonitorName( LPTSTR pMonitorName, DWORD cchBufSize )
{
    PPORT_INFO_2 pPortInfo2 = NULL;
    BOOL fRet = FALSE;
    DWORD dwNeeded, dwReturned;


    // Now get all ports to find a match from.
    LPTSTR  lpszServerName = m_pInfo2 ? m_pInfo2->pServerName : NULL;

    if( EnumPorts(lpszServerName, 2, NULL, 0, &dwNeeded, &dwReturned) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPortInfo2 = (PPORT_INFO_2)LocalAlloc( LPTR, dwNeeded))) ||
        (!EnumPorts( lpszServerName , 2, (LPBYTE)pPortInfo2, dwNeeded, &dwNeeded, &dwReturned ))) {

        LocalFree( pPortInfo2 );
        SetAspHelpScriptingError(GetLastError());
        return FALSE;
    }

    if ( m_pInfo2 ) {
        for( DWORD i=0; i < dwReturned; i++ )
            if( !lstrcmpi( pPortInfo2[i].pPortName, m_pInfo2->pPortName )) {
                // Some monitors (like LPRMON) do not fill in pMonitorName, so we ignore them.
                if( pPortInfo2[i].pMonitorName ) {
                    StringCchCopy( pMonitorName, cchBufSize, pPortInfo2[i].pMonitorName );
                    fRet = TRUE;
                }
                break;
            }
    }

    LocalFree( pPortInfo2 );

    return fRet;
}

//
// Get the model name (aka driver name) of the printer
//
// Caller allocs memory for pModel.
//
BOOL Casphelp::GetModel( LPTSTR pModel, DWORD cchBufSize )
{
    if (!m_pInfo2)
    {
        Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
        return FALSE;
    }

    StringCchCopy( pModel, cchBufSize, m_pInfo2->pDriverName );
    return TRUE;
}



//
// Get the Manufacturer name (aka driver name) of the printer
//
// Caller allocs memory for pManufacturer.
//
BOOL Casphelp::GetManufacturer( LPTSTR pManufacturer, DWORD cchBufSize )
{
    if (!m_hPrinter)
    {
        Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);
        return FALSE;
    }

    DWORD dwNeeded, dwType, dwRet;


    dwRet = GetPrinterDataEx( m_hPrinter,
                                  cszManufacturerKey,
                                  cszManufacturerValue,
                                  &dwType,
                                  (LPBYTE) pManufacturer,
                                  sizeof(TCHAR) * cchBufSize,
                                  &dwNeeded);

    if (dwRet != ERROR_SUCCESS || dwType != REG_SZ)
    {
        SetAspHelpScriptingError(dwRet);
        return FALSE;
    }
    else
    {
        pManufacturer[cchBufSize - 1] = 0;
        return TRUE;
    }
}



//
// Returns:
//       bDeviceASP == TRUE:  The relative path to the ASP file if the printer has INF-based ASP support.
//       bDeviceASP == FALSE: The relative path to the ASP file if the printer has per-manufacturer ASP support (i.e.
//                            ASP support just based on its manufacturer name, rather than per model.
//
// Caller allocs memory for pAspPage.
//
// - pASPPage untouched if failure.
//
BOOL Casphelp::IsCustomASP( BOOL bDeviceASP, LPTSTR pASPPage, DWORD cchBufSize )
{
    TCHAR  szRelPath   [MAX_PATH];    // Path relative to Winnt\web\printers, e.g. HP\LJ4si\page1.asp or .\hp (witout the .\)
    TCHAR  szFinalPath [MAX_PATH];    // Absolute path for szRelPath.
    TCHAR  szModel     [MAX_PATH];
    int    nLen;


    // The Printer virtual dir assumed to be winnt\web\printers. Construct it.

    if( !GetWindowsDirectory( szFinalPath, COUNTOF(szFinalPath)))      // Return value is the length in chars w/o null char.
        return FALSE;

    // Append web\printers to the end
    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), cszEverestVirRoot );

    // Prepare the relative path.

    if( !GetManufacturer( szRelPath, ARRAYSIZE(szRelPath)))
        return FALSE;

    if( bDeviceASP ) {

        // Add a '\' before we add the model name
        StringCchCat( szRelPath, ARRAYSIZE(szRelPath), L"\\" );

        // Append the Model name
        if( !GetModel(szModel, ARRAYSIZE(szModel)))
            return FALSE;
        StringCchCat( szRelPath, ARRAYSIZE(szRelPath), szModel );
    }

    // Append "page1.asp" to the end.
    StringCchCat( szRelPath, ARRAYSIZE(szRelPath), L"\\" );
    StringCchCat( szRelPath, ARRAYSIZE(szRelPath), DEFAULTASPPAGE );

    // At this point, szRelPath should be something like HP\LJ4si\page1.asp or HP\page1.asp.


    // Make an absolute path by concatanating szRelPath and szFinalPath
    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), L"\\" );
    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), szRelPath );

    // See if the file exists.
    if( (DWORD)(-1) == GetFileAttributes( szFinalPath ))
        return FALSE;     // The file does not exist
    else {
        // The file exists, so the printer has per device or per manufacturer customization.
        StringCchCopy( pASPPage, cchBufSize, szRelPath ); 
        return TRUE;
    }
}


//
// Returns:  The relative path to the default ASP file, i.e. page1.asp, if the printer supports RFC 1759.
//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::IsSnmpSupportedASP( LPTSTR pASPPage, DWORD cchBufSize )
{
    BOOL   fIsSNMPSupported;
    HRESULT hr;


    hr = get_SNMPSupported( &fIsSNMPSupported );

    if( FAILED( hr ))
        return FALSE;

    if( fIsSNMPSupported )
        StringCchCopy( pASPPage, cchBufSize, DEFAULTASPPAGE );
    else
        *pASPPage = 0;        // Return an empty string. Not an error case.

    return TRUE;
}


//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPageForUniversalMonitor( LPTSTR pASPPage, DWORD cchBufSize )
{
    if( !IsCustomASP( TRUE, pASPPage, cchBufSize ))              // Check for device ASP
        if( !IsCustomASP( FALSE, pASPPage, cchBufSize ))         // Check for manufacturer ASP
            if( !IsSnmpSupportedASP( pASPPage, cchBufSize ))     // Check for SNMP support
                return FALSE;

    return TRUE;
}

//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPageForOtherMonitors( LPTSTR pMonitorName, LPTSTR pASPPage, DWORD cchBufSize )
{
    TCHAR  szRelPath   [MAX_PATH];    // Path relative to Winnt\web\printers, e.g. LexmarkMon\page1.asp
    TCHAR  szFinalPath [MAX_PATH];    // Absolute path for szRelPath.
    int    nLen;


    // The Printer virtual dir assumed to be winnt\web\printers. Construct it.

    if( !GetWindowsDirectory( szFinalPath, COUNTOF(szFinalPath)))      // Return value is the length in chars w/o null char.
        return FALSE;

    // Append web\printers to the end

    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), cszEverestVirRoot );

    // Prepare the relative path.

    StringCchCopy( szRelPath, ARRAYSIZE(szRelPath), pMonitorName );

    // Append "page1.asp" to the end.
    StringCchCat( szRelPath, ARRAYSIZE(szRelPath), L"\\" );
    StringCchCat( szRelPath, ARRAYSIZE(szRelPath), DEFAULTASPPAGE );

    // At this point, szRelPath should be something like LexmarkMon\page1.asp


    // Make an absolute path by concatanating szRelPath and szFinalPath
    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), L"\\" );
    StringCchCat( szFinalPath, ARRAYSIZE(szFinalPath), szRelPath );

    // See if the file exists.
    if( (DWORD)(-1) == GetFileAttributes( szFinalPath ))
        return FALSE;     // The file does not exist
    else {
        // The file exists, so the printer has per device or per manufacturer customization.
        StringCchCopy( pASPPage, cchBufSize, szRelPath );
        return TRUE;
    }
}



//
// Returns a buffer containing the relative path of the ASP, or an empty string.
//
// Caller allocs memory for pAspPage.
//
// pASPPage untouched if failure.
//
BOOL Casphelp::GetASPPage( LPTSTR pASPPage, DWORD cchBufSize )
{

    if( m_bTCPMonSupported ) {
        // The printer is using the Universal monitor
        if( !GetASPPageForUniversalMonitor( pASPPage, cchBufSize ))
            return FALSE;
    }
    else {
        TCHAR szMonitorName[MAX_PATH];

        if ( !GetMonitorName( szMonitorName, ARRAYSIZE(szMonitorName)))
            return FALSE;

        // The printer is NOT using the Universal monitor
        if( !GetASPPageForOtherMonitors( szMonitorName, pASPPage, cchBufSize))
            return FALSE;

    }
    return TRUE;
}


// STDMETHODIMP means "HRESULT _stdcall"

STDMETHODIMP Casphelp::get_AspPage(DWORD dwPage, BSTR * pbstrVal)
{
    TCHAR   szASPPage[MAX_PATH];
    LPTSTR  pUrl;

    if (!pbstrVal)
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);

    if (m_hPrinter == NULL)
        return Error(IDS_NO_PRINTER_OPEN, IID_Iasphelp, E_HANDLE);

    if( !GetASPPage( szASPPage, ARRAYSIZE(szASPPage)))
        return Error(IDS_DATA_NOT_SUPPORTED, IID_Iasphelp, E_NOTIMPL);

    // Encode the URL by replacing ' ' with %20, etc.
    if (! (pUrl = EncodeString (szASPPage, TRUE)))
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);

    if (!(*pbstrVal = SysAllocString( pUrl ))) {
        LocalFree (pUrl);
        return Error(IDS_OUT_OF_MEMORY, IID_Iasphelp, E_POINTER);
    }

    if (pUrl)
        LocalFree (pUrl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\olecvt.cpp ===
// OleCvt.cpp : Implementation of COleCvt
#include "stdafx.h"
#include <strsafe.h>

#include "oleprn.h"
#include "OleCvt.h"


/////////////////////////////////////////////////////////////////////////////
// COleCvt

STDMETHODIMP COleCvt::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IOleCvt,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP COleCvt::OnStartPage (IUnknown* pUnk)
{
	if(!pUnk)
		return E_POINTER;

    if (m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER) 
        return E_ACCESSDENIED;

	CComPtr<IScriptingContext> spContext;
	HRESULT hr;

	// Get the IScriptingContext Interface
	hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
	if(FAILED(hr))
		return hr;

	// Get Request Object Pointer
	hr = spContext->get_Request(&m_piRequest);
	if(FAILED(hr))
	{
		spContext.Release();
		return hr;
	}

	// Get Response Object Pointer
	hr = spContext->get_Response(&m_piResponse);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		return hr;
	}
	
	// Get Server Object Pointer
	hr = spContext->get_Server(&m_piServer);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		return hr;
	}
	
	// Get Session Object Pointer
	hr = spContext->get_Session(&m_piSession);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		return hr;
	}

	// Get Application Object Pointer
	hr = spContext->get_Application(&m_piApplication);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		m_piSession.Release();
		return hr;
	}
	m_bOnStartPageCalled = TRUE;
	return S_OK;
}

STDMETHODIMP COleCvt::OnEndPage ()
{
    if (m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER) 
        return E_ACCESSDENIED;

	m_bOnStartPageCalled = FALSE;
	// Release all interfaces
	m_piRequest.Release();
	m_piResponse.Release();
	m_piServer.Release();
	m_piSession.Release();
	m_piApplication.Release();

	return S_OK;
}

HRESULT COleCvt::SetOleCvtScriptingError(DWORD dwError)
{
    return (SetScriptingError(CLSID_OleCvt, IID_IOleCvt, dwError));
}

STDMETHODIMP COleCvt::get_ToUtf8(BSTR bstrUnicode, BSTR * pVal)
{
    LPSTR   pszUtf8 = NULL;
    LPWSTR  pwszUnicodeStr = NULL;
    DWORD   rc;
    HRESULT hr = S_OK;

    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    // Convert the input unicode string to utf8
    if (! (rc = WideCharToMultiByte( CP_UTF8, 0, bstrUnicode, -1, NULL, 0, NULL, NULL ))) {
        goto Cleanup;
    }

    // Allocate the string
    if (! (pszUtf8 = (LPSTR) LocalAlloc (LPTR, rc)))
        goto Cleanup;

    if (! (rc = WideCharToMultiByte( CP_UTF8, 0, bstrUnicode, -1, pszUtf8, rc, NULL, NULL )))
        goto Cleanup;

    // Convert the string to unicode as if it is ANSI (preserve the UTF8 conversion)
    if (! (rc = MultiByteToWideChar( 1252, 0, pszUtf8, -1, NULL, 0)))
        goto Cleanup;

    // Allocate the string
    if (! (pwszUnicodeStr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * rc)))
        goto Cleanup;

    if (! (rc = MultiByteToWideChar( 1252, 0, pszUtf8, -1, pwszUnicodeStr, rc)))
        goto Cleanup;

    if (!(*pVal = SysAllocString (pwszUnicodeStr)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszUtf8)
        LocalFree (pszUtf8);
    if (pwszUnicodeStr)
        LocalFree (pwszUnicodeStr);

    return hr;
}

STDMETHODIMP COleCvt::get_EncodeUnicodeName(BSTR bstrSrcName, BSTR * pDstName)
{
    LPTSTR  pszEncodedName  = NULL;
    DWORD   dwSize          = 0;
    HRESULT hr              = S_OK;

    if (!bstrSrcName || !pDstName)
        return E_POINTER;

    EncodePrinterName (bstrSrcName, NULL, &dwSize);

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        goto Cleanup;

    if (!EncodePrinterName (bstrSrcName, pszEncodedName, &dwSize))
        goto Cleanup;

    if (!(*pDstName = SysAllocString (pszEncodedName)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return hr;
}

STDMETHODIMP COleCvt::get_DecodeUnicodeName(BSTR bstrSrcName, BSTR * pDstName)
{
    LPTSTR  pszDecodedName  = NULL;
    DWORD   dwSize          = 0;
    HRESULT hr              = S_OK;

    if (!bstrSrcName || !pDstName)
        return E_POINTER;

    DecodePrinterName (bstrSrcName, NULL, &dwSize);

    if (! (pszDecodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        goto Cleanup;

    if (!DecodePrinterName (bstrSrcName, pszDecodedName, &dwSize))
        goto Cleanup;

    if (!(*pDstName = SysAllocString (pszDecodedName)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszDecodedName) {
        LocalFree (pszDecodedName);
    }
    return hr;
}

// This function is to take the input string bstrString as if it wrer ANSI
// and then convert it back to unicode using whatever codepage specifed.
STDMETHODIMP COleCvt::get_ToUnicode(BSTR bstrString, long lCodePage, BSTR * pVal)
{
    LPSTR   pszStr = NULL;
    LPWSTR  pwszUnicodeStr = NULL;
    DWORD   rc;
    HRESULT hr = S_OK;

    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    // Convert the input unicode string to utf8
    if (! (rc = WideCharToMultiByte(CP_ACP, 0, bstrString, -1, NULL, 0, NULL, NULL ))) {
        goto Cleanup;
    }

    // Allocate the string
    if (! (pszStr = (LPSTR) LocalAlloc (LPTR, rc)))
        goto Cleanup;

    if (! (rc = WideCharToMultiByte( CP_ACP, 0, bstrString, -1, pszStr, rc, NULL, NULL )))
        goto Cleanup;

    // Convert the string to unicode as if it is ANSI (preserve the UTF8 conversion)
    if (! (rc = MultiByteToWideChar( lCodePage, 0, pszStr, -1, NULL, 0)))
        goto Cleanup;

    // Allocate the string
    if (! (pwszUnicodeStr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * rc)))
        goto Cleanup;

    if (! (rc = MultiByteToWideChar( lCodePage, 0, pszStr, -1, pwszUnicodeStr, rc)))
        goto Cleanup;

    if (!(*pVal = SysAllocString (pwszUnicodeStr)))
        goto Cleanup;

    SetLastError (ERROR_SUCCESS);

Cleanup:
    if (GetLastError () != ERROR_SUCCESS)
        hr = SetOleCvtScriptingError (GetLastError ());

    if (pszStr)
        LocalFree (pszStr);
    if (pwszUnicodeStr)
        LocalFree (pwszUnicodeStr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\oleinst.h ===
// oleInst.h : Declaration of the COleInstall

#ifndef __OLEINSTALL_H_
#define __OLEINSTALL_H_

#include "CPinst.h"         // Template for connection point

#define WM_ON_PROGRESS      (WM_USER+100)
#define WM_INSTALL_ERROR    (WM_USER+101)

#define FILEBUFSIZE                 1024
#define MAX_INET_RETRY              3
#define RET_SUCCESS                 1
#define RET_SERVER_ERROR            2
#define RET_OTHER_ERROR             3

typedef class  OleInstallData {
public:
    LONG        m_lCount;
    LPTSTR      m_pszTempWebpnpFile;
    LPTSTR      m_pPrinterUncName;
    LPTSTR      m_pPrinterUrl;
    HWND        m_hwnd;
    BOOL        m_bValid;
    BOOL        m_bRPC;         // Should we do an RPC install?

    OleInstallData (LPTSTR      pPrinterUncName,
                    LPTSTR      pPrinterUrl,
                    HWND        hwnd,
                    BOOL        m_bRPC);
    ~OleInstallData ();

} OleInstallData;


/////////////////////////////////////////////////////////////////////////////
// COleInstall
class ATL_NO_VTABLE COleInstall :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<COleInstall, &CLSID_OleInstall>,
    public COlePrnSecComControl<COleInstall>,
    public IDispatchImpl<IOleInstall, &IID_IOleInstall, &LIBID_OLEPRNLib>,
    public IProvideClassInfo2Impl<&CLSID_OleInstall, &DIID__InstallEvent, &LIBID_OLEPRNLib>,
    public IPersistStreamInitImpl<COleInstall>,
    public IPersistStorageImpl<COleInstall>,
    public IQuickActivateImpl<COleInstall>,
    public IOleControlImpl<COleInstall>,
    public IOleObjectImpl<COleInstall>,
    public IOleInPlaceActiveObjectImpl<COleInstall>,
    public IViewObjectExImpl<COleInstall>,
    public IOleInPlaceObjectWindowlessImpl<COleInstall>,
    public IDataObjectImpl<COleInstall>,
    public ISpecifyPropertyPagesImpl<COleInstall>,
    public CProxy_InstallEvents<COleInstall>,
    public IConnectionPointContainerImpl<COleInstall>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_OLEINSTALL)

BEGIN_COM_MAP(COleInstall)
    COM_INTERFACE_ENTRY(IOleInstall)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(COleInstall)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(COleInstall)
   CONNECTION_POINT_ENTRY(DIID__InstallEvent)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(COleInstall)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IOleInstall
public:
    STDMETHOD(OpenPrintersFolder)();
    STDMETHOD(InstallPrinter)(BSTR pbstrUncName, BSTR pbstrUrl);

    COleInstall();
    ~COleInstall();
    HRESULT     OnDraw(ATL_DRAWINFO& di);

private:
    HWND m_hwnd;
    LPTSTR      m_pPrinterUncName;          // holds the printers'UNC name
    LPTSTR      m_pPrinterUrl;              // holds the printer URL
    OleInstallData *m_pThreadData;

    HRESULT             InitWin (BOOL bRPC);

    static LRESULT CALLBACK WndProc(
                            HWND hWnd,
                            UINT uMsg,
                            WPARAM wParam,
                            LPARAM lParam);

    static BOOL         WorkingThread(
                            void * pParam);

    static BOOL         StartInstall(
                            OleInstallData *pThreadData);

    static BOOL         SyncExecute(
                            LPTSTR pszFileName,
                            int nShow);

    static DWORD        GetWebpnpFile(
                            OleInstallData *pData,
                            LPTSTR pszURL,
                            LPTSTR *ppErrMsg);

    static HANDLE       GetTempFile(
                            LPTSTR pExtension,
                            LPTSTR * ppFileName);

    static BOOL         IsHttpPreferred(void);

    static BOOL         GetHttpPrinterFile(
                            OleInstallData *pData,
                            LPTSTR pbstrURL);

    static BOOL         InstallHttpPrinter(
                            OleInstallData *pData);

    static BOOL         CheckAndSetDefaultPrinter(void);

    static BOOL         UpdateUI (
                            OleInstallData *pData,
                            UINT message,
                            WPARAM wParam);

    static BOOL         UpdateProgress (
                            OleInstallData *pData,
                            DWORD dwProgress);

    static BOOL         UpdateError (
                            OleInstallData *pData);

    HRESULT             CanIOpenPrintersFolder(void);

    HRESULT             CanIInstallRPC(IN LPTSTR lpszPrinterUNC);

    HRESULT             GetServerNameFromUNC(
                            IN     LPTSTR   pszUNC,
                            IN OUT LPTSTR  *ppszServerName);

    HRESULT             CheckServerForSpooler(
                            IN  LPTSTR   pszServerName);

    static LPTSTR       RemoveURLVars(LPTSTR);      // Get rid of everything after ?

    static LPTSTR       GetNTPrint(void);

    static LPTSTR       CreatePrinterBaseName(
                            LPCTSTR lpszPrinterURL,
                            LPCTSTR lpszPrinterName);

};


#endif //__OLEINSTALL_H_

/******************************************************************
** End of File (oleinst.h)
******************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\oleprn.cpp ===
// oleprn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//  To build a separate proxy/stub DLL,
//  run nmake -f oleprnps.mk in the project directory.

#include "stdafx.h"
#include "stdafx.cpp"
#include <strsafe.h>
#include "prnsec.h"
#include "gensph.h"

#include "initguid.h"
#include "comcat.h"
#include "objsafe.h"

#include "oleprn.h"

#include "oleprn_i.c"

#include "prturl.h"

#include "olesnmp.h"
#include "asphelp.h"
#include "DSPrintQ.h"
#include "OleCvt.h"

#include "oleInst.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_prturl, Cprturl)
    OBJECT_ENTRY(CLSID_SNMP, CSNMP)
    OBJECT_ENTRY(CLSID_asphelp, Casphelp)
    OBJECT_ENTRY(CLSID_DSPrintQueue, CDSPrintQueue)
    OBJECT_ENTRY(CLSID_OleCvt, COleCvt)
    OBJECT_ENTRY(CLSID_OleInstall, COleInstall)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL bRet = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        bRet = COlePrnSecurity::InitStrings();
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
        COlePrnSecurity::DeallocStrings();
    }
        
    return bRet;    
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (FAILED(hr))
        return hr;    // Make sure the HKCR\Component Categories\{..catid...}

    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    int len = wcslen(catDescription);

    if (len>127)
        len = 127;

    wcsncpy(catinfo.szDescription, catDescription, len);

    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';
    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();
    return hr;
}

HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    // Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (SUCCEEDED(hr)) {
        // Register this category as being "implemented" by
        // the class.

        CATID rgcatid[1] ;
        rgcatid[0] = catid;
        hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
    return hr;
}

HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICatRegister,
                          (void**)&pcr);

    if (SUCCEEDED(hr)) {
        // Unregister this category as being "implemented" by
        // the class.

        CATID rgcatid[1] ;
        rgcatid[0] = catid;

        hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // Mark as safe for scripting failure OK.
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib
    hr =  _Module.RegisterServer(TRUE);

    if (FAILED(hr)) return hr;

    // After we successfully register it, add the "safe* for scripting" feature
    hr = CreateComponentCategory(CATID_SafeForScripting,
                                 L"Controls that are safely scriptable");

    if (SUCCEEDED(hr)) {
        RegisterCLSIDInCategory(CLSID_prturl, CATID_SafeForScripting);
    }

    hr = CreateComponentCategory(CATID_SafeForInitializing,
                                 L"Controls safely initializable from persistent data");

    if (SUCCEEDED(hr)) {
        RegisterCLSIDInCategory(CLSID_prturl, CATID_SafeForInitializing);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    UnRegisterCLSIDInCategory (CLSID_prturl, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory (CLSID_prturl, CATID_SafeForInitializing);
    
    _Module.UnregisterServer();
    return S_OK;
}

/*****************************************************************************\
*
* These function are for linking with spllib.
*
\*****************************************************************************/
EXTERN_C
LPVOID
DllAllocSplMem(
    DWORD cb
    )
{
	return LocalAlloc(LPTR, cb);
}

EXTERN_C
BOOL
DllFreeSplMem(
   LPVOID pMem
   )
{
	LocalFree(pMem);

	return TRUE;
}


EXTERN_C
BOOL
DllFreeSplStr(
   LPWSTR lpStr
   )
{
	LocalFree(lpStr);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\olesnmp.h ===
/*****************************************************************************\
* MODULE:       olesnmp.h
*
* PURPOSE:      Declaration of the CSNMP
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Moved to oleprn.dll
*     02/14/01  weihaic    Added GetAsByte
*
\*****************************************************************************/

#ifndef __OLESNMP_H_
#define __OLESNMP_H_

/////////////////////////////////////////////////////////////////////////////
// CSNMP
class ATL_NO_VTABLE CSNMP :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSNMP, &CLSID_SNMP>,
    public ISupportErrorInfoImpl<&IID_ISNMP>,
    public IDispatchImpl<ISNMP, &IID_ISNMP, &LIBID_OLEPRNLib>
{
public:
    CSNMP(
        VOID
        );

    ~CSNMP(
        VOID
        );

    DECLARE_REGISTRY_RESOURCEID(IDR_SNMP)

    BEGIN_COM_MAP(CSNMP)
        COM_INTERFACE_ENTRY(ISNMP)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

// ISNMP
public:
    STDMETHOD(Open)(
        IN  BSTR bstrHost,
        IN  BSTR bstrCommunity,
        IN  VARIANT varRetry,
        IN  VARIANT varTimeout
        );

    STDMETHOD(OIDFromString)(
        IN  BSTR bstrOID,
        OUT VARIANT *pvarOID
        );

    STDMETHOD(Close)(
        VOID
        );

    STDMETHOD(Get)(
        IN  BSTR bstrOID,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(GetList)(
        IN  VARIANT *pvarList,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(GetTree)(
        IN  BSTR varTree,
        OUT VARIANT *pvarValue
        );

    STDMETHOD(Set)(
        IN  BSTR bstrOID,
        OUT VARIANT varValue
        );

    STDMETHOD(SetList)(
        IN  VARIANT *pvarName,
        IN  VARIANT *pvarValue
        );

    STDMETHOD(GetAsByte)(
        IN  BSTR bstrOID,
        OUT PUINT puValue
        );

private:

    HRESULT
    RfcToVarList (
        long lbound,
        RFC1157VarBindList * prfcVarList,
        SAFEARRAY  *psaOut);

    HRESULT
    VarToRfcVarList (
        long lbound,
        long ubound,
        SAFEARRAY  *psa,
        RFC1157VarBindList * prfcVarList
        );

    HRESULT
    SetSnmpScriptError (
        DWORD dwError
        );

    HRESULT
    SetWinSnmpApiError(
        DWORD dwError
        );

    static HRESULT
    VariantToRFC1157 (
        RFC1157VarBind *varb,
        VARIANT *var
        );

    static HRESULT
    RFC1157ToUInt(
        PUINT puValue,
        RFC1157VarBind * prfcvbValue
        );

    static HRESULT
    VarListAdd(
        BSTR bstrOID,
        RFC1157VarBindList *vl,
        VARIANT *v = NULL
        );

    static HRESULT
    RFC1157ToVariant(
        VARIANT *v,
        RFC1157VarBind *varb
        );

    LPSNMP_MGR_SESSION m_SNMPSession;
};


#endif //__SNMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\oleinst.cpp ===
// oleInst.cpp : Implementation of COleInstall
#include "stdafx.h"
#include <strsafe.h>
#include "prnsec.h"

#include "oleprn.h"
#include "oleInst.h"
#include "printer.h"

/////////////////////////////////////////////////////////////////////////////
// COleInstall

const TCHAR * const g_szWindowClassName = TEXT("Ole Install Control");
const TCHAR * const g_fmtSpoolSSPipe = TEXT("\\\\%s\\PIPE\\SPOOLSS");
const DWORD cdwSucessExitCode = 0xFFFFFFFF;

typedef DWORD (*pfnPrintUIEntry)(HWND,HINSTANCE,LPCTSTR,UINT);

OleInstallData::OleInstallData (
    LPTSTR      pPrinterUncName,
    LPTSTR      pPrinterUrl,
    HWND        hwnd,
    BOOL        bRPC)
    :m_lCount (2),
    m_pPrinterUncName (NULL),
    m_pPrinterUrl (NULL),
    m_pszTempWebpnpFile (NULL),
    m_hwnd (hwnd),
    m_bValid (FALSE),
    m_bRPC(bRPC)
{
    if (AssignString (m_pPrinterUncName, pPrinterUncName)
        && AssignString (m_pPrinterUrl, pPrinterUrl))
        m_bValid = TRUE;
}

OleInstallData::~OleInstallData ()
{
    if (m_pszTempWebpnpFile) {
        DeleteFile (m_pszTempWebpnpFile);
        LocalFree (m_pszTempWebpnpFile);
    }

    LocalFree (m_pPrinterUncName);
    LocalFree (m_pPrinterUrl);
}


COleInstall::COleInstall()
            : m_hwnd (NULL),
              m_pPrinterUncName (NULL),
              m_pPrinterUrl (NULL),
              m_pThreadData (NULL)

{
    DisplayUIonDisallow(FALSE);         // We don't want IE displaying UI.
}

COleInstall::~COleInstall()
{
    if(m_hwnd)
    {
        if (m_pThreadData) {
            m_pThreadData->m_hwnd = NULL;
        }

        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }


    LocalFree (m_pPrinterUncName);
    LocalFree (m_pPrinterUrl);

    if (m_pThreadData) {
        if (InterlockedDecrement (& (m_pThreadData->m_lCount)) == 0) {
            delete (m_pThreadData);
        }
    }
}

HRESULT
COleInstall::OnDraw(
    ATL_DRAWINFO& di)
{
    return S_OK;
}


BOOL
COleInstall::UpdateUI (
    OleInstallData *pData,
    UINT message,
    WPARAM wParam)
{
    BOOL bRet = FALSE;

    if (pData->m_hwnd) {
        ::SendMessage (pData->m_hwnd, message, wParam, NULL);
        bRet =  TRUE;
    }

    return bRet;
}

BOOL
COleInstall::UpdateProgress (
    OleInstallData *pData,
    DWORD dwProgress)
{
    return UpdateUI (pData, WM_ON_PROGRESS, dwProgress);
}

BOOL
COleInstall::UpdateError (
    OleInstallData *pData)
{
    return UpdateUI (pData, WM_INSTALL_ERROR, GetLastError ());
}

HRESULT
COleInstall::InitWin (BOOL bRPC)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwThreadId;
    HANDLE      hThread = NULL;
    WNDCLASS    wc;

    // Create Window Class
    if (!::GetClassInfo(_Module.GetModuleInstance(), g_szWindowClassName, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = COleInstall::WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = g_szWindowClassName;

        if (!RegisterClass(&wc)) {
            return hr;
        }
    }

    m_hwnd = CreateWindow(g_szWindowClassName,
                          NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                          _Module.GetModuleInstance(), this);

    if (m_hwnd) {

        m_pThreadData = new OleInstallData (m_pPrinterUncName,
                                            m_pPrinterUrl,
                                            m_hwnd,
                                            bRPC);

        if (m_pThreadData && m_pThreadData->m_bValid) {

            if (hThread = ::CreateThread (NULL,
                                          0,
                                          (LPTHREAD_START_ROUTINE) &COleInstall::WorkingThread,
                                          m_pThreadData,
                                          0,
                                          &dwThreadId)) {
                CloseHandle (hThread);
                hr = S_OK;
            }
        }
    }

    return hr;

}


BOOL
COleInstall::WorkingThread(
    void * param)
{
    OleInstallData * pThreadData = (OleInstallData *) param;
    BOOL bRet = FALSE;

    if (pThreadData) {
        bRet = StartInstall (pThreadData);
    }

    return bRet;
}


BOOL
COleInstall::StartInstall(
                         OleInstallData *pThreadData)
{
    HANDLE hServer = NULL;
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    BOOL bRet = FALSE;

    CPrinter        Printer;
    HANDLE          hPrinter;
    PPRINTER_INFO_2 pPrinterInfo2  = NULL;
    LPTSTR          lpszPrinterURL = NULL;

    // Working thread
    if (!UpdateProgress (pThreadData, 0))
        goto Cleanup;

    //
    // Check if we are to try RPC or HTTP
    //
    if (pThreadData->m_bRPC)
    {
        // Check RPC connections at first
        if (::AddPrinterConnection( (BSTR)pThreadData->m_pPrinterUncName))
        {
            UpdateProgress (pThreadData, 50);
            if (CheckAndSetDefaultPrinter ())
            {
                UpdateProgress (pThreadData, 100);
                bRet = TRUE;
            }
            goto Cleanup;
        }
    }
    else
    {
        //
        // Install using HTTP
        //
        // Since http installation always requires
        // administrator privilidge, We have to do a access check before we
        // try to down load the cab file

        if (!OpenPrinter (NULL, &hServer, &pd))
        {
            // If this fails and it is because we do not have access, we should send a better error
            // message to the local user telling them that the do not have the ability to create
            // printers on the local machine

            if (GetLastError() == ERROR_ACCESS_DENIED)
            {
                SetLastError(ERROR_LOCAL_PRINTER_ACCESS);
            }
            goto Cleanup;
        }
        else
            ClosePrinter (hServer);

        //
        // Try the local CAB installation instead of downloading the cab, etc.
        // Need admin privaleges.
        //
        if ( NULL != (lpszPrinterURL = RemoveURLVars( pThreadData->m_pPrinterUrl )) &&
             Printer.Open( lpszPrinterURL, &hPrinter ) )
        {

            LPTSTR lpszInfName            = NULL;
            LPTSTR lpszPrinterName        = NULL;

            pPrinterInfo2 = Printer.GetPrinterInfo2();
            if ((pPrinterInfo2 == NULL) && (GetLastError () == ERROR_ACCESS_DENIED))
            {
                if (!ConfigurePort( NULL, pThreadData->m_hwnd, lpszPrinterURL ))
                {
                    bRet = FALSE;
                    goto Cleanup;
                }
                pPrinterInfo2 = Printer.GetPrinterInfo2();
            }

            if ( (NULL != pPrinterInfo2) &&
                 (NULL != (lpszInfName     = GetNTPrint()))   &&
                 (NULL != (lpszPrinterName = CreatePrinterBaseName(lpszPrinterURL, pPrinterInfo2->pPrinterName))) )
            {

                LPTSTR          lpszCmd       = NULL;
                DWORD           dwLength      = 0;
                TCHAR           szCmdString[] = _TEXT("/if /x /b \"%s\" /r \"%s\" /m \"%s\" /n \"%s\" /f %s /q");
                HMODULE         hPrintUI      = NULL;
                pfnPrintUIEntry PrintUIEntry;

                dwLength = lstrlen( szCmdString )                    +
                           lstrlen( lpszPrinterName )                +
                           lstrlen( pPrinterInfo2->pPortName )       +
                           lstrlen( pPrinterInfo2->pDriverName )     +
                           lstrlen( pThreadData->m_pPrinterUncName ) +
                           lstrlen( lpszInfName )                    + 1;

                if ( (lpszCmd  = (LPTSTR)LocalAlloc( LPTR, dwLength*sizeof(TCHAR) )) &&
                     (hPrintUI = LoadLibraryFromSystem32( TEXT("printui.dll") )) )
                {

                    StringCchPrintf( lpszCmd,
                                     dwLength,
                                     szCmdString,
                                     lpszPrinterName,
                                     pPrinterInfo2->pPortName,
                                     pPrinterInfo2->pDriverName,
                                     pThreadData->m_pPrinterUncName,
                                     lpszInfName );

                    if ( PrintUIEntry = (pfnPrintUIEntry)GetProcAddress(hPrintUI, "PrintUIEntryW") )
                    {
                        if ( ERROR_SUCCESS == (*PrintUIEntry)( NULL,
                                                               0,
                                                               lpszCmd,
                                                               SW_HIDE ) )
                        {
                            UpdateProgress (pThreadData, 50);
                            if (CheckAndSetDefaultPrinter ())
                            {
                                UpdateProgress (pThreadData, 100);
                                bRet = TRUE;
                            }
                        }
                    }
                }
                if ( lpszCmd )
                    LocalFree( lpszCmd );

                if ( hPrintUI )
                    FreeLibrary( hPrintUI );
            }
            if ( lpszInfName )
                LocalFree( lpszInfName );

            if ( lpszPrinterName )
                LocalFree( lpszPrinterName );
        }

        if ( lpszPrinterURL )
            LocalFree(lpszPrinterURL);

        if ( bRet )
            goto Cleanup;

        if (UpdateProgress (pThreadData, 25))
        {

            // Step two, the Local CAB install failed so download a driver and install
            if (GetHttpPrinterFile (pThreadData, pThreadData->m_pPrinterUrl))
            {

                if (UpdateProgress (pThreadData, 60))
                {

                    if (InstallHttpPrinter (pThreadData))
                    {

                        if (UpdateProgress (pThreadData, 90))
                        {

                            if (CheckAndSetDefaultPrinter ())
                            {
                                UpdateProgress (pThreadData, 100);
                                bRet = TRUE;
                            }
                        }
                    }
                }
            }
        }

    }


    Cleanup:
    if (!bRet)
    {
        UpdateError (pThreadData);
    }

    // Cleanup the ThreadData
    if (InterlockedDecrement (& (pThreadData->m_lCount)) == 0)
    {
        delete (pThreadData);
    }

    return bRet;
}


LRESULT CALLBACK
COleInstall::WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    COleInstall *ptc = (COleInstall *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (COleInstall *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, (UINT_PTR) ptc);
        }
        break;

    case WM_ON_PROGRESS:
        if (ptc)
            ptc->Fire_OnProgress ((long) wParam);
        break;

    case WM_INSTALL_ERROR:
        if (ptc)
            ptc->Fire_InstallError ((long) wParam);
        break;

    case WM_DESTROY:
        // ignore late messages
        if(ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hWnd, WM_ON_PROGRESS, WM_INSTALL_ERROR, PM_REMOVE));
            ::SetWindowLongPtr (hWnd, GWLP_USERDATA, NULL);
        }
        break;

    default:
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

STDMETHODIMP
COleInstall::InstallPrinter(
    BSTR bstrUncName,
    BSTR bstrUrl)
{
    HRESULT hr = bstrUncName && bstrUrl ? S_OK : E_POINTER;

    if (SUCCEEDED(hr))
    {
        // When using an ATL string conversion Macro, spedcify the USES_CONVERSION macro
        // to avoid compiler error
        USES_CONVERSION;

        hr = AssignString(m_pPrinterUncName, OLE2T(bstrUncName)) && AssignString(m_pPrinterUrl, OLE2T(bstrUrl)) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = CanIInstallRPC(m_pPrinterUncName); // Determine whether to use RPC or HTTP.
    }

    if (SUCCEEDED(hr))
    {
        BOOL    bRPC = hr == S_OK;
        LPTSTR  lpszDisplay = NULL;
        LPTSTR  lpszTemp = NULL;
        DWORD   cchSize = 0;

        if (bRPC)
        {
            cchSize = lstrlen(m_pPrinterUncName) + 1;
            lpszDisplay = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchSize);
            hr = lpszDisplay ? S_OK : E_OUTOFMEMORY;

            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(lpszDisplay, cchSize, m_pPrinterUncName);
            }
        }
        else
        {
            //
            // If it's a URL printer name, we need to remove any variables embedded in the
            // URL and also decode it to remove those ~-escaped characters.
            //
            lpszTemp = RemoveURLVars(m_pPrinterUrl);
            hr = lpszTemp ? S_OK : E_OUTOFMEMORY;

            if (SUCCEEDED(hr))
            {
                //
                // This call is to ask for the required size for this decoding. It has to fail and
                // return ERROR_INSUFFICIENT_BUFFER, otherwise, something is wrong.
                //
                hr = DecodePrinterName(lpszTemp, NULL, &cchSize) ? E_FAIL : GetLastErrorAsHResultAndFail();

                if (FAILED(hr) && HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)
                {
                    lpszDisplay = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchSize);
                    hr = lpszDisplay ? S_OK : E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = DecodePrinterName(lpszTemp, lpszDisplay, &cchSize) ? S_OK : GetLastErrorAsHResultAndFail();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = PromptUser(bRPC ? AddPrinterConnection : AddWebPrinterConnection, lpszDisplay);
        }

        LocalFree(lpszTemp);
        LocalFree(lpszDisplay);

        if (hr == S_OK)
        {
            hr = InitWin(bRPC);
        }
        else if (hr == S_FALSE)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSTALL_USEREXIT);
        }
    }

    return hr;
}


STDMETHODIMP
COleInstall::OpenPrintersFolder()
{
    HRESULT hr;

    if (FAILED(hr = CanIOpenPrintersFolder()))
        return hr;          // We allow JAVALOW/JAVAMEDIUM to open the printers folder

    LPITEMIDLIST pidl = NULL;
    HWND         hwnd = GetDesktopWindow ();

    hr   = SHGetSpecialFolderLocation( hwnd, CSIDL_PRINTERS, &pidl );

    if (SUCCEEDED(hr))
    {
        SHELLEXECUTEINFO ei = {0};

        ei.cbSize   = sizeof(SHELLEXECUTEINFO);
        ei.fMask    = SEE_MASK_IDLIST;
        ei.hwnd     = hwnd;
        ei.lpIDList = (LPVOID)pidl;
        ei.nShow    = SW_SHOWNORMAL;

        if (!ShellExecuteEx(&ei))
            hr = E_FAIL;
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//          Private Member Functions
/////////////////////////////////////////////////////////////////////////////

BOOL
COleInstall::SyncExecute(
    LPTSTR pszFileName,
    int nShow)
{
    SHELLEXECUTEINFO shellExeInfo;
    DWORD            dwErrorCode;
    BOOL             bRet = FALSE;
    HWND             hWndForeground, hWndParent, hWndOwner, hWndLastPopup;

    //
    // We need to get the window handle of the current process to pass to the installation code,
    // otherwise any UI (e.g. driver signing pop ups) won't have focus of the IE frame.
    //

    // get the foreground window first
    hWndForeground = ::GetForegroundWindow();

    // climb up to the top parent in case it's a child window...
    hWndParent = hWndForeground;
    while( hWndParent = ::GetParent(hWndParent) ) {
        hWndForeground = hWndParent;
    }

    // get the owner in case the top parent is owned
    hWndOwner = ::GetWindow(::GetParent(hWndForeground), GW_OWNER);
    if( hWndOwner ) {
        hWndForeground = hWndOwner;
    }

    // get the last popup of the owner window
    hWndLastPopup = ::GetLastActivePopup(hWndForeground);

    ZeroMemory (&shellExeInfo, sizeof (SHELLEXECUTEINFO));
    shellExeInfo.cbSize     = sizeof (SHELLEXECUTEINFO);
    shellExeInfo.hwnd       = hWndLastPopup;
    shellExeInfo.lpVerb     = TEXT ("open");
    shellExeInfo.lpFile     = pszFileName;
    shellExeInfo.fMask      = SEE_MASK_NOCLOSEPROCESS;
    shellExeInfo.nShow      = nShow;

    if (ShellExecuteEx (&shellExeInfo) &&
        (UINT_PTR) shellExeInfo.hInstApp > 32) {

        // Wait until it is done
        if (!WaitForSingleObject (shellExeInfo.hProcess , INFINITE) &&
            GetExitCodeProcess (shellExeInfo.hProcess, &dwErrorCode)) {

            if (dwErrorCode == cdwSucessExitCode) {
                bRet = TRUE;
            }
            else {
                if (!dwErrorCode) {
                    // This means that wpnpinst was terminated abnormally
                    // So we have to setup an customized error code here.
                    dwErrorCode = ERROR_WPNPINST_TERMINATED;
                }
                SetLastError (dwErrorCode);
            }
        }

        if (shellExeInfo.hProcess) {
            ::CloseHandle(shellExeInfo.hProcess);
        }
    }
    return bRet;
}

DWORD
COleInstall::GetWebpnpFile(
    OleInstallData *pData,
    LPTSTR pszURL,
    LPTSTR *ppErrMsg)
{
    HINTERNET   hUrlWebpnp   = NULL;
    HINTERNET   hHandle      = NULL;
    HANDLE      hFile        = INVALID_HANDLE_VALUE;
    DWORD       dwSize       = 0;
    DWORD       dwWritten    = 0;
    LPTSTR      pszHeader    = NULL;
    BOOL        bRet;
    BOOL        bRetry       = TRUE;
    DWORD       dwRet        = RET_OTHER_ERROR;
    DWORD       dwError      = ERROR_SUCCESS;
    DWORD       dwLastError;
    DWORD i;
    BYTE buf[FILEBUFSIZE];

    *ppErrMsg = NULL;

    if (! (hHandle = InternetOpen (TEXT ("Internet Add Printer"),
                                   INTERNET_OPEN_TYPE_PRECONFIG,
                                   NULL, NULL, 0)))
        goto Cleanup;


    for (i = 0; bRetry ; i++) {
        DWORD dwCode;
        DWORD dwBufSize = sizeof (DWORD);

        hUrlWebpnp = InternetOpenUrl (hHandle, pszURL, NULL, 0, 0, 0);


        if (!HttpQueryInfo(hUrlWebpnp,
                           HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
                           &dwCode,
                           &dwBufSize,
                           NULL))
            goto Cleanup;

        switch (dwCode) {
        case HTTP_STATUS_OK :
            bRetry = FALSE;
            break;
        case HTTP_STATUS_SERVER_ERROR :
            // Errors are returned by the server
            // Try to get the error string

            dwBufSize = 0;
            bRet =  HttpQueryInfo(hUrlWebpnp,
                                  HTTP_QUERY_STATUS_TEXT,
                                  NULL,
                                  &dwBufSize,
                                  NULL);

            if (!bRet && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {
                if (!(pszHeader = (LPTSTR) LocalAlloc( LPTR, dwBufSize)))
                    goto Cleanup;

                *ppErrMsg = pszHeader;

                if (! HttpQueryInfo(hUrlWebpnp,
                                    HTTP_QUERY_STATUS_TEXT,
                                    pszHeader,
                                    &dwBufSize,
                                    NULL))
                    goto Cleanup;

                dwRet = RET_SERVER_ERROR;
                goto Cleanup;
            }
            else
                goto Cleanup;

            break;
        case HTTP_STATUS_DENIED :
        case HTTP_STATUS_PROXY_AUTH_REQ :
            dwError = InternetErrorDlg(GetDesktopWindow(), hUrlWebpnp,
                                       hUrlWebpnp? ERROR_SUCCESS : GetLastError(),
                                       FLAGS_ERROR_UI_FILTER_FOR_ERRORS |
                                       FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                                       FLAGS_ERROR_UI_FLAGS_GENERATE_DATA,
                                       NULL);

            switch (dwError) {
            case ERROR_INTERNET_FORCE_RETRY:
                if (i >= MAX_INET_RETRY) {
                    goto Cleanup;
                }
                break;
            case ERROR_SUCCESS:
                bRetry = FALSE;
                break;
            case ERROR_CANCELLED:
            default:
                goto Cleanup;
            }
            break;
        default:
            goto Cleanup;
        }

    }

    if (!UpdateProgress (pData, 35))
        goto Cleanup;

    if ( INVALID_HANDLE_VALUE ==
         (hFile = GetTempFile(TEXT (".webpnp"),  &(pData->m_pszTempWebpnpFile))))
        goto Cleanup;

    dwSize = FILEBUFSIZE;
    while (dwSize == FILEBUFSIZE) {
        if (! InternetReadFile (hUrlWebpnp, (LPVOID)buf, FILEBUFSIZE, &dwSize)) {
            goto Cleanup;
        }

        if (! (pData->m_hwnd)) {
            goto Cleanup;
        }

        if (! WriteFile (hFile, buf, dwSize, &dwWritten, NULL)) {
            goto Cleanup;
        }
    }
    CloseHandle (hFile);
    hFile = INVALID_HANDLE_VALUE;

    dwRet = RET_SUCCESS;

Cleanup:

    dwLastError = GetLastError ();

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);
    if (hUrlWebpnp)
        InternetCloseHandle (hUrlWebpnp);
    if (hHandle)
        InternetCloseHandle (hHandle);

    SetLastError (dwLastError);

    if (dwRet == RET_OTHER_ERROR && GetLastError () == ERROR_SUCCESS) {
        SetLastError (ERROR_ACCESS_DENIED);
    }

    return dwRet;
}

HANDLE
COleInstall::GetTempFile(
    LPTSTR pExtension,
    LPTSTR * ppFileName)
{
    HANDLE      hServer         = NULL;
    PRINTER_DEFAULTS prDefaults = {0};      // Used to test access rights to the printer
    DWORD       dwType          = 0;        // This is the type of the string

    HANDLE      hFile           = INVALID_HANDLE_VALUE;
    LPTSTR      pszTempDir      = NULL;
    LPTSTR      pszTempFname    = NULL;
    GUID        guid            = GUID_NULL;
    LPOLESTR    pszGUID         = NULL;

    DWORD       dwAllocated     = 0;    // This is the total number of characters allocated (not byte-size).
    DWORD       dwTempLen       = 0;    // This is the new size of the string
    DWORD       dwTempSize      = 0;    // This is the Size of the return String

    // First we want to open the local print server and ensure that we have access to it
    prDefaults.pDatatype = NULL;
    prDefaults.pDevMode  = NULL;
    prDefaults.DesiredAccess =  SERVER_ACCESS_ADMINISTER;

    *ppFileName = NULL;

    // Open the local spooler to get a handle to it
    if (!OpenPrinter( NULL, &hServer, &prDefaults)) {
        hServer = NULL; // Open Printer returns NULL and not INVALID_HANDLE_VALUE for a failure
        goto Cleanup;   // OpenPrinter will SetLastError to the reason why we couldn't open
    }

    // Get the size of the buffer we will need to copy the printer data
    if (ERROR_MORE_DATA !=
        GetPrinterData( hServer, SPLREG_DEFAULT_SPOOL_DIRECTORY, &dwType, NULL, 0, &dwTempSize)) {
        goto Cleanup;
    }

    // If it's something other than a simple string, set the error to a database error
    if (dwType != REG_SZ) {
        SetLastError(ERROR_BADDB);
        goto Cleanup;
    }

    // Allocate memory for the directory string.
    if (! (pszTempDir = (LPTSTR) LocalAlloc( LPTR, dwTempSize )))
        goto Cleanup;

    if (ERROR_SUCCESS !=
        GetPrinterData( hServer, SPLREG_DEFAULT_SPOOL_DIRECTORY, &dwType, (LPBYTE)pszTempDir,
                        dwTempSize, &dwTempLen))
        goto Cleanup; // For some reason we could not get the data

    ClosePrinter(hServer);
    hServer = NULL;

    if ( FAILED( ::CoCreateGuid( &guid )))
        goto Cleanup;

    if ( FAILED( ::StringFromCLSID( guid, &pszGUID )))
        goto Cleanup;

    dwAllocated = lstrlen( pszTempDir ) + 1 + lstrlen( pszGUID ) + lstrlen ( pExtension ) + 1;

    if (! (pszTempFname = (LPTSTR) LocalAlloc( LPTR, sizeof (TCHAR) * dwAllocated )) )
        goto Cleanup;

    if ( FAILED ( StringCchPrintf( pszTempFname,
                                   dwAllocated,
                                   TEXT("%s\\%s%s"),
                                   pszTempDir,
                                   pszGUID,
                                   pExtension )))
        goto Cleanup;

    hFile = CreateFile( pszTempFname,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( !hFile || hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    LocalFree (pszTempDir);
    ::CoTaskMemFree(pszGUID);

    *ppFileName = pszTempFname;
    return hFile;

Cleanup:
    if (pszTempDir)
        LocalFree (pszTempDir);

    if (pszTempFname)
        LocalFree (pszTempFname);

    if (pszGUID)
        ::CoTaskMemFree(pszGUID);

    if (hServer)
        ClosePrinter(hServer);

    return INVALID_HANDLE_VALUE;
}


BOOL
COleInstall::IsHttpPreferred(void)
{
    DWORD dwVal;
    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof (DWORD);
    HKEY  hHandle   = NULL;
    BOOL  bRet      = FALSE;


    if (ERROR_SUCCESS != RegOpenKey (HKEY_CURRENT_USER,
                                          TEXT ("Printers\\Settings"),
                                          &hHandle))
        goto Cleanup;

    if (ERROR_SUCCESS == RegQueryValueEx (hHandle,
                                          TEXT ("PreferredConnection"),
                                          NULL,
                                          &dwType,
                                          (LPBYTE) &dwVal,
                                          &dwSize)) {
        bRet =  (dwVal == 0) ? TRUE : FALSE;
    }

Cleanup:

    if (hHandle) {
        RegCloseKey (hHandle);
    }
    return bRet;
}

BOOL
COleInstall::GetHttpPrinterFile(
    OleInstallData *pData,
    LPTSTR pbstrURL)
{
    LPTSTR  pszErrMsg           = NULL;
    BOOL    bRet                = FALSE;
    DWORD   dwError;

    if (!pbstrURL) {
        return  FALSE;
    }

    switch (GetWebpnpFile(pData, pbstrURL, &pszErrMsg)) {
    case RET_SUCCESS:
        bRet = TRUE;
        break;

    case RET_SERVER_ERROR:
        dwError = _ttol (pszErrMsg);
        if (dwError == 0) {
            // This is a server internal error
            dwError = ERROR_INTERNAL_SERVER;
        }

        SetLastError (dwError);

        break;

    case RET_OTHER_ERROR:
    default:
        break;
    }

    if (pszErrMsg) {
        LocalFree (pszErrMsg);
    }
    return bRet;
}

BOOL
COleInstall::InstallHttpPrinter(
    OleInstallData *pData)
{
    BOOL bRet = FALSE;

    if (SyncExecute(pData->m_pszTempWebpnpFile, SW_SHOWNORMAL))
        bRet = TRUE;

    return bRet;
}

BOOL
COleInstall::CheckAndSetDefaultPrinter()
{
    DWORD   dwSize  = 0;
    BOOL    bRet = TRUE;

    if (!GetDefaultPrinterW (NULL, &dwSize)) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            // No default printer is set
            // We pass a NULL to SetDefaultPrinter to set the first printer in the device list to
            // be the default one
            bRet = SetDefaultPrinter (NULL);
        }
    }

    return bRet;
}



HRESULT COleInstall::CanIOpenPrintersFolder(void) {
    DWORD   dwPolicy;
    HRESULT hr = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicy );

    if (SUCCEEDED(hr)) {
        hr = (dwPolicy == URLPOLICY_JAVA_MEDIUM ||
              dwPolicy == URLPOLICY_JAVA_LOW    ||
              dwPolicy == URLPOLICY_ALLOW) ? S_OK : HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED);
    }

    if (FAILED(hr)) {
        hr = GetActionPolicy(URLACTION_SHELL_INSTALL_DTITEMS, dwPolicy);

        if (SUCCEEDED(hr))
            hr = dwPolicy == URLPOLICY_DISALLOW ? HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED) : S_OK;
    }

    return hr;
}

HRESULT
COleInstall::CanIInstallRPC(
    IN  LPTSTR lpszPrinterUNC
    )
/*++

Routine Description:
    Examine Secuiry Policies to determine whether we should install the printer or not

Arguments:
    lpszPrinterUNC - The UNC of the printer that we want to install

Return Value:
    S_OK                                       - Install via RPC
    S_FALSE                                    - Install via Web Pnp
    HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED) - IE security does not allow this action
    Other HRESULT error code.

--*/
{
    DWORD       dwPolicyJava;
    DWORD       dwPolicyDTI;
    HRESULT     hrRet            = S_FALSE;
    HRESULT     hr               = GetActionPolicy(URLACTION_JAVA_PERMISSIONS, dwPolicyJava);

    _ASSERTE(lpszPrinterUNC);

    //
    // Before checking anything, we should check the HTTP install registry setting
    //   If it is don;t even check the other stuff.
    //
    if (IsHttpPreferred())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (FAILED(hr))
    {
        // There is no JAVA Security Manager, or something went wrong,
        // then we decide whether to use Web PnP instead or just fail.
        hrRet = S_OK;
    }

    switch (dwPolicyJava)
    {
        case URLPOLICY_JAVA_LOW:
        case URLPOLICY_JAVA_MEDIUM:
            hr = S_OK;
            break;
        default:        // We must do Web PnP
            hr = GetActionPolicy(URLACTION_SHELL_INSTALL_DTITEMS, dwPolicyDTI );

            if (FAILED(hr))  // Couldn't get the policy on installing Desk Top Items
                goto Cleanup;

            switch (dwPolicyDTI)
            {
                case URLPOLICY_ALLOW:
                case URLPOLICY_QUERY:
                    hr = hrRet;
                    break;
                case URLPOLICY_DISALLOW:
                    hr = HRESULT_FROM_WIN32(ERROR_IE_SECURITY_DENIED);
                    break;
            }
    }

    //
    // If it looks like we can install via RPC then check if the UNC is valid
    //
    if (S_OK == hr)
    {
        //
        // Find ther Server name from the UNC
        //
        LPTSTR  pszServer = NULL;
        hr = GetServerNameFromUNC( lpszPrinterUNC, &pszServer );

        if (S_OK == hr)
        {
            hr = CheckServerForSpooler(pszServer);
        }

        if (pszServer)
            LocalFree(pszServer);
    }

Cleanup:

    return hr;
}

/*++

Routine Name:

    GetServerNameFromUNC

Description:

    This returns the server name from the given UNC path

Arguments:

    pszUNC          -   The UNC name,
    ppszServerName  -   The server name.

Return Value:

    An HRESULT.

--*/
HRESULT
COleInstall::GetServerNameFromUNC(
    IN      LPTSTR              pszUNC,
        OUT LPTSTR             *ppszServerName
    )
{
    HRESULT hr = pszUNC && ppszServerName ? S_OK : S_FALSE;
    PWSTR   pszServer = NULL;

    if (S_OK==hr)
    {
        hr = *pszUNC++ == L'\\' && *pszUNC++ == L'\\' ? S_OK : S_FALSE;
    }

    if (S_OK==hr)
    {
        hr = AssignString(pszServer, pszUNC) ? S_OK : E_OUTOFMEMORY;
    }

    if (S_OK==hr)
    {
        PWSTR pszSlash = wcschr(&pszServer[0], L'\\');

        //
        // If there was no second slash, then what we have is the server name.
        //
        if (pszSlash)
        {
            *pszSlash = L'\0';
        }

        *ppszServerName = pszServer;
        pszServer = NULL;
    }

    LocalFree(pszServer);

    return hr;
}


HRESULT
COleInstall::CheckServerForSpooler(
    IN  LPTSTR   pszServerName
    )
{
    HRESULT hr;
    //
    // Build a string with the Server Name and the name of the spooler
    //  named pipe
    //
    LPTSTR pszSpoolerPipe = NULL;
    DWORD  dwStrLen = lstrlen(pszServerName) + lstrlen(g_fmtSpoolSSPipe) + 1;
    pszSpoolerPipe = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwStrLen);
    hr = pszSpoolerPipe ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        hr = StringCchPrintf(pszSpoolerPipe, dwStrLen, g_fmtSpoolSSPipe, pszServerName);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Now try to connect to the pipe with Anonymous Access
        //
        HANDLE  hSpoolerPipe = INVALID_HANDLE_VALUE;
        hSpoolerPipe = CreateFile(pszSpoolerPipe, 0, 0, NULL, OPEN_EXISTING,
                                  (FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS), NULL);
        if (hSpoolerPipe != INVALID_HANDLE_VALUE)
        {
            // Pipe Exists try RPC
            hr = S_OK;
            CloseHandle(hSpoolerPipe);
        }
        else
        {
            // Check to see if failure is ACCESS_DENIED
            DWORD dwError = GetLastError();
            if (ERROR_ACCESS_DENIED == dwError)
            {
                // The pipe exists, but we don't have permissions
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
    }

    if (pszSpoolerPipe)
        LocalFree(pszSpoolerPipe);

    return hr;
}


LPTSTR COleInstall::RemoveURLVars(IN LPTSTR lpszPrinter) {
    _ASSERTE(lpszPrinter);

    LPTSTR lpszStripped = NULL;

    DWORD dwIndex = _tcscspn( lpszPrinter, TEXT("?") );

    lpszStripped = (LPTSTR)LocalAlloc( LPTR, (dwIndex + 1) * sizeof(TCHAR) );

    if (NULL == lpszStripped)
        goto Cleanup;

    _tcsncpy( lpszStripped, lpszPrinter, dwIndex );

    lpszStripped[dwIndex] = NULL;       // NULL terminate it.

Cleanup:
    return lpszStripped;
}


/*

  Function: GetNTPrint

  Purpose:  Returns a LPTSTR with the path to %windir%\inf\ntprint.inf
            Caller must free the returned string.

*/
LPTSTR
COleInstall::GetNTPrint(void)
{
    UINT    uiSize         = 0;
    UINT    uiAllocSize    = 0;
    PTCHAR  pData          = NULL;
    LPTSTR  lpszNTPrintInf = NULL;
    LPCTSTR gcszNTPrint    = _TEXT("\\inf\\ntprint.inf");

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //
    if( !(uiSize = GetSystemWindowsDirectory( lpszNTPrintInf, 0 )))
        goto Cleanup;

    uiAllocSize += uiSize + _tcslen( gcszNTPrint ) + 1;

    if( NULL == (lpszNTPrintInf = (LPTSTR)LocalAlloc( LPTR, uiAllocSize*sizeof(TCHAR) )))
        goto Cleanup;

    if ( GetSystemWindowsDirectory( lpszNTPrintInf, uiSize ) > uiSize )
    {
        LocalFree(lpszNTPrintInf);
        lpszNTPrintInf = NULL;
        goto Cleanup;
    }

    //
    // Determine if we have a \ on the end remove it.
    //
    pData = &lpszNTPrintInf[ _tcslen(lpszNTPrintInf)-1 ];
    if( *pData == _TEXT('\\') )
        *pData = 0;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    StringCchCat( lpszNTPrintInf, uiAllocSize, gcszNTPrint );

Cleanup:
    return lpszNTPrintInf;
}

//
// Creates the printer base name from the printerURL and printer name.
// Form is : "\\http://url\printer name"
//
LPTSTR
COleInstall::CreatePrinterBaseName(
    LPCTSTR lpszPrinterURL,
    LPCTSTR lpszPrinterName
)
{
    LPTSTR lpszFullPrinterName = NULL;
    PTCHAR pWhack              = NULL,
           pFriendlyName       = NULL;
    DWORD  cchBufSize          = 0;

    //
    // lpszPrinterName should be of the form "server\printer name"
    // We need to get only the "printer name" part.
    //
    if( NULL != ( pFriendlyName = _tcsrchr( lpszPrinterName, _TEXT('\\') ))) {
        //
        // Move off the \
        //
        pFriendlyName++;
    } else {
        pFriendlyName = (PTCHAR)lpszPrinterName;
    }

    //
    // Worst case size - the size of the two strings plus the "\\" plus "\" and
    // a NULL terminator
    //
    cchBufSize = lstrlen(lpszPrinterURL) + lstrlen(pFriendlyName) + 4;
    lpszFullPrinterName = (LPTSTR)LocalAlloc( LPTR, cchBufSize * sizeof(TCHAR) );

    if( lpszFullPrinterName ){
        StringCchCopy( lpszFullPrinterName, cchBufSize, _TEXT("\\\\") );
        StringCchCat( lpszFullPrinterName, cchBufSize, lpszPrinterURL );

        pWhack = _tcschr( lpszFullPrinterName, _TEXT('/') );

        if( pWhack ) {
            if( *(pWhack+1) == _TEXT('/') ) {
                //
                //  We've got a //, find the next /
                //
                pWhack = _tcschr( pWhack+2, _TEXT('/') );
            }
        }

        if( !pWhack ) {
            pWhack = &lpszFullPrinterName[ lstrlen( lpszFullPrinterName ) ];
        }

        *pWhack++ = _TEXT('\\');

        *pWhack = 0;

        StringCchCat( lpszFullPrinterName, cchBufSize, pFriendlyName );
    }

    return lpszFullPrinterName;
}


/****************************************************************************************
** End of File (oleinst.cpp)
****************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\olecvt.h ===
// OleCvt.h : Declaration of the COleCvt

#ifndef __OLECVT_H_
#define __OLECVT_H_

#include <asptlb.h>         // Active Server Pages Definitions

/////////////////////////////////////////////////////////////////////////////
// COleCvt
class ATL_NO_VTABLE COleCvt :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<COleCvt, &CLSID_OleCvt>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<COleCvt>,
	public IDispatchImpl<IOleCvt, &IID_IOleCvt, &LIBID_OLEPRNLib>,
    public IObjectSafetyImpl<COleCvt>
{
public:
	COleCvt()
	{
		m_bOnStartPageCalled = FALSE;
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_OLECVT)

BEGIN_COM_MAP(COleCvt)
	COM_INTERFACE_ENTRY(IOleCvt)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(COleCvt)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IOleCvt
public:
	STDMETHOD(get_ToUnicode)(BSTR bstrString, long lCodePage, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_DecodeUnicodeName)(BSTR bstrSrcName, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_EncodeUnicodeName)(BSTR bstrSrcName, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ToUtf8)(BSTR bstrUnicode, /*[out, retval]*/ BSTR *pVal);
	//Active Server Pages Methods
	STDMETHOD(OnStartPage)(IUnknown* IUnk);
	STDMETHOD(OnEndPage)();

private:
    HRESULT SetOleCvtScriptingError(DWORD dwError);
	CComPtr<IRequest> m_piRequest;					//Request Object
	CComPtr<IResponse> m_piResponse;				//Response Object
	CComPtr<ISessionObject> m_piSession;			//Session Object
	CComPtr<IServer> m_piServer;					//Server Object
	CComPtr<IApplicationObject> m_piApplication;	//Application Object
	BOOL m_bOnStartPageCalled;						//OnStartPage successful?
};

#endif //__OLECVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\printer.h ===
// Printer.h: interface for the CPrinter class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _PRINTER_H
#define _PRINTER_H

/***********************************************\
* Define      - ULOFFSET
*
* Description - This gives the offset into a data structure
\***********************************************/
#define ULOFFSET(type, identifier)  ((ULONG_PTR)&(((type)0)->identifier))


class CPrinter
{
public:
    DWORD           GetWaitingTime();
    BOOL            GetJobEtaData (DWORD &, DWORD &, DWORD &, DWORD &);
    LPTSTR          GetPrinterWebUrl();
    LPTSTR          GetOemUrl(LPTSTR & pszManufactureName);

    PPRINTER_INFO_2 GetPrinterInfo2 ();
    BOOL            CalJobEta();
    BOOL            Open (LPTSTR pPrinterName, LPHANDLE phPrinter = NULL);
    CPrinter();
    virtual ~CPrinter();

private:

    enum DriverData {
        OEMUrlPattern = 0,
        HardwareID,
        Manufacturer,
        LastDriverData      // This must always be the last member of the Enum.
        };

    PDRIVER_INFO_6  GetDriverInfo6 ();
    
    BOOL            AllocGetPrinterInfo2();
    BOOL            AllocGetPrinterInfo4();
    BOOL            AllocGetDriverInfo6();

    DWORD           GetPPM();
    DWORD           GetWaitingMinutes(DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob);
    BOOL            GetDriverData(DriverData dwDriverData, LPTSTR &pszData);
    BOOL            ParseUrlPattern(LPTSTR pSrc, LPTSTR pDest, DWORD &dwDestLen);

    HANDLE          m_hPrinter;
    PPRINTER_INFO_2 m_pInfo2;
    PPRINTER_INFO_4 m_pInfo4;
    PDRIVER_INFO_6  m_pDriverInfo6;
    BOOL            m_bCalcJobETA;
    DWORD           m_dwPendingJobCount;
    DWORD           m_dwAvgJobSize;
    DWORD           m_dwJobCompletionMinute;
    DWORD           m_dwAvgJobSizeUnit;

    LPTSTR          m_pszUrlBuffer;

    LPTSTR          m_pszOemUrl;
    LPTSTR          m_pszManufacturer;
};

#else

class CPrinter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\printer.cpp ===
// Printer.cpp: implementation of the CPrinter class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <strsafe.h>

#include "Printer.h"
#include "wininet.h"

static const DWORD BIT_IGNORED_JOB = (JOB_STATUS_PAUSED   |
                                      JOB_STATUS_PRINTED  |
                                      JOB_STATUS_DELETING |
                                      JOB_STATUS_OFFLINE  |
                                      JOB_STATUS_SPOOLING);
static const DWORD BIT_ERROR_JOB   = (JOB_STATUS_ERROR | JOB_STATUS_PAPEROUT);
static const DWORD CHAR_PER_PAGE   = 4800;
static const DWORD PAGEPERJOB      = 1;
static const DWORD BYTEPERJOB      = 2;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPrinter::CPrinter():
          m_hPrinter(NULL),
          m_pInfo2(NULL),
          m_pInfo4(NULL),
          m_pDriverInfo6(NULL),
          m_bCalcJobETA(NULL),
          m_pszUrlBuffer(NULL),
          m_pszOemUrl (NULL),
          m_pszManufacturer (NULL)
{
}

CPrinter::~CPrinter()
{
    if (m_pInfo2) {
        LocalFree (m_pInfo2);
    }

    if (m_pInfo4) {
        LocalFree (m_pInfo4);
    }

    if (m_pDriverInfo6) {
        LocalFree (m_pDriverInfo6);
    }

    if (m_hPrinter) {
        ClosePrinter (m_hPrinter);
    }

    if (m_pszUrlBuffer) {
        LocalFree (m_pszUrlBuffer);
    }

    if (m_pszOemUrl) {
        LocalFree (m_pszOemUrl);
    }

    if (m_pszManufacturer) {
        LocalFree (m_pszManufacturer);
    }

}

BOOL CPrinter::Open(LPTSTR pPrinterName, LPHANDLE phPrinter)
{
    PRINTER_DEFAULTS pd = {NULL, NULL, PRINTER_ACCESS_USE};

    if (m_hPrinter != NULL)
        return FALSE;

    if (! (OpenPrinter(pPrinterName, &m_hPrinter, &pd)))
        return FALSE;

    if (phPrinter) {
        *phPrinter = m_hPrinter;
    }

    return TRUE;
}

// This is a compiler safe way of checking that an unsigned integer is
// negative and returning zero if it is or the integer if it is not
// Note: Tval can be any size but must be unsigned
template<class T> inline T ZeroIfNegative(T Tval) {
    if (Tval & (T(1) << (sizeof(Tval) * 8 - 1))) return 0;
        else return Tval;
}

BOOL CPrinter::CalJobEta()
{
    DWORD           dwPrintRate = DWERROR;
    PJOB_INFO_2     pJobInfo = NULL;
    PJOB_INFO_2     pJob;
    DWORD           dwNumJobs;
    DWORD           dwNeeded = 0;
    DWORD           i;
    float           fFactor = 1;
    float           fTotal = 0;
    DWORD           dwNumJobsReqested;
    BOOL            bRet = FALSE;
    const   DWORD   cdwLimit = 256;

    if (! AllocGetPrinterInfo2())
        return NULL;

    if (m_pInfo2->cJobs > 0) {

        if (m_pInfo2->cJobs > cdwLimit) {
            fFactor = (float) m_pInfo2->cJobs / cdwLimit;
            dwNumJobsReqested = cdwLimit;
        }
        else
            dwNumJobsReqested = m_pInfo2->cJobs;

        EnumJobs (m_hPrinter, 0, dwNumJobsReqested, 2,
            NULL, 0, &dwNeeded, &dwNumJobs);

        if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
            (NULL == (pJobInfo = (PJOB_INFO_2)LocalAlloc(LPTR, dwNeeded))) ||
            (!EnumJobs (m_hPrinter, 0, dwNumJobsReqested, 2, (LPBYTE) pJobInfo, dwNeeded,
            &dwNeeded, &dwNumJobs))) {

            goto Cleanup;
        }

        // Get the average Job size

        // Find out if we can use page as the unit
        for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
            if (pJob->Status & BIT_IGNORED_JOB)
                continue;

            if (pJob->Size > 0 && pJob->TotalPages == 0)
                break;
        }

        m_dwPendingJobCount = 0;

        if (i == dwNumJobs) {
            // All the jobs have the page information. Use page as the unit
            m_dwAvgJobSizeUnit = PAGEPERJOB;

            for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
                if (pJob->Status & BIT_IGNORED_JOB)
                    continue;
                m_dwPendingJobCount++;
                fTotal += pJob->TotalPages;
            }
        }
        else {
            // Use byte as the unit
            m_dwAvgJobSizeUnit = BYTEPERJOB;
            for (pJob = pJobInfo, i = 0; i < dwNumJobs; i++, pJob++) {
                if (pJob->Status & BIT_IGNORED_JOB)
                    continue;
                m_dwPendingJobCount++;
                fTotal += ZeroIfNegative(pJob->Size);
            }
        }

        // Calculate the averate job size
        if (m_dwPendingJobCount) {
            m_dwAvgJobSize = DWORD ((fTotal) / (float) m_dwPendingJobCount);
            dwPrintRate = GetPPM();

            if (dwPrintRate != DWERROR)
                m_dwJobCompletionMinute = (DWORD) (fFactor * GetWaitingMinutes (dwPrintRate, pJobInfo, dwNumJobs));
        }
        else {
            m_dwAvgJobSize = 0;
            m_dwJobCompletionMinute = 0;
        }

        m_dwPendingJobCount = (DWORD) (m_dwPendingJobCount * fFactor);
    }
    else {
        m_dwPendingJobCount = 0;
        m_dwAvgJobSize = 0;
        m_dwJobCompletionMinute = 0;
        m_dwAvgJobSizeUnit = PAGEPERJOB;
    }

    m_bCalcJobETA = TRUE;

    // Set the last error to ERROR_INVALID_DATA if the printer rate is not available for the current printer
    // or if the printer status is not suitable to display the summary information
    //

    if (dwPrintRate == DWERROR ||
        m_pInfo2->Status & ( PRINTER_STATUS_PAUSED           |
                             PRINTER_STATUS_ERROR            |
                             PRINTER_STATUS_PENDING_DELETION |
                             PRINTER_STATUS_PAPER_JAM        |
                             PRINTER_STATUS_PAPER_OUT        |
                             PRINTER_STATUS_OFFLINE )) {
        SetLastError (ERROR_INVALID_DATA);
        m_dwJobCompletionMinute = DWERROR;
        bRet = FALSE;
    }
    else
        bRet = TRUE;

Cleanup:
    if (pJobInfo)
        LocalFree(pJobInfo);
    return bRet;

    }

DWORD CPrinter::GetWaitingMinutes(DWORD dwPPM, PJOB_INFO_2 pJobInfo, DWORD dwNumJob)
{
    DWORD   dwWaitingTime   = 0;
    DWORD   dwTotalPages    = 0;

    if (dwNumJob == 0)
        return 0;

    if (dwPPM == 0)
        return DWERROR;

    for (DWORD i = 0; i < dwNumJob; i++,  pJobInfo++) {
        if (pJobInfo->Status & BIT_IGNORED_JOB)
            continue;
        if (pJobInfo->Status & BIT_ERROR_JOB)
            return DWERROR;

        if (pJobInfo->TotalPages > 0) {
            dwTotalPages += pJobInfo->TotalPages;
        }
        else {
            if (pJobInfo->Size) {
                dwTotalPages += 1 + ZeroIfNegative(pJobInfo->Size) / CHAR_PER_PAGE;
            }
        }
    }

    if (dwTotalPages)
        dwWaitingTime = 1 + dwTotalPages / dwPPM;

    return dwWaitingTime;
}


DWORD CPrinter::GetPPM()
{
    DWORD dwPrintRate;
    DWORD dwPrintRateUnit;

    // Get PrintRate
    dwPrintRate = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                     NULL,
                                     DC_PRINTRATE,
                                     NULL,
                                     NULL);

    if (dwPrintRate == DWERROR ) {
        return dwPrintRate;
    }

    dwPrintRateUnit = MyDeviceCapabilities(m_pInfo2->pPrinterName,
                                         NULL,
                                         DC_PRINTRATEUNIT,
                                         NULL,
                                         NULL);

    switch (dwPrintRateUnit) {
    case PRINTRATEUNIT_PPM:         // PagesPerMinute
        break;
    case PRINTRATEUNIT_CPS:         // CharactersPerSecond
        dwPrintRate = CPS2PPM (dwPrintRate);
        break;
    case PRINTRATEUNIT_LPM:         // LinesPerMinute
        dwPrintRate = LPM2PPM (dwPrintRate);
        break;
    case PRINTRATEUNIT_IPM:         // InchesPerMinute
        dwPrintRate  = DWERROR;
        break;
    default:                        // Unknown
        dwPrintRate  = DWERROR;
        break;
    }

    return dwPrintRate ;
}

BOOL CPrinter::AllocGetPrinterInfo2()
{

    DWORD               dwNeeded = 0;
    PPRINTER_INFO_2     pPrinterInfo = NULL;
    LPTSTR              pszTmp;


    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a PRINTER_INFO_2 structure filled up

    if (GetPrinter(m_hPrinter, 2, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_2)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinter(m_hPrinter, 2, (byte *)pPrinterInfo, dwNeeded, &dwNeeded))) {

            if (pPrinterInfo)
                LocalFree(pPrinterInfo);

            if (! GetLastError())
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    // Mark the offline status if the attribute says offline
    if (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) {
        pPrinterInfo->Status |= PRINTER_STATUS_OFFLINE;
    }

    // Extract the first port for the case of pooled printing. i.e. we don't support pooled printing.
    if ( pPrinterInfo->pPortName) {
        if( pszTmp = _tcschr( pPrinterInfo->pPortName, TEXT(',')))
            *pszTmp = TEXT('\0');
    }

    if (m_pInfo2) {
        LocalFree (m_pInfo2);
    }

    m_pInfo2 = pPrinterInfo;

    return TRUE;
}

BOOL CPrinter::AllocGetPrinterInfo4()
{

    DWORD               dwNeeded = 0;
    PPRINTER_INFO_4     pPrinterInfo = NULL;

    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a PRINTER_INFO_4 structure filled up

    if (GetPrinter(m_hPrinter, 4, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_4)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinter(m_hPrinter, 4, (byte *)pPrinterInfo, dwNeeded, &dwNeeded))) {

            if (pPrinterInfo)
                LocalFree(pPrinterInfo);

            if (! (GetLastError()))
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    if (m_pInfo4) {
        LocalFree (m_pInfo4);
    }
    m_pInfo4 = pPrinterInfo;

    return TRUE;
}

BOOL CPrinter::AllocGetDriverInfo6()
{

    DWORD               dwNeeded = 0;
    PDRIVER_INFO_6      pDriverInfo = NULL;

    if (m_hPrinter == NULL) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Get a DRIVER_INFO_6 structure filled up

    if (GetPrinterDriver(m_hPrinter, NULL, 6, NULL, 0, &dwNeeded) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pDriverInfo = (PDRIVER_INFO_6)LocalAlloc(LPTR, dwNeeded))) ||
        (!GetPrinterDriver(m_hPrinter, NULL, 6, (LPBYTE)pDriverInfo, dwNeeded, &dwNeeded))) {

            if (pDriverInfo)
                LocalFree(pDriverInfo);

            if (! (GetLastError()))
                SetLastError (ERROR_INVALID_DATA);
            return FALSE;
    }

    if (m_pDriverInfo6) {
        LocalFree (m_pDriverInfo6);
    }
    m_pDriverInfo6 = pDriverInfo;

    return TRUE;
}


PPRINTER_INFO_2 CPrinter::GetPrinterInfo2()
{
    if (m_pInfo2 == NULL) {
        if (! AllocGetPrinterInfo2())
            return NULL;
    }

    return m_pInfo2;
}

PDRIVER_INFO_6 CPrinter::GetDriverInfo6()
{
    if (m_pDriverInfo6 == NULL) {
        if (! AllocGetDriverInfo6()) {
            return NULL;
        }
    }

    return m_pDriverInfo6;
}


DWORD CPrinter::GetWaitingTime()
{
    if (!m_bCalcJobETA) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }
    return m_dwJobCompletionMinute;
}

BOOL CPrinter::GetJobEtaData (DWORD & dwWaitingTime, DWORD &dwJobCount, DWORD &dwJobSize, DWORD &dwJob)
{
    if (!m_bCalcJobETA) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwJobCount    = m_dwPendingJobCount;
    dwJobSize     = m_dwAvgJobSize;
    dwWaitingTime = m_dwJobCompletionMinute;
    dwJob         = m_dwAvgJobSizeUnit;

    return TRUE;
}


LPTSTR CPrinter::GetPrinterWebUrl(void)
{
    static const TCHAR c_szHttp[]   = TEXT("http://");
    static const TCHAR c_szHttps[]  = TEXT("https://");

    BOOL                bReturn = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwLen       = 0;
    TCHAR               szBuffer[MAX_COMPUTERNAME_LENGTH+1];
    DWORD               dwBufferSize;
    DWORD               dwAttributes;
    LPCTSTR             pszServerName;
    LPTSTR              pszShareName;
    LPTSTR              pszSplServerName;
    LPTSTR              pszSplPrinterName;
    LPTSTR              pszSplShareName;

    //
    // Get printer info 4 to fetch the attribute.
    //
    bReturn = AllocGetPrinterInfo4();

    if (!bReturn) {

        if (GetLastError () == ERROR_INVALID_LEVEL ) {
            //
            // Most likely it is a remote printers folder, no support for level4, so
            // we have to use level 2 instead.
            //
            if (! AllocGetPrinterInfo2())
                goto Cleanup;
        }
        else {
            //
            // The call fails with other reasons
            //
            goto Cleanup;
        }

    }
    else{

        if (m_pInfo4->Attributes & PRINTER_ATTRIBUTE_LOCAL) {
            // Check if the local flag is on. If so, try to get printer info2 for more information
            if (! AllocGetPrinterInfo2())
                goto Cleanup;
        }
    }

    //
    // Assume failure
    //
    bReturn = FALSE;


    if (m_pInfo2) {
        dwAttributes = m_pInfo2->Attributes;
        pszSplServerName = m_pInfo2->pServerName;
        pszSplPrinterName = m_pInfo2->pPrinterName;
        pszSplShareName = m_pInfo2->pShareName;
    }
    else
    {
        dwAttributes = m_pInfo4->Attributes;
        pszSplServerName = m_pInfo4->pServerName;
        pszSplPrinterName = m_pInfo4->pPrinterName;
        pszSplShareName = NULL;
    }

    //
    // Check if it is a printer connected to an http port
    // then the port name is the url.
    //
    if( m_pInfo2 )
    {

        if( m_pInfo2->pPortName )
        {
            //
            // Compare the port name prefex to see if it is an HTTP port.
            //
            if( !_tcsnicmp( m_pInfo2->pPortName, c_szHttp, _tcslen( c_szHttp ) ) ||
                !_tcsnicmp( m_pInfo2->pPortName, c_szHttps, _tcslen( c_szHttps ) ) )
            {
                //
                //  We always use portname as the URL
                //
                dwLen = 1 + lstrlen( m_pInfo2->pPortName );

                if (! (m_pszUrlBuffer = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
                {
                    goto Cleanup;
                }

                StringCchCopy( m_pszUrlBuffer, dwLen, m_pInfo2->pPortName );

                bReturn = TRUE;
                goto Cleanup;


            }
        }
    }


    //
    // If it is an unshared printer, return false
    //
    if ( !(dwAttributes & PRINTER_ATTRIBUTE_SHARED) )
    {
        goto Cleanup;
    }


    //
    // Check if it is a connection or a local printer or a masq printer
    // which is not connected over http, then build the url
    // from the \\server name\share name.
    //
    if( !pszSplServerName )
    {
        dwBufferSize = COUNTOF( szBuffer );

        if( !GetComputerName( szBuffer, &dwBufferSize ) )
        {
            goto Cleanup;
        }

        pszServerName = szBuffer;
    }
    //
    // Server name was provided then set our pointer to just
    // after the two leading wacks.
    //
    else
    {
        if( pszSplServerName[0] == TEXT('\\') &&
            pszSplServerName[1] == TEXT('\\') )
        {
            pszServerName = pszSplServerName + 2;
        }
        else
        {
            goto Cleanup;
        }
    }

    if ( !IsWebServerInstalled(pszSplServerName) ) {

        dwLastError = ERROR_NO_BROWSER_SERVERS_FOUND;
        goto Cleanup;
    }

    //
    // Build the URL -  http://server/printers/ipp_0004.asp?printer=ShareName
    //
    if (pszSplShareName)
    {
        pszShareName = pszSplShareName;
    }
    else {
        //
        //  Parse the sharename/printername  from the printer name
        //
        if(pszSplPrinterName) {
            if (pszSplPrinterName[0] == TEXT ('\\') && pszSplPrinterName[1] == TEXT ('\\') )
            {
                pszShareName = _tcschr (pszSplPrinterName + 2, TEXT ('\\'));
                pszShareName++;
            }
            else
                pszShareName = pszSplPrinterName;
        }
        else
        {
            goto Cleanup;
        }
    }

    GetWebUIUrl  (pszServerName, pszShareName, NULL, &dwLen);

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER )
    {
        goto Cleanup;
    }

    if (! (m_pszUrlBuffer = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
    {
        goto Cleanup;
    }

    if (!GetWebUIUrl  (pszServerName, pszShareName, m_pszUrlBuffer, &dwLen))
    {
        goto Cleanup;
    }

    //
    // Indicate success.
    //
    bReturn = TRUE;

    //
    // Clean any opened or allocated resources.
    //
Cleanup:


    //
    // If this routine failed then set the last error.
    //
    if( !bReturn )
    {
        //
        // If the last error was not set then a called routine may
        // have set the last error.  We don't want to clear the
        // last error.
        //
        if( dwLastError != ERROR_SUCCESS )
        {
            SetLastError( dwLastError );
        }
    }
    return m_pszUrlBuffer;
}

BOOL CPrinter::GetDriverData(
    DriverData dwDriverData,
    LPTSTR &pszData)
{
    static const ULONG_PTR ulpOffset[LastDriverData] = {
        // This has the offsets into the DRIVER_INFO_6 structure.....
        ULOFFSET( PDRIVER_INFO_6, pszOEMUrl )     ,
        ULOFFSET( PDRIVER_INFO_6, pszHardwareID ) ,
        ULOFFSET( PDRIVER_INFO_6, pszMfgName)
    };

    LPTSTR pszDataString = NULL;
    BOOL   bRet          = FALSE;
    DWORD  dwSize;

    ASSERT( (int)dwDriverData >= 0 && (int)dwDriverData < LastDriverData );

    if (! GetDriverInfo6() )
        goto Cleanup;

    pszDataString = *(LPTSTR *)(((ULONG_PTR) m_pDriverInfo6) +  ulpOffset[dwDriverData] );

    if (pszDataString == NULL || *pszDataString == NULL)
        goto Cleanup;

    dwSize = sizeof(TCHAR) * (lstrlen( pszDataString ) + 1);

    if (! (pszData  = (LPTSTR)LocalAlloc(LPTR, dwSize)))
        goto Cleanup;

    //
    // Use byte-size there.
    //
    StringCbCopy( pszData, dwSize, pszDataString );

    bRet = TRUE;
Cleanup:
    return bRet;
}

BOOL CPrinter::ParseUrlPattern(
    LPTSTR pSrc,
    LPTSTR pDest,
    DWORD &dwDestLen)
{
    const dwMaxMacroLen = 255;
    enum {
        NORMALTEXT, STARTMACRO
    } URL_PATTERN_STATE;


    BOOL bRet = FALSE;
    DWORD dwLen = 0;
    DWORD dwMacroLen = 0;
    DWORD dwAvailbleSize;
    DWORD dwState = NORMALTEXT;
    int i;
    TCHAR ch;
    TCHAR szMacroName [dwMaxMacroLen + 1];
    LPTSTR pMacroValue = NULL;

    LPTSTR pszMacroList[] = {
        TEXT ("MODEL"),
        TEXT ("HARDWAREID"),
    };


    while (ch = *pSrc++) {
        switch (dwState) {
        case NORMALTEXT:
            if (ch == TEXT ('%')) {
                // Start a macro
                dwState = STARTMACRO;
                dwMacroLen = 0;
                szMacroName[0] = 0;
            }
            else {
                if (dwLen >= dwDestLen) {
                    dwLen ++;
                }
                else {
                    pDest[dwLen++] = ch;
                }
            }

            break;
        case STARTMACRO:
            if (ch == TEXT ('%')) {
                szMacroName[dwMacroLen] = 0;
                // Replace Macro
                for (int i = 0; i < sizeof (pszMacroList) / sizeof (pszMacroList[0]); i++) {
                    if (!lstrcmpi (szMacroName, pszMacroList[i])) {

                        pMacroValue = 0;
                        switch (i) {
                        case 0:
                            AssignString (pMacroValue, m_pInfo2->pDriverName);
                            break;
                        case 1:
                            GetDriverData (HardwareID , pMacroValue);
                            break;
                        default:
                            break;
                        }

                        if (pMacroValue) {

                            if (dwDestLen > dwLen)
                                dwAvailbleSize =  dwDestLen - dwLen;
                            else
                                dwAvailbleSize = 0;

                            TCHAR szPlaceHolder[1];
                            DWORD dwBufSize = sizeof (szPlaceHolder) / sizeof (TCHAR);
                            if (!InternetCanonicalizeUrl (pMacroValue, szPlaceHolder, &dwBufSize, 0)) {
                                if (dwBufSize < dwAvailbleSize ) {
                                    if (!InternetCanonicalizeUrl (pMacroValue, pDest + dwLen, &dwBufSize, 0)) {
                                        LocalFree (pMacroValue);
                                        return bRet;
                                    }
                                    else {
                                        dwLen = lstrlen (pDest);
                                    }
                                }
                                else {
                                    dwLen += dwBufSize;
                                }
                            }
                            LocalFree (pMacroValue);
                        }
                        break;
                    }
                }

                dwState = NORMALTEXT;
            }
            else {
                if (dwMacroLen < dwMaxMacroLen) {
                    szMacroName[dwMacroLen ++] = ch;
                }
            }
            break;
        }
    }

    if (dwState == STARTMACRO) {
        SetLastError ( ERROR_INVALID_DATA );
    }
    else {
        if (dwLen >= dwDestLen) {
            SetLastError (ERROR_INSUFFICIENT_BUFFER);
            dwDestLen = dwLen + 1;
        }
        else {
            pDest[dwLen] = 0;
            bRet = TRUE;
        }
    }

    return bRet;

}

LPTSTR CPrinter::GetOemUrl(
    LPTSTR & pszManufacturer)
{
    LPTSTR pszOemUrlPattern = NULL;
    DWORD dwLen = 0;
    LPTSTR pszUrl = NULL;

    if (!GetPrinterInfo2 () )
        goto Cleanup;

    if (GetDriverData (OEMUrlPattern, pszOemUrlPattern)) {

        if (! ParseUrlPattern (pszOemUrlPattern, NULL, dwLen)
            && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            m_pszOemUrl = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwLen);
            if (m_pszOemUrl) {

                if (!ParseUrlPattern (pszOemUrlPattern, m_pszOemUrl, dwLen))
                    goto Cleanup;
            }
            else
                goto Cleanup;
        }

    }

    if (GetDriverData (Manufacturer, m_pszManufacturer)) {
        pszManufacturer = m_pszManufacturer;
        pszUrl =  m_pszOemUrl;
    }

Cleanup:
    if (pszOemUrlPattern) {
        LocalFree ( pszOemUrlPattern);
    }

    return pszUrl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\olesnmp.cpp ===
/*****************************************************************************\
* MODULE:       olesnmp.cpp
*
* PURPOSE:      Implementation of COM interface for SNMP
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Moved to oleprn.dll
*
\*****************************************************************************/

#include "stdafx.h"
#include <strsafe.h>

#include "oleprn.h"
#include "olesnmp.h"

/////////////////////////////////////////////////////////////////////////////
// CSNMP


CSNMP::
CSNMP(
    VOID
    )
{
    m_SNMPSession = NULL;
}

CSNMP::
~CSNMP(
    VOID
    )
{
    if (m_SNMPSession != NULL) SnmpMgrClose(m_SNMPSession);
}

/*****************************************************************************\
* Function:         Open
*
* PURPOSE:          COM wrapper for SnmpMgrOpen
*
* ARGUMENTS:
*
*   bstrHost:       Host name or Server Name
*   bstrCommunity:  Community Name
*   varRetry:       Retry times [optional in VB]
*   varTimeOut:     Time out Value (in millisecond) [optional in VB]
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid argument. It occurs when either varRetry or varTimeOut
*                   can not be converted to a short integer.
*   E_FAIL:         If SNMPMgrOpen fails
*
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Open(
    IN  BSTR bstrHost,
    IN  BSTR bstrCommunity,
    IN  VARIANT varRetry,
    IN  VARIANT varTimeOut
    )
{
    const INT   iDefaultRetry = 5;
    const INT   iDefaultTimeOut = 5000;
    INT         iRetry;
    INT         iTimeOut;
    LPSTR       pAnsiHost = NULL;
    LPSTR       pAnsiCommunity = NULL;
    HRESULT     hr = E_FAIL;

    // To prevent a second open
    if (m_SNMPSession != NULL){
        SnmpMgrClose(m_SNMPSession);
        m_SNMPSession = NULL;
    }

    if (varRetry.vt == VT_ERROR) {
        iRetry = iDefaultRetry;
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, &varRetry, 0, VT_I2);
        if (FAILED (hr))
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        iRetry = varTemp.iVal;
    }

    if (varTimeOut.vt == VT_ERROR) {
        iTimeOut = iDefaultTimeOut;
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, &varTimeOut, 0, VT_I2);
        if (FAILED (hr))
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        iTimeOut = varTemp.iVal;
    }

    pAnsiHost = MakeNarrow(bstrHost);
    pAnsiCommunity = MakeNarrow(bstrCommunity);

    if (pAnsiHost && pAnsiCommunity) {
        __try {

            m_SNMPSession = SnmpMgrOpen(pAnsiHost, pAnsiCommunity, iTimeOut, iRetry);

        } __except(1) {

            hr = E_FAIL;
        }
    }

    LocalFree(pAnsiHost);
    LocalFree(pAnsiCommunity);

    if (m_SNMPSession == NULL)
        return Error(IDS_FAILED_OPEN_SNMP, IID_ISNMP, E_FAIL);

    return S_OK;
}

/*****************************************************************************\
* Function:         Get
*
* PURPOSE:          Get a value of a SNMP oid
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   pvarValue:      The return value for the corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Get(
    IN  BSTR bstrOID,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList))){
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_GETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = RFC1157ToVariant(pvarValue, &rfcVarList.list[0]);

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         GetAsByte
*
* PURPOSE:          Get a value of a SNMP oid as an integer
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   puValue:        The return value for the corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetAsByte(
    IN  BSTR bstrOID,
    OUT PUINT puValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList))){
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_GETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = RFC1157ToUInt(puValue, &rfcVarList.list[0]);

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         GetList
*
* PURPOSE:          Get a list of a SNMP oids
*
* ARGUMENTS:
*
*   pvarList:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The return value for the corresponding Oids, it is 1D array
*                   of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid or the type of the variant is not a 1D array
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetList(
    IN  VARIANT *pvarList,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psa,*psaOut = NULL;
    SAFEARRAYBOUND      rgsabound[1];
    long                lbound, ubound, half, step;
    VARIANT             var;
    BOOL                bFound;
    BOOL                bTooBig;

    // Check if Open Method has been called
    if (m_SNMPSession == NULL)
        return (Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL));

    // Validate the input variable
    if (!(pvarList->vt & VT_ARRAY))
        return (Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG));

    if (pvarList->vt & VT_BYREF)
        psa = *(pvarList->pparray);
    else
        psa = pvarList->parray;

    if (SafeArrayGetDim(psa)!=1)
        return (Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG));

    // Get the array boundary
    SafeArrayGetLBound(psa, 1, &lbound);
    SafeArrayGetUBound(psa, 1, &ubound);

    VariantInit(pvarValue);
    VariantInit(&var);

    // Alloc the destination array
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = ubound - lbound + 1;

    if (! (psaOut = SafeArrayCreate(VT_VARIANT, 1, rgsabound))) {
        hr = Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        goto Cleanup;
    }

    // Try to determine the size of data we can put into one call
    half = ubound;

    bFound = FALSE;
    while (!bFound) {

        bTooBig = FALSE;

        // Convert items of the array to rfcVarList
        hr = VarToRfcVarList (lbound, half, psa, &rfcVarList);
        if (FAILED (hr))
            goto Cleanup;

        if (! SnmpMgrRequest(m_SNMPSession,
                             ASN_RFC1157_GETREQUEST,
                             &rfcVarList,
                             &asniErrorStatus,
                             &asniErrorIndex)) {

            if (GetLastError() != ERROR_NOT_ENOUGH_MEMORY)
            {
                // SNMP call fails. Setup error and return
                hr = SetWinSnmpApiError (GetLastError ());
                goto Cleanup;
            }
            else
                bTooBig = TRUE;
        }

        if (asniErrorStatus > 0)  {
            // SNMP call succeeds but the returned status if wrong
            if (asniErrorStatus != SNMP_ERRORSTATUS_TOOBIG) {
                // Other errors occur in the call, setup error and return
                hr = SetSnmpScriptError(asniErrorStatus);
                goto Cleanup;
            }
            else
                bTooBig = TRUE;
        }

        if (bTooBig){
            // The size of input is too big, reduce it again
            if (half - lbound < 2) {
                // Something must be wrong, quit
                hr = SetSnmpScriptError(asniErrorStatus);
                goto Cleanup;
            }
            else {
                // Divdie the size by 2
                half = (lbound + half) / 2;
            }
        }
        else {
            // We've found the proper steps and also got the first portion
            // Save them to the destination safe array psaout
            hr = RfcToVarList (lbound, &rfcVarList, psaOut);
            if (FAILED (hr))
                goto Cleanup;

            bFound = TRUE;
        }
        SnmpUtilVarBindListFree(&rfcVarList);
        rfcVarList.list = NULL;
        rfcVarList.len = 0;
    }

    step = half - lbound;
    for (lbound = half + 1; lbound <= ubound; lbound += step) {
        half = lbound + step;
        if (half > ubound)
            half = ubound;

        hr = VarToRfcVarList (lbound, half, psa, &rfcVarList);
        if (FAILED (hr))
            goto Cleanup;

        if (! SnmpMgrRequest(m_SNMPSession,
                             ASN_RFC1157_GETREQUEST,
                             &rfcVarList,
                             &asniErrorStatus,
                             &asniErrorIndex)) {
            // SNMP call fails. Setup error and return
            hr = SetWinSnmpApiError (GetLastError ());
            goto Cleanup;
        }
        if (asniErrorStatus > 0)  {
            // SNMP call succeeds but the returned status if wrong
            hr = SetSnmpScriptError(asniErrorStatus);
            goto Cleanup;
        }
        // Everything is OK
        hr = RfcToVarList (lbound, &rfcVarList, psaOut);
        if (FAILED (hr))
            goto Cleanup;

        SnmpUtilVarBindListFree(&rfcVarList);
        rfcVarList.list = NULL;
        rfcVarList.len = 0;
    }

    VariantInit(pvarValue);
    pvarValue->vt = VT_ARRAY|VT_VARIANT;
    pvarValue->parray = psaOut;
    hr = S_OK;
    return hr;

Cleanup:
    if (rfcVarList.len > 0)
        SnmpUtilVarBindListFree(&rfcVarList);
    if (psaOut)
        SafeArrayDestroy (psaOut);
    return hr;
}

/*****************************************************************************\
* Function:         GetTree
*
* PURPOSE:          It walks through  SNMP oids
*
* ARGUMENTS:
*
*   bstrTree:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The return value for the corresponding Oids, it is 1D array
*                   of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
GetTree(
    IN  BSTR bstrTree,
    OUT VARIANT *pvarValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    VARIANT             v;
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    AsnObjectIdentifier asnRootOid;
    AsnObjectIdentifier asnTmpOid;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psa = NULL;
    SAFEARRAYBOUND      rgsabound[2];
    long                ix[2];
    LPSTR               pszStr;

    if (m_SNMPSession == NULL)
        return (Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL));

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = 2;
    rgsabound[1].lLbound = 0;
    rgsabound[1].cElements = 0;
    if (! (psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound)))
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

    hr = VarListAdd(bstrTree, &rfcVarList);
    if (FAILED (hr))
    {
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup2;
    }

    if (!SnmpUtilOidCpy(&asnRootOid, &rfcVarList.list[0].name)){
        hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
        goto Cleanup2;
    }

    while(1){
        if (!SnmpMgrRequest(m_SNMPSession,
                            ASN_RFC1157_GETNEXTREQUEST,
                            &rfcVarList,
                            &asniErrorStatus,
                            &asniErrorIndex)) {
            hr = SetWinSnmpApiError (GetLastError ());
            goto Cleanup;
        }

        if (asniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
            SnmpUtilOidNCmp(&rfcVarList.list[0].name, &asnRootOid, asnRootOid.idLength))
            break;

        if (asniErrorStatus > 0) {
            hr = SetSnmpScriptError(asniErrorStatus);
            goto Cleanup;
        }

        rgsabound[1].cElements++;
        ix[1] = rgsabound[1].cElements - 1;
        hr = SafeArrayRedim(psa, &rgsabound[1]);
        if (FAILED (hr))
        {
            Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            goto Cleanup;
        }

        // put a pszStr version of the OID in the result array

        pszStr = NULL;
        if (!SnmpMgrOidToStr(&rfcVarList.list[0].name, &pszStr)){
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            goto Cleanup;
        }

        ix[0] = 0;
        hr = PutString(psa, ix, pszStr);
        if (FAILED (hr))
            goto Cleanup;

        SnmpUtilMemFree(pszStr);

        // Put the value variant in the result array

        hr = RFC1157ToVariant(&v, &rfcVarList.list[0]);
        if (FAILED (hr)) goto Cleanup;

        ix[0] = 1;
        hr = SafeArrayPutElement(psa, ix, &v);
        if (FAILED (hr))
        {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }
        VariantClear(&v);

        if (! SnmpUtilOidCpy(&asnTmpOid, &rfcVarList.list[0].name)) {
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            goto Cleanup;
        }

        SnmpUtilVarBindFree(&rfcVarList.list[0]);

        if (! SnmpUtilOidCpy(&rfcVarList.list[0].name, &asnTmpOid)) {
            hr = SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
            SnmpUtilOidFree(&asnTmpOid);
            goto Cleanup;
        }

        rfcVarList.list[0].value.asnType = ASN_NULL;
        SnmpUtilOidFree(&asnTmpOid);
    }

    SnmpUtilOidFree(&asnRootOid);
    SnmpUtilVarBindListFree(&rfcVarList);

    VariantInit(pvarValue);
    pvarValue->vt = VT_ARRAY|VT_VARIANT;
    pvarValue->parray = psa;
    return S_OK;

Cleanup:
    SnmpUtilOidFree(&asnRootOid);
Cleanup2:
    SnmpUtilVarBindListFree(&rfcVarList);
    if (psa)
        SafeArrayDestroy(psa);
    return hr;
}

/*****************************************************************************\
* Function:         Close
*
* PURPOSE:          A Com Wrapper for SnmpMgrClose()
*
* ARGUMENTS:
*
* RETURN VALUE:
*   S_OK:           always.
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Close(
    VOID
    )
{
    if (m_SNMPSession)
        SnmpMgrClose(m_SNMPSession);
    m_SNMPSession = NULL;
    return S_OK;
}


STDMETHODIMP
CSNMP::
OIDFromString(
    BSTR bstrOID,
    VARIANT *pvarOID
    )
{
    SAFEARRAY           *psaOID;
    SAFEARRAYBOUND      rgsaOID[1];
    long                ixOID[1];
    LPSTR               pszOID;
    BOOL                bResult;
    VARIANT             v;
    AsnObjectIdentifier asnReqObject;
    HRESULT             hr;

    VariantInit(&v);
    if (! (pszOID = MakeNarrow(bstrOID)))
        return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());

    bResult = SnmpMgrStrToOid(pszOID, &asnReqObject);
    LocalFree(pszOID);

    if (!bResult )
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    // put a numeric array of the pvarOID in the result array

    rgsaOID[0].lLbound = 0;
    rgsaOID[0].cElements = asnReqObject.idLength;
    psaOID = SafeArrayCreate(VT_VARIANT, 1, rgsaOID);
    if (psaOID == NULL)
        goto out;
    for (ixOID[0] = 0; ixOID[0] < (long)rgsaOID[0].cElements ; ixOID[0]++){
        hr = VariantClear(&v);
        _ASSERTE (SUCCEEDED (hr));
        v.vt = VT_I4;
        v.lVal = asnReqObject.ids[ixOID[0]];
        hr = SafeArrayPutElement(psaOID, ixOID, &v);
        if (FAILED(hr))
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        //SafeArrayPutElement(psaOID, ixOID, &(asnReqObject.ids[ixOID[0]]));
    }

    hr = VariantClear(pvarOID);
    _ASSERTE(hr);
    pvarOID->vt = VT_ARRAY|VT_VARIANT;
    pvarOID->parray = psaOID;
    SnmpUtilOidFree(&asnReqObject);
    return S_OK;

out:
    SnmpUtilOidFree(&asnReqObject);
    return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
}

HRESULT
CSNMP::
VariantToRFC1157(
    RFC1157VarBind * prfcvbValue,
    VARIANT * pvarValue
    )
{
    HRESULT hr = S_OK;

    if (!pvarValue) {
        prfcvbValue->value.asnType = ASN_NULL;
    } else
    if (pvarValue->vt == VT_BSTR){
        prfcvbValue->value.asnType = ASN_OCTETSTRING;
        LPSTR pStr = MakeNarrow (pvarValue->bstrVal);

        if (pStr) {
            DWORD dwLen = strlen (pStr);

            if (! (prfcvbValue->value.asnValue.string.stream = (BYTE *) SnmpUtilMemAlloc (dwLen + 1))) {
                LocalFree (pStr);
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            }
            memcpy (prfcvbValue->value.asnValue.string.stream, pStr, dwLen + 1);
            prfcvbValue->value.asnValue.string.length = dwLen;
            prfcvbValue->value.asnValue.string.dynamic = TRUE;
            LocalFree (pStr);
        }
        else
            hr = Error( IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY );
    }
    else {
        VARIANT varTemp;

        VariantInit (&varTemp);
        hr = VariantChangeType (&varTemp, pvarValue, 0, VT_I4);
        if (FAILED (hr))
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        else {
            prfcvbValue->value.asnType = ASN_INTEGER;
            prfcvbValue->value.asnValue.number = pvarValue->lVal;
        }
    }

    return hr;
}

// ----------------------------------------------------
//  Place a returned SNMP value in a variant
//
HRESULT
CSNMP::
RFC1157ToVariant(
    VARIANT * pvarValue,
    RFC1157VarBind * prfcvbValue
    )
{
    VariantInit(pvarValue);
    switch (prfcvbValue->value.asnType){
    case ASN_RFC1155_TIMETICKS:
    case ASN_RFC1155_COUNTER:
    case ASN_RFC1155_GAUGE:
    case ASN_INTEGER:
    case ASN_UNSIGNED32:
        pvarValue->vt= VT_I4;
        pvarValue->lVal = prfcvbValue->value.asnValue.number;
        break;

    case ASN_RFC1155_IPADDRESS:
    case ASN_RFC1155_OPAQUE:
    case ASN_BITS:
    case ASN_SEQUENCE:
    case ASN_OCTETSTRING:
        pvarValue->vt = VT_BSTR;
        LPWSTR pszUnicodeStr;
        if (prfcvbValue->value.asnValue.string.length > 0 ){
            LPSTR pszAnsiStr;
            if (! (pszAnsiStr = (LPSTR )LocalAlloc(LPTR,
                prfcvbValue->value.asnValue.string.length + 1)))
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
            memcpy(pszAnsiStr, (LPSTR )prfcvbValue->value.asnValue.string.stream,
                   prfcvbValue->value.asnValue.string.length);
            pszAnsiStr[prfcvbValue->value.asnValue.string.length] = 0;
            pszUnicodeStr = MakeWide(pszAnsiStr);
            LocalFree(pszAnsiStr);
        }
        else{
            pszUnicodeStr = MakeWide("");
        }

        if (pszUnicodeStr == NULL)
            return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

        pvarValue->bstrVal = SysAllocString(pszUnicodeStr);

        LocalFree(pszUnicodeStr);

        if (pvarValue->bstrVal == NULL) {
            return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        }
        break;

    case ASN_OBJECTIDENTIFIER:
        LPSTR pszAnsiOid;

        pszAnsiOid = NULL;
        if (SnmpMgrOidToStr(& (prfcvbValue->value.asnValue.object), &pszAnsiOid)) {
            LPWSTR pszUnicodeOid = MakeWide (pszAnsiOid);

            SnmpUtilMemFree (pszAnsiOid);

            if (pszUnicodeOid) {
                pvarValue->vt = VT_BSTR;
                pvarValue->bstrVal = SysAllocString(pszUnicodeOid);
                LocalFree (pszUnicodeOid);
            }
            else
                return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
        }
        else
            return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());
        break;
    default:
        pvarValue->vt = VT_EMPTY;
    }
    return S_OK;
}

// ----------------------------------------------------
//  Place a returned SNMP value in a uint
//
HRESULT
CSNMP::
RFC1157ToUInt(
    PUINT puValue,
    RFC1157VarBind * prfcvbValue
    )
{
    switch (prfcvbValue->value.asnType){
    case ASN_RFC1155_TIMETICKS:
    case ASN_RFC1155_COUNTER:
    case ASN_RFC1155_GAUGE:
    case ASN_INTEGER:
    case ASN_UNSIGNED32:
        *puValue = prfcvbValue->value.asnValue.number;
        break;

    case ASN_RFC1155_OPAQUE:
    case ASN_BITS:
    case ASN_SEQUENCE:
    case ASN_OCTETSTRING:

        if (prfcvbValue->value.asnValue.string.length == 1 ){
            *puValue = prfcvbValue->value.asnValue.string.stream[0];
        }
        else{
            return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        }
        break;

    default:
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);
    }
    return S_OK;
}

// -----------------------------------------------------
//   Add an OID to an SNMP get list
//
//  Convert the UNICODE string to ANSI
//  Convert it to a real OID (numbers)
//  Add to the Array
HRESULT
CSNMP::
VarListAdd(
    BSTR bstrOID,
    RFC1157VarBindList * prfcList,
    VARIANT *pvarValue
    )
{
    LPSTR               pszOID;
    BOOL                bResult;
    AsnObjectIdentifier asnReqObject;

    if (! (pszOID = MakeNarrow(bstrOID)))
        return SetScriptingError(CLSID_SNMP, IID_ISNMP, GetLastError());

    bResult = SnmpMgrStrToOid(pszOID, &asnReqObject);
    LocalFree(pszOID);

    if (!bResult)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    prfcList->len++;

    if (! (prfcList->list = (RFC1157VarBind *) SNMP_realloc (prfcList->list,
        sizeof(RFC1157VarBind) * prfcList->len)))
        return Error(IDS_OUT_OF_MEMORY, IID_ISNMP, E_OUTOFMEMORY);

    prfcList->list[prfcList->len - 1].name = asnReqObject;

    return VariantToRFC1157(& (prfcList->list[prfcList->len -1]), pvarValue);

}

/*****************************************************************************\
* Function:         Set
*
* PURPOSE:          Set a value of a SNMP oid
*
* ARGUMENTS:
*
*   bstrOID:        The SNMP Oid in BSTR
*   varValue:       The corresponding Oid
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid.
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
Set(
    IN  BSTR bstrOID,
    IN  VARIANT varValue
    )
{
    RFC1157VarBindList rfcVarList = {NULL, 0};
    AsnInteger asniErrorStatus;
    AsnInteger asniErrorIndex;
    HRESULT hr = E_FAIL;

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (FAILED (hr = VarListAdd(bstrOID, &rfcVarList)))
    {
        Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
        goto Cleanup;
    }

    hr = VariantToRFC1157(&rfcVarList.list[0], &varValue);
    if (FAILED (hr))
        goto Cleanup;

    if (!SnmpMgrRequest(m_SNMPSession,
                        ASN_RFC1157_SETREQUEST,
                        &rfcVarList,
                        &asniErrorStatus,
                        &asniErrorIndex)) {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}

/*****************************************************************************\
* Function:         SetList
*
* PURPOSE:          Set a list of a SNMP oids
*
* ARGUMENTS:
*
*   pvarList:       The array of SNMP Oids. The type must be a 1D array of BSTRs
*   pvarValue:      The corresponding Oids, it must also b a 1D array of Variants
*
* RETURN VALUE:
*   S_OK:           If succeed.
*   E_INVALIDARG:   Invalid oid or the type of the variant is not a 1D array
*   E_FAIL:         If Open method has not been called before
*   E_OUTOFMEMORY:  Out of memory
*   other:          Returns the last error set by SnmpMgrRequest
*
\*****************************************************************************/
STDMETHODIMP
CSNMP::
SetList(
    IN  VARIANT * varName,
    IN  VARIANT * varValue
    )
{
    RFC1157VarBindList  rfcVarList = {NULL, 0};
    AsnInteger          asniErrorStatus;
    AsnInteger          asniErrorIndex;
    HRESULT             hr = E_FAIL;
    SAFEARRAY           *psaName, *psaValue;
    long                lLowBound, lUpperBound;
    long                ix[1];

    if (m_SNMPSession == NULL)
        return Error(IDS_NO_SNMP_SESSION, IID_ISNMP, E_FAIL);

    if (!(varName->vt & VT_ARRAY) || !(varValue->vt & VT_ARRAY))
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    if (varName->vt & VT_BYREF)
        psaName = *(varName->pparray);
    else
        psaName = varName->parray;

    if (varValue->vt & VT_BYREF)
        psaValue = *(varValue->pparray);
    else
        psaValue = varValue->parray;

    if (SafeArrayGetDim(psaName) != 1 || SafeArrayGetDim(psaValue) != 1)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    SafeArrayGetLBound(psaName, 1, &lLowBound);
    SafeArrayGetUBound(psaName, 1, &lUpperBound);

    long lVal;

    SafeArrayGetLBound(psaValue, 1, &lVal);
    if (lVal != lLowBound)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
    SafeArrayGetUBound(psaValue, 1, &lVal);
    if (lVal != lUpperBound)
        return Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);

    for (ix[0] = lLowBound; ix[0] <= lUpperBound; ix[0]++) {
        VARIANT             varArgName, varArgValue;

        VariantClear(&varArgName);
        VariantClear(&varArgValue);

        hr = SafeArrayGetElement(psaName, ix, &varArgName);
        if (FAILED (hr)) {
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }

        if (varArgName.vt != VT_BSTR) {
            hr = Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            goto Cleanup;
        }

        hr = SafeArrayGetElement(psaValue, ix, &varArgValue);
        if (FAILED (hr))
            goto Cleanup;

        if (FAILED (hr = VarListAdd(varArgName.bstrVal, &rfcVarList, &varArgValue)))
            goto Cleanup;
    }

    if (! SnmpMgrRequest(m_SNMPSession,
                         ASN_RFC1157_SETREQUEST,
                         &rfcVarList,
                         &asniErrorStatus,
                         &asniErrorIndex))
    {
        hr = SetWinSnmpApiError (GetLastError ());
        goto Cleanup;
    }

    if (asniErrorStatus > 0) {
        hr = SetSnmpScriptError(asniErrorStatus);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    SnmpUtilVarBindListFree(&rfcVarList);
    return hr;
}


HRESULT
CSNMP::
SetSnmpScriptError(
    IN  DWORD dwError
    )
{
    static DWORD SnmpErrorMapping [] = {
        IDS_SNMP_ERRORSTATUS_NOERROR,
        IDS_SNMP_ERRORSTATUS_TOOBIG,
        IDS_SNMP_ERRORSTATUS_NOSUCHNAME,
        IDS_SNMP_ERRORSTATUS_BADVALUE,
        IDS_SNMP_ERRORSTATUS_READONLY,
        IDS_SNMP_ERRORSTATUS_GENERR,
        IDS_SNMP_ERRORSTATUS_NOACCESS,
        IDS_SNMP_ERRORSTATUS_WRONGTYPE,
        IDS_SNMP_ERRORSTATUS_WRONGLENGTH,
        IDS_SNMP_ERRORSTATUS_WRONGENCODING,
        IDS_SNMP_ERRORSTATUS_WRONGVALUE,
        IDS_SNMP_ERRORSTATUS_NOCREATION,
        IDS_SNMP_ERRORSTATUS_INCONSISTENTVALUE,
        IDS_SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE,
        IDS_SNMP_ERRORSTATUS_COMMITFAILED,
        IDS_SNMP_ERRORSTATUS_UNDOFAILED,
        IDS_SNMP_ERRORSTATUS_AUTHORIZATIONERROR,
        IDS_SNMP_ERRORSTATUS_NOTWRITABLE,
        IDS_SNMP_ERRORSTATUS_INCONSISTENTNAME};

    if ((int)dwError < 0 || dwError > sizeof (SnmpErrorMapping) / sizeof (DWORD))
        dwError = SNMP_ERRORSTATUS_GENERR;
    return Error(SnmpErrorMapping[dwError], IID_ISNMP, E_FAIL);
}

HRESULT
CSNMP::
SetWinSnmpApiError(
    IN  DWORD dwError
    )
{
    static DWORD WinSnmpApiErrorMapping [] = {
        IDS_SNMPAPI_ALLOC_ERROR,
        IDS_SNMPAPI_CONTEXT_INVALID,
        IDS_SNMPAPI_CONTEXT_UNKNOWN,
        IDS_SNMPAPI_ENTITY_INVALID,
        IDS_SNMPAPI_ENTITY_UNKNOWN,
        IDS_SNMPAPI_INDEX_INVALID,
        IDS_SNMPAPI_NOOP,
        IDS_SNMPAPI_OID_INVALID,
        IDS_SNMPAPI_OPERATION_INVALID,
        IDS_SNMPAPI_OUTPUT_TRUNCATED,
        IDS_SNMPAPI_PDU_INVALID,
        IDS_SNMPAPI_SESSION_INVALID,
        IDS_SNMPAPI_SYNTAX_INVALID,
        IDS_SNMPAPI_VBL_INVALID,
        IDS_SNMPAPI_MODE_INVALID,
        IDS_SNMPAPI_SIZE_INVALID,
        IDS_SNMPAPI_NOT_INITIALIZED,
        IDS_SNMPAPI_MESSAGE_INVALID,
        IDS_SNMPAPI_HWND_INVALID,
        IDS_SNMPAPI_OTHER_ERROR,
        IDS_SNMPAPI_TL_NOT_INITIALIZED,
        IDS_SNMPAPI_TL_NOT_SUPPORTED,
        IDS_SNMPAPI_TL_NOT_AVAILABLE,
        IDS_SNMPAPI_TL_RESOURCE_ERROR,
        IDS_SNMPAPI_TL_UNDELIVERABLE,
        IDS_SNMPAPI_TL_SRC_INVALID,
        IDS_SNMPAPI_TL_INVALID_PARAM,
        IDS_SNMPAPI_TL_IN_USE,
        IDS_SNMPAPI_TL_TIMEOUT,
        IDS_SNMPAPI_TL_PDU_TOO_BIG,
        IDS_SNMPAPI_TL_OTHER
    };

    static DWORD WinSnmpApiError [] = {
        SNMPAPI_ALLOC_ERROR,
        SNMPAPI_CONTEXT_INVALID,
        SNMPAPI_CONTEXT_UNKNOWN,
        SNMPAPI_ENTITY_INVALID,
        SNMPAPI_ENTITY_UNKNOWN,
        SNMPAPI_INDEX_INVALID,
        SNMPAPI_NOOP,
        SNMPAPI_OID_INVALID,
        SNMPAPI_OPERATION_INVALID,
        SNMPAPI_OUTPUT_TRUNCATED,
        SNMPAPI_PDU_INVALID,
        SNMPAPI_SESSION_INVALID,
        SNMPAPI_SYNTAX_INVALID,
        SNMPAPI_VBL_INVALID,
        SNMPAPI_MODE_INVALID,
        SNMPAPI_SIZE_INVALID,
        SNMPAPI_NOT_INITIALIZED,
        SNMPAPI_MESSAGE_INVALID,
        SNMPAPI_HWND_INVALID,
        SNMPAPI_OTHER_ERROR,
        SNMPAPI_TL_NOT_INITIALIZED,
        SNMPAPI_TL_NOT_SUPPORTED,
        SNMPAPI_TL_NOT_AVAILABLE,
        SNMPAPI_TL_RESOURCE_ERROR,
        SNMPAPI_TL_UNDELIVERABLE,
        SNMPAPI_TL_SRC_INVALID,
        SNMPAPI_TL_INVALID_PARAM,
        SNMPAPI_TL_IN_USE,
        SNMPAPI_TL_TIMEOUT,
        SNMPAPI_TL_PDU_TOO_BIG,
        SNMPAPI_TL_OTHER
    };

    for (int i = 0; i < sizeof (WinSnmpApiError); i++) {
        if (dwError == WinSnmpApiError[i]) {
            dwError = WinSnmpApiErrorMapping[i];
            break;
        }
    }
    return Error(dwError, IID_ISNMP, E_FAIL);

}

// Convert part of the the variant array to
// RFC1157VarBindList used in SnmpMgrRequest call
HRESULT
CSNMP::
VarToRfcVarList(
    long lbound,
    long ubound,
    SAFEARRAY *psa,
    RFC1157VarBindList * prfcVarList
    )
{
    long                ix[1];
    VARIANT             var;
    HRESULT             hr = S_OK;

    for (ix[0] = lbound; ix[0] <= ubound; ix[0]++) {
        VariantClear(&var);
        hr = SafeArrayGetElement(psa, ix, &var);
        if (FAILED (hr) || var.vt != VT_BSTR) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }

        hr = VarListAdd(var.bstrVal, prfcVarList);
        if (FAILED (hr)) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }
    }
    return hr;
}

// Append RFC1157VarBindList used in SnmpMgrRequest call at the
// end of the variant array
HRESULT
CSNMP::
RfcToVarList(
    long lbound,
    RFC1157VarBindList *prfcVarList,
    SAFEARRAY * psaOut
    )
{
    long                ix[1];
    DWORD               i;
    VARIANT             var;
    HRESULT             hr = S_OK;

    for(ix[0] = lbound, i = 0; i < prfcVarList->len; i++, ix[0]++) {
        hr = RFC1157ToVariant(&var, & prfcVarList->list[i]);
        if (FAILED (hr))
            break;

        hr = SafeArrayPutElement(psaOut, ix, &var);
        if (FAILED (hr)) {
            Error(IDS_INVALIDARG, IID_ISNMP, E_INVALIDARG);
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\prnsec.h ===
/*****************************************************************************\
* MODULE:       prnsec.h
*
* PURPOSE:      Declaration of the security class that determines the required
*               security settings for a com class. Interacts with the security
*               manager to determine the zone that we are running under.
*
* Copyright (C) 1999 Microsoft Corporation
*
* History:
*
*     09/2/99  mlawrenc    Declaration of security templates
*
\*****************************************************************************/

#ifndef __PRNSEC_H_
#define __PRNSEC_H_

#include "stdafx.h"
#include "urlmon.h"

class ATL_NO_VTABLE COlePrnSecurity {
/*++

Class Description
        This is the class that we we use for a mix in in all the printer classes that require
        zone based security. It also automatically loads any string resources it needs.
    
--*/
public:
    // Enumeration, Security Messages, these messages must correspond to the resource order
    // given from START_SECURITY_DIALOGUE_RES

    enum SecurityMessage {
        StartMessages = 0,
        AddWebPrinterConnection = 0,
        AddPrinterConnection,
        DeletePrinterConnection,
        EndMessages
    };

    static BOOL    InitStrings(void);
    static void    DeallocStrings(void);       
    static HRESULT PromptUser( SecurityMessage, LPTSTR ); 

    inline BOOL DisplayUIonDisallow(BOOL);   // Set to FALSE if we don't want IE to pop
                                             // up UI on disallow or Query
    virtual ~COlePrnSecurity();
protected:	
    // Protected Methods
    COlePrnSecurity(IUnknown *&iSite, DWORD &dwSafety); 

    HRESULT GetActionPolicy(DWORD dwAction, DWORD &dwPolicy);  
                                             // Find out if the action is allowed
private:
    // Private Methods
    HRESULT SetSecurityManager(void);
    static  LPTSTR LoadResString(UINT uResId);
    static const DWORD  dwMaxResBuf;     

    // Private Data Members
    IUnknown*                    &m_iSite;               // The site under which we are located
    DWORD                        &m_dwSafetyFlags;       // The safety set for the site 
    BOOL                         m_bDisplayUIonDisallow; // Should we ask for UI when Policy is Disallow? Default TRUE
    IInternetHostSecurityManager *m_iSecurity;           // Use this to get the security information of
                                                         // the site we are running under
    static LPTSTR                m_MsgStrings[EndMessages*2];
};

template<class T>
class ATL_NO_VTABLE COlePrnSecComControl : public CComControl<T>,
                                           public IObjectSafetyImpl<T>,
                                           public COlePrnSecurity {
/*++

Class Description
        A class which wishes to use the security control just needs to derive from this.
        Used to to illiminate having to templatise COlePrnSecurity
    
--*/
public:
    COlePrnSecComControl() : COlePrnSecurity(*(IUnknown **)&m_spClientSite, m_dwSafety) {}
};

template<class T>
class ATL_NO_VTABLE COlePrnSecObject : public IObjectWithSiteImpl<T>,
                                       public IObjectSafetyImpl<T>,
                                       public COlePrnSecurity 
/*++

Class Description
        A class which wishes to use the security control just needs to derive from this.
        This is for classes that are not OleObjects (i.e. do not have IOleObjectImpl<T> in 
        their inheritance. IE can use the lighter weight IObjectWithSite interface for
        these objects
        
--*/
    {
public:
    COlePrnSecObject() : COlePrnSecurity(*(IUnknown **)&m_spUnkSite, m_dwSafety) {}
};


////////////////////////////////////////////////////////////////////////////////
// INLINE METHODS
////////////////////////////////////////////////////////////////////////////////
inline BOOL COlePrnSecurity::DisplayUIonDisallow(BOOL bNewSetting) {
    BOOL bOldSetting = m_bDisplayUIonDisallow;
    m_bDisplayUIonDisallow = bNewSetting;
    return bOldSetting;
}

#endif  // __PRNSEC_H_

/*******************************************************************************
** End of File (prnsec.h)
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\prnsec.cpp ===
/*****************************************************************************\
* MODULE:       prnsec.cpp
*
* PURPOSE:      Implementations 
*
* Copyright (C) 1999 Microsoft Corporation
*
* History:
*
*     09/2/99  mlawrenc    First implemented the security templates
*
\*****************************************************************************/

#include <stdio.h>

#include "stdafx.h"
#include <strsafe.h>
#include "prnsec.h"


///////////////////////////////////////////////////////////////////////////////
// Static Data Members
///////////////////////////////////////////////////////////////////////////////
LPTSTR      COlePrnSecurity::m_MsgStrings[EndMessages*2] = { NULL };
const DWORD COlePrnSecurity::dwMaxResBuf                 = 256;

///////////////////////////////////////////////////////////////////////////////
// Methods
///////////////////////////////////////////////////////////////////////////////
COlePrnSecurity::COlePrnSecurity(IN IUnknown *&iSite, 
                                 IN DWORD &dwSafety ) 
/*++

Routine Description:

    This initialises all of the required members

Arguments:
            iSite    - A reference to the Site Interface pointer
            dwSafety - A reference to the ATL Safety Flags member
                   
--*/
    : m_iSite(iSite),
      m_dwSafetyFlags(dwSafety),
      m_bDisplayUIonDisallow(TRUE),
      m_iSecurity(NULL) {
}


COlePrnSecurity::~COlePrnSecurity() 
/*++

Routine Description:

    This clears any memory we have had to allocate

--*/
    {
    if (m_iSecurity) 
        m_iSecurity->Release();
}



HRESULT COlePrnSecurity::GetActionPolicy(IN  DWORD dwAction, 
                                         OUT DWORD &dwPolicy)
/*++

Routine Description:
    Sees whether the requested action is allowed by the site. 
    

Arguments:
    dwAction    : The action which we want to perform
    dwPolicy    : The policy associated with the action
    
Return Value:
    S_OK or S_FAIL the Policy was returned, S_OK generally means don't prompt
    E_XXXXX

--*/
    {
    HRESULT hr = S_OK;

    dwPolicy = URLPOLICY_DISALLOW;
    
    if (!(m_dwSafetyFlags & INTERFACESAFE_FOR_UNTRUSTED_CALLER)) {
        dwPolicy = URLPOLICY_ALLOW;
        goto Cleanup;
    }
       
    if (NULL == m_iSecurity &&
        FAILED( hr = SetSecurityManager()) ) 
        goto Cleanup;
    
    _ASSERTE(m_iSecurity != NULL);

    hr = m_iSecurity->ProcessUrlAction(dwAction,
                                       (LPBYTE)&dwPolicy,
                                       sizeof(dwPolicy),
                                       NULL,
                                       0,
                                       m_bDisplayUIonDisallow ? PUAF_WARN_IF_DENIED : PUAF_NOUI,
                                       0);
    if (FAILED(hr)) {
        dwPolicy = URLPOLICY_DISALLOW;
        goto Cleanup;
    }
    
Cleanup:

    return hr;
}


HRESULT COlePrnSecurity::SetSecurityManager(void) 
/*++

Routine Description:
    Sets up the security manager 
    
Return Value:
    E_FAIL         - Failed to instantiate
    E_NOINTERFACE  - There was no security Manager
    S_OK           - We instantiated the security manager

--*/
    {
    HRESULT          hr                 = E_NOINTERFACE;
    IServiceProvider *iServiceProvider  = NULL;
    
    if (NULL != m_iSecurity) {
        hr = S_OK;
        goto Cleanup;
    }

    if (NULL == m_iSite)
        goto Cleanup;
    
    if ( FAILED(hr = m_iSite->QueryInterface(IID_IServiceProvider, 
                                             (LPVOID *)&iServiceProvider) ) )
        goto Cleanup;
    
    // From the Service Provider, we can get the security Manager if there is one
    hr = iServiceProvider->QueryService(SID_SInternetHostSecurityManager,
                                        IID_IInternetHostSecurityManager,
                                        (LPVOID *)&m_iSecurity);

    // Either of these are equivalent to allowing the policy to go through
    // We have a Security Manager
Cleanup:

    if (iServiceProvider) 
        iServiceProvider->Release();

    return hr;
}


LPTSTR COlePrnSecurity::LoadResString(UINT uResId)
/*++

Routine Description:
    Allocate and return a resource string.
    
Parameters:
    uResId  - Resource Id to load    
    
Return Value:
    The String or NULL

--*/
    {
    TCHAR  szStr[dwMaxResBuf];
    DWORD  dwLength;
    LPTSTR lpszRet = NULL;


    dwLength = LoadString(_Module.GetResourceInstance(), uResId, szStr, dwMaxResBuf);
    
    if (dwLength == 0) 
        goto Cleanup;

    dwLength = (dwLength + 1)*sizeof(TCHAR);
    
    lpszRet = (LPTSTR)LocalAlloc( LPTR, dwLength );

    if (NULL == lpszRet) 
        goto Cleanup;

    //
    // Use byte-size there.
    //
    StringCbCopy( lpszRet, dwLength, szStr );

Cleanup:
    return lpszRet;
}

BOOL COlePrnSecurity::InitStrings(void) 
/*++

Routine Description:
    Initialise all of the security strings. It either allocates all of them or none
    
Return Value:
    TRUE if successful, False otherwise

--*/
    {
    BOOL bRet = TRUE;

    for(DWORD dwIndex = StartMessages; dwIndex < (EndMessages*2); dwIndex++) {
        m_MsgStrings[dwIndex] = LoadResString(START_SECURITY_DIALOGUE_RES + dwIndex);
        if (NULL == m_MsgStrings[dwIndex]) {
            DeallocStrings();       // Deallocate any we have allocated
            bRet = FALSE;
            break;
        }
    }

    return bRet;
}

void COlePrnSecurity::DeallocStrings(void)  
/*++

Routine Description:
    Deallocate all of the security strings
   
--*/
    {
    for(DWORD dwIndex = StartMessages; dwIndex < (EndMessages*2); dwIndex++) {
        if (NULL != m_MsgStrings[dwIndex]) {
            LocalFree( m_MsgStrings[dwIndex]);
            m_MsgStrings[dwIndex] = NULL;
        }
    }
}

HRESULT COlePrnSecurity::PromptUser(SecurityMessage eMessage,
                                    LPTSTR          lpszOther) 
/*++

Routine Description:
    Prompt the user with a [Yes]/[No] Message Box based on the message passed in and
    the other string passed in (which is substituted in with sprintf()
    
Parameters:
    eMessage  - The Message to display
    lpszOther - Other Data to display
    
Return Value:
    E_POINTER       - lpszOther was NULL
    E_OUTOFMEMORY   - Could not allocate temporary storage
    E_UNEXPECTED    - sprintf wrote more character than we thought
    S_OK            - The Dialogue Box was displayed and the user selected [Yes]
    S_FALSE         - The Dialogue Box was displayed and the user selected [No]

--*/
    {
    HRESULT hr          = E_POINTER;
    DWORD   dwIndex     = ((DWORD)eMessage)*2;
    LPTSTR  lpszMessage = NULL;
    DWORD   dwLength;
    int     iMBRes;     
    

    if (NULL == lpszOther) 
        goto Cleanup;

    _ASSERTE( dwIndex < EndMessages );              // Must be a valid message
    _ASSERTE( m_MsgStrings[dwIndex    ]  != NULL ); // The table must have been initialised
    _ASSERTE( m_MsgStrings[dwIndex + 1]  != NULL );
    
    // Required Length of the message string
    dwLength = lstrlen( m_MsgStrings[dwIndex+1] ) + lstrlen( lpszOther ) + 1; 
    
    lpszMessage = (LPTSTR)LocalAlloc( LPTR , dwLength * sizeof(TCHAR) );

    if (NULL == lpszMessage) 
        goto Cleanup;

    if ( FAILED( StringCchPrintf( lpszMessage, dwLength, m_MsgStrings[dwIndex+1], lpszOther ))) {
        hr   = E_UNEXPECTED;
        goto Cleanup;
    }

    // Now display the MessageBox

    iMBRes = MessageBox( NULL,
                         lpszMessage,
                         m_MsgStrings[dwIndex],
                         MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 );

    switch(iMBRes) {
    case IDYES: hr = S_OK;          break;
    case IDNO:  hr = S_FALSE;       break;
    default:    hr = E_UNEXPECTED;  break;
    }

Cleanup:
    if (NULL != lpszMessage) 
        LocalFree( lpszMessage );

    return hr;
}

/***********************************************************************************
** End of File (prnsec.cpp)
**********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\prturl.cpp ===
// prturl.cpp : Implementation of Cprturl
#include "stdafx.h"
#include <strsafe.h>
#include "gensph.h"

#include "oleprn.h"
#include "prturl.h"
#include "printer.h"

/////////////////////////////////////////////////////////////////////////////
// Cprturl

// generate proper HRESULT from Win32 last error
inline HRESULT HRESULTFromWIN32()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

HRESULT Cprturl::PrivateGetSupportValue (LPTSTR pValueName, BSTR * pVal)
{
// The max length of the link is 255 as defined in winnt.adm
#define MAX_LINK_LEN 256

    static  TCHAR szPrinterPath[]   = TEXT ("Software\\Policies\\Microsoft\\Windows NT\\Printers");
    HKEY    hPrinterKey             = NULL;
    TCHAR   szBuffer[MAX_LINK_LEN]  = {0};
    BOOL    bRet                    = FALSE;
    DWORD   dwSize                  = sizeof (szBuffer);
    DWORD   dwType;

    if (ERROR_SUCCESS == RegOpenKeyEx  (HKEY_LOCAL_MACHINE,
                                        szPrinterPath,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hPrinterKey)) {

        if ((ERROR_SUCCESS == RegQueryValueEx (hPrinterKey,
                                               pValueName,
                                               0,
                                               &dwType,
                                               (LPBYTE) szBuffer,
                                               &dwSize))
             && dwType == REG_SZ) {

            szBuffer[ARRAYSIZE(szBuffer) - 1] = 0;
            bRet = TRUE;

        }

        RegCloseKey (hPrinterKey);
    }

    if (!bRet) {
        szBuffer[0] = 0;
    }

    if (*pVal = SysAllocString (szBuffer))
        return S_OK;
    else
        return Error(IDS_OUT_OF_MEMORY, IID_Iprturl, E_OUTOFMEMORY);
}

STDMETHODIMP Cprturl::get_SupportLinkName(BSTR * pVal)
{
   return PrivateGetSupportValue (TEXT ("SupportLinkName"), pVal);
}

STDMETHODIMP Cprturl::get_SupportLink(BSTR * pVal)
{
   return PrivateGetSupportValue (TEXT ("SupportLink"), pVal);
}

STDMETHODIMP Cprturl::put_PrinterName(BSTR newVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!newVal || 0 == newVal[0])
        {
            //
            // The printer name can't ne NULL or empty string.
            //
            hr = E_INVALIDARG;
            break;
        }

        CPrinter printer;
        if (!printer.Open(newVal))
        {
            //
            // Failed to open the printer. This is fatal.
            //
            hr = HRESULTFromWIN32();
            break;
        }

        LPTSTR pszOemName = NULL;
        LPTSTR pszOemUrl = printer.GetOemUrl(pszOemName);
        LPTSTR pszWebUrl = printer.GetPrinterWebUrl();

        CAutoPtrBSTR spbstrPrinterWebURL = SysAllocString(pszWebUrl);
        CAutoPtrBSTR spbstrPrinterOemURL = SysAllocString(pszOemUrl);
        CAutoPtrBSTR spbstrPrinterOemName = SysAllocString(pszOemName);

        if ((pszWebUrl  && !spbstrPrinterWebURL) || 
            (pszOemUrl  && !spbstrPrinterOemURL) || 
            (pszOemName && !spbstrPrinterOemName))
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // If we are here then everything has succeeded.
        // Remember the new strings.
        //
        m_spbstrPrinterWebURL = spbstrPrinterWebURL.Detach();
        m_spbstrPrinterOemURL = spbstrPrinterOemURL.Detach();
        m_spbstrPrinterOemName = spbstrPrinterOemName.Detach();
        hr = S_OK;
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterWebURL(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterWebURL)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterWebURL);
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterOemURL(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterOemURL)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterOemURL);
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_PrinterOemName(BSTR *pVal)
{
    HRESULT hr = S_OK;
    do
    {
        if (!pVal)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!m_spbstrPrinterOemName)
        {
            hr = E_UNEXPECTED;
            break;
        }

        *pVal = SysAllocString(m_spbstrPrinterOemName);
    }
    while(false);
    return hr;
}

STDMETHODIMP Cprturl::get_ClientInfo(long *lpdwInfo)
{
    if (lpdwInfo == NULL)
        return E_POINTER;

    *lpdwInfo = (long)webCreateOSInfo();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\resource.h ===
// This script must be edited manually, originally generated by Visual Studio
//
// Used by oleprn.rc
//
#define IDS_PROJNAME                    100
#define IDR_PRTURL                      101
#define IDR_SNMP                        102
#define IDR_ASPHELP                     103
#define IDR_DSPRINTQUEUE                104
#define IDR_OLECVT                      109
#define IDR_OLEINSTALL                  110

#define IDS_ENVELOPE_10X13              150
#define IDS_ENVELOPE_10X14              151
#define IDS_ENVELOPE_10X15              152
#define IDS_ENVELOPE_6X9                153
#define IDS_ENVELOPE_7X9                154
#define IDS_ENVELOPE_9X11               155
#define IDS_ENVELOPE_9X12               156
#define IDS_A0_841_X_1189_MM            157
#define IDS_A1_594_X_841_MM             158
#define IDS_A10_26_X_37_MM              159
#define IDS_A2_420_X_594_MM             160
#define IDS_A3_297_X_420_MM             161
#define IDS_A4_210_X_297_MM             163
#define IDS_A5_148_X_210_MM             164
#define IDS_A6_105_X_148_MM             165
#define IDS_A7_74_X_105_MM              166
#define IDS_A8_52_X_74_MM               167
#define IDS_A9_37_X_52_MM               168
#define IDS_B0_1000_X_1414_MM           169
#define IDS_B0_1030_X_1456_MM           170
#define IDS_B1_707_X_1000_MM            171
#define IDS_B1_728_X_1030_MM            172
#define IDS_B10_31_X_44_MM              173
#define IDS_B10_32_X_45_MM              174
#define IDS_B10_64_X_91_MM              175
#define IDS_B2_500_X_707_MM             176
#define IDS_B2_515_X_728_MM             177
#define IDS_B3_353_X_500_MM             178
#define IDS_B3_364_X_515_MM             179
#define IDS_B4_250_X_353_MM             180
#define IDS_B4_257_X_364_MM             181
#define IDS_B4_ENVELOPE_250_X_353_MM    182
#define IDS_B5_176_X_250_MM             183
#define IDS_B5_182_X_257_MM             184
#define IDS_B5_ENVELOPE_176_X_250_MM    185
#define IDS_B6_125_X_176_MM             186
#define IDS_B6_128_X_182_MM             187
#define IDS_B6_257_X_364_MM             188
#define IDS_B7_182_X_257_MM             189
#define IDS_B7_88_X_125_MM              190
#define IDS_B7_91_X_128_MM              191
#define IDS_B8_128_X_182_MM             192
#define IDS_B8_62_X_88_MM               193
#define IDS_B8_64_X_91_MM               194
#define IDS_B9_44_X_62_MM               195
#define IDS_B9_45_X_64_MM               196
#define IDS_B9_91_X_128_MM              197
#define IDS_C0_917_X_1297_MM            198
#define IDS_C1_648_X_917_MM             199
#define IDI_WEBPNPICON                  200
#define IDS_C2_458_X_648_MM             200
#define IDS_C3_324_X_458_MM             201
#define IDS_C4_ENVELOPE_229_X_324_MM    202
#define IDS_C5_ENVELOPE_162_X_229_MM    203
#define IDS_C6_114_X_162_MM             204
#define IDS_C7_81_X_114_MM              205
#define IDS_C8_57_X_81_MM               206
#define IDS_DL_ENVELOPE_110_X_220_MM    207
#define IDS_ENGINEERING_A_8_5_X_11_IN   208
#define IDS_ENGINEERING_B_11_X_17_IN    209
#define IDS_ENGINEERING_C_17_X_22_IN    210
#define IDS_ENGINEERING_D_22_X_34_IN    211
#define IDS_ENGINEERING_E_34_X_44_IN    212
#define IDS_ENVELOPE_10                 213
#define IDS_ENVELOPE_9                  214
#define IDS_LEGAL_8_5_X_14_IN           215
#define IDS_LETTER_8_5_X_11_IN          216
#define IDS_SNMP_ERRORSTATUS_NOERROR    250
#define IDS_SNMP_ERRORSTATUS_TOOBIG     251
#define IDS_SNMP_ERRORSTATUS_NOSUCHNAME 252
#define IDS_SNMP_ERRORSTATUS_BADVALUE   253
#define IDS_SNMP_ERRORSTATUS_READONLY   254
#define IDS_SNMP_ERRORSTATUS_GENERR     255
#define IDS_SNMP_ERRORSTATUS_NOACCESS   256
#define IDS_SNMP_ERRORSTATUS_WRONGTYPE  257
#define IDS_SNMP_ERRORSTATUS_WRONGLENGTH 258
#define IDS_SNMP_ERRORSTATUS_WRONGENCODING 259
#define IDS_SNMP_ERRORSTATUS_WRONGVALUE 260
#define IDS_SNMP_ERRORSTATUS_NOCREATION 261
#define IDS_SNMP_ERRORSTATUS_INCONSISTENTVALUE 262
#define IDS_SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE 263
#define IDS_SNMP_ERRORSTATUS_COMMITFAILED 264
#define IDS_SNMP_ERRORSTATUS_UNDOFAILED 265
#define IDS_SNMP_ERRORSTATUS_AUTHORIZATIONERROR 266
#define IDS_SNMP_ERRORSTATUS_NOTWRITABLE 267
#define IDS_SNMP_ERRORSTATUS_INCONSISTENTNAME 268
#define IDS_SNMPAPI_ALLOC_ERROR         270
#define IDS_SNMPAPI_CONTEXT_INVALID     271
#define IDS_SNMPAPI_CONTEXT_UNKNOWN     272
#define IDS_SNMPAPI_ENTITY_INVALID      274
#define IDS_SNMPAPI_ENTITY_UNKNOWN      275
#define IDS_SNMPAPI_INDEX_INVALID       276
#define IDS_SNMPAPI_NOOP                277
#define IDS_SNMPAPI_OID_INVALID         278
#define IDS_SNMPAPI_OPERATION_INVALID   279
#define IDS_SNMPAPI_OUTPUT_TRUNCATED    280
#define IDS_SNMPAPI_PDU_INVALID         281
#define IDS_SNMPAPI_SESSION_INVALID     282
#define IDS_SNMPAPI_SYNTAX_INVALID      283
#define IDS_SNMPAPI_VBL_INVALID         284
#define IDS_SNMPAPI_MODE_INVALID        285
#define IDS_SNMPAPI_SIZE_INVALID        286
#define IDS_SNMPAPI_NOT_INITIALIZED     287
#define IDS_SNMPAPI_MESSAGE_INVALID     288
#define IDS_SNMPAPI_HWND_INVALID        289
#define IDS_SNMPAPI_OTHER_ERROR         290
#define IDS_SNMPAPI_TL_NOT_INITIALIZED  291
#define IDS_SNMPAPI_TL_NOT_SUPPORTED    292
#define IDS_SNMPAPI_TL_NOT_AVAILABLE    293
#define IDS_SNMPAPI_TL_RESOURCE_ERROR   294
#define IDS_SNMPAPI_TL_UNDELIVERABLE    295
#define IDS_SNMPAPI_TL_SRC_INVALID      296
#define IDS_SNMPAPI_TL_INVALID_PARAM    297
#define IDS_SNMPAPI_TL_IN_USE           298
#define IDS_SNMPAPI_TL_TIMEOUT          299
#define IDS_SNMPAPI_TL_PDU_TOO_BIG      300
#define IDS_SNMPAPI_TL_OTHER            301

#define IDS_NO_PRINTER_OPEN             512
#define IDS_OUT_OF_MEMORY               513
#define IDS_DATA_NOT_SUPPORTED          514
#define IDS_NO_XCVDATA                  515
#define IDS_INVALIDARG                  516
#define IDS_NO_SNMP_SESSION             517
#define IDS_FAILED_OPEN_SNMP            518
#define IDS_MIBERR_OTHER                1000
#define IDS_MIBERR_UNKNOWN              1001
#define IDS_MIBERR_COVEROPEN            1002
#define IDS_MIBERR_COVERCLOSED          1003
#define IDS_MIBERR_INTERLOCKOPEN        1004
#define IDS_MIBERR_INTERLOCKCLOSED      1005
#define IDS_MIBERR_CONFIGURATIONCHANGE  1006
#define IDS_MIBERR_JAM                  1007
#define IDS_MIBERR_DOOROPEN             1008
#define IDS_MIBERR_DOORCLOSED           1009
#define IDS_MIBERR_POWERUP              1010
#define IDS_MIBERR_POWERDOWN            1011
#define IDS_MIBERR_INPUTMEDIATRAYMISSING 1012
#define IDS_MIBERR_INPUTMEDIASIZECHANGE 1013
#define IDS_MIBERR_INPUTMEDIAWEIGHTCHANGE 1014
#define IDS_MIBERR_INPUTMEDIATYPECHANGE 1015
#define IDS_MIBERR_INPUTMEDIACOLORCHANGE 1016
#define IDS_MIBERR_INPUTMEDIAFORMPARTSCHANGE 1017
#define IDS_MIBERR_INPUTMEDIASUPPLYLOW  1018
#define IDS_MIBERR_INPUTMEDIASUPPLYEMPTY 1019
#define IDS_MIBERR_OUTPUTMEDIATRAYMISSING 1020
#define IDS_MIBERR_OUTPUTMEDIATRAYALMOSTFULL 1021
#define IDS_MIBERR_OUTPUTMEDIATRAYFULL  1022
#define IDS_MIBERR_MARKERFUSERUNDERTEMPERATURE 1023
#define IDS_MIBERR_MARKERFUSEROVERTEMPERATURE 1024
#define IDS_MIBERR_MARKERTONEREMPTY     1025
#define IDS_MIBERR_MARKERINKEMPTY       1026
#define IDS_MIBERR_MARKERPRINTRIBBONEMPTY 1027
#define IDS_MIBERR_MARKERTONERALMOSTEMPTY 1028
#define IDS_MIBERR_MARKERINKALMOSTEMPTY 1029
#define IDS_MIBERR_MARKERPRINTRIBBONALMOSTEMPTY 1030
#define IDS_MIBERR_MARKERWASTETONERRECEPTACLEALMOSTFULL 1031
#define IDS_MIBERR_MARKERWASTEINKRECEPTACLEALMOSTFULL 1032
#define IDS_MIBERR_MARKERWASTETONERRECEPTACLEFULL 1033
#define IDS_MIBERR_MARKERWASTEINKRECEPTACLEFULL 1034
#define IDS_MIBERR_MARKEROPCLIFEALMOSTOVER 1035
#define IDS_MIBERR_MARKEROPCLIFEOVER    1036
#define IDS_MIBERR_MARKERDEVELOPERALMOSTEMPTY 1037
#define IDS_MIBERR_MARKERDEVELOPEREMPTY 1038
#define IDS_MIBERR_MEDIAPATHMEDIATRAYMISSING 1039
#define IDS_MIBERR_MEDIAPATHMEDIATRAYALMOSTFULL 1040
#define IDS_MIBERR_MEDIAPATHMEDIATRAYFULL 1041
#define IDS_MIBERR_INTERPRETERMEMORYINCREASE 1042
#define IDS_MIBERR_INTERPRETERMEMORYDECREASE 1043
#define IDS_MIBERR_INTERPRETERCARTRIDGEADDED 1044
#define IDS_MIBERR_INTERPRETERCARTRIDGEDELETED 1045
#define IDS_MIBERR_INTERPRETERRESOURCEADDED 1046
#define IDS_MIBERR_INTERPRETERRESOURCEDELETED 1047
#define IDS_MIBERR_INTERPRETERRESOURCEUNAVAILABLE 1048
#define IDS_ERROR_CPUNOTSUPPORTED       2000
#define IDS_ERROR_DRIVERNOTFOUND        2001
#define IDS_ERROR_WPNPINST_TERMINATED   2002
#define IDS_ERROR_INTERNAL_SERVER       2003
#define IDS_ERROR_SERVER_DISK_FULL      2004
#define IDS_ERROR_TRUST_E_NOSIGNATURE   2005
#define IDS_ERROR_LOCAL_PRINTER_ACCESS  2006
#define IDS_ERROR_IE_SECURITY_DENIED    2007
#define IDS_CRYPT_E_FILE_ERROR          2008

// The following Resources must be defined in order
#define IDS_SECURITY_ADD_WEB_PRN        3000
#define IDS_SECURITY_ADD_WEB_PRN_MSG    3001
#define IDS_SECURITY_ADD_CONNECTION     3002
#define IDS_SECURITY_ADD_CONNECTION_MSG 3003
#define IDS_SECURITY_DELETE_PRINTER     3004
#define IDS_SECURITY_DELETE_PRINTER_MSG 3005
#define START_SECURITY_DIALOGUE_RES     IDS_SECURITY_ADD_WEB_PRN  // Must be set to the first resource

#define ERROR_DRIVER_NOT_FOUND          5500
#define ERROR_WPNPINST_TERMINATED       5510
#define ERROR_INTERNAL_SERVER           5511
#define ERROR_SERVER_DISK_FULL          5512
#define ERROR_TRUST_E_NOSIGNATURE      (TRUST_E_NOSIGNATURE & 0xFFFF)
#define ERROR_SPAPI_E_NO_CATALOG       (SPAPI_E_NO_CATALOG_FOR_OEM_INF & 0xFFFF)
#define ERROR_TRUST_E_BAD_DIGEST       (TRUST_E_BAD_DIGEST & 0xFFFF)
#define ERROR_LOCAL_PRINTER_ACCESS      5520
#define ERROR_IE_SECURITY_DENIED        5521

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif

#define WM_ON_INFO_READY   (WM_USER+300)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\prturl.h ===
// prturl.h : Declaration of the Cprturl

#ifndef __PRTURL_H_
#define __PRTURL_H_

/////////////////////////////////////////////////////////////////////////////
// Cprturl
class ATL_NO_VTABLE Cprturl :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<Cprturl, &CLSID_prturl>,
    public ISupportErrorInfoImpl<&IID_Iprturl>,
    public IDispatchImpl<Iprturl, &IID_Iprturl, &LIBID_OLEPRNLib>
{
public:
    Cprturl()
    {
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PRTURL)
//DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(Cprturl)
    COM_INTERFACE_ENTRY(Iprturl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// Iprturl

private:
    HRESULT PrivateGetPrinterData(LPTSTR strPrnName, LPTSTR pszKey, LPTSTR pszValueName, BSTR * pVal);
    HRESULT PrivateGetSupportValue (LPTSTR pValueName, BSTR * pVal);

public:
    STDMETHOD(get_SupportLinkName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SupportLink)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_PrinterName)(/* [in] */ BSTR newVal);
    STDMETHOD(get_PrinterWebURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PrinterOemURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PrinterOemName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ClientInfo)(/*[out, retval]*/ long *lpdwInfo);

private:
    CAutoPtrBSTR m_spbstrPrinterWebURL;
    CAutoPtrBSTR m_spbstrPrinterOemURL;
    CAutoPtrBSTR m_spbstrPrinterOemName;
};

#endif //__PRTURL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\stdafx.h ===
#if !defined(AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED_)
#define AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#define STRICT

#define DWERROR           ((DWORD) -1)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <shellapi.h>
#include <shlobj.h>
#include <wininet.h>
#include <spllib.hxx>

#include <oaidl.h>
#include <winsnmp.h>
#include <snmp.h>
#include <mgmtapi.h>

#include "resource.h"
#include "util.h"

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <clusapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7586B344_EC08_11D0_A466_00C04FC30DF6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\perflib\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for router.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Environment:

    User Mode -Win32

Revision History:

--*/


#ifndef MODULE
#define MODULE "SPLPERF:"
#define MODULE_DEBUG SplPerfDebug
#define LINK_SPLPERF
#endif
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

//#include <excpt.h>
//#include <rpc.h>    // DataTypes and runtime APIs
//#include <string.h>

#include <windows.h>
//#include <winspool.h>
//#include <winsplp.h>
//#include <winspl.h> // generated by the MIDL complier
//#include <wininet.h>
#include <splcom.h>
//#include <change.h>
//#include <dbt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\util.cpp ===
/*****************************************************************************\
* MODULE:       util.cpp
*
* PURPOSE:      Tools for OlePrn project
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     08/16/97  paulmo     Created
*     09/12/97  weihaic    Added more functions
*     10/28/97  keithst    Added SetScriptingError
*     11/06/97  keithst    Removed Win2ComErr
*
\*****************************************************************************/
#include "stdafx.h"
#include <strsafe.h>

//---------------------------------------------
//    Put an ANSI string into a SAFEARRAY
//
//
//  Convert the string into UNICODE
//  Make a BSTR out of it
//  Add it to the array
//
HRESULT PutString(SAFEARRAY *psa, long *ix, LPSTR sz)
{
    LPWSTR  lpWstr;
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    var.vt = VT_BSTR;

    if (sz == NULL)
        lpWstr = MakeWide("");
    else
        lpWstr = MakeWide(sz);

    if (lpWstr == NULL) return E_OUTOFMEMORY;

    var.bstrVal = SysAllocString(lpWstr);
    LocalFree(lpWstr);

    if (var.bstrVal == NULL)
        return E_OUTOFMEMORY;

    hr = SafeArrayPutElement(psa, ix, &var);
    VariantClear(&var);
    return hr;
}

// ---------------------------------------------
//  Convert an ANSI string to UNICODE
//
// Note - you must LocalFree the returned string
//

LPWSTR  MakeWide(LPSTR psz)
{
    LPWSTR buff;
    int i;
    if (!(i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0)))
        return NULL;
    buff = (LPWSTR)LocalAlloc(LPTR, i * sizeof(WCHAR));
    if (buff == NULL)
        return NULL;
    if (!(i = MultiByteToWideChar(CP_ACP, 0, psz, -1, buff, i)))
    {
        LocalFree(buff);
        return NULL;
    }
    return buff;
}

//-------------------------------------------------
//  Convert a UNICODE string to ANSI
//
// Note - you must LocalFree the returned string
//
LPSTR MakeNarrow(LPWSTR str)
{
    LPSTR  buff;
    int i;

    if (!(i = WideCharToMultiByte(CP_ACP, 0, str, -1, NULL, 0, NULL, NULL)))
        return NULL;
    buff = (LPSTR )LocalAlloc(LPTR, i * sizeof(CHAR));
    if (buff == NULL)
        return NULL;
    if (!(i = WideCharToMultiByte(CP_ACP, 0, str, -1, buff, i, NULL, NULL)))
    {
        LocalFree(buff);
        return NULL;
    }
    return buff;
}

//-------------------------------------------------
// SetScriptingError
//   Takes a Win32 error code and sets the associated string as
//   the scripting language error description
//
// Parameters:
//   CLSID *pclsid: pointer to Class ID (CLSID) for the class which
//                  generated the error; passed to AtlReportError
//
//   IID *piid:     pointer to interface ID (IID) for the interface
//                  which generated the error; passed to AtlReportError
//
//   DWORD dwError: the error code retrieved from GetLastError by
//                  the caller of this function
//
// Return Value:
//   This function uses the HRESULT_FROM_WIN32 macro, which translates
//   the Win32 dwError code to a COM error code.  This COM error code
//   should be returned out as the return value of the failed method.
//
HRESULT SetScriptingError(const CLSID& rclsid, const IID& riid, DWORD dwError)
{
    LPTSTR  lpMsgBuf = NULL;
    DWORD   dwRet = 0;

    dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          dwError,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL);

    if (dwRet == 0 || !lpMsgBuf)
    {
        //
        // If FormatMessage fails, it returns 0, but since we can not call
        // GetLastError again, we return OUTOFMEMORY instead.
        //
        return E_OUTOFMEMORY;
    }

    AtlReportError(rclsid, lpMsgBuf, riid, HRESULT_FROM_WIN32(dwError));

    LocalFree(lpMsgBuf);

    return (HRESULT_FROM_WIN32(dwError));
}


HANDLE
RevertToPrinterSelf(
    VOID)
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_IMPERSONATE,
                 TRUE,
                 &OldToken
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    return OldToken;

}

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&hToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    NtClose(hToken);

    return TRUE;
}

DWORD MyDeviceCapabilities(
    LPCTSTR pDevice,    // pointer to a printer-name string
    LPCTSTR pPort,      // pointer to a port-name string
    WORD fwCapability,  // device capability to query
    LPTSTR pOutput,     // pointer to the output
    CONST DEVMODE *pDevMode
                      // pointer to structure with device data
    )
{
    DWORD dwRet = DWERROR;
    HANDLE hToken = NULL;

    dwRet = DeviceCapabilities(pDevice, pPort, fwCapability, pOutput, pDevMode);

    if (dwRet == DWERROR && GetLastError () == ERROR_ACCESS_DENIED) {
        // In a cluster machine, we need to get the local admin previlige to get
        // the device capabilities.

        if (hToken = RevertToPrinterSelf()) {
            dwRet = DeviceCapabilities(pDevice, pPort, fwCapability, pOutput, pDevMode);
            ImpersonatePrinterClient(hToken);
        }
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\perflib\wmi.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All rights reserved

Module Name:

    wmi.h

Abstract:

    Holds defs for wmi instrumentation

Author:

    Stuart de Jong (sdejong) 15-Oct-99

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef __WMI_H
#define __WMI_H

ULONG WmiInitializeTrace();
ULONG WmiTerminateTrace();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\oleprn\util.h ===
/*****************************************************************************\
* MODULE:       util.h
*
* PURPOSE:      Header file for util.cpp
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*
*     09/12/97  weihaic    Created
*     11/06/97  keithst    Added SetScriptingError, removed Win2ComErr
*
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

LPWSTR  MakeWide(LPSTR psz);
LPSTR   MakeNarrow(LPWSTR str);
HRESULT PutString(SAFEARRAY *psa, long *ix, char *sz);
HRESULT SetScriptingError(const CLSID& rclsid, const IID& riid, DWORD dwError);

DWORD MyDeviceCapabilities(
    LPCTSTR pDevice,    // pointer to a printer-name string
    LPCTSTR pPort,      // pointer to a port-name string
    WORD fwCapability,  // device capability to query
    LPTSTR pOutput,     // pointer to the output
    CONST DEVMODE *pDevMode
                      // pointer to structure with device data
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\perflib\wmi.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation
All rights reserved

Module Name:

    wmi.c

Abstract:

    Holds the internal operations for wmi instrumenation

Author:

    Stuart de Jong (sdejong) 15-Oct-99

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
//
// WMI files
//
#include <wmistr.h>
#include <evntrace.h>
#include "wmi.h"
#include "wmidata.h"
// End WMI


//
// How it works:
//
// There are similar guids defined in the sdktools tracecounter programs, and also 
// descriptions there of the information we send them. This is used by them to print out
// and format the data we send.
//
// When we start up we register ourselves with WMI and provide a callback into our control
// code. This allows an external tool to call the start trace code in WMI with our guid, which
// then has WMI call us, and start tracing. 
//
// Stopping a trace is also done through the callback. the data is then analyzed by the WMI tools
// and output in human readable form, or it could be further analyzed from there.
//




MODULE_DEBUG_INIT ( DBG_ERROR, DBG_ERROR );

// These Guid's correspond to the definitions in \nt\sdktools\trace\tracedmp\mofdata.guid

//
// Identifies the PrintJob data logged by the delete job event.
//
GUID WmiPrintJobGuid = { /* 127eb555-3b06-46ea-a08b-5dc2c3c57cfd */
    0x127eb555, 0x3b06, 0x46ea, 0xa0, 0x8b, 0x5d, 0xc2, 0xc3, 0xc5, 0x7c, 0xfd
};

//
// Identifies the RenderedJob data logged by the job rendered event.
//
GUID WmiRenderedJobGuid = { /* 1d32b239-92a6-485a-96d2-dc3659fb803e */
    0x1d32b239, 0x92a6, 0x485a, 0x96, 0xd2, 0xdc, 0x36, 0x59, 0xfb, 0x80, 0x3e
};

//
// Used by the control app. to find the callback that turns spooler tracing on
// and off.
//
GUID WmiSpoolerControlGuid = { /* 94a984ef-f525-4bf1-be3c-ef374056a592 */
    0x94a984ef, 0xf525, 0x4bf1, 0xbe, 0x3c, 0xef, 0x37, 0x40, 0x56, 0xa5, 0x92 };

#define szWmiResourceName TEXT("Spooler")

TRACE_GUID_REGISTRATION WmiTraceGuidReg[] =
{
    { (LPGUID)&WmiPrintJobGuid,
      NULL
    },
    { (LPGUID)&WmiRenderedJobGuid,
      NULL
    }
};

//
//  The mof fields point to the following data.
//    DWORD                JobId;  // Unique ID for the transaction of printing a job
//    WMI_SPOOL_DATA       Data;   // See splcom.h
//
typedef struct _WMI_SPOOL_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             MofData[2];
} WMI_SPOOL_EVENT, *PWMI_SPOOL_EVENT;


static TRACEHANDLE WmiRegistrationHandle;
static TRACEHANDLE WmiLoggerHandle;
static LONG ulWmiEnableLevel = 0;
static HANDLE hWmiRegisterThread = NULL;
static DWORD dwWmiRegisterThreadId = 0;

static ULONG bWmiTraceOnFlag = FALSE;
static ULONG bWmiIsInitialized = FALSE;

ULONG
WmiControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

/*++
  Routine Name:
    WmiRegisterTrace()
 
  Routine Description:
    Thread routine that registers us with the WMI tools
 
  Arguments:
   LPVOID Arg        : Not used.
 
 
--*/

DWORD 
WmiRegisterTrace(
    IN LPVOID arg
    )
{
    ULONG Status = ERROR_SUCCESS;
    WCHAR szImagePath[MAX_PATH];

    Status = GetModuleFileName(NULL, szImagePath, COUNTOF(szImagePath));
    if (Status == 0) {
        Status = ERROR_FILE_NOT_FOUND;
    }
    else {
        Status = RegisterTraceGuids(
            WmiControlCallback,
            NULL,                 
            (LPGUID)&WmiSpoolerControlGuid,
            1,
            WmiTraceGuidReg,
            szImagePath,
            szWmiResourceName,
            &WmiRegistrationHandle);
        
        if (Status == ERROR_SUCCESS) {
            DBGMSG(DBG_TRACE, ("WmiInitializeTrace: SPOOLER WMI INITIALIZED.\n"));
            InterlockedExchange(&bWmiIsInitialized, TRUE);
        }
        else {
            DBGMSG(DBG_TRACE, ("WmiInitializeTrace: SPOOLER WMI INITIALIZE FAILED: %u.\n",
                     Status));
        }
    }
    return Status;
}


/*++
  Routine Name:  
    WmiInitializeTrace()
 
  Routine Description:
    Initialises the Trace structures and registers the callback with WMI.
    This creates a thread and calls WmiRegisterTrace, since the registering may take
    a long time (up to minutes)
 
  Arguments:
 
  Returns ERROR_SUCCESS if it succeeds or ERROR_ALREADY_EXISTS otherwise
 
--*/
ULONG 
WmiInitializeTrace(VOID)
{
    ULONG Status = ERROR_ALREADY_EXISTS;
    
    if (!hWmiRegisterThread) 
    {
        InterlockedExchange(&bWmiIsInitialized, FALSE);

        //
        // Registering can block for a long time (I've seen minutes
        // occationally), so it must be done in its own thread.
        //
        if (hWmiRegisterThread = CreateThread(NULL,
                                              0,
                                              (LPTHREAD_START_ROUTINE)WmiRegisterTrace,
                                              0,
                                              0,
                                              &dwWmiRegisterThreadId))
        {
            CloseHandle(hWmiRegisterThread);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = GetLastError();
        }
    }
    
    return Status;
}

/*++
  Routine Name:
    WmiTerminateTrace()
 
  Routine Description:
    Deregisters us from the WMI tools
 
  Arguments:
 
  Returns ERROR_SUCCESS on success. a Winerror otherwise.
 
--*/
ULONG 
WmiTerminateTrace(VOID)
{
    ULONG Status = ERROR_SUCCESS;
    DWORD dwExitCode;

    if (bWmiIsInitialized) {
        InterlockedExchange(&bWmiIsInitialized, FALSE);
        Status = UnregisterTraceGuids(WmiRegistrationHandle);
        if (Status == ERROR_SUCCESS) {
            DBGMSG(DBG_TRACE, ("WmiTerminateTrace: SPOOLER WMI UNREGISTERED.\n"));
        }
        else {
            DBGMSG(DBG_TRACE, ("WmiTerminateTrace: SPOOLER WMI UNREGISTER FAILED.\n"));
        }       
    }
    
    return Status;
}

/*++
  Routine Name:  
    SplWmiTraceEvent()
 
  Routine Description:
    If tracing is turned on, this sends the event to the WMI subsystem.
 
  Arguments:
    DWORD            JobId          : the JobID this is related to.
    UCHAR            EventTraceType : The type of event that happened
    PWMI_SPOOL_DATA  Data           : The Event Data, could be NULL
 
  Returns ERROR_SUCCESS if it doesn't need to do anything, or if it succeeds.
 
--*/
ULONG
LogWmiTraceEvent(
    IN DWORD JobId,
    IN UCHAR EventTraceType,
    IN PWMI_SPOOL_DATA Data   OPTIONAL
    )
{
    WMI_SPOOL_EVENT WmiSpoolEvent;
    ULONG Status;

    if (!bWmiTraceOnFlag)
        return ERROR_SUCCESS;

    //
    // Level 1 tracing just traces response time of individual jobs with job data.
    // Default level is 0.
    //
    if (ulWmiEnableLevel == 1) {
        switch (EventTraceType) {
            //
            // Save overhead by not tracking resource usage.
            //
        case EVENT_TRACE_TYPE_SPL_TRACKTHREAD:
        case EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD:
            return ERROR_SUCCESS;
        default:
            //
            // Job data.
            //
            break;
        }
    }

    //
    // Record data.
    //
    RtlZeroMemory(&WmiSpoolEvent, sizeof(WmiSpoolEvent));
    WmiSpoolEvent.Header.Size  = sizeof(WMI_SPOOL_EVENT);
    WmiSpoolEvent.Header.Flags = (WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR);
    WmiSpoolEvent.Header.Class.Type = EventTraceType;
    WmiSpoolEvent.Header.Guid  = WmiPrintJobGuid;

    WmiSpoolEvent.MofData[0].DataPtr = (ULONG64)&JobId;
    WmiSpoolEvent.MofData[0].Length = sizeof(DWORD);

    WmiSpoolEvent.MofData[1].DataPtr = (ULONG64)Data;
    if (Data) {
        switch (EventTraceType) {
        case EVENT_TRACE_TYPE_SPL_DELETEJOB:
            WmiSpoolEvent.MofData[1].Length = sizeof(struct _WMI_JOBDATA);
            break;
        case EVENT_TRACE_TYPE_SPL_JOBRENDERED:
            WmiSpoolEvent.Header.Guid  = WmiRenderedJobGuid;
            WmiSpoolEvent.MofData[1].Length = sizeof(struct _WMI_EMFDATA);
            break;
        default:
            DBGMSG(DBG_TRACE, ("SplWmiTraceEvent:  FAILED to log WMI Trace Event Unexpected Data JobId:%u Type:%u\n",
                     JobId, (ULONG) EventTraceType));
            return ERROR_INVALID_DATA;
        }
    }

    Status = TraceEvent(
        WmiLoggerHandle,
        (PEVENT_TRACE_HEADER) &WmiSpoolEvent);
    //
    // logger buffers out of memory should not prevent provider from
    // generating events. This will only cause events lost.
    //
    if (Status == ERROR_NOT_ENOUGH_MEMORY) {
        DBGMSG(DBG_TRACE, ("SplWmiTraceEvent: FAILED to log WMI Trace Event No Memory JobId:%u Type:%u\n",
                 JobId, (ULONG) EventTraceType));
    }
    else if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("SplWmiTraceEvent: FAILED to log WMI Trace Event JobId:%u Type:%u Status:%u\n",
                 JobId, (ULONG) EventTraceType, Status));
    }
    
    return Status;
}

/*++
  Routine Name:
    SplWmiControlCallback()
 
  Routine Description:
    This is the function we provite to the WMI subsystem as a callback, it is used to 
    start and stop the trace events.
 
  Arguments:
    IN     WMIDPREQUESTCODE  RequestCode      : The function to provide (enable/disable)
    IN     PVOID             Context          : Not used by us.
    IN OUT ULONG            *InOutBufferSize  : The Buffersize
    IN OUT PVOID             Buffer           : The buffer to use for the events
 
  Returns ERROR_SUCCESS on success, or an error code. 
 
--*/
ULONG
WmiControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;

    if (!bWmiIsInitialized) {
        DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI NOT INITIALIZED.\n"));
        return ERROR_GEN_FAILURE;
    }

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            WmiLoggerHandle = GetTraceLoggerHandle( Buffer );
            ulWmiEnableLevel = GetTraceEnableLevel( WmiLoggerHandle );
            InterlockedExchange(&bWmiTraceOnFlag, TRUE);

            DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI ENABLED LEVEL %u.\n",
                     ulWmiEnableLevel));
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            DBGMSG(DBG_TRACE, ("SplWmiControlCallback: SPOOLER WMI DISABLED.\n"));
            InterlockedExchange(&bWmiTraceOnFlag, FALSE);
            WmiLoggerHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = 0;
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\perflib\wmidata.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    wmidata.h

Abstract:

    Header file for the WMI trace event datatypes.

    Note -- link with spoolss.lib or perflib.lib to find these routines

Author:

    Bryan Kilian (BryanKil) May 2000

Revision History:


--*/

#ifndef __WMIDEF
#define __WMIDEF

//
// WMI Structures
//
// NOTE: Placing the spooler WMI types in a public header accessible to the
// sdktools depot would help a lot.  These structures are duplicated in the pdh
// source, so to change you need to change this header, the mofdata.guid file,
// and pdh\tracectr.

// JOB TRANSACTIONS
// The first four events correspond to the start and end event values found in
// evntrace.h.  Spooljob is the start and deletejob is the end.  Printjob is
// when the job is taken off the queue and printing has started.  Trackthread is
// used to track secondary threads spun off to help process a job, like RPC calls.
#define EVENT_TRACE_TYPE_SPL_SPOOLJOB    EVENT_TRACE_TYPE_START
#define EVENT_TRACE_TYPE_SPL_PRINTJOB    EVENT_TRACE_TYPE_DEQUEUE
#define EVENT_TRACE_TYPE_SPL_DELETEJOB   EVENT_TRACE_TYPE_END
#define EVENT_TRACE_TYPE_SPL_TRACKTHREAD EVENT_TRACE_TYPE_CHECKPOINT

// Non-reserved event types start at 0x0A.  These match values in reducer code
// so they cannot be changed.
#define EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD 0x0A
#define EVENT_TRACE_TYPE_SPL_JOBRENDERED 0x0B
#define EVENT_TRACE_TYPE_SPL_PAUSE 0x0C
#define EVENT_TRACE_TYPE_SPL_RESUME 0x0D

#define eDataTypeRAW  1
#define eDataTypeEMF  2
#define eDataTypeTEXT 3

// The fields in this struct correspond to the records in \nt\sdktools\trace\tracedmp\mofdata.guid
typedef union _WMI_SPOOL_DATA {
    // A zero indicates that the field was not filled in (i.e. WMI will ignore
    // the field).
    struct _WMI_JOBDATA {
        ULONG                  ulSize;      // Size of spooled job (post-rendered).
        ULONG                  eDataType;
        ULONG                  ulPages;
        ULONG                  ulPagesPerSide;
        // 0-3 indicates whether the spool writer, spool reader, and/or shadow
        // file were opened.  If not opened then the handles must of come from
        // the file pool cache.
        SHORT                  sFilesOpened;
    } uJobData;
    // See wingdi.h for definitions of the different possible values.
    struct _WMI_EMFDATA {
        ULONG                 ulSize;      // Size of spooled job (pre-rendered).
        ULONG                 ulICMMethod;
        SHORT                 sColor;
        SHORT                 sXRes;
        SHORT                 sYRes;
        SHORT                 sQuality;
        SHORT                 sCopies;
        SHORT                 sTTOption;
    } uEmfData;
} WMI_SPOOL_DATA, * PWMI_SPOOL_DATA;



ULONG
LogWmiTraceEvent(
    DWORD JobId,
    UCHAR EventTraceType,
    WMI_SPOOL_DATA *data        // Could be NULL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\formfeed.c ===
#include <windows.h>
/*++

Copyright (c) 1993-2003  Microsoft Corporation

Module Name:

    formfeed.c

Abstract:

    Table and routine to send formfeed to a printer.

Author:

    Dave Snipp (davesn)

Revision History:

    Tommy Evans (v-tommye) 10-15-1993 - commented code and fixed possible bug.

--*/
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

typedef struct _FormFeedChar {
    LPWSTR  pDeviceName;        /* Name of device */
    CHAR    NoChars;            /* Number of bytes in formfeed command */
    CHAR    Char1;              /* Formfeed command(n) */
    CHAR    Char2;
    CHAR    Char3;
} FORMFEEDCHAR;

/**
    This is our table of print devices and their
    associated formfeed commands.
**/

FORMFEEDCHAR
FormFeedChar[]={L"Canon Bubble-Jet BJ-10e", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-130e", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-300", 0, 0, 0, 0,
                L"Canon Bubble-Jet BJ-330", 0, 0, 0, 0,
                L"Citizen PN48", 0, 0, 0, 0,
                L"Citizen GSX-130", 0, 0, 0, 0,
                L"Citizen GSX-140", 0, 0, 0, 0,
                L"Citizen GSX-140+", 0, 0, 0, 0,
                L"Citizen GSX-145", 0, 0, 0, 0,
                L"Citizen 120D", 0, 0, 0, 0,
                L"Citizen 180D", 0, 0, 0, 0,
                L"Citizen 200GX", 0, 0, 0, 0,
                L"Citizen 200GX/15", 0, 0, 0, 0,
                L"Citizen HSP-500", 0, 0, 0, 0,
                L"Citizen HSP-550", 0, 0, 0, 0,
                L"C-Itoh 8510", 0, 0, 0, 0,
                L"AT&T 470/475", 0, 0, 0, 0,
                L"Epson LQ-500", 0, 0, 0, 0,
                L"Epson LQ-510", 0, 0, 0, 0,
                L"Epson LQ-800", 0, 0, 0, 0,
                L"Epson LQ-850", 0, 0, 0, 0,
                L"Epson LQ-950", 0, 0, 0, 0,
                L"Epson LQ-1000", 0, 0, 0, 0,
                L"Epson LQ-1050", 0, 0, 0, 0,
                L"Epson LQ-1500", 0, 0, 0, 0,
                L"Epson LQ-2500", 0, 0, 0, 0,
                L"Epson LQ-2550", 0, 0, 0, 0,
                L"Epson SQ-2000", 0, 0, 0, 0,
                L"Epson SQ-2500", 0, 0, 0, 0,
                L"Epson L-750", 0, 0, 0, 0,
                L"Epson L-1000", 0, 0, 0, 0,
                L"Epson MX-80", 0, 0, 0, 0,
                L"Epson MX-80 F/T", 0, 0, 0, 0,
                L"Epson MX-100", 0, 0, 0, 0,
                L"Epson RX-80", 0, 0, 0, 0,
                L"Epson RX-80 F/T", 0, 0, 0, 0,
                L"Epson RX-100", 0, 0, 0, 0,
                L"Epson RX-80 F/T+", 0, 0, 0, 0,
                L"Epson RX-100+", 0, 0, 0, 0,
                L"Epson FX-80", 0, 0, 0, 0,
                L"Epson FX-100", 0, 0, 0, 0,
                L"Epson FX-80+", 0, 0, 0, 0,
                L"Epson FX-100+", 0, 0, 0, 0,
                L"Epson FX-85", 0, 0, 0, 0,
                L"Epson FX-185", 0, 0, 0, 0,
                L"Epson FX-286", 0, 0, 0, 0,
                L"Epson FX-86e", 0, 0, 0, 0,
                L"Epson FX-286e", 0, 0, 0, 0,
                L"Epson DFX-5000", 0, 0, 0, 0,
                L"Epson T-750", 0, 0, 0, 0,
                L"Epson FX-850", 0, 0, 0, 0,
                L"Epson FX-1050", 0, 0, 0, 0,
                L"Epson JX-80", 0, 0, 0, 0,
                L"Epson EX-800", 0, 0, 0, 0,
                L"Epson EX-1000", 0, 0, 0, 0,
                L"Epson LX-80", 0, 0, 0, 0,
                L"Epson LX-86", 0, 0, 0, 0,
                L"Epson LX-800", 0, 0, 0, 0,
                L"Epson LX-810", 0, 0, 0, 0,
                L"Epson T-1000", 0, 0, 0, 0,
                L"Diconix 150 Plus", 0, 0, 0, 0,
                L"IBM ExecJet", 0, 0, 0, 0,
                L"Fujitsu DL 2400", 0, 0, 0, 0,
                L"Fujitsu DL 2600", 0, 0, 0, 0,
                L"Fujitsu DL 3300", 0, 0, 0, 0,
                L"Fujitsu DL 3400", 0, 0, 0, 0,
                L"Fujitsu DL 5600", 0, 0, 0, 0,
                L"Fujitsu DX 2100", 0, 0, 0, 0,
                L"Fujitsu DX 2200", 0, 0, 0, 0,
                L"Fujitsu DX 2300", 0, 0, 0, 0,
                L"Fujitsu DX 2400", 0, 0, 0, 0,
                L"HP DeskJet", 0, 0, 0, 0,
                L"HP DeskJet Plus", 0, 0, 0, 0,
                L"HP DeskJet 500", 0, 0, 0, 0,
                L"HP LaserJet Series II", 2, 0x1b, 'E', 0,
                L"HP LaserJet IID", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIP", 2, 0x1b, 'E', 0,
                L"HP LaserJet 2000", 2, 0x1b, 'E', 0,
                L"HP LaserJet III", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIID", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIIP", 2, 0x1b, 'E', 0,
                L"HP LaserJet IIISi", 2, 0x1b, 'E', 0,
                L"HP LaserJet", 2, 0x1b, 'E', 0,
                L"HP LaserJet Plus", 2, 0x1b, 'E', 0,
                L"HP LaserJet 500+", 2, 0x1b, 'E', 0,
                L"Agfa Compugraphic Genics", 2, 0x1b, 'E', 0,
                L"Apricot Laser", 2, 0x1b, 'E', 0,
                L"Epson EPL-6000", 2, 0x1b, 'E', 0,
                L"Epson EPL-7000", 2, 0x1b, 'E', 0,
                L"Epson GQ-3500", 2, 0x1b, 'E', 0,
                L"Kodak EktaPlus 7016", 2, 0x1b, 'E', 0,
                L"Kyocera F-Series (USA)", 2, 0x1b, 'E', 0,
                L"NEC Silentwriter LC 860", 2, 0x1b, 'E', 0,
                L"NEC Silentwriter LC 860 Plus", 2, 0x1b, 'E', 0,
                L"Okidata LaserLine 6", 2, 0x1b, 'E', 0,
                L"Okidata OL-400", 2, 0x1b, 'E', 0,
                L"Okidata OL-800", 2, 0x1b, 'E', 0,
                L"Olivetti PG 108", 2, 0x1b, 'E', 0,
                L"Olivetti PG 208 M2", 2, 0x1b, 'E', 0,
                L"Olivetti PG 308 HS", 2, 0x1b, 'E', 0,
                L"Olivetti ETV 5000", 2, 0x1b, 'E', 0,
                L"Panasonic KX-P4420", 2, 0x1b, 'E', 0,
                L"QuadLaser I", 2, 0x1b, 'E', 0,
                L"Tandy LP-1000", 2, 0x1b, 'E', 0,
                L"Tegra Genesis", 2, 0x1b, 'E', 0,
                L"Toshiba PageLaser12", 2, 0x1b, 'E', 0,
                L"Unisys AP9210", 2, 0x1b, 'E', 0,
                L"Wang LDP8", 2, 0x1b, 'E', 0,
                L"IBM QuickWriter 5204", 0, 0, 0, 0,
                L"NEC Pinwriter P2200", 0, 0, 0, 0,
                L"NEC Pinwriter CP6", 0, 0, 0, 0,
                L"NEC Pinwriter CP7", 0, 0, 0, 0,
                L"NEC Pinwriter P5200", 0, 0, 0, 0,
                L"NEC Pinwriter P5300", 0, 0, 0, 0,
                L"NEC Pinwriter P5XL", 0, 0, 0, 0,
                L"NEC Pinwriter P9XL", 0, 0, 0, 0,
                L"NEC Pinwriter P6", 0, 0, 0, 0,
                L"NEC Pinwriter P7", 0, 0, 0, 0,
                L"Okidata ML 380", 0, 0, 0, 0,
                L"Okidata ML 390", 0, 0, 0, 0,
                L"Okidata ML 390 Plus", 0, 0, 0, 0,
                L"Okidata ML 393 Plus", 0, 0, 0, 0,
                L"Okidata ML 391 Plus", 0, 0, 0, 0,
                L"Okidata ML 393", 0, 0, 0, 0,
                L"Okidata ML 393C Plus", 0, 0, 0, 0,
                L"Okidata ML 393C", 0, 0, 0, 0,
                L"Okidata ML 391", 0, 0, 0, 0,
                L"Okidata ML 192", 0, 0, 0, 0,
                L"Okidata ML 192 Plus", 0, 0, 0, 0,
                L"Okidata ML 193", 0, 0, 0, 0,
                L"Okidata ML 193 Plus", 0, 0, 0, 0,
                L"Okidata ML 320", 0, 0, 0, 0,
                L"Okidata ML 321", 0, 0, 0, 0,
                L"Okidata ML 321-IBM", 0, 0, 0, 0,
                L"Okidata ML 320-IBM", 0, 0, 0, 0,
                L"Okidata ML 193-IBM", 0, 0, 0, 0,
                L"Okidata ML 93-IBM", 0, 0, 0, 0,
                L"Okidata ML 192-IBM", 0, 0, 0, 0,
                L"Okidata ML 92-IBM", 0, 0, 0, 0,
                L"IBM Graphics", 0, 0, 0, 0,
                L"ATT 473/478", 0, 0, 0, 0,
                L"HP PaintJet", 0, 0, 0, 0,
                L"HP PaintJet XL", 0, 0, 0, 0,
                L"Panasonic KX-P1123", 0, 0, 0, 0,
                L"Panasonic KX-P1124", 0, 0, 0, 0,
                L"Panasonic KX-P1624", 0, 0, 0, 0,
                L"Panasonic KX-P1180", 0, 0, 0, 0,
                L"Panasonic KX-P1695", 0, 0, 0, 0,
                L"IBM Proprinter", 0, 0, 0, 0,
                L"IBM Proprinter II", 0, 0, 0, 0,
                L"IBM Proprinter XL", 0, 0, 0, 0,
                L"IBM Proprinter XL II", 0, 0, 0, 0,
                L"IBM Proprinter III", 0, 0, 0, 0,
                L"IBM Proprinter XL III", 0, 0, 0, 0,
                L"IBM Proprinter X24", 0, 0, 0, 0,
                L"IBM Proprinter XL24", 0, 0, 0, 0,
                L"IBM Proprinter X24e", 0, 0, 0, 0,
                L"IBM Proprinter XL24e", 0, 0, 0, 0,
                L"IBM PS/1", 0, 0, 0, 0,
                L"IBM QuietWriter III", 0, 0, 0, 0,
                L"HP ThinkJet (2225 C-D)", 0, 0, 0, 0,
                L"TI 850/855", 0, 0, 0, 0,
                L"Toshiba P351", 0, 0, 0, 0,
                L"Toshiba P1351", 0, 0, 0, 0,
                L"IBM LaserPrinter 4029 PS17", 1, 0x4, 0, 0,
                L"IBM LaserPrinter 4029 PS39", 1, 0x4, 0, 0,
                L"Apple LaserWriter v23.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter Plus v38.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter Plus v42.2", 1, 0x4, 0, 0,
                L"APS-PS PIP with APS-6/108", 1, 0x4, 0, 0,
                L"APS-PS PIP with LZR 1200", 1, 0x4, 0, 0,
                L"APS-PS PIP with LZR 2600", 1, 0x4, 0, 0,
                L"APS-PS PIP with APS-6/80", 1, 0x4, 0, 0,
                L"AST TurboLaser/PS v47.0", 1, 0x4, 0, 0,
                L"Agfa-Compugraphic 9400P v49.3", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark IIIR", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark IIIT", 1, 0x4, 0, 0,
                L"Canon LBP-8 Mark III", 1, 0x4, 0, 0,
                L"Dataproducts LZR-2665 v47.0", 1, 0x4, 0, 0,
                L"Digital DEClaser 1150", 1, 0x4, 0, 0,
                L"Digital DEClaser 2150", 1, 0x4, 0, 0,
                L"Digital DEClaser 2250", 1, 0x4, 0, 0,
                L"Digital DEClaser 3250", 1, 0x4, 0, 0,
                L"Digital Colormate PS", 1, 0x4, 0, 0,
                L"Digital PrintServer 20/turbo", 1, 0x4, 0, 0,
                L"Dataproducts LZR 1260 v47.0", 1, 0x4, 0, 0,
                L"EPSON EPL-7500 v52.3", 1, 0x4, 0, 0,
                L"Fujitsu RX7100PS", 1, 0x4, 0, 0,
                L"Hermes H 606 PS (13 Fonts)", 1, 0x4, 0, 0,
                L"Hermes H 606 PS (35 fonts)", 1, 0x4, 0, 0,
                L"HP LaserJet ELI PostScript v52.3", 1, 0x4, 0, 0,
                L"HP LaserJet IIISi PostScript", 1, 0x4, 0, 0,
                L"HP LaserJet IID PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet III PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIP PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIID PostScript v52.2", 1, 0x4, 0, 0,
                L"HP LaserJet IIIP PostScript v52.2", 1, 0x4, 0, 0,
                L"IBM 4019 v52.1 (17 Fonts)", 1, 0x4, 0, 0,
                L"IBM 4216-020 v47.0", 1, 0x4, 0, 0,
                L"IBM 4216-030 v50.5", 1, 0x4, 0, 0,
                L"IBM 4019 v52.1 (39 Fonts)", 1, 0x4, 0, 0,
                L"Linotronic 100 v42.5", 1, 0x4, 0, 0,
                L"Linotronic 200/230", 1, 0x4, 0, 0,
                L"Linotronic 200 v47.1", 1, 0x4, 0, 0,
                L"Linotronic 200 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 300 v47.1", 1, 0x4, 0, 0,
                L"Linotronic 300 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 330", 1, 0x4, 0, 0,
                L"Linotronic 500 v49.3", 1, 0x4, 0, 0,
                L"Linotronic 530", 1, 0x4, 0, 0,
                L"Linotronic 630", 1, 0x4, 0, 0,
                L"Apple LaserWriter II NTX v47.0", 1, 0x4, 0, 0,
                L"Apple LaserWriter II NT v47.0", 1, 0x4, 0, 0,
                L"Monotype Imagesetter v52.2", 1, 0x4, 0, 0,
                L"Microtek TrueLaser", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 90 v52.2", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 290 v52.0", 1, 0x4, 0, 0,
                L"NEC Silentwriter2 990 v52.3", 1, 0x4, 0, 0,
                L"NEC Silentwriter LC890XL v50.5", 1, 0x4, 0, 0,
                L"NEC Silentwriter LC890 v47.0", 1, 0x4, 0, 0,
                L"NEC Colormate PS/40 v51.9", 1, 0x4, 0, 0,
                L"NEC Colormate PS/80 v51.9", 1, 0x4, 0, 0,
                L"OceColor G5241 PS", 1, 0x4, 0, 0,
                L"OceColor G5242 PS", 1, 0x4, 0, 0,
                L"Oki OL840/PS V51.8", 1, 0x4, 0, 0,
                L"Olivetti PG 306 PS (13 Fonts)", 1, 0x4, 0, 0,
                L"Olivetti PG 306 PS (35 Fonts)", 1, 0x4, 0, 0,
                L"Panasonic KX-P4455 v51.4", 1, 0x4, 0, 0,
                L"Tektronix Phaser III PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PX", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser PX", 1, 0x4, 0, 0,
                L"QMS-PS 2200 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 2210 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 2220 v51.0", 1, 0x4, 0, 0,
                L"QMS-PS 810 Turbo v. 51.7", 1, 0x4, 0, 0,
                L"QMS-PS 820 Turbo v51.7", 1, 0x4, 0, 0,
                L"QMS-PS 820 v51.7", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 Model 10", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 Model 20/30", 1, 0x4, 0, 0,
                L"QMS-PS 810 v47.0", 1, 0x4, 0, 0,
                L"QMS-PS 800 Plus v46.1", 1, 0x4, 0, 0,
                L"QMS-PS 800 v46.1", 1, 0x4, 0, 0,
                L"QMS ColorScript 100 v49.3", 1, 0x4, 0, 0,
                L"QMS PS Jet Plus v46.1", 1, 0x4, 0, 0,
                L"QMS PS Jet v46.1", 1, 0x4, 0, 0,
                L"Qume ScripTEN v47.0", 1, 0x4, 0, 0,
                L"Ricoh PC Laser 6000/PS v50.5", 1, 0x4, 0, 0,
                L"Schlumberger 5232 Color PostScript Printer v50.3", 1, 0x4, 0, 0,
                L"Scantext 2030/51", 1, 0x4, 0, 0,
                L"Seiko ColorPoint PS Model 04", 1, 0x4, 0, 0,
                L"Seiko ColorPoint PS Model 14", 1, 0x4, 0, 0,
                L"TI OmniLaser 2108 v45.0", 1, 0x4, 0, 0,
                L"TI Omnilaser 2115 v47.0", 1, 0x4, 0, 0,
                L"TI microLaser PS17 v.52.1", 1, 0x4, 0, 0,
                L"TI microLaser PS35 v.52.1", 1, 0x4, 0, 0,
                L"Tektronix Phaser II PXi", 1, 0x4, 0, 0,
                L"Tektronix Phaser III PXi", 1, 0x4, 0, 0,
                L"Triumph Adler SDR 7706 PS13", 1, 0x4, 0, 0,
                L"Triumph Adler SDR 7706 PS35", 1, 0x4, 0, 0,
                L"Unisys AP9415 v47.0", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5330", 1, 0x4, 0, 0,
                L"Varityper 4200B-P", 1, 0x4, 0, 0,
                L"Varityper 4300P", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5300", 1, 0x4, 0, 0,
                L"Varityper Series 4000/5500 v52.2", 1, 0x4, 0, 0,
                L"Varityper VT-600P v48.0", 1, 0x4, 0, 0,
                L"Varityper VT-600W v48.0", 1, 0x4, 0, 0,
                NULL, 0, 0, 0, 0
                };


/*++
*******************************************************************
    D o F o r m F e e d

    Routine Description:
        Sends a formfeed to the printer matching the given
        printer device name.

    Arguments:
        hPrinter    Handle to the printer to send formfeed to.
        pDeviceName Name of print device.

    Return Value:
        TRUE  if successful
        FALSE if failed
*******************************************************************
--*/
BOOL
DoFormFeed(
    IN HANDLE  hPrinter,
    IN LPWSTR  pDeviceName
)
{
    FORMFEEDCHAR *pFormFeed=FormFeedChar;
    DWORD   cbWritten;

    /** If we got a bad pointer, fail the call **/

    if (!pDeviceName) {
        return FALSE;
    }

    /** For our list of devices... **/

    while (pFormFeed->pDeviceName) {

        /** Did we find it? **/

        if (!wcscmp(pDeviceName, pFormFeed->pDeviceName)) {

            /** Yes - send formfeed to printer **/

            if (pFormFeed->NoChars)
                return WritePrinter(hPrinter, &pFormFeed->Char1,
                                    pFormFeed->NoChars, &cbWritten);
            else
                return TRUE;
        }

        /** Next device **/

        pFormFeed++;
    }

    /** Didn't find a matching device - return failed **/

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\emf.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\emf.c
// @@END_DDKSPLIT

Abstract:

    Routines to facilitate printing of EMF jobs.
    
// @@BEGIN_DDKSPLIT
Author:

    Gerrit van Wingerden (gerritv) 5-12-1995

Revision History:

    Ramanathan N. Venkatapathy (ramanv) 5-15-1997
    Alvin Scholten (alvins) 3-31-00
// @@END_DDKSPLIT
--*/

#include "local.h"
#include "stddef.h"
#include <windef.h>

// @@BEGIN_DDKSPLIT
#include "wingdip.h"
/*
// @@END_DDKSPLIT
#include <winppi.h>
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT


#define EMF_DUP_NONE 0
#define EMF_DUP_VERT 1
#define EMF_DUP_HORZ 2

#define EMF_DEGREE_90   0x0001
#define EMF_DEGREE_270  0x0002
#define EMF_DEGREE_SWAP 0x8000

//
// IS_DMSIZE_VALID returns TRUE if the size of the devmode is atleast as much as to 
// be able to access field x in it without AV. It is assumed that the devmode is 
// atleast the size pdm->dmSize 
//
#define IS_DMSIZE_VALID(pdm,x)  ( ( (pdm)->dmSize >= (FIELD_OFFSET(DEVMODEW, x ) + sizeof((pdm)->x )))? TRUE:FALSE)

//   PAGE_NUMBER is used to save a list of the page numbers to start new sides while
//   Reverse Printing.

typedef struct _PAGE_NUMBER {
    struct _PAGE_NUMBER *pNext;
    DWORD  dwPageNumber;
} PAGE_NUMBER, *PPAGE_NUMBER;

typedef struct _UpdateRect {
        double  top;
        double  bottom;
        double  left;
        double  right;
}  UpdateRect;

// The update factors for the different nup options. These factors when multiplied
// with the horizontal and vertical resolutions give the coordinates for the rectangle
// where the EMF page is to be played.

UpdateRect URect21[] = {{0, 0.5, 0, 1},
                        {0.5, 1, 0, 1}};

UpdateRect URect21R[] = {{0.5, 1, 0, 1},
                         {0, 0.5, 0, 1}};

UpdateRect URect22[] = {{0, 1, 0, 0.5},
                        {0, 1, 0.5, 1}};

UpdateRect URect4[] = {{0, 0.5, 0, 0.5},
                       {0, 0.5, 0.5, 1},
                       {0.5, 1, 0, 0.5},
                       {0.5, 1, 0.5, 1}};

UpdateRect URect61[] = {{0, 1.0/3.0, 0, 0.5},
                        {0, 1.0/3.0, 0.5, 1},
                        {1.0/3.0, 2.0/3.0, 0, 0.5},
                        {1.0/3.0, 2.0/3.0, 0.5, 1},
                        {2.0/3.0, 1, 0, 0.5},
                        {2.0/3.0, 1, 0.5, 1}};

UpdateRect URect61R[] = {{2.0/3.0, 1, 0, 0.5},
                         {1.0/3.0, 2.0/3.0, 0, 0.5},
                         {0, 1.0/3.0, 0, 0.5},
                         {2.0/3.0, 1, 0.5, 1},
                         {1.0/3.0, 2.0/3.0, 0.5, 1},
                         {0, 1.0/3.0, 0.5, 1}};

UpdateRect URect62[]  = {{0, 0.5, 0, 1.0/3.0},
                         {0, 0.5, 1.0/3.0, 2.0/3.0},
                         {0, 0.5, 2.0/3.0, 1},
                         {0.5, 1, 0, 1.0/3.0},
                         {0.5, 1, 1.0/3.0, 2.0/3.0},
                         {0.5, 1, 2.0/3.0, 1}};

UpdateRect URect62R[] = {{0.5, 1, 0, 1.0/3.0},
                         {0, 0.5, 0, 1.0/3.0},
                         {0.5, 1, 1.0/3.0, 2.0/3.0},
                         {0, 0.5, 1.0/3.0, 2.0/3.0},
                         {0.5, 1, 2.0/3.0, 1},
                         {0, 0.5, 2.0/3.0, 1}};

UpdateRect URect9[] = {{0, 1.0/3.0, 0, 1.0/3.0},
                       {0, 1.0/3.0, 1.0/3.0, 2.0/3.0},
                       {0, 1.0/3.0, 2.0/3.0, 1},
                       {1.0/3.0, 2.0/3.0, 0, 1.0/3.0},
                       {1.0/3.0, 2.0/3.0, 1.0/3.0, 2.0/3.0},
                       {1.0/3.0, 2.0/3.0, 2.0/3.0, 1},
                       {2.0/3.0, 1, 0, 1.0/3.0},
                       {2.0/3.0, 1, 1.0/3.0, 2.0/3.0},
                       {2.0/3.0, 1, 2.0/3.0, 1}};

UpdateRect URect16[] = {{0, 0.25, 0, 0.25},
                        {0, 0.25, 0.25, 0.5},
                        {0, 0.25, 0.5, 0.75},
                        {0, 0.25, 0.75, 1},
                        {0.25, 0.5, 0, 0.25},
                        {0.25, 0.5, 0.25, 0.5},
                        {0.25, 0.5, 0.5, 0.75},
                        {0.25, 0.5, 0.75, 1},
                        {0.5, 0.75, 0, 0.25},
                        {0.5, 0.75, 0.25, 0.5},
                        {0.5, 0.75, 0.5, 0.75},
                        {0.5, 0.75, 0.75, 1},
                        {0.75, 1, 0, 0.25},
                        {0.75, 1, 0.25, 0.5},
                        {0.75, 1, 0.5, 0.75},
                        {0.75, 1, 0.75, 1}};

//
// Local function declaration
//
BOOL GdiGetDevmodeForPagePvt(
    IN  HANDLE              hSpoolHandle,
    IN  DWORD               dwPageNumber,
    OUT PDEVMODEW           *ppCurrDM,
    OUT PDEVMODEW           *ppLastDM
  );

BOOL BIsDevmodeOfLeastAcceptableSize(
    IN PDEVMODE pdm) ;


BOOL
ValidNumberForNUp(
    DWORD  dwPages)

/*++
Function Description: Checks if the number of pages printed on a single side is Valid.

Parameters: dwPages - Number of pages printed on a single side

Return Values: TRUE if (dwPages = 1|2|4|6|9|16)
               FALSE otherwise.
--*/

{

    return ((dwPages == 1) || (dwPages == 2) || (dwPages == 4) ||
            (dwPages == 6) || (dwPages == 9) || (dwPages == 16));
}

BOOL
GetPageCoordinatesForNUp(
    HDC    hPrinterDC,
    RECT   *rectDocument,
    RECT   *rectBorder,
    DWORD  dwTotalNumberOfPages,
    UINT   uCurrentPageNumber,
    DWORD  dwNupBorderFlags,
    LPBOOL pbRotate
    )

/*++
Function Description: GetPageCoordinatesForNUp computes the rectangle on the Page where the
                      EMF file is to be played. It also determines if the picture is to
                      rotated.

Parameters:  hPrinterDC           - Printer Device Context
             *rectDocument        - pointer to RECT where the coordinates to play the
                                     page will be returned.
             *rectBorder          - pointer to RECT where the page borders are to drawn.
             dwTotalNumberOfPages - Total number of pages on 1 side.
             uCurrentPageNumber   - 1 based page number on the side.
             dwNupBorderFlags     - flags to draw border along logical pages.
             pbRotate             - pointer to BOOL which indicates if the picture must be
                                    rotated.

Return Values:  NONE.
--*/

{

    UpdateRect  *URect;
    LONG        lXPrintPage,lYPrintPage,lXPhyPage,lYPhyPage,lXFrame,lYFrame,ltemp,ldX,ldY;
    LONG        lXNewPhyPage,lYNewPhyPage,lXOffset,lYOffset,lNumRowCol,lRowIndex,lColIndex;
    double      dXleft,dXright,dYtop,dYbottom;
    LONG        xResolution = GetDeviceCaps(hPrinterDC, LOGPIXELSX);
    LONG        yResolution = GetDeviceCaps(hPrinterDC, LOGPIXELSY);
    
    // Get the 0-based array index for the current page

    uCurrentPageNumber = uCurrentPageNumber - 1;

    if (dwTotalNumberOfPages==1 || xResolution==yResolution) 
    {
        xResolution = yResolution = 1;
    }

    rectDocument->top = rectDocument->bottom = lYPrintPage = (GetDeviceCaps(hPrinterDC, DESKTOPVERTRES)-1) * xResolution;
    rectDocument->left = rectDocument->right = lXPrintPage = (GetDeviceCaps(hPrinterDC, DESKTOPHORZRES)-1) * yResolution;

    lXPhyPage = GetDeviceCaps(hPrinterDC, PHYSICALWIDTH)  * yResolution;
    lYPhyPage = GetDeviceCaps(hPrinterDC, PHYSICALHEIGHT) * xResolution;

    //
    // Down in the code, we are dividing by these values, which can lead
    // to divide-by-zero errors.
    //
    if ( 0 == xResolution ||
         0 == yResolution ||
         0 == lXPhyPage   ||
         0 == lYPhyPage )
    {
        return FALSE;
    }

    *pbRotate = FALSE;

    // Select the array containing the update factors

    switch (dwTotalNumberOfPages) {

    case 1: rectDocument->top = rectDocument->left = 0;
            rectDocument->right += 1;
            rectDocument->bottom += 1;
            return TRUE;

    case 2: if (lXPrintPage > lYPrintPage) {  // cut vertically
                URect = URect22;
                lXFrame = (LONG) (lXPrintPage / 2.0);
                lYFrame = lYPrintPage;
            } else {                          // cut horizontally
                URect = URect21;
                lYFrame = (LONG) (lYPrintPage / 2.0);
                lXFrame = lXPrintPage;
            }
            break;


    case 4: URect = URect4;
            lXFrame = (LONG) (lXPrintPage / 2.0);
            lYFrame = (LONG) (lYPrintPage / 2.0);
            break;

    case 6: if (lXPrintPage > lYPrintPage) {  // cut vertically twice
                URect = URect62;
                lXFrame = (LONG) (lXPrintPage / 3.0);
                lYFrame = (LONG) (lYPrintPage / 2.0);
            } else {                          // cut horizontally twice
                URect = URect61;
                lYFrame = (LONG) (lYPrintPage / 3.0);
                lXFrame = (LONG) (lXPrintPage / 2.0);
            }
            break;

    case 9: URect = URect9;
            lXFrame = (LONG) (lXPrintPage / 3.0);
            lYFrame = (LONG) (lYPrintPage / 3.0);
            break;

    case 16: URect = URect16;
             lXFrame = (LONG) (lXPrintPage / 4.0);
             lYFrame = (LONG) (lYPrintPage / 4.0);
             break;

    default: // Should Not Occur.
             return FALSE;
    }

    // Set the flag if the picture has to be rotated
    *pbRotate = !((lXPhyPage >= lYPhyPage) && (lXFrame >= lYFrame)) &&
                !((lXPhyPage < lYPhyPage) && (lXFrame < lYFrame));
    

    // If the picture is to be rotated, modify the rectangle selected.

    if ((dwTotalNumberOfPages == 2) || (dwTotalNumberOfPages == 6)) {

       if (*pbRotate) {
          switch (dwTotalNumberOfPages) {

          case 2: if (lXPrintPage <= lYPrintPage) {
                      URect = URect21R;
                  } // URect22 = URect22R
                  break;

          case 6: if (lXPrintPage <= lYPrintPage) {
                      URect = URect61R;
                  } else {
                      URect = URect62R;
                  }
                  break;
          }
       }

    } else {

       if (*pbRotate) {

          // get the number of rows/columns. switch is faster than sqrt.
          switch (dwTotalNumberOfPages) {

          case 4: lNumRowCol = 2;
                  break;
          case 9: lNumRowCol = 3;
                  break;
          case 16: lNumRowCol = 4;
                  break;
          }

          lRowIndex  = (LONG) (uCurrentPageNumber / lNumRowCol);
          lColIndex  = (LONG) (uCurrentPageNumber % lNumRowCol);

          uCurrentPageNumber = (lNumRowCol - 1 - lColIndex) * lNumRowCol + lRowIndex;
       }

    }

    // Update the Page Coordinates.

    rectDocument->top    = (LONG) (rectDocument->top    * URect[uCurrentPageNumber].top);
    rectDocument->bottom = (LONG) (rectDocument->bottom * URect[uCurrentPageNumber].bottom);
    rectDocument->left   = (LONG) (rectDocument->left   * URect[uCurrentPageNumber].left);
    rectDocument->right  = (LONG) (rectDocument->right  * URect[uCurrentPageNumber].right);

    // If the page border has to drawn, return the corresponding coordinates in rectBorder.

    if (dwNupBorderFlags == BORDER_PRINT) {
        rectBorder->top    = rectDocument->top/xResolution;
        rectBorder->bottom = rectDocument->bottom/xResolution - 1;
        rectBorder->left   = rectDocument->left/yResolution;
        rectBorder->right  = rectDocument->right/yResolution - 1;
    }

    if (*pbRotate) {
        ltemp = lXFrame; lXFrame = lYFrame; lYFrame = ltemp;
    }

    // Get the new size of the rectangle to keep the X/Y ratio constant.
    if ( ((LONG) (lYFrame*((lXPhyPage*1.0)/lYPhyPage))) >= lXFrame) {
         ldX = 0;
         ldY = lYFrame - ((LONG) (lXFrame*((lYPhyPage*1.0)/lXPhyPage)));
    } else {
         ldY = 0;
         ldX = lXFrame - ((LONG) (lYFrame*((lXPhyPage*1.0)/lYPhyPage)));
    }

    // Adjust the position of the rectangle.

    if (*pbRotate) {
        if (ldX) {
            rectDocument->bottom -= (LONG) (ldX / 2.0);
            rectDocument->top    += (LONG) (ldX / 2.0);
        } else {
           rectDocument->right   -= (LONG) (ldY / 2.0);
           rectDocument->left    += (LONG) (ldY / 2.0);
        }
    } else {
        if (ldX) {
           rectDocument->left    += (LONG) (ldX / 2.0);
           rectDocument->right   -= (LONG) (ldX / 2.0);
        } else {
           rectDocument->top     += (LONG) (ldY / 2.0);
           rectDocument->bottom  -= (LONG) (ldY / 2.0);
        }
    }

    // Adjust to get the Printable Area on the rectangle

    lXOffset = GetDeviceCaps(hPrinterDC, PHYSICALOFFSETX) * yResolution;
    lYOffset = GetDeviceCaps(hPrinterDC, PHYSICALOFFSETY) * xResolution;

    dXleft = ( lXOffset * 1.0) / lXPhyPage;
    dYtop  = ( lYOffset * 1.0) / lYPhyPage;
    dXright =  ((lXPhyPage - (lXOffset + lXPrintPage)) * 1.0) / lXPhyPage;
    dYbottom = ((lYPhyPage - (lYOffset + lYPrintPage)) * 1.0) / lYPhyPage;

    lXNewPhyPage = rectDocument->right  - rectDocument->left;
    lYNewPhyPage = rectDocument->bottom - rectDocument->top;

    if (*pbRotate) {

       ltemp = lXNewPhyPage; lXNewPhyPage = lYNewPhyPage; lYNewPhyPage = ltemp;

       rectDocument->left   += (LONG) (dYtop    * lYNewPhyPage);
       rectDocument->right  -= (LONG) (dYbottom * lYNewPhyPage);
       rectDocument->top    += (LONG) (dXright  * lXNewPhyPage);
       rectDocument->bottom -= (LONG) (dXleft   * lXNewPhyPage);

    } else {

       rectDocument->left   += (LONG) (dXleft   * lXNewPhyPage);
       rectDocument->right  -= (LONG) (dXright  * lXNewPhyPage);
       rectDocument->top    += (LONG) (dYtop    * lYNewPhyPage);
       rectDocument->bottom -= (LONG) (dYbottom * lYNewPhyPage);
    }

    if (xResolution!=yResolution) 
    {
        rectDocument->left   = rectDocument->left   / yResolution;
        rectDocument->right  = rectDocument->right  / yResolution; 
        rectDocument->top    = rectDocument->top    / xResolution;
        rectDocument->bottom = rectDocument->bottom / xResolution; 
    }

    return TRUE;
}

BOOL
PlayEMFPage(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    HANDLE       hEMF,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwPageNumber,
    DWORD        dwPageIndex,
    DWORD        dwNupBorderFlags,
    DWORD        dwAngle)
    
/*++
Function Description: PlayEMFPage plays the EMF in the appropriate rectangle. It performs
                      the required scaling, rotation and translation.

Parameters:   hSpoolHandle           -- handle the spool file handle
              hPrinterDC             -- handle to the printer device context
              hEMF                   -- handle to the contents of the page in the spool file
              dwNumberOfPagesPerSide -- number of pages to be printed per side
              dwPageNumber           -- page number in the document
              dwPageIndex            -- page number in the side. (1 based)
              dwNupBorderFlags       -- border printing options for nup
              dwAngle                -- angle for rotation (if neccesary)

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
   BOOL         bReturn = FALSE, bRotate;
   RECT         rectDocument, rectPrinter, rectBorder = {-1, -1, -1, -1};
   RECT         *prectClip = NULL;
   XFORM        TransXForm = {1, 0, 0, 1, 0, 0}, RotateXForm = {0, -1, 1, 0, 0, 0};
   HPEN         hPen;
   HANDLE       hFormEMF;
   DWORD        dwPageType,dwFormPage;

   // Compute the rectangle for one page.
   if ( FALSE == GetPageCoordinatesForNUp(hPrinterDC,
                            &rectDocument,
                            &rectBorder,
                            dwNumberOfPagesPerSide,
                            dwPageIndex,
                            dwNupBorderFlags,
                            &bRotate) )
    {
        goto CleanUp;
    }

   // If swap flag is set, reverse rotate flag
   //
   if (dwAngle & EMF_DEGREE_SWAP)
       bRotate = !bRotate;

   if (dwAngle & EMF_DEGREE_270) {
       RotateXForm.eM12 = 1;
       RotateXForm.eM21 = -1;
   }   // EMF_DEGREE_90 case is the initialization

   if (bRotate) {

       rectPrinter.top = 0;
       rectPrinter.bottom = rectDocument.right - rectDocument.left;
       rectPrinter.left = 0;
       rectPrinter.right = rectDocument.bottom - rectDocument.top;

       // Set the translation matrix
       if (dwAngle & EMF_DEGREE_270) {
           TransXForm.eDx = (float) rectDocument.right;
           TransXForm.eDy = (float) rectDocument.top;
       } else {
           // EMF_DEGREE_90
           TransXForm.eDx = (float) rectDocument.left;
           TransXForm.eDy = (float) rectDocument.bottom;
       }

       // Set the transformation matrix
       if (!SetWorldTransform(hPrinterDC, &RotateXForm) ||
           !ModifyWorldTransform(hPrinterDC, &TransXForm, MWT_RIGHTMULTIPLY)) {

            ODS(("Setting transformation matrix failed\n"));
            goto CleanUp;
       }
   }

   // Add clipping for Nup
   if (dwNumberOfPagesPerSide != 1) {

       prectClip = &rectDocument;
   }

   // Print the page.
   if (bRotate) {
       GdiPlayPageEMF(hSpoolHandle, hEMF, &rectPrinter, &rectBorder, prectClip);

   } else {
       GdiPlayPageEMF(hSpoolHandle, hEMF, &rectDocument, &rectBorder, prectClip);
   }

   bReturn = TRUE;

CleanUp:
   
   if (!ModifyWorldTransform(hPrinterDC, NULL, MWT_IDENTITY)) {

       ODS(("Setting Identity Transformation failed\n"));
       bReturn = FALSE;
   }

   return bReturn;
}

BOOL
SetDrvCopies(
    HDC          hPrinterDC,
    LPDEVMODEW   pDevmode,
    DWORD        dwNumberOfCopies)

/*++
Function Description: SetDrvCopies sets the dmCopies field in pDevmode and resets
                      hPrinterDC with this devmode

Parameters: hPrinterDC             -- handle to the printer device context
            pDevmode               -- pointer to devmode
            dwNumberOfCopies       -- value for dmCopies

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL     bReturn;
    DWORD    dmFields;

    if ((pDevmode->dmFields & DM_COPIES) &&
        (pDevmode->dmCopies == (short) dwNumberOfCopies)) {

         return TRUE;
    }

    // Save the old fields structure
    dmFields = pDevmode->dmFields;
    pDevmode->dmFields |= DM_COPIES;
    pDevmode->dmCopies = (short) dwNumberOfCopies;

    if (!ResetDC(hPrinterDC, pDevmode))  {
        bReturn = FALSE;
    } else {
        bReturn = TRUE;
    }
    // Restore the fields structure
    pDevmode->dmFields = dmFields;

    if (!SetGraphicsMode(hPrinterDC,GM_ADVANCED)) {
        ODS(("Setting graphics mode failed\n"));
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
DifferentDevmodes(
    LPDEVMODE    pDevmode1,
    LPDEVMODE    pDevmode2
    )

/*++
Function Description: Compares the devmodes for differences other than dmTTOption

Parameters:  pDevmode1    -   devmode 1
             pDevmode2    -   devmode 2
             
Return Values: TRUE if different ; FALSE otherwise           
--*/

{
    DWORD   dwSize1, dwSize2, dwTTOffset, dwSpecOffset, dwLogOffset;

    // Same pointers are the same devmode
    if (pDevmode1 == pDevmode2) {
        return FALSE;
    }

    // Check for Null devmodes
    if (!pDevmode1 || !pDevmode2) {
        return TRUE;
    }

    dwSize1 = pDevmode1->dmSize + pDevmode1->dmDriverExtra;
    dwSize2 = pDevmode2->dmSize + pDevmode2->dmDriverExtra;

    // Compare devmode sizes
    if (dwSize1 != dwSize2) {
        return TRUE;
    }

    dwTTOffset = FIELD_OFFSET(DEVMODE, dmTTOption);
    dwSpecOffset = FIELD_OFFSET(DEVMODE, dmSpecVersion);
    dwLogOffset = FIELD_OFFSET(DEVMODE, dmLogPixels);

    if (wcscmp(pDevmode1->dmDeviceName,
               pDevmode2->dmDeviceName)) {
        // device names are different
        return TRUE;
    }

    if (dwTTOffset < dwSpecOffset ||
        dwSize1 < dwLogOffset) {

        // incorrent devmode offsets
        return TRUE;
    }

    if (memcmp((LPBYTE) pDevmode1 + dwSpecOffset,
               (LPBYTE) pDevmode2 + dwSpecOffset,
               dwTTOffset - dwSpecOffset)) {
        // Front half is different
        return TRUE;
    }

    // Ignore the dmTTOption setting.

    if ((pDevmode1->dmCollate != pDevmode2->dmCollate) ||
        wcscmp(pDevmode1->dmFormName, pDevmode2->dmFormName)) {
        
        // form name or collate option is different
        return TRUE;
    }

    if (memcmp((LPBYTE) pDevmode1 + dwLogOffset,
               (LPBYTE) pDevmode2 + dwLogOffset,
               dwSize1 - dwLogOffset)) {
        // Back half is different
        return TRUE;
    }

    return FALSE;
}


BOOL
ResetDCForNewDevmode(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwPageNumber,
    BOOL         bInsidePage,    
    DWORD        dwOptimization,
    LPBOOL       pbNewDevmode,
    LPDEVMODE    pDevmode,
    LPDEVMODE    *pCurrentDevmode
    )

/*++
Function Description: Determines if the devmode for the page is different from the 
                      current devmode for the printer dc and resets the dc if necessary.
                      The parameters allow dmTTOption to be ignored in devmode comparison.

Parameters: hSpoolHandle         -  spool file handle
            hPrinterDC           -  printer dc
            dwPageNumber         -  page number before which we search for the devmode
            bInsidePage          -  flag to ignore changes in TT options and call EndPage
                                       before ResetDC
            dwOptimization       -  optimization flags
            pbNewDevmode         -  pointer to flag to indicate if ResetDC was called
            pDevmode             -  devmode containing changed resolution settings

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL           bReturn = FALSE;
    LPDEVMODE      pLastDM, pCurrDM;

    // Initialize OUT parameters
    *pbNewDevmode = FALSE;

    // Get the devmode just before the page
    if (!GdiGetDevmodeForPagePvt(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              &pLastDM)) {

        ODS(("GdiGetDevmodeForPagePvt failed\n"));
        return bReturn;
    }
    
    // Save pointer to current devmode
    if (pCurrentDevmode) 
        *pCurrentDevmode = pCurrDM;
        
    // Check if the devmodes are different
    if (pLastDM != pCurrDM) {

        // If the pointers are different the devmodes are always different
        if (!bInsidePage ||
            DifferentDevmodes(pLastDM, pCurrDM)) {

            *pbNewDevmode = TRUE;
        }
    }

    // Call ResetDC on the hPrinterDC if necessary
    if (*pbNewDevmode) {

        if (bInsidePage &&
            !GdiEndPageEMF(hSpoolHandle, dwOptimization)) {

            ODS(("EndPage failed\n"));
            return bReturn;
        }

        if (pCurrDM) {
            pCurrDM->dmPrintQuality = pDevmode->dmPrintQuality;
            pCurrDM->dmYResolution = pDevmode->dmYResolution;
            pCurrDM->dmCopies = pDevmode->dmCopies;

            // @@BEGIN_DDKSPLIT
            // GdiGetDevmodeForPagePvt ensures devmode is atleast big enough for dmYResolution
            // So now we check for dmCollate (which comes after dmYResolution in DEVMODE).
            // @@END_DDKSPLIT

            if ( IS_DMSIZE_VALID ( pCurrDM, dmCollate ) )
            {
                if ( IS_DMSIZE_VALID ( pDevmode, dmCollate ) )
                {
                    pCurrDM->dmCollate = pDevmode->dmCollate;
                }
                else
                {
                    pCurrDM->dmCollate = DMCOLLATE_FALSE;
                }
                
            }
        }

        // Ignore the return values of ResetDC and SetGraphicsMode
        GdiResetDCEMF(hSpoolHandle, pCurrDM);
        SetGraphicsMode(hPrinterDC, GM_ADVANCED);       
    }

    bReturn = TRUE;

    return bReturn;
}

DWORD
PrintOneSideForwardEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwPageNumber,
    DWORD        dwJobNumberOfCopies,
    LPBOOL       pbComplete,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideForwardEMF plays the next physical page in the same order
                      as the spool file.

Parameters: hSpoolHandle              -- handle the spool file handle
            hPrinterDC                -- handle to the printer device context
            dwNumberOfPagesPerSide    -- number of pages to be printed per side by the print processor
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNupBorderFlags          -- border printing options for nup
            bDuplex                   -- flag to indicate duplex printing
            dwOptimization            -- optimization flags
            dwPageNumber              -- pointer to the starting page number
            pbComplete                -- pointer to the flag to indicate completion
            pDevmode                  -- devmode with resolution settings
   
Return Values:  Last Page Number if successful
                0 on job completion (pbReturn set to TRUE) and
                  on failure (pbReturn remains FALSE)
--*/

{
    DWORD              dwPageIndex, dwPageType;
    DWORD              dwReturn = 0;
    LPDEVMODEW         pCurrDM;
    HANDLE             hEMF = NULL;
    DWORD              dwSides;
    BOOL               bNewDevmode;
    DWORD              cPagesToPlay;
    DWORD              dwAngle;
    INT                dmOrientation = pDevmode->dmOrientation;

    // set the number of sides on this page;
    dwSides = bDuplex ? 2 : 1;
    *pbComplete = FALSE;

    for ( ; dwSides && !*pbComplete ; --dwSides) {

       // loop for a single side
       for (dwPageIndex = 1;
            dwPageIndex <= dwNumberOfPagesPerSide;
            ++dwPageIndex, ++dwPageNumber) {

            if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                          dwPageNumber,
                                          &dwPageType))) {

                if (GetLastError() == ERROR_NO_MORE_ITEMS) {
                     // End of the print job
                     *pbComplete = TRUE;
                     break;
                }

                ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }
            dwAngle = EMF_DEGREE_90;
            if (dwPageIndex == 1)
            {
                // Process new devmodes in the spool file that appear before this page
                if (!ResetDCForNewDevmode(hSpoolHandle,
                                      hPrinterDC,
                                      dwPageNumber,
                                      (dwPageIndex != 1),
                                      dwOptimization,
                                      &bNewDevmode,
                                      pDevmode,
                                      &pCurrDM)) {

                    goto CleanUp;
                }
                if (pCurrDM)
                    dmOrientation = pCurrDM->dmOrientation;
            }
            // in case of orientation switch we need to keep track of what
            // we started with and what it is now
            else if (dwNumberOfPagesPerSide > 1)
            {
                if (GdiGetDevmodeForPagePvt(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                    {
                        dwAngle = EMF_DEGREE_SWAP | EMF_DEGREE_90;
                    }
                }
            }
            // Call StartPage for each new page
            if ((dwPageIndex == 1) &&
                !GdiStartPageEMF(hSpoolHandle)) {

                ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }

            if (!PlayEMFPage(hSpoolHandle,
                             hPrinterDC,
                             hEMF,
                             dwNumberOfPagesPerSide,
                             dwPageNumber,
                             dwPageIndex,
                             dwNupBorderFlags,
                             dwAngle)) {

                ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }            
       }

       //
       // Explaination of the scinario set for the conditions on 
       // dwPageIndex1 , pbComplete and bDuplex.
       // N.B. we are naming them cond.1 and cond.2
       //     dwPageIndex!=1    pbComplete   bDuplex    Condition
       //           0               0           0       None    
       //           0               0           1       None
       //           0               1           0       None
       //           0               1           1       Cond2 on Second Side i.e. dwsides==1
       //           1               0           0       Cond1
       //           1               0           1       Cond1
       //           1               1           0       Cond1
       //           1               1           1       Cond1 & Cond2 on First Side i.e. dwsides==2
       //


       // cond.1
       if (dwPageIndex != 1) {

           // Call EndPage if we played any pages
           if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {

               ODS(("EndPage failed\n"));
               *pbComplete = FALSE;
               goto CleanUp;
           }
       }

       // cond.2
       // play empty page on the back of duplex
       if (*pbComplete && bDuplex && dwDrvNumberOfPagesPerSide==1) {

           ODS(("PCL or PS with no N-up\n"));

           //
           // Checking dwsides against 2 or 1. 
           // depends on whether it is n-up or not.
           //
           if (((dwPageIndex!=1)?(dwSides==2):(dwSides==1))) {
          
               if (!GdiStartPageEMF(hSpoolHandle) ||
                   !GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
 
                   ODS(("EndPage failed\n"));
                   *pbComplete = FALSE;
                   goto CleanUp;
               }
           }
        }
    }

    if (*pbComplete && 
        dwNumberOfPagesPerSide==1 && 
        dwDrvNumberOfPagesPerSide!=1 && 
        dwJobNumberOfCopies!=1)
    {
        cPagesToPlay = dwDrvNumberOfPagesPerSide * (bDuplex ? 2 : 1);
        if ((dwPageNumber-1) % cPagesToPlay)
        {
            //
            // Number of pages played on last physical page
            //
            cPagesToPlay = cPagesToPlay - ((dwPageNumber-1) % cPagesToPlay);

            ODS(("\nPS with N-up!\nMust fill in %u pages\n", cPagesToPlay));

            for (;cPagesToPlay;cPagesToPlay--) 
            {
                if (!GdiStartPageEMF(hSpoolHandle) || !GdiEndPageEMF(hSpoolHandle, dwOptimization)) 
                {
                    ODS(("EndPage failed\n"));
                    goto CleanUp;
                }
            }
        }
    }

    if (!(*pbComplete)) dwReturn = dwPageNumber;

CleanUp:

    return dwReturn;
}

BOOL
PrintForwardEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    LPDEVMODEW   pDevmode,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintForwardEMF plays the EMF files in the order in which they
                      were spooled.

Parameters: hSpoolHandle              -- handle the spool file handle
            hPrinterDC                -- handle to the printer device context
            dwNumberOfPagesPerSide    -- number of pages to be printed per side by the print processor
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNupBorderFlags          -- border printing options for nup
            dwJobNumberOfCopies       -- number of copies of the job to be printed
            dwDrvNumberOfCopies       -- number of copies that the driver can print
            bCollate                  -- flag for collating the copies
            bDuplex                   -- flag for duplex printing
            dwOptimization            -- optimization flags
            pDevmode                  -- pointer to devmode for changing the copy count
            pData                     -- needed for status and the handle of the event: pause, resume etc.

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD              dwLastPageNumber = 1,dwPageNumber,dwPageIndex,dwRemainingCopies;
    BOOL               bReturn = FALSE;

    // Keep printing as long as the spool file contains EMF handles.
    while (dwLastPageNumber) {

        //
        // If the print processor is paused, wait for it to be resumed 
        //
        if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
            WaitForSingleObject(pData->semPaused, INFINITE);
        }

        dwPageNumber = dwLastPageNumber;

        if (bCollate) {

           dwLastPageNumber = PrintOneSideForwardEMF(hSpoolHandle,
                                                     hPrinterDC,
                                                     dwNumberOfPagesPerSide,
                                                     dwDrvNumberOfPagesPerSide,
                                                     dwNupBorderFlags,
                                                     bDuplex,
                                                     dwOptimization,
                                                     dwPageNumber,
                                                     dwJobNumberOfCopies,
                                                     &bReturn,
                                                     pDevmode);
        } else {

           dwRemainingCopies = dwJobNumberOfCopies;

           while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }
               
               if (!(dwLastPageNumber =  PrintOneSideForwardEMF(hSpoolHandle,
                                                                hPrinterDC,
                                                                dwNumberOfPagesPerSide,
                                                                dwDrvNumberOfPagesPerSide,
                                                                dwNupBorderFlags,
                                                                bDuplex,
                                                                dwOptimization,
                                                                dwPageNumber,
                                                                dwJobNumberOfCopies,
                                                                &bReturn,
                                                                pDevmode)) &&
                   !bReturn) {

                    goto CleanUp;
               }
           }
        }
    }

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideReverseForDriverEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwPageNumber,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideReverseForDriverEMF plays the EMF pages on the next
                      physical page, in the reverse order for the driver which does the
                      Nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwTotalNumberOfPages   -- total number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            bDuplex                -- flag to indicate duplex printing
            dwOptimization         -- optimization flags
            dwPageNumber           -- page number to start the side
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
    DWORD       dwPageIndex, dwPageType, dwSides;
    BOOL        bReturn = FALSE, bNewDevmode,BeSmart;    
    LPDEVMODEW  pCurrDM;
    HANDLE      hEMF = NULL;
    DWORD       dwLimit;

    dwSides = bDuplex ? 2 : 1;

    //
    // If the document will fit on one phisical page, then this variable will prevent 
    // the printer from playing extra pages just to fill in one phisical page 
    // The exception is when the pages fit on a single phisical page, but they must
    // be collated. Then because of design, the printer will also draw borders for the
    // empty pages which are played so that the page gets ejected.
    //
    BeSmart =  (dwTotalNumberOfPages<=dwDrvNumberOfPagesPerSide) &&
               IS_DMSIZE_VALID(pDevmode, dmCollate) && 
               (pDevmode->dmCollate != DMCOLLATE_TRUE);
         
    for (; dwSides; --dwSides) {

       // This loop may play some empty pages in the last side, since the
       // driver is doing nup and it does not keep count of the page numbers
       //
       dwPageIndex=BeSmart?dwPageNumber:1;
       dwLimit    =BeSmart?dwTotalNumberOfPages:dwDrvNumberOfPagesPerSide;

       for (;dwPageIndex<=dwLimit; ++dwPageIndex,++dwPageNumber) {

             if (BeSmart || dwPageNumber <= dwTotalNumberOfPages) {

                 if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                               dwPageNumber,
                                               &dwPageType))) {
                     ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                 }

                 // Process new devmodes in the spoolfile
                 if (!ResetDCForNewDevmode(hSpoolHandle,
                                           hPrinterDC,
                                           dwPageNumber,
                                           FALSE,
                                           dwOptimization,
                                           &bNewDevmode,
                                           pDevmode,
                                           NULL)) {
                 }
             }

             if (!GdiStartPageEMF(hSpoolHandle)) {
                 ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                 goto CleanUp;
             }

             if (BeSmart || dwPageNumber <= dwTotalNumberOfPages) {
                if (!PlayEMFPage(hSpoolHandle,
                                  hPrinterDC,
                                  hEMF,
                                  1,
                                  dwPageNumber,
                                  1,
                                  dwNupBorderFlags,
                                  EMF_DEGREE_90)) {

                     ODS(("PlayEMFPage failed\n"));
                     goto CleanUp;
                 }
             }

             if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
                 ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                 goto CleanUp;
             }
       }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}



BOOL
PrintReverseForDriverEMF(
    HANDLE     hSpoolHandle,
    HDC        hPrinterDC,
    DWORD      dwDrvNumberOfPagesPerSide,
    DWORD      dwTotalNumberOfPages,
    DWORD      dwNupBorderFlags,
    DWORD      dwJobNumberOfCopies,
    DWORD      dwDrvNumberOfCopies,
    BOOL       bCollate,
    BOOL       bDuplex,
    BOOL       bOdd,
    DWORD      dwOptimization,
    LPDEVMODEW pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintReverseForDriverEMF plays the EMF pages in the reverse order
                      for the driver which does the Nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwTotalNumberOfPages   -- total number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bDuplex                -- flag to indicate duplex printing
            bOdd                   -- flag to indicate odd number of sides to print
            dwOptimization         -- optimization flags
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                                     

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD         dwPageIndex,dwPageNumber,dwRemainingCopies;
    BOOL          bReturn = FALSE;

    // select the correct page for duplex printing
    if (bDuplex && !bOdd) {
       if (pHead) {
          pHead = pHead->pNext;
       } else {
          bReturn = TRUE;
          goto CleanUp;
       }
    }

    // play the sides in reverse order
    while (pHead) {
        //
        // If the print processor is paused, wait for it to be resumed
        //
        if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
            WaitForSingleObject(pData->semPaused, INFINITE);
        }
        
        // set the page number
        dwPageNumber = pHead->dwPageNumber;

        if (bCollate) {
       
           if (!PrintOneSideReverseForDriverEMF(hSpoolHandle,
                                                hPrinterDC,
                                                dwDrvNumberOfPagesPerSide,
                                                dwTotalNumberOfPages,
                                                dwNupBorderFlags,
                                                bDuplex,
                                                dwOptimization,
                                                dwPageNumber,
                                                pDevmode)) {
               goto CleanUp;
           }
           
        } else {

           dwRemainingCopies = dwJobNumberOfCopies;

           while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }

               if (!PrintOneSideReverseForDriverEMF(hSpoolHandle,
                                                    hPrinterDC,
                                                    dwDrvNumberOfPagesPerSide,
                                                    dwTotalNumberOfPages,
                                                    dwNupBorderFlags,
                                                    bDuplex,
                                                    dwOptimization,
                                                    dwPageNumber,
                                                    pDevmode)) {
                   goto CleanUp;
               }
           }
        }

        pHead = pHead->pNext;

        // go to the next page for duplex printing
        if (bDuplex && pHead) {
            pHead = pHead->pNext;
        }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideReverseEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    BOOL         bDuplex,
    DWORD        dwOptimization,
    DWORD        dwStartPage1,
    DWORD        dwEndPage1,
    DWORD        dwStartPage2,
    DWORD        dwEndPage2,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideReverseEMF plays the EMF pages for the next physical page.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            bDuplex                -- flag to indicate duplex printing
            dwOptimization         -- optimization flags
            dwStartPage1           -- page number of the first EMF page on 1st side
            dwEndPage1             -- page number of the last EMF page on 1st side
            dwStartPage2           -- page number of the first EMF page on 2nd side
            dwEndPage2             -- page number of the last EMF page on 2nd side
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/
{
    DWORD         dwPageNumber, dwPageIndex, dwPageType;
    BOOL          bReturn = FALSE, bNewDevmode;
    LPDEVMODEW    pCurrDM;
    HANDLE        hEMF = NULL;
    DWORD         dwEndPage, dwStartPage, dwSides, dwAngle;
    INT           dmOrientation = pDevmode->dmOrientation;

    for (dwSides = bDuplex ? 2 : 1; 
         dwSides; 
         --dwSides) {

         if (bDuplex && (dwSides == 1)) {
             dwStartPage = dwStartPage2;
             dwEndPage = dwEndPage2;
         } else {
             dwStartPage = dwStartPage1;
             dwEndPage = dwEndPage1;
         }

         for (dwPageNumber = dwStartPage, dwPageIndex = 1;
              dwPageNumber <= dwEndPage;
              ++dwPageNumber, ++dwPageIndex) {

            if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                             dwPageNumber,
                                             &dwPageType))) {

                ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;                      
            }
            dwAngle = EMF_DEGREE_90;
            if (dwPageIndex == 1) {
                   
                // Process devmodes in the spool file and call StartPage
                if (!ResetDCForNewDevmode(hSpoolHandle,
                                             hPrinterDC,
                                             dwPageNumber,
                                             FALSE,
                                             dwOptimization,
                                             &bNewDevmode,
                                             pDevmode,
                                             &pCurrDM) ||

                       !GdiStartPageEMF(hSpoolHandle)) {
                        
                       goto CleanUp;
                }
                if (pCurrDM)
                    dmOrientation = pCurrDM->dmOrientation;
            }
            // in case of orientation switch we need to keep track of what
            // we started with and what it is now
            else if (dwNumberOfPagesPerSide > 1)
            {
                if (GdiGetDevmodeForPagePvt(hSpoolHandle, 
                              dwPageNumber,
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                    {
                        dwAngle = EMF_DEGREE_SWAP | EMF_DEGREE_90;
                    }
                }
            }

            if (!PlayEMFPage(hSpoolHandle,
                                hPrinterDC,
                                hEMF,
                                dwNumberOfPagesPerSide,
                                dwPageNumber,
                                dwPageIndex,
                                dwNupBorderFlags,
                                dwAngle)) {

                ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                goto CleanUp;
            }
         }

         if ((dwPageIndex == 1) && !GdiStartPageEMF(hSpoolHandle)) {
              ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
              goto CleanUp;
         }

         if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
             ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
             goto CleanUp;
         }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintReverseEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bDuplex,
    BOOL         bOdd,
    DWORD        dwOptimization,
    LPDEVMODEW   pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintReverseEMF plays the EMF pages in the reverse order and also
                      performs nup transformations.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwTotalNumberOfPages   -- number of pages in the document
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bDuplex                -- flag to indicate duplex printing
            bOdd                   -- flag to indicate odd number of sides to print
            dwOptimization         -- optimization flags
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                                       

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD         dwPageNumber,dwPageIndex,dwRemainingCopies;
    DWORD         dwStartPage1,dwStartPage2,dwEndPage1,dwEndPage2;
    BOOL          bReturn = FALSE;

    if (!pHead) {
        bReturn = TRUE;
        goto CleanUp;
    }

    // set the start and end page numbers for duplex and regular printing
    if (bDuplex) {
       if (bOdd) {
           dwStartPage1 = pHead->dwPageNumber;
           dwEndPage1   = dwTotalNumberOfPages;
           dwStartPage2 = dwTotalNumberOfPages+1;
           dwEndPage2   = 0;
       } else {
           dwStartPage2 = pHead->dwPageNumber;
           dwEndPage2   = dwTotalNumberOfPages;

           if (pHead = pHead->pNext) {
               dwStartPage1 = pHead->dwPageNumber;
               dwEndPage1   = dwStartPage2 - 1;
           }
       }
    } else {
       dwStartPage1 = pHead->dwPageNumber;
       dwEndPage1   = dwTotalNumberOfPages;
       dwStartPage2 = 0;
       dwEndPage2   = 0;
    }

    while (pHead) {
       //
       // If the print processor is paused, wait for it to be resumed 
       //
       if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
              WaitForSingleObject(pData->semPaused, INFINITE);
       }
         
       if (bCollate) {

          if (!PrintOneSideReverseEMF(hSpoolHandle,
                                      hPrinterDC,
                                      dwNumberOfPagesPerSide,
                                      dwNupBorderFlags,
                                      bDuplex,
                                      dwOptimization,
                                      dwStartPage1,
                                      dwEndPage1,
                                      dwStartPage2,
                                      dwEndPage2,
                                      pDevmode)) {

              goto CleanUp;
          }

       } else {

          dwRemainingCopies = dwJobNumberOfCopies;

          while (dwRemainingCopies) {

              if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                 SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                 dwRemainingCopies = 0;
              } else {
                 SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                 dwRemainingCopies -= dwDrvNumberOfCopies;
              }

              if (!PrintOneSideReverseEMF(hSpoolHandle,
                                          hPrinterDC,
                                          dwNumberOfPagesPerSide,
                                          dwNupBorderFlags,
                                          bDuplex,
                                          dwOptimization,
                                          dwStartPage1,
                                          dwEndPage1,
                                          dwStartPage2,
                                          dwEndPage2,
                                          pDevmode)) {

                  goto CleanUp;
              }
          }
       }

       if (bDuplex) {
          if (pHead->pNext && pHead->pNext->pNext) {
              dwEndPage2 = pHead->dwPageNumber - 1;
              pHead = pHead->pNext;
              dwStartPage2 = pHead->dwPageNumber;
              dwEndPage1 = dwStartPage2 - 1;
              pHead = pHead->pNext;
              dwStartPage1 = pHead->dwPageNumber;
          } else {
              break;
          }
       } else {
          pHead = pHead->pNext;
          if (pHead) {
              dwEndPage1 = dwStartPage1 - 1;
              dwStartPage1 = pHead->dwPageNumber;
          }
       }

    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintOneSideBookletEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwNupBorderFlags,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwTotalPrintPages,
    DWORD        dwStartPage,
    BOOL         bReverseOrderPrinting,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODE    pDevmode)

/*++
Function Description: PrintOneSideBookletEMF prints one page of the booklet job.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwNupBorderFlags       -- border printing options for nup
            dwTotalNumberOfPages   -- number of pages in the document
            dwTotalPrintPages      -- number of pages to printed (multiple of 4)
            dwStartPage            -- number of the starting page for the side
            bReverseOrderPrinting  -- flag for reverse order printing
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- devmode with resolution settings

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    DWORD       dwPageArray[4];
    DWORD       dwPagesPrinted = 0, dwPageIndex, dwAngle, dwPageType, dwLastPage;
    HANDLE      hEMF = NULL;
    LPDEVMODEW  pCurrDM;
    BOOL        bReturn = FALSE ,bNewDevmode;
    INT         dmOrientation;

    // set the order of the pages
    if (bReverseOrderPrinting) {
        dwPageArray[0] = dwStartPage + 1;
        dwPageArray[1] = dwTotalPrintPages - dwStartPage;
        if (dwDuplexMode == EMF_DUP_VERT) {
           dwPageArray[2] = dwStartPage;
           dwPageArray[3] = dwPageArray[1] + 1;
        } else { // EMF_DUP_HORZ
           dwPageArray[3] = dwStartPage;
           dwPageArray[2] = dwPageArray[1] + 1;
        }
    } else {
        dwPageArray[1] = dwStartPage;
        dwPageArray[0] = dwTotalPrintPages - dwStartPage + 1;
        if (dwDuplexMode == EMF_DUP_VERT) {
           dwPageArray[2] = dwPageArray[0] - 1;
           dwPageArray[3] = dwPageArray[1] + 1;
        } else { // EMF_DUP_HORZ
           dwPageArray[2] = dwPageArray[1] + 1;
           dwPageArray[3] = dwPageArray[0] - 1;
        }
    }

    // Set page number for ResetDC
    dwLastPage = (dwTotalNumberOfPages < dwPageArray[0]) ? dwTotalNumberOfPages
                                                         : dwPageArray[0];

    // Process devmodes in the spool file
    if (!ResetDCForNewDevmode(hSpoolHandle,
                              hPrinterDC,
                              dwLastPage,
                              FALSE,
                              dwOptimization,
                              &bNewDevmode,
                              pDevmode,
                              &pCurrDM)) {
        goto CleanUp;
    }
    if (pCurrDM)
        dmOrientation = pCurrDM->dmOrientation;
    else
        dmOrientation = pDevmode->dmOrientation;

    while (dwPagesPrinted < 4) {
       for (dwPageIndex = 1;
            dwPageIndex <= dwNumberOfPagesPerSide;
            ++dwPageIndex, ++dwPagesPrinted) {

            if (dwPageArray[dwPagesPrinted] <= dwTotalNumberOfPages) {

                if (!(hEMF = GdiGetPageHandle(hSpoolHandle,
                                              dwPageArray[dwPagesPrinted],
                                              &dwPageType))) {
                     ODS(("GdiGetPageHandle failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }
            if (dwPageIndex == 1) {

                if (!GdiStartPageEMF(hSpoolHandle)) {
                     ODS(("StartPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                    goto CleanUp;
                }
            }
    
            if (dwPageArray[dwPagesPrinted] <= dwTotalNumberOfPages) {
                // in case of orientation switch we need to keep track of what
                // we started with and what it is now
                dwAngle = 0;
                if (GdiGetDevmodeForPagePvt(hSpoolHandle, 
                              dwPageArray[dwPagesPrinted],
                              &pCurrDM,
                              NULL))
                {
                    if (pCurrDM && pCurrDM->dmOrientation != dmOrientation)
                        dwAngle |= EMF_DEGREE_SWAP;
                }

                if ((dwDuplexMode == EMF_DUP_VERT) &&
                     (dwPagesPrinted > 1)) {
                      dwAngle |= EMF_DEGREE_270;
                } else { // EMF_DUP_HORZ or 1st side
                      dwAngle |= EMF_DEGREE_90;
                }
  
                if (!PlayEMFPage(hSpoolHandle,
                                  hPrinterDC,
                                  hEMF,
                                  dwNumberOfPagesPerSide,
                                  dwPageArray[dwPagesPrinted],
                                  dwPageIndex,
                                  dwNupBorderFlags,
                                  dwAngle)) {

                     ODS(("PlayEMFPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }

            if (dwPageIndex == dwNumberOfPagesPerSide) {

                if (!GdiEndPageEMF(hSpoolHandle, dwOptimization)) {
                     ODS(("EndPage failed\nPrinter %ws\n", pDevmode->dmDeviceName));
                     goto CleanUp;
                }
            }
       }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}


BOOL
PrintBookletEMF(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bReverseOrderPrinting,
    BOOL         bCollate,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODEW   pDevmode,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintBookletEMF prints the job in 2-up in booklet form.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwTotalNumberOfPages   -- number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bReverseOrderPrinting  -- flag for reverse order printing
            bCollate               -- flag for collating the copies
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- pointer to devmode for changing the copy count
            pData                  -- needed for status and the handle of the event: pause, resume etc.

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL              bReturn = FALSE;
    DWORD             dwTotalPrintPages, dwNumberOfPhyPages, dwRemainingCopies, dwIndex;

    // Get closest multiple of 4 greater than dwTotalNumberOfPages
    dwTotalPrintPages = dwTotalNumberOfPages - (dwTotalNumberOfPages % 4);
    if (dwTotalPrintPages != dwTotalNumberOfPages) {
        dwTotalPrintPages += 4;
    }
    dwNumberOfPhyPages = (DWORD) dwTotalPrintPages / 4;

    for (dwIndex = 0; dwIndex < dwNumberOfPhyPages; ++dwIndex) {
         //
         // If the print processor is paused, wait for it to be resumed 
         //
         if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                WaitForSingleObject(pData->semPaused, INFINITE);
         }

         if (bCollate) {

            if (!PrintOneSideBookletEMF(hSpoolHandle,
                                        hPrinterDC,
                                        dwNumberOfPagesPerSide,
                                        dwNupBorderFlags,
                                        dwTotalNumberOfPages,
                                        dwTotalPrintPages,
                                        dwIndex * 2 + 1,
                                        bReverseOrderPrinting,
                                        dwOptimization,
                                        dwDuplexMode,
                                        pDevmode)) {
                 goto CleanUp;
            }

         } else {

            dwRemainingCopies = dwJobNumberOfCopies;

            while (dwRemainingCopies) {

                if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                   SetDrvCopies(hPrinterDC, pDevmode, dwRemainingCopies);
                   dwRemainingCopies = 0;
                } else {
                   SetDrvCopies(hPrinterDC, pDevmode, dwDrvNumberOfCopies);
                   dwRemainingCopies -= dwDrvNumberOfCopies;
                }

                if (!PrintOneSideBookletEMF(hSpoolHandle,
                                            hPrinterDC,
                                            dwNumberOfPagesPerSide,
                                            dwNupBorderFlags,
                                            dwTotalNumberOfPages,
                                            dwTotalPrintPages,
                                            dwIndex * 2 + 1,
                                            bReverseOrderPrinting,
                                            dwOptimization,
                                            dwDuplexMode,
                                            pDevmode)) {
                     goto CleanUp;
                }
            }
         }
    }

    bReturn = TRUE;

CleanUp:

    return bReturn;
}

BOOL
PrintEMFSingleCopy(
    HANDLE       hSpoolHandle,
    HDC          hPrinterDC,
    BOOL         bReverseOrderPrinting,
    DWORD        dwDrvNumberOfPagesPerSide,
    DWORD        dwNumberOfPagesPerSide,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNupBorderFlags,
    DWORD        dwJobNumberOfCopies,
    DWORD        dwDrvNumberOfCopies,
    BOOL         bCollate,
    BOOL         bOdd,
    BOOL         bBookletPrint,
    DWORD        dwOptimization,
    DWORD        dwDuplexMode,
    LPDEVMODEW   pDevmode,
    PPAGE_NUMBER pHead,
    PPRINTPROCESSORDATA pData)

/*++
Function Description: PrintEMFSingleCopy plays one copy of the job on hPrinterDC.

Parameters: hSpoolHandle           -- handle the spool file handle
            hPrinterDC             -- handle to the printer device context
            bReverseOrderPrinting  -- flag for reverse order printing
            dwDrvNumberOfPagesPerSide -- number of pages the driver will print per side
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            dwTotalNumberOfPages   -- number of pages in the document
            dwNupBorderFlags       -- border printing options for nup
            dwJobNumberOfCopies    -- number of copies of the job to be printed
            dwDrvNumberOfCopies    -- number of copies that the driver can print
            bCollate               -- flag for collating the copies
            bOdd                   -- flag to indicate odd number of sides to print
            bBookletPrint          -- flag for booklet printing
            dwOptimization         -- optimization flags
            dwDuplexMode           -- duplex printing mode (none|horz|vert)
            pDevmode               -- pointer to devmode for changing the copy count
            pHead                  -- pointer to a linked list containing the starting
                                       page numbers for each of the sides
            pData                  -- needed for status and the handle of the event: pause, resume etc.                             

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{
    BOOL  bDuplex = (dwDuplexMode != EMF_DUP_NONE);

    if (bBookletPrint) {

       // Booklet Printing
       return PrintBookletEMF(hSpoolHandle,
                              hPrinterDC,
                              dwNumberOfPagesPerSide,
                              dwTotalNumberOfPages,
                              dwNupBorderFlags,
                              dwJobNumberOfCopies,
                              dwDrvNumberOfCopies,
                              bReverseOrderPrinting,
                              bCollate,
                              dwOptimization,
                              dwDuplexMode,
                              pDevmode,
                              pData);
    }

    if (bReverseOrderPrinting) {
       if (dwDrvNumberOfPagesPerSide != 1 || dwNumberOfPagesPerSide == 1) {

          // @@BEGIN_DDKSPLIT
          // Reverse printing while driver does nup / no nup required
          // @@END_DDKSPLIT
          return PrintReverseForDriverEMF(hSpoolHandle,
                                          hPrinterDC,
                                          dwDrvNumberOfPagesPerSide,
                                          dwTotalNumberOfPages,
                                          dwNupBorderFlags,
                                          dwJobNumberOfCopies,
                                          dwDrvNumberOfCopies,
                                          bCollate,
                                          bDuplex,
                                          bOdd,
                                          dwOptimization,
                                          pDevmode,
                                          pHead,
                                          pData);
       } else {

          // Reverse printing and nup
          return PrintReverseEMF(hSpoolHandle,
                                 hPrinterDC,
                                 dwTotalNumberOfPages,
                                 dwNumberOfPagesPerSide,
                                 dwNupBorderFlags,
                                 dwJobNumberOfCopies,
                                 dwDrvNumberOfCopies,
                                 bCollate,
                                 bDuplex,
                                 bOdd,
                                 dwOptimization,
                                 pDevmode,
                                 pHead,
                                 pData);
       }

    } else {

       // Normal printing
       return PrintForwardEMF(hSpoolHandle,
                              hPrinterDC,
                              dwNumberOfPagesPerSide,
                              dwDrvNumberOfPagesPerSide,
                              dwNupBorderFlags,
                              dwJobNumberOfCopies,
                              dwDrvNumberOfCopies,
                              bCollate,
                              bDuplex,
                              dwOptimization,
                              pDevmode,
                              pData);
    }
}

BOOL
GetStartPageList(
    HANDLE       hSpoolHandle,
    PPAGE_NUMBER *pHead,
    DWORD        dwTotalNumberOfPages,
    DWORD        dwNumberOfPagesPerSide,
    BOOL         bCheckForDevmode,
    LPBOOL       pbOdd)

/*++
Function Description: GetStartPageList generates a list of the page numbers which
                      should appear on the start of each side of the job. This takes
                      into consideration the ResetDC calls that may appear before the
                      end of the page. The list generated by GetStartPageList is used
                      to play the job in reverse order.

Parameters: hSpoolHandle           -- handle the spool file handle
            pHead                  -- pointer to a pointer to a linked list containing the
                                       starting page numbers for each of the sides
            dwTotalNumberOfPages   -- number of pages in the document
            dwNumberOfPagesPerSide -- number of pages to be printed per side by the print
                                       processor
            pbOdd                  -- pointer to flag indicating odd number of pages to
                                       print

Return Values:  TRUE if successful
                FALSE otherwise
--*/

{

    DWORD        dwPageIndex,dwPageNumber=1,dwPageType;
    LPDEVMODEW   pCurrDM, pLastDM;
    PPAGE_NUMBER pTemp=NULL;
    BOOL         bReturn = FALSE;
    BOOL         bCheckDevmode;

    bCheckDevmode = bCheckForDevmode && (dwNumberOfPagesPerSide != 1);

    while (dwPageNumber <= dwTotalNumberOfPages) {

       for (dwPageIndex = 1;
            (dwPageIndex <= dwNumberOfPagesPerSide) && (dwPageNumber <= dwTotalNumberOfPages);
            ++dwPageIndex, ++dwPageNumber) {

          if (bCheckDevmode) {

             // Check if the devmode has changed requiring a new page
             if (!GdiGetDevmodeForPagePvt(hSpoolHandle, dwPageNumber,
                                               &pCurrDM, NULL)) {
                 ODS(("Get devmodes failed\n"));
                 goto CleanUp;
             }

             if (dwPageIndex == 1) {
                 // Save the Devmode for the first page on a side
                 pLastDM = pCurrDM;

             } else {
                 // If the Devmode changes in a side, start a new page
                 if (DifferentDevmodes(pCurrDM, pLastDM)) {

                     dwPageIndex = 1;
                     pLastDM = pCurrDM;
                 }
             }
          }

          // Create a node for the start of a side
          if (dwPageIndex == 1) {

              if (!(pTemp = AllocSplMem(sizeof(PAGE_NUMBER)))) {
                  ODS(("GetStartPageList - Run out of memory"));
                  goto CleanUp;
              }
              pTemp->pNext = *pHead;
              pTemp->dwPageNumber = dwPageNumber;
              *pHead = pTemp;

              // flip the bOdd flag
              *pbOdd = !*pbOdd;
          }
       }
    }

    bReturn = TRUE;

CleanUp:

    // Free up the memory in case of a failure.
    if (!bReturn) {
       while (pTemp = *pHead) {
          *pHead = (*pHead)->pNext;
          FreeSplMem(pTemp);
       }
    }
    return bReturn;
}


BOOL
CopyDevmode(
    PPRINTPROCESSORDATA pData,
    LPDEVMODEW *pDevmode)

/*++
Function Description: Copies the devmode in pData or the default devmode into pDevmode.

Parameters:   pData           - Data structure for the print job
              pDevmode        - pointer to devmode

Return Value:  TRUE  if successful
               FALSE otherwise
--*/

{
    HANDLE           hDrvPrinter = NULL;
    BOOL             bReturn = FALSE;
    fnWinSpoolDrv    fnList;
    LONG             lNeeded;
    HMODULE          hWinSpoolDrv = NULL;

    if (pData->pDevmode) {

        lNeeded = pData->pDevmode->dmSize +  pData->pDevmode->dmDriverExtra;

        if (*pDevmode = (LPDEVMODEW) AllocSplMem(lNeeded)) {
            memcpy(*pDevmode, pData->pDevmode, lNeeded);
        } else {
            goto CleanUp;
        }

    } else {
        // Get the default devmode

        ZeroMemory ( &fnList, sizeof (fnWinSpoolDrv) );

        //
        // Get the pointers to the client side functions. 
        //

        if (!(hWinSpoolDrv = LoadLibrary(TEXT("winspool.drv")))) 
        {
           // Could not load the client side of the spooler
           goto CleanUp;
        }

        fnList.pfnOpenPrinter        = (BOOL (*)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS))
                                            GetProcAddress( hWinSpoolDrv,"OpenPrinterW" );

        fnList.pfnClosePrinter       = (BOOL (*)(HANDLE))
                                            GetProcAddress( hWinSpoolDrv,"ClosePrinter" );


        fnList.pfnDocumentProperties = (LONG (*)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD))
                                             GetProcAddress( hWinSpoolDrv,"DocumentPropertiesW" );

        if ( NULL == fnList.pfnOpenPrinter   ||
             NULL == fnList.pfnClosePrinter  ||
             NULL == fnList.pfnDocumentProperties )
        {
            goto CleanUp;
        }

        // Get a client side printer handle to pass to the driver
        if (!(* (fnList.pfnOpenPrinter))(pData->pPrinterName, &hDrvPrinter, NULL)) {
            ODS(("Open printer failed\nPrinter %ws\n", pData->pPrinterName));
            goto CleanUp;
        }

        lNeeded = (* (fnList.pfnDocumentProperties))(NULL,
                                                     hDrvPrinter,
                                                     pData->pPrinterName,
                                                     NULL,
                                                     NULL,
                                                     0);

        if (lNeeded <= 0  ||
            !(*pDevmode = (LPDEVMODEW) AllocSplMem(lNeeded)) ||
            (* (fnList.pfnDocumentProperties))(NULL,
                                               hDrvPrinter,
                                               pData->pPrinterName,
                                               *pDevmode,
                                               NULL,
                                               DM_OUT_BUFFER) < 0) {

             if (*pDevmode) {
                FreeSplMem(*pDevmode);
                *pDevmode = NULL;
             }

             ODS(("DocumentProperties failed\nPrinter %ws\n",pData->pPrinterName));
             goto CleanUp;
        }
    }

    bReturn = TRUE;

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }

    if ( hWinSpoolDrv )
    {
        FreeLibrary (hWinSpoolDrv);
        hWinSpoolDrv = NULL;
    }

    return bReturn;
}

BOOL
PrintEMFJob(
    PPRINTPROCESSORDATA pData,
    LPWSTR pDocumentName)

/*++
Function Description: Prints out a job with EMF data type.

Parameters:   pData           - Data structure for this job
              pDocumentName   - Name of this document

Return Value:  TRUE  if successful
               FALSE if failed - GetLastError() will return reason.
--*/

{
    HANDLE             hSpoolHandle = NULL;
    DWORD              LastError; 
    HDC                hPrinterDC = NULL;

    BOOL               bReverseOrderPrinting, bReturn = FALSE, bSetWorldXform = TRUE;
    BOOL               bCollate, bDuplex, bBookletPrint, bStartDoc = FALSE, bOdd = FALSE;
    BOOL               bUpdateAttributes = FALSE;
    SHORT              dmCollate,dmCopies;

    DWORD              dwNumberOfPagesPerSide, dwTotalNumberOfPages = 0, dwNupBorderFlags;
    DWORD              dwJobNumberOfPagesPerSide, dwDrvNumberOfPagesPerSide, dwDuplexMode;
    DWORD              dwJobNumberOfCopies, dwDrvNumberOfCopies,dwRemainingCopies;
    DWORD              dwJobOrder, dwDrvOrder, dwOptimization;

    DOCINFOW           DocInfo;
    XFORM              OldXForm;
    PPAGE_NUMBER       pHead = NULL,pTemp;
    ATTRIBUTE_INFO_3   AttributeInfo;
    LPDEVMODEW         pDevmode = NULL, pFirstDM = NULL, pCopyDM;

    
    // Copy the devmode into pDevMode
    if (!CopyDevmode(pData, &pDevmode)) {
        
        ODS(("CopyDevmode failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    if ( ! BIsDevmodeOfLeastAcceptableSize (pDevmode) )
    {
        ODS(("Devmode not big enough. Failing job.\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    // Update resolution before CreateDC for monochrome optimization
    if (!GetJobAttributes(pData->pPrinterName,
                          pDevmode,
                          &AttributeInfo)) {
        ODS(("GetJobAttributes failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    } else {
        if (AttributeInfo.dwColorOptimization) {
            if (pDevmode->dmPrintQuality != AttributeInfo.dmPrintQuality ||
                pDevmode->dmYResolution != AttributeInfo.dmYResolution)
            {
                pDevmode->dmPrintQuality =  AttributeInfo.dmPrintQuality;
                pDevmode->dmYResolution =  AttributeInfo.dmYResolution;
                bUpdateAttributes = TRUE;
            }
        }
        if (pDevmode->dmFields & DM_COLLATE)
            dmCollate = pDevmode->dmCollate;
        else
            dmCollate = DMCOLLATE_FALSE;

        if (pDevmode->dmFields & DM_COPIES)
            dmCopies = pDevmode->dmCopies;
        else
            dmCopies = 0;
    }

    // Get spool file handle and printer device context from GDI
    try {

        hSpoolHandle = GdiGetSpoolFileHandle(pData->pPrinterName,
                                             pDevmode,
                                             pDocumentName);
        if (hSpoolHandle) {
            hPrinterDC = GdiGetDC(hSpoolHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    if (!hPrinterDC || !hSpoolHandle) {
        goto CleanUp;
    }

    // Use the first devmode in the spool file to update the copy count
    // and the collate setting
    if (GdiGetDevmodeForPagePvt(hSpoolHandle, 1, &pFirstDM, NULL) &&
        pFirstDM) {
        
        if (pFirstDM->dmFields & DM_COPIES) {
            pDevmode->dmFields |= DM_COPIES;
            pDevmode->dmCopies = pFirstDM->dmCopies;
        }
        if ( (pFirstDM->dmFields & DM_COLLATE) && 
             IS_DMSIZE_VALID ( pDevmode, dmCollate) )
        {
            pDevmode->dmFields |= DM_COLLATE;
            pDevmode->dmCollate = pFirstDM->dmCollate;
        }
    }

    // The number of copies of the print job is the product of the number of copies set
    // from the driver UI (present in the devmode) and the number of copies in pData struct
    dwJobNumberOfCopies = (pDevmode->dmFields & DM_COPIES) ? pData->Copies*pDevmode->dmCopies
                                                           : pData->Copies;
    pDevmode->dmCopies = (short) dwJobNumberOfCopies;
    pDevmode->dmFields |=  DM_COPIES;

    // If collate is true this limits the ability of the driver to do multiple copies 
    // and causes the driver (PS) supported n-up to print blank page borders for reverse printing.
    // Therefore we disable collate for 1 page multiple copy jobs or no copies but n-up since 
    // collate has no meaning in those cases.
    //
    if ((pDevmode->dmFields & DM_COLLATE) && pDevmode->dmCollate == DMCOLLATE_TRUE)
    {
        if (dwJobNumberOfCopies > 1)
        {
            // Get the number of pages in the job. This call waits till the
            // last page is spooled.
            try {

                dwTotalNumberOfPages = GdiGetPageCount(hSpoolHandle);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
                goto SkipCollateDisable;
            }
            if (dwTotalNumberOfPages > AttributeInfo.dwDrvNumberOfPagesPerSide)
                goto SkipCollateDisable;
            
        }
        // if copies == 1 and driver n-up we will disable collate 
        //
        else if (AttributeInfo.dwDrvNumberOfPagesPerSide <= 1 && dmCollate == DMCOLLATE_TRUE)
            goto SkipCollateDisable;
            
        pDevmode->dmCollate = DMCOLLATE_FALSE;
        if (pFirstDM && 
            IS_DMSIZE_VALID ( pFirstDM, dmCollate) )
        {
            pFirstDM->dmCollate = DMCOLLATE_FALSE;
        }
    }
SkipCollateDisable:    
    // Update the job attributes but only if something has changed. This is an expensive 
    // call so we only make a second call to GetJobAttributes if something has changed.
    //
    if (bUpdateAttributes || pDevmode->dmCopies != dmCopies || 
            ((pDevmode->dmFields & DM_COLLATE) && (pDevmode->dmCollate != dmCollate)))
    {
        if (!GetJobAttributes(pData->pPrinterName,
                          pDevmode,
                          &AttributeInfo)) {
            ODS(("GetJobAttributes failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
            goto CleanUp;
        }
    }

    // Initialize bReverseOrderPrinting, dwJobNumberOfPagesPerSide,
    // dwDrvNumberOfPagesPerSide, dwNupBorderFlags, dwJobNumberOfCopies,
    // dwDrvNumberOfCopies and bCollate

    dwJobNumberOfPagesPerSide = AttributeInfo.dwJobNumberOfPagesPerSide;
    dwDrvNumberOfPagesPerSide = AttributeInfo.dwDrvNumberOfPagesPerSide;
    dwNupBorderFlags          = AttributeInfo.dwNupBorderFlags;
    dwJobNumberOfCopies       = AttributeInfo.dwJobNumberOfCopies;
    dwDrvNumberOfCopies       = AttributeInfo.dwDrvNumberOfCopies;

    dwJobOrder                = AttributeInfo.dwJobPageOrderFlags & ( NORMAL_PRINT | REVERSE_PRINT);
    dwDrvOrder                = AttributeInfo.dwDrvPageOrderFlags & ( NORMAL_PRINT | REVERSE_PRINT);
    bReverseOrderPrinting     = (dwJobOrder != dwDrvOrder);

    dwJobOrder                = AttributeInfo.dwJobPageOrderFlags & BOOKLET_PRINT;
    dwDrvOrder                = AttributeInfo.dwDrvPageOrderFlags & BOOKLET_PRINT;
    bBookletPrint             = (dwJobOrder != dwDrvOrder);

    bCollate                  = (pDevmode->dmFields & DM_COLLATE) &&
                                  (pDevmode->dmCollate == DMCOLLATE_TRUE);

    bDuplex                   = (pDevmode->dmFields & DM_DUPLEX) &&
                                  (pDevmode->dmDuplex != DMDUP_SIMPLEX);
    

    if (!dwJobNumberOfCopies) {
        //
        // Some applications can set the copy count to 0.
        // In this case we exit.
        //
        bReturn = TRUE;
        goto CleanUp;
    }

    if (bDuplex) {
        dwDuplexMode = (pDevmode->dmDuplex == DMDUP_HORIZONTAL) ? EMF_DUP_HORZ
                                                                : EMF_DUP_VERT;
    } else {
        dwDuplexMode = EMF_DUP_NONE;
    }

    if (bBookletPrint) {
        if (!bDuplex) {
            // Not supported w/o duplex printing. Use default settings.
            bBookletPrint = FALSE;
            dwDrvNumberOfPagesPerSide = 1;
            dwJobNumberOfPagesPerSide = 1;
        } else {
            // Fixed settings for pages per side.
            dwDrvNumberOfPagesPerSide = 1;
            dwJobNumberOfPagesPerSide = 2;
        }
    }

    // Number of pages per side that the print processor has to play
    dwNumberOfPagesPerSide = (dwDrvNumberOfPagesPerSide == 1)
                                               ? dwJobNumberOfPagesPerSide
                                               : 1;

    if (dwNumberOfPagesPerSide == 1) {
        // if the print processor is not doing nup, don't draw borders
        dwNupBorderFlags = NO_BORDER_PRINT;
    }

    //
    // Color optimization may cause wrong output with duplex
    //
    dwOptimization = (AttributeInfo.dwColorOptimization == COLOR_OPTIMIZATION && 
                                           !bDuplex && dwJobNumberOfPagesPerSide == 1)
                                           ? EMF_PP_COLOR_OPTIMIZATION
                                           : 0;

    // Check for Valid Option for n-up printing
    if (!ValidNumberForNUp(dwNumberOfPagesPerSide)) {
        ODS(("Invalid N-up option\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    if (bReverseOrderPrinting || bBookletPrint) {

       // Get the number of pages in the job. This call waits till the
       // last page is spooled.
       try {

           dwTotalNumberOfPages= GdiGetPageCount(hSpoolHandle);

       } except (EXCEPTION_EXECUTE_HANDLER) {

           ODS(("PrintEMFJob gave an exceptionPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
           goto CleanUp;
       }

       // Get start page list for reverse printing
       // Check for a change of devmode between pages only if Nup and PCL driver
       if (!GetStartPageList(hSpoolHandle,
                             &pHead,
                             dwTotalNumberOfPages,
                             dwJobNumberOfPagesPerSide,
                             FALSE,
                             &bOdd)) {
            goto CleanUp;
       }
    }

    // Save the old transformation on hPrinterDC
    if (!SetGraphicsMode(hPrinterDC,GM_ADVANCED) ||
        !GetWorldTransform(hPrinterDC,&OldXForm)) {

         bSetWorldXform = FALSE;
         ODS(("Transformation matrix can't be set\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
         goto CleanUp;
    }

    // pCopyDM will be used for changing the copy count
    pCopyDM = pFirstDM ? pFirstDM : pDevmode;
    pCopyDM->dmPrintQuality = pDevmode->dmPrintQuality;
    pCopyDM->dmYResolution = pDevmode->dmYResolution;

    try {

        DocInfo.cbSize = sizeof(DOCINFOW);
        DocInfo.lpszDocName  = pData->pDocument;
        DocInfo.lpszOutput   = pData->pOutputFile;
        DocInfo.lpszDatatype = NULL;

        if (!GdiStartDocEMF(hSpoolHandle, &DocInfo)) goto CleanUp;
        bStartDoc = TRUE;

        if (bCollate) {

            dwRemainingCopies = dwJobNumberOfCopies & 0x0000FFFF ;

            while (dwRemainingCopies) {

               if (dwRemainingCopies <= dwDrvNumberOfCopies) {
                  SetDrvCopies(hPrinterDC, pCopyDM, dwRemainingCopies);
                  dwRemainingCopies = 0;
               } else {
                  SetDrvCopies(hPrinterDC, pCopyDM, dwDrvNumberOfCopies);
                  dwRemainingCopies -= dwDrvNumberOfCopies;
               }

               if (!PrintEMFSingleCopy(hSpoolHandle,
                                       hPrinterDC,
                                       bReverseOrderPrinting,
                                       dwDrvNumberOfPagesPerSide,
                                       dwNumberOfPagesPerSide,
                                       dwTotalNumberOfPages,
                                       dwNupBorderFlags,
                                       dwJobNumberOfCopies,
                                       dwDrvNumberOfCopies,
                                       bCollate,
                                       bOdd,
                                       bBookletPrint,
                                       dwOptimization,
                                       dwDuplexMode,
                                       pCopyDM,
                                       pHead,
                                       pData)) {
                   goto CleanUp;
               }
            }

        } else {

           if (!PrintEMFSingleCopy(hSpoolHandle,
                                   hPrinterDC,
                                   bReverseOrderPrinting,
                                   dwDrvNumberOfPagesPerSide,
                                   dwNumberOfPagesPerSide,
                                   dwTotalNumberOfPages,
                                   dwNupBorderFlags,
                                   dwJobNumberOfCopies,
                                   dwDrvNumberOfCopies,
                                   bCollate,
                                   bOdd,
                                   bBookletPrint,
                                   dwOptimization,
                                   dwDuplexMode,
                                   pCopyDM,
                                   pHead,
                                   pData)) {

               goto CleanUp;
           }
        }

        bStartDoc = FALSE;
        if (!GdiEndDocEMF(hSpoolHandle)) goto CleanUp;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("PrintEMFSingleCopy gave an exception\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
        goto CleanUp;
    }

    bReturn = TRUE;
    
CleanUp:

    //
    // Preserve the last error
    //
    LastError = bReturn ? ERROR_SUCCESS : GetLastError();
    
    if (bStartDoc) {
       GdiEndDocEMF(hSpoolHandle);
    }

    if (bSetWorldXform && hPrinterDC) {
       SetWorldTransform(hPrinterDC, &OldXForm);
    }

    while (pTemp = pHead) {
       pHead = pHead->pNext;
       FreeSplMem(pTemp);
    }

    if (pDevmode) {
       FreeSplMem(pDevmode);
    }

    try {
        if (hSpoolHandle) {
           GdiDeleteSpoolFileHandle(hSpoolHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ODS(("GdiDeleteSpoolFileHandle failed\nPrinter %ws\nDocument %ws\nJobID %u\n", pData->pDevmode->dmDeviceName, pData->pDocument, pData->JobId));
    }

    SetLastError(LastError);
    
    return bReturn;
}

/*++
Function Name
    GdiGetDevmodeForPagePvt

Function Description.
    In some cases, GDI's GdiGetDevmodeForPage returns a devmode
    that is based on an old format of devmode. e.g. Win3.1 format. The size of such a devmode
    can be smaller than the latest Devmode. This can lead to unpredictable issues.
    Also, sometimes the devmode returned is even smaller than Win3.1 format (due to possible
    corruption).
    This function is a wrapper around GDI's GdiGetDevmodeForPage and partially takes care of this
    situation by doing an extra checking for devmode.

Parameters:
            hSpoolHandle           -- the handle to the spool file
            dwPageNumber           -- the devmode related to this page number is requested.
            ppCurrDM               -- the devmode for the dwPageNumber is placed here.
            ppLastDM               -- devmode for dwPageNumber-1 is placed here. Can be NULL. (if n
ot NULL)

Return Values:  TRUE if a valid devmode was obtained from GDI
                FALSE otherwise
--*/

BOOL GdiGetDevmodeForPagePvt(
    IN  HANDLE              hSpoolHandle,
    IN  DWORD               dwPageNumber,
    OUT PDEVMODEW           *ppCurrDM,
    OUT PDEVMODEW           *ppLastDM
  )
{


    if ( NULL == ppCurrDM )
    {
        return FALSE;
    }

    *ppCurrDM = NULL;

    if ( ppLastDM )
    {
        *ppLastDM = NULL;
    }

    if (!GdiGetDevmodeForPage(hSpoolHandle,
                              dwPageNumber,
                              ppCurrDM,
                              ppLastDM) )
    {
        ODS(("GdiGetDevmodeForPage failed\n"));
        return FALSE;
    }
    //
    // If GdiGetDevmodeForPage has succeeded, then *ppCurrDM should have valid values
    // Also if ppLastDM is not NULL, then *ppLastDM should also have valid values.
    //
    // GDI guarantees that the size of the devmode is atleast dmSize+dmDriverExtra.
    // So we dont need to check for that. But we still need to check some other dependencies
    //
    //

    if ( NULL  == *ppCurrDM ||
         FALSE == BIsDevmodeOfLeastAcceptableSize (*ppCurrDM)
       )
    {
        return FALSE;
    }

    // 
    // It is possible for GdiGetDevmodeForPage to return TRUE (i.e. success)
    // but still not fill in the *ppLastDM. So NULL *ppLastDM is not an error
    // 

    if ( ppLastDM && *ppLastDM &&
         FALSE == BIsDevmodeOfLeastAcceptableSize (*ppLastDM)
       )
    {
        // @@BEGIN_DDKSPLIT
        // We could either ignore the error, set *ppLastDM to NULL and return TRUE
        // or we could fail the call. I think failing the call is better.

        SPLASSERT(FALSE); 
        // skupec - moved HSPLIT token since SPLASSERT() isn't defined in the DDK.
        // @@END_DDKSPLIT

        return FALSE;
    }

    return TRUE;
}


/*++
Function Name
    BIsDevmodeOfLeastAcceptableSize

Function Description.
// @@BEGIN_DDKSPLIT
    Though ideally we should be checking that pdevmode is so big that atleast we can access till
    dmLogPixels(which is the last DEVMODE field), without AVing,
    but due to backward compatibility issues I can only check till dmYResolution.
    dmYResolution is the last field of pdevmode that is currently accessed in print proc
    without checking for its validity using dmFields.  (currently it is line 2519 in this file).

    dmCollate is also used, but that is beyond the limit of the
    Win3.1 devmode (Fields including and after dmCollate were not part of Win3.1 devmode).
    So if the incoming devmode is bigger than offsetof(dmYResolution) but less than dmCollate,
    it should be accepted. Then there is dmTTOption which is not really used. So lets just
    ignore it.

// @@END_DDKSPLIT
Parameters:
    pdm  -- the pointer to the devmode.

Return Values:  TRUE if devmode is of least acceptable size.
                FALSE otherwise
--*/

BOOL BIsDevmodeOfLeastAcceptableSize(
    IN PDEVMODE pdm)
{

    if ( NULL == pdm )
    {
        return FALSE;
    }

    if ( IS_DMSIZE_VALID((pdm),dmYResolution) )
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\local.h ===
/*++

Copyright (c) 1998-2003  Microsoft Corporation
All rights reserved

Module Name:

    local.h

// @@BEGIN_DDKSPLIT                  
Abstract:

    DDK version of local.h


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _LOCAL_H_
#define _LOCAL_H_

// @@BEGIN_DDKSPLIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
/*
// @@END_DDKSPLIT
typedef long NTSTATUS;
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

// @@BEGIN_DDKSPLIT

#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT

#include <winddiui.h>

typedef struct _pfnWinSpoolDrv {
    BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
    BOOL    (*pfnClosePrinter)(HANDLE);
    BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
    BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM, DWORD *);
    LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);
    HANDLE  (*pfnLoadPrinterDriver)(HANDLE);
    BOOL    (*pfnSetDefaultPrinter)(LPCWSTR);
    BOOL    (*pfnGetDefaultPrinter)(LPWSTR, LPDWORD);
    HANDLE  (*pfnRefCntLoadDriver)(LPWSTR, DWORD, DWORD, BOOL);
    BOOL    (*pfnRefCntUnloadDriver)(HANDLE, BOOL);
    BOOL    (*pfnForceUnloadDriver)(LPWSTR);
}   fnWinSpoolDrv, *pfnWinSpoolDrv;


BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv   pfnList
    );

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    );


#define LOG_ERROR   EVENTLOG_ERROR_TYPE

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);
LPVOID ReallocSplMem(   LPVOID pOldMem, 
                        DWORD cbOld, 
                        DWORD cbNew);


#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT
#endif // INTERNAL
// @@END_DDKSPLIT


//
//  DEBUGGING:
//

#if DBG


BOOL
DebugPrint(
    PCH pszFmt,
    ...
    );
  
//
// ODS - OutputDebugString 
//
#define ODS( MsgAndArgs )       \
    do {                        \
        DebugPrint  MsgAndArgs;   \
    } while(0)  

#else
//
// No debugging
//
#define ODS(x)
#endif             // DBG

// @@BEGIN_DDKSPLIT
//#endif             // INTERNAL
// @@END_DDKSPLIT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\msnull.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    MsNull.c

Abstract:

    Implements lanman's msnull type parsing for FFs.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include "winprint.h"
#include "msnull.h"

#define sgn(x) (((x)>0) ? 1:-1)

struct EscapeSequence EscapeStrings[] =

    {
        { "-",prdg_ActConstIgnore, 1},
        { "0",prdg_ActNull,0},
        { "1",prdg_ActNull,0},
        { "2",prdg_ActNull,0},
        { "3",prdg_ActConstIgnore, 1},
        { "4",prdg_ActNull,0},
        { "5",prdg_ActConstIgnore, 1},
        { "6",prdg_ActNull,0},
        { "7",prdg_ActNull,0},
        { ":",prdg_ActNull,0},
        { "=",prdg_ActNull,0},
        { "A",prdg_ActConstIgnore, 1},
        { "B",prdg_ActDelimited, '\0'},
        { "C\0",prdg_ActConstIgnore, 1},
        { "D",prdg_ActDelimited, '\0'},
        { "E",prdg_ActReset,0},
        { "F",prdg_ActNull,0},
        { "G",prdg_ActNull,0},
        { "H",prdg_ActNull,0},
        { "I",prdg_ActConstIgnore, 1},
        { "J",prdg_ActConstIgnore, 1},
        { "K",prdg_ActCountIgnore, 0},
        { "L",prdg_ActCountIgnore, 0},
        { "N",prdg_ActConstIgnore, 1},
        { "O",prdg_ActNull,0},
        { "P",prdg_ActConstIgnore, 1},
        { "Q",prdg_ActConstIgnore, 1},
        { "R",prdg_ActNull,0},
        { "S",prdg_ActConstIgnore, 1},
        { "T",prdg_ActNull,0},
        { "U",prdg_ActConstIgnore, 1},
        { "W",prdg_ActConstIgnore, 1},
        { "X",prdg_ActConstIgnore, 2},
        { "Y",prdg_ActCountIgnore, 0},
        { "Z",prdg_ActCountIgnore, 0},
        { "[@",prdg_ActCountIgnore, 0},
        { "[C",prdg_ActCountIgnore, 0},
        { "[F",prdg_ActCountIgnore, 0},
        { "[I",prdg_ActCountIgnore, 0},
        { "[S",prdg_ActCountIgnore, 0},
        { "[T",prdg_ActCountIgnore, 0},
        { "[\\",prdg_ActCountIgnore, 0},
        { "[g",prdg_ActCountIgnore, 0},
        { "\\",prdg_ActCountIgnore, 0},
        { "]",prdg_ActNull,0},
        { "^",prdg_ActNull,0},
        { "_",prdg_ActConstIgnore, 1},
        { "d",prdg_ActConstIgnore, 2},
        { "e",prdg_ActConstIgnore, 2},
        { "j",prdg_ActNull,0},
        { "n",prdg_ActNull,0},
        { "\x6f", prdg_ActFF, 0}
    };



VOID
CheckFormFeedStream(
    lpDCI           pDCIData,
    unsigned char   inch)

/**********************************************************************/
/*                                                                    */
/*   FUNCTION: prdg_ParseRawData                                      */
/*                                                                    */
/*   PARAMETERS:                                                      */
/*                                                                    */
/*   lpDCI           pDCIData;  Pointer to DC instance data           */
/*   unsigned char   inch;     The next byte in data stream           */
/*                                                                    */
/*   DESCRIPTION:                                                     */
/*                                                                    */
/*   This function parses the stream of raw data which is being       */
/*   passed to the printer so that the driver can handle form feeds   */
/*   correctly.  The function must follow all the escape sequences    */
/*   which occur in the sequence of raw data.                         */
/*                                                                    */
/*   CHANGES:                                                         */
/*                                                                    */
/*   This function is table driven (from the table in in the ddata    */
/*   module) so it should hopefully only require this to be changed   */
/*   to reflect the escape sequences for a different printer.  If     */
/*   however there are escape sequneces which don't fall into the     */
/*   categories this parser can handle then extra code will have      */
/*   to be written to handle them.  The parser can handle escape      */
/*   sequences with any number of unique identifying characters       */
/*   possibly followed by: a count then the number of charcters given */
/*   in the count; a fixed number of characters; a stream of          */
/*   characters followed by a delimeter.                              */
/*                                                                    */
/**********************************************************************/

{
    /******************************************************************/
    /* Local Variables                                                */
    /******************************************************************/
    INT                    Direction;   /* Variables used in the      */
    UINT                   HiIndex;     /* binary chop routine for    */
    UINT                   LoIndex;     /* searching for a matching   */
    UINT                   Index;       /* escape sequence            */
    UINT                   PrevIndex;
    char *                 optr;        /* Pointers to access the     */
    char *                 nptr;        /* escape sequence strings    */
    struct EscapeSequence *NewSequence; /* Pointer to an escape       */
                                        /* sequence                   */

    /******************************************************************/
    /* Process the input character through the parsing function.      */
    /* Switch depending on which state we are currently in.  One of   */
    /* prdg_Text, prdg_ESC_match, prdg_ESC_n_ignore, prdg_ESC_d_ignore*/
    /* prdg_ESC_read_lo_count, prdg_ESC_read_hi_count.                */
    /******************************************************************/
    switch (pDCIData->ParserState)
    {
        case prdg_Text:
            /**********************************************************/
            /* Text state. Usual state, handled in line by a macro.   */
            /* The code is included here for completeness only.       */
            /* The FFaction (Form Feed action) state is maintained -  */
            /* if the character is text (ie >= 0x20) then set it to   */
            /* prdg_FFstate, if the character is a FF then set it to  */
            /* prdg_FFx0c.  If the input character is an escape then  */
            /* start up the sequence matching mode.                   */
            /**********************************************************/
            if (inch >= 0x20)
                pDCIData->FFstate = prdg_FFtext;

            else if (inch == 0x0c)
                pDCIData->FFstate = prdg_FFx0c;

            else if (inch == 0x1b)
            {
                /******************************************************/
                /* The character is an escape so set ParserState and  */
                /* indicate we have not matched a sequence yet by     */
                /* setting ParserSequence to NULL.                    */
                /******************************************************/
                pDCIData->ParserState = prdg_ESC_match;
                pDCIData->ParserSequence = NULL;
            }

            break;

        case prdg_ESC_match:
            /**********************************************************/
            /* Matching an escape sequence so try to match a new      */
            /* character.                                             */
            /**********************************************************/
            if (!pDCIData->ParserSequence)
            {
                /******************************************************/
                /* ParserSequence is NULL indicating that this is the */
                /* first character of an escape sequence so use a     */
                /* binary chop to get to the correct area of the      */
                /* table of escape sequences (based on the first      */
                /* character of the escape sequence which is the      */
                /* cuurent input character).                          */
                /******************************************************/
                HiIndex = MaxEscapeStrings;
                LoIndex = 0;
                Index = (LoIndex + HiIndex)/2;
                PrevIndex = MaxEscapeStrings;

                /******************************************************/
                /* while inch does not match the first character of   */
                /* the sequence indicated by Index move up or down    */
                /* the table depending on whether inch is < or > the  */
                /* first character of the escape sequence at Index.   */
                /******************************************************/
                while (Direction =
                               (inch - *EscapeStrings[Index].ESCString))
                {
                    if (Direction > 0)
                    {
                        LoIndex = Index;
                    }
                    else
                    {
                        HiIndex = Index;
                    };
                    PrevIndex = Index;
                    if (PrevIndex == (Index = (LoIndex + HiIndex)/2))
                    {
                        /**********************************************/
                        /* There is no escape sequence with a first   */
                        /* character matching the current input       */
                        /* character so resume text mode.             */
                        /**********************************************/
                        pDCIData->ParserState = prdg_Text;
                        return;
                    }

                }
                /*.. while (Direction = ...no match yet...............*/

                /******************************************************/
                /* Set up the ParserSequence and ParserString for the */
                /* first match found.                                 */
                /******************************************************/
                pDCIData->ParserSequence = &EscapeStrings[Index];
                pDCIData->ParserString = EscapeStrings[Index].ESCString;
            };
            /*.. if (!pDCIData->ParserSequence) .......................*/

            /**********************************************************/
            /* Loop forever trying to match escape sequences.         */
            /* First, try the new character against the current       */
            /* escape sequence and if it matches then check if it is  */
            /* the end of the sequence and if it is switch to the     */
            /* appropriate matching mode.  If the new character does  */
            /* not match try the next escape sequence (in either      */
            /* ascending or descending order depending on whether the */
            /* current character was < or > the character we were     */
            /* trying to match it to).  If the new sequence we are    */
            /* trying to match against does not exist (ie we are at   */
            /* one end of the table) or it does not match upto (but   */
            /* not including) the position we are currently at then   */
            /* the escape sequence in the raw data we are trying to   */
            /* match is invalid so revert to prdg_Text mode.  If it   */
            /* does match upto (but not including) the position we    */
            /* are currently trying to match then go back to try and  */
            /* match.                                                 */
            /**********************************************************/
            for (Direction = sgn(inch - *pDCIData->ParserString);;)
            {
                /******************************************************/
                /* Partway along a sequence, try the new character and*/
                /* if it matches then check for end of string.        */
                /******************************************************/
                if (!(inch - *pDCIData->ParserString))
                {
                    if (*++pDCIData->ParserString != '\0')
                        /**********************************************/
                        /* Escape sequence not finished yet so return */
                        /* and wait for the next character.  Note that*/
                        /* this is where the pointer to the position  */
                        /* in the escape sequence we are checking is  */
                        /* updated.                                   */
                        /**********************************************/
                        return;
                    else
                        /**********************************************/
                        /* The escape sequence has matched till the   */
                        /* end so break to the next section which will*/
                        /* take the appropriate action.               */
                        /**********************************************/
                        break;
                }
                /*.. if (!(inch - *pDCIData->ParserString)) ...match...*/

                else
                {
                    /**************************************************/
                    /* The current sequence does not match so we must */
                    /* try another sequence.  Direction determines    */
                    /* which way in the table we should go.           */
                    /**************************************************/
                    NewSequence = pDCIData->ParserSequence + Direction;

                    if (NewSequence < EscapeStrings ||
                        NewSequence> &EscapeStrings[MaxEscapeStrings-1])
                    {
                        /**********************************************/
                        /* The new sequence is beyond one end of the  */
                        /* table so revert to prdg_Text mode because  */
                        /* we will not be able to find a match.       */
                        /**********************************************/
                        pDCIData->ParserState = prdg_Text;
                        return;
                    }

                    /**************************************************/
                    /* Check that all the characters in the new       */
                    /* escape sequence upto (but not including) the   */
                    /* current one match the old escape sequence      */
                    /* (because those characters from the old escape  */
                    /* sequence have already been matched to the      */
                    /* raw data).                                     */
                    /**************************************************/
                    for (optr=pDCIData->ParserSequence->ESCString,
                         nptr=NewSequence->ESCString;
                         optr<pDCIData->ParserString; ++optr,++nptr)

                         if (*nptr != *optr)
                         {
                             /*****************************************/
                             /* If the new sequence does not match the*/
                             /* old then a match is not possible so   */
                             /* return.                               */
                             /*****************************************/
                             pDCIData->ParserState = prdg_Text;
                             return;
                         }

                    /**************************************************/
                    /* The new sequence is correct upto the character */
                    /* before the current character so loop back and  */
                    /* check the current character.                   */
                    /**************************************************/
                    pDCIData->ParserSequence = NewSequence;
                    pDCIData->ParserString = nptr;


                }
                /*.. else ! (!(inch - *pDCIData->ParserString.no match.*/

            }
            /*.. for ( ... ;;) ....for ever...........................*/

            /**********************************************************/
            /* The escape sequence has been matched from our table of */
            /* escape sequences so take the appropriate action for    */
            /* the particular sequence.                               */
            /**********************************************************/
            switch (pDCIData->ParserSequence->ESCAction)
            {
                case prdg_ActNull:
                    /**************************************************/
                    /* No further action so revert to prdg_Text mode  */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    break;

                case prdg_ActDelimited:
                    /**************************************************/
                    /* Ignore subsequent characters upto a specified  */
                    /* delimeter.                                     */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_d_ignore;
                    pDCIData->ParserDelimiter =
                               (char)pDCIData->ParserSequence->ESCValue;
                    break;

                case prdg_ActConstIgnore:
                    /**************************************************/
                    /* Ignore a specified number of characters.       */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_n_ignore;
                    pDCIData->ParserCount =
                                      pDCIData->ParserSequence->ESCValue;
                    break;

                case prdg_ActCountIgnore:
                    /**************************************************/
                    /* A two byte count follows so prepare to read it */
                    /* in.                                            */
                    /**************************************************/
                    pDCIData->ParserState = prdg_ESC_read_lo_count;
                    break;

                case prdg_ActFF:
                    /**************************************************/
                    /* A special action for recognising the 0x1b6f    */
                    /* "No Formfeed" sequence                         */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    pDCIData->FFstate = prdg_FFx1b6f;
                    break;

                case prdg_ActReset:
                    /**************************************************/
                    /* On Esc-E (reset) don't eject a page if this is */
                    /* the last sequence in the stream.               */
                    /**************************************************/
                    pDCIData->ParserState = prdg_Text;
                    pDCIData->FFstate = prdg_FFx1b45;
                    break;
            }
            /*.. switch (pDCIData->ParserSequence->ESCAction) .........*/

            break;

        case prdg_ESC_n_ignore:
            /**********************************************************/
            /* Ignoring n characters. Decrement the count, move back  */
            /* to text state if all ignored.                          */
            /**********************************************************/
            if (!(--pDCIData->ParserCount))
                pDCIData->ParserState = prdg_Text;
            break;

        case prdg_ESC_d_ignore:
            /**********************************************************/
            /* Ignoring up to a delimiter. If this is it, then stop   */
            /* ignoring.                                              */
            /**********************************************************/
            if (inch == pDCIData->ParserDelimiter)
                pDCIData->ParserState = prdg_Text;
            break;

        case prdg_ESC_read_lo_count:
            /**********************************************************/
            /* Reading first byte of count. Save it, advance state.   */
            /**********************************************************/
            pDCIData->ParserCount = (UINT)inch;
            pDCIData->ParserState = prdg_ESC_read_hi_count;
            break;

        case prdg_ESC_read_hi_count:
            /**********************************************************/
            /* Reading second byte of count. Save it, move to ignore  */
            /* a specified number of characters if there are any.     */
            /**********************************************************/
            pDCIData->ParserCount += 256*(UINT)inch;
            if (pDCIData->ParserCount)
                pDCIData->ParserState = prdg_ESC_n_ignore;
            else
                pDCIData->ParserState = prdg_Text;
            break;

    };
    /*.. switch (pDCIData->ParserState) ...............................*/

    return;
}


BOOL
CheckFormFeed(
    lpDCI pDCIData)
{
    if (pDCIData->FFstate != prdg_FFx1b6f &&
        pDCIData->FFstate != prdg_FFx1b45) {

        if (pDCIData->uType == PRINTPROCESSOR_TYPE_RAW_FF ||
            (pDCIData->uType == PRINTPROCESSOR_TYPE_RAW_FF_AUTO &&
                pDCIData->FFstate == prdg_FFtext)) {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\local.c ===
/*++

Copyright (c) 1999-2003  Microsoft Corporation
All rights reserved

Module Name:

    local.c

// @@BEGIN_DDKSPLIT                  
Abstract:

    Implementation of debug functions

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/


#if DBG

#include "local.h"
#include <stdarg.h>
#include <stdio.h>



/*++

Title:

    vsntprintf

Routine Description:

    Formats a string and returns a heap allocated string with the
    formated data.  This routine can be used to for extremely
    long format strings.  Note:  If a valid pointer is returned
    the callng functions must release the data with a call to delete.
    

Arguments:

    psFmt - format string
    pArgs - pointer to a argument list.

Return Value:

    Pointer to formated string.  NULL if error.

--*/
LPSTR
vsntprintf(
    IN LPCSTR      szFmt,
    IN va_list     pArgs
    )
{
    LPSTR  pszBuff;
    UINT   uSize   = 256;

    for( ; ; )
    {
        pszBuff = AllocSplMem(sizeof(char) * uSize);

        if (!pszBuff)
        {
            break;
        }

        //
        // Attempt to format the string.  If format succeeds, get out
        // of the loop. If it fails, increase buffer size and continue.
        // (assuming failure is due to less buffer size).
        //
        if (SUCCEEDED ( StringCchVPrintfA(pszBuff, uSize, szFmt, pArgs) ) )
        {
            break;
        }
        
        FreeSplMem(pszBuff);

        pszBuff = NULL;

        //
        // Double the buffer size after each failure.
        //
        uSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (uSize > 100*1024)
        {
            break;
        }
    }
    return pszBuff;
}



/*++

Title:

    DbgPrint

Routine Description:

    Format the string similar to sprintf and output it in the debugger.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    0

--*/
BOOL
DebugPrint(
    PCH pszFmt,
    ...
    )
{
    LPSTR pszString = NULL;
    BOOL  bReturn;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    pszString = vsntprintf( pszFmt, pArgs );

    bReturn = !!pszString;

    va_end( pArgs );

    if (pszString) 
    {
        OutputDebugStringA(pszString);
        
        FreeSplMem(pszString);
    }
    return bReturn;
}


// @@BEGIN_DDKSPLIT
#ifdef NEVER

VOID
vTest(
    IN LPTSTR pPrinterName,
    IN LPTSTR pDocName
    )
{
    WCHAR buf[250];
    UINT  i;

    ODS(("Printer %ws\nDocument %ws\n\n", pPrinterName, pDocName));
    ODS(("Some numbers: %u %u %u %u %u %u %u \n\n", 1, 2, 3, 4, 5, 6 ,7));
    
    for (i=0;i<250;i++) 
    {
        buf[i] = i%40 + 40 ;
    }
    ODS(("The string %ws \n\n", buf));
}

#endif //NEVER
// @@END_DDKSPLIT

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\parsparm.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\formfeed.c
// @@END_DDKSPLIT

Abstract:

    Table and routine to send formfeed to a printer.

// @@BEGIN_DDKSPLIT
Author:

    Tommy Evans (vtommye) 10-21-1993

Revision History:
// @@END_DDKSPLIT
--*/
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>

#include "winprint.h"

/** Constants for our various states **/

#define ST_KEY      0x01        /** Looking for a key **/
#define ST_VALUE    0x02        /** Looking for a value **/
#define ST_EQUAL    0x04        /** Looking for an = sign **/
#define ST_EQNODATA 0x08        /** Looking for equal w/ no data **/
#define ST_DELIM    0x10        /** Looking for a ; **/
#define ST_DMNODATA 0x20        /** Looking for a ; w/ no data **/


/*++
*******************************************************************
    G e t K e y V a l u e

    Routine Description:
        Returns the value for a given key in the given
        parameter string.  The key/values are in the order of
        KEY = VALUE;.  The spaces are optional, the ';' is
        required and MUST be present, directly after the value.
        If the call fails, the return length will be 0 and the
        return code will give the error.  This routine is written
        as a state machine, driven by the current character. 

    Arguments:
        pParmString => Parameter string to parse
        pKeyName    => Key to search for
        ValueType   =  type of value to return, string or ULONG
        pDestLength => length of dest buffer on enter,
                       new length on exit.
        pDestBuffer => area to store the key value

    Return Value:
        0 if okay
        error if failed (from winerror.h)
*******************************************************************
--*/
USHORT
GetKeyValue(
    IN      PWCHAR  pParmString,
    IN      PWCHAR  pKeyName,
    IN      USHORT  ValueType,
    IN OUT  PUSHORT pDestLength,
    OUT     PVOID   pDestBuffer)
{
    PWCHAR  pKey, pVal, pValEnd = NULL;
    WCHAR   HoldChar;
    USHORT  State = ST_KEY;    /** Start looking for a key **/
    ULONG   length;

    /** If any of the pointers are bad, return error **/

    if ((pParmString == NULL) ||
        (pKeyName == NULL)    ||
        (pDestLength == NULL) ||
        (pDestBuffer == NULL)) {

        if (pDestLength) {
            *pDestLength = 0;
        }

        return ERROR_INVALID_PARAMETER;
    }

    /**
        If we are looking for a ULONG, make sure they passed
        in a big enough buffer.
    **/

    if (ValueType == VALUE_ULONG) {
        if (*pDestLength < sizeof(ULONG)) {
            *pDestLength = 0;
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
        
    while (pParmString && *pParmString) {

        /**
            Update our state, if necessary, depending on
            the current character.
        **/

        switch (*pParmString) {

        /**
            We got a white space.  If we were looking for an equal
            sign or delimiter, then note that we got a space.  If
            we run across more data, then we have an error.
        **/

        case (WCHAR)' ':
        case (WCHAR)'\t':

            /**
                If we were looking for an equal sign,
                check to see if this is the key they
                wanted.  If not, jump to the next key.
            **/

            if (State == ST_EQUAL) {
                if (_wcsnicmp(pKey, pKeyName, lstrlen(pKeyName))) {
                    if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                        pParmString++;
                    }
                    State = ST_KEY;
                    pValEnd = NULL;
                    break;
                }

                /** Looking for an equal sign with no more data **/

                State = ST_EQNODATA;
            }
            else if (State == ST_DELIM) {

                /** If this is the end of the value, remember it **/

                if (!pValEnd) {
                    pValEnd = pParmString;
                }

                /** Now looking for a delimiter with no more data **/

                State = ST_DMNODATA;
            }
            pParmString++;
            break;

        /**
            Found an equal sign.  If we were looking for one,
            then great - we will then be looking for a value.
            We will check to see if this is the key they wanted.
            Otherwise, this is an error and we will start over
            with the next key.
        **/

        case (WCHAR)'=':
            if (State == ST_EQUAL) {
                if (_wcsnicmp(pKey, pKeyName, lstrlen(pKeyName))) {

                    /** Error - go to next key **/

                    if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                        pParmString++;
                    }
                    State = ST_KEY;
                    pValEnd = NULL;
                    break;
                }
                pParmString++;
                State = ST_VALUE;
            }
            else {

                /** Error - go to next key **/

                if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                    pParmString++;
                }
                State = ST_KEY;
                pValEnd = NULL;
            }
            break;
        // @@BEGIN_DDKSPLIT
        /**
            Found a delimeter.  If this is what we were looking
            for, great - we have a complete key/value pair.
        **/
        // @@END_DDKSPLIT

        case (WCHAR)';':    
            if (State == ST_DELIM) {
                if (!pValEnd) {
                    pValEnd = pParmString;
                }
                if (ValueType == VALUE_ULONG) {
                    if (!iswdigit(*pVal)) {
                        if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                            pParmString++;
                        }
                        State = ST_KEY;
                        pValEnd = NULL;
                        break;
                    }
                    *(PULONG)pDestBuffer = wcstoul(pVal, NULL, 10);
                    return 0;
                }
                else if (ValueType == VALUE_STRING) {

                    /**
                        ASCIIZ the value to copy it out without
                        any trailing spaces.
                    **/

                    HoldChar = *pValEnd;
                    *pValEnd = (WCHAR)0;

                    /** Make sure the buffer is big enough **/

                    length = lstrlen(pVal);
                    if (*pDestLength < (length+1) * sizeof(WCHAR) ) {
                        *pDestLength = 0;
                        return ERROR_INSUFFICIENT_BUFFER;
                    }

                    /**
                        Copy the data, restore the character where
                        we ASCIIZ'd the string, set up the length
                        and return.
                    **/

                    StringCchCopy ( (LPWSTR)pDestBuffer, *pDestLength/sizeof(WCHAR), pVal);
                    *pValEnd = HoldChar;
                    *(PULONG)pDestLength = length;
                    return 0;
                }
            }
            else {

                /** We weren't looking for a delimiter - next key **/

                State = ST_KEY;
                pValEnd = NULL;
                pParmString++;
            }
            break;

        /**
            Found some data.  If we had hit a space,
            and were expecting a equal sign or delimiter,
            this is an error.
        **/

        default:
            if ((State == ST_EQNODATA) ||
                (State == ST_DMNODATA)) {
                if (pParmString = wcschr(pParmString, (WCHAR)';')) {
                    pParmString++;
                }
                State = ST_KEY;
                pValEnd = NULL;
                break;
            }
            else if (State == ST_KEY) {
                pKey = pParmString;
                State = ST_EQUAL;
            }
            else if (State == ST_VALUE) {
                pVal = pParmString;
                State = ST_DELIM;
            }
            pParmString++;
            break;
        } /* End switch */
    } /* While parms data */

    *pDestLength = 0;
    return ERROR_NO_DATA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\msnull.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    MsNull.c

Abstract:

    Implements lanman's msnull type parsing for FFs.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/


enum ParserAction

    {
        prdg_ActNull,
        prdg_ActDelimited,
        prdg_ActConstIgnore,
        prdg_ActCountIgnore,
        prdg_ActFF,
        prdg_ActReset
    };

enum FFstateType

    {
        prdg_FFtext,
        prdg_FFx0c,
        prdg_FFx1b6f,
        prdg_FFx1b45
    };

enum ParserStateType

    {
        prdg_Text,
        prdg_ESC_match,
        prdg_ESC_n_ignore,
        prdg_ESC_d_ignore,
        prdg_ESC_read_lo_count,
        prdg_ESC_read_hi_count
    };

typedef struct dci
    {
        enum ParserStateType ParserState;
        UINT            ParserCount;
        struct EscapeSequence *ParserSequence;
        CHAR           *ParserString;
        CHAR            ParserDelimiter;
        enum FFstateType FFstate;
        UINT uType;
    } DCI;

typedef DCI far *lpDCI;

struct EscapeSequence

    {
        CHAR             *ESCString;
        enum ParserAction ESCAction;
        UINT              ESCValue;
    };

#define MaxEscapeStrings (sizeof(EscapeStrings)/sizeof(struct EscapeSequence))


BOOL
CheckFormFeed(
    lpDCI pDCIData);

VOID
CheckFormFeedStream(
    lpDCI pDCIData,
    UCHAR   inch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\raw.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT

Module Name:

    windows\spooler\prtprocs\winprint\raw.c

// @@END_DDKSPLIT
Abstract:

    Routines to facilitate printing of raw jobs.

// @@BEGIN_DDKSPLIT
Author:

    Tommy Evans (vtommye) 10-22-1993

Revision History:
// @@END_DDKSPLIT
--*/
#include "local.h"

// @@BEGIN_DDKSPLIT
#include <winsplp.h>
// @@END_DDKSPLIT
#include <wchar.h>

// @@BEGIN_DDKSPLIT
#include "msnull.h"
// @@END_DDKSPLIT

BYTE abyFF[1] = { 0xc };


/*++
*******************************************************************
    P r i n t R a w J o b

    Routine Description:
        Prints out a job with RAW data type.

    Arguments:
        pData           => Print Processor data structure
        pPrinterName    => name of printer to print on

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError will return reason
*******************************************************************
--*/

BOOL
PrintRawJob(
    IN PPRINTPROCESSORDATA pData,
    IN LPWSTR pPrinterName,
    IN UINT uDataType)

{
    DOC_INFO_1  DocInfo;
    DWORD       Copies;
    DWORD       NoRead, NoWritten;
    DWORD       i;
    BOOL        rc;
    HANDLE      hPrinter;
    BYTE        *ReadBuffer = NULL;
    BOOL        bRet        = FALSE;
    BOOL        bStartDoc   = FALSE;
    // @@BEGIN_DDKSPLIT
    BOOL        bAddFF = FALSE;
    BOOL        bCheckFF;
    PBYTE       pByte;
    DCI         DCIData;
    // @@END_DDKSPLIT

    DocInfo.pDocName    = pData->pDocument;     /* Document name */
    DocInfo.pOutputFile = pData->pOutputFile;   /* Output file */
    DocInfo.pDatatype   = pData->pDatatype;     /* Document data type */

    /** Let the printer know we are starting a new document **/

    if (!StartDocPrinter(pData->hPrinter, 1, (LPBYTE)&DocInfo)) {
        goto Done;
    }

    bStartDoc = TRUE;

    // @@BEGIN_DDKSPLIT
    bCheckFF = (uDataType == PRINTPROCESSOR_TYPE_RAW_FF ||
                uDataType == PRINTPROCESSOR_TYPE_RAW_FF_AUTO);

    /** Setup the formfeed stuff **/

    if (bCheckFF) {

        DCIData.ParserState = prdg_Text;
        DCIData.ParserSequence = NULL;
        DCIData.FFstate = prdg_FFtext;
        DCIData.uType = uDataType;
    }
    // @@END_DDKSPLIT

    /** Allocate the read buffer, dynamically allocated to conserve stack space **/

    ReadBuffer = AllocSplMem(READ_BUFFER_SIZE);

    if (!ReadBuffer) {
        goto Done;
    }

    /** Print the data pData->Copies times **/

    Copies = pData->Copies;

    while (Copies--) {

        /**
            Open the printer.  If it fails, return.  This also sets up the
            pointer for the ReadPrinter calls.
        **/

        if (!OpenPrinter(pPrinterName, &hPrinter, NULL)) {   
            goto Done;
        }

        /**
            Loop, getting data and sending it to the printer.  This also
            takes care of pausing and cancelling print jobs by checking
            the processor's status flags while printing.
        **/

        while ((rc = ReadPrinter(hPrinter, ReadBuffer, READ_BUFFER_SIZE, &NoRead)) &&
               NoRead) {

            // @@BEGIN_DDKSPLIT
            if (bCheckFF) {

                for(i=0, pByte = ReadBuffer;
                    i< NoRead;
                    i++, pByte++) {

                    CheckFormFeedStream(&DCIData, *pByte);
                }
            }
            // @@END_DDKSPLIT

            /** If the print processor is paused, wait for it to be resumed **/

            if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                WaitForSingleObject(pData->semPaused, INFINITE);
            }

            /** If the job has been aborted, don't write anymore **/

            if (pData->fsStatus & PRINTPROCESSOR_ABORTED) {
                break;
            }

            /** Write the data to the printer **/

            WritePrinter(pData->hPrinter, ReadBuffer, NoRead, &NoWritten);
        }

        // @@BEGIN_DDKSPLIT
        /**
            If we are type _FF* then we may need to add a form feed.
        **/

        if (bCheckFF && CheckFormFeed(&DCIData)) {

            WritePrinter(pData->hPrinter, abyFF, sizeof(abyFF), &NoWritten);
        }
        // @@END_DDKSPLIT

        /**
            Close the printer - we open/close the printer for each
            copy so the data pointer will rewind.
        **/

        ClosePrinter(hPrinter);

    } /* While copies to print */

    bRet = TRUE;

Done:    
    
    /** Close the buffer we allocated **/

    if (ReadBuffer) {
        FreeSplMem(ReadBuffer);
    }
    
    /** Let the printer know that we are done printing **/

    if (bStartDoc) {
        EndDocPrinter(pData->hPrinter);
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\support.c ===
/*++
Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\support.c
// @@END_DDKSPLIT

Abstract:

    Support routines for WinPrint.

// @@BEGIN_DDKSPLIT
Revision History:
// @@END_DDKSPLIT
--*/

/*++
*******************************************************************
    G e t P r i n t e r I n f o

    Routine Description:
        This routine allocates the required memory for a
        PRINTER_INFO_? structure and retrieves the information
        from NT.  This returns a pointer to the structure, which
        must be freed by the calling routine.

    Arguments:
                hPrinter    HANDLE to the printer the job is in
                StructLevel The structure level to get
                pErrorCode   => field to place error, if one

    Return Value:
                PUCHAR => buffer where devmode info is if okay
                NULL if error - pErrorCode returns error
*******************************************************************
--*/

#include "local.h"

PUCHAR 
GetPrinterInfo(IN  HANDLE   hPrinter,
               IN  ULONG    StructLevel,
               OUT PULONG   pErrorCode)
{
    ULONG   reqbytes, alloc_size;
    PUCHAR  ptr_info;
    USHORT  retry = 2;

    alloc_size = BASE_PRINTER_BUFFER_SIZE;

    /** Allocate a buffer.  **/

    ptr_info = AllocSplMem(alloc_size);

    /** If the buffer isn't big enough, try once more **/

    while (retry--) {

        /** If the alloc / realloc failed, return error **/

        if (!ptr_info) {
            *pErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            return NULL;
        }

        /** Go get the printer information **/

        if (GetPrinter(
              hPrinter,
              StructLevel,
              (PUCHAR)ptr_info,
              alloc_size,
              &reqbytes) == TRUE) {

            /** Got the info - return it **/

            *pErrorCode = 0;
            return (PUCHAR)ptr_info;
        }

        /**
            GetPrinter failed - if not because of insufficient buffer, fail
            the call.  Otherwise, up our hint, re-allocate and try again.
        **/

        *pErrorCode = GetLastError();

        if (*pErrorCode != ERROR_INSUFFICIENT_BUFFER) {
            FreeSplMem(ptr_info);
            return NULL;
        }

        /**
            Reallocate the buffer and re-try (note that, because we
            allocated the buffer as LMEM_FIXED, the LMEM_MOVABLE does
            not return a movable allocation, it just allows realloc
            to return a different pointer.
        **/

        alloc_size = reqbytes + 10;
        ptr_info = ReallocSplMem(ptr_info, alloc_size, 0);

    } /* While re-trying */

    if (ptr_info) {
        FreeSplMem(ptr_info);
    }

    *pErrorCode = ERROR_NOT_ENOUGH_MEMORY;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\text.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\text.c

// @@END_DDKSPLIT
Abstract:

    Routines to facilitate printing of text jobs.

--*/

#include "local.h"

#define FLAG_CR_STATE         0x1
#define FLAG_TAB_STATE        0x2
#define FLAG_DBCS_SPLIT       0x8
#define FLAG_FF               0x10
#define FLAG_LF               0x20
#define FLAG_CR               0x40
#define FLAG_TRANSLATE_LF     0x80
#define FLAG_TRANSLATE_CR     0x100

const WCHAR gszNoTranslateCRLF[] = L"Winprint_TextNoTranslation";
const WCHAR gszNoTranslateCR[]   = L"Winprint_TextNoCRTranslation";
const WCHAR gszTransparency[]    = L"Transparency";

/** Prototypes for functions in this file **/

PBYTE
GetTabbedLineFromBuffer(
    IN      PBYTE   pSrcBuffer,
    IN      PBYTE   pSrcBufferEnd,
    IN      PBYTE   pDestBuffer,
    IN      ULONG   CharsPerLine,
    IN      ULONG   TabExpansionSize,
    IN      ULONG   Encoding,
    IN OUT  PULONG  pLength,
    IN OUT  PULONG  pTabBase,
    IN OUT  PDWORD  pfdwFlags
    );


/*++
*******************************************************************
    P r i n t T e x t J o b

    Routine Description:
        Prints a text data job.

    Arguments:
        pData           => Data structure for this job
        pDocumentName   => Name of this document

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError() will return reason.
*******************************************************************
--*/
BOOL
PrintTextJob(
    IN PPRINTPROCESSORDATA pData,
    IN LPWSTR pDocumentName)
{
    DOCINFO     DocInfo;
    LOGFONT     LogFont;
    CHARSETINFO CharSetInfo;
    HFONT       hOldFont, hFont;
    DWORD       Copies;
    BOOL        rc;
    DWORD       NoRead;
    DWORD       CurrentLine;
    DWORD       CurrentCol;
    HANDLE      hPrinter = NULL;
    BYTE        *ReadBufferStart = NULL;
    PBYTE       pLineBuffer = NULL;
    PBYTE       pReadBuffer = NULL;
    PBYTE       pReadBufferEnd = NULL;
    ULONG       CharHeight, CharWidth, CharsPerLine, LinesPerPage;
    ULONG       PageWidth, PageHeight;
    ULONG       Length, TabBase;
    BOOL        ReadAll;
    TEXTMETRIC  tm;
    DWORD       fdwFlags;
    DWORD       Encoding;
    DWORD       SplitSize;
    BOOL        ReturnValue = FALSE;
    BOOL        bAbortDoc   = FALSE;

    DWORD       dwNeeded;
    DWORD       dwNoTranslate = 0;
    DWORD       dwNoTranslateCR = 0;
    DWORD       dwTransparent = 0;
    INT         iBkMode;

    DocInfo.lpszDocName = pData->pDocument;  /* Document name */
    DocInfo.lpszOutput  = NULL;              /* Output file */
    DocInfo.lpszDatatype = NULL;             /* Datatype */
    DocInfo.cbSize = sizeof(DOCINFO);        /* Size of the structure */



    //
    // Go figure out the size of the form on the printer.  We do this
    // by calling GetTextMetrics, which gives us the font size of the
    // printer font, then getting the form size and calculating the
    // number of characters that will fit. In other cases we treat it as ANSI text.
    // Currently the codepage context is fixed to the system default codepage.
    //

    Encoding = GetACP();

    //
    // Create FIXED PITCH font and select
    //

    hOldFont = 0;
    ZeroMemory(&CharSetInfo, sizeof(CHARSETINFO));
    if (TranslateCharsetInfo((PDWORD)UIntToPtr(Encoding), &CharSetInfo, TCI_SRCCODEPAGE))
    {
        ZeroMemory(&LogFont, sizeof(LOGFONT));

        LogFont.lfWeight = 400;
        LogFont.lfCharSet = (BYTE)CharSetInfo.ciCharset;
        LogFont.lfPitchAndFamily = FIXED_PITCH;

        hFont = CreateFontIndirect(&LogFont);
        hOldFont = SelectObject(pData->hDC, hFont);
    }

    if (!GetTextMetrics(pData->hDC, &tm)) {
        // Essential text processing computation failed
        goto Done;
    }

    CharHeight = tm.tmHeight + tm.tmExternalLeading;
    CharWidth  = tm.tmAveCharWidth;

    if (!CharWidth || !CharHeight) {
        // Essential text processing computation failed
        goto Done;
    }

    //
    // Calculate most fittable characters' number to one line.
    //

    PageWidth = GetDeviceCaps(pData->hDC, DESKTOPHORZRES);
    PageHeight = GetDeviceCaps(pData->hDC, DESKTOPVERTRES);

    CharsPerLine = PageWidth / CharWidth;
    LinesPerPage = PageHeight / CharHeight;

    if (!CharsPerLine || !LinesPerPage) {
        // Essential text processing computation failed
        goto Done;
    }

    /** Allocate a buffer for one line of text **/

    pLineBuffer = AllocSplMem(CharsPerLine + 5);

    if (!pLineBuffer) {
        goto Done;
    }

    /** Let the printer know we are starting a new document **/

    if (!StartDoc(pData->hDC, (LPDOCINFO)&DocInfo)) {

        goto Done;
    }

    ReadBufferStart = AllocSplMem(READ_BUFFER_SIZE);

    if (!ReadBufferStart) {

        goto Done;
    }

    /** Print the data pData->Copies times **/

    Copies = pData->Copies;

    while (Copies--) {

        /**
            Loop, getting data and sending it to the printer.  This also
            takes care of pausing and cancelling print jobs by checking
            the processor's status flags while printing.  The way we do
            this is to read in some data from the printer.  We will then
            pull data, one tabbed line at a time from there and print
            it.  If the last bit of data in the buffer does not make up
            a whole line, we call GetTabbedLineFromBuffer() with a non-
            zero Length, which indicates that there are chars left
            from the previous read.
        **/

        TabBase = 0;
        Length = 0;
        fdwFlags = FLAG_TRANSLATE_CR | FLAG_TRANSLATE_LF;

        CurrentLine = 0;
        CurrentCol = 0;

        /**
            Open the printer.  If it fails, return.  This also sets up the
            pointer for the ReadPrinter calls.
        **/

        if (!OpenPrinter(pDocumentName, &hPrinter, NULL)) {

            hPrinter = NULL;
            bAbortDoc = TRUE;
            goto Done;
        }

        //
        // Call GetPrinterData to see if the queue wants no LF/CR processing.
        //
        if( GetPrinterData( hPrinter,
                            (LPWSTR)gszNoTranslateCRLF,
                            NULL,
                            (PBYTE)&dwNoTranslate,
                            sizeof( dwNoTranslate ),
                            &dwNeeded ) == ERROR_SUCCESS ){

            if( dwNoTranslate ){
                fdwFlags &= ~( FLAG_TRANSLATE_CR | FLAG_TRANSLATE_LF );
            }
        }

        //
        // Call GetPrinterData to see if the queue wants no CR processing.
        //
        if( GetPrinterData( hPrinter,
                            (LPWSTR)gszNoTranslateCR,
                            NULL,
                            (PBYTE)&dwNoTranslateCR,
                            sizeof( dwNoTranslateCR ),
                            &dwNeeded ) == ERROR_SUCCESS ){

            if( dwNoTranslateCR ){

                fdwFlags &= ~FLAG_TRANSLATE_CR;

                if( GetPrinterData( hPrinter,
                                (LPWSTR)gszTransparency,
                                NULL,
                                (PBYTE)&dwTransparent,
                                sizeof( dwTransparent ),
                                &dwNeeded ) == ERROR_SUCCESS ){

                    if( dwTransparent ){
                        iBkMode = SetBkMode( pData->hDC, TRANSPARENT );
                    }
                }
            }
        }

        if (StartPage(pData->hDC) == SP_ERROR) {

            bAbortDoc = TRUE;
            goto Done;
        }

        /** ReadAll indicates if we are on the last line of the file **/

        ReadAll = FALSE;

        /**
            This next do loop continues until we have read all of the
            data for the print job.
        **/

        do {

            if (fdwFlags & FLAG_DBCS_SPLIT) {
                SplitSize = (DWORD)(pReadBufferEnd - pReadBuffer);
                memcpy(ReadBufferStart, pReadBuffer, SplitSize);
                fdwFlags &= ~FLAG_DBCS_SPLIT;
            }
            else {
                SplitSize = 0;
            }

            rc = ReadPrinter(hPrinter,
                             (ReadBufferStart + SplitSize),
                             (READ_BUFFER_SIZE - SplitSize),
                             &NoRead);

            if (!rc || !NoRead) {

                ReadAll = TRUE;

            } else {

                /** Pick up a pointer to the end of the data **/

                pReadBuffer    = ReadBufferStart;
                pReadBufferEnd = ReadBufferStart + SplitSize + NoRead;
            }

            /**
                This loop will process all the data that we have
                just read from the printer.
            **/

            do {

                if (!ReadAll) {

                    /**
                        Length on entry holds the length of any
                        residual chars from the last line that we couldn't
                        print out because we ran out of characters on
                        the ReadPrinter buffer.
                    **/

                    pReadBuffer = GetTabbedLineFromBuffer(
                                      pReadBuffer,
                                      pReadBufferEnd,
                                      pLineBuffer,
                                      CharsPerLine - CurrentCol,
                                      pData->TabSize,
                                      Encoding,
                                      &Length,
                                      &TabBase,
                                      &fdwFlags );

                    /**

                        If pReadBuffer == NULL, then we have
                        exhausted the read buffer and we need to ReadPrinter
                        again and save the last line chars.  Length holds
                        the number of characters on this partial line,
                        so the next time we call ReadPrinter we will
                        pickup where we left off.

                        The only time we'll get residual chars is if:

                        1. The last line ends w/o ff/lf/cr ("Hello\EOF")
                           In this case we should TextOutA the last line
                           and then quit.

                           (In this case, don't break here; go ahead and
                           print, then we'll break out below in the do..while.)


                        2. The ReadPrinter last byte is in the middle of a line.
                           Here we should read the next chunk and add the
                           new characters at the end of the chars we just read.

                           (In this case, we should break and leave Length
                           as it is so we will read again and append to the
                           buffer, beginning at Length.)
                    **/

                    if (!pReadBuffer || (fdwFlags & FLAG_DBCS_SPLIT))
                        break;
                }


                /** If the print processor is paused, wait for it to be resumed **/

                if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {
                    WaitForSingleObject(pData->semPaused, INFINITE);
                }

                /** If the job has been aborted, clean up and leave **/

                if (pData->fsStatus & PRINTPROCESSOR_ABORTED) {

                    ReturnValue = TRUE;

                    bAbortDoc = TRUE;
                    goto Done;
                }

                /** Write the data to the printer **/

                /** Make sure Length is not zero  **/
                /** TextOut will fail if Length == 0 **/

                if (Length) {

                    /**
                        We may have a number of newlines pending, that
                        may push us to the next page (or even next-next
                        page).
                    **/

                    while (CurrentLine >= LinesPerPage) {

                        /**
                            We need a new page; always defer this to the
                            last second to prevent extra pages from coming out.
                        **/

                        if (EndPage(pData->hDC) == SP_ERROR ||
                            StartPage(pData->hDC) == SP_ERROR) {

                            bAbortDoc = TRUE;
                            goto Done;
                        }

                        CurrentLine -= LinesPerPage;
                    }

                    if (TextOutA(pData->hDC,
                                 CurrentCol * CharWidth,
                                 CurrentLine * CharHeight,
                                 pLineBuffer,
                                 Length) == FALSE) {

                        ODS(("TextOut() failed\n"));

                        bAbortDoc = TRUE;
                        goto Done;
                    }

                    CurrentCol += Length;
                }

                /**
                    Even if the length is zero, increment the line.
                    Should happen when the character is only 0x0D or 0x0A.
                **/

                if (fdwFlags & FLAG_CR) {
                    CurrentCol=0;
                    fdwFlags &= ~FLAG_CR;
                }

                if (fdwFlags & FLAG_LF) {
                    CurrentLine++;
                    fdwFlags &= ~FLAG_LF;
                }

                /**
                    We need a new page.  Set the current line to the
                    end of the page.  We could do a End/StartPage
                    sequence, but this may cause a blank page to get
                    ejected.

                    Note: this code will avoid printing out pages that
                    consist of formfeeds only (if you have a page with a
                    space in it, that counts as text).
                **/

                if (fdwFlags & FLAG_FF) {

                    CurrentLine = LinesPerPage;
                    CurrentCol = 0;
                    fdwFlags &= ~FLAG_FF;
                }

                /**
                    We have done the text out, so these characters have
                    been successfully printed.  Zero out Length
                    so these characters won't be printed again
                **/

                Length = 0;

                /**
                    We only terminate this loop if we run out of chars
                    or we run out of read buffer.
                **/

            } while (pReadBuffer && pReadBuffer != pReadBufferEnd);

            /** Keep going until we get the last line **/

        } while (!ReadAll);

        if (EndPage(pData->hDC) == SP_ERROR) {

            bAbortDoc = TRUE;
            goto Done;
        }

        /**
            Close the printer - we open/close the printer for each
            copy so the data pointer will rewind.
        **/

        ClosePrinter(hPrinter);
        hPrinter = NULL;

    } /* While copies to print */

    /** Let the printer know that we are done printing **/

    EndDoc(pData->hDC);

    ReturnValue = TRUE;

Done:

    if (dwTransparent)
        SetBkMode( pData->hDC, iBkMode  );

    if (hPrinter)
        ClosePrinter(hPrinter);

    if (bAbortDoc)
        AbortDoc(pData->hDC);

    if (pLineBuffer)
        FreeSplMem(pLineBuffer);

    if (hOldFont)
    {
        SelectObject(pData->hDC, hOldFont);
        DeleteObject(hFont);
    }

    if (ReadBufferStart) 
    {
        FreeSplMem(ReadBufferStart);
    }

    return ReturnValue;
}


/*++
*******************************************************************
    G e t T a b b e d L i n e F r o m B u f f e r

    Routine Description:
        This routine, given a buffer of text, will pull out a
        line of tab-expanded text.  This is used for tab
        expansion of text data jobs.

    Arguments:
        pSrcBuffer      => Start of source buffer.
        pSrcBufferEnd   => End of source buffer
        pDestBuffer     => Start of destination buffer
        CharsPerLine    => Number of characters on a line
        TabExpansionSize=> Number of spaces in a tab
        Encoding        => Code page
        pLength         => Length of chars from prev line, rets current
        pTabBase        => New 0 offset for tabbing
        pfdwFlags       => State

    Return Value:
        PBYTE => Place left off in the source buffer.  This should
                 be passed in on the next call.  If we ran out of
                 data in the source, this will be unchanged.
*******************************************************************
--*/

PBYTE
GetTabbedLineFromBuffer(
    IN      PBYTE   pSrcBuffer,
    IN      PBYTE   pSrcBufferEnd,
    IN      PBYTE   pDestBuffer,
    IN      ULONG   CharsPerLine,
    IN      ULONG   TabExpansionSize,
    IN      ULONG   Encoding,
    IN OUT  PULONG  pLength,
    IN OUT  PULONG  pTabBase,
    IN OUT  PDWORD  pfdwFlags
    )
{
    ULONG   current_pos;
    ULONG   expand, i;
    ULONG   TabBase = *pTabBase;
    ULONG   TabBaseLeft = TabExpansionSize-TabBase;
    PBYTE   pDestBufferEnd = pDestBuffer + CharsPerLine;

    /**
        If the tab pushed us past the end of the last line, then we need to
        add it back to the next one.
    **/

    if (TabBase && ( *pfdwFlags & FLAG_TAB_STATE )) {

        current_pos = 0;

        i=TabBase;

        while (i-- && (pDestBuffer < pDestBufferEnd)) {
            *pDestBuffer++ = ' ';
            current_pos++;
        }

        /**
            If we ran out of room again, return.  This means that
            the tab expansion size is greater than we can fit on
            one line.
        **/

        if (pDestBuffer >= pDestBufferEnd) {

            *pLength = current_pos;
            *pTabBase -= CharsPerLine;

            //
            // We need to move to the next line.
            //
            *pfdwFlags |= FLAG_LF | FLAG_CR;

            return pSrcBuffer;
        }
        *pfdwFlags &= ~FLAG_TAB_STATE;

    } else {

        /** We may have some chars from the previous ReadPrinter **/

        current_pos = *pLength;
        pDestBuffer += current_pos;
    }

    while (pSrcBuffer < pSrcBufferEnd) {

        /** Now process other chars **/

        switch (*pSrcBuffer) {

        case 0x0C:

            /** Found a FF.  Quit and indicate we need to start a new page **/

            *pTabBase = 0;
            *pfdwFlags |= FLAG_FF;
            *pfdwFlags &= ~FLAG_CR_STATE;

            pSrcBuffer++;

            break;

        case '\t':

            *pfdwFlags &= ~FLAG_CR_STATE;

            /**
                Handle TAB case.  If we are really out of buffer,
                then defer now so that the tab will be saved for
                the next line.
            **/

            if (pDestBuffer >= pDestBufferEnd) {
                goto ShiftTab;
            }

            pSrcBuffer++;

            /** Figure out how far to expand the tabs **/

            expand = TabExpansionSize -
                     (current_pos + TabBaseLeft) % TabExpansionSize;

            /** Expand the tabs **/

            for (i = 0; (i < expand) && (pDestBuffer < pDestBufferEnd); i++) {
                *pDestBuffer++ = ' ';
            }

            /**
                If we reached the end of our dest buffer,
                return and set the number of spaces we have left.
            **/

            if (pDestBuffer >= pDestBufferEnd) {

                *pfdwFlags |= FLAG_TAB_STATE;
                goto ShiftTab;
            }

            /** Update our position counter **/

            current_pos += expand;

            continue;

        case 0x0A:

            pSrcBuffer++;

            /** If the last char was a CR, ignore this guy **/

            if (*pfdwFlags & FLAG_CR_STATE) {

                *pfdwFlags &= ~FLAG_CR_STATE;

                //
                // We are translating CRLF, so if we saw a CR
                // immediately before this, then don't do anything.
                //
                continue;
            }

            if( *pfdwFlags & FLAG_TRANSLATE_LF ){

                //
                // If we are translating, then treat a LF as a CRLF pair.
                //
                *pfdwFlags |= FLAG_LF | FLAG_CR;

                /** Found a linefeed.  That's it for this line. **/

                *pTabBase = 0;

            } else {

                *pfdwFlags |= FLAG_LF;
            }

            break;

        case 0x0D:

            /** Found a carriage return.  That's it for this line. **/

            *pTabBase = 0;
            pSrcBuffer++;

            if (*pfdwFlags & FLAG_TRANSLATE_CR) {

                //
                // If we are translating CRLF, then make the newline
                // occur now.  This handles the case where we have a
                // CR all by itself.  Also set the CR flag so if there
                // happens to be a LF immediately after this, we don't
                // move down another line.
                //
                *pfdwFlags |= FLAG_CR_STATE | FLAG_LF | FLAG_CR;

            } else {

                *pfdwFlags |= FLAG_CR;
            }

            break;

        default:

            /** Not tab or carriage return, must be simply data **/

            *pfdwFlags &= ~FLAG_CR_STATE;

            //
            // We always check before we are adding a character
            // (instead of after) since we may be at the end of a line,
            // but we can still process chars like 0x0d 0x0a.
            // This happens in MS-DOS printscreen.
            //
            if (pDestBuffer >= pDestBufferEnd ||
                    (pDestBuffer + 1 >= pDestBufferEnd) &&
                    IsDBCSLeadByteEx(Encoding, *pSrcBuffer)) {

ShiftTab:
                //
                // We must shift the tab over since we are on the
                // same line.
                //
                *pTabBase = (*pTabBase + TabExpansionSize -
                            (CharsPerLine % TabExpansionSize))
                                % TabExpansionSize;

                *pfdwFlags |= FLAG_LF | FLAG_CR;

                break;
            }

            if (IsDBCSLeadByteEx(Encoding, *pSrcBuffer)) {

                // Check if we have trail byte also.

                if (pSrcBuffer + 1 >= pSrcBufferEnd) {
                    *pfdwFlags |= FLAG_DBCS_SPLIT;
                    break;
                }

                // Advance source pointer (for lead byte).

                *pDestBuffer++ = *pSrcBuffer++;
                current_pos++;
            }

            *pDestBuffer++ = *pSrcBuffer++;
            current_pos++;
            continue;
        }

        *pLength = current_pos;
        return pSrcBuffer;
    }

    /** We ran out of source buffer before getting to the EOL **/

    *pLength = current_pos;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\util.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

   util.c
// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

    NOTE: THIS IS FOR THE DDK ONLY! 

Revision History:
// @@END_DDKSPLIT

--*/

#include "local.h"

LPVOID
ReallocSplMem(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    LPVOID pNewMem;

    pNewMem=AllocSplMem(cbNew);

    if (pOldMem && pNewMem) {

        if (cbOld) {
            CopyMemory( pNewMem, pOldMem, min(cbNew, cbOld));
        }
        FreeSplMem(pOldMem);
    }
    return pNewMem;
}


LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}



LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\winprint.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

   winprint.h

// @@BEGIN_DDKSPLIT

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

// @@END_DDKSPLIT
--*/

// for driver related defines and typedefs
#include <winddiui.h>
#include <strsafe.h>

typedef struct _PRINTPROCESSORDATA {
    DWORD   signature;
    DWORD   cb;
    struct _PRINTPROCESSORDATA *pNext;
    DWORD   fsStatus;
    HANDLE  semPaused;
    DWORD   uDatatype;
    HANDLE  hPrinter;
    LPWSTR  pPrinterName;
    LPWSTR  pDocument;
    LPWSTR  pOutputFile;
    LPWSTR  pDatatype;
    LPWSTR  pParameters;
    DWORD   JobId;
    DWORD   Copies;         /** Number of copies to print **/
    DWORD   TabSize;
    HDC     hDC;
    DEVMODEW *pDevmode;
    LPWSTR  pPrinterNameFromOpenData;
} PRINTPROCESSORDATA, *PPRINTPROCESSORDATA;

#define PRINTPROCESSORDATA_SIGNATURE    0x5051  /* 'QP' is the signature value */

/* Define flags for fsStatus field */

#define PRINTPROCESSOR_ABORTED      0x0001
#define PRINTPROCESSOR_CLOSED       0x0004
#define PRINTPROCESSOR_PAUSED       0x0008

#define PRINTPROCESSOR_RESERVED     0xFFF8

/** Flags used for the GetKey routing **/

#define VALUE_STRING    0x01
#define VALUE_ULONG     0x02

/** Buffer sizes we'll use **/

#define READ_BUFFER_SIZE            0x10000
#define BASE_PRINTER_BUFFER_SIZE    2048

PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hPrintProcessor
);

/** Data types we support **/
// @@BEGIN_DDKSPLIT
#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_RAW_FF      1
#define PRINTPROCESSOR_TYPE_RAW_FF_AUTO 2
#define PRINTPROCESSOR_TYPE_EMF_40      3
#define PRINTPROCESSOR_TYPE_EMF_50_1    4
#define PRINTPROCESSOR_TYPE_EMF_50_2    5
#define PRINTPROCESSOR_TYPE_EMF_50_3    6
#define PRINTPROCESSOR_TYPE_TEXT        7

/** Data types we support for the DDK **/
#if 0
// @@END_DDKSPLIT
#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_EMF_50_1    1
#define PRINTPROCESSOR_TYPE_EMF_50_2    2
#define PRINTPROCESSOR_TYPE_EMF_50_3    3
#define PRINTPROCESSOR_TYPE_TEXT        4
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbglocal.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbglocal.h

Abstract:

    Header file for Spooler Subsystem Debugger Extensions

Author:

    Krishna Ganugapati (KrishnaG) 08-July-1992

Revision History:

--*/


// Macro Land
// Note: if you use any of these macros within your code, you must have the
// following variables present and set to the appropriate value
//
// HANDLE               hCurrentProcess
// PNTSD_GET_EXPRESSION EvalExpression
//
//

#define move(dst, src)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, &dst, sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movestruct(src, dst, type)\
try {\
    ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sizeof(type), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movemem(src, dst, sz)\
try {\
    if (!ReadProcessMemory(hCurrentProcess, (LPVOID)src, dst, sz, NULL)) { \
        ((PBYTE)(dst))[0] = 0; \
    } \
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define movestr(src, dst, sz)\
try {\
    if (!ReadProcessString(hCurrentProcess, (LPVOID)src, dst, sz, NULL)) { \
        ((PBYTE)(dst))[0] = 0; \
    } \
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return 0;\
}

#define GetAddress(dst, src)\
try {\
    dst = EvalExpression(src);\
} except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src);\
    return(0);\
}

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

#if DBG

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);

#else

#define SplInSem()
#define SplOutSem()

#endif

BOOL
DbgDumpIniPrintProc(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTPROC pIniPrintProc
);


BOOL
DbgDumpIniDriver(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIDRIVER  pIniDriver
);


BOOL
DbgDumpIniEnvironment(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIENVIRONMENT pIniEnvironment
);


BOOL
DbgDumpIniNetPrint(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PININETPRINT pIniNetPrint
);

BOOL
DbgDumpIniMonitor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIMONITOR pIniMonitor
);


BOOL
DbgDumpIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPORT pIniPort
);

BOOL
DbgDumpWIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWINIPORT pIniPort
);


BOOL
DbgDumpIniPrinter(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTER pIniPrinter
);

BOOL
DbgDumpIniForm(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIFORM pForm
);


BOOL
DbgDumpIniJob(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIJOB pIniJob
);

BOOL
DbgDumpProvidor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    LPPROVIDOR pProvidor
);

BOOL
DbgDumpSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSPOOL pSpool
);

BOOL
DbgDumpShadowFile(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE pShadowFile
);

BOOL
DbgDumpShadowFile2(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE_2 pShadowFile
);

VOID
WINAPIV
PrintData(
    PNTSD_OUTPUT_ROUTINE Print,
    LPSTR   TypeString,
    LPSTR   VarString,
    ...
);

BOOL
DbgDumpChange(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGE pChange
    );

BOOL
DumpDevMode(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress
    );

BOOL
DbgDumpSecurityDescriptor(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PISECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
DbgDumpSid(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID  SidAddress
    );

BOOL
DbgDumpAcl(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID  AclAddress
    );

VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String,
    size_t  cchString
    );

DWORD
EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print
    );

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
    );

BOOL
DbgDumpPrintHandle(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PPRINTHANDLE pPrintHandle
    );

BOOL
DbgDumpChange(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGE pChange
    );


BOOL
DbgDumpNotify(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PNOTIFY pNotify
    );


BOOL
DbgDumpChangeInfo(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PCHANGEINFO pChangeInfo
    );

BOOL
DbgDumpStructure(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pData
    );

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
    );

BOOL
DbgDumpLL(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pAddress,
    BOOL  bCountOn,
    DWORD dwCount,
    PVOID pNextAddress
    );

BOOL
DbgDumpPI2(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD   dwCount
    );

BOOL
DbgDumpPI0(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD dwCount
    );

BOOL
DbgDumpFI1(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD dwCount
    );

BOOL
DbgDumpPDEF(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR lpAddress,
    DWORD   dwCount
    );

BOOL
ReadProcessString(
    IN  HANDLE  hProcess,
    IN  LPCVOID lpBaseAddress,
    OUT LPVOID  lpBuffer,
    IN  SIZE_T  nSize,
    OUT SIZE_T  *lpNumberOfBytesRead
    );

BOOL
QuerySystemInformation(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbginit.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbginit.c

Abstract:

    This module initialization

Author:

    Dave Snipp (DaveSn) 15-Mar-1991
    Steve Kiraly (SteveKi) 28-Nov-2000

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

HANDLE hInst;

BOOL
DllMain(
    IN HANDLE  hModule,
    IN DWORD   dwReason,
    IN LPVOID  lpRes
    )
{
    BOOL bRetval = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        hInst = hModule;
        DisableThreadLibraryCalls(hInst);
        QuerySystemInformation();
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbgmain.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgmain.c

Abstract:

    This module provides all the Spooler Subsystem Debugger extensions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    Matthew Felton (MattFe) July 1994 Added flag decode and cleanup

--*/

#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"

#define     VERBOSE_ON      1
#define     VERBOSE_OFF     0


DWORD   dwGlobalAddress = 32;
DWORD   dwGlobalCount =  48;

BOOL help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    Print("Windows NT Spooler Subsystem - debugging extensions\n");
    Print("help - prints this list of debugging commands\n");
    Print("d  [addr]        - dumps a spooler structure at [addr]\n");
    Print("dc [addr]        - dumps a change structure at [addr]\n");
    Print("dci [addr]       - dumps a change info structure at [addr]\n");
    Print("ds               - dumps all INISPOOLER structures\n");
    Print("dp               - dumps all INIPRINTER structures pointed to by IniSpooler\n");
    Print("dmo              - dumps all INIMONITOR structures pointed to by IniSpooler\n");
    Print("de               - dumps all INIENVIRONMENT structures pointed to by IniSpooler\n");
    Print("dpo              - dumps all INIPORT structures pointed to by IniSpooler\n");
    Print("df               - dumps all INIFORM structures pointed to by IniSpooler\n");
    Print("dnp              - dumps all ININETPRINT structures pointed to by IniSpooler\n");
    Print("dd               - dumps all INIDRIVER structures pointed to by IniSpooler\n");
    Print("dpv              - dumps all PROVIDOR structures in the router\n");
    Print("dtp [c#]         - dumps all or first [c#] WIN32THREAD structures in the threadpool\n");
    Print("w32              - dumps all Win32Spl handles WSPOOL\n");
    Print("dll [c#] [addr]  - dumps all or [c#] structures (based on sig) at [addr]\n");
    Print("dsd [addr]       - dumps a security descriptor starting from [addr]\n");
    Print("ddev [addr]      - dumps a devmode structure starting from [addr]\n");
    Print("dam [addr]       - dumps a security access mask starting at [addr]\n");
    Print("ct [addr] [arg0] - creates a thread at addr with 1 parm: [argv0]\n");
    Print("dpi2 [c#] addr   - dumps 1 or [c#] PRINTER_INFO_2 structures\n");
    Print("dpi0 [c#] addr   - dumps 1 or [c#] PRINTER_INFO_STRESS structures\n");
    Print("dfi1 [c#] addr   - dumps 1 or [c#] FORMS_INFO_1 structures\n");
    Print("dpdef addr       - dumps PRINTER_DEFAULTS structure\n");
    Print("handle           - dumps ClientHandleCount\n");

    return(TRUE);

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL d(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        Print("Usage: d [address] - Dumps internal Spooler structure based on signature\n");

    } else {
        UINT_PTR address;
        address = EvalExpression(lpArgumentString);
        Print("%x ", address);
        if (!DbgDumpStructure(hCurrentProcess, Print, (UINT_PTR)address))
            return(0);
    }

    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dc(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    DbgDumpChange(hCurrentProcess, Print, (PCHANGE)Address);

    //
    // Add Command to the Command Queue
    //
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dci(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    CHANGEINFO  ChangeInfo;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        return(0);
    }

    movestruct(Address, &ChangeInfo, CHANGEINFO);
    DbgDumpChangeInfo(hCurrentProcess, Print, &ChangeInfo);

    // Add Command to the Command Queue
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



PWSPOOL
GetpFirstWSpool(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_SYMBOL GetSymbol;
    PNTSD_GET_EXPRESSION EvalExpression;
    ULONG_PTR dwAddrGlobal;
    PWSPOOL pWSpool;

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwAddrGlobal, "win32spl!pFirstWSpool");
    movestruct((PVOID)dwAddrGlobal,&pWSpool, PWSPOOL);
    return pWSpool;
}


BOOL w32(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 0;
    UINT_PTR  Address = 0;
    PWSPOOL pWSpool = NULL;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }


    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        pWSpool = GetpFirstWSpool( hCurrentProcess, lpExtensionApis, lpArgumentString );
        Address = (UINT_PTR)pWSpool;
    }

    dwGlobalCount = dwCount;

    if ( Address != 0 ) {

        if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
            return(0);

    } else {

        Print("There are NO Win32spl Handles\n");

    }

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

}





PINISPOOLER
GetLocalIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PINISPOOLER pIniSpooler;
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_SYMBOL GetSymbol;
    PNTSD_GET_EXPRESSION EvalExpression;
    ULONG_PTR dwAddrGlobal;

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwAddrGlobal, "localspl!pLocalIniSpooler");
    movestruct((PVOID)dwAddrGlobal,&pIniSpooler, PINISPOOLER);
    return pIniSpooler;
}




BOOL ds(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 0;
    UINT_PTR Address = 0;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }


    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        Address = (UINT_PTR)pIniSpooler;
    }

    dwGlobalCount = dwCount;

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

}

PWIN32THREAD
GetThreadPoolHead(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PVOID        pThreadPool = NULL;
    PWIN32THREAD pHead       = NULL;
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_SYMBOL GetSymbol;
    PNTSD_GET_EXPRESSION EvalExpression;
    ULONG_PTR dwAddrGlobal;

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwAddrGlobal, "win32spl!g_pThreadPool");
    movemem((PVOID)dwAddrGlobal, &pThreadPool, sizeof(PVOID));
    movemem(pThreadPool, &pHead, sizeof(PWIN32THREAD));
    return pHead;
}


BOOL dtp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    PWIN32THREAD pWin32Thread;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 0;
    UINT_PTR Address = 0;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }


    pWin32Thread = GetThreadPoolHead( hCurrentProcess, lpExtensionApis, lpArgumentString );
    Address = (UINT_PTR)pWin32Thread;
    
    dwGlobalCount = dwCount;

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

}

BOOL dll(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    Address = EvalExpression(lpArgumentString);

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        return(0);
    }

    // if we do have a count which is valid and > 0, call the incremental dump
    // otherwise call the dump all function.

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE: FALSE, dwCount, &dwGlobalAddress)) {
        return(0);
    }


    // Add Command to the Command Queue
    return  TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR  Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniPrinter;
    }

    dwGlobalCount = dwCount;

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    Print("dwGlobalAddress %.8x dwGlobalCount %d\n", dwGlobalAddress, dwGlobalCount);
    // Add Command to the Command Queue
    return TRUE;

}

BOOL de(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniEnvironment;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dd(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    INIENVIRONMENT IniEnvironment;
    PINIENVIRONMENT pIniEnvironment;
    INIVERSION IniVersion;
    PINIVERSION pIniVersion;
    UINT_PTR  Address = 0;
    WCHAR Buffer[MAX_PATH+1];


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
    movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

    for (pIniEnvironment = IniSpooler.pIniEnvironment;
         pIniEnvironment;
         pIniEnvironment = IniEnvironment.pNext) {

       movestruct((PVOID)pIniEnvironment,&IniEnvironment, INIENVIRONMENT);
       movemem(IniEnvironment.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
       (*Print)("\nEnvironment %ws\n", Buffer);

       for (pIniVersion = IniEnvironment.pIniVersion;
            pIniVersion;
            pIniVersion = IniVersion.pNext) {

          movestruct((PVOID)pIniVersion,&IniVersion, INIVERSION);
          movemem(IniVersion.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
          (*Print)("\nVersion %ws\n", Buffer);

          Address = (UINT_PTR)IniVersion.pIniDriver;

          if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, FALSE, 0, &dwGlobalAddress))
              return(0);
       }
    }

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}

BOOL dpo(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        PSHARED pShared;
        SHARED Shared;

        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniPort;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dmo(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {

        PSHARED pShared;
        SHARED Shared;

        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        Address = (UINT_PTR)IniSpooler.pIniMonitor;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL dnp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

        Address = (UINT_PTR)IniSpooler.pIniNetPrint;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);


    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}




BOOL df(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        PSHARED pShared;
        SHARED Shared;

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);
        movestruct( (PVOID)IniSpooler.pShared, &Shared, SHARED );
        Address = (UINT_PTR)Shared.pIniForm;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL dsp(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = (UINT_PTR)NULL;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        // Print("We have a Null address\n");

        pIniSpooler = GetLocalIniSpooler( hCurrentProcess, lpExtensionApis, lpArgumentString );
        movestruct((PVOID)pIniSpooler,&IniSpooler, INISPOOLER);

        Address = (UINT_PTR)IniSpooler.pSpool;
    }

    dwGlobalCount = dwCount;
    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);


    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL next(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    Address = dwGlobalAddress;    // Let's get the address to dump at
    dwCount = dwGlobalCount;        // and while we're at it, get the count

    Print("Next address: %.8x Count: %d\n", Address, dwCount);
    if (Address == 0) {
        Print("dump address = <null>; no more data to dump\n");
        return(FALSE);
    }

    if (!DbgDumpLL(hCurrentProcess, Print, (UINT_PTR)Address, dwCount? TRUE:FALSE, dwCount, &dwGlobalAddress))
        return(0);

    // Add Command to the Command Queue
    return (TRUE);

}

BOOL ct(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    DWORD   dwArg = 0;
    BOOL    bThereAreOptions = TRUE;
    UINT i = 0;
    HANDLE hThread;
    DWORD dwThreadId;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (*lpArgumentString) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (i) {
        case 0:

            Address = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        case 1:

            dwArg = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default:

            (*Print)("Usage: ct addr arg0");
            return FALSE;
       }
       i++;
    }

    hThread = CreateRemoteThread(hCurrentProcess,
                                 NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE)Address,
                                 (LPVOID)UIntToPtr(dwArg),
                                 0,
                                 &dwThreadId);

    if (hThread) {

        (*Print)("Thread id 0x%x at %x, arg0 %x created.\n",
                 dwThreadId, Address, dwArg);

        CloseHandle(hThread);
        return TRUE;
    }

    return FALSE;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}



BOOL dpi2(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi2 you need to supply an address\n");
        return TRUE;
    }

    if ( !DbgDumpPI2(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}




BOOL dpi0(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi0 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpPI0(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}









BOOL dfi1(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dfi1 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpFI1(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}






BOOL dpdef(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    INISPOOLER IniSpooler;
    PINISPOOLER pIniSpooler;
    UINT_PTR Address = 0;
    BOOL    bThereAreOptions = TRUE;
    DWORD   dwCount = 1;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (Address == 0) {
        Print("dpi0 you need to supply an address\n");
        return TRUE;
    }


    if ( !DbgDumpPDEF(hCurrentProcess, Print, (UINT_PTR)Address, dwCount ))
        return(0);

    // Add Command to the Command Queue
    return TRUE;

}


BOOL handle(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    ULONG_PTR dwAddrGlobal = 0;
    DWORD   HandleCount;


    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;


    GetAddress(dwAddrGlobal, "winspool!ClientHandleCount");

    if ( dwAddrGlobal != 0 ) {

        movestruct((PVOID)dwAddrGlobal, &HandleCount, DWORD);
        Print("ClientHandleCount %d\n", HandleCount);

    }


    GetAddress(dwAddrGlobal, "spoolss!ServerHandleCount");

    if ( dwAddrGlobal != 0 ) {

        movestruct((PVOID)dwAddrGlobal, &HandleCount, DWORD);
        Print("ServerHandleCount %d\n", HandleCount);

    }

    return TRUE;
}

BOOL dpv(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    ULONG_PTR dwGlobalAddress = 0;
    WCHAR Buffer[MAX_PATH+1];
    LPPROVIDOR  pLocalProvidor, pProvidor;
    PROVIDOR    Providor;


    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetAddress(dwGlobalAddress, "spoolss!pLocalProvidor");
    movestruct((PVOID)dwGlobalAddress, &pLocalProvidor, LPPROVIDOR);

    for (pProvidor = pLocalProvidor;
         pProvidor;
         pProvidor = Providor.pNext)
    {
        (*Print) ("Providor %x\n", pProvidor);
        movestruct((PVOID) pProvidor, &Providor, PROVIDOR);
        DbgDumpProvidor(hCurrentProcess, Print, &Providor);
    }

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbgsec.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgsec.h

Abstract:

    Header file for Spooler Subsystem Debugger Extensions

Author:

    Krishna Ganugapati (KrishnaG) 08-July-1992

Revision History:

--*/

//
// Object types
//

#define SPOOLER_OBJECT_SERVER   0
#define SPOOLER_OBJECT_PRINTER  1
#define SPOOLER_OBJECT_DOCUMENT 2
#define SPOOLER_OBJECT_COUNT    3

/* These access bits must be different from those exposed in winspool.h,
 * so that no auditing takes place when we do an access check against them:
 */
#define SERVER_ACCESS_ADMINISTER_PRIVATE    0x00000004
#define PRINTER_ACCESS_ADMINISTER_PRIVATE   0x00000008
#define JOB_ACCESS_ADMINISTER_PRIVATE       0x00000080

PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
);

PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
);

BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
);

BOOL
DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
);

BOOL
DeleteDocumentSecurity(
    PINIJOB pIniJob
);

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
);

BOOL
ValidateObjectAccess(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID      ObjectHandle
);

BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
);

VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
);

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
);

BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
);

ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
);

BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
);

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbgsec.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgspl.c

Abstract:

    This module provides all the Spooler Subsystem Debugger extensions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion routines)
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)

To do:

    Write a generic dump unicode string (reduce the code!!)

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"


#define NULL_TERMINATED 0
#define VERBOSE_ON      1
#define VERBOSE_OFF     0

#define         MAX_SDC_FLAGS           7

typedef struct _DBG_SED_CONTROL{
    unsigned short    Flag;
    LPSTR     String;
}DBG_SED_CONTROL, *PDBG_SED_CONTROL;

DBG_SED_CONTROL SDC_Table[] =

{
    0x0001, "SE_OWNER_DEFAULTED",

    0x0002, "SE_GROUP_DEFAULTED",

    0x0004, "SE_DACL_PRESENT",

    0x0008, "SE_DACL_DEFAULTED",

    0x0010, "SE_SACL_PRESENT",

    0x0020, "SE_SACL_DEFAULTED",

    0x8000, "SE_SELF_RELATIVE"

};

#define     MAX_ACE_FLAGS       6

typedef struct _DBG_ACE_FLAGS{
    UCHAR   Flags;
    LPSTR   String;
}DBG_ACE_FLAGS, *PDBG_ACE_FLAGS;


DBG_ACE_FLAGS AceFlagsTable[] =

{
    0x1, "OBJECT_INHERIT_ACE",

    0x2, "CONTAINER_INHERIT_ACE",

    0x4, "NO_PROPAGATE_INHERIT_ACE",

    0x8, "INHERIT_ONLY_ACE",

    0x40, "SUCCESSFUL_ACCESS_ACE_FLAG",

    0x80, "FAILED_ACCESS_ACE_FLAG"
};



typedef struct _ACCESSMASKTAB{
    DWORD   Flag;
    LPSTR   String;
}ACCESSMASKTAB, *PACCESSMASKTAB;


ACCESSMASKTAB AccessMaskTable[33] =

{
    0x00000001, "SERVER_ACCESS_ADMINSTER",

    0x00000002, "SERVER_ACCESS_ENUMERATE",

    0x00000004, "PRINTER_ACCESS_ADMINSTER",

    0x00000008, "PRINTER_ACCESS_USE",

    0x00000010, "JOB_ACCESS_ADMINISTER",

    0x00010000, "DELETE",

    0x00020000, "READ_CONTROL",

    0x00040000, "WRITE_DAC",

    0x00080000, "WRITE_OWNER",

    0x00100000, "SYNCHRONIZE",

    0x01000000, "ACCESS_SYSTEM_SECURITY",

    0x10000000, "GENERIC_ALL",

    0x20000000, "GENERIC_EXECUTE",

    0x40000000, "GENERIC_WRITE",

    0x80000000, "GENERIC_READ",

    0x0000FFFF, "SPECIFIC_RIGHTS_ALL",

    0x000F0000, "STANDARD_RIGHTS_REQUIRED <D-R/C-W/DAC-W/O>",

    0x001F0000, "STANDARD_RIGHTS_ALL  <D-R/C-W/DAC-W/O-S>",

    READ_CONTROL, "STANDARD_RIGHTS_READ <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_WRITE <R/C>",

    READ_CONTROL, "STANDARD_RIGHTS_EXECUTE <R/C>",

    SERVER_ALL_ACCESS, "SERVER_ALL_ACCESS <SRREQ-SAA-SAE>",

    SERVER_READ,    "SERVER_READ <SRR-SAE>",

    SERVER_WRITE, "SERVER_WRITE <SRW-SAA-SAE>",

    SERVER_EXECUTE, "SERVER_EXECUTE <SRE-SAE>",

    PRINTER_ALL_ACCESS, "PRINTER_ALL_ACCESS <SRREQ-PAA-PAU>",

    PRINTER_READ, "PRINTER_READ <SRR-PAU>",

    PRINTER_WRITE, "PRINTER_WRITE <SRW-PAU>",

    PRINTER_EXECUTE, "PRINTER_EXECUTE <SRE-PAU>",

    JOB_ALL_ACCESS, "JOB_ALL_ACCESS <SRREQ-JAA>",

    JOB_READ, "JOB_READ <SRR-JAA>",

    JOB_WRITE, "JOB_WRITE <SRW-JAA>",

    JOB_EXECUTE, "JOB_EXECUTE <SRE-JAA>"

};



BOOL
DbgDumpSecurityDescriptor(
            HANDLE hCurrentProcess,
            PNTSD_OUTPUT_ROUTINE Print,
            PISECURITY_DESCRIPTOR pSecurityDescriptor
            )
{
    BOOL    bSe_Self_Relative = FALSE;
    DWORD   i;
    UINT_PTR   OwnerSidAddress, GroupSidAddress;
    UINT_PTR   SaclAddress, DaclAddress;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    memset(&SecurityDescriptor, 0, sizeof(SECURITY_DESCRIPTOR));
    movestruct(pSecurityDescriptor, &SecurityDescriptor, SECURITY_DESCRIPTOR);

    (*Print)("SecurityDescriptor\n");

    bSe_Self_Relative = SecurityDescriptor.Control & SE_SELF_RELATIVE;
    if (bSe_Self_Relative) {
        (*Print)("This Security Descriptor is a Self-Relative Security Descriptor\n");
    }

    (*Print)("UCHAR         Revision        0x%x\n", SecurityDescriptor.Revision);
    (*Print)("UCHAR         Sbz1            0x%x\n", SecurityDescriptor.Sbz1);
    (*Print)("USHORT         Control        0x%x\n", SecurityDescriptor.Control);
    for (i = 0; i < MAX_SDC_FLAGS; i++ ) {
        if (SecurityDescriptor.Control & SDC_Table[i].Flag) {
            (*Print)("%s - ON  (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        } else {
            (*Print)("%s - OFF (%.4x)\n", SDC_Table[i].String, SDC_Table[i].Flag);
        }
    }

    //
    // Now dumping out the owner's sid
    //

    if (SecurityDescriptor.Owner == NULL) {
        (*Print)("PSID       Owner     null -- no owner sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID          Owner Offset   0x%.8x\n",SecurityDescriptor.Owner);
            OwnerSidAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Owner;
        }else {
            OwnerSidAddress = (UINT_PTR)SecurityDescriptor.Owner;
        }
        // (*Print)("PSID         Owner            0x%.8x\n", OwnerSidAddress);
    }
    (*Print)("The owner's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)OwnerSidAddress);
    (*Print)("\n\n");

    //
    // Now dumping out the group's sid

    if (SecurityDescriptor.Group == NULL) {
        (*Print)("PSID       Group    null -- no group sid present in the security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PSID      Group Offset    0x%.8x\n", SecurityDescriptor.Group);
            GroupSidAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Group;
        }else {
            GroupSidAddress = (UINT_PTR)SecurityDescriptor.Group;
        }
        // (*Print)("PSID         Group            0x%.8x\n", GroupSidAddress);
    }
    (*Print)("The group's sid is:\t\n");
    DbgDumpSid(hCurrentProcess, Print, (PVOID)GroupSidAddress);
    (*Print)("\n");



    if (SecurityDescriptor.Sacl == NULL) {
        (*Print)("PACL       Sacl    null -- no sacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Sacl Offset %.8x\n", SecurityDescriptor.Sacl);
            SaclAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Sacl;
        }else{
            SaclAddress = (UINT_PTR)SecurityDescriptor.Sacl;

        }
        // (*Print)("PACL         Sacl            0x%.8x\n", SaclAddress);
    }

    if (SecurityDescriptor.Dacl == NULL) {
        (*Print)("PACL      Dacl    null -- no dacl present in this security descriptor\n");
    }else {
        if (bSe_Self_Relative) {
            // (*Print)("PACL     Dacl Offset %.8x\n", SecurityDescriptor.Dacl);
            DaclAddress = (UINT_PTR)pSecurityDescriptor + (UINT_PTR)SecurityDescriptor.Dacl;
        }else {
            DaclAddress = (UINT_PTR)SecurityDescriptor.Dacl;
        }
        // (*Print)("PACL         Dacl            0x%.8x\n", DaclAddress);
        DbgDumpAcl(hCurrentProcess, Print,(PVOID)DaclAddress);
    }

    return TRUE;
}


BOOL
DbgDumpSid(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  SidAddress
           )
{
    BYTE    Sid[256];
    CHAR   SidString[256];
    SID_NAME_USE SidType = 1;

    // (*Print)("Size of a SID is %d\n", sizeof(SID));

    // movestruct(SidAddress, &Sid, SID);
    memset(Sid, 0,  sizeof(Sid));
    movemem(SidAddress, Sid, sizeof(Sid));
    ConvertSidToAsciiString(Sid, SidString, COUNTOF(SidString));
    (*Print)("PSID      %s\n", SidString);

    return TRUE;
}


BOOL
DbgDumpAceHeader(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PVOID   AceHeaderAddress
    )
{
   ACE_HEADER AceHeader;
   DWORD i = 0;

   memset(&AceHeader, 0, sizeof(ACE_HEADER));
   movestruct(AceHeaderAddress, &AceHeader, ACE_HEADER);
   (*Print)("UCHAR      AceType         %.2x\n", AceHeader.AceType);
   switch (AceHeader.AceType) {
   case ACCESS_ALLOWED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_ALLOWED_ACE_TYPE\n");
       break;
   case ACCESS_DENIED_ACE_TYPE:
       (*Print)("This is an ace of type: ACCESS_DENIED_ACE_TYPE\n");
       break;
   case SYSTEM_AUDIT_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_AUDIT_ACE_TYPE\n");
       break;

   case SYSTEM_ALARM_ACE_TYPE:
       (*Print)("This is an ace of type: SYSTEM_ALARM_ACE_TYPE\n");
       break;
   }
   (*Print)("UCHAR      AceFlags        %.2x\n", AceHeader.AceFlags);

   for (i = 0; i < MAX_ACE_FLAGS; i++ ) {
       if (AceFlagsTable[i].Flags & AceHeader.AceFlags) {
           (*Print)("%s - ON (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }else {
           (*Print)("%s - OFF (%d)\n", AceFlagsTable[i].String, AceFlagsTable[i].Flags);
       }
   }

   (*Print)("USHORT     AceSize         %d\n", AceHeader.AceSize);

    return TRUE;
}


BOOL
DbgDumpAcl(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     PVOID  AclAddress
           )
{
    ACL         Acl;
    PVOID       AceAddress;
    ACE_HEADER  AceHeader;
    ACCESS_ALLOWED_ACE AccessAllowedAce;
    ACCESS_DENIED_ACE  AccessDeniedAce;
    SYSTEM_AUDIT_ACE   SystemAuditAce;
    SYSTEM_ALARM_ACE   SystemAlarmAce;
    DWORD   i;
    UINT_PTR   SidAddress;

    // Pull the Acl across

    movestruct(AclAddress, &Acl, ACL);

    (*Print)("ACL\n");

    (*Print)("UCHAR     AclRevision     0x%x\n", Acl.AclRevision);
    (*Print)("UCHAR     Sbz1            0x%x\n", Acl.Sbz1);
    (*Print)("USHORT    AclSize         %d\n", Acl.AclSize);
    (*Print)("USHORT    AceCount        %d\n", Acl.AceCount);
    (*Print)("USHORT    Sz2             0x%x\n", Acl.Sbz2);

    AceAddress = (LPBYTE)AclAddress + sizeof(ACL);
    for (i = 0; i < Acl.AceCount; i++ ) {
        (*Print)("\nAce # %d: ",i);
        DbgDumpAceHeader(hCurrentProcess, Print, AceAddress);
        movestruct(AceAddress, &AceHeader, ACE_HEADER);

        switch (AceHeader.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            memset(&AccessAllowedAce, 0, sizeof(ACCESS_ALLOWED_ACE));
            movestruct(AceAddress, &AccessAllowedAce, ACCESS_ALLOWED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessAllowedAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            // (*Print)("The Address of the Sid is %.8x\n", SidAddress);
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            memset(&AccessDeniedAce, 0, sizeof(ACCESS_DENIED_ACE));
            movestruct(AceAddress, &AccessDeniedAce, ACCESS_DENIED_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", AccessDeniedAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            memset(&SystemAuditAce, 0, sizeof(SYSTEM_AUDIT_ACE));
            movestruct(AceAddress, &SystemAuditAce, SYSTEM_AUDIT_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAuditAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;

        case SYSTEM_ALARM_ACE_TYPE:
            memset(&SystemAlarmAce, 0, sizeof(SYSTEM_ALARM_ACE));
            movestruct(AceAddress, &SystemAlarmAce, SYSTEM_ALARM_ACE);
            (*Print)("ACCESSMASK AccessMask     %.8x\n", SystemAlarmAce.Mask);
            SidAddress = (UINT_PTR)((LPBYTE)AceAddress + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
            DbgDumpSid(hCurrentProcess, Print, (PVOID)SidAddress);
            break;
        }
        AceAddress = (PVOID)((UINT_PTR)AceAddress +  AceHeader.AceSize);
        (*Print)("\n");
    }

    return TRUE;
}


BOOL
dsd(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSecurityDescriptor(
                hCurrentProcess,
                Print,
                (PISECURITY_DESCRIPTOR)Address
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}


BOOL
dsid(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpSid(
          hCurrentProcess,
          Print,
          (PVOID)Address
          );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}




BOOL
ddev(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    UINT_PTR Address = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        Address = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (!Address) {
        Print("We have a Null address\n");
        return(0);
    }

    DumpDevMode(
                hCurrentProcess,
                Print,
                (UINT_PTR)Address
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}





BOOL
DbgDumpAccessMask(
     HANDLE hCurrentProcess,
     PNTSD_OUTPUT_ROUTINE Print,
     DWORD  AccessMask
           )
{
    DWORD i;
    for (i = 0; i < 33; i++) {
        if (AccessMask & AccessMaskTable[i].Flag) {
            (*Print)("%s\t\tON\n", AccessMaskTable[i].String);
        }else {
            (*Print)("%s\t\tOFF\n", AccessMaskTable[i].String);
        }
    }
    return TRUE;
}




BOOL
dam(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    UINT_PTR dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;
    DWORD   AccessMask = 0;
    DWORD   dwCount = 0;
    BOOL    bThereAreOptions = TRUE;

    UNREFERENCED_PARAMETER(hCurrentProcess);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    while (bThereAreOptions) {
        while (isspace(*lpArgumentString)) {
            lpArgumentString++;
        }

        switch (*lpArgumentString) {
        case 'c':
            lpArgumentString++;
            dwCount = EvalValue(&lpArgumentString, EvalExpression, Print);
            break;

        default: // go get the address because there's nothing else
            bThereAreOptions = FALSE;
            break;
       }
    }

    if (*lpArgumentString != 0) {
        AccessMask = EvalValue(&lpArgumentString, EvalExpression, Print);
    }

    // if we've got no address, then quit now - nothing we can do

    if (AccessMask == (UINT_PTR)NULL) {
        Print("We have a Null address\n");
        return(0);
    }

    DbgDumpAccessMask(
                hCurrentProcess,
                Print,
                AccessMask
                );

    // Add Command to the Command Queue
    return 0;

    DBG_UNREFERENCED_PARAMETER(hCurrentProcess);
    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\prtprocs\winprint\winprint.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

// @@BEGIN_DDKSPLIT
Module Name:

    windows\spooler\prtprocs\winprint\winprint.c

// @@END_DDKSPLIT
Abstract:

    Win32 print processor support functions.


--*/

#include "local.h"

#include <excpt.h>

// @@BEGIN_DDKSPLIT
/**
    Used for enumerating, checking supported data types

    !! Warning !! Must match PRINTPROCESSOR_TYPE_* defined in winprint.h

    If the EMF version is rev-ed, corresponding changes need to be made in
      spoolss\client\winspool.c (GetPrinterDataW)
      localspl\port.c (PortThread)
      localspl\schedule.c (CheckMemoryAvailable)
      ntgdi\client\output.c (StartDocW)

    !! HACK !!

    NT EMF 1.003 isn't really supported.  Localspl is hardcoded to reject this
    call, but we keep it so that HP LJ 1100 monolithic driver can still install.
    (During install, they set the DRIVER_INFO_3 datatype to 1.003, and this
    fails if it isn't supported by somebody.)

    In localspl's LocalStartDocPrinter call, we actually reject this datatype.
**/
// @@END_DDKSPLIT

LPWSTR  Datatypes[]={
    L"RAW",
// @@BEGIN_DDKSPLIT
    L"RAW [FF appended]",
    L"RAW [FF auto]",
    L"NT EMF 1.003",
// @@END_DDKSPLIT
    L"NT EMF 1.006",
    L"NT EMF 1.007",
    L"NT EMF 1.008",
    L"TEXT",
    0};

/** Misc. constants **/

#define BASE_TAB_SIZE 8

/**
 *  For localization:
**/

PWCHAR pTabsKey     = L"TABS";
PWCHAR pCopiesKey   = L"COPIES";


/**
    Prototypes
**/

/** Functions found in parsparm.c **/

extern USHORT GetKeyValue(
    IN      PWCHAR,
    IN      PWCHAR,
    IN      USHORT,
    IN OUT  PUSHORT,
    OUT     PVOID);

/** Functions found in raw.c **/

extern BOOL PrintRawJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR,
    IN UINT);

/** Functions found in text.c **/

extern BOOL PrintTextJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR);

/** Functions found in emf.c */

extern BOOL PrintEMFJob(
    IN PPRINTPROCESSORDATA,
    IN LPWSTR);

/** Functions found in support.c **/

extern PUCHAR GetPrinterInfo(
    IN  HANDLE hPrinter,
    IN  ULONG,
    OUT PULONG);

BOOL BReleasePPData(
        IN  PPRINTPROCESSORDATA * ppData );



//@@BEGIN_DDKSPLIT
/* DllMain only to be compiled for DDK.
//@@END_DDKSPLIT

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
)
{
    return TRUE;
}    

//@@BEGIN_DDKSPLIT
*/
//@@END_DDKSPLIT


/*++
*******************************************************************
    E n u m P r i n t P r o c e s s o r D a t a t y p e s W

    Routine Description:
        Enumerates the data types supported by the print processor.

    Arguments:
        pName               => server name
        pPrintProcessorName => print processor name
        Level               => level of data to return (must be 1)
        pDatatypes          => structure array to fill in
        cbBuf               => length of structure array in bytes
        pcbNeeded           => buffer length copied/required
        pcReturned          => number of structures returned

    Return Value:
        TRUE  if successful
        FALSE if failed - caller must use GetLastError for reason
*******************************************************************
--*/
BOOL
EnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DATATYPES_INFO_1    *pInfo1 = (DATATYPES_INFO_1 *)pDatatypes;
    LPWSTR              *pMyDatatypes = Datatypes;
    DWORD               cbTotal=0;
    ULONG               cchBuf =0;
    LPBYTE              pEnd;


    if ( NULL == pcbNeeded  ||
         NULL == pcReturned )
    {
        return FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    /** Start assuming failure, no entries returned **/

    *pcReturned = 0;

    /** Add up the minimum buffer required **/

    while (*pMyDatatypes) {

        cbTotal += wcslen(*pMyDatatypes) * sizeof(WCHAR) + sizeof(WCHAR) +
                   sizeof(DATATYPES_INFO_1);

        pMyDatatypes++;
    }

    /** Set the buffer length returned/required **/

    *pcbNeeded = cbTotal;

    /** Fill in the array only if there is sufficient space **/

    if (cbTotal <= cbBuf) {

        if ( NULL == pInfo1 ) //pInfo1 is same as pDatatypes
        {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        /** Pick up pointer to end of the given buffer **/

        pEnd = (LPBYTE)pInfo1 + cbBuf;

    
        /** Pick up our list of supported data types **/

        pMyDatatypes = Datatypes;

        /**
            Fill in the given buffer.  We put the data names at the end of
            the buffer, working towards the front.  The structures are put
            at the front, working towards the end.
        **/

        while (*pMyDatatypes) {

            cchBuf = wcslen(*pMyDatatypes) + 1; //+1 is for \0.
            pEnd -= cchBuf*sizeof(WCHAR); 

            StringCchCopy ( (LPWSTR)pEnd, cchBuf, *pMyDatatypes);
            pInfo1->pName = (LPWSTR)pEnd;
            pInfo1++;
            (*pcReturned)++;

            pMyDatatypes++;
        }

    } else {

        /** Caller didn't have large enough buffer, set error and return **/

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    /** Return success **/

    return TRUE;
}


/*++
*******************************************************************
    O p e n P r i n t P r o c e s s o r

    Routine Description:

    Arguments:
        pPrinterName            => name of printer we are
                                    opening for
        pPrintProcessorOpenData => information used for opening
                                    the print processor

    Return Value:
        PPRINTPROCESSORDATA => processor data of opened
                                processor if successful
        NULL if failed - caller uses GetLastError for reason

    NOTE: OpenPrinter will be called iff this returns a valid handle
          (and we're not journal)
@@BEGIN_DDKSPLIT
          ClosePrintProcessor MUST be called if we succeed here,
          (or else things don't get cleaned up--like pIniJob->cRef
          for RAW jobs, which causes the queue to stick!)
@@END_DDKSPLIT          

*******************************************************************
--*/
HANDLE
OpenPrintProcessor(
    LPWSTR   pPrinterName,
    PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
)
{
    PPRINTPROCESSORDATA pData;
    LPWSTR              *pMyDatatypes=Datatypes;
    DWORD               uDatatype=0;
    HANDLE              hPrinter=0;
    HDC                 hDC = 0;
    PDEVMODEW           pDevmode = NULL;


    /** If the caller passed a NULL for the open data, fail the call.
        pPrintProcessorOpenData->pDevMode can be NULL **/

    if (!pPrintProcessorOpenData ||
        !pPrintProcessorOpenData->pDatatype ||
        !*pPrintProcessorOpenData->pDatatype) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    /** Search for the data type index we are opening for **/

    while (*pMyDatatypes) {

        if (!_wcsicmp(*pMyDatatypes,pPrintProcessorOpenData->pDatatype)) {
            break;
        }
        pMyDatatypes++;
        uDatatype++;
    }

    /** Allocate a buffer for the print processor data to return **/

    pData = (PPRINTPROCESSORDATA)AllocSplMem(sizeof(PRINTPROCESSORDATA));

    if (!pData) {
        ODS(("Alloc failed in OpenPrintProcessor, while printing on %ws\n", pPrinterName));
        return NULL;
    }

    ZeroMemory ( pData, sizeof (PRINTPROCESSORDATA) );

    /** Open the processor accordingly **/

    switch (uDatatype) {

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
        if (!OpenPrinter(pPrinterName, &hPrinter, NULL))
            goto Fail;
        break;

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:

        if(pPrintProcessorOpenData->pDevMode)
        {
            if(!(pDevmode=AllocSplMem(pPrintProcessorOpenData->pDevMode->dmSize+
                                      pPrintProcessorOpenData->pDevMode->dmDriverExtra)))
            {
                goto Fail;
            }
            memcpy(pDevmode,
                   pPrintProcessorOpenData->pDevMode,
                   pPrintProcessorOpenData->pDevMode->dmSize+
                   pPrintProcessorOpenData->pDevMode->dmDriverExtra);
        }
        break;

    case PRINTPROCESSOR_TYPE_TEXT:
        if (!(hDC = CreateDC(L"", pPrinterName, L"",
                             pPrintProcessorOpenData->pDevMode)))
            goto Fail;
        break;

    default:
        SetLastError(ERROR_INVALID_DATATYPE);
        goto Fail;
    }

    /** Fill in the print processors information **/

    pData->cb          = sizeof(PRINTPROCESSORDATA);
    pData->signature   = PRINTPROCESSORDATA_SIGNATURE;
    pData->JobId       = pPrintProcessorOpenData->JobId;
    pData->hPrinter    = hPrinter;
    pData->semPaused   = CreateEvent(NULL, TRUE, TRUE,NULL);
    pData->uDatatype   = uDatatype;
    pData->hDC         = hDC;
    pData->Copies      = 1;
    pData->TabSize     = BASE_TAB_SIZE;

    /** Allocate and fill in the processors strings **/

    pData->pPrinterName = AllocSplStr(pPrinterName);
    pData->pDatatype    = AllocSplStr(pPrintProcessorOpenData->pDatatype);
    pData->pDocument    = AllocSplStr(pPrintProcessorOpenData->pDocumentName);
    pData->pOutputFile  = AllocSplStr(pPrintProcessorOpenData->pOutputFile);
    pData->pParameters  = AllocSplStr(pPrintProcessorOpenData->pParameters);
    pData->pDevmode     = pDevmode;
    pData->pPrinterNameFromOpenData = AllocSplStr(pPrintProcessorOpenData->pPrinterName);

    //
    // Check for validity of pData. In the AllocSplStr above, if RHS is non-null, then LHS
    // should be non-null. 
    //
    if ( NULL == pData->semPaused ||
        ( NULL != pPrinterName                           && NULL == pData->pPrinterName )  ||
        ( NULL != pPrintProcessorOpenData->pDatatype     && NULL == pData->pDatatype    )  ||
        ( NULL != pPrintProcessorOpenData->pDocumentName && NULL == pData->pDocument    )  ||
        ( NULL != pPrintProcessorOpenData->pOutputFile   && NULL == pData->pOutputFile  )  ||
        ( NULL != pPrintProcessorOpenData->pParameters   && NULL == pData->pParameters  )  ||
        ( NULL != pPrintProcessorOpenData->pPrinterName  && NULL == pData->pPrinterNameFromOpenData)
      )
    {
        goto Fail;
    }

    // @@BEGIN_DDKSPLIT
    /**
        WORKWORK : Currently, the pParameters field has
        the name of the printer driver.  This will be fixed, and
        should come up here the same as the user submitted in the
        job's Printer Info structure.
    **/
    // @@END_DDKSPLIT

    /** Parse the parameters string **/
    if (pData->pParameters) {
        ULONG   value;
        USHORT  length = sizeof(ULONG);

        /**
            Look to see if there is a COPIES=n key/value in the
            Parameters field of this job.  This tells us the number
            of times to play the data.
        **/

        if (pData->pParameters) {

            GetKeyValue(pData->pParameters,
                        pCopiesKey,
                        VALUE_ULONG,
                        &length,
                        &value);

            if (length == sizeof(ULONG)) {
                pData->Copies = value;
            }
        }

        /** If this is a text job, see if the tab size is in there **/

        if (uDatatype == PRINTPROCESSOR_TYPE_TEXT) {
            length = sizeof(ULONG);

            GetKeyValue(pData->pParameters,
                        pTabsKey,
                        VALUE_ULONG,
                        &length,
                        &value);

            if ((length == sizeof(ULONG)) && value) {
                pData->TabSize = value;
            }
        }
    } /* If we have a parameter string */

    /**
        If we are doing copies, we need to check to see if
        this is a direct or spooled job.  If it is direct, then
        we can't do copies because we can't rewind the data stream.
    **/

    if (pData->Copies > 1) {
        ULONG           Error;
        PPRINTER_INFO_2 pPrinterInfo2;

        /** If we don't already have the printer open, open it **/

        if (uDatatype != PRINTPROCESSOR_TYPE_RAW 
            // @@BEGIN_DDKSPLIT 
            &&
            uDatatype != PRINTPROCESSOR_TYPE_RAW_FF &&
            uDatatype != PRINTPROCESSOR_TYPE_RAW_FF_AUTO 
            // @@END_DDKSPLIT
            ) {

            OpenPrinter(pPrinterName, &hPrinter, NULL);
        }
        if (hPrinter && hPrinter != INVALID_HANDLE_VALUE) {

            /** Get the printer info - this returns an allocated buffer **/

            pPrinterInfo2 = (PPRINTER_INFO_2)GetPrinterInfo(hPrinter, 2, &Error);

            /** If we couldn't get the info, be safe and don't do copies **/

            if (!pPrinterInfo2) {
                ODS(("GetPrinter failed - falling back to 1 copy\n"));
                pData->Copies = 1;
            }
            else {
                if (pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
                    pData->Copies = 1;
                }
                FreeSplMem((PUCHAR)pPrinterInfo2);
            }

            /** If we just opened the printer, close it **/

            if (uDatatype != PRINTPROCESSOR_TYPE_RAW 
                // @@BEGIN_DDKSPLIT 
                &&
                uDatatype != PRINTPROCESSOR_TYPE_RAW_FF &&
                uDatatype != PRINTPROCESSOR_TYPE_RAW_FF_AUTO 
                // @@END_DDKSPLIT
                ) {

                ClosePrinter(hPrinter);
            }
        }
        else {
            pData->Copies = 1;
        }
    }

    return (HANDLE)pData;

Fail:
    BReleasePPData(&pData);

    return FALSE;
}


/*++
*******************************************************************
    P r i n t D o c u m e n t O n P r i n t P r o c e s s o r

    Routine Description:

    Arguments:
        hPrintProcessor
        pDocumentName

    Return Value:
        TRUE  if successful
        FALSE if failed - GetLastError() will return reason
*******************************************************************
--*/
BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPWSTR  pDocumentName
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (!(pData = ValidateHandle(hPrintProcessor))) {

        return FALSE;
    }

    /**
        Print the job based on its data type.
    **/

    switch (pData->uDatatype) {

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:

        return PrintEMFJob( pData, pDocumentName );
        break;

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
        return PrintRawJob(pData, pDocumentName, pData->uDatatype);
        break;

    case PRINTPROCESSOR_TYPE_TEXT:
        return PrintTextJob(pData, pDocumentName);
        break;    
    } /* Case on data type */

    /** Return success **/

    return TRUE;
}


/*++
*******************************************************************
    C l o s e P r i n t P r o c e s s o r

    Routine Description:
        Frees the resources used by an open print processor.

    Arguments:
        hPrintProcessor (HANDLE) => print processor to close

    Return Value:
        TRUE  if successful
        FALSE if failed - caller uses GetLastError for reason.
*******************************************************************
--*/

BOOL
ClosePrintProcessor(
    HANDLE  hPrintProcessor
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (!(pData= ValidateHandle(hPrintProcessor))) {
        return FALSE;
    }

    return BReleasePPData(&pData);
}

BOOL BReleasePPData(
        IN  PPRINTPROCESSORDATA * ppData )
{

    PPRINTPROCESSORDATA pData = NULL;

    if ( NULL == ppData || NULL == *ppData)
    {
        return FALSE;
    }

    pData = *ppData;
    
    pData->signature = 0;

    /* Release any allocated resources */

    if (pData->hPrinter)
        ClosePrinter(pData->hPrinter);

    if (pData->hDC)
        DeleteDC(pData->hDC);

    if (pData->pDevmode)
        FreeSplMem(pData->pDevmode);

    if (pData->pPrinterNameFromOpenData)
        FreeSplStr(pData->pPrinterNameFromOpenData);

    if (pData->semPaused)
        CloseHandle(pData->semPaused);

    if (pData->pPrinterName)
        FreeSplStr(pData->pPrinterName);

    if (pData->pDatatype)
        FreeSplStr(pData->pDatatype);

    if (pData->pDocument)
        FreeSplStr(pData->pDocument);

    if (pData->pOutputFile)
        FreeSplStr(pData->pOutputFile);

    if (pData->pParameters)
        FreeSplStr(pData->pParameters);

    ZeroMemory ( pData, sizeof (PRINTPROCESSORDATA) );
    FreeSplMem(pData);
    *ppData = pData = NULL;


    return TRUE;
}


/*++
*******************************************************************
    C o n t r o l P r i n t P r o c e s s o r

    Routine Description:
        Handles commands to pause, resume, and cancel print jobs.

    Arguments:
        hPrintProcessor = HANDLE to the PrintProcessor the
        command is issued for.

    Return Value:
        TRUE  if command succeeded
        FALSE if command failed (invalid command)
*******************************************************************
--*/
BOOL
ControlPrintProcessor(
    HANDLE  hPrintProcessor,
    DWORD   Command
)
{
    PPRINTPROCESSORDATA pData;

    /**
        Make sure the handle is valid and pick up
        the Print Processors data area.
    **/

    if (pData = ValidateHandle(hPrintProcessor)) {

        switch (Command) {

        case JOB_CONTROL_PAUSE:

            ResetEvent(pData->semPaused);
            pData->fsStatus |= PRINTPROCESSOR_PAUSED;
            return TRUE;
            break;

        case JOB_CONTROL_CANCEL:

            pData->fsStatus |= PRINTPROCESSOR_ABORTED;

            if ((pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_1) ||
                (pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_2) ||
                (pData->uDatatype == PRINTPROCESSOR_TYPE_EMF_50_3))

                CancelDC(pData->hDC);

            /* Fall through to release job if paused */

        case JOB_CONTROL_RESUME:

            if (pData->fsStatus & PRINTPROCESSOR_PAUSED) {

                SetEvent(pData->semPaused);
                pData->fsStatus &= ~PRINTPROCESSOR_PAUSED;
            }

            return TRUE;
            break;

        default:

            return FALSE;
            break;
        }
    }

    return FALSE;
}


/*++
*******************************************************************
    V a l i d a t e H a n d l e

    Routine Description:
        Validates the given Print Processor HANDLE (which is
        really a pointer to the Print Processor's data) by
        checking for our signature.

    Arguments:
        hQProc (HANDLE) => Print Processor data structure.  This
        is verified as really being a pointer to the Print
        Processor's data.

    Return Value:
        PPRINTPROCESSORDATA if successful (valid pointer passed)
        NULL if failed - pointer was not valid
*******************************************************************
--*/
PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hQProc
)
{
    /** Pick up the pointer **/

    PPRINTPROCESSORDATA pData = (PPRINTPROCESSORDATA)hQProc;

    //
    // Note that spooler has to leave the critical section to call into print
    // proc. So the handle passed by spooler could be invalid since one
    // thread could call SetJob to pause/resume a job while port thread
    // is printing it
    //
    try {

        /** See if our signature exists in the suspected data region **/

        if (pData && pData->signature != PRINTPROCESSORDATA_SIGNATURE) {

            /** Bad pointer - return failed **/

            pData = NULL;
        }


    }except (1) {

        /** Bad pointer - return failed **/

        pData = NULL;

    }

    if ( pData == NULL )
        SetLastError( ERROR_INVALID_HANDLE );

    return pData;

}

DWORD
GetPrintProcessorCapabilities(
    LPTSTR   pValueName,
    DWORD    dwAttributes,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
)
/*++
Function Description: GetPrintProcessorCapabilities returns information about the
                      options supported by the print processor for the given datatype
                      in a PRINTPROCESSOR_CAPS_1 struct.

Parameters:   pValueName   -- datatype like RAW|NT EMF 1.006|TEXT|...
              dwAttributes -- printer attributes
              pData        -- pointer to the buffer
              nSize        -- size of the buffer
              pcbNeeded    -- pointer to the variable to store the required buffer size

Return Values: Error Codes.
--*/
{
    LPWSTR                  *pDatatypes = Datatypes;
    DWORD                   dwDatatype  = 0;
    DWORD                   dwReturn;
    PPRINTPROCESSOR_CAPS_1  ppcInfo;

    // Check for valid parameters.
    if ( !pcbNeeded || !pData || !pValueName) {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    *pcbNeeded = sizeof(PRINTPROCESSOR_CAPS_1);

    // Check for sufficient buffer.
    if (nSize < *pcbNeeded) {
        dwReturn = ERROR_MORE_DATA;
        goto CleanUp;
    }

    // Loop to find the index of the datatype.
    while (*pDatatypes) {
       if (!_wcsicmp(*pDatatypes,pValueName)) {
           break;
       }
       pDatatypes++;
       dwDatatype++;
    }

    ppcInfo = (PPRINTPROCESSOR_CAPS_1) pData;

    // Level is 1 for PRINTPROCESSOR_CAPS_1.
    ppcInfo->dwLevel = 1;

    switch (dwDatatype) {

    case PRINTPROCESSOR_TYPE_RAW:
    // @@BEGIN_DDKSPLIT
    case PRINTPROCESSOR_TYPE_RAW_FF:
    case PRINTPROCESSOR_TYPE_RAW_FF_AUTO:
    // @@END_DDKSPLIT
    case PRINTPROCESSOR_TYPE_TEXT:
          ppcInfo->dwNupOptions = 1;
          ppcInfo->dwNumberOfCopies = 0xffffffff; // maximum number of copies.
          ppcInfo->dwPageOrderFlags = NORMAL_PRINT;
          break;

    case PRINTPROCESSOR_TYPE_EMF_50_1:
    case PRINTPROCESSOR_TYPE_EMF_50_2:
    case PRINTPROCESSOR_TYPE_EMF_50_3:
          // For direct printing, masq. printers and print RAW only,
          // EMF is not spooled. Dont expose EMF features in the UI.
          if ((dwAttributes & PRINTER_ATTRIBUTE_DIRECT)   ||
              (dwAttributes & PRINTER_ATTRIBUTE_RAW_ONLY) ||
              ((dwAttributes & PRINTER_ATTRIBUTE_LOCAL)  &&
               (dwAttributes & PRINTER_ATTRIBUTE_NETWORK))) {
              ppcInfo->dwNupOptions = 1;
              ppcInfo->dwNumberOfCopies = 1;
              ppcInfo->dwPageOrderFlags = NORMAL_PRINT;
          } else {
              ppcInfo->dwNupOptions = 0x0000812b;  // for 1,2,4,6,9,16 up options.
              ppcInfo->dwNumberOfCopies = 0xffffffff; // maximum number of copies.
              ppcInfo->dwPageOrderFlags = REVERSE_PRINT | BOOKLET_PRINT;
          }
          break;

    default:
          // Should not happen since the spooler must check if the datatype is
          // supported before calling this print processor.
          dwReturn = ERROR_INVALID_DATATYPE;
          goto CleanUp;
    }

    dwReturn = ERROR_SUCCESS;

CleanUp:

    return dwReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbgspl.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgspl.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

    KrishnaG:       Created: 1-July-1993 (imported most of IanJa's stuff)
    KrishnaG:       Added:   7-July-1993 (added AndrewBe's UnicodeAnsi conversion routines)
    KrishnaG        Added:   3-Aug-1993  (added DevMode/SecurityDescriptor dumps)
    MattFe                   7 NOV   94   win32spl debug extentions

To do:

    Write a generic dump unicode string (reduce the code!!)

--*/

#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

#define NULL_TERMINATED 0
#define VERBOSE_ON      1
#define VERBOSE_OFF     0


typedef void (*PNTSD_OUTPUT_ROUTINE)(char *, ...);

BOOL
DbgDumpIniPrintProc(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTPROC pIniPrintProc
);


BOOL
DbgDumpIniDriver(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIDRIVER  pIniDriver
);


BOOL
DbgDumpIniEnvironment(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIENVIRONMENT pIniEnvironment
);


BOOL
DbgDumpIniNetPrint(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PININETPRINT pIniNetPrint
);

BOOL
DbgDumpIniMonitor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIMONITOR pIniMonitor
);


BOOL
DbgDumpIniPort(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPORT pIniPort
);

BOOL
DbgDumpIniPrinter(

    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIPRINTER pIniPrinter
);

BOOL
DbgDumpIniForm(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIFORM pForm
);

BOOL
DbgDumpIniJob(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIJOB pIniJob
);

BOOL
DbgDumpProvidor(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    LPPROVIDOR pProvidor
);

BOOL
DbgDumpSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSPOOL pSpool
);

BOOL
DbgDumpShadowFile(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE pShadowFile
);

BOOL
DbgDumpShadowFile2(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PSHADOWFILE_2 pShadowFile
);

VOID
PrintData(
    PNTSD_OUTPUT_ROUTINE Print,
    LPSTR   TypeString,
    LPSTR   VarString,
    ...
);

BOOL
DbgDumpWCacheIniPrinter(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWCACHEINIPRINTEREXTRA pWCacheIniPrinter
);

BOOL
DbgDumpWSpool(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWSPOOL pSpool
);

BOOL
DbgDumpWin32Thread(
    HANDLE  hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PWIN32THREAD pThread
);

BOOL
DbgDumpIniSpooler(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINISPOOLER pIniSpooler
);


BOOL
DbgDumpIniVersion(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PINIVERSION pIniVersion
);

BOOL
DbgDumpPrintHandle(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    PPRINTHANDLE pPrintHandle
);


typedef struct _DBG_PRINTER_ACCESS
{
    DWORD   Attribute;
    LPSTR   String;
} DBG_PRINTER_ACCESS, *PDBG_PRINTER_ACCESS;


DBG_PRINTER_ACCESS
PrinterAccessTable[] =
{
    SERVER_ACCESS_ADMINISTER    ,"Server_Access_Administer",
    SERVER_ACCESS_ENUMERATE     ,"Server_Access_Enumerate",
    PRINTER_ACCESS_ADMINISTER   ,"Printer_Access_Administer",
    PRINTER_ACCESS_USE          ,"Printer_Access_Use",
    JOB_ACCESS_ADMINISTER       ,"Job_Access_Administer"
};




typedef struct _DBG_SPOOLER_FLAGS
{
    DWORD   SpoolerFlags;
    LPSTR   String;
} DBG_SPOOLER_FLAGS, *PDBG_SPOOLER_FLAGS;


DBG_SPOOLER_FLAGS
SpoolerFlagsTable[] =

{
    SPL_UPDATE_WININI_DEVICES                   ,"Update_WinIni_Devices",
    SPL_PRINTER_CHANGES                         ,"Printer_Changes",
    SPL_LOG_EVENTS                              ,"Log_Events",
    SPL_FORMS_CHANGE                            ,"Forms_Change",
    SPL_BROADCAST_CHANGE                        ,"Broadcast_Change",
    SPL_SECURITY_CHECK                          ,"Security_Check",
    SPL_OPEN_CREATE_PORTS                       ,"Open_Create_Ports",
    SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION     ,"Fail_Open_Printers_Pending_Deletion",
    SPL_REMOTE_HANDLE_CHECK                     ,"Remote_Handle_Check"
};



typedef struct _DBG_PRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PRINTER_STATUS, *PDBG_PRINTER_STATUS;


DBG_PRINTER_STATUS
PrinterStatusTable[] =

{
    PRINTER_ZOMBIE_OBJECT,              "Zombie_Object",
    PRINTER_PENDING_CREATION,           "Pending_Creation",
    PRINTER_OK,                         "OK",
    PRINTER_FROM_REG,                   "From_Reg",
    PRINTER_WAS_SHARED,                 "Was_Shared",

    PRINTER_ERROR,               "Error",
    PRINTER_PAPER_JAM,           "PaperJam",
    PRINTER_PAPEROUT,           "PaperOut",
    PRINTER_MANUAL_FEED,         "ManualFeed",
    PRINTER_PAPER_PROBLEM,       "PaperProblem",
    PRINTER_OFFLINE,             "OffLine",
    PRINTER_IO_ACTIVE,           "IOActive",
    PRINTER_BUSY,                "Busy",
    PRINTER_PRINTING,            "Printing",
    PRINTER_OUTPUT_BIN_FULL,     "OutputBinFull",
    PRINTER_NOT_AVAILABLE,       "NotAvailable",
    PRINTER_WAITING,             "Waiting",
    PRINTER_PROCESSING,          "Processing",
    PRINTER_INITIALIZING,        "Initializing",
    PRINTER_WARMING_UP,          "WarmingUp",
    PRINTER_TONER_LOW,           "TonerLow",
    PRINTER_NO_TONER,            "NoToner",
    PRINTER_PAGE_PUNT,           "PagePunt",
    PRINTER_USER_INTERVENTION,   "UserIntervention",
    PRINTER_OUT_OF_MEMORY,       "OutOfMemory",
    PRINTER_DOOR_OPEN,           "DoorOpen",
    PRINTER_SERVER_UNKNOWN,      "ServerUnknown",

    PRINTER_PAUSED,              "Paused",
    PRINTER_PENDING_DELETION,    "Pending_Deletion",
};

typedef struct _DBG_EXTERNAL_PRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_EXTERNAL_PRINTER_STATUS, *PDBG_EXTERNAL_PRINTER_STATUS;


DBG_EXTERNAL_PRINTER_STATUS
ExternalPrinterStatusTable[] =

{
     PRINTER_STATUS_PAUSED            , "Paused",
     PRINTER_STATUS_ERROR             , "Error",
     PRINTER_STATUS_PENDING_DELETION  , "Pending_Deletion",
     PRINTER_STATUS_PAPER_JAM         , "Paper_Jam",
     PRINTER_STATUS_PAPER_OUT         , "Paper_Out",
     PRINTER_STATUS_MANUAL_FEED       , "Manual_Feed",
     PRINTER_STATUS_PAPER_PROBLEM     , "Paper_Problem",
     PRINTER_STATUS_OFFLINE           , "OffLine",
     PRINTER_STATUS_IO_ACTIVE         , "IO_Active",
     PRINTER_STATUS_BUSY              , "Busy",
     PRINTER_STATUS_PRINTING          , "Printing",
     PRINTER_STATUS_OUTPUT_BIN_FULL   , "Output_Bin_Full",
     PRINTER_STATUS_NOT_AVAILABLE     , "Not_Available",
     PRINTER_STATUS_WAITING           , "Waiting",
     PRINTER_STATUS_PROCESSING        , "Processing",
     PRINTER_STATUS_INITIALIZING      , "Initializing",
     PRINTER_STATUS_WARMING_UP        , "Warming_Up",
     PRINTER_STATUS_TONER_LOW         , "Toner_Low",
     PRINTER_STATUS_NO_TONER          , "No_Toner",
     PRINTER_STATUS_PAGE_PUNT         , "Page_Punt",
     PRINTER_STATUS_USER_INTERVENTION , "User_Intervention",
     PRINTER_STATUS_OUT_OF_MEMORY     , "Out_Of_Memory",
     PRINTER_STATUS_DOOR_OPEN         , "Door_Open",
     PRINTER_STATUS_SERVER_UNKNOWN    , "Server_Unknown"
};

typedef struct _DBG_PORT_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PORT_STATUS, *PDBG_PORT_STATUS;

DBG_PORT_STATUS
PortStatusTable[] =

{
    PORT_STATUS_OFFLINE                 , "Offline",
    PORT_STATUS_PAPER_JAM               , "PaperJam",
    PORT_STATUS_PAPER_OUT               , "PaperOut",
    PORT_STATUS_OUTPUT_BIN_FULL         , "OutputBinFull",
    PORT_STATUS_PAPER_PROBLEM           , "PaperJam",
    PORT_STATUS_NO_TONER                , "NoToner",
    PORT_STATUS_DOOR_OPEN               , "DoorOpen",
    PORT_STATUS_USER_INTERVENTION       , "UserIntervention",
    PORT_STATUS_OUT_OF_MEMORY           , "OutOfMemory",

    PORT_STATUS_TONER_LOW               , "TonerLow",

    PORT_STATUS_WARMING_UP              , "WarmingUp",
    PORT_STATUS_POWER_SAVE              , "PowerSave"
};





typedef struct _DBG_PRINTER_ATTRIBUTE
{
    DWORD   Attribute;
    LPSTR   String;
} DBG_PRINTER_ATTRIBUTE, *PDBG_PRINTER_ATTRIBUTE;


DBG_PRINTER_ATTRIBUTE
ChangeStatusTable[] =

{
    STATUS_CHANGE_FORMING, "Forming",
    STATUS_CHANGE_VALID,   "Valid",
    STATUS_CHANGE_CLOSING, "Closing",
    STATUS_CHANGE_CLIENT,  "Client",
    STATUS_CHANGE_ACTIVE,  "Active",

    STATUS_CHANGE_INFO, "Info",

    STATUS_CHANGE_ACTIVE_REQ,  "ActiveRequest",

    STATUS_CHANGE_DISCARDED, "Discarded",

    STATUS_CHANGE_DISCARDNOTED, "DiscardNoted",
};

DBG_PRINTER_ATTRIBUTE
PrinterAttributeTable[] =

{
    PRINTER_ATTRIBUTE_QUEUED,            "Queued",
    PRINTER_ATTRIBUTE_DIRECT,            "Direct",
    PRINTER_ATTRIBUTE_DEFAULT,           "Default",
    PRINTER_ATTRIBUTE_SHARED,            "Shared",
    PRINTER_ATTRIBUTE_NETWORK,           "Network",
    PRINTER_ATTRIBUTE_LOCAL,             "Local",
    PRINTER_ATTRIBUTE_HIDDEN,            "Hidden",
    PRINTER_ATTRIBUTE_ENABLE_DEVQ,       "Enable_DevQ",
    PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS,   "KeepPrintedJobs",
    PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, "DoCompleteFirst",
    PRINTER_ATTRIBUTE_ENABLE_BIDI,       "EnableBidi",
    PRINTER_ATTRIBUTE_FAX,               "Fax",
    PRINTER_ATTRIBUTE_WORK_OFFLINE,      "Offline"
};


typedef struct _DBG_JOB_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_JOB_STATUS, *PDBG_JOB_STATUS;

DBG_JOB_STATUS
JobStatusTable[] =

{
    JOB_PAUSED,                  "Paused",
    JOB_ERROR,                   "Error",
    JOB_OFFLINE,                 "OffLine",
    JOB_PAPEROUT,                "PaperOut",

    JOB_PENDING_DELETION,        "Deleting",
    JOB_SPOOLING,                "Spooling",
    JOB_PRINTING,                "Printing",
    JOB_PRINTED,                 "Printed",
    JOB_BLOCKED_DEVQ,            "Blocked_DevQ",
    JOB_DELETED,                 "Deleted",

    JOB_DESPOOLING,              "Despooling",
    JOB_DIRECT,                  "Direct",
    JOB_COMPLETE,                "Complete",
    JOB_RESTART,                 "Restart",
    JOB_REMOTE,                  "Remote",
    JOB_NOTIFICATION_SENT,       "Notification_Sent",
    JOB_PRINT_TO_FILE,           "Print_To_File",
    JOB_TYPE_ADDJOB,             "AddJob",
    JOB_SCHEDULE_JOB,            "Schedule_Job",
    JOB_TIMEOUT,                 "Timeout",
    JOB_ABANDON,                 "Abandon",
    JOB_TRUE_EOJ,                "TrueEOJ",
    JOB_COMPOUND,                "Compound",
    JOB_HIDDEN,                  "Hidden",
    JOB_TYPE_OPTIMIZE,           "MemoryMap Optimization",
    JOB_PP_CLOSE,                "Print Proccessor Close",
    JOB_DOWNLEVEL,               "Downlevel Job"
};

typedef struct _DBG_PINIPORT_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PINIPORT_STATUS, *PDBG_PINIPORT_STATUS;


DBG_PINIPORT_STATUS
pIniPortStatusTable[]=
{
     PP_PAUSED         ,"Paused",
     PP_WAITING        ,"Waiting",
     PP_RUNTHREAD      ,"RunThread",
     PP_THREADRUNNING  ,"ThreadRunning",
     PP_RESTART        ,"Restart",
     PP_CHECKMON       ,"CheckMon",
     PP_STOPMON        ,"StopMon",
     PP_QPROCCHECK     ,"QProcCheck",
     PP_QPROCPAUSE     ,"QProcPause",
     PP_QPROCABORT     ,"QProctAbort",
     PP_QPROCCLOSE     ,"QProcClose",
     PP_PAUSEAFTER     ,"PauseAfter",
     PP_MONITORRUNNING ,"MonitorRunning",
     PP_RUNMONITOR     ,"RunMonitor",
     PP_MONITOR        ,"Monitor",
     PP_FILE           ,"File",
     PP_ERROR          ,"Error",
     PP_WARNING        ,"Warning",
     PP_INFORMATIONAL  ,"Informational",
     PP_DELETING       ,"Deleting",
     PP_STARTDOC       ,"StartDoc",
     PP_PLACEHOLDER    ,"Placeholder",
};



typedef struct _DBG_WSPOOL_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_WSPOOL_STATUS, *PDBG_WSPOOL_STATUS;


DBG_WSPOOL_STATUS
WSpoolStatusTable[]=
{
     WSPOOL_STATUS_STARTDOC                   ,"StartDoc",
     WSPOOL_STATUS_TEMP_CONNECTION            ,"Temp_Connection",
     WSPOOL_STATUS_OPEN_ERROR                 ,"Open_Error",
     WSPOOL_STATUS_PRINT_FILE                 ,"Print_File",
     WSPOOL_STATUS_USE_CACHE                  ,"Use_Cache",
     WSPOOL_STATUS_NO_RPC_HANDLE              ,"No_Rpc_Handle",
     WSPOOL_STATUS_RESETPRINTER_PENDING       ,"ResetPrinter_Pending",
     WSPOOL_STATUS_NOTIFY                     ,"Notify",
     WSPOOL_STATUS_NOTIFY_POLL                ,"Notify_Poll",
     WSPOOL_STATUS_CNVRTDEVMODE               ,"Convert_DevMode",
     WSPOOL_STATUS_ASYNC                      ,"Async"
};

typedef struct _DBG_WIN32THREAD_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_WIN32THREAD_STATUS, *PDBG_WIN32THREAD_STATUS;


DBG_WIN32THREAD_STATUS
Win32ThreadStatusTable[]=
{
    THREAD_STATUS_EXECUTING                   , "Thread Executing",
    THREAD_STATUS_TERMINATED                  , "Thread Terminated",    
};

typedef struct _DBG_PSPOOL_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_PSPOOL_STATUS, *PDBG_PSPOOL_STATUS;


DBG_PSPOOL_STATUS
pSpoolStatusTable[]=
{
     SPOOL_STATUS_STARTDOC          ,"StartDoc",
     SPOOL_STATUS_BEGINPAGE         ,"BeginPage",
     SPOOL_STATUS_CANCELLED         ,"Cancelled",
     SPOOL_STATUS_PRINTING          ,"Printing",
     SPOOL_STATUS_ADDJOB            ,"AddJob",
     SPOOL_STATUS_PRINT_FILE        ,"Print_File",
     SPOOL_STATUS_NOTIFY            ,"Notify",
     SPOOL_STATUS_FLUSH_PRINTER     ,"FlushPrinter"
};


typedef struct _DBG_PSPOOL_TYPE_OF_HANDLE
{
    DWORD   TypeOfHandle;
    LPSTR   String;
} DBG_PSPOOL_TYPE_OF_HANDLE, *PDBG_PSPOOL_TYPE_OF_HANDLE;


DBG_PSPOOL_TYPE_OF_HANDLE
pSpoolTypeOfHandleTable[]=
{

    PRINTER_HANDLE_PRINTER,         "Printer",
    PRINTER_HANDLE_REMOTE_DATA,     "RemoteData",
    PRINTER_HANDLE_REMOTE_CALL,     "RemoteCall",
    PRINTER_HANDLE_JOB,             "Job",
    PRINTER_HANDLE_PORT,            "Port",
    PRINTER_HANDLE_DIRECT,          "Direct",
    PRINTER_HANDLE_SERVER,          "Server",
    PRINTER_HANDLE_3XCLIENT,        "Nt3x_Client",
    PRINTER_HANDLE_REMOTE_ADMIN,    "Remote Admin"
};



typedef struct _DBG_WCACHEPRINTER_STATUS
{
    DWORD   Status;
    LPSTR   String;
} DBG_WCACHEPRINTER_STATUS, *PDBG_WCACHEPRINTER_STATUS;


DBG_WCACHEPRINTER_STATUS
WCachePrinterStatusTable[]=
{

    EXTRA_STATUS_PENDING_FFPCN  ,"Pending_FFPCN",
    EXTRA_STATUS_DOING_REFRESH  ,"Doing_Refresh"
};


typedef struct _DBG_DEVMODE_FIELDS {
    DWORD   dmField;
    LPSTR   String;
}DBG_DEVMODE_FIELDS;

#define MAX_DEVMODE_FIELDS          14

DBG_DEVMODE_FIELDS DevModeFieldsTable[] =
{
    0x00000001, "dm_orientation",
    0x00000002, "dm_papersize",
    0x00000004, "dm_paperlength",
    0x00000008, "dm_paperwidth",
    0x00000010, "dm_scale",
    0x00000100, "dm_copies",
    0x00000200, "dm_defautsource",
    0x00000400, "dm_printquality",
    0x00000800, "dm_color",
    0x00001000, "dm_duplex",
    0x00002000, "dm_yresolution",
    0x00004000, "dm_ttoption",
    0x00008000, "dm_collate",
    0x00010000, "dm_formname"
};

typedef struct _DBG_PINIDRIVER_FLAGS {
    DWORD   dwDriverFlag;
    LPSTR   String;
} DBG_PINIDRIVER_FLAGS;

DBG_PINIDRIVER_FLAGS pIniDriverFlagsTable[] =
{
    PRINTER_DRIVER_PENDING_DELETION,     "Pending-Deletion"
};


#define MAX_DEVMODE_PAPERSIZES              41

LPSTR DevModePaperSizes[] =
{
           " Letter 8 1/2 x 11 in               ",
           " Letter Small 8 1/2 x 11 in         ",
           " Tabloid 11 x 17 in                 ",
           " Ledger 17 x 11 in                  ",
           " Legal 8 1/2 x 14 in                ",
           " Statement 5 1/2 x 8 1/2 in         ",
           " Executive 7 1/4 x 10 1/2 in        ",
           " A3 297 x 420 mm                    ",
           " A4 210 x 297 mm                    ",
          " A4 Small 210 x 297 mm              ",
          " A5 148 x 210 mm                    ",
          " B4 250 x 354                       ",
          " B5 182 x 257 mm                    ",
          " Folio 8 1/2 x 13 in                ",
          " Quarto 215 x 275 mm                ",
          " 10x14 in                           ",
          " 11x17 in                           ",
          " Note 8 1/2 x 11 in                 ",
          " Envelope #9 3 7/8 x 8 7/8          ",
          " Envelope #10 4 1/8 x 9 1/2         ",
          " Envelope #11 4 1/2 x 10 3/8        ",
          " Envelope #12 4 \276 x 11           ",
          " Envelope #14 5 x 11 1/2            ",
          " C size sheet                       ",
          " D size sheet                       ",
          " E size sheet                       ",
          " Envelope DL 110 x 220mm            ",
          " Envelope C5 162 x 229 mm           ",
          " Envelope C3  324 x 458 mm          ",
          " Envelope C4  229 x 324 mm          ",
          " Envelope C6  114 x 162 mm          ",
          " Envelope C65 114 x 229 mm          ",
          " Envelope B4  250 x 353 mm          ",
          " Envelope B5  176 x 250 mm          ",
          " Envelope B6  176 x 125 mm          ",
          " Envelope 110 x 230 mm              ",
          " Envelope Monarch 3.875 x 7.5 in    ",
          " 6 3/4 Envelope 3 5/8 x 6 1/2 in    ",
          " US Std Fanfold 14 7/8 x 11 in      ",
          " German Std Fanfold 8 1/2 x 12 in   ",
          " German Legal Fanfold 8 1/2 x 13 in "
};




VOID
ExtractPrinterAccess(PNTSD_OUTPUT_ROUTINE Print, DWORD Attribute)
{
    DWORD i = 0;
    if ( Attribute != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterAccessTable)/sizeof(PrinterAccessTable[0])) {
            if (Attribute & PrinterAccessTable[i].Attribute) {
                (*Print)("%s ", PrinterAccessTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractPrinterAttributes(PNTSD_OUTPUT_ROUTINE Print, DWORD Attribute)
{
    DWORD i = 0;
    if ( Attribute != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterAttributeTable)/sizeof(PrinterAttributeTable[0])) {
            if (Attribute & PrinterAttributeTable[i].Attribute) {
                (*Print)("%s ", PrinterAttributeTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractChangeStatus(PNTSD_OUTPUT_ROUTINE Print, ESTATUS eStatus)
{
    DWORD i = 0;
    if ( eStatus != 0 ) {
        (*Print)(" ");
        while (i < sizeof(ChangeStatusTable)/sizeof(ChangeStatusTable[0])) {
            if (eStatus & ChangeStatusTable[i].Attribute) {
                (*Print)("%s ", ChangeStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractExternalPrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(ExternalPrinterStatusTable)/sizeof(ExternalPrinterStatusTable[0])) {
            if (Status & ExternalPrinterStatusTable[i].Status) {
                (*Print)("%s ", ExternalPrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractSpoolerFlags(PNTSD_OUTPUT_ROUTINE  Print, DWORD SpoolerFlags)
{
    DWORD i = 0;
    if ( SpoolerFlags != 0 ) {
        (*Print)(" ");
        while (i < sizeof(SpoolerFlagsTable)/sizeof(SpoolerFlagsTable[0])) {
            if (SpoolerFlags & SpoolerFlagsTable[i].SpoolerFlags) {
                (*Print)("%s ", SpoolerFlagsTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}


VOID
ExtractPrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(PrinterStatusTable)/sizeof(PrinterStatusTable[0])) {
            if (Status & PrinterStatusTable[i].Status) {
                (*Print)("%s ", PrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }

}

VOID
ExtractWCachePrinterStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(WCachePrinterStatusTable)/sizeof(WCachePrinterStatusTable[0])) {
            if (Status & WCachePrinterStatusTable[i].Status) {
                (*Print)("%s ", WCachePrinterStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }

}

VOID
ExtractPortStatus(PNTSD_OUTPUT_ROUTINE  Print, DWORD Status)
{
    DWORD i = 0;

    (*Print)(" ");
    if ( Status != 0 ) {
        while (i < sizeof(PortStatusTable)/sizeof(PortStatusTable[0])) {
            if (Status == PortStatusTable[i].Status) {
                (*Print)("%s ", PortStatusTable[i].String);
            }
            i++;
        }
    } else {

    }
   (*Print)("\n");

}

VOID
ExtractJobStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(JobStatusTable)/sizeof(JobStatusTable[0])) {
            if (Status & JobStatusTable[i].Status) {
                (*Print)("%s ", JobStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpSpoolTypeOfHandle(PNTSD_OUTPUT_ROUTINE Print, DWORD TypeOfHandle)
{
    DWORD i = 0;
    if ( TypeOfHandle != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pSpoolTypeOfHandleTable)/sizeof(pSpoolTypeOfHandleTable[0])) {
            if (TypeOfHandle & pSpoolTypeOfHandleTable[i].TypeOfHandle) {
                (*Print)("%s ", pSpoolTypeOfHandleTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpSpoolStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status  != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pSpoolStatusTable)/sizeof(pSpoolStatusTable[0])) {
            if (Status & pSpoolStatusTable[i].Status) {
                (*Print)("%s ", pSpoolStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}


VOID
ExtractWSpoolStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(WSpoolStatusTable)/sizeof(WSpoolStatusTable[0])) {
            if (Status & WSpoolStatusTable[i].Status) {
                (*Print)("%s ", WSpoolStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractWin32ThreadStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    
    (*Print)(" ");
        
    while (i < sizeof(Win32ThreadStatusTable)/sizeof(Win32ThreadStatusTable[0])) 
    {
        if (Status == Win32ThreadStatusTable[i].Status) 
        {
            (*Print)("%s ", Win32ThreadStatusTable[i].String);
            break;
        }
        i++;
    }
    (*Print)("\n");
}

VOID
ExtractpIniPortStatus(PNTSD_OUTPUT_ROUTINE Print, DWORD Status)
{
    DWORD i = 0;
    if ( Status != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pIniPortStatusTable)/sizeof(pIniPortStatusTable[0])) {
            if (Status & pIniPortStatusTable[i].Status) {
                (*Print)("%s ", pIniPortStatusTable[i].String);
            }
            i++;
        }
        (*Print)("\n");
    }
}

VOID
ExtractpIniDriverFlags(PNTSD_OUTPUT_ROUTINE Print, DWORD Flags)
{
    DWORD i = 0;
    if ( Flags != 0 ) {
        (*Print)(" ");
        while (i < sizeof(pIniDriverFlagsTable)/sizeof(pIniDriverFlagsTable[0])) {
            if (Flags & pIniDriverFlagsTable[i].dwDriverFlag) {
                (*Print)("%s ", pIniDriverFlagsTable[i].String);
            }
            i++;
        }        
    }

    (*Print)("\n");
}



// All of the primary spooler structures are identified by an
// "signature" field which is the first DWORD in the structure
// This function examines the signature field in the structure
// and appropriately dumps out the contents of the structure in
// a human-readable format.

BOOL
DbgDumpStructure(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, UINT_PTR pData)
{

    INIDRIVER IniDriver;
    INIENVIRONMENT IniEnvironment;
    INIPRINTER IniPrinter;
    INIPRINTPROC IniPrintProc;
    ININETPRINT IniNetPrint;
    INIMONITOR IniMonitor;
    INIPORT IniPort;
    WINIPORT WIniPort;
    INIFORM IniForm;
    INIJOB  IniJob;
    SPOOL   Spool;
    WSPOOL  WSpool;
    WIN32THREAD Win32Thread;
    SHADOWFILE  ShadowFile;
    SHADOWFILE_2  ShadowFile2;
    PRINTHANDLE PrintHandle;
    DWORD   Signature;
    INISPOOLER IniSpooler;
    INIVERSION IniVersion;
    WCACHEINIPRINTEREXTRA WCacheIniPrinterExtra;

    movestruct(pData,&Signature, DWORD);
    switch (Signature) {

    case ISP_SIGNATURE: // dump INISPOOLER
        movestruct(pData, &IniSpooler, INISPOOLER);
        DbgDumpIniSpooler(hCurrentProcess, Print, (PINISPOOLER)&IniSpooler);
        break;

    case IPP_SIGNATURE: // dump INIPRINTPROC structure
        movestruct(pData, &IniPrintProc, INIPRINTPROC);
        DbgDumpIniPrintProc(hCurrentProcess, Print, (PINIPRINTPROC)&IniPrintProc);
        break;

    case ID_SIGNATURE: //  dump INIDRIVER structure
        movestruct(pData, &IniDriver, INIDRIVER);
        DbgDumpIniDriver(hCurrentProcess, Print, (PINIDRIVER)&IniDriver);
        break;

    case IE_SIGNATURE: //   dump INIENVIRONMENT structure
        movestruct(pData, &IniEnvironment, INIENVIRONMENT);
        DbgDumpIniEnvironment(hCurrentProcess, Print, (PINIENVIRONMENT)&IniEnvironment);
        break;

    case IV_SIGNATURE: //   dump INIVERSION structure
        movestruct(pData, &IniVersion, INIVERSION);
        DbgDumpIniVersion(hCurrentProcess, Print, (PINIVERSION)&IniVersion);
        break;

    case IP_SIGNATURE:
        movestruct(pData, &IniPrinter, INIPRINTER);
        DbgDumpIniPrinter(hCurrentProcess, Print, (PINIPRINTER)&IniPrinter);
        break;

    case WCIP_SIGNATURE:
        movestruct(pData, &WCacheIniPrinterExtra, WCACHEINIPRINTEREXTRA);
        DbgDumpWCacheIniPrinter(hCurrentProcess, Print, (PWCACHEINIPRINTEREXTRA)&WCacheIniPrinterExtra);
        break;

    case IN_SIGNATURE:
        movestruct(pData, &IniNetPrint, ININETPRINT);
        DbgDumpIniNetPrint(hCurrentProcess, Print, (PININETPRINT)&IniNetPrint);
        break;

    case IMO_SIGNATURE:
        movestruct(pData, &IniMonitor, INIMONITOR);
        DbgDumpIniMonitor(hCurrentProcess, Print, (PINIMONITOR)&IniMonitor);
        break;

    case IPO_SIGNATURE:
        movestruct(pData, &IniPort, INIPORT);
        DbgDumpIniPort(hCurrentProcess, Print, (PINIPORT)&IniPort);
        break;

    case WIPO_SIGNATURE:
        movestruct(pData, &WIniPort, WINIPORT);
        DbgDumpWIniPort(hCurrentProcess, Print, (PWINIPORT)&WIniPort);
        break;

    case IFO_SIGNATURE:
        movestruct(pData, &IniForm, INIFORM);
        DbgDumpIniForm(hCurrentProcess, Print, (PINIFORM)&IniForm);
        break;

    case IJ_SIGNATURE:
        movestruct(pData, &IniJob, INIJOB);
        DbgDumpIniJob(hCurrentProcess, Print, (PINIJOB)&IniJob);
        break;

    case SJ_SIGNATURE:
        movestruct(pData, &Spool, SPOOL);
        DbgDumpSpool(hCurrentProcess, Print, (PSPOOL)&Spool);
        break;

    case WSJ_SIGNATURE:
        movestruct(pData, &WSpool, WSPOOL);
        DbgDumpWSpool(hCurrentProcess, Print, (PWSPOOL)&WSpool);
        break;

    case TP_SIGNATURE:
        movestruct(pData, &Win32Thread, WIN32THREAD);
        DbgDumpWin32Thread(hCurrentProcess, Print, (PWIN32THREAD)&Win32Thread);
        break;

    case SF_SIGNATURE:
        movestruct(pData, &ShadowFile, SHADOWFILE);
        DbgDumpShadowFile(hCurrentProcess, Print, (PSHADOWFILE)&ShadowFile);
        break;

    case SF_SIGNATURE_2:
        movestruct(pData, &ShadowFile2, SHADOWFILE_2);
        DbgDumpShadowFile2(hCurrentProcess, Print, (PSHADOWFILE_2)&ShadowFile2);
        break;

    case PRINTHANDLE_SIGNATURE:
        movestruct(pData, &PrintHandle, PRINTHANDLE);
        DbgDumpPrintHandle(hCurrentProcess, Print, (PPRINTHANDLE)&PrintHandle);
        break;


    default:
        // Unknown signature -- no data to dump
        (*Print)("Warning: Unknown Signature\n");
        break;
    }
    (*Print)("\n");

    return TRUE;
}

BOOL
DbgDumpIniEntry(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIENTRY pIniEntry)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniEntry\n");
    (*Print)("DWORD         signature                       %d\n", pIniEntry->signature);
    (*Print)("PINIENTRY     pNext                           %p\n", pIniEntry->pNext);

    movestr(pIniEntry->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

    return TRUE;
}

BOOL
DbgDumpIniPrintProc(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPRINTPROC pIniPrintProc)
{
   WCHAR Buffer[MAX_PATH+1];
   DWORD i = 0;

   (*Print)("IniPrintProc\n");
   (*Print)("DWORD          signature                       %d\n", pIniPrintProc->signature);
   (*Print)("PINIPRINTPROC  pNext                           %x\n", pIniPrintProc->pNext);
   (*Print)("DWORD          cRef                            %d\n", pIniPrintProc->cRef);


    movestr(pIniPrintProc->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
   (*Print)("DWORD          pName                           %ws\n", Buffer);

    movestr(pIniPrintProc->pDLLName, Buffer, sizeof(WCHAR)*MAX_PATH);
   (*Print)("LPWSTR         pDLLName                        %ws\n", Buffer);
   (*Print)("LPWSTR         cbDatatypes                     %d\n", pIniPrintProc->cbDatatypes);
   (*Print)("LPWSTR         cDatatypes                      %d\n", pIniPrintProc->cDatatypes);
   for (i = 0; i < pIniPrintProc->cDatatypes; i++ ) {
       (*Print)("   Each of the Strings here \n");
   }
   (*Print)("HANDLE         hLibrary                        0x%.8x\n", pIniPrintProc->hLibrary);
   (*Print)("FARPROC        Install                         0x%.8x\n", pIniPrintProc->Install);
   (*Print)("FARPROC        EnumDatatypes                   0x%.8x\n", pIniPrintProc->EnumDatatypes);
   (*Print)("FARPROC        Open                            0x%.8x\n", pIniPrintProc->Open);
   (*Print)("FARPROC        Print                           0x%.8x\n", pIniPrintProc->Print);
   (*Print)("FARPROC        Close                           0x%.8x\n", pIniPrintProc->Close);
   (*Print)("FARPROC        Control                         0x%.8x\n", pIniPrintProc->Control);
   (*Print)("CRITICAL_SECTION CriticalSection               0x%.8x\n", pIniPrintProc->CriticalSection);

    return TRUE;
}

BOOL
DbgDumpIniDriver(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIDRIVER pIniDriver)
{
    WCHAR Buffer[MAX_PATH+1];
    WCHAR UnKnown[] = L"Not Initialized";
    WCHAR Kernel[] = L"Kernel Mode";
    WCHAR User[] = L"User Mode";
    SYSTEMTIME SystemTime;

    (*Print)("IniDriver\n");
    (*Print)("DWORD         signature                       %d\n", pIniDriver->signature);
    (*Print)("PINIDRIVER    pNext                           %p\n", pIniDriver->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniDriver->cRef);

     movestr(pIniDriver->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniDriver->pDriverFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDriverFile                     %ws\n", Buffer);

     movestr(pIniDriver->pConfigFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pConfigFile                     %ws\n", Buffer);

     movestr(pIniDriver->pDataFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDataFile                       %ws\n", Buffer);

     movestr(pIniDriver->pHelpFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pHelpFile                       %ws\n", Buffer);

     movestr(pIniDriver->pDependentFiles, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDependentFiles                 %ws\n", Buffer);

     movestr(pIniDriver->pMonitorName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMonitorName                    %ws\n", Buffer);
    (*Print)("PINIMONITOR   pIniLangMonitor                 %p\n", pIniDriver->pIniLangMonitor);

     movestr(pIniDriver->pDefaultDataType, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDefaultDataType                %ws\n", Buffer);

     movestr(pIniDriver->pszzPreviousNames, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszzPreviousNames               %ws\n", Buffer);

    switch (pIniDriver->dwDriverAttributes) {
    case 0:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)UnKnown);
       break;
    case 1:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)Kernel);
       break;
    case 2:
       (*Print)("DWORD         dwDriverAttributes              %ws\n", (LPWSTR)User);
       break;
    }

    (*Print)("DWORD         cVersion                        %d\n", pIniDriver->cVersion);
    (*Print)("DWORD         dwTempDir                       %d\n", pIniDriver->dwTempDir);

    movestr(pIniDriver->pszMfgName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        Manufacturer                    %ws\n", Buffer);

    movestr(pIniDriver->pszOEMUrl, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        OEM URL                         %ws\n", Buffer);

    movestr(pIniDriver->pszHardwareID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        HardwareID                      %ws\n", Buffer);

    movestr(pIniDriver->pszProvider, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        Provider                        %ws\n", Buffer);

    (*Print)("DWORDLONG     DriverVersion                   %I64x\n",  pIniDriver->dwlDriverVersion);

    if (pIniDriver->ftDriverDate.dwHighDateTime &&
        pIniDriver->ftDriverDate.dwLowDateTime  &&
        FileTimeToSystemTime(&pIniDriver->ftDriverDate, &SystemTime))
    {
        (*Print)("SYSTEMTIME    DriverDate                      %d/%d/%d  %d  %d:%d:%d.%d\n",SystemTime.wYear,
                                                                SystemTime.wMonth,
                                                                SystemTime.wDay,
                                                                SystemTime.wDayOfWeek,
                                                                SystemTime.wHour,
                                                                SystemTime.wMinute,
                                                                SystemTime.wSecond,
                                                                SystemTime.wMilliseconds);
    }
    else
    {
        (*Print)("SYSTEMTIME    DriverDate                      Not initialized\n");
    }

    (*Print)("DWORD         dwDriverFlags                   %08x", pIniDriver->dwDriverFlags);

    ExtractpIniDriverFlags(Print, pIniDriver->dwDriverFlags);
    
    return TRUE;
}

BOOL
DbgDumpIniEnvironment(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIENVIRONMENT pIniEnvironment)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniEnvironment\n");
    (*Print)("DWORD         signature                       %d\n", pIniEnvironment->signature);
    (*Print)("struct _INIENVIRONMENT *pNext                 %p\n", pIniEnvironment->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniEnvironment->cRef);

     movestr(pIniEnvironment->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniEnvironment->pDirectory, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDirectory                      %ws\n", Buffer);

    (*Print)("PINIVERSION   pIniVersion                     %p\n", pIniEnvironment->pIniVersion);
    (*Print)("PINIPRINTPROC pIniPrintProc                   %p\n", pIniEnvironment->pIniPrintProc);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniEnvironment->pIniSpooler);

    return TRUE;
}

BOOL
DbgDumpIniVersion( HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIVERSION pIniVersion )
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniVersion\n");
    (*Print)("DWORD         signature                       %d\n", pIniVersion->signature);
    (*Print)("struct _IniVersion *pNext                     %p\n", pIniVersion->pNext);

     movestr(pIniVersion->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniVersion->szDirectory, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        szDirectory                     %ws\n", Buffer);
    (*Print)("DWORD         cMajorVersion                   %d\n", pIniVersion->cMajorVersion );
    (*Print)("DWORD         cMinorVersion                   %d\n", pIniVersion->cMinorVersion );
    (*Print)("PINIDRIVER    pIniDriver                      %p\n", pIniVersion->pIniDriver );

    return TRUE;
}


BOOL
DbgDumpWCacheIniPrinter(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWCACHEINIPRINTEREXTRA pWCacheIniPrinter)
{
    WCHAR Buffer[MAX_PATH+1];


    (*Print)("WCacheIniPrinterExtra\n");
    (*Print)("DWORD         signature                       %d\n", pWCacheIniPrinter->signature);

    (*Print)("DWORD         cb                              %d\n", pWCacheIniPrinter->cb);

    (*Print)("LPPRINTER_INFO_2 pPI2                         %p\n", pWCacheIniPrinter->pPI2);
    (*Print)("DWORD         cbPI2                           %d\n", pWCacheIniPrinter->cbPI2);

    DbgDumpPI2( hCurrentProcess, Print, (UINT_PTR)pWCacheIniPrinter->pPI2, 1 );

    (*Print)("DWORD         cCacheID                        %d\n", pWCacheIniPrinter->cCacheID );
    (*Print)("DWORD         cRef                            %d\n", pWCacheIniPrinter->cRef );
    (*Print)("DWORD         dwServerVersion                 %x\n", pWCacheIniPrinter->dwServerVersion );
    (*Print)("DWORD         dwTickCount                     %x\n", pWCacheIniPrinter->dwTickCount );
    (*Print)("DWORD         Status                          0x%.8x\n", pWCacheIniPrinter->Status );
    ExtractWCachePrinterStatus( Print, pWCacheIniPrinter->Status );

    return  TRUE;
}



BOOL
DbgDumpIniPrinter(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPRINTER pIniPrinter)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniPrinter\n");
    (*Print)("DWORD         signature                       %d\n", pIniPrinter->signature);

    (*Print)("PINIPRINTER   pNext                           %p\n", pIniPrinter->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniPrinter->cRef);

     movestr(pIniPrinter->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniPrinter->pShareName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pShareName                      %ws\n", Buffer);

    (*Print)("PINIPRINTPROC pIniPrintProc                   %p\n", pIniPrinter->pIniPrintProc);

     movestr(pIniPrinter->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDatatype                       %ws\n", Buffer);

     movestr(pIniPrinter->pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pParameters                     %ws\n", Buffer);

     movestr(pIniPrinter->pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

    (*Print)("PINIDRIVER    pIniDriver                      %p\n", pIniPrinter->pIniDriver);
    (*Print)("DWORD         cbDevMode                       %d\n", pIniPrinter->cbDevMode);
    (*Print)("LPDEVMODE     pDevMode                        %p\n", pIniPrinter->pDevMode);
    (*Print)("DWORD         Priority                        %d\n", pIniPrinter->Priority);
    (*Print)("DWORD         DefaultPriority                 %d\n", pIniPrinter->DefaultPriority);
    (*Print)("DWORD         StartTime                       %d\n", pIniPrinter->StartTime);
    (*Print)("DWORD         UntilTime                       %d\n", pIniPrinter->UntilTime);

     movestr(pIniPrinter->pSepFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pSepFile                        %ws\n", Buffer);

    (*Print)("DWORD         Status                          0x%.8x\n", pIniPrinter->Status);
    ExtractPrinterStatus( Print, pIniPrinter->Status );

     movestr(pIniPrinter->pLocation, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pLocation                       %ws\n", Buffer);


    (*Print)("DWORD         Attributes                      0x%.8x\n",pIniPrinter->Attributes);
    ExtractPrinterAttributes( Print, pIniPrinter->Attributes );

    (*Print)("DWORD         cJobs                           %d\n", pIniPrinter->cJobs);
    (*Print)("DWORD         AveragePPM                      %d\n", pIniPrinter->AveragePPM);
    (*Print)("BOOL          GenerateOnClose                 0x%.8x\n", pIniPrinter->GenerateOnClose);
    (*Print)("PINIPORT      pIniNetPort                     %p\n", pIniPrinter->pIniNetPort);
    (*Print)("PINIJOB       pIniFirstJob                    %p\n", pIniPrinter->pIniFirstJob);
    (*Print)("PINIJOB       pIniLastJob                     %p\n", pIniPrinter->pIniLastJob);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pIniPrinter->pSecurityDescriptor);
    (*Print)("PSPOOL        *pSpool                         %p\n", pIniPrinter->pSpool);

    if ( pIniPrinter->pSpoolDir == NULL ) {

        (*Print)("LPWSTR        pSpoolDir                       %p\n", pIniPrinter->pSpoolDir);

    } else {

        movestr(pIniPrinter->pSpoolDir, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pSpoolDir                       %ws\n", Buffer);
    }

    (*Print)("DWORD         cTotalJobs                      %d\n", pIniPrinter->cTotalJobs);
    (*Print)("DWORD         cTotalBytes.LowPart             %d\n", pIniPrinter->cTotalBytes.LowPart);
    (*Print)("DWORD         cTotalBytes.HighPart            %d\n", pIniPrinter->cTotalBytes.HighPart);
    (*Print)("SYSTEMTIME    stUpTime                        %d/%d/%d  %d  %d:%d:%d.%d\n",pIniPrinter->stUpTime.wYear,
                                                                pIniPrinter->stUpTime.wMonth,
                                                                pIniPrinter->stUpTime.wDay,
                                                                pIniPrinter->stUpTime.wDayOfWeek,
                                                                pIniPrinter->stUpTime.wHour,
                                                                pIniPrinter->stUpTime.wMinute,
                                                                pIniPrinter->stUpTime.wSecond,
                                                                pIniPrinter->stUpTime.wMilliseconds);
    (*Print)("DWORD         MaxcRef                         %d\n", pIniPrinter->MaxcRef);
    (*Print)("DWORD         cTotalPagesPrinted              %d\n", pIniPrinter->cTotalPagesPrinted);
    (*Print)("DWORD         cSpooling                       %d\n", pIniPrinter->cSpooling);
    (*Print)("DWORD         cMaxSpooling                    %d\n", pIniPrinter->cMaxSpooling);
    (*Print)("DWORD         cErrorOutOfPaper                %d\n", pIniPrinter->cErrorOutOfPaper);
    (*Print)("DWORD         cErrorNotReady                  %d\n", pIniPrinter->cErrorNotReady);
    (*Print)("DWORD         cJobError                       %d\n", pIniPrinter->cJobError);
    (*Print)("DWORD         dwLastError                     %d\n", pIniPrinter->dwLastError);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniPrinter->pIniSpooler);
    (*Print)("DWORD         cZombieRef                      %d\n", pIniPrinter->cZombieRef);
    (*Print)("LPBYTE        pExtraData                      %x\n", pIniPrinter->pExtraData);
    (*Print)("DWORD         cChangeID                       %d\n", pIniPrinter->cChangeID);
    (*Print)("DWORD         cPorts                          %d\n", pIniPrinter->cPorts);
    (*Print)("PINIPORT      *ppIniPorts                     %x\n", pIniPrinter->ppIniPorts);
    (*Print)("DWORD         PortStatus                      %d\n", pIniPrinter->PortStatus);
    (*Print)("DWORD         dnsTimeout                      %d\n", pIniPrinter->dnsTimeout);
    (*Print)("DWORD         txTimeout                       %d\n", pIniPrinter->txTimeout);
     movestr(pIniPrinter->pszObjectGUID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszObjectGUID                   %ws\n", Buffer);
    (*Print)("DWORD         DsKeyUpdate                     %x\n", pIniPrinter->DsKeyUpdate);
    (*Print)("DWORD         DsKeyUpdateForeground           %x\n", pIniPrinter->DsKeyUpdateForeground);
     movestr(pIniPrinter->pszDN, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszDN                           %ws\n", Buffer);
     movestr(pIniPrinter->pszCN, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszCN                           %ws\n", Buffer);
    (*Print)("DWORD         cRefIC                          %d\n", pIniPrinter->cRefIC);
    (*Print)("DWORD         dwAction                        %d\n", pIniPrinter->dwAction);
    (*Print)("BOOL          bDsPendingDeletion              %d\n", pIniPrinter->bDsPendingDeletion);

    return TRUE;
}


BOOL
DbgDumpIniNetPrint(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PININETPRINT pIniNetPrint)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniNetPrint\n");
    (*Print)("DWORD         signature                       %d\n", pIniNetPrint->signature);
    (*Print)("PININETPRINT  *pNext                          %p\n", pIniNetPrint->pNext);
    (*Print)("DWORD         TickCount                       %d\n", pIniNetPrint->TickCount);

     movestr(pIniNetPrint->pDescription, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDescription                    %ws\n", Buffer);

     movestr(pIniNetPrint->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniNetPrint->pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

    return TRUE;
}


BOOL
DbgDumpIniMonitor(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIMONITOR pIniMonitor)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniMonitor\n");
    (*Print)("DWORD         signature                       %d\n", pIniMonitor->signature);
    (*Print)("PINIMONITOR   pNext                           %p\n", pIniMonitor->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniMonitor->cRef);

     movestr(pIniMonitor->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

     movestr(pIniMonitor->pMonitorDll, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMonitorDll                     %ws\n", Buffer);

    (*Print)("HANDLE        hModule                         %p\n", pIniMonitor->hModule);
    (*Print)("PMONITORINIT  pMonitorInit                    %p\n", pIniMonitor->pMonitorInit);
    (*Print)("HANDLE        hMonitor                        %p\n", pIniMonitor->hMonitor);
    (*Print)("BOOL          bUplevel                        %%.8x\n", pIniMonitor->bUplevel);
    (*Print)("PINISPOOLER   pIniSpooler                     %p\n", pIniMonitor->pIniSpooler);

    return TRUE;
}

BOOL
DbgDumpIniPort(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIPORT pIniPort)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniPort\n");
    (*Print)("DWORD             signature                       %d\n", pIniPort->signature);
    (*Print)("struct            _INIPORT *pNext                 %p\n", pIniPort->pNext);
    (*Print)("DWORD             cRef                            0x%.8x\n", pIniPort->cRef);

     movestr(pIniPort->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR            pName                           %ws\n", Buffer);
    (*Print)("HANDLE            hProc                           0x%.8x\n", pIniPort->hProc);
    (*Print)("DWORD             Status                          0x%.8x\n", pIniPort->Status);
    ExtractpIniPortStatus( Print, pIniPort->Status);
    ExtractPortStatus( Print, pIniPort->PrinterStatus);

    (*Print)("HANDLE            Semaphore                       0x%.8x\n", pIniPort->Semaphore);
    (*Print)("PINIJOB           pIniJob                         %p\n", pIniPort->pIniJob);
    (*Print)("DWORD             cJobs                           %d\n", pIniPort->cJobs);
    (*Print)("DWORD             cPrinters                       %d\n", pIniPort->cPrinters);
    (*Print)("PINIPRINTER       *ppIniPrinter                   %p\n", pIniPort->ppIniPrinter);

    (*Print)("PINIMONITOR       pIniMonitor                     %p\n", pIniPort->pIniMonitor);
    (*Print)("PINIMONITOR       pIniLangMonitor                 %p\n", pIniPort->pIniLangMonitor);
    (*Print)("HANDLE            hEvent                          0x%.8x\n", pIniPort->hEvent);
    (*Print)("HANDLE            hMonitorHandle                  0x%.8x\n", pIniPort->hMonitorHandle);
    (*Print)("CRITICAL_SECTION  MonitorCS                       0x%.8x\n", pIniPort->MonitorCS);
    (*Print)("HANDLE            Ready                           0x%.8x\n", pIniPort->Ready);
    (*Print)("HANDLE            hPortThread                     0x%.8x\n", pIniPort->hPortThread);
    (*Print)("DWORD             IdleTime                        %d\n", pIniPort->IdleTime);
    (*Print)("DWORD             ErrorTime                       %d\n", pIniPort->ErrorTime);
    (*Print)("PINISPOOLER       pIniSpooler                     %p\n", pIniPort->pIniSpooler);
    (*Print)("DWORD             InCriticalSection               %d\n", pIniPort->InCriticalSection);
    (*Print)("HANDLE            hPortThreadRunning              0x%.8x\n", pIniPort->hPortThreadRunning);
    (*Print)("BOOL              bIdleTimeValid                  %%.8x\n", pIniPort->bIdleTimeValid);

    return TRUE;
}

BOOL
DbgDumpWIniPort(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWINIPORT pWIniPort)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("WIniPort\n");
    (*Print)("DWORD         signature                       %d\n", pWIniPort->signature);
    (*Print)("DWORD         cb                              %d\n", pWIniPort->cb);
    (*Print)("struct        _WIniPort *pNext                 %p\n", pWIniPort->pNext);

     movestr(pWIniPort->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %ws\n", Buffer);

    return TRUE;
}


BOOL
DbgDumpIniForm(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIFORM pIniForm)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniForm\n");
    (*Print)("DWORD         signature                       %d\n", pIniForm->signature);
    (*Print)("struct        _INIFORM *pNext                 %p\n", pIniForm->pNext);
    (*Print)("DWORD         cRef                            %d\n", pIniForm->cRef);

    movestr(pIniForm->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pName                           %p %ws\n", pIniForm->pName, Buffer );

    (*Print)("SIZEL         Size                            cx %d cy %d\n", pIniForm->Size.cx, pIniForm->Size.cy);
    (*Print)("RECTL         ImageableArea                   left %d right %d top %d bottom %d\n",
                                                             pIniForm->ImageableArea.left,
                                                             pIniForm->ImageableArea.right,
                                                             pIniForm->ImageableArea.top,
                                                             pIniForm->ImageableArea.bottom);
    (*Print)("DWORD         Type                            0x%.8x", pIniForm->Type);

    if ( pIniForm->Type & FORM_BUILTIN )
        (*Print)(" FORM_BUILTIN\n");
    else
        (*Print)(" FORM_USERDEFINED\n");

    (*Print)("DWORD         cFormOrder                      %d\n", pIniForm->cFormOrder);

    return TRUE;
}

BOOL
DbgDumpIniSpooler(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINISPOOLER pIniSpooler)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniSpooler\n" );
    (*Print)("DWORD         signature                       %d\n", pIniSpooler->signature);
    (*Print)("PINISPOOLER   pIniNextSpooler                 %p\n", pIniSpooler->pIniNextSpooler);
    (*Print)("DWORD         cRef                            %d\n",     pIniSpooler->cRef);
    movestr(pIniSpooler->pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pMachineName                    %ws\n", Buffer);
    movestr(pIniSpooler->pDir, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDir                            %ws\n", Buffer);
    (*Print)("PINIPRINTER   pIniPrinter                     %p\n", pIniSpooler->pIniPrinter);
    (*Print)("PINIENVIRONMENT pIniEnvironment               %p\n", pIniSpooler->pIniEnvironment);
    (*Print)("PINIMONITOR   pIniMonitor                     %p\n", pIniSpooler->pIniMonitor);
    (*Print)("PINIPORT      pIniPort                        %p\n", pIniSpooler->pIniPort);
    (*Print)("PSHARED       pShared                         %p\n", pIniSpooler->pShared);
    (*Print)("PININETPRINT  pIniNetPrint                    %p\n", pIniSpooler->pIniNetPrint);
    (*Print)("PSPOOL        pSpool                          %p\n", pIniSpooler->pSpool);
    movestr(pIniSpooler->pDefaultSpoolDir, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pDefaultSpoolDir                %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryMonitors, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryMonitors             %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryEnvironments, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryEnvironments         %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryEventLog, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryEventLog             %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryProviders, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryProviders            %ws\n", Buffer);
    movestr(pIniSpooler->pszEventLogMsgFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszEventLogMsgFile              %ws\n", Buffer);
    (*Print)("PSHARE_INFO_2 pDriversShareInfo               %p\n", pIniSpooler->pDriversShareInfo);
    movestr(pIniSpooler->pszDriversShare, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszDriversShare                 %ws\n", Buffer);
    movestr(pIniSpooler->pszRegistryForms, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszRegistryForms                %ws\n", Buffer);
    (*Print)("DWORD         SpoolerFlags                    %d\n", pIniSpooler->SpoolerFlags );
    ExtractSpoolerFlags( Print, pIniSpooler->SpoolerFlags );
    (*Print)("FARPROC       pfnReadRegistryExtra            0x%.8x\n", pIniSpooler->pfnReadRegistryExtra );
    (*Print)("FARPROC       pfnWriteRegistryExtra           0x%.8x\n", pIniSpooler->pfnWriteRegistryExtra );
    (*Print)("FARPROC       pfnFreePrinterExtra             0x%.8x\n", pIniSpooler->pfnFreePrinterExtra );
    (*Print)("DWORD         cEnumerateNetworkPrinters       %d\n", pIniSpooler->cEnumerateNetworkPrinters );
    (*Print)("DWORD         cAddNetPrinters                 %d\n", pIniSpooler->cAddNetPrinters );
    (*Print)("DWORD         cFormOrderMax                   %d\n", pIniSpooler->cFormOrderMax );
    (*Print)("HKEY          hckRoot                         %p\n", pIniSpooler->hckRoot );
    (*Print)("HKEY          hckPrinters                     %p\n", pIniSpooler->hckPrinters );
    (*Print)("DWORD         cFullPrintingJobs               %d\n", pIniSpooler->cFullPrintingJobs );
    (*Print)("DWORD         hEventNoPrintingJobs            %p\n", pIniSpooler->hEventNoPrintingJobs );
    (*Print)("HKEY          hJobIdMap                       %p\n", pIniSpooler->hJobIdMap );
    (*Print)("DWORD         dwEventLogging                  %d\n", pIniSpooler->dwEventLogging );
    (*Print)("BOOL          bEnableNetPopups                %d\n", pIniSpooler->bEnableNetPopups );
    (*Print)("DWORD         dwJobCompletionTimeout          %d\n", pIniSpooler->dwJobCompletionTimeout );
    (*Print)("DWORD         dwBeepEnabled                   %d\n", pIniSpooler->dwBeepEnabled );
    (*Print)("HKEY          bEnableNetPopupToComputer       %d\n", pIniSpooler->bEnableNetPopupToComputer );
    (*Print)("HKEY          bEnableRetryPopups              %d\n", pIniSpooler->bEnableRetryPopups );
    movestr(pIniSpooler->pszClusterSID, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszClusterSID                  %ws\n", Buffer);
    (*Print)("HKEY          hClusterToken                   %p\n", pIniSpooler->hClusterToken );
    (*Print)("DWORD         dwRestartJobOnPoolTimeout       %p\n", pIniSpooler->dwRestartJobOnPoolTimeout );
    (*Print)("DWORD         bRestartJobOnPoolEnabled        %p\n", pIniSpooler->bRestartJobOnPoolEnabled );
    (*Print)("DWORD         bImmortal                       %p\n", pIniSpooler->bImmortal );
    movestr(pIniSpooler->pszFullMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR        pszFullMachineName              %ws\n", Buffer);
    return TRUE;
}

BOOL
DbgDumpIniJob(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PINIJOB pIniJob)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("IniJob\n");
    (*Print)("DWORD           signature                     %d\n", pIniJob->signature);
    (*Print)("PINIJOB         pIniNextJob                   %p\n", pIniJob->pIniNextJob);
    (*Print)("PINIJOB         pIniPrevJob                   %p\n", pIniJob->pIniPrevJob);
    (*Print)("DWORD           cRef                          %d\n", pIniJob->cRef);
    (*Print)("DWORD           Status                        0x%.8x\n", pIniJob->Status);
    ExtractJobStatus( Print, pIniJob->Status );

    (*Print)("DWORD           JobId                         %d\n", pIniJob->JobId);
    (*Print)("DWORD           Priority                      %d\n", pIniJob->Priority);

     movestr(pIniJob->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pIniJob->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pIniJob->pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pMachineName                  %ws\n", Buffer);

     movestr(pIniJob->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pIniJob->pOutputFile, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pOutputFile                   %ws\n", Buffer);

    (*Print)("PINIPRINTER     pIniPrinter                   %p\n", pIniJob->pIniPrinter);
    (*Print)("PINIDRIVER      pIniDriver                    %p\n", pIniJob->pIniDriver);
    (*Print)("LPDEVMODE       pDevMode                      %p\n", pIniJob->pDevMode);
    (*Print)("PINIPRINTPROC   pIniPrintProc                 %p\n", pIniJob->pIniPrintProc);

     movestr(pIniJob->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pIniJob->pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    (*Print)("SYSTEMTIME      Submitted                     %d/%d/%d  %d  %d:%d:%d.%d\n",pIniJob->Submitted.wYear,
                                                                pIniJob->Submitted.wMonth,
                                                                pIniJob->Submitted.wDay,
                                                                pIniJob->Submitted.wDayOfWeek,
                                                                pIniJob->Submitted.wHour,
                                                                pIniJob->Submitted.wMinute,
                                                                pIniJob->Submitted.wSecond,
                                                                pIniJob->Submitted.wMilliseconds);
//    (*Print)("DWORD           StartPrintingTickCount        %d\n", pIniJob->StartPrintingTickCount );
    (*Print)("DWORD           Time                          %d\n", pIniJob->Time);
    (*Print)("DWORD           StartTime                     %d\n", pIniJob->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pIniJob->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pIniJob->Size);
    (*Print)("HANDLE          hWriteFile                    0x%.8x\n", pIniJob->hWriteFile);

     movestr(pIniJob->pStatus, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pStatus                       %ws\n", Buffer);

    (*Print)("PBOOL           pBuffer                       %p\n", pIniJob->pBuffer);
    (*Print)("DWORD           cbBuffer                      %d\n", pIniJob->cbBuffer);
    (*Print)("HANDLE          WaitForRead                   0x%.8x\n", pIniJob->WaitForRead);
    (*Print)("HANDLE          WaitForWrite                  0x%.8x\n", pIniJob->WaitForWrite);
    (*Print)("HANDLE          StartDocComplete              0x%.8x\n", pIniJob->StartDocComplete);
    (*Print)("DWORD           StartDocError                 0x%.8x\n", pIniJob->StartDocError);
    (*Print)("PINIPORT        pIniPort                      %p\n", pIniJob->pIniPort);
    (*Print)("HANDLE          hToken                        0x%.8x\n", pIniJob->hToken);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pIniJob->pSecurityDescriptor);
    (*Print)("DWORD           cPagesPrinted                 %d\n", pIniJob->cPagesPrinted);
    (*Print)("DWORD           cPages                        %d\n", pIniJob->cPages);
    (*Print)("DWORD           dwJobNumberOfPagesPerSide     %d\n", pIniJob->dwJobNumberOfPagesPerSide);
    (*Print)("DWORD           dwDrvNumberOfPagesPerSide     %d\n", pIniJob->dwDrvNumberOfPagesPerSide);
    (*Print)("DWORD           cLogicalPagesPrinted          %d\n", pIniJob->cLogicalPagesPrinted);
    (*Print)("DWORD           cLogicalPages                 %d\n", pIniJob->cLogicalPages);
    (*Print)("BOOL            GenerateOnClose               0x%.8x\n", pIniJob->GenerateOnClose);
    (*Print)("DWORD           cbPrinted                     %d\n", pIniJob->cbPrinted);
    (*Print)("DWORD           NextJobId                     %d\n", pIniJob->NextJobId);
    (*Print)("PINIJOB         pCurrentIniJob                %p\n", pIniJob->pCurrentIniJob);
    (*Print)("DWORD           dwJobControlsPending          %d\n", pIniJob->dwJobControlsPending);
    (*Print)("DWORD           dwReboots                     %d\n", pIniJob->dwReboots);
    (*Print)("DWORD           dwValidSize                   %d\n", pIniJob->dwValidSize);
    (*Print)("DWORD           bWaitForEnd                   %d\n", pIniJob->bWaitForEnd);
    (*Print)("DWORD           WaitForSeek                   %d\n", pIniJob->WaitForSeek);
    (*Print)("DWORD           bWaitForSeek                  %d\n", pIniJob->bWaitForSeek);
    (*Print)("DWORD           dwAlert                       %d\n", pIniJob->dwAlert);

    movestr(pIniJob->pszSplFileName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pszSplFileName                %ws\n", Buffer);

    (*Print)("HANDLE          hFileItem                     0x%.8x\n", pIniJob->hFileItem);
    (*Print)("DWORD           AddJobLevel                   %d\n", pIniJob->AddJobLevel);

    return TRUE;
}

BOOL
DbgDumpProvidor(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, LPPROVIDOR pProvidor)
{
    WCHAR Buffer[MAX_PATH+1];

    movestr(pProvidor->lpName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR         ProvidorName                   %ws\n", Buffer);
    (*Print)("HANDLE         hModule                        %p\n", pProvidor->hModule);

    return TRUE;
}


BOOL
DbgDumpSpool(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSPOOL pSpool)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("Spool - LocalSpl Handle\n");
    (*Print)("DWORD           signature                     %d\n", pSpool->signature);
    (*Print)("struct _SPOOL  *pNext                         %p\n", pSpool->pNext);
    (*Print)("DWORD           cRef                          %d\n", pSpool->cRef);

     movestr(pSpool->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pName                         %ws\n", Buffer);

     movestr(pSpool->pFullMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pFullMachineName              %ws\n", Buffer);

     movestr(pSpool->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n",    Buffer);
    (*Print)("PINIPRINTPROC   pIniPrintProc                 %p\n", pSpool->pIniPrintProc);
    (*Print)("LPDEVMODE       pDevMode                      %p\n", pSpool->pDevMode);
    (*Print)("PINIPRINTER     pIniPrinter                   %p\n", pSpool->pIniPrinter);
    (*Print)("PINIPORT        pIniPort                      %p\n", pSpool->pIniPort);
    (*Print)("PINIJOB         pIniJob                       %p\n", pSpool->pIniJob);
    (*Print)("DWORD           TypeofHandle                  %d\n", pSpool->TypeofHandle);
    ExtractpSpoolTypeOfHandle( Print, pSpool->TypeofHandle);

    (*Print)("PINIPORT        pIniNetPort                   %p\n", pSpool->pIniNetPort);
    (*Print)("HANDLE          hPort                         %p\n", pSpool->hPort);
    (*Print)("DWORD           Status                        %d\n", pSpool->Status);
    ExtractpSpoolStatus( Print, pSpool->Status);

    (*Print)("ACCESS_MASK     GrantedAccess                 %p\n", (DWORD)pSpool->GrantedAccess);
    (*Print)("DWORD           ChangeFlags                   %p\n", pSpool->ChangeFlags);
    (*Print)("DWORD           WaitFlags                     %x\n", pSpool->WaitFlags);
    (*Print)("PDWORD          pChangeFlags                  %p\n", pSpool->pChangeFlags);
    (*Print)("HANDLE          ChangeEvent                   %d\n", pSpool->ChangeEvent);
    (*Print)("DWORD           OpenPortError                 %x\n", pSpool->OpenPortError);
    (*Print)("HANDLE          hNotify                       %p\n", pSpool->hNotify);
    (*Print)("ESTATUS         eStatus                       %d\n", pSpool->eStatus);
    (*Print)("pIniSpooler     pIniSpooler                   %p\n", pSpool->pIniSpooler);
    (*Print)("PINIXCV         pIniXcv                       %p\n", pSpool->pIniXcv);
     movestr(pSpool->SplClientInfo1.pUserName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUserName                     %ws\n",    Buffer);
     movestr(pSpool->SplClientInfo1.pMachineName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pMachineName                  %ws\n",    Buffer);

    return TRUE;
}


BOOL
DbgDumpWSpool(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWSPOOL pWSpool)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("WSpool - Win32Spl Handle\n");
    (*Print)("DWORD           signature                     %d\n", pWSpool->signature);
    (*Print)("struct _WSPOOL  *pNext                        %p\n", pWSpool->pNext);
    (*Print)("struct _WSPOOL  *pPrev                        %p\n", pWSpool->pPrev);
    
     Buffer[0] = L'\0';
     movestr(pWSpool->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pName                         %ws\n", Buffer);
     Buffer[0] = L'\0';

    (*Print)("DWORD           Type                          %d\n", pWSpool->Type);

    if ( pWSpool->Type == SJ_WIN32HANDLE )
        (*Print)(" SJ_WIN32HANDLE\n");

    if ( pWSpool->Type == LM_HANDLE )
        (*Print)(" LM_HANDLE\n");

    (*Print)("HANDLE          RpcHandle                     %p\n", pWSpool->RpcHandle);

     movestr(pWSpool->pServer, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pServer                       %ws\n", Buffer);
     Buffer[0] = L'\0';

     movestr(pWSpool->pShare, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pShare                        %ws\n", Buffer);
     Buffer[0] = L'\0';

    (*Print)("HANDLE          hFile                         %p\n", pWSpool->hFile);
    (*Print)("DWORD           Status                        %d\n", pWSpool->Status);
    ExtractWSpoolStatus( Print, pWSpool->Status );

    (*Print)("DWORD           RpcError                      %d\n", pWSpool->RpcError);
    (*Print)("LMNOTIFY        LMNotify                      %p %p %p\n", pWSpool->LMNotify.ChangeEvent,
                                                                         pWSpool->LMNotify.hNotify,
                                                                         pWSpool->LMNotify.fdwChangeFlags );

    (*Print)("HANDLE          hIniSpooler                   %p\n", pWSpool->hIniSpooler );
    (*Print)("HANDLE          hSplPrinter                   %p\n", pWSpool->hSplPrinter );

     movestr(pWSpool->PrinterDefaults.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          PrinterDefaults.pDatatype     %ws\n",    Buffer);
    Buffer[0] = L'\0';
    (*Print)("LPDEVMODE       PrinterDefaults.pDevMode      %p\n", pWSpool->PrinterDefaults.pDevMode);
    (*Print)("ACCESS_MASK     PrinterDefaults.DesiredAccess %x\n", pWSpool->PrinterDefaults.DesiredAccess);
    ExtractPrinterAccess( Print, pWSpool->PrinterDefaults.DesiredAccess);
    (*Print)("BOOL            bNt3xServer                   %d\n", pWSpool->bNt3xServer);
    (*Print)("PWIN32THREAD    pThread                       %p\n", pWSpool->pThread);

    return TRUE;
}


BOOL
DbgDumpWin32Thread(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PWIN32THREAD pThread)
{
    WCHAR Buffer[MAX_PATH+1];
    BYTE    Sid[256];
    CHAR    SidString[256];
    PRINTER_DEFAULTSW PrinterDefaults;
    
    (*Print)("Win32Thread - Win32Spl Thread Object\n");
    (*Print)("DWORD                  signature                     %d\n", pThread->signature);
    
    Buffer[0] = L'\0';
    movestr(pThread->pName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR                 pName                         %ws\n", Buffer);
    Buffer[0] = L'\0';

    (*Print)("HANDLE                 hRpcHandle                    %p\n", pThread->hRpcHandle);

    movestruct(pThread->pDefaults, &PrinterDefaults, PRINTER_DEFAULTSW);
    movestr(PrinterDefaults.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR                 pDefaults->pDatatype          %ws\n", Buffer);
    Buffer[0] = L'\0';
    (*Print)("LPDEVMODE              pDefaults->pDevMode           %p\n", PrinterDefaults.pDevMode);
    (*Print)("ACCESS_MASK            pDefaults->DesiredAccess      %x\n", PrinterDefaults.DesiredAccess);
    ExtractPrinterAccess( Print, PrinterDefaults.DesiredAccess);

    (*Print)("DWORD                  dwStatus                      %d\n", pThread->dwStatus);
    ExtractWin32ThreadStatus(Print, pThread->dwStatus);

    (*Print)("struct _win32thread    pNext                         %p\n", pThread->pNext);
    (*Print)("HANDLE                 hToken                        %p\n", pThread->hToken);
    (*Print)("HANDLE                 hWaitValidHandle              %p\n", pThread->hWaitValidHandle);
    (*Print)("DWORD                  dwRpcOpenPrinterError         %d\n", pThread->dwRpcOpenPrinterError);
    
    memset(Sid, 0,  sizeof(Sid));
    movemem(pThread->pSid, Sid, sizeof(Sid));
    ConvertSidToAsciiString(Sid, SidString, COUNTOF(SidString));
    (*Print)("PSID                   pSid                          %s\n", SidString);

    return TRUE;
}


BOOL
DbgDumpShadowFile(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSHADOWFILE pShadowFile)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("ShadowFile\n");
    (*Print)("DWORD           signature                     %d\n", pShadowFile->signature);
    (*Print)("DWORD           Status                        0x%.8x\n", pShadowFile->Status);
    (*Print)("DWORD           JobId                         %d\n", pShadowFile->JobId);
    (*Print)("DWORD           Priority                      %d\n", pShadowFile->Priority);

     movestr(pShadowFile->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pShadowFile->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pShadowFile->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pShadowFile->pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrinterName               %ws\n", Buffer);

     movestr(pShadowFile->pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDriverName                   %ws\n", Buffer);

    (*Print)("LPDEVMODE       pDevMode                      %p\n", pShadowFile->pDevMode);

     movestr(pShadowFile->pPrintProcName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrintProcName             %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    //SYSTEMTIME      Submitted;
    (*Print)("DWORD           StartTime                     %d\n", pShadowFile->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pShadowFile->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pShadowFile->Size);
    (*Print)("DWORD           cPages                        %d\n", pShadowFile->cPages);
    (*Print)("DWORD           cbSecurityDescriptor          %d\n", pShadowFile->cbSecurityDescriptor);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pShadowFile->pSecurityDescriptor);

    return TRUE;
}


BOOL
DbgDumpShadowFile2(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSHADOWFILE_2 pShadowFile)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("ShadowFile2\n");
    (*Print)("DWORD           signature                     %x\n", pShadowFile->signature);
    (*Print)("DWORD           Status                        0x%.8x\n", pShadowFile->Status);
    (*Print)("DWORD           JobId                         %d\n", pShadowFile->JobId);
    (*Print)("DWORD           Priority                      %d\n", pShadowFile->Priority);

     movestr(pShadowFile->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pShadowFile->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pShadowFile->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pShadowFile->pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrinterName               %ws\n", Buffer);

     movestr(pShadowFile->pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDriverName                   %ws\n", Buffer);

    (*Print)("LPDEVMODE       pDevMode                      %p\n", pShadowFile->pDevMode);

     movestr(pShadowFile->pPrintProcName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrintProcName             %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    //SYSTEMTIME      Submitted;
    (*Print)("DWORD           StartTime                     %d\n", pShadowFile->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pShadowFile->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pShadowFile->Size);
    (*Print)("DWORD           cPages                        %d\n", pShadowFile->cPages);
    (*Print)("DWORD           cbSecurityDescriptor          %d\n", pShadowFile->cbSecurityDescriptor);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pShadowFile->pSecurityDescriptor);
    (*Print)("DWORD           Version                       %d\n", pShadowFile->Version);
    (*Print)("DWORD           dwReboots                     %d\n", pShadowFile->dwReboots);

    return TRUE;
}


BOOL
DbgDumpPrintHandle(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PPRINTHANDLE pPrintHandle)
{
    NOTIFY Notify;

    (*Print)("PrintHandle\n");
    (*Print)("DWORD               signature  %d\n", pPrintHandle->signature);
    (*Print)("LPPROVIDOR          pProvidor  %p\n", pPrintHandle->pProvidor);
    (*Print)("HANDLE               hPrinter  0x%.8x\n", pPrintHandle->hPrinter);
    (*Print)("PCHANGE               pChange  %p\n", pPrintHandle->pChange);

    if (pPrintHandle->pChange) {
        DbgDumpChange(hCurrentProcess, Print, pPrintHandle->pChange);
    }

    (*Print)("PNOTIFY               pNotify  %p\n", pPrintHandle->pNotify);

    if (pPrintHandle->pNotify) {
        movestruct(pPrintHandle->pNotify, &Notify, NOTIFY);
        DbgDumpNotify(hCurrentProcess, Print, &Notify);
    }

    (*Print)("PPRINTHANDLE            pNext  %p\n", pPrintHandle->pNext);
    (*Print)("DWORD           fdwReplyTypes  0x%.8x\n", pPrintHandle->fdwReplyTypes);

    return TRUE;
}

BOOL
DbgDumpChange(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PCHANGE pChange)
{

    WCHAR Buffer[MAX_PATH+1];
    CHANGE Change;

    // if we've got no address, then quit now - nothing we can do

    if (!pChange) {
        return(0);
    }


    movestruct(pChange, &Change, CHANGE);

    if (Change.signature != CHANGEHANDLE_SIGNATURE) {
        (*Print)("Warning: Unknown Signature\n");
        return FALSE;
    }

    (*Print)("Change %p\n", pChange);
    (*Print)("                         Link  %p\n", Change.Link.pNext);
    (*Print)("                    signature  %d\n", Change.signature);
    (*Print)("                      eStatus  0x%x ", Change.eStatus);
    ExtractChangeStatus(Print, Change.eStatus);

    (*Print)("                      dwColor  %d\n", Change.dwColor);
    (*Print)("                         cRef  %d\n", Change.cRef);

    movestr(Change.pszLocalMachine, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("              pszLocalMachine  %ws\n", Buffer);

    DbgDumpChangeInfo(hCurrentProcess, Print, &Change.ChangeInfo);

    (*Print)("                      dwCount  0x%.8x\n", Change.dwCount);
    (*Print)("                       hEvent  0x%.8x\n", Change.hEvent);
    (*Print)("               fdwChangeFlags  0x%.8x\n", Change.fdwChangeFlags);
    (*Print)("              dwPrinterRemote  0x%.8x\n", Change.dwPrinterRemote);
    (*Print)("                hNotifyRemote  0x%.8x\n", Change.hNotifyRemote);

    return TRUE;
}

BOOL
DbgDumpNotify(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PNOTIFY pNotify)
{
    (*Print)("Notify\n");
    (*Print)("                  signature  %d\n", pNotify->signature);
    (*Print)("               pPrintHandle  %p\n", pNotify->pPrintHandle);

    return TRUE;
}

BOOL
DbgDumpChangeInfo(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PCHANGEINFO pChangeInfo)
{
    (*Print)("  ChangeInfo %x\n", pChangeInfo);
    (*Print)("                    Link  %p\n", pChangeInfo->Link.pNext);
    (*Print)("            pPrintHandle  %p\n", pChangeInfo->pPrintHandle);
    (*Print)("              fdwOptions  0x%.8x\n", pChangeInfo->fdwOptions);
    (*Print)("          fdwFilterFlags  0x%.8x\n", pChangeInfo->fdwFilterFlags);
    (*Print)("                dwStatus  0x%.8x\n", pChangeInfo->fdwStatus);
    (*Print)("              dwPollTime  0x%.8x\n", pChangeInfo->dwPollTime);
    (*Print)("          dwPollTimeLeft  0x%.8x\n", pChangeInfo->dwPollTimeLeft);
    (*Print)("          bResetPollTime  0x%.8x\n", pChangeInfo->bResetPollTime);
    (*Print)("                fdwFlags  0x%.8x\n", pChangeInfo->fdwFlags);
    (*Print)("      pPrinterNotifyInfo  %p\n", pChangeInfo->pPrinterNotifyInfo);

    return TRUE;
}

BOOL
DbgDumpLL(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pAddress,
    BOOL  bCountOn,
    DWORD dwCount,
    PUINT_PTR  pNextAddress
    )
{

    INIDRIVER IniDriver;
    INIENVIRONMENT IniEnvironment;
    INIPRINTER IniPrinter;
    INIPRINTPROC IniPrintProc;
    ININETPRINT IniNetPrint;
    INIMONITOR IniMonitor;
    INIPORT IniPort;
    WINIPORT WIniPort;
    INIFORM IniForm;
    INIJOB  IniJob;
    INISPOOLER IniSpooler;
    SPOOL   Spool;
    WSPOOL  WSpool;
    WIN32THREAD Win32Thread;
    SHADOWFILE  ShadowFile;
    SHADOWFILE_2  ShadowFile2;
    DWORD   Signature;
    UINT_PTR NextAddress;
    PRINTHANDLE PrintHandle;
    INIVERSION IniVersion;
    WCACHEINIPRINTEREXTRA WCacheIniPrinterExtra;
    BOOL    bRetval = TRUE;
    DWORD   i;

    if (!pAddress) {
        *pNextAddress = 0;
        return FALSE ;
    }

    if (bCountOn && (dwCount == 0)) {
        *pNextAddress = (UINT_PTR)pAddress;
        return FALSE ;
    }

    for (i=0; pAddress && (!bCountOn || i < dwCount); i++)
    {
        movestruct(pAddress,&Signature, DWORD);

        (*Print)("\n%p ",pAddress);

        switch (Signature) {

        case ISP_SIGNATURE: // dump INISPOOLER
            movestruct(pAddress, &IniSpooler, INISPOOLER);
            DbgDumpIniSpooler(hCurrentProcess, Print, (PINISPOOLER)&IniSpooler);
            NextAddress = (UINT_PTR)IniSpooler.pIniNextSpooler;
            break;

        case IPP_SIGNATURE: // dump INIPRINTPROC structure
            movestruct(pAddress, &IniPrintProc, INIPRINTPROC);
            DbgDumpIniPrintProc(hCurrentProcess, Print, (PINIPRINTPROC)&IniPrintProc);
            NextAddress = (UINT_PTR)IniPrintProc.pNext;
            break;

        case ID_SIGNATURE: //  dump INIDRIVER structure
            movestruct(pAddress, &IniDriver, INIDRIVER);
            DbgDumpIniDriver(hCurrentProcess, Print, (PINIDRIVER)&IniDriver);
            NextAddress = (UINT_PTR)IniDriver.pNext;
            break;

        case IE_SIGNATURE: //   dump INIENVIRONMENT structure
            movestruct(pAddress, &IniEnvironment, INIENVIRONMENT);
            DbgDumpIniEnvironment(hCurrentProcess, Print, (PINIENVIRONMENT)&IniEnvironment);
            NextAddress = (UINT_PTR)IniEnvironment.pNext;
            break;

        case IV_SIGNATURE: //   dump INIVERSION structure
            movestruct(pAddress, &IniVersion, INIVERSION);
            DbgDumpIniVersion(hCurrentProcess, Print, (PINIVERSION)&IniVersion);
            NextAddress = (UINT_PTR)IniVersion.pNext;
            break;

        case IP_SIGNATURE:
            movestruct(pAddress, &IniPrinter, INIPRINTER);
            DbgDumpIniPrinter(hCurrentProcess, Print, (PINIPRINTER)&IniPrinter);
            NextAddress = (UINT_PTR)IniPrinter.pNext;
            break;

        case WCIP_SIGNATURE:
            movestruct(pAddress, &WCacheIniPrinterExtra, WCACHEINIPRINTEREXTRA);
            DbgDumpWCacheIniPrinter(hCurrentProcess, Print, (PWCACHEINIPRINTEREXTRA)&WCacheIniPrinterExtra);
            NextAddress = 0;
            break;

        case IN_SIGNATURE:
            movestruct(pAddress, &IniNetPrint, ININETPRINT);
            DbgDumpIniNetPrint(hCurrentProcess, Print, (PININETPRINT)&IniNetPrint);
            NextAddress = (UINT_PTR)IniNetPrint.pNext;
            break;

        case IMO_SIGNATURE:
            movestruct(pAddress, &IniMonitor, INIMONITOR);
            DbgDumpIniMonitor(hCurrentProcess, Print, (PINIMONITOR)&IniMonitor);
            NextAddress = (UINT_PTR)IniMonitor.pNext;
            break;

        case IPO_SIGNATURE:
            movestruct(pAddress, &IniPort, INIPORT);
            DbgDumpIniPort(hCurrentProcess, Print, (PINIPORT)&IniPort);
            NextAddress = (UINT_PTR)IniPort.pNext;
            break;

        case WIPO_SIGNATURE:
            movestruct(pAddress, &WIniPort, WINIPORT);
            DbgDumpWIniPort(hCurrentProcess, Print, (PWINIPORT)&WIniPort);
            NextAddress = (UINT_PTR)WIniPort.pNext;
            break;

        case IFO_SIGNATURE:
            movestruct(pAddress, &IniForm, INIFORM);
            DbgDumpIniForm(hCurrentProcess, Print, (PINIFORM)&IniForm);
            NextAddress = (UINT_PTR)IniForm.pNext;
            break;

        case IJ_SIGNATURE:
            movestruct(pAddress, &IniJob, INIJOB);
            DbgDumpIniJob(hCurrentProcess, Print, (PINIJOB)&IniJob);
            NextAddress = (UINT_PTR)IniJob.pIniNextJob;
            break;

        case SJ_SIGNATURE:
            movestruct(pAddress, &Spool, SPOOL);
            DbgDumpSpool(hCurrentProcess, Print, (PSPOOL)&Spool);
            NextAddress = (UINT_PTR)Spool.pNext;
            break;

        case WSJ_SIGNATURE:
            movestruct(pAddress, &WSpool, WSPOOL);
            DbgDumpWSpool(hCurrentProcess, Print, (PWSPOOL)&WSpool);
            NextAddress = (UINT_PTR)WSpool.pNext;
            break;

        case TP_SIGNATURE:
            movestruct(pAddress, &Win32Thread, WIN32THREAD);
            DbgDumpWin32Thread(hCurrentProcess, Print, (PWIN32THREAD)&Win32Thread);
            NextAddress = (UINT_PTR)Win32Thread.pNext;
            break;

        case PRINTHANDLE_SIGNATURE:
            movestruct(pAddress, &PrintHandle, PRINTHANDLE);
            DbgDumpPrintHandle(hCurrentProcess, Print, (PPRINTHANDLE)&PrintHandle);
            NextAddress = 0x00000000;
            break;

        case SF_SIGNATURE:
            movestruct(pAddress, &ShadowFile, SHADOWFILE);
            DbgDumpShadowFile(hCurrentProcess, Print, (PSHADOWFILE)&ShadowFile);
            NextAddress = 0x00000000;
            break;

        case SF_SIGNATURE_2:
            movestruct(pAddress, &ShadowFile2, SHADOWFILE_2);
            DbgDumpShadowFile2(hCurrentProcess, Print, (PSHADOWFILE_2)&ShadowFile2);
            NextAddress = 0x00000000;
            break;

        default:
            // Unknown signature -- no data to dump
            (*Print)("Warning: Unknown Signature\n");
            NextAddress = 0x00000000;
            bRetval = FALSE;
            break;
        }

        pAddress = NextAddress;
        *pNextAddress = NextAddress;
    }

    return bRetval ;
}

BOOL DumpDevMode(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress
        )
{
    DEVMODEW DevMode;
    DWORD   i;

    Print("DevMode\n");

    if (!lpAddress) {
        Print("\n Null DEVMODE Structure lpDevMode = NULL\n");
        return TRUE ;
    }
    movestruct(lpAddress, &DevMode, DEVMODEW);

    Print("TCHAR        dmDeviceName[32]    %ws\n", DevMode.dmDeviceName);
    Print("WORD         dmSpecVersion       %d\n", DevMode.dmSpecVersion);
    Print("WORD         dmDriverVersion     %d\n", DevMode.dmDriverVersion);
    Print("WORD         dmSize              %d\n", DevMode.dmSize);
    Print("WORD         dmDriverExtra       %d\n", DevMode.dmDriverExtra);
    Print("DWORD        dmFields            %d\n", DevMode.dmFields);

    for (i = 0; i < MAX_DEVMODE_FIELDS; i++ ) {
        if (DevMode.dmFields & DevModeFieldsTable[i].dmField) {
            Print("\t %s is ON\n", DevModeFieldsTable[i].String);
        } else {
            Print("\t %s is OFF\n", DevModeFieldsTable[i].String);
        }
    }

    Print("short        dmOrientation       %d\n", DevMode.dmOrientation);
    Print("short        dmPaperSize         %d\n", DevMode.dmPaperSize);

    if ((DevMode.dmPaperSize >= 1) && (DevMode.dmPaperSize <= MAX_DEVMODE_PAPERSIZES)) {
        Print("Paper size from dmPaperSize is %s\n", DevModePaperSizes[DevMode.dmPaperSize - 1]);
    } else {
        Print("Paper size from dmPaperSize is out of bounds!!\n");
    }

    Print("short        dmPaperLength       %d\n", DevMode.dmPaperLength);
    Print("short        dmPaperWidth        %d\n", DevMode.dmPaperWidth);

    Print("short        dmScale             %d\n", DevMode.dmScale);
    Print("short        dmCopies            %d\n", DevMode.dmCopies);
    Print("short        dmDefaultSource     %d\n", DevMode.dmDefaultSource);
    Print("short        dmPrintQuality      %d\n", DevMode.dmPrintQuality);
    Print("short        dmColor             %d\n", DevMode.dmColor);
    Print("short        dmDuplex            %d\n", DevMode.dmDuplex);
    Print("short        dmYResolution       %d\n", DevMode.dmYResolution);
    Print("short        dmTTOption          %d\n", DevMode.dmTTOption);
    Print("short        dmCollate           %d\n", DevMode.dmCollate);
    Print("TCHAR        dmFormName[32]      %ws\n", DevMode.dmFormName);
    Print("DWORD        dmLogPixels         %d\n", DevMode.dmLogPixels);
    Print("USHORT       dmBitsPerPel        %d\n", DevMode.dmBitsPerPel);
    Print("DWORD        dmPelsWidth         %d\n", DevMode.dmPelsWidth);
    Print("DWORD        dmPelsHeight        %d\n", DevMode.dmPelsHeight);
    Print("DWORD        dmDisplayFlags      %d\n", DevMode.dmDisplayFlags);
    Print("DWORD        dmDisplayFrequency  %d\n", DevMode.dmDisplayFrequency);

    return TRUE;
}

BOOL DbgDumpPI2(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_INFO_2  pi2;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_INFO_2 pPrinterInfo;

    for ( pPrinterInfo = (PPRINTER_INFO_2)lpAddress;
          pPrinterInfo != NULL && dwCount != 0;
          pPrinterInfo++, dwCount--  ) {


        movestruct( pPrinterInfo, &pi2, PRINTER_INFO_2);

        (*Print)("\nAddress %x\n", pPrinterInfo );

         movestr(pi2.pServerName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pServerName                     %ws\n", Buffer);

         movestr(pi2.pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrinterName                    %ws\n", Buffer);

         movestr(pi2.pShareName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pShareName                      %ws\n", Buffer);

         movestr(pi2.pPortName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPortName                       %ws\n", Buffer);

         movestr(pi2.pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pDriverName                     %ws\n", Buffer);

         movestr(pi2.pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

         movestr(pi2.pLocation, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pLocation                       %ws\n", Buffer);

        (*Print)("LPDEVMODE     pDevMode                        %p\n", pi2.pDevMode);

         movestr(pi2.pSepFile, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pSepFile                        %ws\n", Buffer);

         movestr(pi2.pPrintProcessor, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrintProcessor                 %ws\n", Buffer);

         movestr(pi2.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pDatatype                       %ws\n", Buffer);

         movestr(pi2.pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pParameters                     %ws\n", Buffer);

        (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pi2.pSecurityDescriptor);

        (*Print)("DWORD         Attributes                      0x%.8x\n",pi2.Attributes);
        ExtractPrinterAttributes( Print, pi2.Attributes);

        (*Print)("DWORD         Priority                        %d\n", pi2.Priority);
        (*Print)("DWORD         DefaultPriority                 %d\n", pi2.DefaultPriority);
        (*Print)("DWORD         StartTime                       %d\n", pi2.StartTime);
        (*Print)("DWORD         UntilTime                       %d\n", pi2.UntilTime);

        (*Print)("DWORD         Status                          0x%.8x\n", pi2.Status);
        ExtractExternalPrinterStatus( Print, pi2.Status );

        (*Print)("DWORD         cJobs                           %d\n", pi2.cJobs);
        (*Print)("DWORD         AveragePPM                      %d\n", pi2.AveragePPM);

    }

    return TRUE;
}



BOOL DbgDumpPI0(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_INFO_STRESS  pi0;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_INFO_STRESS pPrinterInfo;

    for ( pPrinterInfo = (PPRINTER_INFO_STRESS)lpAddress;
          pPrinterInfo != NULL && dwCount != 0;
          pPrinterInfo++, dwCount--  ) {


        movestruct( pPrinterInfo, &pi0, PRINTER_INFO_STRESS);

        (*Print)("\nAddress %x\n", pPrinterInfo );

         movestr(pi0.pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrinterName                    %ws\n", Buffer);

         movestr(pi0.pServerName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pServerName                     %ws\n", Buffer);

        (*Print)("DWORD         cJobs                           %d\n", pi0.cJobs);

        (*Print)("DWORD         cTotalJobs                      %d\n", pi0.cTotalJobs);

        (*Print)("DWORD         cTotalBytes (LOWER DWORD)       %d\n", pi0.cTotalBytes);

        (*Print)("SYSTEMTIME    stUpTime                        %d/%d/%d  %d  %d:%d:%d.%d\n",pi0.stUpTime.wYear,
                                                                pi0.stUpTime.wMonth,
                                                                pi0.stUpTime.wDay,
                                                                pi0.stUpTime.wDayOfWeek,
                                                                pi0.stUpTime.wHour,
                                                                pi0.stUpTime.wMinute,
                                                                pi0.stUpTime.wSecond,
                                                                pi0.stUpTime.wMilliseconds);

        (*Print)("DWORD         MaxcRef                         %d\n", pi0.MaxcRef);

        (*Print)("DWORD         cTotalPagesPrinted              %d\n", pi0.cTotalPagesPrinted);

        (*Print)("DWORD         dwGetVersion                    %d\n", pi0.dwGetVersion);

        (*Print)("DWORD         fFreeBuild                      %d\n", pi0.fFreeBuild);

        (*Print)("DWORD         cSpooling                       %d\n", pi0.cSpooling);

        (*Print)("DWORD         cMaxSpooling                    %d\n", pi0.cMaxSpooling);

        (*Print)("DWORD         cRef                            %d\n", pi0.cRef);

        (*Print)("DWORD         cErrorOutOfPaper                %d\n", pi0.cErrorOutOfPaper);

        (*Print)("DWORD         cErrorNotReady                  %d\n", pi0.cErrorNotReady);

        (*Print)("DWORD         cJobError                       %d\n", pi0.cJobError);

        (*Print)("DWORD         dwNumberOfProcessors            %d\n", pi0.dwNumberOfProcessors);

        (*Print)("DWORD         dwProcessorType                 %d\n", pi0.dwProcessorType);

        (*Print)("DWORD         dwHighPartTotalBytes            %d\n", pi0.dwHighPartTotalBytes);

        (*Print)("DWORD         cChangeID                       %d\n", pi0.cChangeID);

        (*Print)("DWORD         dwLastError                     %d\n", pi0.dwLastError);

        (*Print)("DWORD         Status                          0x%.8x\n", pi0.Status);
        ExtractExternalPrinterStatus( Print, pi0.Status );

        (*Print)("DWORD         cEnumerateNetworkPrinters       %d\n", pi0.cEnumerateNetworkPrinters);

        (*Print)("DWORD         cAddNetPrinters                 %d\n", pi0.cAddNetPrinters);

        (*Print)("WORD          wProcessorArchitecture          %d\n", pi0.wProcessorArchitecture);

        (*Print)("WORD          wProcessorLevel                 %d\n", pi0.wProcessorLevel);
    }

    return TRUE;
}

BOOL DbgDumpFI1(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    FORM_INFO_1  fi1;
    WCHAR Buffer[MAX_PATH+1];
    PFORM_INFO_1 pFORMInfo;

    for ( pFORMInfo = (PFORM_INFO_1)lpAddress;
          pFORMInfo != NULL && dwCount != 0;
          pFORMInfo++, dwCount--  ) {


        movestruct( pFORMInfo, &fi1, FORM_INFO_1);

        (*Print)("\nAddress %p\n", pFORMInfo );

        (*Print)("DWORD         Flags                           %x", fi1.Flags);

        if ( fi1.Flags & FORM_BUILTIN )
            (*Print)(" FORM_BUILTIN\n");
        else
            (*Print)(" FORM_USERDEFINED\n");

         movestr(fi1.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pName                           %ws\n", Buffer);

        (*Print)("SIZEL         Size                            cx %d cy %d\n", fi1.Size.cx, fi1.Size.cy);
        (*Print)("RECTL         ImageableArea                   left %d right %d top %d bottom %d\n",
                                                                 fi1.ImageableArea.left,
                                                                 fi1.ImageableArea.right,
                                                                 fi1.ImageableArea.top,
                                                                 fi1.ImageableArea.bottom);

    }

    return TRUE;
}

BOOL DbgDumpPDEF(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_DEFAULTS PDef;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_DEFAULTS pPDef;

    pPDef = ( PPRINTER_DEFAULTS )lpAddress;

    movestruct( pPDef, &PDef, PRINTER_DEFAULTS);

    (*Print)("\nAddress %x\n", pPDef );

    Buffer[0] = L'\0';
     movestr(PDef.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          PrinterDefaults.pDatatype     %p %ws\n", PDef.pDatatype, Buffer);
    (*Print)("LPDEVMODE       PrinterDefaults.pDevMode      %p\n", PDef.pDevMode);
    (*Print)("ACCESS_MASK     PrinterDefaults.DesiredAccess %p\n", PDef.DesiredAccess);
    ExtractPrinterAccess( Print, PDef.DesiredAccess );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\dbgutil.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000
All rights reserved.

Module Name:

    dbgutil.c

Abstract:

    This module provides all the Spooler Subsystem Debugger utility
    functions.

Author:

    Krishna Ganugapati (KrishnaG) 1-July-1993

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "dbglocal.h"
#include "dbgsec.h"

SYSTEM_INFO gSysInfo;

DWORD EvalValue(
    LPSTR *pptstr,
    PNTSD_GET_EXPRESSION EvalExpression,
    PNTSD_OUTPUT_ROUTINE Print)
{
    LPSTR lpArgumentString;
    LPSTR lpAddress;
    DWORD dw;
    char ach[80];
    UINT_PTR cch;

    UNREFERENCED_PARAMETER(Print);
    lpArgumentString = *pptstr;

    while (isspace(*lpArgumentString))
        lpArgumentString++;

    lpAddress = lpArgumentString;
    while ((!isspace(*lpArgumentString)) && (*lpArgumentString != 0))
        lpArgumentString++;

    cch = (UINT_PTR)lpArgumentString - (UINT_PTR)lpAddress;
    if (cch > 79)
        cch = 79;

    StringCchCopyA(ach, (UINT)cch, lpAddress);

    dw = (DWORD)EvalExpression(lpAddress);

    *pptstr = lpArgumentString;
    return dw;
}


VOID
ConvertSidToAsciiString(
    PSID pSid,
    LPSTR   String,
    size_t  cchString
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    UCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= '\0';
        return;
    }

    StringCchPrintfA(Buffer, COUNTOF(Buffer), "S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    StringCchCopyA(String, cchString, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        StringCchPrintfA(Buffer, COUNTOF(Buffer), 
                         "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                         (USHORT)pSidIdentifierAuthority->Value[0],
                         (USHORT)pSidIdentifierAuthority->Value[1],
                         (USHORT)pSidIdentifierAuthority->Value[2],
                         (USHORT)pSidIdentifierAuthority->Value[3],
                         (USHORT)pSidIdentifierAuthority->Value[4],
                         (USHORT)pSidIdentifierAuthority->Value[5] );
        StringCchCatA(String, cchString, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        StringCchPrintfA(Buffer, COUNTOF(Buffer), "%lu", Tmp);
        StringCchCatA(String, cchString, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        StringCchPrintfA(Buffer, COUNTOF(Buffer), "-%lu", *(GetSidSubAuthority(pSid, i)));
        StringCchCatA(String, cchString, Buffer);
    }

}

BOOL
ReadProcessString(
    IN  HANDLE  hProcess,
    IN  LPCVOID lpBaseAddress,
    OUT LPVOID  lpBuffer,
    IN  SIZE_T  nSize,
    OUT SIZE_T  *lpNumberOfBytesRead
    )
{
    BOOL        bRetval     = FALSE;
    SIZE_T      cbRead      = 0;
    UINT_PTR    nAddress    = 0;

    //
    // Attempt to read the memory, up to the provided size.
    //
    bRetval = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, &cbRead);

    //
    // The string in the debugged process may have unmapped memory just after
    // the end of the string, (this is true when page heap is enabled),
    //
    // If the read failed and the address plus the string buffer size crosses
    // a page boundary then retry the operation up to the page end.
    //
    if (!bRetval)
    {
        nAddress = (UINT_PTR)lpBaseAddress;

        //
        // If we have crossed a page boundary.
        //
        if (((nAddress & (gSysInfo.dwPageSize-1)) + nSize) > gSysInfo.dwPageSize-1)
        {
            nSize = (SIZE_T)((gSysInfo.dwPageSize-1) - (nAddress & (gSysInfo.dwPageSize-1)));

            bRetval = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, &cbRead);
        }
    }

    //
    // The read succeeded.
    //
    if (bRetval)
    {
        //
        // If the caller wants to know the number of bytes read.
        //
        if (lpNumberOfBytesRead)
        {
            *lpNumberOfBytesRead = cbRead;
        }
    }

    return bRetval;
}

//
// Query the system for the page size.
//
BOOL
QuerySystemInformation(
    VOID
    )
{
    GetSystemInfo(&gSysInfo);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splexts\precomp.h ===
#include <windows.h>
#include <winspool.h>
#include <ntsdexts.h>
#include <stdio.h>

#include <winsplp.h>
#include <spltypes.h>
#include <router.h>
#include <winspl.h>
#include <reply.h>
#include <w32types.h>
#include <splcom.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\checkpoint.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    checkpoint.cxx

Abstract:

    This file implements a class (or for 'C' handle based) calls to set and
    restore system breakpoints.

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "checkpoint.hxx"
#include "safewrap.hxx"

TSystemRestorePoint::
TSystemRestorePoint(
    VOID
    ) : m_hLibrary(NULL),
        m_pfnSetRestorePoint(NULL),
        m_bSystemRestoreSet(FALSE),
        m_hr(E_FAIL)
{
    memset(&m_RestorePointInfo, 0, sizeof(m_RestorePointInfo));

    m_hr = Initialize();
}

TSystemRestorePoint::
~TSystemRestorePoint(
    VOID
    )
{
    if (m_hLibrary)
    {
        FreeLibrary(m_hLibrary);
    }
}

HRESULT
TSystemRestorePoint::
IsValid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Routine Name:

    StartSystemRestorePoint

Routine Description:

    This routine starts a system restore point in the AddPrinterDriver code.

Arguments:

    pszServer       -   The server name on which we are setting the restore point.
    pszDriverName   -   The driver name of which we are trying to install.
    hInst           -   The hInstance of the resource library.
    ResId           -   The resource id to use for the message string.

Return Value:

    An HRESULT.

--*/
HRESULT
TSystemRestorePoint::
StartSystemRestorePoint(
    IN      PCWSTR          pszServer,
    IN      PCWSTR          pszDriverName,
    IN      HINSTANCE       hInst,
    IN      UINT            ResId
    )
{
    HRESULT         hRetval     = E_FAIL;
    STATEMGRSTATUS  SMgrStatus;
    WCHAR           szDriverName[MAX_DESC];
    WCHAR           szMessage[MAX_DESC];

    hRetval = pszDriverName && hInst ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // We only set system restore points on the local machine for now.
    //
    if (SUCCEEDED(hRetval) && !pszServer)
    {

        if (SUCCEEDED(hRetval))
        {
            if (LoadString(hInst, ResId, szMessage, COUNTOF(szMessage)))
            {
                //
                // We have to check here if the length of the message
                // is at least two (because of the string terminator and
                // at least one format specifier)
                //
                if (lstrlen(szMessage) > 2)
                {
                    hRetval = S_OK;
                }
                else
                {
                    hRetval = HResultFromWin32(ERROR_RESOURCE_DATA_NOT_FOUND);
                }
            }
            else
            {
                hRetval = GetLastErrorAsHResult();
            }
        }

        if (SUCCEEDED(hRetval))
        {
            PWSTR       pszArray[1];

            //
            // Now we calculate how much of the driver name we can fit into the
            // message (which is only 64 characters). This is
            // MAX_DESC - (strlen(szMessage) - 2) - 1.
            //
            StringCchCopyW(szDriverName, MAX_DESC - wcslen(szMessage) + 2, pszDriverName);

            pszArray[0] = szDriverName;

            hRetval = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   szMessage,
                                   0,
                                   0,
                                   m_RestorePointInfo.szDescription,
                                   COUNTOF(m_RestorePointInfo.szDescription),
                                   (va_list *)pszArray) ? S_OK : GetLastErrorAsHResult();
        }

        //
        // Now that we have the system restore point, set it.
        //
        if (SUCCEEDED(hRetval))
        {
            m_RestorePointInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
            m_RestorePointInfo.dwRestorePtType = DEVICE_DRIVER_INSTALL;
            m_RestorePointInfo.llSequenceNumber = 0;

            hRetval = m_pfnSetRestorePoint(&m_RestorePointInfo, &SMgrStatus) ? S_OK : HRESULT_FROM_WIN32(SMgrStatus.nStatus);
        }

        if (SUCCEEDED(hRetval))
        {
            m_bSystemRestoreSet = TRUE;
        }
        else
        {
            //
            // Failing to set the system restore point should not stop us adding
            // the printer driver.
            //
            hRetval = S_OK;
        }
    }

    return hRetval;
}

/*++

Routine Name:

    EndSystemRestorePoint

Routine Description:

    This function either completes the system restore point or it cancels it
    if whoever was doing the installation tells us to.

Arguments:

    bCancel         -   If TRUE, the restore point should be cancelled.

Return Value:

    An HRESULT.

--*/
HRESULT
TSystemRestorePoint::
EndSystemRestorePoint(
    IN      BOOL            bCancel
    )
{
    HRESULT         hRetval = S_OK;
    STATEMGRSTATUS  SMgrStatus;

    if (m_bSystemRestoreSet)
    {
        m_RestorePointInfo.dwEventType     = END_NESTED_SYSTEM_CHANGE;
        m_RestorePointInfo.dwRestorePtType = bCancel ? CANCELLED_OPERATION : DEVICE_DRIVER_INSTALL;

        hRetval = m_pfnSetRestorePoint(&m_RestorePointInfo, &SMgrStatus) ? S_OK : HRESULT_FROM_WIN32(SMgrStatus.nStatus);
    }

    return hRetval;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Load the system restore library and get the address of the system restore
    function.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
TSystemRestorePoint::
Initialize(
    VOID
    )
{
    HRESULT hRetval = E_FAIL;

    m_hLibrary = LoadLibraryFromSystem32(L"srclient.dll");

    hRetval  = m_hLibrary ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        m_pfnSetRestorePoint = reinterpret_cast<PFnSRSetRestorePoint>(GetProcAddress(m_hLibrary, "SRSetRestorePointW"));

        hRetval  = m_pfnSetRestorePoint ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}


/*++

Routine Name:

    StartSystemRestorePoint

Routine Description:

    This form of the function is for C callers, it is handle based.

Arguments:

    pszServer       -   The server on which we are doing the restore point.
    pszDriverName   -   The driver name we are installing.
    hInst           -   The instance in which the resource which we want to load is.
    ResId           -   The Resource Id.

Return Value:

    An HRESULT

--*/
extern "C"
HANDLE
StartSystemRestorePoint(
    IN      PCWSTR          pszServer,
    IN      PCWSTR          pszDriverName,
    IN      HINSTANCE       hInst,
    IN      UINT            ResId
    )
{
    HRESULT hRetval         = E_FAIL;
    HANDLE  hRestorePoint   = NULL;

#ifdef _WIN64
    return NULL;
#endif

    TSystemRestorePoint *pSystemRestorePoint = new TSystemRestorePoint;

    hRetval = pSystemRestorePoint ? pSystemRestorePoint->IsValid() : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        hRetval = pSystemRestorePoint->StartSystemRestorePoint(pszServer, pszDriverName, hInst, ResId);
    }

    if (SUCCEEDED(hRetval))
    {
        hRestorePoint = pSystemRestorePoint;

        pSystemRestorePoint = NULL;
    }
    else
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    delete pSystemRestorePoint;

    return hRestorePoint;
}

/*++

Routine Name:

    EndSystemRestorePoint

Routine Description:

    This form of the function is for C callers, it is handle based.
    Note: This also closes the handle.

Arguments:

    hRestorePoint   -   The system restore point.
    bCancel         -   If TRUE, the system restore point should be cancelled
                        and not completed.

Return Value:

    An HRESULT

--*/
extern "C"
BOOL
EndSystemRestorePoint(
    IN      HANDLE          hRestorePoint,
    IN      BOOL            bCancel
    )
{

    HRESULT             hRetval        = E_FAIL;
    TSystemRestorePoint *pRestorePoint = reinterpret_cast<TSystemRestorePoint *>(hRestorePoint);

#ifdef _WIN64
    return SUCCEEDED( E_FAIL );
#endif

    hRetval = pRestorePoint ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hRetval))
    {
        hRetval = pRestorePoint->EndSystemRestorePoint(bCancel);

        delete pRestorePoint;
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\csrlist.cxx ===
/*++

Copyright (C) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    list.cxx

Abstract:

    List template class.

Author:

    Steve Kiraly (SteveKi)  03-Mar-2000

Revision History:

--*/
#include "spllibp.hxx"
#pragma hdrstop
#include "CSRutility.hxx"
#include "CSRlist.hxx"

using namespace NCoreLibrary;

TLink::
TLink(
    VOID
    )
{
    m_pNext = this;
    m_pPrev = this;
}

TLink::
~TLink(
    VOID
    )
{
    if (SUCCEEDED(IsLinked()))
    {
        UnLink();
    }
}

HRESULT
TLink::
IsValid(
    VOID
    ) const
{
    return m_pNext && m_pPrev ? S_OK : E_FAIL;
}

HRESULT
TLink::
IsLinked(
    VOID
    ) const
{
    return m_pNext != this && m_pPrev != this ? S_OK : E_FAIL;
}

HRESULT
TLink::
Link(
    IN TLink *pNode
    )
{
    HRESULT hRetval = E_FAIL;

    //
    // The caller must provide a valid node pointer.
    //
    if (pNode)
    {
        //
        // We cannot be linked twice.
        //
        if (SUCCEEDED(pNode->IsLinked()))
        {
            pNode->UnLink();
        }

        //
        // Link the specified node just after the this Node.
        //
        m_pNext->m_pPrev    = pNode;
        pNode->m_pNext      = m_pNext;
        pNode->m_pPrev      = this;
        m_pNext             = pNode;

        //
        // Indicate success.
        //
        hRetval = S_OK;
    }

    return hRetval;
}

VOID
TLink::
UnLink(
    VOID
    )
{
    //
    // UnLink this node from the list.
    //
    m_pNext->m_pPrev = m_pPrev;
    m_pPrev->m_pNext = m_pNext;

    //
    // Fix yourself up now.
    //
    m_pPrev = m_pNext = this;
}

TLink *
TLink::
Next(
    VOID
    ) const
{
    return m_pNext;
}

TLink *
TLink::
Prev(
    VOID
    ) const
{
    return m_pPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\common.cxx ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation
All rights reserved.

Module Name:

    common.cxx

Abstract:

    common functions across all spooler components

Author:

    Steve Kiraly (SteveKi)

Revision History:

    Felix Maxa (AMaxa) 19 Apr 2001
    Added StrCatSystemPath

--*/
#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"

extern "C"
DWORD
WINAPIV
StrCatAlloc(
    IN OUT  LPCTSTR      *ppszString,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    and returns a pointer to the new string.  It's the callers
    responsibility to release the returned string with a call
    to FreeSplMem();  The last argument must be a NULL
    to signify the end of the argument list.

Arguments:

    ppszString - pointer where to return pointer to newly created
                 string which is the concatenation of the passed
                 in strings.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

Usage

--*/
{
    UINT    uTotalLen   = 0;
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    LPTSTR  pszString   = NULL;
    LPCTSTR pszTemp     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (ppszString)
    {
        dwRetval = ERROR_SUCCESS;

        //
        // Keep the callers from getting random value on failure.
        //
        *ppszString = NULL;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, ppszString);

        //
        // Tally up all the strings.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, LPCTSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Sum all the string lengths.
            //
            uTotalLen = uTotalLen + _tcslen(pszTemp);
        }

        //
        // Need space for the null terminator.
        //
        uTotalLen = uTotalLen + 1;

        //
        // Allocate the space for the sum of all the strings.
        //
        pszString = (LPTSTR)AllocSplMem(uTotalLen * sizeof(TCHAR));

        if (pszString)
        {
            *pszString = L'\0';

            //
            // Reset the pointer to the argument frame.
            //
            va_start(pArgs, ppszString);

            //
            // Concatenate all the strings.
            //
            for ( ; ; )
            {
                pszTemp = va_arg(pArgs, LPCTSTR);

                if (!pszTemp)
                {
                    break;
                }

                StringCchCat(pszString, uTotalLen, pszTemp);
            }

            //
            // Copy back the string pointer to the caller.
            //
            *ppszString = pszString;
        }
        else
        {
            dwRetval = ERROR_NOT_ENOUGH_MEMORY;
        }

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;
}

extern "C"
DWORD
WINAPIV
StrNCatBuff(
    IN      LPTSTR      pszBuffer,
    IN      UINT        cchBuffer,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    into the provided buffer.  The last argument must be a NULL
    to signify the end of the argument list.

Arguments:

    pszBuffer  - pointer buffer where to place the concatenated
                 string.
    cchBuffer  - character count of the provided buffer including
                 the null terminator.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

--*/
{
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    LPCTSTR pszTemp     = NULL;
    LPTSTR  pszDest     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (pszBuffer && cchBuffer)
    {
        //
        // Assume success.
        //
        dwRetval = ERROR_SUCCESS;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, cchBuffer);

        //
        // Get temp destination pointer.
        //
        pszDest = pszBuffer;

        //
        // Insure we have space for the null terminator.
        //
        cchBuffer--;

        //
        // Collect all the arguments.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, LPCTSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Copy the data into the destination buffer.
            //
            for ( ; cchBuffer; cchBuffer-- )
            {
                if (!(*pszDest = *pszTemp))
                {
                    break;
                }

                pszDest++, pszTemp++;
            }

            //
            // If were unable to write all the strings to the buffer,
            // set the error code and nuke the incomplete copied strings.
            //
            if (!cchBuffer && pszTemp && *pszTemp)
            {
                dwRetval = ERROR_INVALID_PARAMETER;
                *pszBuffer = _T('\0');
                break;
            }
        }

        //
        // Terminate the buffer always.
        //
        *pszDest = _T('\0');

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;

}

extern "C"
LPTSTR
WINAPI
SubChar(
    IN LPCTSTR  pszIn,
    IN TCHAR    cIn,
    IN TCHAR    cOut
    )
/*++

Routine Description:

    Replaces all instances of cIn in pszIn with cOut.

Arguments:

    pszIn   - input string
    cIn     - character to replace with cOut
    cOut    - character that replaces cIn

Return Value:

    If successful, returns a pointer to an allocated buffer containing the
    output string.  If the return value is NULL, SubChar has fails and
    GetLastError() will return the error.

Notes:

    An output buffer is allocated (and contains NULL) even if pszOut is NULL.

--*/
{
    LPTSTR   pszReturn   = NULL;
    LPTSTR   pszOut      = NULL;

    if (cIn && pszIn)
    {
        if ((pszOut = pszReturn = (LPTSTR) AllocSplMem((_tcslen(pszIn) + 1)*sizeof(TCHAR))))
        {
            for (; *pszIn ; ++pszIn, ++pszOut)
            {
                *pszOut = (*pszIn == cIn) ? cOut : *pszIn;
            }
            *pszOut = *pszIn;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return pszReturn;
}

/*++

Routine Name:

    GetLastErrorAsHResult

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    None

Return Value:

    An HRESULT.

--*/
EXTERN_C
HRESULT
GetLastErrorAsHResult(
    VOID
    )
{
    return HResultFromWin32(GetLastError()); 
}

/*++

Routine Name:

    GetFileNamePart

Routine Description:

    Get the file name portion of a path.
        
Arguments:
    
    pszFullPath          - Full path to a file
    ppszFileName         - File name 
    
Return Value:

    An HRESULT           
                               
--*/
EXTERN_C
HRESULT
GetFileNamePart(
    IN     PCWSTR      pszFullPath,
       OUT PCWSTR      *ppszFileName
    )
{
   HRESULT hRetval             = E_FAIL;
   WCHAR   szfname[_MAX_FNAME] = {0};

   hRetval = pszFullPath && ppszFileName ? S_OK : E_INVALIDARG;

   if (SUCCEEDED(hRetval)) 
   {
       _wsplitpath(pszFullPath, NULL, NULL, szfname, NULL);
       *ppszFileName = wcsstr(pszFullPath, szfname);
   }
      
   return hRetval; 
}

/*++

Routine Name:

    GetLastErrorAsHResultAndFail

Routine Description:

    This routine gets the last error as HRESULT, and if there was no last error, 
    returns E_UNEXPECTED. 

Arguments:

    None
    
Return Value:

    An HRESULT
        
--*/
EXTERN_C
HRESULT
GetLastErrorAsHResultAndFail(
    void
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = GetLastErrorAsHResult();

    if (S_OK == hRetval) 
    {
        hRetval = E_UNEXPECTED;
    }

    return hRetval;
}

/*++

Routine Name:

    HResultFromWin32

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    dwError   - Win32 error code

Return Value:

    An HRESULT

--*/
EXTERN_C
HRESULT
HResultFromWin32(
    IN DWORD dwError
    )
{
    return HRESULT_FROM_WIN32(dwError); 
}

/*++

Description:

    This routine allocates a string which is the concatenation:
    Directory\pszFile. Directory is Windir, SystemRoot, CurrentDir,
    SystemWindowsDir, depending on the edir input argument.
    
Arguments:

    pszFile      - file name
    eDir         - enumeration, tells the function what directory to concatenate
    ppszFullPath - pointer where to return pointer to newly created string

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must use FreeSplMem to free the string returned by this function

--*/
EXTERN_C
DWORD
WINAPI
StrCatSystemPath(
    IN   LPCTSTR    pszFile,
    IN   EStrCatDir eDir,
    OUT  LPTSTR    *ppszFullPath
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;
    
    //
    // Validate arguments
    //
    if (pszFile && ppszFullPath)
    {
        DWORD cchNeeded;

        *ppszFullPath = NULL;

        //
        // Get the number of chars needed to hold the system directory. The returned 
        // number accounts for the NULL terminator. GetCurrentDirectory is different than
        // the other function, because if takes the size of the buffer as the first 
        // argument. 
        // 
        cchNeeded = eDir == kWindowsDir       ? GetWindowsDirectory(NULL, 0) :
                    eDir == kSystemWindowsDir ? GetSystemWindowsDirectory(NULL, 0) :
                    eDir == kSystemDir        ? GetSystemDirectory(NULL, 0) : 
                                                GetCurrentDirectory(0, NULL);                    

        Error = cchNeeded ? ERROR_SUCCESS : GetLastError();

        if (Error == ERROR_SUCCESS) 
        {
            // 
            // Calculate the size of the buffer needed. Note that cchNeeded already 
            // includes the NULL terminator. 
            // length(directory) + whack + length(pszFile)
            //
            cchNeeded = cchNeeded + 1 + _tcslen(pszFile);

            *ppszFullPath = static_cast<LPTSTR>(AllocSplMem(cchNeeded * sizeof(TCHAR)));

            Error = *ppszFullPath ? ERROR_SUCCESS : GetLastError();

            if (Error == ERROR_SUCCESS) 
            {
                DWORD cchTemp;

                cchTemp = eDir == kWindowsDir       ? GetWindowsDirectory(*ppszFullPath, cchNeeded) :
                          eDir == kSystemWindowsDir ? GetSystemWindowsDirectory(*ppszFullPath, cchNeeded) :
                          eDir == kSystemDir        ? GetSystemDirectory(*ppszFullPath, cchNeeded) : 
                                                      GetCurrentDirectory(cchNeeded, *ppszFullPath);
                if (cchTemp)
                {
                    StringCchCat(*ppszFullPath, cchNeeded, _T("\\"));
                    StringCchCat(*ppszFullPath, cchNeeded, pszFile);
                }
                else
                {
                    Error = GetLastError();
                    
                    FreeSplMem(*ppszFullPath);

                    *ppszFullPath = NULL;
                }
            }            
        }        
    }

    return Error;
}

/*++

Description:

    This routine converts a unicode string to an ansi string. The caller 
    must free the ansi string using "delete [] pszAnsi".
    
Arguments:

    pszUnicode - pointer to NULL terminated unicode string
    ppszAnsi   - pointer where to return pointer to newly created string

Returns:

    S_OK - operation was successful and *ppszAnsi can be used
    or any other HRESULT if an error occurred.

--*/
EXTERN_C
HRESULT
UnicodeToAnsiWithAlloc(
    IN  LPCWSTR  pszUnicode,
    OUT LPSTR   *ppszAnsi
    )
{
    HRESULT hr = E_INVALIDARG;

    if (ppszAnsi)
    {
        *ppszAnsi = NULL;

        hr = S_OK;

        if (pszUnicode)
        {
            INT rc; 

            rc = WideCharToMultiByte(CP_THREAD_ACP,
                                     0,
                                     pszUnicode,
                                     -1,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL);
    
            if (rc) 
            {
                *ppszAnsi = new CHAR[rc];
    
                if (*ppszAnsi) 
                {
                    rc = WideCharToMultiByte(CP_THREAD_ACP,
                                             0,
                                             pszUnicode,
                                             -1,
                                             *ppszAnsi,
                                             rc,
                                             NULL,
                                             NULL);
    
                    if (!rc)
                    {
                         hr = GetLastErrorAsHResult();
                         
                         delete [] *ppszAnsi;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = GetLastErrorAsHResult();                
            }
        }
    }

    return hr;
}

/*++

Description:

    This routine converts an ansi string to a unicode string. The caller 
    must free the unicode string using "delete [] pszUnicode".
    
Arguments:

    pszAnsi     - pointer to NULL terminated ansi string
    ppszUnicode - pointer where to return pointer to newly created string

Returns:

    S_OK - operation was successful and *ppszUnicode can be used
    or any other HRESULT if an error occurred.

--*/
EXTERN_C
HRESULT
AnsiToUnicodeWithAlloc(
    IN  LPCSTR   pszAnsi,
    OUT LPWSTR  *ppszUnicode
    )
{
    HRESULT hr = E_INVALIDARG;

    if (ppszUnicode) 
    {
        *ppszUnicode = NULL;

        hr = S_OK;

        if (pszAnsi) 
        {
            INT rc; 

            rc = MultiByteToWideChar(CP_ACP,
                                     MB_PRECOMPOSED,
                                     pszAnsi,
                                     -1,
                                     NULL,
                                     0);
    
            if (rc) 
            {
                *ppszUnicode = new WCHAR[rc];
    
                if (*ppszUnicode) 
                {
                    rc = MultiByteToWideChar(CP_ACP,
                                             MB_PRECOMPOSED,
                                             pszAnsi,
                                             -1,
                                             *ppszUnicode,
                                             rc);
    
                    if (!rc)
                    {
                         hr = GetLastErrorAsHResult();
                         
                         delete [] *ppszUnicode;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;                
                }
            }
            else
            {
                hr = GetLastErrorAsHResult();            
            }
        }
    }

    return hr;
}

/*++

Routine Name:

    StatusFromHResult

Description:

    This function returns a win32 error code from an HRESULT if possible and
    it failed, if it is not a win32 error code, it just returns the error code,
    otherwise it returns ERROR_SUCCESS.

Arguments:

    hr      -   The HRESULT.

Returns:

    The status equivalent of the hresult.

--*/
EXTERN_C
DWORD
StatusFromHResult(
    IN      HRESULT     hr
    )
{
    DWORD   Status = ERROR_SUCCESS;

    if (FAILED(hr))
    {
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            //
            // Kind of wacky, should we have a table here for reasonably translatable HResults?
            //
            Status = hr;
        }
    }

    return Status;
}

/*++

Routine Name:

    BoolFromHResult

Description:

    This function take an HRESULT input, if the HRESULT is a failure, it sets
    the last error and returns false, otherwise it returns TRUE.

Arguments:

    hr      -   The HRESULT.

Returns:

    A BOOLEAN, Sets the last error

--*/
EXTERN_C
BOOL
BoolFromHResult(
    IN      HRESULT     hr
    )
{
    DWORD   Status = StatusFromHResult(hr);

    if (Status != ERROR_SUCCESS)
    {
       SetLastError(Status);
    }

    return Status == ERROR_SUCCESS;
}

/*++

Routine Name:

    BoolFromStatus

Description:

    This function sets the last error to the given win32 error code if it is not
    error success. It returns the corresponding error result.

Arguments:

    Status      -   The Win32 error code.

Returns:

    A BOOLEAN, Sets the last error

--*/
EXTERN_C
BOOL
BoolFromStatus(
    IN      DWORD       Status
    )
{
    BOOL    bRet = TRUE;

    if (ERROR_SUCCESS != Status)
    {
        SetLastError(Status);

        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\clink.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    CLink.cxx

Abstract:

    C linkage support for DEBUG support only.

Author:

    Albert Ting (AlbertT)  10-Oct-95

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG

extern DBG_POINTERS gDbgPointers;

HANDLE
DbgAllocBackTrace(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceMem;
}

HANDLE
DbgAllocBackTraceMem(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceMem;
}

HANDLE
DbgAllocBackTraceFile(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceFile;
}

VOID
DbgFreeBackTrace(
    HANDLE hBackTrace
    )
{
    delete (VBackTrace*)hBackTrace;
}

VOID
DbgCaptureBackTrace(
    HANDLE hBackTrace,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3
    )
{
    VBackTrace* pBackTrace = (VBackTrace*)hBackTrace;
    if( pBackTrace ){
        pBackTrace->hCapture( Info1, Info2, Info3 );
    }
}

HANDLE
DbgAllocCritSec(
    VOID
    )
{
    return (HANDLE)new MCritSec;
}

VOID
DbgFreeCritSec(
    HANDLE hCritSec
    )
{
    delete (MCritSec*)hCritSec;
}

BOOL
DbgInsideCritSec(
    HANDLE hCritSec
    )
{
    return ((MCritSec*)hCritSec)->bInside();
}

BOOL
DbgOutsideCritSec(
    HANDLE hCritSec
    )
{
    return ((MCritSec*)hCritSec)->bOutside();
}

VOID
DbgEnterCritSec(
    HANDLE hCritSec
    )
{
    ((MCritSec*)hCritSec)->vEnter();
}

VOID
DbgLeaveCritSec(
    HANDLE hCritSec
    )
{
    ((MCritSec*)hCritSec)->vLeave();
}

VOID
DbgSetAllocFail(
    BOOL bEnable,
    LONG cAllocFail
    )
{
    gbAllocFail = bEnable;
    gcAllocFail = cAllocFail;
}

PVOID
DbgGetPointers(
    VOID
    )
{
    return &gDbgPointers;
}

#else

//
// Stub these out so that non-DBG builds can link w/ debug spoolss.dll.
//

PVOID
DbgGetPointers(
    VOID
    )
{
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\csem.cxx ===
/*****************************************************************************\
* Class  CriticalSection - Implementation
*
* Copyright (C) 1998 Microsoft Corporation
*
* History:
*   Jun 10, 1998, Weihai Chen (weihaic)
*
\*****************************************************************************/

#include "spllibp.hxx"

CCriticalSection::CCriticalSection (void):
    m_bValid (TRUE)
{
    m_bValid = InitializeCriticalSectionAndSpinCount (&m_csec,0x80000000);
}


CCriticalSection::~CCriticalSection (void)
{

    if (m_bValid) {
        DeleteCriticalSection (&m_csec);
    }
}

BOOL
CCriticalSection::Lock (void)
const
{
    BOOL bRet;
    
    if (m_bValid) {
        EnterCriticalSection ((PCRITICAL_SECTION) &m_csec);
        bRet = TRUE;
    }   
    else {
        bRet = FALSE;
    }
        
    return bRet;
}

BOOL
CCriticalSection::Unlock (void)
const
{   
    BOOL bRet;
    
    if (m_bValid) {
        LeaveCriticalSection ((PCRITICAL_SECTION) &m_csec);
        bRet = TRUE;
    }
    else {
        bRet = FALSE;
    }
        
    return TRUE;
}

    
TAutoCriticalSection::TAutoCriticalSection (
    CONST TCriticalSection & refCrit):
    m_pCritSec (refCrit)
    
{
    m_bValid = m_pCritSec.Lock ();
}

TAutoCriticalSection::~TAutoCriticalSection ()
{
    if (m_bValid) 
        m_pCritSec.Unlock ();
}

BOOL 
TAutoCriticalSection::bValid (VOID) 
{ 
    return m_bValid; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\csrcrtsect.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    crtsect.cxx

Abstract:

    Critical Section class

Author:

    Steve Kiraly (SteveKi)  30-Mar-1997
    Mark Lawrence (mlawrenc) 08-Mar-2000

Revision History:

    Moved Over from debug library and changed name.  Note that
    the funny const_casts all over the place are to allow the
    methods to be exported as const. This is necessary in a class
    exports a const method that does not want to allow other methods to
    run. This is legitimate and it is cleaner to do this in one place
    (i.e. here)

--*/

#include "spllibp.hxx"
#include "CSRutility.hxx"
#include "CSRcrtsect.hxx"

namespace NCoreLibrary
{

TCriticalSection::
TCriticalSection(
    IN  BOOL        bPrealloc
    ) : m_hr(E_FAIL),
        m_dwOwnerId(0),
        m_uEnterCount(0)
{
    m_hr = Initialize(bPrealloc);
}

TCriticalSection::
~TCriticalSection(
    VOID
    )
{
    Release();
}

HRESULT
TCriticalSection::
IsValid(
    VOID
    ) const
{
    return m_hr;
}

HRESULT
TCriticalSection::
Enter(
    VOID
    ) const
{
    //
    // Since EnterCriticalSection cannot fail or throw an exception we just
    // return S_OK
    //

    EnterCriticalSection(const_cast<LPCRITICAL_SECTION>(&m_CriticalSection));

    const_cast<UINT &>(m_uEnterCount)++;
    const_cast<DWORD &>(m_dwOwnerId) = GetCurrentThreadId();

    return S_OK;
}

HRESULT
TCriticalSection::
Leave(
    VOID
    ) const
{
    const_cast<UINT &>(m_uEnterCount)--;

    if (m_uEnterCount == 0)
    {
        const_cast<DWORD &>(m_dwOwnerId) = 0;
    }

    LeaveCriticalSection(const_cast<LPCRITICAL_SECTION>(&m_CriticalSection));

    return S_OK;
}

HRESULT
TCriticalSection::
GetOwningThreadId(
    OUT     DWORD       *pdwThreadId
    )
{
    HRESULT hRetval = pdwThreadId ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *pdwThreadId = m_dwOwnerId;
    }

    return hRetval;
}


VOID
TCriticalSection::
CheckInCS(
    VOID
    ) const
{

    DWORD dwCurrentId = GetCurrentThreadId();
}


VOID
TCriticalSection::
CheckOutOfCS(
    VOID
    ) const
{
    DWORD dwCurrentId = GetCurrentThreadId();
}


HRESULT
TCriticalSection::
Initialize(
    BOOL    bPrealloc
    )
{
    HRESULT hRetval = E_FAIL;

    m_uEnterCount = 0;
    m_dwOwnerId   = 0;

    //
    // If the high order bit is set in InitializeCriticalSectionAndSpin
    // count, then the Event used internally will be allocated up front.
    // Then, Enter() is guaranteed not to throw an exception.
    //
    hRetval = InitializeCriticalSectionAndSpinCount(&m_CriticalSection, ((bPrealloc ? 1 : 0) << (sizeof(DWORD) * 8 - 1))) ? S_OK : GetLastErrorAsHResult();

    return hRetval;
}

VOID
TCriticalSection::
Release(
    VOID
    )
{
    if (SUCCEEDED(m_hr))
    {
        DeleteCriticalSection(&m_CriticalSection);
        m_hr = E_FAIL;
    }
}


TCriticalSection::TLock::
TLock(
    const TCriticalSection &CriticalSection
    ) : m_CriticalSection(CriticalSection)
{
    m_hr = m_CriticalSection.Enter();
}


TCriticalSection::TLock::
~TLock(
    VOID
    )
{
    if (SUCCEEDED(m_hr))
    {
        m_CriticalSection.Leave();
    }
}


TCriticalSection::TUnLock::
TUnLock(
    const TCriticalSection &CriticalSection
    ) : m_CriticalSection(CriticalSection)
{
    m_hr = m_CriticalSection.Leave();
}


TCriticalSection::TUnLock::
~TUnLock(
    VOID
    )
{
    if (SUCCEEDED(m_hr))
    {
        m_CriticalSection.Enter();
    }
}

} // namespace ncorlibrary
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\cstmarsh.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    cstmars.h

Abstract:

    Declarations for custom marshalling spooler structures sent via RPC/LPC

Author:

    Adina Trufinescu (AdinaTru) 01/27/00

Revision History:

    
--*/

inline
PBYTE
AlignIt(
    IN  PBYTE       Addr,
    IN  ULONG_PTR   Boundary
    );


BOOL
BasicMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );


BOOL
BasicMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );

BOOL
BasicMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );


BOOL
BasicMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );

BOOL
CustomMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\cstmarsh.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    cstmars.cxx

Abstract:

    Code for custom marshalling spooler structures sent via RPC/LPC

Author:

    Adina Trufinescu (AdinaTru) 01/27/00

Revision History:

    
--*/

#include "spllibp.hxx"
#pragma hdrstop

/*++

Routine Name:   

    AlignUp

Routine Description: 

    Aligns up address to specified boundary

Arguments:  

    Addr   --  pointer to be aligned
    Boundary -- alignment boundary

Return Value:  

    Aligned pointer

Last Error: 

    Not set

--*/
inline
PBYTE
AlignIt(
    IN  PBYTE       Addr,
    IN  ULONG_PTR   Boundary
    ) 
{
    return (PBYTE)(((ULONG_PTR) (Addr) + (Boundary - 1))&~(Boundary - 1));
}

/*++

Routine Name:   

    BasicMarshallDownStructure

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{

    PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    BOOL    ReturnValue = FALSE;   
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;        
    }

    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        //
        // Pointer fields only: Convert pointers to offsets.
        //
        if (pFieldInfo[Index].Type == PTR_TYPE) 
        {
            Offset = pFieldInfo[Index].Offset;

            pOffset = (PBYTE *) (pStructure + Offset);

            if (*pOffset)
            {
                *pOffset -= (ULONG_PTR)pStructure;                
            }
         }
    }

    ReturnValue = TRUE;

End:
    return ReturnValue;

}

/*++

Routine Name:   

    BasicMarshallDownEntry

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    return BasicMarshallDownStructure(pStructure, pFieldInfo);
}

/*++

Routine Name:   

    MarshallUpStructure

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled up
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters.
--*/
BOOL
BasicMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    DWORD32 dwStrOffset = 0;
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }
    
    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        //
        // Pointer fields only: Convert offsets to pointers.
        //
        if(pFieldInfo[Index].Type == PTR_TYPE) 
        {
            Offset = pFieldInfo[Index].Offset;

            pOffset = (PBYTE *)(pStructure + Offset);

            if (*pOffset)
            {
                *pOffset += (ULONG_PTR) pStructure;                
            }
         }
    }

    ReturnValue = TRUE;
    
End:
    return ReturnValue;
}

/*++

Routine Name:   

    BasicMarshallUpEntry

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    return BasicMarshallUpStructure(pStructure, pFieldInfo);
}

/*++

Routine Name:   

    CustomMarshallDownEntry

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled down structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    
Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    PBYTE   *pOffset = NULL;
    PBYTE   pLast = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    ULONG_PTR Size = 0;
    ULONG_PTR Alignment = 0;
    BOOL    ReturnValue = FALSE;   

    //
    // pLast keeps track of the end of the shrinked part of the structure.
    //
    for (Index = 0, pLast = pStructure;
         Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff;
         ++Index)
     {
        //
        // ShiftIndex keeps track of how many bytes the structure shrinked because of 
        // shifting data.
        // pOffset points to the next field in the structure.
        // pOffset needs to be adjusted with ShiftIndex since structure changed.
        //
        pOffset = (PBYTE *)(pStructure + Offset);        

        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // Calculate the offset relatively to the new place where 
                // the structure will lay down on 32bit (pNewStructure).
                //
                if (*pOffset)
                {
                    *pOffset -= (ULONG_PTR) pNewStructure;
                }
                //
                // For pointers, enforce the size and alignment as they are on 32b
                //
                Size = sizeof(DWORD32);

                Alignment = sizeof(DWORD32);

                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;

                Alignment = pFieldInfo[Index].Alignment;

                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }

        //
        // pLast is the place where the fields should lay, as it is on 32b
        //
        pLast = AlignIt(pLast, Alignment);
        //
        // Enforce the alignment
        //
        MoveMemory((PBYTE)pLast, 
                   (PBYTE)pOffset, 
                   Size);
        //
        // Update pLast. After this, pLast points to the end of the shrinked part of the structure
        //
        pLast += Size;
    }
 
    //
    // Move up the shrinked structure in the 32bit structures to became array
    //
    MoveMemory(pNewStructure, 
               pStructure, 
               StructureSize);

    ReturnValue = TRUE;
End:
    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallDownStructure

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    BOOL    ReturnValue = FALSE;    

    ReturnValue = CustomMarshallDownEntry(pStructure, pStructure, pFieldInfo, StructureSize);

    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallUpEntry

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.
    It also handles 32-64 bit machine compatibility.

Arguments:  

    pStructure   --  pointer to the structure to be marshalled up
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled up structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the structure as it is to be when marshalled up
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
CustomMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize
    )
{
    PBYTE   *pOffset = NULL;
    PBYTE   pOffsetAlign = NULL;
    PBYTE   pLast = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    DWORD32 dwStrOffset = 0;
    DWORD32 ShiftIndex = 0;
    ULONG_PTR   Size = 0;
    ULONG_PTR   Alignment = 0;
    BOOL    ReturnValue = FALSE;
    //
    // The structure is part of the array of shrinked structures as for 32bit. 
    // Before expanding, we need to move the structure down in it's place in the 
    // array of 64bit structures to be.
    //
    MoveMemory(pNewStructure, 
               pStructure, 
               ShrinkedSize);
    //
    // pLast keeps track of the end of the expanded part of the structure.
    //
    for (Index = 0, ShiftIndex = 0, pLast = pNewStructure;
         Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff;
         ++Index)
     {
        pOffset = (PBYTE *)(pNewStructure + Offset);

        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // ShiftIndex keeps track of how many bytes the structure expanded.
                // pLast points to the field of the 32b structure that needs to be marshalled.
                // pLast - ShiftIndex points where the field was on 32b including the enforced padding.
                // Align (pLast - ShiftIndex) as it use to be on 32b and than add the shifting 
                // to determine the place of this field.
                // 
                Alignment = sizeof(DWORD32);

                pOffsetAlign = AlignIt(pLast - ShiftIndex, Alignment);

                pLast = pOffsetAlign + ShiftIndex;

                //
                // Move field on it's offset on 64b.
                //        
                MoveMemory((PBYTE)pOffset, 
                           (PBYTE)pLast, 
                           StructureSize - Offset);

                ShiftIndex += (DWORD32)((ULONG_PTR)pOffset - (ULONG_PTR)pLast);
                
                //
                // Expand 32bit pointer to 64bit.
                //
                MoveMemory((PBYTE) pOffset + sizeof(ULONG64),
                           (PBYTE) pOffset + sizeof(ULONG32),
                           StructureSize - (Offset + sizeof(ULONG32) + sizeof(ULONG32)));

                ShiftIndex += sizeof(DWORD32);

                dwStrOffset = *(LPDWORD)pOffset;            
                //
                // Update pointer field if offset different than zero.
                //
                if (dwStrOffset)
                {
                    *pOffset = pStructure + dwStrOffset;
                }
                else
                {
                    *pOffset = NULL;
                }

                Size = sizeof(DWORD64);

                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;

                Alignment = pFieldInfo[Index].Alignment;
                //
                // Align (pLast - ShiftIndex) as it use to be on 32b and than add the shifting 
                // to determine the place of this field.
                //
                pOffsetAlign = AlignIt(pLast - ShiftIndex, Alignment);

                pLast = pOffsetAlign + ShiftIndex;
                //
                // Move field on it's 64b place.
                //
                MoveMemory((PBYTE)pOffset, 
                           (PBYTE)pLast, 
                           StructureSize - Offset);

                ShiftIndex += (DWORD32)((ULONG_PTR)pOffset - (ULONG_PTR)pLast);
                
                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }
        //
        // Again, pLast keeps track of the end of the expanded part of the structure.
        //            
        pLast = (PBYTE)pOffset + Size;
     }
 
    ReturnValue =  TRUE;
End:
    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallUpStructure

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    BOOL    ReturnValue = FALSE;

    ReturnValue = CustomMarshallUpEntry(pStructure, pStructure, pFieldInfo, StructureSize, StructureSize);
    
    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\dbglog.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.h

Abstract:

    New debug services for spooler.

Author:

    Albert Ting (AlbertT)  15-Jan-1995

Revision History:

--*/

#ifndef _DBGLOG_H
#define _DBGLOG_H

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD GENERROR, *PGENERROR;

/********************************************************************

DBGCHK

    Wraps any function that returns an unsigned 4 byte
    quantity with debug logging.

Arguments:

    expr - function/expression that needs to be tested

    uDbgLevel - print/break error level

    exprSuccess - expression that indicates function success
                  (GenError may be used as the expr return value)

    cgeFail - Count of items in pgeFails array

    pgeFails - Array of error return values (GenError) used
               when simulating failures (must be an array, not
               a pointer).

    pdwLastErrors - Array of error returned from GetLastError used
                    when simulating failures, zero terminated.

    argsPrint - Arguments to print/log in printf format.


Return Value:

    Result of the wrapped function or a simulated failure code.

Usage:

    lReturn = RegCreateKey( hKey,
                            L"SubKey",
                            &hKeyResult );

    should be re-written as:

    lReturn = DBGCHK( RegCreateKey( hKey,
                                    L"SubKey",
                                    &hKeyResult ),
                      DBG_ERROR,
                      GenError == ERROR_SUCCESS,
                      2, { ERROR_ACCESS_DENIED, ERROR_INVALID_PARAMETER },
                      NULL,
                      ( "CreateError 0x%x", hKey ));

    dwReturn = DBGCHK( GetProfileString( pszSection,
                                         pszKey,
                                         pszDefault,
                                         szReturnBuffer,
                                         COUNTOF( szReturnBuffer )),
                       DBG_WARN,
                       GenError != 0,
                       1, { 0 },
                       { ERROR_CODE_1, ERROR_CODE_2, 0 },
                       ( "GetProfileString: %s, %s, %s",
                          pszSection,
                          pszKey,
                          pszDefault ));

********************************************************************/

#define DBGCHK( expr,                                         \
                uDbgLevel,                                    \
                exprSuccess,                                  \
                cgeFail,                                      \
                pgeFails,                                     \
                pdwLastErrors,                                \
                argsPrint )                                   \
{                                                             \
    GENERROR GenError;                                        \
    LPSTR pszFileA = __FILE__;                                \
                                                              \
    if( !bDbgGenFail( pszFileA,                               \
                      __LINE__,                               \
                      cgeFail,                                \
                      pgeFails,                               \
                      pdwLastErrors,                          \
                      &GenError )){                           \
                                                              \
        GenError = (GENERROR)(expr);                          \
                                                              \
        if( !( exprSuccess )){                                \
                                                              \
            vDbgLogError( MODULE_DEBUG,                       \
                          uDbgLevel,                          \
                          __LINE__,                           \
                          pszFileA,                           \
                          MODULE,                             \
                          pszDbgAllocMsgA argsPrint );        \
        }                                                     \
    }                                                         \
    GenError;                                                 \
}

LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    );

BOOL
bDbgGenFail(
    LPCSTR    pszFileA,
    UINT      uLine,
    UINT      cgeFails,
    PGENERROR pgeFails,
    PDWORD    pdwLastErrors
    );

#ifdef __cplusplus
}
#endif

#endif // _DBGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\csrlist.inl ===
/*++

Copyright (C) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    list.cxx

Abstract:

    List template class.

Author:

    Steve Kiraly (SteveKi)  03-Mar-2000

Revision History:

--*/

/********************************************************************

 List class, used for intrusive list.

********************************************************************/

template<class T>
TList<T>::
TList(
    VOID
    )
{
}

template<class T>
TList<T>::
~TList(
    VOID
    )
{
    //
    // Release all the nodes.
    //
    TLink *pLink = m_Root.Next();
    TLink *pTemp = NULL;

    while (pLink != &m_Root)
    {
        pTemp = pLink;
        pLink = pLink->Next();
        delete pTemp;
    }
}

template<class T>
HRESULT
TList<T>::
IsValid(
    VOID
    ) const
{
    return S_OK;
}

template<class T>
BOOL
TList<T>::
IsEmpty(
    VOID
    )
{
    //
    // If the next pointer is ourself the list is empty.
    //
    return &m_Root == m_Root.Next();
}

template<class T>
BOOL
TList<T>::
IsLast(
    IN TLink *pLink
    )
{
    //
    // If the next pointer is ourself the link is the last one.
    //
    return pLink->Next() == &m_Root;
}

template<class T>
HRESULT
TList<T>::
AddAtHead(
    IN TLink *pLink
    )
{
    //
    // Check if the node is valid.
    //
    HRESULT hRetval = pLink ? pLink->IsValid() : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        //
        // Add the node at the head of the list.
        //
        hRetval = m_Root.Link(pLink);
    }

    return hRetval;
}

template<class T>
HRESULT
TList<T>::
AddAtTail(
    IN TLink *pLink
    )
{
    //
    // Check if the node is valid.
    //
    HRESULT hRetval = pLink ? pLink->IsValid() : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        //
        // Add the node at the tail of the list.
        //
        hRetval = m_Root.Prev()->Link(pLink);
    }

    return hRetval;
}

template<class T>
HRESULT
TList<T>::
Insert(
    IN TLink *pLink,
    IN TLink *pHere
    )
{
    //
    // Check if the node is valid.
    //
    HRESULT hRetval = pLink ? pLink->IsValid() : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = pHere ? pHere->IsValid() : E_INVALIDARG;

        if (SUCCEEDED(hRetval))
        {
            //
            // Link the specified node just after the apecified node.
            //
            hRetval = pHere->Link(pLink);
        }
        else
        {
            //
            // Link this node to the head of the list.
            //
            hRetval = m_Root.Link(pLink);
        }
    }

    return hRetval;
}

template<class T>
T *
TList<T>::
RemoveAtHead(
    VOID
    )
{
    TLink *pLink = m_Root.Next();

    pLink->UnLink();

    return pLink != &m_Root ? reinterpret_cast<T *>(pLink) : NULL;
}

template<class T>
T *
TList<T>::
RemoveAtTail(
    VOID
    )
{
    TLink *pLink = m_Root.Prev();

    pLink->UnLink();

    return pLink != &m_Root ? reinterpret_cast<T *>(pLink) : NULL;
}

template<class T>
HRESULT
TList<T>::
Remove(
    IN TLink *pLink
    )
{
    //
    // We only succeed if work was done.
    //
    HRESULT hRetval = E_FAIL;

    if (pLink)
    {
        //
        // Release the node, the caller must delete themselves.
        //
        pLink->UnLink();

        hRetval = S_OK;
    }

    return hRetval;
}

template<class T>
T *
TList<T>::
Head(
    VOID
    ) const
{
    TLink *pLink = m_Root.Next();
    return pLink != &m_Root ? reinterpret_cast<T *>(pLink) : NULL;
}

template<class T>
T *
TList<T>::
Tail(
    VOID
    ) const
{
    TLink *pLink = m_Root.Prev();
    return pLink != &m_Root ? reinterpret_cast<T *>(pLink) : NULL;
}

/********************************************************************

 List class, used for non intrusive list.

********************************************************************/

template<class T>
TLinkNi<T>::
TLinkNi(
    IN T *pInfo
    ) : m_pInfo(pInfo)
{
}

template<class T>
TLinkNi<T>::
~TLinkNi(
    VOID
    )
{
    m_pInfo = NULL;
}

template<class T>
HRESULT
TLinkNi<T>::
IsValid(
    VOID
    ) const
{
    return S_OK;
}

template<class T>
T *
TLinkNi<T>::
Get(
    VOID
    ) const
{
    return m_pInfo;
}

template<class T>
TLinkNi<T> *
TLinkNi<T>::
Next(
    VOID
    ) const
{
    return static_cast<TLinkNi<T> *>(TLink::Next());
}

template<class T>
TLinkNi<T> *
TLinkNi<T>::
Prev(
    VOID
    ) const
{
    return static_cast<TLinkNi<T> *>(TLink::Prev());
}

//
// Spooler non instrusive list template.
//
template<class T>
TListNi<T>::
TListNi(
    VOID
    ) : m_Root(NULL)
{
}

template<class T>
TListNi<T>::
~TListNi(
    VOID
    )
{
    //
    // Release all the nodes, the clients must release
    // their own data.
    //
    TLinkNi<T> *pNode = m_Root.Next();
    TLinkNi<T> *pTemp = NULL;

    while (pNode != &m_Root)
    {
        pTemp = pNode;
        pNode = pNode->Next();
        delete pTemp;
    }
}

template<class T>
HRESULT
TListNi<T>::
IsValid(
    VOID
    ) const
{
    return S_OK;
}

template<class T>
BOOL
TListNi<T>::
IsEmpty(
    VOID
    ) const
{
    //
    // If the next pointer is ourself the list is empty.
    //
    return &m_Root == m_Root.Next();
}

template<class T>
HRESULT
TListNi<T>::
AddAtHead(
    IN T *pData
    )
{
    return Insert(pData, &m_Root);
}

template<class T>
HRESULT
TListNi<T>::
AddAtTail(
    IN T *pData
    )
{
    return Insert(pData, m_Root.Prev());
}

template<class T>
HRESULT
TListNi<T>::
Insert(
    IN T            *pData,
    IN TLinkNi<T>   *pHere
    )
{
    HRESULT hRetval = E_FAIL;

    if (pData)
    {
        //
        // Create the new node with the data attached.
        //
        TLinkNi<T> *pNode = new TLinkNi<T>(pData);

        //
        // Check if the node is valid.
        //
        hRetval = pNode ? pNode->IsValid() : E_OUTOFMEMORY;

        if (SUCCEEDED(hRetval))
        {
            hRetval = pHere ? pHere->IsValid() : E_FAIL;

            if (SUCCEEDED(hRetval))
            {
                //
                // Link this node to the list.
                //
                hRetval = pHere->Link(pNode);
            }
            else
            {
                //
                // Link this node to the list.
                //
                hRetval = m_Root.Link(pNode);
            }
        }

        //
        // Something failed release the allocated node.
        //
        if (FAILED(hRetval))
        {
            delete pNode;
        }
    }

    return hRetval;
}

template<class T>
T *
TListNi<T>::
RemoveAtHead(
    VOID
    )
{
    T *pData = NULL;

    if (!IsEmpty())
    {
        pData = m_Root.Next()->Get();
        delete m_Root.Next();
    }

    return pData;
}

template<class T>
T *
TListNi<T>::
RemoveAtTail(
    VOID
    )
{
    T *pData = NULL;

    if (!IsEmpty())
    {
        pData = m_Root.Prev()->Get();
        delete m_Root.Prev();
    }

    return pData;
}

template<class T>
HRESULT
TListNi<T>::
Remove(
    IN TLinkNi<T>  *pNode
    )
{
    HRESULT hRetval = pNode ? pNode->IsValid() : E_FAIL;

    if (SUCCEEDED(hRetval))
    {
        //
        // Release the link, its the callers responsibility to release thier data.
        //
        delete pNode;
    }

    return bRetval;
}

template<class T>
HRESULT
TListNi<T>::
Remove(
    IN T *pData
    )
{
    HRESULT hRetval = E_FAIL;

    if (pData)
    {
        //
        // Locate the data and delete the node, the data
        // is not deleted, it is the callers responsibility
        // to delete their own data.
        //
        TLinkNi<T> *pNode = m_Root.Next();

        for (; pNode != &m_Root; pNode = pNode->Next())
        {
            if (pNode->Get() == pData)
            {
                delete pNode;
                hRetval = S_OK;
                break;
            }
        }
    }

    return hRetval;
}

template<class T>
T *
TListNi<T>::
Head(
    VOID
    ) const
{
    TListNi<T> *pLink = m_Root.Next();

    return pLink != &m_Root ? reinterpret_cast<T *>(pLink->Get()) : NULL;
}

template<class T>
T *
TListNi<T>::
Tail(
    VOID
    ) const
{
    TListNi<T> *pLink = m_Root.Prev();

    return pLink != &m_Root ? reinterpret_cast<T *>(pLink->Get()) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\dbgmsg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.h

Abstract:

    New debug services for spooler.

Author:

    Albert Ting (AlbertT)  15-Jan-1995

Revision History:

--*/

#ifndef _DBGLOG_H
#define _DBGLOG_H

/********************************************************************

    Setting up the debug support:
    =============================

    Define a MODULE prefix string.  Since this will be printed as
    a prefix to all debug output, it should be concise and unique.

    In your global header file:

        #define MODULE "prtlib:"

    Define a MODULE_DEBUG variable.  This is the actual symbol
    that the library will use to indicate debugging level.
    This DWORD is broken into two bitfield WORDs: the low word
    indicates which levels to print to the debugger; the high word
    breaks into the debugger.  The library takes the DebugLevel from
    a debug message, then ANDs it with the debug level.  If the bit
    is on, the corresponding action (print or break) is taken.

    In your global header file:

        #define MODULE_DEBUG PrtlibDebug

    Finally, the actual debug variable must be defined and initialized
    to a default debug level.  This must be done in exactly one
    *.c translation unit:

    In one of your source files:

        MODULE_DEBUG_INIT ( {LevelsToPrint}, {LevelsToBreak} );

    Adding logging to source code:
    ==============================

    The general format for debug message is:

        DBGMSG( {DebugLevel}, ( {args to printf} ));

    The DebugLevel dictates whether the level should print, break
    into the debugger, or just log to memory (logging always done).

    The args to printf must be placed in an extra set of parens,
    and should assume everything is ANSI.  To print LPTSTRs, use
    the TSTR macro:

        DBGMSG( DBG_WARN,
                ( "LPTSTR "TSTR", LPSTR %s, LPWSTR %ws\n",
                  TEXT("hello"), "hello", L"hello" ));

    Viewing DBGMSGs:
    ================

    Messages will print to the debugger (usermode, or kernel debugger
    if no usermode debugger is available) for all printable levels.
    To change the level, you can edit the MODULE_DEBUG variable
    (PrtlibDebug in the above example).

    By default, DBG_ERROR and DBG_WARNING messages a logged to the
    error log (stored at gpbterrlog).  All others are stored in the
    trace log (gpbttracelog).  These currently log to memory in
    a circular buffer.  Use the splx.dll extension to dump these
    logs.

    At compile time, you can switch these logs to go to file rather
    than memory.  They will be stored as the PID + index number in
    the default directory of the process.

********************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

//
// These values are strictly debug, but must be defined in the free
// build because the TStatus error checking uses them as the first ctr
// parameter.  (During inlining they are discarded.)
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100

#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000

#if DBG

extern DWORD MODULE_DEBUG;

//
// This should be used exactly once in a C file.  It defines
// the Debug variable, and also the DbgMsg function.
//
// If we are statically linking with SplLib (SplLib is a library, not
// a Dll), then we will get the definition from SplLib, so don't define
// it here.
//
#ifdef LINK_SPLLIB
#define MODULE_DEBUG_INIT( print, break )                              \
    DWORD MODULE_DEBUG = (DBG_PRINT( print ) | DBG_BREAK( break ))

#else // !LINK_SPLLIB

#ifdef _STRSAFE_H_INCLUDED_

#define MODULE_DEBUG_INIT( print, break )                                       \
    VOID                                                                        \
    DbgMsg(                                                                     \
        LPCSTR pszMsgFormat,                                                    \
        ...                                                                     \
        )                                                                       \
    {                                                                           \
        CHAR szMsgText[1024];                                                   \
        va_list vargs;                                                          \
                                                                                \
        va_start( vargs, pszMsgFormat );                                        \
        StringCchVPrintfA(szMsgText, COUNTOF(szMsgText), pszMsgFormat, vargs ); \
        va_end( vargs );                                                        \
                                                                                \
        if( szMsgText[0]  &&  szMsgText[0] != ' ' ){                            \
            OutputDebugStringA( MODULE );                                       \
        }                                                                       \
        OutputDebugStringA( szMsgText );                                        \
    }                                                                           \
    DWORD MODULE_DEBUG = (DBG_PRINT( print ) | DBG_BREAK( break ))

#else // !_STRSAFE_H_INCLUDED_

#define MODULE_DEBUG_INIT( print, break )                                       \
    VOID                                                                        \
    DbgMsg(                                                                     \
        LPCSTR pszMsgFormat,                                                    \
        ...                                                                     \
        )                                                                       \
    {                                                                           \
        CHAR szMsgText[1024];                                                   \
        va_list vargs;                                                          \
                                                                                \
        va_start( vargs, pszMsgFormat );                                        \
        wvsprintfA(szMsgText, pszMsgFormat, vargs);                             \
        va_end( vargs );                                                        \
                                                                                \
        if( szMsgText[0]  &&  szMsgText[0] != ' ' ){                            \
            OutputDebugStringA( MODULE );                                       \
        }                                                                       \
        OutputDebugStringA( szMsgText );                                        \
    }                                                                           \
    DWORD MODULE_DEBUG = (DBG_PRINT( print ) | DBG_BREAK( break ))

#endif // _STRSAFE_H_INCLUDED_

#endif // LINK_SPLLIB

#define DBGSTR( str ) \
    ((str) ? (str) : TEXT("(NULL)"))

#ifdef UNICODE
#define TSTR "%ws"
#else
#define TSTR "%s"
#endif

#define DBG_PRINT_MASK 0xffff
#define DBG_BREAK_SHIFT 16

#define DBG_PRINT(x) (x)
#define DBG_BREAK(x) (((x) << DBG_BREAK_SHIFT)|(x))

#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

VOID
DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    );

#ifdef DBGLOG

#define DBGMSG( uDbgLevel, argsPrint )             \
        vDbgLogError( MODULE_DEBUG,                \
                      uDbgLevel,                   \
                      __LINE__,                    \
                      __FILE__,                    \
                      MODULE,                      \
                      pszDbgAllocMsgA argsPrint )

LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    );

VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    );
#else

VOID
DbgBreakPoint(
    VOID
    );

#define DBGMSG( Level, MsgAndArgs )                 \
{                                                   \
    if( ( (Level) & 0xFFFF ) & MODULE_DEBUG ){      \
        DbgMsg MsgAndArgs;                          \
    }                                               \
    if( ( (Level) << 16 ) & MODULE_DEBUG )          \
        DbgBreakPoint();                            \
}

#endif

#else
#define MODULE_DEBUG_INIT( print, break )
#define DBGMSG( uDbgLevel, argsPrint )
#define SPLASSERT(exp)
#endif


//
// Automatic checking if an object is valid.
//
#if DBG

VOID
vWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    );

#define VALID_PTR(x)                                                \
    ((( x ) && (( x )->bValid( ))) ?                                \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_OBJ(x)                                                \
    ((( x ).bValid( )) ?                                            \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)&(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_BASE(x)                                               \
    (( x::bValid( )) ?                                              \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)this, MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#else
#define VALID_PTR(x) \
    (( x ) && (( x )->bValid()))
#define VALID_OBJ(x) \
    (( x ).bValid())
#define VALID_BASE(x) \
    ( x::bValid( ))
#endif

#ifdef __cplusplus
}
#endif

#endif // _DBGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\dnode.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dnode.inl

Abstract:

    Node template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/


template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(void):
    m_Data(NULL), 
    m_pPrev(NULL),
    m_Next(NULL)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(T item):
    m_Data(item), 
    m_pPrev(NULL),
    m_pNext(NULL)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(T item, TDoubleNode<T, KEYTYPE>* pPrev, TDoubleNode<T, KEYTYPE>* pNext):
    m_Data(item),
    m_pPrev(pPrev),
    m_pNext(pNext)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::~TDoubleNode(void)
{
    if (m_Data) {
        delete (m_Data);
    }
}

template <class T, class KEYTYPE>
void 
TDoubleNode<T, KEYTYPE>::SetNext (TDoubleNode<T, KEYTYPE> *pNode)
{
    m_pNext = pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TDoubleNode<T, KEYTYPE>::GetNext (void )
{
    return m_pNext;
}

template <class T, class KEYTYPE>
void 
TDoubleNode<T, KEYTYPE>::SetPrev (
    TDoubleNode<T, KEYTYPE> *pNode)
{
    m_pPrev = pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * TDoubleNode<T, KEYTYPE>::GetPrev (void )
{
    return m_pPrev;
}

template <class T, class KEYTYPE>
T TDoubleNode<T, KEYTYPE>::GetData (void )
{
    return m_Data;  
}

template <class T, class KEYTYPE>
void TDoubleNode<T, KEYTYPE>::SetData (T pData)
{
    m_Data = pData;
}


template <class T, class KEYTYPE>
BOOL TDoubleNode<T, KEYTYPE>::IsSameItem (T &item)
{
    return m_Data->Compare (item) == 0;

}

template <class T, class KEYTYPE>
BOOL TDoubleNode<T, KEYTYPE>::IsSameKey (KEYTYPE &key)
{
    return m_Data->Compare (key) == 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\debug.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.cxx

Abstract:

    Debug support

Author:

    Albert Ting (AlbertT)  28-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "trace.hxx"

#define DEFAULT_TRACE_TYPE TBackTraceMem
//#define DEFAULT_TRACE_TYPE TBackTraceFile // For tracing to file.

#define DEFAULT_MEM_TRACE_TYPE TBackTraceMem

extern HANDLE ghMemHeap;
extern HANDLE ghDbgMemHeap;
pfCreateThread gpfSafeCreateThread;

#if DBG

UINT gLogFilter = (UINT)-1;
VBackTrace* gpbtErrLog;
VBackTrace* gpbtTraceLog;

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );
DBG_POINTERS gDbgPointers;
PDBG_POINTERS gpDbgPointers;

extern VBackTrace* gpbtAlloc;
extern VBackTrace* gpbtFree;

/********************************************************************

    TStatus automated error logging and codepath testing.

********************************************************************/

TStatusBase&
TStatusBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBase&)*this;
}



TStatusBase&
TStatusBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBase&)*this;
}


DWORD
TStatus::
dwGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _dwStatus;
}


DWORD
TStatusBase::
operator=(
    DWORD dwStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA &&
        dwStatus != ERROR_SUCCESS &&
        dwStatus != _dwStatusSafe1 &&
        dwStatus != _dwStatusSafe2 &&
        dwStatus != _dwStatusSafe3 ){

#ifdef DBGLOG
        //
        // An unexpected error occured.  Log an error and continue.
        //
        vDbgLogError( _uDbg,
                      _uDbgLevel,
                      _uLine,
                      _pszFileA,
                      _pszModuleA,
                      pszDbgAllocMsgA( "TStatus set to %d\nLine %d, %hs\n",
                                       dwStatus,
                                       _uLine,
                                       _pszFileA ));
#else
        DBGMSG( DBG_WARN,
                ( "TStatus set to %d\nLine %d, %hs\n",
                  dwStatus,
                  _uLine,
                  _pszFileA ));
#endif

    }

    return _dwStatus = dwStatus;
}

/********************************************************************

    Same, but for HRESULTs.

********************************************************************/

TStatusHBase&
TStatusHBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusH&)*this;
}

TStatusHBase&
TStatusHBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusH&)*this;
}

HRESULT
TStatusHBase::
operator=(
    HRESULT hrStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //


    if( _pszFileA &&
        FAILED(hrStatus)           &&
        hrStatus != _hrStatusSafe1 &&
        hrStatus != _hrStatusSafe2 &&
        hrStatus != _hrStatusSafe3 ){

#ifdef DBGLOG
        //
        // An unexpected error occured.  Log an error and continue.
        //
        vDbgLogError( _uDbg,
                      _uDbgLevel,
                      _uLine,
                      _pszFileA,
                      _pszModuleA,
                      pszDbgAllocMsgA( "TStatusH set to %x\nLine %d, %hs\n",
                                       hrStatus,
                                       _uLine,
                                       _pszFileA ));
#else
        DBGMSG( DBG_WARN,
                ( "TStatusH set to %x\nLine %d, %hs\n",
                  hrStatus,
                  _uLine,
                  _pszFileA ));
#endif

    }

    return _hrStatus = hrStatus;
}

HRESULT
TStatusH::
hrGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _hrStatus;
}
/********************************************************************

    Same, but for BOOLs.

********************************************************************/

TStatusBBase&
TStatusBBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBBase&)*this;
}

TStatusBBase&
TStatusBBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBBase&)*this;
}

BOOL
TStatusB::
bGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _bStatus;
}


BOOL
TStatusBBase::
operator=(
    BOOL bStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA && !bStatus ){

        DWORD dwLastError = GetLastError();

        if( dwLastError != _dwStatusSafe1 &&
            dwLastError != _dwStatusSafe2 &&
            dwLastError != _dwStatusSafe3 ){

#ifdef DBGLOG
            //
            // An unexpected error occured.  Log an error and continue.
            //
            vDbgLogError( _uDbg,
                          _uDbgLevel,
                          _uLine,
                          _pszFileA,
                          _pszModuleA,
                          pszDbgAllocMsgA( "TStatusB set to FALSE, LastError = %d\nLine %d, %hs\n",
                                           GetLastError(),
                                           _uLine,
                                           _pszFileA ));
#else
            DBGMSG( DBG_WARN,
                    ( "TStatusB set to FALSE, LastError = %d\nLine %d, %hs\n",
                      GetLastError(),
                      _uLine,
                      _pszFileA ));
#endif

        }
    }

    return _bStatus = bStatus;
}


VOID
vWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )

/*++

Routine Description:

    Warns that an object is invalid.

Arguments:

Return Value:

--*/

{
#if DBGLOG
    vDbgLogError( uDbg,
                  DBG_WARN,
                  uLine,
                  pszFileA,
                  pszModuleA,
                  pszDbgAllocMsgA( "Invalid Object %x LastError = %d\nLine %d, %hs\n",
                                   (ULONG_PTR)pvObject,
                                   GetLastError(),
                                   uLine,
                                   pszFileA ));
#else
    DBGMSG( DBG_WARN,
            ( "Invalid Object %x LastError = %d\nLine %d, %hs\n",
              (DWORD)pvObject,
              GetLastError(),
              uLine,
              pszFileA ));
#endif
}


/********************************************************************

    Generic Error logging package.

********************************************************************/

VOID
DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    )
{
    CHAR szMsgText[1024];
    va_list vargs;

    va_start( vargs, pszMsgFormat );
    StringCchVPrintfA( szMsgText, COUNTOF(szMsgText), pszMsgFormat, vargs );
    va_end( vargs );

#ifndef DBGLOG
    //
    // Prefix the string if the first character isn't a space:
    //
    if( szMsgText[0]  &&  szMsgText[0] != ' ' ){
        OutputDebugStringA( MODULE );
    }
#endif

    OutputDebugStringA( szMsgText );
}


#ifdef DBGLOG

LPSTR
pszDbgAllocMsgA(
    LPCSTR  pszMsgFormatA,
    ...
    )
{
    CHAR szMsgTextA[1024];
    UINT cbStr;
    LPSTR pszMsgA;

    va_list vargs;

    va_start(vargs, pszMsgFormatA);

    __try
    {
        StringCchVPrintfA( szMsgTextA, COUNTOF(szMsgTextA), pszMsgFormatA, vargs );
    } __except(( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ||
                GetExceptionCode() == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH )
    {

        OutputDebugStringA( "SPL: <Bad DbgMsg !!> " );
        OutputDebugStringA( pszMsgFormatA );
    }

    va_end(vargs);

    cbStr = ( lstrlenA( szMsgTextA ) + 1 ) * sizeof( szMsgTextA[0] );

    pszMsgA = (LPSTR)DbgAllocMem( cbStr );

    if( pszMsgA ){
        CopyMemory( pszMsgA, szMsgTextA, cbStr );
    }

    return pszMsgA;
}


VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    )
{
    DWORD dwLastError = GetLastError();
    VBackTrace* pBackTrace = gpbtTraceLog;

    if(( uDbgLevel & DBG_PRINT_MASK & uDbg ) && pszMsgA ){

        if( !( uDbgLevel & DBG_NOHEAD )){

            OutputDebugStringA( pszModuleA );
        }
        OutputDebugStringA( pszMsgA );
    }

    if(( uDbgLevel << DBG_BREAK_SHIFT ) & uDbg ){

        DebugBreak();
    }

    if( gLogFilter & uDbgLevel  )
    {
        //
        // Log the failure.
        //

        //
        // Capture significant errors in separate error log.
        //
        if( uDbgLevel & DBG_ERRLOG_CAPTURE ){
            pBackTrace = gpbtErrLog;
        }

        if (pBackTrace)
        {
            pBackTrace->hCapture( (ULONG_PTR)pszMsgA,
                                  uLine | ( uDbgLevel << DBG_BREAK_SHIFT ),
                                  (ULONG_PTR)pszFileA );
        }
        else
        {
            //
            // Backtracing is not enabled, free the message string that is
            // passed in.
            //
            if(pszMsgA)
            {
                DbgFreeMem((PVOID)pszMsgA);
            }
        }
    }
    else
    {
        //
        // Just free up the memory if this line is not captured
        // actually this happens when uDbgLevel == DBG_NONE (0)
        //
        if( pszMsgA )
        {
            DbgFreeMem( (PVOID)pszMsgA );
        }
    }

    SetLastError( dwLastError );
}


#endif // def DBGLOG
#endif // DBG


/********************************************************************

    Initialization

********************************************************************/

#if DBG

BOOL
bSplLibInit(
    pfCreateThread pfSafeCreateThread
    )
{
    BOOL bValid;

    bValid = (ghMemHeap = HeapCreate( 0, 1024*4, 0 ))                       &&
             (ghDbgMemHeap = HeapCreate( 0, 1024*4, 0 ))                    &&
             (VBackTrace::bInit( ))                                         &&
#ifdef TRACE_ENABLED
             (gpbtAlloc = new DEFAULT_MEM_TRACE_TYPE)                       &&
             (gpbtFree = new DEFAULT_MEM_TRACE_TYPE)                        &&
             (gpbtErrLog = new DEFAULT_TRACE_TYPE( VBackTrace::kString ))   &&
             (gpbtTraceLog = new DEFAULT_TRACE_TYPE( VBackTrace::kString )) &&
#endif
             (MRefCom::gpcsCom = new MCritSec)                              &&
             MRefCom::gpcsCom->bValid();

    gpfSafeCreateThread = ( pfSafeCreateThread ) ? pfSafeCreateThread : CreateThread;

    if( bValid ){
        gDbgPointers.pfnAllocBackTrace = &DbgAllocBackTrace;
        gDbgPointers.pfnAllocBackTraceMem = &DbgAllocBackTraceMem;
        gDbgPointers.pfnAllocBackTraceFile = &DbgAllocBackTraceFile;
        gDbgPointers.pfnFreeBackTrace = &DbgFreeBackTrace;
        gDbgPointers.pfnCaptureBackTrace = &DbgCaptureBackTrace;
        gDbgPointers.pfnAllocCritSec = &DbgAllocCritSec;
        gDbgPointers.pfnFreeCritSec = &DbgFreeCritSec;
        gDbgPointers.pfnInsideCritSec = &DbgInsideCritSec;
        gDbgPointers.pfnOutsideCritSec = &DbgOutsideCritSec;
        gDbgPointers.pfnEnterCritSec = &DbgEnterCritSec;
        gDbgPointers.pfnLeaveCritSec = &DbgLeaveCritSec;
        gDbgPointers.pfnSetAllocFail = &DbgSetAllocFail;

        gDbgPointers.hMemHeap = ghMemHeap;
        gDbgPointers.hDbgMemHeap = ghDbgMemHeap;
        gDbgPointers.pbtAlloc = gpbtAlloc;
        gDbgPointers.pbtFree = gpbtFree;
        gDbgPointers.pbtErrLog = gpbtErrLog;
        gDbgPointers.pbtTraceLog = gpbtTraceLog;

        gpDbgPointers = &gDbgPointers;
    }
    return bValid;
}

VOID
vSplLibFree(
    VOID
    )
{
    SPLASSERT( MRefCom::gpcsCom->bOutside( ));
    delete MRefCom::gpcsCom;

    VBackTrace::vDone();

    if (ghMemHeap)
    {
        HeapDestroy( ghMemHeap );
        ghMemHeap = NULL;
    }

    if (ghDbgMemHeap)
    {
        HeapDestroy( ghDbgMemHeap );
        ghDbgMemHeap = NULL;
    }
}

#else

BOOL
bSplLibInit(
    pfCreateThread pfSafeCreateThread
    )
{
    UINT RetLen;
    UINT HeapFragValue = 2;

    gpfSafeCreateThread = ( pfSafeCreateThread ) ? pfSafeCreateThread : CreateThread;

    ghMemHeap = HeapCreate(0, 1024*4, 0);

    if (ghMemHeap)
    {
        //
        // Activate LFH (low fragmentation) for the spooler heap. We don't care if the
        // function fails. LFH won't go in effect if certain gflags are set.
        //
        HeapSetInformation(ghMemHeap,
                           HeapCompatibilityInformation,
                           &HeapFragValue,
                           sizeof(HeapFragValue));
    }

    return !!ghMemHeap;
}

VOID
vSplLibFree(
    VOID
    )
{
    if (ghMemHeap)
    {
        HeapDestroy( ghMemHeap );
        ghMemHeap = NULL;
    }
}

#endif

/********************************************************************

    Stub these out so non-debug builds will find them.

********************************************************************/

#if !DBG
#ifdef DBGLOG

LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    )
{
    return NULL;
}

VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    )
{
}

#else

VOID
vDbgMsg2(
    LPCTSTR pszMsgFormat,
    ...
    )
{
}

#endif // ndef DBGLOG
#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\dlistlck.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dlistlck.inl

Abstract:

    Double linked list with lock template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/

template <class T, class KEYTYPE>
TDoubleListLock<T, KEYTYPE>::TDoubleListLock<T, KEYTYPE>(void):
    m_bValid (FALSE)
{

    if (m_pList = new TDoubleList<T, KEYTYPE>) {
        if (m_pList->bValid ())
            m_bValid = TRUE;
    }

}

template <class T, class KEYTYPE>
TDoubleListLock<T, KEYTYPE>::~TDoubleListLock<T, KEYTYPE>(void)
{
    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ())  {
    
        delete m_pList;
        m_pList = NULL;
    }
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::InsertItem (T item)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->InsertItem (item);
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::AppendItem (T item)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->AppendItem (item);
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::DeleteItem (T item)
{
    BOOL    bRet = FALSE;

    if (m_bValid) {
        Lock();

        bRet = m_pList->DeleteItem (item);
    
        Unlock();
    }

    return FALSE;
}


template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::InsertNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->InsertNode (pNewNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::AppendNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->AppendNode (pNewNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::DeleteNode (TDoubleNode<T, KEYTYPE> *pNode)
{
    BOOL    bRet = FALSE;

    if (pNode && m_bValid) {
        
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
                         
            bRet = m_pList->DeleteNode (pNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleListLock<T, KEYTYPE>::GetHead (void)
{
    TDoubleNode<T, KEYTYPE> * pHead = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pHead = m_pList->GetHead ();
    }

    return pHead;
}

template <class T, class KEYTYPE>
BOOL  
TDoubleListLock<T, KEYTYPE>::GetTotalNode (PDWORD pdwCount)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);
        
        if (CritSec.bValid ()) {
            bRet = m_pList->GetTotalNode (pdwCount);
        }
    }
    return bRet;
}

template <class T, class KEYTYPE>
T TSrchDoubleListLock<T, KEYTYPE>::FindItemFromKey (KEYTYPE key)
{
    T pItem = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pItem = m_pList->FindItemFromKey (key);
    }

    return pItem;
}
    
template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TSrchDoubleListLock<T, KEYTYPE>::FindNodeFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> * pNode = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pNode = m_pList->FindNodeFromItem (item);
    
    }
    return pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TSrchDoubleListLock<T, KEYTYPE>::FindNodeFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> * pNode = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pNode = m_pList->FindNodeFromKey (key);
    
    }
    return pNode;
}

template <class T, class KEYTYPE>
T TSrchDoubleListLock<T, KEYTYPE>::FindItemFromItem (T item)
{
    T pItem = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  

            pItem = m_pList->FindItemFromItem (item);

    }
            
    return pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\marshall.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    marshall.hxx

Abstract:

    Declarations for marshalling spooler structures sent via RPC/LPC

Author:

    Ramanathan Venkatapathy (RamanV)   4/30/98

Revision History:

--*/


//
// 32-64 bit marshalling constants
//

#include "mType.h"

typedef enum _EDataSize 
{
	kPointerSize = sizeof (ULONG_PTR),

} EDataSize;

typedef enum _EPtrSize 
{
	kSpl32Ptr = 4,
    kSpl64Ptr = 8,

} EPtrSize ;

EXTERN_C
BOOL
MarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
BOOL
MarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );


EXTERN_C
BOOL
MarshallUpStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
BOOL
MarshallDownStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
DWORD
UpdateBufferSize(
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      cbStruct,
    IN  OUT LPDWORD pcbNeeded,
    IN  DWORD       cbBuf,
    IN  DWORD       dwError,
    IN  LPDWORD     pcReturned
    );

EXTERN_C
BOOL
GetShrinkedSize(
    IN  FieldInfo   *pFieldInfo,
    OUT SIZE_T      *pShrinkedSize      
    );

EXTERN_C
VOID
AdjustPointers(
    IN  PBYTE       pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  ULONG_PTR   cbAdjustment
    );    

EXTERN_C
VOID
AdjustPointersInStructuresArray(
    IN  PBYTE       pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  ULONG_PTR   cbAdjustment
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\marshall.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    marshall.cxx

Abstract:

    Code for custom marshalling spooler structures sent via RPC/LPC.
    It handles 32-64 bit machine compatibility depending on the route the call is comming.
    It can come either from Kernel mode (NATIVE_CALL), an in-proc winspool.drv call (NATIVE_CALL),
    a 32 bit process (RPC_CALL) or a 64 bit process (RPC_CALL). 
    For native calls we perform basic marshalling. For RPC_CALLS we perform custom marshalling.
    Because there is no way to distinguish if a call came from a 64b or 32b proc, we always do
    custom marshalling across processes/wire.

Author:

    Ramanathan Venkatapathy (RamanV)   4/30/98

Revision History:

    Adina Trufinescu (AdinaTru) 12/09/99
    
--*/

#include "spllibp.hxx"
#pragma hdrstop
#include "cstmarsh.h"


/*++

Routine Name:   

    GetShrinkedSize

Routine Description: 

    Calculates the size of a 64bit structure as it is on 32bit.

Arguments: 

    pFieldInfo    -- structure containing information about fields inside the structure.           
    pShrinkedSize -- how much difference it between the structure'ssize on 32bit and 64bit

Return Value:  

    Size of the 32bit structure.

Last Error: 
    
    Not set.

--*/
EXTERN_C
BOOL
GetShrinkedSize(
    IN  FieldInfo   *pFieldInfo,
    OUT SIZE_T      *pShrinkedSize
    )
{

    DWORD     Index = 0;
    ULONG_PTR Size = 0; 
    ULONG_PTR Alignment = 0;
    BOOL      ReturnValue = FALSE;
    

    *pShrinkedSize = 0;

    //
    // For each field in the structure adds the length and enforce field's alignment.
    // For data fileds, the alignment is the same on both 32b and 64b.
    //
    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // Treat pointers as they are on 32bit.
                //
                Size = sizeof(DWORD32);
                Alignment = sizeof(DWORD32);
                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;
                Alignment = pFieldInfo[Index].Alignment;
                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }
        //
        // Enforce alignment before adding the size of the next field.
        //
        *pShrinkedSize = (SIZE_T)(AlignIt((PBYTE)*pShrinkedSize, Alignment));
        //
        // Add field's size.
        //
        *pShrinkedSize += Size;
    }
    
    //
    // Almoust done. We need to align the 32b structure's size to 32bit since 
    // structures come as an array.
    //
    Alignment = sizeof(DWORD32);
    *pShrinkedSize = (SIZE_T)(AlignIt((PBYTE)*pShrinkedSize, Alignment));

    ReturnValue = TRUE;

End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallDownStructure

Routine Description: 

    Marshalls down structures to be sent via RPC/LPC.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    RpcRoute    --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{

    BOOL    ReturnValue = FALSE;   
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;        
    }
    
    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // 32 bit server does not require special marshalling; 
            //
            ReturnValue = BasicMarshallDownStructure(pStructure, pFieldInfo);

            break;
        }
        case kSpl64Ptr :
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing
                    //
                    ReturnValue = BasicMarshallDownStructure(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallDownStructure(pStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }

End:
    return ReturnValue;

}

/*++

Routine Name:   

    MarshallDownEntry

Routine Description: 

    Custom marshalls down structures to be sent via RPC/LPC.

Arguments:  

    pStructure   --  pointer to the structure to be marshalled down
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled down structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    RpcRoute    --  indicates what type of marshalling we should do
    
Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
MarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
  
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // 32 bit server does not require special marshalling
            //
            ReturnValue = BasicMarshallDownEntry(pStructure, pFieldInfo);

            break;
        }
        case kSpl64Ptr :
        {   
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallDownEntry(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallDownEntry(pStructure, pNewStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallUpStructure

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.

Arguments:  
    pStructure   --  pointer to the structure to be marshalled up
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the structure as it is to be when marsahlled up
    Route        --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            ReturnValue = BasicMarshallUpStructure(pStructure, pFieldInfo);
            break;
        }
        case kSpl64Ptr:
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallUpStructure(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallUpStructure(pStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallUpEntry

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.

Arguments:  

    pStructure      --  pointer to the structure to be marshalled up
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled up structures ( pStructure == pNewStructure on 32b)
    pFieldInfo      --  structure containing information about fileds inside the structure
    StructureSize   --  size of the structure as it is to be when marshalled up
    Route           -- determine what type of marshalling will be performed
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
MarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            ReturnValue = BasicMarshallUpEntry(pStructure, pFieldInfo);
            break;
        }
        case kSpl64Ptr :
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallUpEntry(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallUpEntry(pStructure, pNewStructure, pFieldInfo, 
                                                        StructureSize, ShrinkedSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            break;    
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallDownStructuresArray

Routine Description: 

    Custom marshalls down array of structures to be sent via RPC/LPC.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures and packed data
    cReturned   --  number of structures returned
    pFieldInfo   --  structure containing information about fields inside the structure
    StructureSize --  size of the 64bit structure 
    RpcRoute    --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallDownStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    DWORD   Index = 0;
    PBYTE   pStructure, pNewStructure;
    SIZE_T  ShrinkedSize = 0;
    BOOL    ReturnValue = FALSE;

    //
    // Check if there are any structures in the array.
    // This check must come before the one against pBufferArray and pFieldInfo.
    // If the Enum function didn't enumerate anything, we need to return success.
    //
    if (cReturned == 0) {
    
        ReturnValue = TRUE;
        goto End;
    }

    if (!pBufferArray || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // The size of the structure remains the same on 32b.
            //
            ShrinkedSize = StructureSize;

            break;
        }
        case kSpl64Ptr:
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // There is no need of special marshalling since the structures
                    // need to stay padding unaltered.
                    //
                    ShrinkedSize = StructureSize;
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // Get the size of the 32b structure ; it takes care of both pointers and pointers/data alignments 
                    //
                    if (!GetShrinkedSize(pFieldInfo, &ShrinkedSize))
                    {
                        goto End;
                    }
                    break; 
                }   
                default:
                {
                    //
                    // Unknown route size; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }   
            break;         
        }
        default: 
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto End;
        }
    }

    // 
    // pStructure is the pointer to the place where the 64b structure lays down in the array
    // pNewStructure is the pointer to the new place where the 32b structure will lay down in the array
    // MarshallDownEntry returns a pointer to the end of the just marshalled 32b structure which is  
    // the new place where the next 32b marshalled structure will lay down in the array
    //
    for( Index = 0, pNewStructure = pStructure = pBufferArray;
         Index < cReturned ; 
         Index++ , pStructure += StructureSize , pNewStructure += ShrinkedSize ) 
    {
        if (!MarshallDownEntry(pStructure, pNewStructure, pFieldInfo, StructureSize, Route))
        {
            goto End;
        }
    }

    ReturnValue = TRUE;

End:
    return ReturnValue;
    
}

/*++

Routine Name:   

    MarshallUpStructuresArray

Routine Description: 

    Custom marshalls up array of structures to be sent via RPC/LPC.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures and packed data
    cReturned    --  number of structures returned
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize -- size of the 64bit structure ( including the padding )
    Route         -- determine what type of marshalling will be performed
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallUpStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    INT32   Index = 0;
    PBYTE   pStructure, pNextStructure;
    SIZE_T  ShrinkedSize = 0;
    BOOL    ReturnValue = FALSE;
    
    //
    // Check if there are any structures in the array.
    // This check must come before the one against pBufferArray and pFieldInfo.
    // If the Enum function didn't enumerate anything, we need to return success.
    //
    if (cReturned == 0) {
    
        ReturnValue = TRUE;
        goto End;
    }

    if (!pBufferArray || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // The size of the structure remains the same on 32b.
            //
            ShrinkedSize = StructureSize;

            break;
        }
        case kSpl64Ptr:
        {
            //
            // Get the size of the 32b structure ; it takes care of both pointers and pointers/data alignments 
            //
            if (!GetShrinkedSize(pFieldInfo, &ShrinkedSize))
            {
                goto End;
            }            
            break;
        }
        default: 
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto End;
        }
    }
    
    //
    // pBufferArray is an array of 32b stuctures;
    // pStructure is the pointer to the place where the 32b structure lays down in the array
    // pNewStructure is the pointer to the new place where the 64b structure will lay down in the array
    //
    for (Index = cReturned - 1; Index >= 0 ; Index--) 
    {
        pStructure = pBufferArray + Index * ShrinkedSize;

        pNextStructure = pBufferArray + Index * StructureSize;

        if (!MarshallUpEntry(pStructure, pNextStructure, pFieldInfo, StructureSize, ShrinkedSize, Route))
        {
            goto End;
        }
    }

    ReturnValue = TRUE;
End:
    return ReturnValue;
}

/*++

Routine Name:   

    UpdateBufferSize

Routine Description: 

    UpdateBufferSize adjusts the number of bytes required for
    returning the structures based on 32 and 64 bit clients and servers.

Arguments:  

    pOffsets     - pointer to Offset struct
    cbStruct     - sizeof struct
    cbStructAlign - sizeof struct aligned on 32b
    pcNeeded     - pointer to number of bytes needed
    cbBuf        - sizeof input buffer
    dwError      - last error from RPC call
    pcReturned   - pointer to number of returned structures
                  (valid only if dwError == ERROR_SUCCESS)
    
Return Value:  

    Last Error; This function is called right after a RPC call.
    dwError is the return value of RPC call.
    The return value of this function is the result of applying of this code on the dwError.

Last Error: 

    Not set.

--*/
EXTERN_C
DWORD
UpdateBufferSize(
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      cbStruct,
    IN  OUT LPDWORD pcbNeeded,
    IN  DWORD       cbBuf,
    IN  DWORD       dwError,
    IN  LPDWORD     pcReturned
    )
{
    DWORD   cStructures = 0;
    SIZE_T  cbShrinkedStruct = 0;

    if (dwError != ERROR_SUCCESS &&
        dwError != ERROR_MORE_DATA &&
        dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // RpcCall failed, no need to update required size
        //
        goto End;
    }

    if (!cbStruct)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
           //
           // The pointers are not bigger on the server. Hence no adjustment is
           // required.
           //
           break;
        }
        case kSpl64Ptr:
        {            
            if (!GetShrinkedSize(pFieldInfo, &cbShrinkedStruct))
            {
                dwError = ERROR_INVALID_PARAMETER;
                goto End;
            }
        
            //
            // Increase the required size of buffer. This may be superfluous in the 64-64
            // connection but this solution is simpler than adjusting pcbNeeded on the server.
            // 
            // Count the number of structures to be returned
            // *pcbNeeded must be divided with the size of the structure on 32 bit.
            //
            cStructures = *pcbNeeded / (DWORD32)cbShrinkedStruct;        

            //
            // For each structure, pcbNeeded is increased with the number of bites the pointers shrink
            // and the number of bites needed fpr padding
            // cbStruct - cbStructAlign is the number of bytes the compiler padds
            //
            *pcbNeeded += (DWORD) (cStructures * (cbStruct - cbShrinkedStruct));

            if (cbBuf < *pcbNeeded && dwError == ERROR_SUCCESS)
            {
               dwError = ERROR_INSUFFICIENT_BUFFER;
            }            

            break;
        }
        default: 
        {
            //
            // Invalid pointer size; should not occur.
            //
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
    }

End:
    return dwError;
}


/*++

Routine Name:   

    AdjustPointers

Routine Description: 

    AdjustPointers adjusts pointer fields inside the structure.

Arguments:  

    pStructure   -- pointer to a structructure
    pFieldInfo   -- contains information about fields inside the structure
    cbAdjustment -- quantity to add to all pointer fields inside the structure
    
Return Value:  

    None.

Last Error: 

    Not set.

--*/
EXTERN_C
VOID
AdjustPointers
(   IN  PBYTE       pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  ULONG_PTR   cbAdjustment
    )    
{   PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    
    for (Index = 0; Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff; ++Index) 
    {
        if (pFieldInfo[Index].Type == PTR_TYPE) 
        {
            pOffset = (PBYTE *)(pStructure + Offset);

            if ( *pOffset )
            {
                *pOffset += (ULONG_PTR)cbAdjustment;
            }
        }
    }
}



/*++

Routine Name:   

    AdjustPointersInStructuresArray

Routine Description: 

    AdjustPointersInStructuresArray adjusts pointer fields 
    inside the each structure of an array.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures
    cReturned    --  number of structures in array
    pFieldInfo   -- contains information about fields inside the structure
    StructureSize -- size of structure 
    cbAdjustment -- quantity to add to all pointer fields inside the structure
    
Return Value:  

    None.

Last Error: 

    Not set.

--*/
EXTERN_C
VOID
AdjustPointersInStructuresArray(
    IN  PBYTE       pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  ULONG_PTR   cbAdjustment
    )    
{   
    INT32   Index = 0;
    PBYTE   pStructure;
    
    if (cReturned && cbAdjustment && pBufferArray && pFieldInfo) 
    {
        for (Index = cReturned - 1; Index >= 0 ; Index--) 
        {
            pStructure = pBufferArray + Index * StructureSize;

            //
            // Call AdjustPointers for each entry in the array
            //
            AdjustPointers(pStructure, pFieldInfo, cbAdjustment);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\dlist.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dlist.inl

Abstract:

    Double linked list template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

    Weihai Chen (WeihaiC) 03/08/00 Rename to T*
    
--*/

template <class T, class KEYTYPE>
TDoubleList<T, KEYTYPE>::TDoubleList<T, KEYTYPE>(void):
    m_pHead (NULL),
    m_pTail (NULL),
    m_dwNumNode (0),
    m_bValid (TRUE)
{
}

template <class T, class KEYTYPE>
TDoubleList<T, KEYTYPE>::~TDoubleList<T, KEYTYPE>(void)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;
    TDoubleNode<T, KEYTYPE> *pNext;

    while (pNode) {
        pNext = pNode->GetNext();
        delete pNode;
        pNode = pNext;
    }
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::InsertItem (T item)
{
    BOOL bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);

    if (pNewNode) {
        bRet = InsertNode (pNewNode);
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::AppendItem (T item)
{
    BOOL bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);

    if (pNewNode) {
        bRet = AppendNode (pNewNode);
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::DeleteItem (T item)
{
    BOOL    bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;
    while (pNode) {
        if (pNode->IsSameItem (item)) {
            // Delete it
            DeleteNode (pNode);
            delete (item);
            bRet = TRUE;
            break;
        }
        pNode = pNode->GetNext();
    }

    return bRet;
}

template <class T, class KEYTYPE>
T TDoubleList<T, KEYTYPE>::GetItemFromIndex (DWORD dwIndex)
{
    TDoubleNode<T, KEYTYPE> *pNode = GetNodeFromIndex (dwIndex);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}


template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleList<T, KEYTYPE>::GetNodeFromIndex (DWORD dwIndex)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    DWORD i = 0;

    while (pNode && i < dwIndex) {
        i++;
        pNode = pNode->GetNext();
    }

    return pNode;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::InsertNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;


    if (pNewNode) {
        if (m_pHead) {
            pNewNode->SetNext (m_pHead);
            pNewNode->SetPrev (NULL);
            
            m_pHead->SetPrev (pNewNode);
        }
        else {
            // This is the first node
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (NULL);
            m_pTail = pNewNode;
        }
        m_pHead = pNewNode;
        m_dwNumNode ++;
        bRet = TRUE;
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::AppendNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;


    if (pNewNode) {
        if (m_pTail) {
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (m_pTail);
            
            m_pTail->SetNext (pNewNode);
        }
        else {
            // This is the first node
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (NULL);
            m_pHead = pNewNode;
        }
        m_pTail = pNewNode;
        m_dwNumNode ++;
        bRet = TRUE;
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::DeleteNode (TDoubleNode<T, KEYTYPE> *pNode)
{
    TDoubleNode<T, KEYTYPE> *pNextNode;
    TDoubleNode<T, KEYTYPE> *pPrevNode;
    BOOL    bRet = FALSE;

    if (pNode) {
        

        // It is not the first one, i.e. not the only one
        pNextNode = pNode->GetNext ();
        pPrevNode = pNode->GetPrev ();

        if (pNextNode) {
            pNextNode->SetPrev (pPrevNode);
        }
        else {
            m_pTail = pPrevNode;
        }
        
        if (pPrevNode) {
            pPrevNode->SetNext (pNextNode);
        }
        else {
            // It is the first one
            m_pHead = pNextNode;
        }

        m_dwNumNode --;
        bRet = TRUE;
    }
    return bRet;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleList<T, KEYTYPE>::GetHead (void)
{
    TDoubleNode<T, KEYTYPE> * pHead = NULL;

    pHead =  m_pHead;

    return pHead;
}

template <class T, class KEYTYPE>
BOOL  
TDoubleList<T, KEYTYPE>::GetTotalNode (PDWORD pdwCount)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {
        *pdwCount = m_dwNumNode;
        bRet = TRUE;
    }
    return bRet;
}

template <class T, class KEYTYPE>
T TSrchDoubleList<T, KEYTYPE>::FindItemFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> *pNode = FindNodeFromItem (item);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}

template <class T, class KEYTYPE>
T TSrchDoubleList<T, KEYTYPE>::FindItemFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> *pNode = FindNodeFromKey (key);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TSrchDoubleList<T, KEYTYPE>::FindNodeFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    while (pNode) {
        if (pNode->IsSameItem (item)) {
            return pNode;
        }
        pNode = pNode->GetNext();
    }


    return NULL;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TSrchDoubleList<T, KEYTYPE>::FindNodeFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    while (pNode) {
        if (pNode->IsSameKey (key)) {
            return pNode;
        }
        pNode = pNode->GetNext();
    }


    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\mem.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Mem.cxx

Abstract:

    Memory manipulations

Author:

    Albert Ting (AlbertT)  20-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

HANDLE ghMemHeap;

#if defined( CHECKMEM ) || DBG
LONG gcbMem = 0;
#endif

#if DBG

HANDLE ghDbgMemHeap;

VBackTrace* gpbtAlloc;
VBackTrace* gpbtFree;

/*++

    Memory fail test code

    This is test code (checked builds only) that fails memory allocations
    at regular intervals.  It helps detect cases where we are not checking
    memory return errors.

    Every gcAlloc allocations, it will try to fail.  However, if it detects
    that it has failed at that backtrace in the past, it will not fail
    and try to fail at the next allocation.

    Once it has failed, the counter is reset.

    To enable, set gbAllocFail to 1 (usually from the debugger).

    If you find an allocation and want to fail at it again, set the
    gAllocFailHash to the hash value of the failure, then also
    set gAllocFailHashAction to 1 (for fail) or 2 (for break and fail).


    gbAllocFail controls whether the alloc fail is enabled.
    gcAlloc is the current count of allocs.
    gcAllocFail indicates how often we fail (every gcAllocFail allocs).

--*/

BOOL gbAllocFail = FALSE;
LONG gcAlloc = 0;
LONG gcAllocFail = 0x20;
ULONG gAllocFailHash = 0;

enum EAllocFailHashAction {
    kIgnore = 0,
    kFail = 1,
    kBreakFail = 2
};

EAllocFailHashAction gAllocFailHashAction = kIgnore;

PVOID
DbgAllocMem(
    UINT cbSize
    )
{
    return HeapAlloc( ghDbgMemHeap, 0, cbSize );
}

VOID
DbgFreeMem(
    PVOID pMem
    )
{
    if( pMem ){
        HeapFree( ghDbgMemHeap, 0, pMem );
    }
}


#endif

PVOID
AllocMem(
    UINT cbSize
    )

/*++

Routine Description:

    Allocates memory.  If CHECKMEM is defined, adds tail guard.

Arguments:

Return Value:

--*/

{
#if defined( CHECKMEM ) || DBG
    PULONG_PTR pMem;
    UINT      cbNew;

    cbNew = DWordAlign(cbSize+3*sizeof(*pMem));

    pMem = (PULONG_PTR)HeapAlloc( ghMemHeap, 0, cbNew );

    if (!pMem) {

        //
        // HeapAlloc either raises an exception or returns NULL, but does not set the last error
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return NULL;
    }

    FillMemory(pMem, cbNew, 0x83);

    pMem[0] = cbSize;

#if DBG
    HANDLE hData;
    ULONG Hash = 0;

    hData = gpbtAlloc ?
                gpbtAlloc->hCapture( (ULONG_PTR)&pMem[2], cbSize, 0, &Hash ) :
                NULL;

    pMem[1] = reinterpret_cast<ULONG_PTR>( hData );

    //
    // Test if what happens if out of memory failures
    // occur.
    //
    if( gbAllocFail && gpbtAlloc){

        BOOL bHashCase;

        bHashCase = ( Hash == gAllocFailHash ) &&
                    ( gAllocFailHashAction != kIgnore );

        if( bHashCase ||
            ( InterlockedCompareExchange( &gcAlloc, 0, 0 ) == 0 )){

            BOOL bBreak = bHashCase && ( gAllocFailHashAction == kBreakFail );

            PLONG plCount;

            plCount = gpbtAlloc->plGetCount( hData );

            //
            // Counter started at -1, so if it is 0 now, then fail
            // the allocation.
            //
            if( bBreak ||
                ( plCount && InterlockedIncrement( plCount ) == 0 )){

                gpbtAlloc->hCapture( 0, cbSize );
                HeapFree( ghMemHeap, 0, (PVOID)pMem );
                pMem = NULL;

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );

                //
                // Reset the counter to the negative number.
                //
                InterlockedExchangeAdd( &gcAlloc, -gcAllocFail );

                if( bBreak ){
                    OutputDebugStringA( "Reached AllocFail Hash.\n" );
                    DebugBreak();
                }

                return NULL;
            }
        } else {

            //
            // We didn't reach zero.  Increment the count.
            //
            InterlockedIncrement( &gcAlloc );
        }
    }

#endif

    InterlockedExchangeAdd( &gcbMem, cbNew );

    *(PDWORD)((PBYTE)pMem + cbNew - sizeof(ULONG_PTR)) = 0xdeadbeef;

    return (PVOID)(pMem+2);
#else

    VOID *pMem = HeapAlloc(ghMemHeap, 0, cbSize);

    if (!pMem)
    {
        //
        // HeapAlloc either raises an exception or returns NULL, but does not set the last error
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return pMem;
#endif
}

VOID
FreeMem(
    PVOID pMem
    )
{
    if( !pMem ){
        return;
    }

#if defined( CHECKMEM ) || DBG
    DWORD   cbSize;
    PULONG_PTR pNewMem;

    pNewMem = (PULONG_PTR)pMem;
    pNewMem -= 2;

    cbSize = (DWORD)*pNewMem;
    InterlockedExchangeAdd( &gcbMem, -(LONG)cbSize );

    if (*(PDWORD)((PBYTE)pMem + DWordAlign(cbSize)) != 0xdeadbeef) {

        DBGMSG( DBG_ERROR,
                ( "Corrupt Memory: %x size = 0x%x\n",
                   pMem,
                   cbSize ));

    } else {

        FillMemory(pNewMem, cbSize, 0x65);
        HeapFree( ghMemHeap, 0, (PVOID)pNewMem );

#if DBG
        if( gpbtFree ){
            gpbtFree->hCapture( (ULONG_PTR)pMem, cbSize );
        }
#endif
    }
#else
    HeapFree( ghMemHeap, 0, (PVOID)pMem );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\loadlib.cxx ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation
All rights reserved.

Module Name:

    loadlib.cxx

Abstract:

    Library Loader helper class        
         
Author:

    Steve Kiraly (SteveKi) 10/17/95

Revision History:

--*/
#include "spllibp.hxx"
#pragma hdrstop

TLibrary::
TLibrary(
    LPCTSTR pszLibName
    ) 
{
    _hInst = LoadLibrary( pszLibName );

    if( !_hInst )
    {
        DBGMSG( DBG_WARN, ( "Library.ctr: unable to load "TSTR"\n", pszLibName ));
    }
}

TLibrary::
~TLibrary(
    )
{
    if( bValid() )
    {
        FreeLibrary( _hInst );
    }
}

BOOL
TLibrary::
bValid(
    VOID
    ) const
{
    return _hInst != NULL;
}

FARPROC
TLibrary::
pfnGetProc(
    IN LPCSTR pszProc
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, pszProc ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %s\n", pszProc ));
    }
    return fpProc;
}

FARPROC
TLibrary::
pfnGetProc(
    IN UINT uOrdinal
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, (LPCSTR)MAKELPARAM( uOrdinal, 0 ) ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %d\n", uOrdinal ));
    }
    return fpProc;
}

HINSTANCE
TLibrary::
hInst(
    VOID
    ) const
{
    return _hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\memblock.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    memblock.cxx

Abstract:

    Memory allocater for chunks of read only memory.

Author:

    Albert Ting (AlbertT)  30-Aug-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

TMemBlock::
TMemBlock(
    UINT uGranularity,
    DWORD fdwFlags) :
    _uGranularity(uGranularity),
    _pIterBlock(NULL),
    _pIterData(NULL),
    _dwCount(0),
    _fdwFlags(fdwFlags)
{
    DWORD dwSize = dwBlockHeaderSize() + _uGranularity;

    if( _fdwFlags & kFlagGlobalNew ){

        _pLast = (PBLOCK) new BYTE[dwSize];

    } else {

        _pLast = (PBLOCK)AllocMem( dwSize );
    }

    _pFirst = _pLast;

    if (_pFirst) {
        _pFirst->pNext = NULL;
        _dwNextFree = dwBlockHeaderSize();
    }
}

TMemBlock::
~TMemBlock()
{
    PBLOCK pBlock;
    PBLOCK pBlockNext;

    for (pBlock = _pFirst; pBlock; pBlock = pBlockNext) {

        pBlockNext = pBlock->pNext;

        if( _fdwFlags & kFlagGlobalNew ){

            delete [] (PBYTE)pBlock;

        } else {

            //
            // Our Delete must mirror the New.
            //
            FreeMem(pBlock);
        }
    }
}

PVOID
TMemBlock::
pvAlloc(
    DWORD dwSize
    )
{
    PDATA pData;

    //
    // If out of memory, fail.
    //
    if (!_pFirst) {
        goto FailOOM;
    }

    dwSize = Align(dwSize + dwDataHeaderSize());

    SPLASSERT(dwSize <= _uGranularity);

    if (dwSize + _dwNextFree > _uGranularity) {

        DWORD dwSize = dwBlockHeaderSize() + _uGranularity;

        //
        // Must allocate a new block
        //
        if( _fdwFlags & kFlagGlobalNew ){

            _pLast->pNext = (PBLOCK) new BYTE[dwSize];

        } else {

            _pLast->pNext = (PBLOCK)AllocMem( dwSize );
        }

        if (!_pLast->pNext) {
            goto FailOOM;
        }

        _pLast = _pLast->pNext;
        _pLast->pNext = NULL;

        _dwNextFree = dwBlockHeaderSize();
   }

   //
   // We have enough space in this link now;
   // update everything.
   //

   pData = (PDATA)((PBYTE)_pLast + _dwNextFree);
   pData->dwSize = dwSize;

   _dwNextFree += dwSize;
   _pLast->pDataLast = pData;
   _dwCount++;

   return pvDataToUser(pData);

FailOOM:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return NULL;
}

PVOID
TMemBlock::
pvFirst(
    VOID
    )
{
    if (!_dwCount) {
        return NULL;
    }

    _pIterBlock = _pFirst;
    _pIterData = pBlockToData(_pIterBlock);
    _dwIterCount = 0;

    return pvDataToUser(_pIterData);
}

PVOID
TMemBlock::
pvIter(
    VOID
    )
{
    _dwIterCount++;

    if (_dwIterCount == _dwCount)
        return NULL;

    //
    // Go to next block.  If we're at the last pData, go to next block.
    //
    if (_pIterData == _pIterBlock->pDataLast) {

        _pIterBlock = _pIterBlock->pNext;
        _pIterData = pBlockToData(_pIterBlock);

    } else {

        _pIterData = pDataNext(_pIterData);
    }

    return pvDataToUser(_pIterData);
}


UINT
TMemBlock::
uSize(
    PVOID pvUser
    ) const
{
    return pvUserToData(pvUser)->dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\sitem.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    sitem.inl

Abstract:

    Item template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/


template <class T>
CSingleItem<T>::CSingleItem(void)
               : m_Data(NULL), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item)
               : m_Data(item), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item, CSingleItem<T>* next)
               : m_Data(item), m_Next(next)
{
}

template <class T>
CSingleItem<T>::~CSingleItem(void)
{
    if (m_Data) {
        delete (m_Data);
    }
}

template <class T>
void CSingleItem<T>::SetNext (CSingleItem<T> *item)
{
    m_Next = item;
}

template <class T>
CSingleItem<T> * CSingleItem<T>::GetNext (void )
{
    return m_Next;
}

template <class T>
T CSingleItem<T>::GetData (void )
{
    return m_Data;
}


template <class T>
BOOL CSingleItem<T>::IsSame (T &item)
{
    return m_Data->Compare (item) == 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\safewrap.cxx ===
/*++

Copyright (c) 1994-1995  Microsoft Corporation
All rights reserved.

Module Name:

    safewrap.cxx

Abstract:

    This implements safe-wrappers for various system APIs.

Author:

    Mark Lawrence (MLawrenc)

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"
#include "safewrap.hxx"

/*++

Routine Name:

    LoadLibraryFromSystem32

Routine Description:

    Load the dll from system32 directory

Arguments:

    lpLibFileName   - Library file name

Return Value:

    If the function succeeds, the return value is the handle;
    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

--*/
HINSTANCE
LoadLibraryFromSystem32(
    IN LPCTSTR lpLibFileName
    )
{
    HINSTANCE hLib = NULL;

    static const TCHAR cszBackSlash[] = TEXT("\\");
    static const TCHAR cszSystem32[] = TEXT("system32\\");

    TCHAR szWindowDir[MAX_PATH];
    LPTSTR pszPath = NULL;
    DWORD dwWinDirLen = 0;

    if (dwWinDirLen = GetSystemWindowsDirectory (szWindowDir, MAX_PATH))
    {
        size_t cPathLen = dwWinDirLen + lstrlen (lpLibFileName) + COUNTOF (cszSystem32) + 2;
        pszPath = new TCHAR [cPathLen];

        if (pszPath)
        {
            StringCchCopy (pszPath, cPathLen, szWindowDir);

            if (szWindowDir[dwWinDirLen - 1] != cszBackSlash[0])
            {
                StringCchCat (pszPath, cPathLen, cszBackSlash);
            }

            StringCchCat (pszPath, cPathLen, cszSystem32);
            StringCchCat (pszPath, cPathLen, lpLibFileName);

            hLib = LoadLibrary(pszPath);
        }

        delete [] pszPath;
    }

    return hLib;
}

/*++

Routine Name:

    SafeQueryValueAsStringPointer

Routine Description:

    This does a query value on a string type. It guarantees:

    1. The value retrieved is a REG_SZ.
    2. The returned string is NULL terminated.

Arguments:

    hKey        -   The key to retrieve the value from.
    pValueName  -   The value field.
    ppszString  -   The returned string, use FreeSplMem to free it.
    cchHint     -   A hint for the size of the buffer we would most likely need,
                    use 0 if you have no idea, or don't care about two round
                    trips.

Return Value:

    An HRESULT - S_OK       - Everything succeeded.
                 S_FALSE    - The string was read, but was not NULL terminated
                              in the registry.

--*/
HRESULT
SafeRegQueryValueAsStringPointer(
    IN      HKEY            hKey,
    IN      PCWSTR          pValueName,
        OUT PWSTR           *ppszString,
    IN      DWORD           cchHint         OPTIONAL
    )
{
    HRESULT hr              = pValueName && ppszString? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    DWORD   cbData          = 0;
    DWORD   Type            = 0;
    BOOL    bTruncated      = FALSE;
    BOOL    bNullInRegistry = FALSE;
    PWSTR   pszString       = NULL;

    if (SUCCEEDED(hr))
    {
        if (cchHint)
        {
            pszString = reinterpret_cast<PWSTR>(AllocSplMem(cchHint * sizeof(WCHAR)));

            hr = pszString ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }
    }

    if (SUCCEEDED(hr))
    {
        cbData = cchHint * sizeof(WCHAR);

        hr = HResultFromWin32(RegQueryValueEx(hKey, pValueName, NULL, &Type, reinterpret_cast<BYTE *>(pszString), &cbData));

        //
        // This code in only unicode.
        //
        hr = SUCCEEDED(hr) ? (Type == REG_SZ && !(cbData & 0x01) ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
    }

    //
    // If this succeeded and we were passed a hint, then check and NULL terminate the string.
    //
    if (SUCCEEDED(hr) && pszString)
    {

        hr = CheckAndNullTerminateRegistryBuffer(pszString, cchHint, cbData / sizeof(WCHAR), &bTruncated, &bNullInRegistry);

        //
        // If we could not NULL terminate inside the buffer, then we will re-read using
        // the advertised registry buffer size
        //
        hr = SUCCEEDED(hr) ? (bTruncated ? HRESULT_FROM_WIN32(ERROR_MORE_DATA) : S_OK) : hr;
    }

    if (SUCCEEDED(hr))
    {
        if (pszString)
        {
            *ppszString = pszString;
            pszString = NULL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
    }

    FreeSplMem(pszString);
    pszString = NULL;

    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
    {
        //
        // On our next read, we always add 1 to the buffer size. This is so that
        // we can be guaranteed of NULL termination (assuming the registry value
        // hasn't changed).
        //
        cchHint = (cbData + sizeof(WCHAR) - 1) / sizeof(WCHAR) + 1;

        pszString = reinterpret_cast<PWSTR>(AllocSplMem(cchHint * sizeof(WCHAR)));

        hr = pszString ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

        if (SUCCEEDED(hr))
        {
            cbData = cchHint * sizeof(WCHAR);

            hr = HResultFromWin32(RegQueryValueEx(hKey, pValueName, NULL, &Type, reinterpret_cast<BYTE *>(pszString), &cbData));

            hr = SUCCEEDED(hr) ? (Type == REG_SZ && !(cbData & 0x01) ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
        }

        if (SUCCEEDED(hr))
        {
            hr = CheckAndNullTerminateRegistryBuffer(pszString, cchHint, cbData / sizeof(WCHAR), &bTruncated, &bNullInRegistry);

            hr = SUCCEEDED(hr) ? (bTruncated ? HRESULT_FROM_WIN32(ERROR_INVALID_DATA) : S_OK) : hr;
        }

        if (SUCCEEDED(hr))
        {
            *ppszString = pszString;
            pszString = NULL;
        }
    }

    FreeSplMem(pszString);
    pszString = NULL;

    return SUCCEEDED(hr) ? (bNullInRegistry ? S_OK : S_FALSE) : hr;
}

/*++

Routine Name:

    CheckAndNullTerminateRegistryBuffer

Routine Description:

    This routine runs the buffer over the size returned by the registry backwards
    to find a NULL, if there is a NULL in the buffer, we return success, otherwise,
    if we can add a NULL within the buffer we do so. Otherwise, we truncate the string.

Arguments:

    pszBuffer           -   The buffer we will bve checking.
    cchBuffer           -   The size of the buffer.
    cchRegBuffer        -   The size of the data returned from the registry.
    pbTruncated         -   If TRUE, the data was truncated, this will only happen
                            if cchBuffer == cchRegBuffer.
    pbNullInRegistry    -   If TRUE, there was a NULL termination in the given buffer.

Return Value:

    An HRESULT.

--*/
HRESULT
CheckAndNullTerminateRegistryBuffer(
    IN      PWSTR           pszBuffer,
    IN      UINT            cchBuffer,
    IN      UINT            cchRegBuffer,
        OUT BOOL            *pbTruncated,
        OUT BOOL            *pbNullInRegistry
    )
{
    HRESULT hr = pszBuffer && cchBuffer && cchRegBuffer <= cchBuffer && cchRegBuffer && pbTruncated && pbNullInRegistry
                 ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        UINT    iRegScan = 0;

        //
        // Start at the end of the buffer and work backwards to find the NULL,
        // this is faster since the NULL is likely to be at the end.
        //
        for(iRegScan = cchRegBuffer; iRegScan > 0; iRegScan--)
        {
            if (!pszBuffer[iRegScan - 1])
            {
                break;
            }
        }

        //
        // If we reached the beginning of the buffer and there wasn't a NULL,
        // then see if we can NULL terminate ourselves.
        //
        if (!iRegScan)
        {
            *pbNullInRegistry = FALSE;

            if (cchBuffer > cchRegBuffer)
            {
                pszBuffer[cchRegBuffer] = L'\0';
                *pbTruncated = FALSE;
            }
            else
            {
                pszBuffer[cchRegBuffer - 1] = L'\0';
                *pbTruncated = TRUE;
            }
        }
        else
        {
            *pbNullInRegistry = TRUE;
            *pbTruncated = FALSE;
        }
    }

    return hr;
}

//
// Test code follows
//
/*++

Routine Name:

    TestNullTerminateRegistryBuffer

Routine Description:

    This is test code for SafeRegQueryValueAsStringPointer. This code is not
    dead and functions as a validator for the above code.

Arguments:

    None.

Return Value:

    An HRESULT

--*/
HRESULT
TestNullTerminateRegistryBuffer(
    VOID
    )
{
    HRESULT hr = E_FAIL;

    //
    // This string must be quadword aligned or the registry does funky stuff
    // on the write.
    //
    const WCHAR  NonNullString[]        = { L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8' };
    const WCHAR  NullString[]           = L"1234567";
    const WCHAR  EmptyString[]          = L"";

    HKEY    hKey              = NULL;
    DWORD   dwDisposition     = 0;

    hr = HResultFromWin32(RegCreateKeyEx(HKEY_CURRENT_USER, L"StringTest", 0, NULL, 0, KEY_WRITE | KEY_READ, NULL, &hKey, &dwDisposition));

    if (SUCCEEDED(hr))
    {
        hr = SubTestVariations(hKey, L"NonNull", NonNullString, COUNTOF(NonNullString), L"12345678", S_FALSE);
    }

    if (SUCCEEDED(hr))
    {
        hr = SubTestVariations(hKey, L"Null", NullString, COUNTOF(NullString), NullString, S_OK);
    }

    if (SUCCEEDED(hr))
    {
        hr = SubTestVariations(hKey, L"Empty", EmptyString, COUNTOF(EmptyString), EmptyString, S_OK);
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    RegDeleteKey(HKEY_CURRENT_USER, L"StringTest");

    return hr;
}

/*++

Routine Name:

    SubTestVariations

Routine Description:

    This test a second set of standard variations depending on the string that
    is written into the registry.

Arguments:

    hKey                -   The key we are writing to.
    pszValue            -   The value we are testing.
    pWriteBuffer        -   The buffer to write (may not be NULL-terminated)
    cchBuffer           -   The size of the buffer we are writing.
    pszCompareString    -   The string we expect to compare it against.
    hrExpected          -   The HR we expect from the function, must be a success code.

Return Value:

    An HRESULT

--*/
HRESULT
SubTestVariations(
    IN      HKEY            hKey,
    IN      PCWSTR          pszValue,
    IN      PCWSTR          pWriteBuffer,
    IN      UINT            cchBuffer,
    IN      PCWSTR          pszCompareString,
    IN      HRESULT         hrExpected
    )
{
    HRESULT hr = hKey && pszValue && pWriteBuffer && pszCompareString && cchBuffer ? S_OK : E_INVALIDARG;
    PWSTR   pszString = NULL;

    //
    // Write the string into the registry.
    //
    if (SUCCEEDED(hr))
    {
        hr = HResultFromWin32(RegSetValueExW(hKey, pszValue, 0, REG_SZ, reinterpret_cast<const BYTE *>(pWriteBuffer), cchBuffer * sizeof(pWriteBuffer[0])));
    }

    //
    // Variation 1, our hint buffer is 0.
    //
    if (SUCCEEDED(hr))
    {
        hr = SafeRegQueryValueAsStringPointer(hKey, pszValue, &pszString, 0);

        hr = hr == hrExpected && pszString ? (!wcscmp(pszString, pszCompareString) ? S_OK : E_FAIL) : (SUCCEEDED(hr) ? E_FAIL : hr);
    }

    FreeSplMem(pszString);
    pszString = NULL;

    //
    // Variation 2, our hint buffer is smaller than the reg size.
    //
    if (SUCCEEDED(hr))
    {
        hr = SafeRegQueryValueAsStringPointer(hKey, pszValue, &pszString, cchBuffer / 2);

        hr = hr == hrExpected && pszString ? (!wcscmp(pszString, pszCompareString) ? S_OK : E_FAIL) : (SUCCEEDED(hr) ? E_FAIL : hr);
    }

    FreeSplMem(pszString);
    pszString = NULL;

    //
    // Variation 3, our hint buffer is exactly the same size as the reg size.
    //
    if (SUCCEEDED(hr))
    {
        hr = SafeRegQueryValueAsStringPointer(hKey, pszValue, &pszString, cchBuffer);

        hr = hr == hrExpected && pszString ? (!wcscmp(pszString, pszCompareString) ? S_OK : E_FAIL) : (SUCCEEDED(hr) ? E_FAIL : hr);
    }

    //
    // Variation 4, our hint buffer is larger than the reg buffer.
    //
    FreeSplMem(pszString);
    pszString = NULL;

    if (SUCCEEDED(hr))
    {
        hr = SafeRegQueryValueAsStringPointer(hKey, pszValue, &pszString, cchBuffer * 2);

        hr = hr == hrExpected && pszString ? (!wcscmp(pszString, pszCompareString) ? S_OK : E_FAIL) : (SUCCEEDED(hr) ? E_FAIL : hr);
    }

    FreeSplMem(pszString);
    pszString = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\splutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    splutil.cxx

Abstract:

    Common utils.

Author:

    Albert Ting (AlbertT)  29-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG
VOID
LinkListDump(
    PDLINK pdlinkHead,
    DWORD offset,
    LPCSTR pcszType,
    LPCSTR pcszName
    )
{
    PDLINK pdlinkT;

    DbgMsg( " [Dump LL %s::%s (offset %d)]\n",
             pcszType,
             pcszName,
             offset);

    for( pdlinkT = pdlinkHead;
         pdlinkT != pdlinkHead;
         pdlinkT = pdlinkT->FLink ){

        DbgMsg( "   %x\n", (PBYTE)pdlinkT + offset );
    }
}
#endif

MEntry*
MEntry::
pFindEntry(
    PDLINK pdlink,
    LPCTSTR pszName
    )
{
    PDLINK pdlinkT;
    MEntry* pEntry;

    for( pdlinkT = pdlink->FLink;
         pdlinkT != pdlink;
         pdlinkT = pdlinkT->FLink ){

        pEntry = MEntry::Entry_pConvert( pdlinkT );
        if( pEntry->_strName == pszName ){

            return pEntry;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\spldevmode.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation
All rights reserved

Module Name:

    spldevmode.cxx

Abstract:

    Implements methods for validating the devmode.

Author:

    Adina Trufinescu (adinatru).

Environment:

    User Mode - Win32

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"

template<class TChar>
BOOL
IsNullTerminated(
    IN  TChar*  pszString,
    IN  INT     Size
    )
{
    BOOL bReturn = FALSE;
    INT i        = 0;
    
    for (i = Size - 1 ; i >= 0 ; i--)
    {
        if (pszString[i] == static_cast<TChar>(0))
        {
            bReturn = TRUE;
            break;
        }
    }

    return bReturn;
}

/*++

Routine Name

    SplIsValidDevmodeNoSize

Routine Description:

    Template method for checking for devmode validity.
    
    We check whether the buffer is big enough to hold all the 
    fields specified in dmFields, plus, we need to make sure that 
    private devmode is DWORD aligned. 

    We check for DWORD aligned instead of sizeof(ULONG_PTR),
    because we expect existing applications to send data DWORD aligned.

    This check is required on ia64 platforms, to avoid data missalignments.
    We do it regardless of the platforms, since the devmode can roam between
    different platform machines.

Arguments:

    pDevMode     -  pointer to devmode structure

Return Value:

    HRESULT

--*/
template<class TDevmode, class TChar>
HRESULT
SplIsValidDevmodeNoSize(
    IN  TDevmode*      pDevMode
    )
{
    typedef struct 
    {
        DWORD   FieldBit;
        size_t  MinSize;

    } DevmodeFieldEntry;

    static const
    DevmodeFieldEntry DevmodeFieldTable [] = {
    {DM_PANNINGHEIGHT,               offsetof(TDevmode, dmPanningHeight)    + sizeof(DWORD)},
    {DM_PANNINGWIDTH,                offsetof(TDevmode, dmPanningWidth)     + sizeof(DWORD)},
    {DM_DITHERTYPE,                  offsetof(TDevmode, dmDitherType)       + sizeof(DWORD)},
    {DM_MEDIATYPE,                   offsetof(TDevmode, dmMediaType)        + sizeof(DWORD)},
    {DM_ICMINTENT,                   offsetof(TDevmode, dmICMIntent)        + sizeof(DWORD)},
    {DM_ICMMETHOD,                   offsetof(TDevmode, dmICMMethod)        + sizeof(DWORD)},
    {DM_DISPLAYFREQUENCY,            offsetof(TDevmode, dmDisplayFrequency) + sizeof(DWORD)},
    {DM_DISPLAYFLAGS,                offsetof(TDevmode, dmDisplayFlags)     + sizeof(DWORD)},
    {DM_NUP,                         offsetof(TDevmode, dmNup)              + sizeof(DWORD)},
    {DM_PELSHEIGHT,                  offsetof(TDevmode, dmPelsHeight)       + sizeof(DWORD)},
    {DM_PELSWIDTH,                   offsetof(TDevmode, dmPelsWidth)        + sizeof(DWORD)},
    {DM_BITSPERPEL,                  offsetof(TDevmode, dmBitsPerPel)       + sizeof(DWORD)},
    {DM_LOGPIXELS,                   offsetof(TDevmode, dmLogPixels)        + sizeof(WORD)},
    {DM_FORMNAME,                    offsetof(TDevmode, dmFormName)         + sizeof(TChar) * CCHFORMNAME},
    {DM_COLLATE,                     offsetof(TDevmode, dmCollate)          + sizeof(short)},
    {DM_TTOPTION,                    offsetof(TDevmode, dmTTOption)         + sizeof(short)},
    {DM_YRESOLUTION,                 offsetof(TDevmode, dmYResolution)      + sizeof(short)},
    {DM_DUPLEX,                      offsetof(TDevmode, dmDuplex)           + sizeof(short)},
    {DM_COLOR,                       offsetof(TDevmode, dmColor)            + sizeof(short)},
    {DM_DISPLAYFIXEDOUTPUT,          offsetof(TDevmode, dmDisplayFixedOutput) + sizeof(DWORD)},
    {DM_DISPLAYORIENTATION,          offsetof(TDevmode, dmDisplayOrientation) + sizeof(DWORD)},    
    {DM_POSITION,                    offsetof(TDevmode, dmPosition)         + sizeof(POINTL)},
    {DM_PRINTQUALITY,                offsetof(TDevmode, dmPrintQuality)     + sizeof(short)},
    {DM_DEFAULTSOURCE,               offsetof(TDevmode, dmDefaultSource)    + sizeof(short)},
    {DM_COPIES,                      offsetof(TDevmode, dmCopies)           + sizeof(short)},
    {DM_SCALE,                       offsetof(TDevmode, dmScale)            + sizeof(short)},
    {DM_PAPERWIDTH,                  offsetof(TDevmode, dmPaperWidth)       + sizeof(short)},
    {DM_PAPERLENGTH,                 offsetof(TDevmode, dmPaperLength)      + sizeof(short)},
    {DM_PAPERSIZE,                   offsetof(TDevmode, dmPaperSize)        + sizeof(short)},
    {DM_ORIENTATION,                 offsetof(TDevmode, dmOrientation)      + sizeof(short)},
    {0,                              0}};

    HRESULT hr = HResultFromWin32(ERROR_INVALID_DATA);

    if ((pDevMode)                                                          &&
        (pDevMode != reinterpret_cast<TDevmode*>(-1))                       &&
        (pDevMode->dmSize >= offsetof(TDevmode, dmFields) + sizeof(DWORD)))
    {
        hr = S_OK;

        //
        // The private devmode must be 4 bytes aligned, on both x86 and ia64 platforms.        
        //
        if (pDevMode->dmDriverExtra)
        {
            hr = (DWORD_ALIGN_DOWN(pDevMode->dmSize) != pDevMode->dmSize) ?   
                     HResultFromWin32(ERROR_INVALID_DATA) :
                     S_OK;
        }        

        //
        // Check whether the dmSize is big enough to fit all the fields specified in dmFields.
        //
        for(ULONG Index = 0; DevmodeFieldTable[Index].FieldBit && SUCCEEDED(hr); Index++)
        {
            if (pDevMode->dmFields & DevmodeFieldTable[Index].FieldBit)
            {
                hr = pDevMode->dmSize >= DevmodeFieldTable[Index].MinSize ?
                        S_OK :
                        HResultFromWin32(ERROR_INVALID_DATA);
            }
        }

        if (SUCCEEDED(hr))
        {
            __try
            {
                if (!IsNullTerminated<TChar>(pDevMode->dmDeviceName, CCHDEVICENAME))
                {
                    pDevMode->dmDeviceName[CCHDEVICENAME-1] = static_cast<TChar>(0);
                }
                if (pDevMode->dmFields & DM_FORMNAME && 
                    !IsNullTerminated<TChar>(pDevMode->dmFormName, CCHFORMNAME))
                {
                    pDevMode->dmFormName[CCHFORMNAME-1] = static_cast<TChar>(0);
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = HResultFromWin32(GetExceptionCode());
            }
        }
    }    
    
    return hr;
}

/*++

Routine Name

    SplIsValidDevmode

Routine Description:

    Template method for checking for devmode validity when the size
    of the buffer is known.

Arguments:

    pDevMode     -  pointer to devmode structure
    DevmodeSize  -  size of buffer

Return Value:

    HRESULT

--*/
template<class TDevmode, class TChar>
HRESULT
SplIsValidDevmode(
    TDevmode*      pDevMode, 
    size_t         DevmodeSize
    )
{
    HRESULT hr = HResultFromWin32(ERROR_INVALID_DATA);

    if ((pDevMode)                                                    &&
        (DevmodeSize >= offsetof(TDevmode, dmFields) + sizeof(DWORD)) &&
        (DevmodeSize >= (size_t)(pDevMode->dmSize) + (size_t)(pDevMode->dmDriverExtra)))
    {
        hr = SplIsValidDevmodeNoSize<TDevmode, TChar>(pDevMode);
    }

    return hr;
}

/*++

Routine Name

    SplIsValidDevmodeW

Routine Description:

    Method for checking for UNICODE devmode validity when the size
    of the buffer is known.

Arguments:

    pDevMode     -  pointer to devmode structure
    DevmodeSize  -  size of buffer

Return Value:

    HRESULT

--*/           
HRESULT
SplIsValidDevmodeW(
    IN  PDEVMODEW   pDevmode,
    IN  size_t      DevmodeSize
    )
{
    return SplIsValidDevmode<DEVMODEW, WCHAR>(pDevmode, DevmodeSize);
}

/*++

Routine Name

    SplIsValidDevmodeW

Routine Description:

    Method for checking for ANSI devmode validity when the size
    of the buffer is known.

Arguments:

    pDevMode     -  pointer to devmode structure
    DevmodeSize  -  size of buffer

Return Value:

    HRESULT

--*/           
HRESULT
SplIsValidDevmodeA(
    IN  PDEVMODEA   pDevmode,
    IN  size_t      DevmodeSize
    )
{
    return SplIsValidDevmode<DEVMODEA, BYTE>(pDevmode, DevmodeSize);
}

/*++

Routine Name

    SplIsValidDevmodeNoSizeW

Routine Description:

    Method for checking for UNICODE devmode validity when the size
    of the buffer is unknown.

Arguments:

    pDevMode     -  pointer to devmode structure
    DevmodeSize  -  size of buffer

Return Value:

    HRESULT

--*/           
HRESULT
SplIsValidDevmodeNoSizeW(
    IN  PDEVMODEW   pDevmode
    )
{
    return SplIsValidDevmodeNoSize<DEVMODEW, WCHAR>(pDevmode);
}

/*++

Routine Name

    SplIsValidDevmodeNoSizeA

Routine Description:

    Method for checking for ANSI devmode validity when the size
    of the buffer is unknown.

Arguments:

    pDevMode     -  pointer to devmode structure
    DevmodeSize  -  size of buffer

Return Value:

    HRESULT

--*/
HRESULT
SplIsValidDevmodeNoSizeA(
    IN  PDEVMODEA   pDevmode
    )
{
    return SplIsValidDevmodeNoSize<DEVMODEA, BYTE>(pDevmode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\slist.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    slist.inl

Abstract:

    Single linked list template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/

template <class T>
CSingleList<T>::CSingleList<T>(void)
               :m_Dummy ()
{
}

template <class T>
CSingleList<T>::~CSingleList<T>(void)
{
    Lock ();

    CSingleItem<T> *pItem = m_Dummy.GetNext();
    CSingleItem<T> *pNext;

    while (pItem) {
        pNext = pItem->GetNext();
        delete pItem;
        pItem = pNext;
    }
    Unlock ();
}

template <class T>
BOOL CSingleList<T>::Insert (T item)
{
    BOOL bRet = FALSE;

    Lock();

    CSingleItem<T> *pNewItem = new CSingleItem<T> (item, m_Dummy.GetNext());

    if (pNewItem) {
        m_Dummy.SetNext (pNewItem);
        bRet = TRUE;
    }

    Unlock();
    return bRet;
}

template <class T>
BOOL CSingleList<T>::Delete (T item)
{
    CSingleItem<T> *pHead = &m_Dummy;
    CSingleItem<T> *pItem;
    BOOL    bRet = FALSE;

    Lock();

    while (pItem = pHead->GetNext()) {
        if (pItem->IsSame (item)) {
            // Delete it
            pHead->SetNext (pItem->GetNext ());
            delete (pItem);
            bRet = TRUE;
            break;
        }
        pHead = pHead->GetNext();
    }
    Unlock();

    return FALSE;
}

template <class T>
T CSingleList<T>::Find (T item)
{

    Lock();

    CSingleItem<T> *pItem = m_Dummy.GetNext();

    while (pItem) {
        if (pItem->IsSame (item)) {
            Unlock ();
            return pItem->GetData();
        }
        pItem = pItem->GetNext();
    }

    Unlock ();

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\splpolicy.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation
All rights reserved

Module Name:

    splpolicy.cxx

Abstract:

    Implements methods for reading Spooler policies.

Author:

    Adina Trufinescu (adinatru).

Environment:

    User Mode - Win32

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"
#include "splpolicy.hxx"

CONST TCHAR *szPrintPolicy                      = TEXT("Software\\Policies\\Microsoft\\Windows NT\\Printers");
CONST TCHAR *szRegisterSpoolerRemoteRpcEndPoint = TEXT("RegisterSpoolerRemoteRpcEndPoint");

/*++

Routine Name

    GetSpoolerPolicy

Routine Description:

    Reads a Spooler policy.

Arguments:

    pszRegValue     -  pointer to a null-terminated string
    pData           -  pointer to buffer that receives the value's data
    pcbSize         -  pointer to variable that receives the value's size in bytes    
    pType           -  pointer to variable that receives the value's type    

Return Value:

    HRESULT

--*/
HRESULT
GetSpoolerPolicy(
    IN      PCTSTR  pszRegValue,
    IN  OUT PBYTE   pData,
    IN  OUT PDWORD  pcbSize,
        OUT PDWORD  pType
    )
{
    HRESULT     hr;
    HKEY        hPrintPolicyKey = NULL;
    ULONG       Type;
    ULONG       cbSize;    
    
    hr = (pszRegValue && pData && pcbSize) ? S_OK : E_POINTER;

    if (SUCCEEDED(hr))
    { 
        hr = HResultFromWin32(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                           szPrintPolicy,
                                           0,
                                           KEY_READ,
                                           &hPrintPolicyKey));
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(RegQueryValueEx(hPrintPolicyKey,
                                                  pszRegValue,
                                                  NULL,
                                                  &Type,
                                                  pData,
                                                  pcbSize));
            if (SUCCEEDED(hr) && pType)
            {
                *pType = Type;               
            }

            RegCloseKey(hPrintPolicyKey);
        }
    }    

    return hr;
}

/*++

Routine Name

    GetSpoolerNumericPolicy

Routine Description:

    Reads a numeric Spooler policy. Allows setting the default value
    if policy is unconfigured.

Arguments:

    pszRegValue     -  pointer to a null-terminated string
    DefaultValue    -  Default value if reading fails

Return Value:

    ULONG

--*/
ULONG
GetSpoolerNumericPolicy(
    IN  PCTSTR  pszRegValue,
    IN  ULONG   DefaultValue
    )
{
    ULONG   Value  = DefaultValue;
    ULONG   cbSize = sizeof(DWORD);
    HRESULT hr     = (pszRegValue) ? S_OK : E_POINTER;
    ULONG   Type;

    if (SUCCEEDED(hr))
    {
        hr = GetSpoolerPolicy(pszRegValue, (PBYTE)&Value, &cbSize, &Type);

        if (FAILED(hr) || Type != REG_DWORD)
        {
           Value =  DefaultValue;
        }
    }
        
    return Value;
}

/*++

Routine Name

    GetSpoolerNumericPolicyValidate

Routine Description:

    Reads a numeric Spooler policy. Allows setting the default value
    if policy is unconfigured and does validation against the value.
    If the value is of another type, or the value is bigger than MaxValue,
    it returns the DefaultValue.

Arguments:

    pszRegValue     -  pointer to a null-terminated string
    DefaultValue    -  Default value if reading fails
    MaxValue        -  Maximum value expected.

Return Value:

    ULONG

--*/
ULONG
GetSpoolerNumericPolicyValidate(
    IN  PCTSTR  pszRegValue,
    IN  ULONG   DefaultValue,
    IN  ULONG   MaxValue    
    )
{
    ULONG   Value  = DefaultValue;
    ULONG   cbSize = sizeof(DWORD);
    HRESULT hr     = (pszRegValue) ? S_OK : E_POINTER;
    ULONG   Type;

    if (SUCCEEDED(hr))
    {
        hr = GetSpoolerPolicy(pszRegValue, (PBYTE)&Value, &cbSize, &Type);

        if (FAILED(hr) || Type != REG_DWORD || Value > MaxValue)
        {
           Value =  DefaultValue;
        }
    }
        
    return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\state.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    State.cxx

Abstract:

    State abstraction and critical section

Author:

    Albert Ting (AlbertT)  28-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG
MCritSec* MRefCom::gpcsCom;
#endif

/********************************************************************

    Ref counting

********************************************************************/

VOID
MRefQuick::
vIncRef(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld + 1 );
#endif

    ++_cRef;
}

LONG
MRefQuick::
cDecRef(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld - 1 );
#endif

    --_cRef;

    if( !_cRef ){

        vRefZeroed();
        return 0;
    }
    return _cRef;
}

VOID
MRefQuick::
vDecRefDelete(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld );
#endif

    --_cRef;

    if( !_cRef ){
        vRefZeroed();
    }
}

/********************************************************************

    MRefCom: Reference counting using interlocked references.
    This avoids creating a common critical section.

    vDeleteDecRef is the same as vDecRef, but it logs differently.

********************************************************************/

VOID
MRefCom::
vIncRef(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld+1 );
#endif

    InterlockedIncrement( &_cRef );
}

LONG
MRefCom::
cDecRef(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld - 1 );
#endif

    LONG cRefReturn = InterlockedDecrement( &_cRef );

    if( !cRefReturn ){
        vRefZeroed();
    }
    return cRefReturn;
}


VOID
MRefCom::
vDecRefDelete(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld );
#endif

    if( !InterlockedDecrement( &_cRef )){
        vRefZeroed();
    }
}

VOID
MRefCom::
vRefZeroed(
    VOID
    )
{
}

/********************************************************************

    Critical section implementation

    Logging:


    CS initialized: 00000000 00000000 00000000

    CS acquired:    1eeeeeee bbbbbbbb tttttttt
    e   New entry count.
    b   TickCount thread was blocked before acquiring CS.
    t   Total tickcount all threads have blocked before acquiring CS

    CS released:    0eeeeeee iiiiiiii tttttttt
    e   New entry count.
    i   Time spent inside the CS, from _first_ acquisition.
    t   Total tickcount all threads inside CS.

********************************************************************/


#if DBG

MCritSec::
MCritSec(
    VOID
    ) : _dwThreadOwner( 0 ), _dwEntryCount( 0 ),
        _dwTickCountBlockedTotal( 0 ), _dwTickCountInsideTotal( 0 ),
        _dwEntryCountTotal( 0 )
{
    InitializeCriticalSectionAndSpinCount( &_CritSec, 0x80000000 );
    _BackTrace.hCapture( 0, 0, 0 );
}

MCritSec::
~MCritSec(
    VOID
    )
{
    DeleteCriticalSection( &_CritSec );
}

VOID
MCritSec::
vEnter(
    VOID
    )
{
    DWORD dwTickCountBefore = GetTickCount();

    EnterCriticalSection( &_CritSec );

    ++_dwEntryCountTotal;

    DWORD dwTickCountBlocked = 0;

    //
    // Re-entrant case: only start the TickCountEntered counter
    // if this is the first time we've entered the cs.
    //
    if( _dwEntryCount == 0 ){

        //
        // Check how long it took us to enter the critical section.
        //
        _dwTickCountEntered = GetTickCount();
        dwTickCountBlocked = _dwTickCountEntered - dwTickCountBefore;

        //
        // Update the amount of time this thread blocked on this cs.
        //
        _dwTickCountBlockedTotal += dwTickCountBlocked;
    }

    //
    // We have entered the critical section; update the count
    // and the thread owner.
    //
    ++_dwEntryCount;
    _dwThreadOwner = GetCurrentThreadId();

    _BackTrace.hCapture( 0x10000000 | _dwEntryCount,
                          dwTickCountBlocked,
                          _dwTickCountBlockedTotal );

}

VOID
MCritSec::
vLeave(
    VOID
    )
{
    SPLASSERT( bInside( ));

    DWORD dwTickCountInside = GetTickCount() - _dwTickCountEntered;

    --_dwEntryCount;

    //
    // Verify that we don't leave a CritSecHardLock.
    //
    TIter Iter;
    TCritSecHardLock *pCritSecHardLock;

    for( CritSecHardLock_vIterInit( Iter ), Iter.vNext();
         Iter.bValid();
         Iter.vNext( )){

        pCritSecHardLock = CritSecHardLock_pConvert( Iter );

        //
        // If you hit this assert, then you have created a hard
        // lock, but someone is trying to leave it.  See header file
        // for more info (state.hxx).
        //
        if( _dwEntryCount < pCritSecHardLock->_dwEntryCountMarker ){
            DBGMSG( DBG_ERROR, ( "CritSec.vLeave: Leaving a hard lock.\n" ));
        }
    }

    //
    // If this leave frees the critical section, then capture
    // the total time the section was held (from the very first enter).
    //
    if( !_dwEntryCount ){
        _dwTickCountInsideTotal += dwTickCountInside;

        //
        // Since we are leaving the critical section for the last
        // time, the CS is now unowned.  We set the thread owner to 0.
        //
        _dwThreadOwner = 0;
    }

    //
    // Note: dwTickCountInsideTotal is based on _first_ entrance
    // of critical section, not the most recent.
    //
    _BackTrace.hCapture( ~0x10000000 & _dwEntryCount,
                          dwTickCountInside,
                          _dwTickCountInsideTotal );

    LeaveCriticalSection( &_CritSec );
}

BOOL
MCritSec::
bInside(
    VOID
    ) const
{
    if( !_dwEntryCount || GetCurrentThreadId() != _dwThreadOwner ){

        DBGMSG( DBG_NONE, ( "CritSec: Not inside 0x%x!\n", this ));
        return FALSE;
    }
    return TRUE;
}


BOOL
MCritSec::
bOutside(
    VOID
    ) const
{
    //
    // We are outside if dwThreadOwner is not our thread id.
    //
    DWORD dwThreadOwner = (DWORD)InterlockedCompareExchange(
                                     (PLONG)&_dwThreadOwner,
                                     0,
                                     0 );

    if( dwThreadOwner == GetCurrentThreadId( )){

        DBGMSG( DBG_NONE, ( "CritSec: Not outside 0x%x!\n",this ));
        return FALSE;
    }
    return TRUE;
}

#else // !DBG

MCritSec::
MCritSec() {
    InitializeCriticalSectionAndSpinCount(&_CritSec, 0);
    }

#endif

/********************************************************************

    TCritSecHardLock

********************************************************************/

#if DBG

TCritSecHardLock::
TCritSecHardLock(
    MCritSec& CritSec
    ) : _CritSec( CritSec )
{
    _CritSec.vEnter();

    //
    // Add ourselves to the linked list and remember what the entry
    // count is.  Everytime we leave the critical section, we'll look
    // at all the items in the list and see if the current entry count
    // is < all hard locks.
    //
    _CritSec.CritSecHardLock_vAdd( this );
    _dwEntryCountMarker = _CritSec._dwEntryCount;
}


TCritSecHardLock::
~TCritSecHardLock(
    VOID
    )
{
    CritSecHardLock_vDelinkSelf();
    _CritSec.vLeave();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\trace.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    trace.cxx

Abstract:

    Holds logging routines.

Author:

    Albert Ting (AlbertT)  24-May-1996

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG

#include "trace.hxx"

/*
**  Turn off memory tracing. Turning this on keeps all the back traces in
** memory.
#if i386
#define BACKTRACE_ENABLED
#endif
*/

CRITICAL_SECTION gcsBackTrace;

#ifdef TRACE_ENABLED

TBackTraceDB* gpBackTraceDB;

/********************************************************************

    BackTrace DB

********************************************************************/

TBackTraceDB::
TBackTraceDB(
    VOID
    ) : _pTraceHead( NULL )

/*++

Routine Description:

    Initialize the trace database.

    Generally you will have just one database that holds all the
    traces.

Arguments:

Return Value:

--*/

{
    _pMemBlock = new TMemBlock( kBlockSize, TMemBlock::kFlagGlobalNew );
}

TBackTraceDB::
~TBackTraceDB(
    VOID
    )

/*++

Routine Description:

    Destroy the back trace database.

Arguments:

Return Value:

--*/

{
    delete _pMemBlock;
}

BOOL
TBackTraceDB::
bValid(
    VOID
    )
{
    return _pMemBlock && _pMemBlock->bValid();
}



HANDLE
TBackTraceDB::
hStore(
    IN ULONG ulHash,
    IN PVOID pvBackTrace
    )

/*++

Routine Description:

    Store a backtrace into the database.

Arguments:

    ulHash - Hash for this backtrace.

    pvBackTrace - Actual backtrace; must be NULL terminated.

Return Value:

    HANDLE - backtrace handle.

--*/

{
    TTrace *ptRet;
    TTrace **ppTrace;

    //
    // First see if we can find a backtrace.  If we can't, then
    // pTrace will hold the slot where it should be.
    //
    ptRet = ptFind( ulHash, pvBackTrace, &ppTrace );

    if( !ptRet ){

        //
        // Didn't find one; add it.
        //
        ptRet = TTrace::pNew( this, ulHash, pvBackTrace, ppTrace );
    }

    return ptRet;
}

PLONG
TBackTraceDB::
plGetCount(
    HANDLE hData
    )

/*++

Routine Description:

    Get data from a HANDLE retrieved from hStore.  There is one ULONG
    per stack backtrace.

Arguments:

    hData - Returned from hStore.

Return Value:

    PLONG.

--*/

{
    TTrace *ptTrace = static_cast<TTrace*>( hData );
    return &ptTrace->lCount();
}

TBackTraceDB::TTrace*
TBackTraceDB::
ptFind(
    IN     ULONG ulHash,
    IN     PVOID pvBackTrace,
       OUT TTrace ***pppTrace OPTIONAL
    )

/*++

Routine Description:

    Find a backtrace in the database.  If one does not exist,
    then return NULL and a pointer to where it would exist
    in the database.

Arguments:

    ulHash - Hash of the backtrace.

    pvBackTrace - Backtrace to find.

    pppTrace - If not found, this holds the address of where it should
        be stored in the database.  Adding the trace here is sufficient
        to add it.

Return Value:

    TTrace* the actual trace, NULL if not found.

--*/

{
    //
    // Traverse the binary tree until we find the end or the
    // right one.
    //
    TTrace **ppTrace = &_pTraceHead;

    while( *ppTrace ){

        //
        // Check if this one matches ours.
        //
        COMPARE Compare = (*ppTrace)->eCompareHash( ulHash );

        if( Compare == kEqual ){

            //
            // Now do slow compare in case the hash is a collision.
            //
            Compare = (*ppTrace)->eCompareBackTrace( pvBackTrace );

            if( Compare == kEqual ){

                //
                // Break out of while loop and quit.
                //
                break;
            }
        }

        ppTrace = ( Compare == kLess ) ?
            &(*ppTrace)->_pLeft :
            &(*ppTrace)->_pRight;
    }

    if( pppTrace ){
        *pppTrace = ppTrace;
    }
    return *ppTrace;
}


/********************************************************************

    TBackTraceDB::TTrace

********************************************************************/

COMPARE
TBackTraceDB::
TTrace::
eCompareHash(
    ULONG ulHash
    ) const

/*++

Routine Description:

    Quickly compare two trace hashes.

Arguments:

    ulHash - Input hash.

Return Value:

--*/

{
    if( _ulHash < ulHash ){
        return kLess;
    }

    if( _ulHash > ulHash ){
        return kGreater;
    }

    return kEqual;
}

COMPARE
TBackTraceDB::
TTrace::
eCompareBackTrace(
    PVOID pvBackTrace
    ) const

/*++

Routine Description:

    Compare backtrace to one stored in this.

Arguments:

    pvBackTrace - Must be NULL terminated.

Return Value:

    COMAARE: kLess, kEqual, kGreater.

--*/

{
    PVOID *pSrc;
    PVOID *pDest;

    for( pSrc = (PVOID*)this, pDest = (PVOID*)&pvBackTrace;
        *pSrc && *pDest;
        pSrc++, pDest++ ) {

        if ( *pSrc != *pDest ){
            return (ULONG_PTR)*pSrc < (ULONG_PTR)*pDest ?
                kLess :
                kGreater;
        }
    }
    return kEqual;
}

TBackTraceDB::TTrace*
TBackTraceDB::
TTrace::
pNew(
    IN     TBackTraceDB *pBackTraceDB,
    IN     ULONG ulHash,
    IN     PVOID pvBackTrace,
       OUT TTrace ** ppTrace
    )

/*++

Routine Description:

    Constructs a new TTrace and puts it in pBackTraceDB.

    Assumes the trace does _not_ exist already, and ppTrace points
    to the place where it should be stored to ensure the database
    is kept consistent.

Arguments:

    pBackTraceDB - Storage for the new trace.

    ulHash - Hash for the trace.

    pvBackTrace - The actual backtrace.

    ppTrace - Where the trace should be stored in the database.

Return Value:

    TTrace* - New trace, NULL if failed.

--*/

{
    COUNT cCalls;
    PVOID *ppvCalls;

    //
    // Calculate size of backtrace.  Start with cCalls = 1 so that
    // we include 1 extra for the NULL terminator.
    //
    for( ppvCalls = (PVOID*)pvBackTrace, cCalls = 1;
        *ppvCalls;
        ++ppvCalls, ++cCalls )

        ;

    ++cCalls;

    COUNTB cbSize = OFFSETOF( TTrace, apvBackTrace ) +
                    cCalls * sizeof( PVOID );

    TTrace* pTrace = (TTrace*)pBackTraceDB->_pMemBlock->pvAlloc( cbSize );

    if( pTrace ){

        pTrace->_pLeft = NULL;
        pTrace->_pRight = NULL;
        pTrace->_ulHash = ulHash;
        pTrace->_lCount = -1;

        CopyMemory( pTrace->apvBackTrace,
                    (PVOID*)pvBackTrace,
                    cCalls * sizeof( PVOID ));

        //
        // Add it in the right spot into the database.
        //
        *ppTrace = pTrace;
    }

    return pTrace;
}


/********************************************************************

    Back tracing: abstract base class.

********************************************************************/

BOOL VBackTrace::gbInitialized = FALSE;

#endif // TRACE_ENABLED

VBackTrace::
VBackTrace(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : _fOptions1( fOptions1 ), _fOptions2( fOptions2 )
{
}

VBackTrace::
~VBackTrace(
    VOID
    )
{
}

BOOL
VBackTrace::
bInit(
    VOID
    )
{

#ifdef TRACE_ENABLED

    gbInitialized = InitializeCriticalSectionAndSpinCount(&gcsBackTrace, 0x80000000);
    gpBackTraceDB = new TBackTraceDB();

    return gbInitialized && (gpBackTraceDB != NULL);

#else

    return TRUE;

#endif

}

VOID
VBackTrace::
vDone(
    VOID
    )
{

#ifdef TRACE_ENABLED

    if( gbInitialized )
    {
        DeleteCriticalSection(&gcsBackTrace);
    }

#endif

}

PLONG
VBackTrace::
plGetCount(
    HANDLE hData
    )
{

#ifdef TRACE_ENABLED

    return gpBackTraceDB->plGetCount( hData );

#else

    return NULL;

#endif

}

#ifndef TRACE_ENABLED


HANDLE
VBackTrace::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )

/*++

Routine Description:

    In the case that tracing is disabled, this function is coded
    to return NULL.

Arguments:

Return Value:

    NULL

--*/

{
    return NULL;
}

#endif // ndef TRACE_ENABLED


#ifdef TRACE_ENABLED

/********************************************************************

    Back tracing to memory.

********************************************************************/

TBackTraceMem::
TBackTraceMem(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : VBackTrace( fOptions1, fOptions2 ), _uNextFree( 0 )
{
    _pLines = new TLine[kMaxCall];
    if( _pLines ){
        ZeroMemory( _pLines, sizeof( TLine[kMaxCall] ));
    }
}

TBackTraceMem::
~TBackTraceMem(
    VOID
    )
{
    UINT i;
    TLine* pLine;

    if( _pLines ){
        for( i=0, pLine = _pLines; i< kMaxCall; i++, pLine++ ){

            if( _fOptions1 & kString ){
                DbgFreeMem( (PVOID)pLine->_Info1 );
            }

            if( _fOptions2 & kString ){
                DbgFreeMem( (PVOID)pLine->_Info2 );
            }
        }
        delete [] _pLines;
    }
}

VOID
TBackTraceMem::
vCaptureLine(
    IN OUT TLine* pLine,
    IN     ULONG_PTR Info1,
    IN     ULONG_PTR Info2,
    IN     ULONG_PTR Info3,
       OUT PVOID apvBackTrace[kMaxDepth+1], OPTIONAL
       OUT PULONG pulHash OPTIONAL
    )

/*++

Routine Description:

    Captures information into a TLine structure; freeing previous
    contents if necessary.

Arguments:

    pLine - Fully initialized pLine structure.  On output, everything
        _except_ _hTrace is filled in.

    ** Both apvBackTrace && pulHash must both be valid if either is valid **

    apvBackTrace - Buffer to receive backtrace.

    pulHash - Buffer to receive ulHash.

Return Value:

--*/

{
    //
    // Free memory if necessary.
    //
    if( _fOptions1 & kString ) {
        DbgFreeMem( (PVOID)pLine->_Info1 );
    }

    if( _fOptions2 & kString ) {
        DbgFreeMem( (PVOID)pLine->_Info2 );
    }

    pLine->_TickCount = GetTickCount();
    pLine->_Info1 = Info1;
    pLine->_Info2 = Info2;
    pLine->_Info3 = Info3;

    pLine->_ThreadId = GetCurrentThreadId();
    pLine->_hTrace = NULL;

#ifdef BACKTRACE_ENABLED

    if( apvBackTrace && pulHash ){

        ULONG ulHash;

        //
        // Capture a backtrace at this spot for debugging.
        //
        UINT uDepth = RtlCaptureStackBackTrace( 2,
                                                kMaxDepth,
                                                apvBackTrace,
                                                pulHash );

        //
        // NULL terminate.
        //
        apvBackTrace[uDepth] = NULL;
    }
#else
    apvBackTrace[0] = NULL;
    *pulHash = 0;
#endif

}

HANDLE
TBackTraceMem::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )
{
    UINT uDepth;
    TLine* pLine;
    ULONG ulHash;
    PVOID apvBackTrace[kMaxDepth+1];

    if( !_pLines ){
        return NULL;
    }

    EnterCriticalSection( &gcsBackTrace );

    pLine = &_pLines[_uNextFree];

    vCaptureLine( pLine, Info1, Info2, Info3, apvBackTrace, &ulHash );
    pLine->_hTrace = gpBackTraceDB->hStore( ulHash, apvBackTrace );

    _uNextFree++;

    if( _uNextFree == kMaxCall )
        _uNextFree = 0;

    LeaveCriticalSection( &gcsBackTrace );

    if( pHash )
    {
        *pHash = ulHash;
    }

    return (PVOID)pLine->_hTrace;
}

/********************************************************************

    Backtracing to File.

********************************************************************/

COUNT TBackTraceFile::gcInstances;

TBackTraceFile::
TBackTraceFile(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : VBackTrace( fOptions1, fOptions2 )
{
    TCHAR szFile[kMaxPath];

    EnterCriticalSection( &gcsBackTrace );

    StringCchPrintf( szFile,
                     COUNTOF(szFile),
                     TEXT( "spl_%d.%d.log" ),
                     GetCurrentProcessId(),
                     gcInstances );

    ++gcInstances;

    LeaveCriticalSection( &gcsBackTrace );

    _hFile = CreateFile( szFile,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_COMPRESSED,
                         NULL );

    if( _hFile == INVALID_HANDLE_VALUE ){

        OutputDebugStringA( "SPLLIB: Unable to open file " );
        OutputDebugString( szFile );
        OutputDebugStringA( "\n" );
        return;
    }
}

TBackTraceFile::
~TBackTraceFile(
    VOID
    )
{
    if( _hFile != INVALID_HANDLE_VALUE ){
        CloseHandle( _hFile );
    }
}

HANDLE
TBackTraceFile::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )
{
    TLine Line;
    PVOID apvBackTrace[kMaxDepth+1];
    DWORD cbWritten;

    CHAR szLine[kMaxLineStr];
    szLine[0] = 0;

#ifdef BACKTRACE_ENABLED

    ULONG ulHash;

    //
    // Capture a backtrace at this spot for debugging.
    //
    UINT uDepth = RtlCaptureStackBackTrace( 2,
                                            kMaxDepth,
                                            apvBackTrace,
                                            &ulHash );
#endif

    EnterCriticalSection( &gcsBackTrace );

    //
    // Print out strings as appropriate.
    //

    if( _fOptions1 & kString )
    {
        WriteFile( _hFile,
                   (LPCVOID)Info1,
                   lstrlenA( (LPCSTR)Info1 ),
                   &cbWritten,
                   NULL );
    }

    if( _fOptions2 & kString )
    {
        WriteFile( _hFile,
                   (LPCVOID)Info2,
                   lstrlenA( (LPCSTR)Info2 ),
                   &cbWritten,
                   NULL );
    }

    //
    // Print out the hex info.
    //

    StringCchPrintfA(szLine,
                     COUNTOF(szLine),
                     "\n\t%08x: %08x %08x %08x threadid=%x tc=%x < %x >: ",
                     this,
                     Info1,
                     Info2,
                     Info3,
                     GetCurrentThreadId(),
                     GetTickCount(),
                     Info1 + Info2 );

    if( _hFile )
    {
        WriteFile( _hFile, szLine, lstrlenA( szLine ), &cbWritten, NULL );
    }

#ifdef BACKTRACE_ENABLED

    //
    // Print out the backtrace.
    //

    UINT i;
    
    szLine[0] = '\t';
    CHAR *pszLineEnd = &szLine[1];
    size_t cRemaining = COUNTOF(szLine)-1;
    
    for( i=0; i < uDepth; ++i )
    {
        StringCchPrintfAEx( pszLineEnd, cRemaining, pszLineEnd, cRemaining, "%08x ", apvBackTrace[i] );
    }

    if( _hFile && i )
    {
        //
        // Countof(szLine)-cRemaining is the number of characters that were copied to szLine.
        // We add 2 for the first character and the null character at the end.
        //
        WriteFile( _hFile, szLine, COUNTOF(szLine)-cRemaining+2, &cbWritten, NULL );
    }

#endif

    //
    // Add extra blank line.
    //
    szLine[0] = '\n';
    WriteFile( _hFile, szLine, 1, &cbWritten, NULL );

    LeaveCriticalSection( &gcsBackTrace );

    //
    // Free memory if necessary.
    //
    if( _fOptions1 & kString )
    {
        DbgFreeMem( (PVOID)Info1 );
    }

    if( _fOptions2 & kString )
    {
        DbgFreeMem( (PVOID)Info2 );
    }

#ifdef BACKTRACE_ENABLED

    if( pHash )
    {
        *pHash = ulHash;
    }

#endif

    return NULL;
}

#endif // TRACE_ENABLED

#endif // #ifdef DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\string.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    String.cxx

Abstract:

    Short strings

Author:

    Albert Ting (AlbertT)  9-June-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

//
// Class specific NULL state.
//
TCHAR TString::gszNullState[2] = {0,0};

//
// Default construction.
//
TString::
TString(
    VOID
    ) : _pszString( &TString::gszNullState[kValid] )
{
}

//
// Construction using an existing LPCTSTR string.
//
TString::
TString(
    IN LPCTSTR psz
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( psz );
}

//
// Destruction, ensure we don't free our NULL state.
//
TString::
~TString(
    VOID
    )
{
    vFree( _pszString );
}

//
// Copy constructor.
//
TString::
TString(
    const TString &String
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( String._pszString );
}

//
// Indicates if a string has any usable data.
//
BOOL
TString::
bEmpty(
    VOID
    ) const
{
    return _pszString[0] == 0;
}

//
// Indicates if a string object is valid.
//
BOOL
TString::
bValid(
    VOID
    ) const
{
    return _pszString != &TString::gszNullState[kInValid];
}

//
// Return the length of the string.
//
UINT
TString::
uLen(
    VOID
    ) const
{
    return lstrlen( _pszString );
}

BOOL
TString::
bCat(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe concatenation of the specified string to the string
    object. If the allocation fails, return FALSE and the
    original string is not modified.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    BOOL bStatus = FALSE;

    //
    // If a valid string was passed.
    //
    if( psz ){

        LPTSTR pszTmp = _pszString;

        //
        // Allocate the new buffer consisting of the size of the orginal
        // string plus the sizeof of the new string plus the null terminator.
        //
        size_t cchSize = lstrlen( pszTmp ) + lstrlen( psz ) + 1;
        _pszString = (LPTSTR)AllocMem(cchSize * sizeof(pszTmp[0]));

        //
        // If memory was not available.
        //
        if( !_pszString ){

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Mark the string object as invalid.
            //
            _pszString = &TString::gszNullState[kInValid];

        } else {

            //
            // Copy the string and concatenate the passed string.
            //
            StringCchCopy( _pszString, cchSize, pszTmp);
            StringCchCat(_pszString, cchSize, psz);

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Indicate success.
            //
            bStatus = TRUE;

        }

    //
    // Skip null pointers, not an error.
    //
    } else {

        bStatus = TRUE;

    }

    return bStatus;
}

BOOL
TString::
bUpdate(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe updating of string.  If the allocation fails, return FALSE
    and leave the string as is.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    //
    // Check if the null pointer is passed.
    //
    if( !psz ){

        //
        // If not pointing to the gszNullState
        //
        vFree( _pszString );

        //
        // Mark the object as valid.
        //
       _pszString = &TString::gszNullState[kValid];

        return TRUE;
    }

    //
    // Create temp pointer and allocate the new string.
    //
    LPTSTR pszTmp = _pszString;
    SIZE_T cchLen = lstrlen(psz) + 1;

    _pszString = (LPTSTR) AllocMem(static_cast<DWORD>(cchLen * sizeof( psz[0] )));

    //
    // If memory was not available.
    //
    if( !_pszString ){

        //
        // Ensure we free any previous string.
        //
        vFree( pszTmp );

        //
        // Mark the string object as invalid.
        //
        _pszString = &TString::gszNullState[kInValid];

        return FALSE;
    }

    //
    // Copy the string and
    //
    StringCchCopy( _pszString, cchLen, psz);

    //
    // If the old string object was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    vFree( pszTmp );

    return TRUE;
}

/*++

Routine Name:

    Update

Routine Description:

    Safe updating of string.  If the allocation fails, return E_OUTOFMEMORY.
    
Arguments:

    psz - Input string, may be NULL.

Return Value:

    An HRESULT

--*/
HRESULT
TString::
Update(
    IN LPCTSTR psz
    )
{
    return bUpdate(psz) ? S_OK : E_OUTOFMEMORY;
}

BOOL
TString::
bLoadString(
    IN HINSTANCE hInst,
    IN UINT uID
    )

/*++

Routine Description:

    Safe load of a string from a resources file.

Arguments:

    hInst - Instance handle of resource file.
    uId - Resource id to load.

Return Value:

    TRUE = load successful
    FALSE = load failed

--*/

{
    LPTSTR  pszString   = NULL;
    BOOL    bStatus     = FALSE;
    INT     iSize;
    INT     iLen;

    //
    // Continue increasing the buffer until
    // the buffer is big enought to hold the entire string.
    //
    for( iSize = kStrMax; ; iSize += kStrMax ){

        //
        // Allocate string buffer.
        //
        pszString = (LPTSTR)AllocMem( iSize * sizeof( pszString[0] ) );

        if( pszString ){

            iLen = LoadString( hInst, uID, pszString, iSize );

            if( iLen == 0 ) {

                DBGMSG( DBG_ERROR, ( "String.vLoadString: failed to load IDS 0x%x, %d\n",  uID, GetLastError() ));
                FreeMem( pszString );
                break;

            //
            // Since LoadString does not indicate if the string was truncated or it
            // just happened to fit.  When we detect this ambiguous case we will
            // try one more time just to be sure.
            //
            } else if( iSize - iLen <= sizeof( pszString[0] ) ){

                FreeMem( pszString );

            //
            // LoadString was successful release original string buffer
            // and update new buffer pointer.
            //
            } else {

                vFree( _pszString );
                _pszString = pszString;
                bStatus = TRUE;
                break;
            }

        } else {
            DBGMSG( DBG_ERROR, ( "String.vLoadString: unable to allocate memory, %d\n", GetLastError() ));
            break;
        }
    }
    return bStatus;
}

VOID
TString::
vFree(
    IN LPTSTR pszString
    )
/*++

Routine Description:

    Safe free, frees the string memory.  Ensures
    we do not try an free our global memory block.

Arguments:

    pszString pointer to string meory to free.

Return Value:

    Nothing.

--*/

{
    //
    // If this memory was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    if( pszString != &TString::gszNullState[kValid] &&
        pszString != &TString::gszNullState[kInValid] ){

        FreeMem( pszString );
    }
}


BOOL
TString::
bFormat(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
/*++

Routine Description:

    Format the string opbject similar to sprintf.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/

    BOOL bStatus = TRUE;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    bStatus = bvFormat( pszFmt, pArgs );

    va_end( pArgs );

    return bStatus;

}

BOOL
TString::
bvFormat(
    IN LPCTSTR pszFmt,
    IN va_list avlist
    )
/*++

Routine Description:

    Format the string opbject similar to vsprintf.

Arguments:

    pszFmt pointer format string.
    pointer to variable number of arguments similar to vsprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/
{
    BOOL bStatus;

    //
    // Save previous string value.
    //
    LPTSTR pszTemp = _pszString;

    //
    // Format the string.
    //
    _pszString = vsntprintf( pszFmt, avlist );

    //
    // If format failed mark object as invalid and
    // set the return value.
    //
    if( !_pszString )
    {
        _pszString = &TString::gszNullState[kInValid];
        bStatus = FALSE;
    }
    else
    {
        bStatus = TRUE;
    }

    //
    // Release near the end because the format string or arguments
    // may be referencing this string object.
    //
    vFree( pszTemp );

    return bStatus;
}

LPTSTR
TString::
vsntprintf(
    IN LPCTSTR      szFmt,
    IN va_list      pArgs
    )
/*++

Routine Description:

    //
    // Formats a string and returns a heap allocated string with the
    // formated data.  This routine can be used to for extremely
    // long format strings.  Note:  If a valid pointer is returned
    // the callng functions must release the data with a call to delete.
    // Example:
    //
    //  LPCTSTR p = vsntprintf("Test %s", pString );
    //
    //  SetTitle( p );
    //
    //  delete [] p;
    //

Arguments:

    pszString pointer format string.
    pointer to a variable number of arguments.

Return Value:

    Pointer to format string.  NULL if error.

--*/

{
    LPTSTR  pszBuff = NULL;
    INT     iSize   = kStrIncrement;

    for( ; ; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = (LPTSTR)AllocMem( iSize * sizeof(TCHAR) );

        if( !pszBuff )
        {
            break;
        }

        //
        // Attempt to format the string.  
        if (SUCCEEDED(StringCchVPrintf( pszBuff, iSize, szFmt, pArgs )))
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        if( pszBuff )
        {
            FreeMem( pszBuff );
        }

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if( iSize > kStrMaxFormatSize )
        {
            DBGMSG( DBG_ERROR, ("TString::vsntprintf failed string too long.\n") );
            pszBuff = NULL;
            break;
        }

    }

    return pszBuff;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\webipp.h ===
/*****************************************************************************\
* MODULE: webipp.h
*
* This is the header module for webipp.c.  This contains the IPP 1.1 parser
* that encodes/decodes data for transfering across the HTTP wire.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* history:
*   27-Oct-1997 <chriswil/v-chrisw> created.
*
\*****************************************************************************/
#ifndef _WEBIPP_H
#define _WEBIPP_H

#include <time.h>

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
extern "C" {        // when doing C++ stuff.
#endif

/***********************************************\
* Common Macros
*
\***********************************************/
#define offs(type, identifier) ((ULONG_PTR)&(((type)0)->identifier))


/***********************************************\
* Constant Values
*
\***********************************************/
#define IPP_BLOCK_SIZE  1024
#define IPP_VERSION     ((WORD)0x0100)
#define IPP_GETJOB_ALL  ((DWORD)0x7FFFFFFF)

#define IPPOBJ_MASK_SIZE     2


#define IPPTYPE_UNKNOWN 0
#define IPPTYPE_PRT     1
#define IPPTYPE_JOB     2
#define IPPTYPE_AUTH    3



#define IPP_ATR_ABSOLUTE     0
#define IPP_ATR_OFFSET      -1
#define IPP_ATR_OFFSETCONV  -2
#define IPP_ATR_TAG         -4


/***********************************************\
* IPP Element Sizes
*
*   These are used to identify the size of
*   IPP element values.
*
\***********************************************/
#define IPP_SIZEOFREQ   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFVER   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFLEN   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFTAG   sizeof(BYTE)     // 1 byte
#define IPP_SIZEOFINT   sizeof(DWORD)    // 4 bytes
#define IPP_SIZEOFBYTE  sizeof(BYTE)     // 1 bytes
#define IPP_SIZEOFHDR   (IPP_SIZEOFVER + IPP_SIZEOFREQ + IPP_SIZEOFINT)


/***********************************************\
* IPP Attribute Sizes
*
\***********************************************/
#define SIZE_TEXT           1023
#define SIZE_NAME            255
#define SIZE_KEYWORD         255
#define SIZE_KEYWORDNAME     255
#define SIZE_ENUM              4
#define SIZE_URI            1023
#define SIZE_URISCHEME        63
#define SIZE_CHARSET          63
#define SIZE_NATLANG          63
#define SIZE_MIMEMEDIA        63
#define SIZE_OCTSTRING      1023
#define SIZE_BOOLEAN           1
#define SIZE_INTEGER           4
#define SIZE_RANGEINTEGER      8
#define SIZE_DATETIME         11
#define SIZE_RESOLUTION        9


/***********************************************\
* IPP Job-State Codes
*
\***********************************************/
#define IPP_JOBSTATE_UNKNOWN            ((BYTE)0)
#define IPP_JOBSTATE_PENDING            ((BYTE)3)
#define IPP_JOBSTATE_PENDINGHELD        ((BYTE)4)
#define IPP_JOBSTATE_PROCESSING         ((BYTE)5)
#define IPP_JOBSTATE_PROCESSEDSTOPPED   ((BYTE)6)
#define IPP_JOBSTATE_CANCELLED          ((BYTE)7)
#define IPP_JOBSTATE_ABORTED            ((BYTE)8)
#define IPP_JOBSTATE_COMPLETED          ((BYTE)9)


/***********************************************\
* IPP Printer-State Codes
*
\***********************************************/
#define IPP_PRNSTATE_UNKNOWN            ((DWORD)0)
#define IPP_PRNSTATE_IDLE               ((DWORD)3)
#define IPP_PRNSTATE_PROCESSING         ((DWORD)4)
#define IPP_PRNSTATE_STOPPED            ((DWORD)5)


/***********************************************\
* IPP Request/Response Codes
*
\***********************************************/
#define IPP_REQ_GETOPERATION    ((WORD)0x0001)
#define IPP_REQ_PRINTJOB        ((WORD)0x0002)  // Implemented
#define IPP_REQ_PRINTURI        ((WORD)0x0003)
#define IPP_REQ_VALIDATEJOB     ((WORD)0x0004)  // Implemented
#define IPP_REQ_CREATEJOB       ((WORD)0x0005)
#define IPP_REQ_SENDDOC         ((WORD)0x0006)
#define IPP_REQ_SENDURI         ((WORD)0x0007)
#define IPP_REQ_CANCELJOB       ((WORD)0x0008)  // Implemented
#define IPP_REQ_GETJOB          ((WORD)0x0009)  // Implemented
#define IPP_REQ_ENUJOB          ((WORD)0x000A)  // Implemented
#define IPP_REQ_GETPRN          ((WORD)0x000B)  // Implemented
#define IPP_REQ_PAUSEJOB        ((WORD)0x000C)  // Implemented
#define IPP_REQ_RESUMEJOB       ((WORD)0x000D)  // Implemented
#define IPP_REQ_RESTARTJOB      ((WORD)0x000E)  // Implemented
#define IPP_REQ_REPROCESSJOB    ((WORD)0x000F)
#define IPP_REQ_PAUSEPRN        ((WORD)0x0010)  // Implemented
#define IPP_REQ_RESUMEPRN       ((WORD)0x0011)  // Implemented
#define IPP_REQ_CANCELPRN       ((WORD)0x0012)  // Implemented
#define IPP_REQ_FORCEAUTH       ((WORD)0x4000)

#define IPP_RESPONSE            ((WORD)0x1000)
#define IPP_RET_PRINTJOB        (IPP_RESPONSE | IPP_REQ_PRINTJOB)
#define IPP_RET_VALIDATEJOB     (IPP_RESPONSE | IPP_REQ_VALIDATEJOB)
#define IPP_RET_CANCELJOB       (IPP_RESPONSE | IPP_REQ_CANCELJOB)
#define IPP_RET_GETJOB          (IPP_RESPONSE | IPP_REQ_GETJOB)
#define IPP_RET_ENUJOB          (IPP_RESPONSE | IPP_REQ_ENUJOB)
#define IPP_RET_GETPRN          (IPP_RESPONSE | IPP_REQ_GETPRN)
#define IPP_RET_PAUSEJOB        (IPP_RESPONSE | IPP_REQ_PAUSEJOB)
#define IPP_RET_RESUMEJOB       (IPP_RESPONSE | IPP_REQ_RESUMEJOB)
#define IPP_RET_RESTARTJOB      (IPP_RESPONSE | IPP_REQ_RESTARTJOB)
#define IPP_RET_PAUSEPRN        (IPP_RESPONSE | IPP_REQ_PAUSEPRN)
#define IPP_RET_RESUMEPRN       (IPP_RESPONSE | IPP_REQ_RESUMEPRN)
#define IPP_RET_CANCELPRN       (IPP_RESPONSE | IPP_REQ_CANCELPRN)
#define IPP_RET_FORCEAUTH       (IPP_RESPONSE | IPP_REQ_FORCEAUTH)


/***********************************************\
* IPP Response Error Codes
*
\***********************************************/
#define IPPRSP_SUCCESS    ((WORD)0x0000)    // Standard
#define IPPRSP_SUCCESS1   ((WORD)0x0001)    // Standard
#define IPPRSP_SUCCESS2   ((WORD)0x0002)    // Standard

#define IPPRSP_ERROR_400  ((WORD)0x0400)    // Standard
#define IPPRSP_ERROR_401  ((WORD)0x0401)    // Standard
#define IPPRSP_ERROR_402  ((WORD)0x0402)    // Standard
#define IPPRSP_ERROR_403  ((WORD)0x0403)    // Standard
#define IPPRSP_ERROR_404  ((WORD)0x0404)    // Standard
#define IPPRSP_ERROR_405  ((WORD)0x0405)    // Standard
#define IPPRSP_ERROR_406  ((WORD)0x0406)    // Standard
#define IPPRSP_ERROR_407  ((WORD)0x0407)    // Standard
#define IPPRSP_ERROR_408  ((WORD)0x0408)    // Standard
#define IPPRSP_ERROR_409  ((WORD)0x0409)    // Standard
#define IPPRSP_ERROR_40A  ((WORD)0x040A)    // Standard
#define IPPRSP_ERROR_40B  ((WORD)0x040B)    // Standard
#define IPPRSP_ERROR_40C  ((WORD)0x040C)    // Standard
#define IPPRSP_ERROR_40D  ((WORD)0x040D)    // Standard
#define IPPRSP_ERROR_40E  ((WORD)0x040E)    // Standard
#define IPPRSP_ERROR_500  ((WORD)0x0500)    // Standard
#define IPPRSP_ERROR_501  ((WORD)0x0501)    // Standard
#define IPPRSP_ERROR_502  ((WORD)0x0502)    // Standard
#define IPPRSP_ERROR_503  ((WORD)0x0503)    // Standard
#define IPPRSP_ERROR_504  ((WORD)0x0504)    // Standard
#define IPPRSP_ERROR_505  ((WORD)0x0505)    // Standard
#define IPPRSP_ERROR_506  ((WORD)0x0506)    // Standard
#define IPPRSP_ERROR_540  ((WORD)0x0540)    // Extended

#define SUCCESS_RANGE(wRsp) ((BOOL)((wRsp >= 0x0000) && (wRsp <= 0x00FF)))

#define ERROR_RANGE(wReq)                                          \
    (((wReq >= IPPRSP_ERROR_400) && (wReq <= IPPRSP_ERROR_40E)) || \
     ((wReq >= IPPRSP_ERROR_500) && (wReq <= IPPRSP_ERROR_506)) || \
     ((wReq == IPPRSP_ERROR_540)))


#define REQID_RANGE(idReq) (((DWORD)idReq >= 1) && ((DWORD)idReq <= 0x7FFFFFFF))


/***********************************************\
* IPP Attribute Delimiter Tags
*
\***********************************************/
#define IPP_TAG_DEL_RESERVED    ((BYTE)0x00)    //
#define IPP_TAG_DEL_OPERATION   ((BYTE)0x01)    //
#define IPP_TAG_DEL_JOB         ((BYTE)0x02)    //
#define IPP_TAG_DEL_DATA        ((BYTE)0x03)    //
#define IPP_TAG_DEL_PRINTER     ((BYTE)0x04)    //
#define IPP_TAG_DEL_UNSUPPORTED ((BYTE)0x05)    //

#define IPP_TAG_OUT_UNSUPPORTED ((BYTE)0x10)    //
#define IPP_TAG_OUT_DEFAULT     ((BYTE)0x11)    //
#define IPP_TAG_OUT_NONE        ((BYTE)0x12)    //
#define IPP_TAG_OUT_COMPOUND    ((BYTE)0x13)    //

#define IPP_TAG_INT_INTEGER     ((BYTE)0x21)    // sizeof(DWORD)
#define IPP_TAG_INT_BOOLEAN     ((BYTE)0x22)    // sizeof(BYTE)
#define IPP_TAG_INT_ENUM        ((BYTE)0x23)    // sizeof(DWORD)

#define IPP_TAG_OCT_STRING      ((BYTE)0x30)    // UTF-8
#define IPP_TAG_OCT_DATETIME    ((BYTE)0x31)    // UTF-8
#define IPP_TAG_OCT_RESOLUTION  ((BYTE)0x32)    // UTF-8
#define IPP_TAG_OCT_RANGEOFINT  ((BYTE)0x33)    // UTF-8
#define IPP_TAG_OCT_DICTIONARY  ((BYTE)0x34)    // UTF-8
#define IPP_TAG_OCT_TXTWITHLANG ((BYTE)0x35)
#define IPP_TAG_OCT_NMEWITHLANG ((BYTE)0x36)

#define IPP_TAG_CHR_TEXT        ((BYTE)0x41)    // CharSet Dependent
#define IPP_TAG_CHR_NAME        ((BYTE)0x42)    // CharSet Dependent
#define IPP_TAG_CHR_KEYWORD     ((BYTE)0x44)    // US-ASCII
#define IPP_TAG_CHR_URI         ((BYTE)0x45)    // US-ASCII
#define IPP_TAG_CHR_URISCHEME   ((BYTE)0x46)    // US-ASCII
#define IPP_TAG_CHR_CHARSET     ((BYTE)0x47)    // US-ASCII
#define IPP_TAG_CHR_NATURAL     ((BYTE)0x48)    // US-ASCII
#define IPP_TAG_CHR_MEDIA       ((BYTE)0x49)    // US-ASCII


#define IPP_MANDITORY ((BYTE)0x00)
#define IPP_OPTIONAL  ((BYTE)0x10)
#define IPP_MULTIPLE  ((BYTE)0x20)
#define IPP_HIT       ((BYTE)0x80)

/***********************************************\
* IPP Tag-Value Ranges
*
\***********************************************/
#define IS_TAG_DELIMITER(bTag)   ((BOOL)((bTag >= 0x00) && (bTag <= 0x0F)))
#define IS_TAG_ATTRIBUTE(bTag)   ((BOOL)((bTag >= 0x10) && (bTag <= 0xFF)))
#define IS_TAG_OUTBOUND(bTag)    ((BOOL)((bTag >= 0x10) && (bTag <= 0x1F)))
#define IS_TAG_INTEGER(bTag)     ((BOOL)((bTag >= 0x20) && (bTag <= 0x2F)))
#define IS_TAG_OCTSTR(bTag)      ((BOOL)((bTag >= 0x30) && (bTag <= 0x3F)))
#define IS_TAG_CHRSTR(bTag)      ((BOOL)((bTag >= 0x40) && (bTag <= 0x5F)))
#define IS_TAG_CHARSETSTR(bTag)  ((BOOL)((bTag == 0x41) || (bTag == 0x42)))
#define IS_RANGE_DELIMITER(bTag) ((BOOL)((bTag >= 0x00) && (bTag <= 0x05)))

#define IS_TAG_COMPOUND(bTag)    ((BOOL)((bTag == 0x35) || (bTag == 0x36)))

/***********************************************\
* IPP Request Flags
*
\***********************************************/

#define RA_JOBURI                      0x00000001
#define RA_JOBID                       0x00000002
#define RA_JOBSTATE                    0x00000004
#define RA_JOBNAME                     0x00000008
#define RA_JOBSIZE                     0x00000010
#define RA_JOBUSER                     0x00000020
#define RA_JOBPRIORITY                 0x00000040
#define RA_JOBFORMAT                   0x00000080
#define RA_JOBSTATE_REASONS            0x00000100
#define RA_JOBSTATE_MESSAGE            0x00000200
#define RA_JOBCOUNT                    0x00000400
#define RA_SHEETSTOTAL                 0x00000800
#define RA_SHEETSCOMPLETED             0x00001000
#define RA_PRNURI                      0x00002000
#define RA_PRNSTATE                    0x00004000
#define RA_PRNNAME                     0x00008000
#define RA_PRNMAKE                     0x00010000
#define RA_URISUPPORTED                0x00020000
#define RA_URISECURITY                 0x00040000
#define RA_ACCEPTINGJOBS               0x00080000
#define RA_CHRSETCONFIGURED            0x00100000
#define RA_CHRSETSUPPORTED             0x00200000
#define RA_NATLNGCONFIGURED            0x00400000
#define RA_NATLNGSUPPORTED             0x00800000
#define RA_DOCDEFAULT                  0x01000000
#define RA_DOCSUPPORTED                0x02000000
#define RA_PDLOVERRIDE                 0x04000000
#define RA_UPTIME                      0x08000000
#define RA_OPSSUPPORTED                0x10000001
#define RA_JOBKSUPPORTED               0x10000002
#define RA_JOBSCOMPLETED               0x10000004
#define RA_JOBSUNCOMPLETED             0x10000008
#define RA_TIMEATCREATION              0x10000010



#define IPP_REQALL_IDX       8
#define IPP_REQENU_IDX       9
#define IPP_REQJDSC_IDX     10
#define IPP_REQJTMP_IDX     11
#define IPP_REQPDSC_IDX     12
#define IPP_REQPTMP_IDX     13
#define IPP_REQCLEAR_IDX    14

#define IPP_REQALL      ((DWORD)0x80000000)
#define IPP_REQENU      ((DWORD)0x90000000)
#define IPP_REQJDSC     ((DWORD)0xA0000000)
#define IPP_REQJTMP     ((DWORD)0xB0000000)
#define IPP_REQPDSC     ((DWORD)0xC0000000)
#define IPP_REQPTMP     ((DWORD)0xD0000000)
#define IPP_REQCLEAR    ((DWORD)0xE0000000)


/***********************************************\
* WebIppRcvData Return Codes
*
*   Receive API codes.  These are our internal
*   return-codes for the WebIpp routines.  They
*   have no connection to the IPP spec, but are
*   needed to let the caller know status of our
*   IPP handler-routines.
*
\***********************************************/
#define WEBIPP_OK              0
#define WEBIPP_FAIL            1
#define WEBIPP_MOREDATA        2
#define WEBIPP_BADHANDLE       3
#define WEBIPP_NOMEMORY        4


/***********************************************\
* IPP Job/Printer Structures
*
* These are meant to provide additional
* information to the standard W32 Spooler
* structures.
*
\***********************************************/
typedef struct _JOB_INFO_IPP {

     LPTSTR pPrnUri;
     LPTSTR pJobUri;
     DWORD  cJobs;

} JOB_INFO_IPP;
typedef JOB_INFO_IPP *PJOB_INFO_IPP;
typedef JOB_INFO_IPP *LPJOB_INFO_IPP;

typedef struct _IPPJI2 {

    JOB_INFO_2   ji2;
    JOB_INFO_IPP ipp;

} IPPJI2;
typedef IPPJI2 *PIPPJI2;
typedef IPPJI2 *LPIPPJI2;

typedef struct _PRINTER_INFO_IPP {

    LPTSTR pPrnUri;
    LPTSTR pUsrName;
    time_t dwPowerUpTime;   // This stores the T0 time of the printer in UCT, it is intentionally
                           // signed so that we can support Printers who's T0 is smaller than
                           // our T0 (1 Jan 1970) 
} PRINTER_INFO_IPP;

typedef PRINTER_INFO_IPP *PPRINTER_INFO_IPP;
typedef PRINTER_INFO_IPP *LPPRINTER_INFO_IPP;

typedef struct _IPPPI2 {

    PRINTER_INFO_2   pi2;
    PRINTER_INFO_IPP ipp;

} IPPPI2;
typedef IPPPI2 *PIPPPI2;
typedef IPPPI2 *LPIPPPI2;


/***********************************************\
* IPP Return Structures
*
*   IPPRET_JOB    - Job Information Response.
*   IPPRET_PRN    - Printer Information Response.
*   IPPRET_ENUJOB - Enum-Job.
*   IPPRET_AUTH   - Authentication.
*
\***********************************************/
typedef struct _IPPRET_ALL {

    DWORD cbSize;        // Size of entire structure.
    DWORD dwLastError;   // LastError.
    WORD  wRsp;          // Response Code.
    BOOL  bRet;          // Return Code.

} IPPRET_ALL;
typedef IPPRET_ALL *PIPPRET_ALL;
typedef IPPRET_ALL *LPIPPRET_ALL;

typedef IPPRET_ALL *PIPPRET_AUTH;
typedef IPPRET_ALL *LPIPPRET_AUTH;

typedef struct _IPPRET_JOB {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwLastError; // LastError for failed calls.
    WORD   wRsp;        // Response Code.
    BOOL   bRet;        // Return code for job calls.
    BOOL   bValidate;   // Is this only a validation request.
    IPPJI2 ji;          // Job-Information.

} IPPRET_JOB;
typedef IPPRET_JOB *PIPPRET_JOB;
typedef IPPRET_JOB *LPIPPRET_JOB;

typedef struct _IPPRET_PRN {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwLastError; // LastError for failed calls.
    WORD   wRsp;        // Response Code.
    BOOL   bRet;        // Return code for printer calls.
    IPPPI2 pi;          // Printer-Information.

} IPPRET_PRN;
typedef IPPRET_PRN *PIPPRET_PRN;
typedef IPPRET_PRN *LPIPPRET_PRN;

typedef struct _IPPRET_ENUJOB {

    DWORD    cbSize;       // Size of entire structure (including enum-data).
    DWORD    dwLastError;  // LastError for failed calls.
    WORD     wRsp;         // Response Code.
    BOOL     bRet;         // EnumJob/Get Return-Code.
    DWORD    cItems;       // Number of items in enum.
    DWORD    cbItems;      // Size of Enum Data.
    LPIPPJI2 pItems;       //

} IPPRET_ENUJOB;
typedef IPPRET_ENUJOB *PIPPRET_ENUJOB;
typedef IPPRET_ENUJOB *LPIPPRET_ENUJOB;


/***********************************************\
* IPP Request Structures
*
*   IPPREQ_PRTJOB - Print-Job/Validate-Job.
*   IPPREQ_ENUJOB - Enum-Job.
*   IPPREQ_GETJOB - Get-Job.
*   IPPREQ_SETJOB - Set-Job.
*   IPPREQ_GETPRN - Get-Printer.
*   IPPREQ_SETPRN - Set-Printer.
*   IPPREQ_AUTH   - Authentication.
*
\***********************************************/
typedef struct _IPPREQ_ALL {

    DWORD cbSize;        // Size of entire structure.

} IPPREQ_ALL;
typedef IPPREQ_ALL *PIPPREQ_ALL;
typedef IPPREQ_ALL *LPIPPREQ_ALL;

typedef IPPREQ_ALL IPPREQ_AUTH;
typedef IPPREQ_ALL *PIPPREQ_AUTH;
typedef IPPREQ_ALL *LPIPPREQ_AUTH;

typedef struct _IPPREQ_PRTJOB {

    DWORD  cbSize;      // Size of entire structure.
    BOOL   bValidate;   // Indicates whether this is only a validation.
    LPTSTR pDocument;   // Document name.
    LPTSTR pUserName;   // Requesting User name.
    LPTSTR pPrnUri;     // Printer Uri string.

} IPPREQ_PRTJOB;
typedef IPPREQ_PRTJOB *PIPPREQ_PRTJOB;
typedef IPPREQ_PRTJOB *LPIPPREQ_PRTJOB;

typedef struct _IPPREQ_SETJOB {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwCmd;       // Job command.
    DWORD  idJob;       // Job ID.
    LPTSTR pPrnUri;     // Job Uri.

} IPPREQ_SETJOB;
typedef IPPREQ_SETJOB *PIPPREQ_SETJOB;
typedef IPPREQ_SETJOB *LPIPPREQ_SETJOB;

typedef struct _IPPREQ_ENUJOB {

    DWORD  cbSize;
    DWORD  cJobs;
    LPTSTR pPrnUri;

} IPPREQ_ENUJOB;
typedef IPPREQ_ENUJOB *PIPPREQ_ENUJOB;
typedef IPPREQ_ENUJOB *LPIPPREQ_ENUJOB;

typedef struct _IPPREQ_GETPRN {

    DWORD  cbSize;
    DWORD  dwAttr;
    LPTSTR pPrnUri;

} IPPREQ_GETPRN;
typedef IPPREQ_GETPRN *PIPPREQ_GETPRN;
typedef IPPREQ_GETPRN *LPIPPREQ_GETPRN;

typedef struct _IPPREQ_GETJOB {

    DWORD  cbSize;
    DWORD  idJob;
    LPTSTR pPrnUri;

} IPPREQ_GETJOB;
typedef IPPREQ_GETJOB *PIPPREQ_GETJOB;
typedef IPPREQ_GETJOB *LPIPPREQ_GETJOB;

typedef struct _IPPREQ_SETPRN {

    DWORD  cbSize;
    DWORD  dwCmd;
    LPTSTR pUserName;
    LPTSTR pPrnUri;

} IPPREQ_SETPRN;
typedef IPPREQ_SETPRN *PIPPREQ_SETPRN;
typedef IPPREQ_SETPRN *LPIPPREQ_SETPRN;


/***********************************************\
* IPP Attribute Structure.
*
\***********************************************/
typedef struct _IPPATTR {

    BYTE   bTag;
    WORD   cbName;
    LPTSTR lpszName;
    WORD   cbValue;
    LPVOID lpValue;

} IPPATTR;
typedef IPPATTR *PIPPATTR;
typedef IPPATTR *LPIPPATTR;


/***********************************************\
* IPP Error-Mappings
*
\***********************************************/
typedef struct _IPPERROR {

    WORD   wRsp;
    DWORD  dwLE;
    PCTSTR pszStr;

} IPPERROR;
typedef IPPERROR *PIPPERROR;
typedef IPPERROR *LPIPPERROR;


/***********************************************\
* IPP Default-Error-Mappings
*
\***********************************************/
typedef struct _IPPDEFERROR {

    DWORD dwLE;
    WORD  wRsp;

} IPPDEFERROR;
typedef IPPDEFERROR *PIPPDEFERROR;
typedef IPPDEFERROR *LPIPPDEFERROR;

#define IPPFLG_VALID        1
#define IPPFLG_CHARSET      2
#define IPPFLG_NATLANG      4
#define IPPFLG_USEFIDELITY  8

/***********************************************\
* IPP Object Structure.
*
\***********************************************/
typedef struct _IPPOBJ {

    WORD     wReq;        // Open Request being processed.
    WORD     wError;      // Used to store ipp errors during receive processing.
    DWORD    idReq;       // Request Id.
    UINT     uCPRcv;      // Codepage translation for receiving IPP Streams.
    DWORD    fState;      //
    DWORD    cbIppMax;    // Maximum size of hdr-Buffer.
    DWORD    cbIppHdr;    // Current size of hdr-buffer data.
    LPBYTE   lpIppHdr;    // Buffer to contain IPP-Stream-Header.
    LPBYTE   lpRawDta;    // Aligned (temporary) data buffer.
    LPWEBLST pwlUns;      // Unsupported attributes list.

    DWORD    fReq[IPPOBJ_MASK_SIZE];

} IPPOBJ;
typedef IPPOBJ *PIPPOBJ;
typedef IPPOBJ *LPIPPOBJ;


/***********************************************\
* Request Info
*
\***********************************************/
typedef struct _REQINFO {

    DWORD   idReq;
    UINT    cpReq;
    PWEBLST pwlUns;
    BOOL    bFidelity;
    DWORD   fReq[IPPOBJ_MASK_SIZE];

} REQINFO;
typedef REQINFO *PREQINFO;
typedef REQINFO *LPREQINFO;

/***********************************************\
* TypeDefs
*
\***********************************************/
typedef DWORD (*PFNRET)(LPIPPOBJ lpObj, LPBYTE* lplpRawHdr, LPDWORD lpcbRawHdr);


/***********************************************\
* IPP Attribute Structre (X)
*
\***********************************************/
typedef struct _IPPATTRX {

    BYTE    bTag;
    DWORD   fReq;
    int     nVal;
    LPCTSTR pszNam;
    LPVOID  pvVal;

} IPPATTRX;
typedef IPPATTRX *PIPPATTRX;
typedef IPPATTRX *LPIPPATTRX;


/***********************************************\
* IPP Attribute Structre (Y)
*
\***********************************************/
typedef struct _IPPATTRY {

    LPSTR pszNam;
    DWORD cbNam;
    LPSTR pszVal;
    DWORD cbVal;

} IPPATTRY;
typedef IPPATTRY *PIPPATTRY;
typedef IPPATTRY *LPIPPATTRY;

/***********************************************\
* IPP Conversion Structure
*
\***********************************************/
typedef struct _IPPSNDRCV {

    WORD       wReq;
    PBYTE      pbReqForm;
    PBYTE      pbRspForm;
    LPIPPATTRX paReq;
    DWORD      cbReq;
    LPIPPATTRX paRsp;
    DWORD      cbRsp;
    PFNRET     pfnRcvRet;

} IPPSNDRCV;
typedef IPPSNDRCV *PIPPSNDRCV;
typedef IPPSNDRCV *LPIPPSNDRCV;


/***********************************************\
* Flag/String Structure.
*
\***********************************************/
typedef struct _FLGSTR {

    DWORD   fFlag;
    LPCTSTR pszStr;

} FLGSTR;
typedef FLGSTR *PFLGSTR;
typedef FLGSTR *LPFLGSTR;


/************************************************
** Definition of Allocator (for outside functions)
************************************************/
typedef LPVOID (*ALLOCATORFN)(DWORD cb);
         
/***********************************************\
* WebIpp Object routines.
*
\***********************************************/
DWORD WebIppSndData(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpDta,
    DWORD     cbDta,
    LPBYTE*   lpOut,
    LPDWORD   lpcbOut);

HANDLE WebIppRcvOpen(
    WORD);

DWORD WebIppRcvData(
    HANDLE  hIpp,
    LPBYTE  lpData,
    DWORD   cbData,
    LPBYTE  *lplpHdr,
    LPDWORD lpdwHdr,
    LPBYTE  *lplpDta,
    LPDWORD lpdwDta);

BOOL WebIppRcvClose(
    HANDLE hIpp);

WORD WebIppGetError(
    HANDLE hIpp);

WORD WebIppLeToRsp(
    DWORD dwLastError);

DWORD WebIppRspToLe(
    WORD wRsp);

BOOL WebIppGetReqInfo(
    HANDLE    hIpp,
    LPREQINFO lpri);

BOOL WebIppFreeMem(
    LPVOID lpMem);

LPIPPJI2 WebIppCvtJI2toIPPJI2(
    IN     LPCTSTR      lpszJobBase,
    IN OUT LPDWORD      lpcbJobs,
    IN     DWORD        cJobs,
    IN     LPJOB_INFO_2 lpJI2Src);

LPJOB_INFO_2 WebIppPackJI2(
    IN  LPJOB_INFO_2 lpji2,
    OUT LPDWORD      lpcbSize,
    IN  ALLOCATORFN  pfnAlloc
);

/***********************************************\
* Request Creation Routines
*
\***********************************************/
PIPPREQ_PRTJOB WebIppCreatePrtJobReq(
    BOOL    bValidate,
    LPCTSTR lpszUser,
    LPCTSTR lpszDoc,
    LPCTSTR lpszPrnUri);

PIPPREQ_ENUJOB WebIppCreateEnuJobReq(
    DWORD   cJobs,
    LPCTSTR lpszPrnUri);

PIPPREQ_SETJOB WebIppCreateSetJobReq(
    DWORD   idJob,
    DWORD   dwCmd,
    LPCTSTR lpszPrnUri);

PIPPREQ_GETJOB WebIppCreateGetJobReq(
    DWORD   idJob,
    LPCTSTR lpszPrnUri);

PIPPREQ_GETPRN WebIppCreateGetPrnReq(
    DWORD   dwAttr,
    LPCTSTR lpszPrnUri);

PIPPREQ_SETPRN WebIppCreateSetPrnReq(
    DWORD   dwCmd,
    LPCTSTR lpszPrnName,
    LPCTSTR lpszPrnUri);

PIPPREQ_AUTH WebIppCreateAuthReq(VOID);


/***********************************************\
* Response Creation Routines
*
\***********************************************/
PIPPRET_JOB WebIppCreateJobRet(
    WORD           wRsp,
    BOOL           bRet,
    BOOL           bValidate,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp);

PIPPRET_PRN WebIppCreatePrnRet(
    WORD               wRsp,
    BOOL               bRet,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp);


PIPPRET_ENUJOB WebIppCreateEnuJobRet(
    WORD     wRsp,
    BOOL     bRet,
    DWORD    cbJobs,
    DWORD    cJobs,
    LPIPPJI2 lpbJobs);

PIPPRET_ALL WebIppCreateBadRet(
    WORD wRsp,
    BOOL bRet);

PIPPRET_AUTH WebIppCreateAuthRet(
    WORD wRsp,
    BOOL bRet);

BOOL WebIppConvertSystemTime(
    IN OUT LPSYSTEMTIME pSystemTime,
    IN     time_t       dwPrinterT0);


#ifdef UNICODE

    #define WEB_IPP_ASSERT(Expr) ASSERT(Expr)

#else

    #define WEB_IPP_ASSERT(Expr) // Need to figure out what to do here
    
#endif

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif              //
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\webpnp.cxx ===
/*****************************************************************************\
* MODULE: webpnp.cxx
*
* This module contains routines which read/write printer-configuration
* data to a BIN-File.  The file format is depicted below.  The file begins
* with a header indicating the number of (pData) items.  THIS DOES NOT
* include the DEVMODEW in its item-count.  So, at a minimum, this code
* could result in the setting of a DEVMODE, or just setting the printer
* data, depending upon the header information.
*
*
*   DEVBIN_HEAD          DEVBIN_INFO         ...->      DEVBIN_INFO
*  --------------------------------------------------------------------------
* |            |           cbSize             |           cbSize             |
* |  bDevMode  |------------------------------|------------------------------|
* |  cItems    |      |     |      |  cbData  |      |     |      |  cbData  |
* |            | Type | Key | Name |----------| Type | Key | Name |----------|
* |            |      |     |      | DevModeW |      |     |      | pData 0  |
*  --------------------------------------------------------------------------
*
* The usage scenario is for webWritePrinterInfo() to query a printer and
* write out the DEVMODEW and Printer-Configuration data to this file-format.
* On a call to webReadPrinterInfo(), a particular printer is opened, and
* the BIN-File is read.  The printer is then reset to the information
* contained in the BIN-File.  This is accomplished by doing a GetPrinter(2)
* on the opened-printer, then re-configuring the PRINT_INFO_2 information
* and reseting the the printer through SetPrinter(2).
*
* Likewise, if there exists printer-data, the information is set to the
* opened printer through SetPrinterData() calls.
*
*
* NOTE: The DEVMODE is always the FIRST entry in this file following the
*       DEVBIN_HEAD.
*
* NOTE: The (cItems) only refers to the (Printer-Data) fields.  It does
*       not count the DEVMODEW.
*
* NOTE: The processing for ICM-Profile enumeration is performed in unicode
*       strings and only converted to TCHAR type strings on callbacks to
*       the caller of the enum API.  This is desirable to maintain a level
*       of consistency when dealing with text.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   25-Feb-1997 <chriswil> created.
*
\*****************************************************************************/

#include "spllibp.hxx"
#include <winspool.h>
#include <winsplp.h>
#include <icm.h>
#include <wininet.h>

/***************************************\
* Static Strings.
\***************************************/
static CONST WCHAR s_wszCopyFiles[] = L"CopyFiles";
static CONST WCHAR s_wszDir[]       = L"Directory";
static CONST WCHAR s_wszFil[]       = L"Files";
static CONST WCHAR s_wszMod[]       = L"Module";
static CONST CHAR  s_szGCFP[]       = "GenerateCopyFilePaths";


/*****************************************************************************\
* web_GAlloc (Local Routine)
*
* Allocates a block of memory.
*
\*****************************************************************************/
inline LPVOID web_GAlloc(
    DWORD cbSize)
{
    return new BYTE[cbSize];
}


/*****************************************************************************\
* web_GFree (Local Routine)
*
* Deletes the memory-block allocated via web_GAlloc().
*
\*****************************************************************************/
inline BOOL web_GFree(
    LPVOID lpMem)
{
    delete [] lpMem;

    return TRUE;
}


/*****************************************************************************\
* web_AlignSize (Local Routine)
*
* Returns size (bytes) of the memory-block.  This returns a 64 bit aligned
* value.
*
\*****************************************************************************/
inline DWORD web_AlignSize(
    DWORD cbSize)
{
    return ((cbSize & 7) ? cbSize + (8 - (cbSize & 7)) : cbSize);
}


/*****************************************************************************\
* web_StrSizeW (Local Routine)
*
* Returns size (bytes) of the string.  This includes the NULL terminator.
*
\*****************************************************************************/
inline DWORD web_StrSizeW(
    LPCWSTR lpszStr)
{
    return ((lstrlenW(lpszStr) + 1) * sizeof(WCHAR));
}


/*****************************************************************************\
* web_NextStrW (Local Routine)
*
* Returns pointer to the next-item in a string array.
*
\*****************************************************************************/
inline LPWSTR web_NextStrW(
    LPCWSTR lpszStr)
{
    return ((LPWSTR)lpszStr + (lstrlenW(lpszStr) + 1));
}


/*****************************************************************************\
* web_NextItem (Local Routine)
*
* Returns pointer to the next-item in the BIN-File.
*
\*****************************************************************************/
inline LPDEVBIN_INFO web_NextItem(
    LPDEVBIN_INFO lpInfo)
{
    return (LPDEVBIN_INFO)(((LPBYTE)lpInfo) + lpInfo->cbSize);
}


/*****************************************************************************\
* web_MBtoWC (Local Routine)
*
* Converts a MultiByte string to a Unicode string.
*
\*****************************************************************************/
inline DWORD web_MBtoWC(
    LPWSTR lpszWC,
    LPCSTR lpszMB,
    DWORD  cbSize)
{
    cbSize = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszMB,
                                        -1,
                                        lpszWC,
                                        (int)(cbSize / sizeof(WCHAR)));

    return (cbSize * sizeof(WCHAR));
}


/*****************************************************************************\
* web_WCtoTC (Local Routine)
*
* Converts a Unicode string to a string appropriate for the built library.
* The size must account for the NULL terminator when specifying size.
*
\*****************************************************************************/
inline LPTSTR web_WCtoTC(
    LPCWSTR lpwszWC,
    DWORD   cchWC)
{
    LPTSTR lpszTC;
    DWORD  cbSize;


    cbSize = cchWC * sizeof(TCHAR);

    if (lpszTC = (LPTSTR)web_GAlloc(cbSize)) {

#ifdef UNICODE

        //
        // Use CopyMemory, not lstrcpyn.  This allows strings
        // with nulls in them...(e.g. MULTI_SZ regsitry values
        //
        CopyMemory(lpszTC, lpwszWC, cbSize);

#else

        WideCharToMultiByte(CP_ACP,
                            WC_DEFAULTCHAR,
                            lpwszWC,
                            cchWC,
                            lpszTC,
                            cchWC,
                            NULL,
                            NULL);
#endif

    }

    return lpszTC;
}


/*****************************************************************************\
* web_OpenDirectoryW (Local Routine)
*
* Open a handle to a directory.
*
\*****************************************************************************/
inline HANDLE web_OpenDirectoryW(
    LPCWSTR lpwszDir)
{
    return CreateFileW(lpwszDir,
                      0,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/*****************************************************************************\
* web_OpenFileRead (Local Routine)
*
* Open a file for reading.
*
\*****************************************************************************/
inline HANDLE web_OpenFileRead(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/*****************************************************************************\
* web_OpenFileWrite (Local Routine)
*
* Open a file for writing.
*
\*****************************************************************************/
inline HANDLE web_OpenFileWrite(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/*****************************************************************************\
* web_LockMap (Local Routine)
*
* Locks the map-view.
*
\*****************************************************************************/
inline LPVOID web_LockMap(
    HANDLE hMap)
{
    LPWEB_FILEMAP lpMap;
    LPVOID        lpPtr = NULL;

    if (lpMap = (LPWEB_FILEMAP)hMap)
        lpPtr = MapViewOfFile(lpMap->hMap, FILE_MAP_READ, 0, 0, 0);

    return lpPtr;
}


/*****************************************************************************\
* web_UnlockMap (Local Routine)
*
* Unlocks the map-view.
*
\*****************************************************************************/
inline BOOL web_UnlockMap(
    LPVOID lpPtr)
{
    return UnmapViewOfFile(lpPtr);
}


/*****************************************************************************\
* web_OpenMap (Local Routine)
*
* Opens a file-mapping object.
*
\*****************************************************************************/
HANDLE web_OpenMap(
    LPCTSTR lpszFile)
{
    LPWEB_FILEMAP lpMap;
    DWORD         cbSize;


    if (lpMap = (LPWEB_FILEMAP)web_GAlloc(sizeof(WEB_FILEMAP))) {

        lpMap->hFile = web_OpenFileRead(lpszFile);

        if (lpMap->hFile && (lpMap->hFile != INVALID_HANDLE_VALUE)) {

            if (cbSize = GetFileSize(lpMap->hFile, NULL)) {

                lpMap->hMap = CreateFileMapping(lpMap->hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                cbSize,
                                                NULL);

                if (lpMap->hMap)
                    return (HANDLE)lpMap;
            }

            CloseHandle(lpMap->hFile);
        }

        web_GFree(lpMap);
    }

    return NULL;
}


/*****************************************************************************\
* web_CloseMap (Local Routine)
*
* Closes file-mapping object.
*
\*****************************************************************************/
BOOL web_CloseMap(
    HANDLE hMap)
{
    LPWEB_FILEMAP lpMap;
    BOOL          bRet = FALSE;


    if (lpMap = (LPWEB_FILEMAP)hMap) {

        CloseHandle(lpMap->hMap);
        CloseHandle(lpMap->hFile);

        bRet = web_GFree(lpMap);
    }

    return bRet;
}


/*****************************************************************************\
* web_GAllocStrW (Local Routine)
*
* Allocates a unicode string buffer.
*
\*****************************************************************************/
LPWSTR web_GAllocStrW(
    LPCWSTR lpszStr)
{
    LPWSTR lpszMem;
    DWORD  cbSize;

    if (lpszStr == NULL)
        return NULL;

    cbSize = web_StrSizeW(lpszStr);

    if (lpszMem = (LPWSTR)web_GAlloc(cbSize))
        CopyMemory(lpszMem, lpszStr, cbSize);

    return lpszMem;
}


/*****************************************************************************\
* web_LoadModuleW
*
* Loads the module by first looking in the path.  If this fails it attempts
* to load from the driver-directory.
*
\*****************************************************************************/
HMODULE web_LoadModuleW(
    LPCWSTR lpwszMod)
{
    HMODULE hLib = NULL;
    
    hLib = LoadLibraryW(lpwszMod);

    return hLib;
}


/*****************************************************************************\
* web_FindRCharW
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPWSTR web_FindRCharW(
    LPWSTR lpszStr,
    WCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlenW(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* web_GetDrvDirW
*
* Returns: LPWSTR - the printer driver dir, minus the architecture subdir.
* Example:  Returns something like "%WINDIR%\SYSTEM32\SPOOL\DRIVERS"
*
\*****************************************************************************/
LPWSTR web_GetDrvDirW(VOID)
{
    LPWSTR lpwszDrvDir;
    LPWSTR lpwszFind;
    DWORD  cbSize;

    //
    // Call once to get size of buffer needed.
    //
    cbSize = 0;
    GetPrinterDriverDirectoryW(NULL, NULL, 1, NULL, 0, &cbSize);

    //
    // Alloc a buffer.
    //
    if (cbSize && (lpwszDrvDir = (LPWSTR)web_GAlloc(cbSize)) ) {
        //
        // Get the driver directory.
        //
        if (GetPrinterDriverDirectoryW(NULL,
                                       NULL,
                                       1,
                                       (LPBYTE)lpwszDrvDir,
                                       cbSize,
                                       &cbSize)) {

            //
            // Find the parent-directory of the driver-path.
            //
            if (lpwszFind = web_FindRCharW(lpwszDrvDir, L'\\')) {

                *lpwszFind = L'\0';

                return lpwszDrvDir;
            }
        }
        //
        // Free memory if we fail.
        //
        web_GFree(lpwszDrvDir);
    }

    return NULL;
}


/*****************************************************************************\
* web_BuildNameW
*
* Takes path, name, extension strings and builds a fully-qualified
* string representing the file.  This can also be used to build other
* names.
*
\*****************************************************************************/
LPWSTR web_BuildNameW(
    LPCWSTR lpwszPath,
    LPCWSTR lpwszName,
    LPCWSTR lpwszExt)
{
    DWORD  cch;
    LPWSTR lpwszFull;

    //
    // Calculate the size necessary to hold the full-path filename.
    //
    cch  = lstrlenW(L"\\");
    cch += (lpwszPath ? lstrlenW(lpwszPath) : 0);
    cch += (lpwszName ? lstrlenW(lpwszName) : 0);
    cch += (lpwszExt  ? lstrlenW(lpwszExt)  : 0);


    if (lpwszFull = (LPWSTR)web_GAlloc(((cch + 1) * sizeof(WCHAR)))) {

        if (lpwszPath) {

            if (lpwszExt)
                StringCchPrintfW(lpwszFull, cch+1, L"%s\\%s%s", lpwszPath, lpwszName, lpwszExt);
            else
                StringCchPrintfW(lpwszFull, cch+1, L"%s\\%s", lpwszPath, lpwszName);

        } else {

            if (lpwszExt)
                StringCchPrintfW(lpwszFull, cch+1, L"%s%s", lpwszName, lpwszExt);
            else
                StringCchPrintfW(lpwszFull, cch+1, L"%s", lpwszName);
        }
    }

    return lpwszFull;
}


/*****************************************************************************\
* web_GetCurDirW
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPWSTR web_GetCurDirW(VOID)
{
    DWORD  cbSize;
    LPWSTR lpwszDir = NULL;


    cbSize = GetCurrentDirectoryW(0, NULL);

    if (cbSize && (lpwszDir = (LPWSTR)web_GAlloc((cbSize * sizeof(WCHAR)))))
        GetCurrentDirectoryW(cbSize, lpwszDir);

    return lpwszDir;
}


/*****************************************************************************\
* web_MakeFullKeyW (Local Routine)
*
* Creates a full registry-key from the key/sub-key strings.
*
\*****************************************************************************/
LPWSTR web_MakeFullKeyW(
    LPCWSTR lpszKey,
    LPCWSTR lpszSKey)
{
    DWORD  cbSize;
    LPWSTR lpszFKey = NULL;


    if (lpszKey && lpszSKey) {

        cbSize = web_StrSizeW(lpszKey) + web_StrSizeW(lpszSKey) + sizeof(WCHAR);

        if (lpszFKey = (LPWSTR)web_GAlloc(cbSize)) {

            if (*lpszKey)
                StringCbPrintfW(lpszFKey, cbSize, L"%ws\\%ws", lpszKey, lpszSKey);
            else
                StringCbPrintfW(lpszFKey, cbSize, L"%ws", lpszSKey);
        }
    }

    return lpszFKey;
}


/*****************************************************************************\
* web_KeyExistsW (Local Routine)
*
* Checks to see if the printer-key exists.
*
\*****************************************************************************/
BOOL web_KeyExistsW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    DWORD cbSize;
    DWORD dwRet;


    cbSize = 0;
    dwRet = EnumPrinterKeyW(hPrinter, lpszKey, NULL, 0, &cbSize);

    return (cbSize && (dwRet == ERROR_MORE_DATA));
}


/*****************************************************************************\
* web_EnumPrinterSubKeysW (Local Routine)
*
* Returns an array of printer-keys for the specified key.
*
\*****************************************************************************/
LPWSTR web_EnumPrinterSubKeysW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    DWORD  cbSize;
    DWORD  dwRet;
    LPWSTR aszSKeys;

    //
    // Determine the size necessary for enumerating all the
    // sub-keys for this key.
    //
    cbSize = 0;
    dwRet  = EnumPrinterKeyW(hPrinter, lpszKey, NULL, 0, &cbSize);

    //
    // If OK, then proceed to the enumeration.
    //
    if (cbSize && (dwRet == ERROR_MORE_DATA)) {
        //
        // Allocate the space for retrieving the keys.
        //
        if (aszSKeys = (LPWSTR)web_GAlloc(cbSize)) {
            //
            // Enumerate the sub-keys for this level in (lpszKey).
            //
            dwRet = EnumPrinterKeyW(hPrinter, lpszKey, aszSKeys, cbSize, &cbSize);

            if (dwRet == ERROR_SUCCESS)
                return aszSKeys;

            web_GFree(aszSKeys);
        }
    }

    return NULL;
}


/*****************************************************************************\
* web_EnumPrinterDataW (Local Routine)
*
* Returns an array of printer-data-values for the specified key.
*
\*****************************************************************************/
LPPRINTER_ENUM_VALUES web_EnumPrinterDataW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPDWORD lpcItems)
{
    DWORD                 cbSize;
    DWORD                 dwRet;
    LPPRINTER_ENUM_VALUES apevData;

    //
    // Set the enumerated items to zero.
    //
    *lpcItems = 0;

    //
    // Determine the size necessary to store the enumerated data.
    //
    cbSize = 0;
    dwRet  = EnumPrinterDataExW(hPrinter, lpszKey, NULL, 0, &cbSize, lpcItems);

    //
    // If OK, then proceed to enumerate and write the values to the
    // BIN-File.
    //
    if (cbSize && (dwRet == ERROR_MORE_DATA)) {

        if (apevData = (LPPRINTER_ENUM_VALUES)web_GAlloc(cbSize)) {
            //
            // Enumerate all values for the specified key.  This
            // returns an array of value-structs.
            //
            dwRet = EnumPrinterDataExW(hPrinter,
                                       lpszKey,
                                       (LPBYTE)apevData,
                                       cbSize,
                                       &cbSize,
                                       lpcItems);

            if (dwRet == ERROR_SUCCESS)
                return apevData;

            web_GFree(apevData);
        }
    }

    return NULL;
}


/*****************************************************************************\
* web_GetPrtNameW
*
* Returns a Wide-Char string representing the printer-name.
*
\*****************************************************************************/
LPWSTR web_GetPrtNameW(
    HANDLE hPrinter)
{
    DWORD             cbSize;
    DWORD             cbNeed;
    LPPRINTER_INFO_2W lppi;
    LPWSTR            lpszPrtName = NULL;

    //
    // Get the necessary size for the printer-info-struct.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);

    //
    // Allocate storage for holding the print-info structure.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize))) {

        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {

            lpszPrtName = web_GAllocStrW(lppi->pPrinterName);
        }

        web_GFree(lppi);
    }

    return lpszPrtName;
}


/*****************************************************************************\
* web_GetPrtDataW (Local Routine)
*
* Returns data for the specified key.
*
\*****************************************************************************/
LPBYTE web_GetPrtDataW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPCWSTR lpszVal)
{
    DWORD  dwType;
    DWORD  cbSize;
    DWORD  dwRet;
    LPBYTE lpData;


    cbSize = 0;
    GetPrinterDataExW(hPrinter, lpszKey, lpszVal, &dwType, NULL, 0, &cbSize);

    if (cbSize && (lpData = (LPBYTE)web_GAlloc(cbSize))) {

        dwRet = GetPrinterDataExW(hPrinter,
                                  lpszKey,
                                  lpszVal,
                                  &dwType,
                                  lpData,
                                  cbSize,
                                  &cbSize);

        if (dwRet == ERROR_SUCCESS)
            return lpData;

        web_GFree(lpData);
    }

    return NULL;
}


/*****************************************************************************\
* web_CreateDirW (Local Routine)
*
* Creates the specified directory, if it doesn't exist.
*
\*****************************************************************************/
BOOL web_CreateDirW(
    LPCWSTR lpwszDir)
{
    HANDLE hDir;
    BOOL   bRet = FALSE;


    hDir = web_OpenDirectoryW(lpwszDir);

    if (hDir && (hDir != INVALID_HANDLE_VALUE)) {

        CloseHandle(hDir);

        bRet = TRUE;

    } else {

        bRet = CreateDirectoryW(lpwszDir, NULL);
    }

    return bRet;
}


/*****************************************************************************\
* web_GetICMDirW (Local Routine)
*
* Loads the ICM-Module and returns the target color-directory.  If the
* module isn't loaded then return NULL indicating there is no color
* modules to load.
*
\*****************************************************************************/
LPWSTR web_GetICMDirW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    HMODULE                hLib;
    LPWSTR                 lpwszMod;
    WEBGENCOPYFILEPATHPROC pfn;
    SPLCLIENT_INFO_1       sci;
    LPWSTR                 lpwszSrc;
    LPWSTR                 lpwszDst;
    LPWSTR                 lpwszDrv;
    LPWSTR                 lpwszPrtName;
    DWORD                  cbSrc;
    DWORD                  cbDst;
    DWORD                  dwRet;
    LPWSTR                 lpwszRet = NULL;


    //
    // Load associated module.  (e.g. color module)
    //
    if (lpwszMod = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszMod)) {

        if (hLib = web_LoadModuleW(lpwszMod)) {
            //
            // Call into module to normalize the source/target
            // paths.
            //
            if (pfn = (WEBGENCOPYFILEPATHPROC)GetProcAddress(hLib, s_szGCFP)) {

                if (lpwszPrtName = web_GetPrtNameW(hPrinter)) {

                    if (lpwszDrv = web_GetDrvDirW()) {

                        cbSrc = (MAX_PATH + INTERNET_MAX_HOST_NAME_LENGTH + 1) * sizeof(WCHAR);
                        cbDst = (MAX_PATH + 1) * sizeof(WCHAR);

                        if (lpwszSrc = (LPWSTR)web_GAlloc(cbSrc)) {

                            if (lpwszDst = (LPWSTR)web_GAlloc(cbDst)) {

                                sci.dwSize         = sizeof(SPLCLIENT_INFO_1);
                                sci.pMachineName   = NULL;
                                sci.pUserName      = NULL;
                                sci.dwBuildNum     = 0;
                                sci.dwMajorVersion = webGetOSMajorVer(dwCliInfo);
                                sci.dwMinorVersion = webGetOSMinorVer(dwCliInfo);

                                StringCbPrintfW(lpwszSrc, cbSrc, L"%s\\%s", lpwszDrv, lpwszDir);
                                StringCbCopyW(lpwszDst, cbDst, lpwszDir);

                                dwRet = (*pfn)(lpwszPrtName,
                                               lpwszDir,
                                               (LPBYTE)&sci,
                                               1,
                                               lpwszSrc,
                                               &cbSrc,
                                               lpwszDst,
                                               &cbDst,
                                               COPYFILE_FLAG_SERVER_SPOOLER);

                                if (dwRet == ERROR_SUCCESS) {

                                    lpwszRet = web_GAllocStrW(lpwszDst);
                                }

                                web_GFree(lpwszDst);
                            }

                            web_GFree(lpwszSrc);
                        }

                        web_GFree(lpwszDrv);
                    }

                    web_GFree(lpwszPrtName);
                }
            }

            FreeLibrary(hLib);
        }

        web_GFree(lpwszMod);
    }

    return lpwszRet;
}


/*****************************************************************************\
* web_BuildCopyDirW (Local Routine)
*
* This routine builds the src or dst directory for the CopyFiles. It does the
* following things:
*
* 1) loads optional module (if exists) and calls into it to adjust pathnames
* 2) builds fully-qualified CopyFiles directory
* 3) return the directory name
*
* Upon return this will represent the true path to the ICM profiles for the
* specified key.
*
\*****************************************************************************/
LPWSTR web_BuildCopyDirW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey)
{
    LPWSTR lpwszDir;
    LPWSTR lpwszDrvDir;
    LPWSTR lpwszICM;
    LPWSTR lpwszRet = NULL;

    //
    // Return the directory-value for the specified ICM key.
    //
    if (lpwszDir = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszDir)) {
        //
        // Return the printer-driver-directory-root.
        //
        if (lpwszDrvDir = web_GetDrvDirW()) {
            //
            // If called from the server, then call into the color-module
            // to get the target-directory.  Otherwise, just return the
            // driver directory.
            //
            lpwszICM = web_GetICMDirW(hPrinter, dwCliInfo, lpwszDir, lpwszKey);

            //
            // If the module loaded and return a valid target-directory, then
            // we can return this as our path to the ICM profiles.
            //
            if (lpwszICM != NULL) {
                lpwszRet = web_BuildNameW( lpwszDrvDir, lpwszICM, NULL);
                web_GFree(lpwszICM);  // Free up the memory allocated in web_GetICMDirW
            }


            web_GFree(lpwszDrvDir);
        }

        web_GFree(lpwszDir);
    }

    return lpwszRet;
}


/*****************************************************************************\
* web_CopyFilesW (Local Routine)
*
* This routine copies the point & print "CopyFiles" for the given key.
* It copies files from the web point & print setup-source to the directory
* specified by the "Directory" value under given key.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_CopyFilesW(
    HANDLE  hPrinter,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    LPWSTR awszFiles;
    LPWSTR lpwszFile;
    LPWSTR lpwszCurDir;
    LPWSTR lpwszSrcFile;
    LPWSTR lpwszDstFile;
    LPWSTR lpwszPrtName;
    BOOL   bRet = FALSE;

    //
    // Get the files under the specified ICM key.
    //
    if (awszFiles = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszFil)) {
        //
        // Get our current-directory.
        //
        if (lpwszCurDir = web_GetCurDirW()) {

            if (lpwszPrtName = web_GetPrtNameW(hPrinter)) {
                //
                // For each file in the list, we will need to build our source
                // and destination directories to copy our ICM profiles.
                //
                for (bRet = TRUE, lpwszFile = awszFiles; bRet && *lpwszFile; ) {

                    bRet = FALSE;

                    if (lpwszSrcFile = web_BuildNameW(lpwszCurDir, lpwszFile, NULL)) {

                        if (lpwszDstFile = web_BuildNameW(lpwszDir, lpwszFile, NULL)) {
                            //
                            // Copy the ICM profile to the target directory.
                            //
                            bRet = CopyFileW(lpwszSrcFile, lpwszDstFile, FALSE);

                            web_GFree(lpwszDstFile);
                        }

                        web_GFree(lpwszSrcFile);
                    }

                    lpwszFile = web_NextStrW(lpwszFile);
                }

                web_GFree(lpwszPrtName);
            }

            web_GFree(lpwszCurDir);
        }

        web_GFree(awszFiles);
    }

    return bRet;
}


/*****************************************************************************\
* web_TraverseCopyFilesW (Local Routine)
*
* This routine recursively traverses the printer-registry-settings for
* the CopyFiles keys.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_TraverseCopyFilesW(
    HANDLE  hPrinter,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    LPWSTR awszSKeys;
    LPWSTR lpwszSKey;
    LPWSTR lpwszFKey;
    LPWSTR lpwszFDir;
    DWORD  dwType;
    DWORD  dwCliInfo;
    BOOL   bRet = FALSE;

    //
    // Get the array of keys under the specified key in the registry.
    //
    if (awszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpwszKey)) {
        //
        // For each sub-key in the array, we need to build the path of
        // where we'll place the ICM files.
        //
        for (bRet = TRUE, lpwszSKey = awszSKeys; *lpwszSKey && bRet; ) {

            bRet = FALSE;
            //
            // The enum-routine returns a relative path, so we must build
            // a fully-qualified registry-path.
            //
            if (lpwszFKey = web_MakeFullKeyW(lpwszKey, lpwszSKey)) {

                dwCliInfo = webCreateOSInfo();

                if (lpwszFDir = web_BuildCopyDirW(hPrinter, dwCliInfo, lpwszFKey)) {
                    //
                    // Create the ICM directory if it doesn't exist.  Proceed
                    // to traverse the ICM-keys for more sub-keys.
                    //
                    if (web_CreateDirW(lpwszFDir))
                        bRet = web_TraverseCopyFilesW(hPrinter, lpwszFDir, lpwszFKey);

                    web_GFree(lpwszFDir);
                }

                web_GFree(lpwszFKey);
            }

            lpwszSKey = web_NextStrW(lpwszSKey);
        }

        //
        // Free up the array.
        //
        web_GFree(awszSKeys);

        //
        // Process the ICM files for the specified key.  If this
        // is our top-level key (CopyFiles), then don't bother
        // with the initialization.  i.e. there should be no
        // (module, files, directory) keys at this level.
        //
        if (bRet && lstrcmpiW(lpwszKey, s_wszCopyFiles))
            bRet = web_CopyFilesW(hPrinter, lpwszDir, lpwszKey);
    }

    return bRet;
}


/*****************************************************************************\
* web_WriteHeader (Local Routine)
*
* Outputs the header for the BIN-file.  The parameters to this routine
* specify whether there is a DEVMODE contained in the file, as well as a
* count of all the device-data-items.
*
\*****************************************************************************/
BOOL web_WriteHeader(
    HANDLE hFile,
    DWORD  cItems,
    BOOL   bDevMode)
{
    DWORD       dwWr = 0;
    DEVBIN_HEAD dbh;
    BOOL        bRet;

    //
    // Setup the header information.
    //
    dbh.cItems   = cItems;
    dbh.bDevMode = bDevMode;

    //
    // Make sure our header is positioned at the beginning of the file.
    //
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    //
    // Write out the header.  Check to make sure that all was written
    // succesfully.
    //
    bRet = WriteFile(hFile, &dbh, sizeof(DEVBIN_HEAD), &dwWr, NULL);

    return ((bRet && (dwWr != sizeof(DEVBIN_HEAD))) ? FALSE : bRet);
}


/*****************************************************************************\
* web_ReadDevMode (Local Routine)
*
* Reads the devmode-structure from the BIN-File and sets the printer with
* the information.  Since our data from the BIN-File is in the format
* of UNICODE, we must take care to only use (W) functions.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_ReadDevMode(
    LPDEVBIN_HEAD lpdbh,
    HANDLE        hPrinter,
    LPCTSTR       lpszPrtName)
{
    LPDEVBIN_INFO     lpdbi;
    LPPRINTER_INFO_2W lppi;
    LPDEVMODEW        lpdm;
    DWORD             cbSize;
    DWORD             cbNeed;
    BOOL              bRet = FALSE;

    //
    // Set our pointer past the header.  The DEVMODE always occupies the
    // first entry in our item-list.
    //
    lpdbi = (LPDEVBIN_INFO)(lpdbh + 1);

    //
    // First let's see how big our buffer will need to
    // be in order to hold the PRINTER_INFO_2W.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);

    //
    // Allocate storage for holding the print-info structure as well
    // as the new devmode data we will be copying.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize + lpdbi->cbData))) {
        //
        // Retrieve our current printer-settings.
        //
        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {
            //
            // If our printer has a DEVMODE, then we can continue on
            // with initializing it with our BIN-File DEVMODE.  Otherwise,
            // there's no sense setting a devmode to a printer that
            // doesn't have one...return TRUE in this case.
            //
            if (lppi->pDevMode) {
                //
                // Set the new devmode pointer.  We will be appending our
                // DEVMODE (from the file) to the PRINTER_INFO_2 structure
                // that we have just grabbed.  Reset the pointers to
                // reflect the new-position of the DEVMODE.
                //
                lppi->pDevMode = (LPDEVMODEW)(((LPBYTE)lppi) + cbSize);
                lpdm           = lppi->pDevMode;

                //
                // Copy our new devmode to the printer-info struct.
                // This is appended on to the structure.
                //
                // Since this data was obtained by file, the pointer
                // is actually a byte offset.
                //
                CopyMemory(lpdm,
                           ((LPBYTE)lpdbi) + lpdbi->pData,
                           lpdbi->cbData);

                //
                // Copy the new printer-name to the DEVMODE.  Since our
                // routines deal strictly with unicode, we need to do
                // the correct conversion in case this library was built
                // as ansi.
                //
#ifdef UNICODE

                StringCchCopy(lpdm->dmDeviceName, CCHDEVICENAME, lpszPrtName);
#else
                lpdm->dmDeviceName[CCHDEVICENAME - 1] = (WCHAR)0;

                web_MBtoWC(lpdm->dmDeviceName,
                           lpszPrtName,
                           sizeof(lpdm->dmDeviceName) - sizeof(WCHAR));
#endif
                //
                // Write out our new printer-settings.
                //
                bRet = SetPrinterW(hPrinter, 2, (LPBYTE)lppi, 0);

            } else {

                bRet = TRUE;
            }
        }

        web_GFree(lppi);
    }

    return bRet;
}


/*****************************************************************************\
* web_ReadDevData (Local Routine)
*
* Reads the device-configuration-data from the BIN-File and sets the
* printer with the information.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_ReadDevData(
    LPDEVBIN_HEAD lpdbh,
    HANDLE        hPrinter)
{
    LPDEVBIN_INFO lpdbi;
    LPWSTR        lpszKey;
    LPWSTR        lpszVal;
    LPBYTE        lpbData;
    DWORD         idx;
    DWORD         dwRet;
    BOOL          bRet;

    PWSTR         lpszNewKey = NULL;
    PWSTR         lpszNewVal = NULL;
    PBYTE         lpbNewData = NULL;

    //
    // Set our pointer past the header.  The DEVMODE always occupies the
    // first entry (If a DEVMODE exists).
    //
    lpdbi = (LPDEVBIN_INFO)(lpdbh + 1);

    //
    // If there's a DEVMODE, skip over it and point to the Printer-Data
    // entries.
    //
    if (lpdbh->bDevMode)
        lpdbi = web_NextItem(lpdbi);

    //
    // Loop through our items and set the data to the registry.
    //
    for (idx = 0, bRet = TRUE; (idx < lpdbh->cItems) && bRet; idx++) {
        //
        // Remarshall the byte-offsets into pointers.
        //
        lpszKey = (LPWSTR)(((LPBYTE)lpdbi) + lpdbi->pKey);
        lpszVal = (LPWSTR)(((LPBYTE)lpdbi) + lpdbi->pValue);
        lpbData = (LPBYTE)(((LPBYTE)lpdbi) + lpdbi->pData);

        //
        //  We have to copy the data into a new buffer to avoid 64 bit mis-alignment.
        //
        lpszNewKey = new WCHAR[(lpdbi->pValue - lpdbi->pKey) / sizeof (WCHAR)];
        lpszNewVal = new WCHAR[(lpdbi->pData - lpdbi->pValue) / sizeof (WCHAR)];
        lpbNewData = new BYTE[lpdbi->cbData];

        if (!lpszNewKey || !lpszVal || !lpbData)
        {
            bRet = FALSE;
        }
        else
        {
            CopyMemory (lpszNewKey, lpszKey, lpdbi->pValue - lpdbi->pKey);
            CopyMemory (lpszNewVal, lpszVal, lpdbi->pData - lpdbi->pValue);
            CopyMemory (lpbNewData, lpbData, lpdbi->cbData);
        }

        if (bRet)
        {
            //
            // Set the printer-data.  Since our file-format
            // deals with UNICODE-strings, we will use the
            // Wide-API.
            //
            dwRet = SetPrinterDataExW(hPrinter,
                                      lpszNewKey,
                                      lpszNewVal,
                                      lpdbi->dwType,
                                      lpbNewData,
                                      lpdbi->cbData);
            //
            // If the data is set-correctly, then continue on
            // to the next-item.  Otherwise, set us up to return
            // false.
            //
            if (dwRet == ERROR_SUCCESS) {

                lpdbi = web_NextItem(lpdbi);

            } else {

                bRet = FALSE;
            }
        }

        if (lpszNewKey)
        {
            delete [] lpszNewKey;
            lpszNewKey = NULL;
        }

        if (lpszNewVal)
        {
            delete [] lpszNewVal;
            lpszNewVal = NULL;
        }

        if (lpbNewData)
        {
            delete [] lpbNewData;
            lpbNewData = NULL;
        }

    }

    //
    // Once the registry is initialized with the printer-data, we need
    // to parse the printer-data-registry for the ICM (CopyFiles), to
    // initialize ICM profiles.
    //
    if (bRet && web_KeyExistsW(hPrinter, s_wszCopyFiles))
        bRet = web_TraverseCopyFilesW(hPrinter, NULL, s_wszCopyFiles);

    return bRet;
}


/*****************************************************************************\
* web_WriteDevMode (Local Routine)
*
* Output the DEVMODEW struct to the BIN-File.  Since we are storing this
* to a file, we make sure that our format is consistent across various
* processes.  Our choice is to use UNICODE API as a means to query and store
* the DEVMODE information.
*
\*****************************************************************************/
BOOL web_WriteDevMode(
    HANDLE hFile,
    HANDLE hPrinter,
    LPBOOL lpbDevMode)
{
    DWORD             cbSize;
    DWORD             cbNeed;
    DWORD             cbDevMode;
    DWORD             dwWr;
    LPDEVBIN_INFO     lpdbi;
    LPPRINTER_INFO_2W lppi;
    BOOL              bRet = FALSE;

    //
    // Set the default return for a devmode.
    //
    *lpbDevMode = FALSE;

    //
    // Retrieve the size to store the printer-info-2 struct.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);

    //
    // Allocate the printer-info-2 struct and proceed
    // to pull out the devmode information.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize))) {
        //
        // Retreive the printer-info-2 and write out the
        // DEVMODEW part of this structure.
        //
        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {
            //
            // Allocate space for the devmode and our header information.
            // Align this on DWORD boundries.
            //
            if (lppi->pDevMode) {
                //
                // The DEVMODE will need to include driver-specific
                // information if such is stored in this DEVMODE.
                //
                cbDevMode = lppi->pDevMode->dmSize +
                            lppi->pDevMode->dmDriverExtra;

                //
                // Calculate the DWORD aligned size that we will need
                // to store our DEVMODE information to file.
                //
                cbSize = web_AlignSize(sizeof(DEVBIN_INFO) + cbDevMode);

                //
                // Get the DEVMODE from the PRINTER_INFO_2 struct. and
                // write to file.  We want to take care to
                //
                if (lpdbi = (LPDEVBIN_INFO)web_GAlloc(cbSize)) {
                    //
                    // Setup our memory-block.  The DEVMODEW will
                    // occupy the first item in the array.  Since
                    // it's not associated with printer-data-information,
                    // we will not store any (NAME and TYPE).
                    //
                    // Since this structure will inevitably be written
                    // to file, we must marshall the pointers and store
                    // only byte-offsets.
                    //
                    lpdbi->cbSize  = cbSize;
                    lpdbi->dwType  = 0;
                    lpdbi->pKey    = 0;
                    lpdbi->pValue  = 0;
                    lpdbi->pData   = sizeof(DEVBIN_INFO);
                    lpdbi->cbData  = cbDevMode;

                    CopyMemory(((LPBYTE)lpdbi) + lpdbi->pData,
                               lppi->pDevMode,
                               cbDevMode);

                    //
                    // Write the information to file.  Check the return
                    // to verify bytes were written correctly.
                    //
                    bRet = WriteFile(hFile, lpdbi, cbSize, &dwWr, NULL);

                    if (bRet && (dwWr != cbSize))
                        bRet = FALSE;

                    //
                    // Indicate that a devmode was written.
                    //
                    *lpbDevMode = TRUE;


                    web_GFree(lpdbi);
                }

            } else {

                bRet        = TRUE;
                *lpbDevMode = FALSE;
            }
        }

        web_GFree(lppi);
    }

    return bRet;
}


/*****************************************************************************\
* web_WriteKeyItem (Local Routine)
*
* Writes one item to the file.
*
\*****************************************************************************/
BOOL web_WriteKeyItem(
    HANDLE                hFile,
    LPCWSTR               lpszKey,
    LPPRINTER_ENUM_VALUES lpPEV)
{
    DWORD         cbKeySize;
    DWORD         cbKey;
    DWORD         cbName;
    DWORD         cbSize;
    DWORD         dwWr;
    LPDEVBIN_INFO lpdbi;
    BOOL          bWrite = FALSE;

    //
    // Calculate aligned sizes for the key-name and key-value strings.
    //
    cbKeySize = web_StrSizeW(lpszKey);
    cbKey     = web_AlignSize(cbKeySize);
    cbName    = web_AlignSize(lpPEV->cbValueName);

    //
    // Calculate size necessary to hold our DEVBIN_INFO information
    // which is written to file.
    //
    cbSize = sizeof(DEVBIN_INFO) + cbKey + cbName + web_AlignSize (lpPEV->cbData);

    //
    // Allocate space for the structure.
    //
    if (lpdbi = (LPDEVBIN_INFO)web_GAlloc(cbSize)) {
        //
        // Initialize the structure elements.  Since this information
        // is written to file, we must take care to convert the
        // pointers to byte-offsets.
        //
        lpdbi->cbSize  = cbSize;
        lpdbi->dwType  = lpPEV->dwType;
        lpdbi->pKey    = sizeof(DEVBIN_INFO);
        lpdbi->pValue  = lpdbi->pKey + cbKey;
        lpdbi->pData   = lpdbi->pValue + cbName;
        lpdbi->cbData  = lpPEV->cbData;

        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pKey  , lpszKey          , cbKeySize);
        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pValue, lpPEV->pValueName, lpPEV->cbValueName);
        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pData , lpPEV->pData     , lpPEV->cbData);

        bWrite = WriteFile(hFile, lpdbi, lpdbi->cbSize, &dwWr, NULL);

        if (bWrite && (dwWr != lpdbi->cbSize))
            bWrite = FALSE;

        web_GFree(lpdbi);
    }

    return bWrite;
}


/*****************************************************************************\
* web_WriteKeyData (Local Routine)
*
* Outputs the Printer-Configuration-Data to the BIN-File.  This writes
* all info for the specified key.
*
* returns: number of items written to file.
*          (-1) if an error occurs.
*
\*****************************************************************************/
int web_WriteKeyData(
    HANDLE  hFile,
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    LPPRINTER_ENUM_VALUES apevData;
    BOOL                  bWr;
    int                   idx;
    int                   nItems = -1;

    //
    // Only write data if we are given a valid-key.
    //
    if ((lpszKey == NULL) || (*lpszKey == (WCHAR)0))
        return 0;

    //
    // Enumerate all data for the specified key and write to the file.
    //
    if (apevData = web_EnumPrinterDataW(hPrinter, lpszKey, (LPDWORD)&nItems)) {
        //
        // Write all the values for this key.
        //
        for (idx = 0, bWr = TRUE; (idx < nItems) && bWr; idx++)
            bWr = web_WriteKeyItem(hFile, lpszKey, apevData + idx);

        if (bWr == FALSE)
            nItems = -1;

        web_GFree(apevData);
    }

    return nItems;
}


/*****************************************************************************\
* web_WriteDevData (Local Routine)
*
* Recursively traverses the printer registry and writes out the settings
* to file.
*
\*****************************************************************************/
BOOL web_WriteDevData(
    HANDLE  hFile,
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPDWORD lpcItems)
{
    LPWSTR aszSKeys;
    LPWSTR lpszSKey;
    LPWSTR lpszFKey;
    DWORD  dwRet;
    INT    cItems;
    BOOL   bRet = FALSE;


    if (aszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpszKey)) {

        for (bRet = TRUE, lpszSKey = aszSKeys; *lpszSKey && bRet; ) {

            if (lpszFKey = web_MakeFullKeyW(lpszKey, lpszSKey)) {

                bRet = web_WriteDevData(hFile, hPrinter, lpszFKey, lpcItems);

                web_GFree(lpszFKey);
            }

            lpszSKey = web_NextStrW(lpszSKey);
        }

        //
        // Free up the array.
        //
        web_GFree(aszSKeys);

        //
        // Write the keys/values to the file.
        //
        if (bRet) {

            cItems = web_WriteKeyData(hFile, hPrinter, lpszKey);

            if (cItems >= 0)
                *lpcItems += cItems;
            else
                bRet = FALSE;
        }
    }

    return bRet;
}

/*****************************************************************************\
* web_ICMEnumCallBack (Local Routine)
*
* This routine takes the UNICODE (lpwszDir, lpwszFile) and converts it to
* the appropriate string prior to making the callback to the caller.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_ICMEnumCallBack(
    LPCWSTR lpwszDir,
    LPCWSTR lpwszFile,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPTSTR lpszDir;
    LPTSTR lpszFile;
    BOOL   bRet = FALSE;


    if (lpszDir = web_WCtoTC(lpwszDir, lstrlenW(lpwszDir) + 1)) {

        if (lpszFile = web_WCtoTC(lpwszFile, lstrlenW(lpwszFile) + 1)) {

            bRet = (*(WEBENUMICMPROC)fpEnum)(lpszDir, lpszFile, lpParm);

            web_GFree(lpszFile);
        }

        web_GFree(lpszDir);
    }

    return bRet;
}


/*****************************************************************************\
* web_EnumFilesW (Local Routine)
*
* This routine enums the point & print "files" under the "copyfiles" path
* for the printer.  This is called once we're at the end of a sub-key list
* in the registry.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_EnumFilesW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPWSTR awszFiles;
    LPWSTR lpwszFile;
    LPWSTR lpwszDir;
    BOOL   bRet = FALSE;

    //
    // For this ICM key, we will grab the list of ICM profiles that are
    // necessary.
    //
    if (awszFiles = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszFil)) {
        //
        // Get the src-directory for the ICM profiles under the given key.
        //
        if (lpwszDir = web_BuildCopyDirW(hPrinter, dwCliInfo, lpwszKey)) {

            for (bRet = TRUE, lpwszFile = awszFiles; *lpwszFile && bRet; ) {
                //
                // Make the callback to the caller.  In order to do this,
                // we must make sure our strings are in the appropriate
                // format according to what the caller expects (ie. unicode
                // or ansi).
                //
                bRet = web_ICMEnumCallBack(lpwszDir, lpwszFile, fpEnum, lpParm);

                lpwszFile = web_NextStrW(lpwszFile);
            }

            web_GFree(lpwszDir);
        }

        web_GFree(awszFiles);
    }

    return bRet;
}


/*****************************************************************************\
* web_EnumCopyFilesW (similar to TraverseCopyFiles) (Local Routine)
*
* This routine recursively traverses the printer-registry-settings for
* the CopyFiles keys.  Since the API's used in this routine are only
* available in UNICODE, this should be a (W) type routine.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_EnumCopyFilesW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPWSTR awszSKeys;
    LPWSTR lpwszSKey;
    LPWSTR lpwszFKey;
    DWORD  dwType;
    BOOL   bRet = FALSE;

    //
    // Returns an array of keys stored under the printer registry.
    //
    if (awszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpwszKey)) {
        //
        // For each key, look to see if it contains other sub-keys.  We
        // recursively traverse the registry until we hit a key with
        // no sub-keys.
        //
        for (bRet = TRUE, lpwszSKey = awszSKeys; *lpwszSKey && bRet; ) {

            bRet = FALSE;
            //
            // Since the enum-routine only returns relative key-values,
            // we need to build the fully-qualified key-path.
            //
            if (lpwszFKey = web_MakeFullKeyW(lpwszKey, lpwszSKey)) {

                bRet = web_EnumCopyFilesW(hPrinter,
                                          dwCliInfo,
                                          lpwszFKey,
                                          fpEnum,
                                          lpParm);

                web_GFree(lpwszFKey);
            }
        
            //
            // Next key in list.
            //
            lpwszSKey = web_NextStrW(lpwszSKey);
        }

        //
        // Free up the array.
        //
        web_GFree(awszSKeys);

        //
        // Process the files for the specified key.  If this
        // is our top-level key (CopyFiles), then don't bother
        // with the initialization.  i.e. there should be no
        // (module, files, directory) keys at this level.
        //
        if (bRet && lstrcmpiW(lpwszKey, s_wszCopyFiles))
            bRet = web_EnumFilesW(hPrinter, dwCliInfo, lpwszKey, fpEnum, lpParm);
    }

    return bRet;
}


/*****************************************************************************\
* webEnumPrinterInfo
*
* This routine enumerates the information stored in the registery.  Depending
* upon the (dwType) passed in, it can enumerate different types of information.
*
* Use : Called from the Printer-Server to enumerate the copyfiles sections
*       of the registry.  This also provides a callback to allow the caller
*       to trap the profiles so they may be added to the CAB list.
*
* Use : Called from the printer-server to enumerate ICM information.
*
\*****************************************************************************/
BOOL webEnumPrinterInfo(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    DWORD   dwType,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    BOOL bEnum = TRUE;

    //
    // Call enumeration functions for various enumeration types.
    //
    switch (dwType) {

    case WEB_ENUM_ICM:
        if (web_KeyExistsW(hPrinter, s_wszCopyFiles))
            bEnum = web_EnumCopyFilesW(hPrinter, dwCliInfo, s_wszCopyFiles, fpEnum, lpParm);
        break;

    default:
    case WEB_ENUM_KEY:  // NOT IMPLEMENTED
        bEnum = FALSE;
    }

    return bEnum;
}


/*****************************************************************************\
* webWritePrinterInfo
*
* This routine reads the DEVMODE and Configuration-Data from the specified
* printer, and writes this to a .BIN file.
*
* Use : Called from the printer-server to write the registry settings to file.
*
\*****************************************************************************/
BOOL webWritePrinterInfo(
    HANDLE  hPrinter,
    LPCTSTR lpszBinFile)
{
    HANDLE hFile;
    BOOL   bDevMode;
    DWORD  cItems;
    BOOL   bRet = FALSE;

    //
    // Open the BIN file for writing.
    //
    hFile = web_OpenFileWrite(lpszBinFile);

    if (hFile && (hFile != INVALID_HANDLE_VALUE)) {
        //
        // Output the header.  This basically reserves
        // space at the beginning of the file to store
        // the item-count.
        //
        if (web_WriteHeader(hFile, 0, FALSE)) {
            //
            // Write out the devmode-info.
            //
            if (web_WriteDevMode(hFile, hPrinter, &bDevMode)) {
                //
                // Write out devdata-info.  The (cItems) indicates how
                // many driver-specific entries were written.
                //
                cItems = 0;
                if (web_WriteDevData(hFile, hPrinter, L"", &cItems))
                    bRet = web_WriteHeader(hFile, cItems, bDevMode);
            }
        }

        CloseHandle(hFile);
    }

    return bRet;
}


/*****************************************************************************\
* webReadPrinterInfo
*
* This routine reads the DEVMODE and Configuration-Data from the specified
* BIN-File, and sets the printer-handle with the attributes.
*
* Use : Called from the printer-client to initialize the registry.
*
\*****************************************************************************/
BOOL webReadPrinterInfo(
    HANDLE  hPrinter,
    LPCTSTR lpszPrtName,
    LPCTSTR lpszBinFile)
{
    HANDLE        hMap;
    LPDEVBIN_HEAD lpdbh;
    BOOL          bRet = FALSE;

    //
    // Open the BIN file for writing.
    //
    if (hMap = web_OpenMap(lpszBinFile)) {

        if (lpdbh = (LPDEVBIN_HEAD)web_LockMap(hMap)) {
            //
            // Only if we have a DevMode should we write out the information.
            //
            if (!lpdbh->bDevMode || web_ReadDevMode(lpdbh, hPrinter, lpszPrtName)) {
                //
                // Only if we have printer-data items should we proceed
                // to write out the information.
                //
                if (!lpdbh->cItems || web_ReadDevData(lpdbh, hPrinter)) {

                    bRet = TRUE;
                }
            }

            web_UnlockMap((LPVOID)lpdbh);
        }

        web_CloseMap(hMap);
    }

    return bRet;
}


/*****************************************************************************\
* WebPnpEntry
*
* This routine is called by PrintWizard prior to installing the printer.
* Currently, we can find no value to this, but it is a nice balance to the
* WebPnpPostEntry() routine.
*
* Use : Called from the print-client prior to printer installation.
*
\*****************************************************************************/
BOOL WebPnpEntry(
    LPCTSTR lpszCmdLine)
{
    return TRUE;
}


BOOL
PrinterExists(
    HANDLE hPrinter)
{
    DWORD            cbNeeded;
    DWORD            Error;
    BOOL             rc = FALSE;
    LPPRINTER_INFO_2 pPrinter;
    DWORD            cbPrinter;

    cbPrinter = 0x400;
    pPrinter = (PPRINTER_INFO_2) web_GAlloc ( cbPrinter );

    if( !pPrinter )
        return FALSE;

    if( !GetPrinter( hPrinter, 2, (LPBYTE)pPrinter, cbPrinter, &cbNeeded ) )
    {
        Error = GetLastError( );

        if( Error == ERROR_INSUFFICIENT_BUFFER )
        {
            web_GFree (pPrinter);
            pPrinter = (PPRINTER_INFO_2)web_GAlloc ( cbNeeded );

            if( pPrinter )
            {
                cbPrinter = cbNeeded;

                if( GetPrinter( hPrinter, 2, (LPBYTE)pPrinter, cbPrinter, &cbNeeded ) )
                {
                    rc = TRUE;
                }
            }
        }
        else if( Error == ERROR_INVALID_HANDLE )
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }
    }
    else
    {
        rc = TRUE;
    }


    if( pPrinter )
    {
        web_GFree ( pPrinter );
    }

    return rc;
}


/*****************************************************************************\
* WebPnpPostEntry
*
* This routine is called via PrintWizard after a printer has been added.  This
* provides the oportunity for the web-pnp-installer to initialize the
* registry settings and files according to the information provided in the
* BIN-File.  The (fConnection) flag indicates whether the printer was
* installed via RPC or HTTP.  If it was RPC, then it's not necessary to do
* any printer-settings.
*
* Use : Called from the print-client after printer installation.
*
\*****************************************************************************/
BOOL WebPnpPostEntry(
    BOOL    fConnection,
    LPCTSTR lpszBinFile,
    LPCTSTR lpszPortName,
    LPCTSTR lpszPrtName)
{
    HANDLE           hPrinter;
    PRINTER_DEFAULTS pd;
    BOOL             bRet = TRUE;


    if (fConnection == FALSE) {
        //
        // Setup the printer-defaults to
        // allow printer-changes.
        //
        pd.pDatatype     = NULL;
        pd.pDevMode      = NULL;
        pd.DesiredAccess = PRINTER_ALL_ACCESS;

        //
        // Open the printer specified.
        //
        if (OpenPrinter((LPTSTR)lpszPrtName, &hPrinter, &pd)) {

            if (!PrinterExists(hPrinter) && GetLastError () == ERROR_ACCESS_DENIED) {
                ConfigurePort( NULL, GetDesktopWindow (), (LPTSTR) lpszPortName);
            }

            bRet = webReadPrinterInfo(hPrinter, lpszPrtName, lpszBinFile);

            ClosePrinter(hPrinter);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\webpnp.h ===
/*****************************************************************************\
* MODULE: webpnp.h
*
* This is the header module for webpnp.c.  This contains the routines
* necessary for processing .BIN files.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   25-Feb-1997 <chriswil> created.
*
\*****************************************************************************/
#ifndef _WEBPNP_H
#define _WEBPNP_H

#ifndef _WINSPOOL_
#include <winspool.h>
#endif


/*-----------------------------------*\
| webMakeOSInfo
|
|   Returns OSInfo from parameters.
|
\*-----------------------------------*/
_inline DWORD webMakeOSInfo(
    BYTE bArch,
    BYTE bPlatform,
    BYTE bMajVer,
    BYTE bMinVer)
{
    return (DWORD)MAKELONG(MAKEWORD(bArch, bPlatform), MAKEWORD(bMinVer, bMajVer));
}


/*-----------------------------------*\
| webCreateOSInfo
|
|   Builds an OS Info DWORD.
|
\*-----------------------------------*/
_inline DWORD webCreateOSInfo(VOID)
{
    SYSTEM_INFO   si;
    OSVERSIONINFO os;
    BYTE          bMaj;
    BYTE          bMin;
    BYTE          bArch;
    BYTE          bPlat;
    
    //
    // Retrieve the OS version and architecture
    // information.
    //
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetSystemInfo(&si);
    GetVersionEx(&os);

    //
    // Build our client-info return values.
    //
    bMaj  = (BYTE)(LOWORD(os.dwMajorVersion));
    bMin  = (BYTE)(LOWORD(os.dwMinorVersion));
    bPlat = (BYTE)(LOWORD(os.dwPlatformId));
    bArch = (BYTE)(LOBYTE(si.wProcessorArchitecture));

    return webMakeOSInfo(bArch, bPlat, bMaj, bMin);
}


/*-----------------------------------*\
| webGetOSArch
|
|   Returns architecture of os-info.
|
\*-----------------------------------*/
_inline WORD webGetOSArch(
    DWORD dwInfo)
{
    return (WORD)LOBYTE(LOWORD(dwInfo));
}


/*-----------------------------------*\
| webGetOSPlatform
|
|   Returns platform of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSPlatform(
    DWORD dwInfo)
{
    return (DWORD)HIBYTE(LOWORD(dwInfo));
}


/*-----------------------------------*\
| webGetOSMajorVer
|
|   Returns major version of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSMajorVer(
    DWORD dwInfo)
{
    return (DWORD)(HIBYTE(HIWORD(dwInfo)));
}


/*-----------------------------------*\
| webGetOSMinorVer
|
|   Returns minor version of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSMinorVer(
    DWORD dwInfo)
{
    return (DWORD)(LOBYTE(HIWORD(dwInfo)));
}


#ifdef __cplusplus  // Place this here to prevent decorating of symbols
extern "C" {        // when doing C++ stuff.
#endif              //

//
// WEB_FILEMAP
//
typedef struct _WEB_FILEMAP {

    HANDLE hFile;
    HANDLE hMap;

} WEB_FILEMAP;
typedef WEB_FILEMAP      *PWEB_FILEMAP;
typedef WEB_FILEMAP NEAR *NPWEB_FILEMAP;
typedef WEB_FILEMAP FAR  *LPWEB_FILEMAP;

//
// Device-Bin Header Structure.
//
typedef struct _DEVBIN_HEAD {

    BOOL  bDevMode;
    DWORD cItems;

} DEVBIN_HEAD;
typedef DEVBIN_HEAD      *PDEVBIN_HEAD;
typedef DEVBIN_HEAD NEAR *NPDEVBIN_HEAD;
typedef DEVBIN_HEAD FAR  *LPDEVBIN_HEAD;

//
// Device-Bin Structure.
//
typedef struct _DEVBIN_INFO {

    DWORD cbSize;
    DWORD dwType;
    DWORD pKey;
    DWORD pValue;
    DWORD pData;
    DWORD cbData;

} DEVBIN_INFO;
typedef DEVBIN_INFO      *PDEVBIN_INFO;
typedef DEVBIN_INFO NEAR *NPDEVBIN_INFO;
typedef DEVBIN_INFO FAR  *LPDEVBIN_INFO;

//
// BIN-Routines.
//
#define WEB_ENUM_KEY  0
#define WEB_ENUM_ICM  1

typedef BOOL (CALLBACK* WEBENUMKEYPROC)(LPCTSTR, LPVOID);
typedef BOOL (CALLBACK* WEBENUMICMPROC)(LPCTSTR, LPCTSTR, LPVOID);
typedef BOOL (CALLBACK* WEBGENCOPYFILEPATHPROC)(LPCWSTR, LPCWSTR, LPBYTE, DWORD, LPWSTR, LPDWORD, LPWSTR, LPDWORD, DWORD);

BOOL webWritePrinterInfo(HANDLE, LPCTSTR);
BOOL webReadPrinterInfo(HANDLE, LPCTSTR, LPCTSTR);
BOOL webEnumPrinterInfo(HANDLE, DWORD, DWORD, FARPROC, LPVOID);

//
// SplLib Exports.
//
BOOL WebPnpEntry(LPCTSTR);
BOOL WebPnpPostEntry(BOOL, LPCTSTR, LPCTSTR, LPCTSTR);


#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif              //
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\webipp.cxx ===
/*****************************************************************************\
* MODULE: webipp.cxx
*
* This module contains routines which handle the encoding/decoding of data
* sent across the HTTP wire to represent IPP packets.
*
* Public Interfaces
* -----------------
* WebIppRcvOpen    : returns a handle to an ipp-request stream
* WebIppRcvClose   : closes the handle to the ipp-request stream
* WebIppRcvData    : converts (Ipp -> W32)
* WebIppSndData    : converts (W32 -> Ipp)
* WebIppGetError   : returns ipp-error if WebIppSndData/WebIppRcvData fails
* WebIppLeToRsp    : returns an ipp-error mapping for a win32 error
* WebIppGetReqId   : returns the request-id for the ipp-stream
* WebIppGetUnsAttr : returns object with unsupported attribute strings
* WebIppGetReqFlag : returns a flag of requested-attributes from ipp-stream
* WebIppGetReqCp   : returns codepage that ipp-stream requests
* WebIppFreeMem    : used to free pointers returned from WebIpp* routines
*
* Definintions:
* ------------
* Ipp - Denotes Ipp-Formatted information according to the IPP protocol.
* W32 - Denotes win32 data that NT-Spooler understands.
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* history:
*   27-Oct-1997 <chriswil/v-chrisw> created.
*
\*****************************************************************************/

#include "spllibp.hxx"
#include <time.h>
#include <sys\timeb.h>
#include <wininet.h>
#include <winsock.h>

/*****************************************************************************\
* Static Strings
*
\*****************************************************************************/
static CONST TCHAR s_szJobLimit          [] = TEXT("limit");
static CONST TCHAR s_szJobName           [] = TEXT("job-name");
static CONST TCHAR s_szJobReqUser        [] = TEXT("requesting-user-name");
static CONST TCHAR s_szJobOrgUser        [] = TEXT("job-originating-user-name");
static CONST TCHAR s_szDocName           [] = TEXT("document-name");
static CONST TCHAR s_szJobId             [] = TEXT("job-id");
static CONST TCHAR s_szJobUri            [] = TEXT("job-uri");
static CONST TCHAR s_szJobState          [] = TEXT("job-state");
static CONST TCHAR s_szJobPri            [] = TEXT("job-priority");
static CONST TCHAR s_szJobKOctets        [] = TEXT("job-k-octets");
static CONST TCHAR s_szJobKOctetsProcess [] = TEXT("job-k-octets-processed");
static CONST TCHAR s_szJobSheets         [] = TEXT("job-media-sheets");
static CONST TCHAR s_szJobPrtUri         [] = TEXT("job-printer-uri");
static CONST TCHAR s_szTimeAtCreation    [] = TEXT("time-at-creation");
static CONST TCHAR s_szJobSheetsCompleted[] = TEXT("job-media-sheets-completed");
static CONST TCHAR s_szPrtUri            [] = TEXT("printer-uri");
static CONST TCHAR s_szPrtUriSupported   [] = TEXT("printer-uri-supported");
static CONST TCHAR s_szPrtUriSecurity    [] = TEXT("uri-security-supported");
static CONST TCHAR s_szPrtSecNone        [] = TEXT("none");
static CONST TCHAR s_szPrtOpsSupported   [] = TEXT("operations-supported");
static CONST TCHAR s_szPrtName           [] = TEXT("printer-name");
static CONST TCHAR s_szPrtState          [] = TEXT("printer-state");
static CONST TCHAR s_szPrtJobs           [] = TEXT("queued-job-count");
static CONST TCHAR s_szPrtMake           [] = TEXT("printer-make-and-model");
static CONST TCHAR s_szPrtAcceptingJobs  [] = TEXT("printer-is-accepting-jobs");
static CONST TCHAR s_szPrtUpTime         [] = TEXT("printer-up-time");
static CONST TCHAR s_szCharSetSupported  [] = TEXT("charset-supported");
static CONST TCHAR s_szCharSetConfigured [] = TEXT("charset-configured");
static CONST TCHAR s_szNatLangConfigured [] = TEXT("natural-language-configured");
static CONST TCHAR s_szNatLangSupported  [] = TEXT("generated-natural-language-supported");
static CONST TCHAR s_szUnknown           [] = TEXT("unknown");
static CONST TCHAR s_szWhichJobs         [] = TEXT("which-jobs");
static CONST TCHAR s_szCharSet           [] = TEXT("attributes-charset");
static CONST TCHAR s_szNaturalLanguage   [] = TEXT("attributes-natural-language");
static CONST TCHAR s_szReqAttr           [] = TEXT("requested-attributes");
static CONST TCHAR s_szUtf8              [] = TEXT("utf-8");
static CONST TCHAR s_szUsAscii           [] = TEXT("us-ascii");
static CONST TCHAR s_szEnUS              [] = TEXT("en-us");
static CONST TCHAR s_szDocFormatDefault  [] = TEXT("document-format-default");
static CONST TCHAR s_szDocFormatSupported[] = TEXT("document-format-supported");
static CONST TCHAR s_szStaMsg            [] = TEXT("status-message");
static CONST TCHAR s_szPdlOverride       [] = TEXT("pdl-override-supported");
static CONST TCHAR s_szNotAttempted      [] = TEXT("not-attempted");
static CONST TCHAR s_szDocFormat         [] = TEXT("document-format");
static CONST TCHAR s_szCompleted         [] = TEXT("completed");
static CONST TCHAR s_szNotCompleted      [] = TEXT("not-completed");
static CONST TCHAR s_szMimeTxtHtml       [] = TEXT("text/html");
static CONST TCHAR s_szMimeTxtPlain      [] = TEXT("text/plain");
static CONST TCHAR s_szMimePostScript    [] = TEXT("application/postscript");
static CONST TCHAR s_szMimePCL           [] = TEXT("application/vnd.hppcl");
static CONST TCHAR s_szMimeOctStream     [] = TEXT("application/octet-stream");
static CONST TCHAR s_szAll               [] = TEXT("all");
static CONST TCHAR s_szJobTemplate       [] = TEXT("job-template");
static CONST TCHAR s_szJobDescription    [] = TEXT("job-description");
static CONST TCHAR s_szPrtDescription    [] = TEXT("printer-description");
static CONST TCHAR s_szUnsupported       [] = TEXT("unsupported");
static CONST TCHAR s_szAtrFidelity       [] = TEXT("ipp-attribute-fidelity");
static CONST TCHAR s_szTrue              [] = TEXT("true");
static CONST TCHAR s_szFalse             [] = TEXT("false");

/*****************************************************************************\
* Ipp Error-Mapping
*
* These tables define the mappings for Win32 LastErrors and Ipp-http errors.
*
\*****************************************************************************/
static IPPERROR s_LEIpp[] = {

    IPPRSP_ERROR_400, ERROR_INVALID_DATA          , TEXT("Client: (400) BadRequest")                   ,
    IPPRSP_ERROR_401, ERROR_ACCESS_DENIED         , TEXT("Client: (401) Forbidden Access")             ,
    IPPRSP_ERROR_402, ERROR_ACCESS_DENIED         , TEXT("Client: (402) Not Authenticated")            ,
    IPPRSP_ERROR_403, ERROR_ACCESS_DENIED         , TEXT("Client: (403) Not Authorized")               ,
    IPPRSP_ERROR_404, ERROR_INVALID_DATA          , TEXT("Client: (404) Not Possible")                 ,
    IPPRSP_ERROR_405, ERROR_TIMEOUT               , TEXT("Client: (405) Time Out")                     ,
    IPPRSP_ERROR_406, ERROR_INVALID_DATA          , TEXT("Client: (406) Not Found")                    ,
    IPPRSP_ERROR_407, ERROR_INVALID_DATA          , TEXT("Client: (407) Gone")                         ,
    IPPRSP_ERROR_408, ERROR_INVALID_DATA          , TEXT("Client: (408) Entity Too Large")             ,
    IPPRSP_ERROR_409, ERROR_INVALID_DATA          , TEXT("Client: (409) Uri Too Long")                 ,
    IPPRSP_ERROR_40A, ERROR_INVALID_DATA          , TEXT("Client: (40A) Document Format Not Supported"),
    IPPRSP_ERROR_40B, ERROR_INVALID_DATA          , TEXT("Client: (40B) Attributes Not Supported")     ,
    IPPRSP_ERROR_40C, ERROR_INVALID_DATA          , TEXT("Client: (40C) Uri Scheme Not Supported")     ,
    IPPRSP_ERROR_40D, ERROR_INVALID_DATA          , TEXT("Client: (40D) Charset Not Supported")        ,
    IPPRSP_ERROR_40E, ERROR_INVALID_DATA          , TEXT("Client: (40E) Conflicting Attributes")       ,
    IPPRSP_ERROR_500, ERROR_INVALID_DATA          , TEXT("Server: (500) Internal Error")               ,
    IPPRSP_ERROR_501, ERROR_INVALID_DATA          , TEXT("Server: (501) Operation Not Supported")      ,
    IPPRSP_ERROR_502, ERROR_NOT_READY             , TEXT("Server: (502) Service Unavailable")          ,
    IPPRSP_ERROR_503, ERROR_INVALID_DATA          , TEXT("Server: (503) Version Not Supported")        ,
    IPPRSP_ERROR_504, ERROR_NOT_READY             , TEXT("Server: (504) Device Error")                 ,
    IPPRSP_ERROR_505, ERROR_OUTOFMEMORY           , TEXT("Server: (505) Temporary Error")              ,
    IPPRSP_ERROR_506, ERROR_INVALID_DATA          , TEXT("Server: (506) Not Accepting Jobs")           ,
    IPPRSP_ERROR_540, ERROR_LICENSE_QUOTA_EXCEEDED, TEXT("Server: (540) Too Many Users")
};

static IPPDEFERROR s_LEDef[] = {

    ERROR_INVALID_DATA          , IPPRSP_ERROR_400,
    ERROR_ACCESS_DENIED         , IPPRSP_ERROR_401,
    ERROR_INVALID_PARAMETER     , IPPRSP_ERROR_404,
    ERROR_TIMEOUT               , IPPRSP_ERROR_405,
    ERROR_NOT_READY             , IPPRSP_ERROR_504,
    ERROR_OUTOFMEMORY           , IPPRSP_ERROR_505,
    ERROR_LICENSE_QUOTA_EXCEEDED, IPPRSP_ERROR_540
};


/*****************************************************************************\
* Request/Response attributes that are written to the ipp-stream.
*
*
\*****************************************************************************/
static IPPATTRX s_PJQ[] = { // PrtJob, ValJob Request

    IPP_TAG_CHR_URI , RA_PRNURI , IPP_ATR_OFFSET  , s_szPrtUri    , (LPVOID)offs(PIPPREQ_PRTJOB, pPrnUri)  ,
    IPP_TAG_CHR_NAME, RA_JOBNAME, IPP_ATR_OFFSET  , s_szJobName   , (LPVOID)offs(PIPPREQ_PRTJOB, pDocument),
    IPP_TAG_CHR_NAME, RA_JOBUSER, IPP_ATR_OFFSET  , s_szJobReqUser, (LPVOID)offs(PIPPREQ_PRTJOB, pUserName),
    IPP_TAG_DEL_JOB , 0         , IPP_ATR_TAG     , NULL          , (LPVOID)NULL
};

static IPPATTRX s_EJQ[] = { // GetJobs Request

    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET  , s_szPrtUri  , (LPVOID)offs(PIPPREQ_ENUJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, RA_JOBCOUNT       , IPP_ATR_OFFSET  , s_szJobLimit, (LPVOID)offs(PIPPREQ_ENUJOB, cJobs)  ,
    IPP_TAG_CHR_KEYWORD, 0                 , IPP_ATR_ABSOLUTE, s_szReqAttr , (LPVOID)s_szAll
};

static IPPATTRX s_SJQ[] = { // PauJob, CanJob, RsmJob, RstJob Request

    IPP_TAG_CHR_URI    , 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_SETJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, 0, IPP_ATR_OFFSET, s_szJobId , (LPVOID)offs(PIPPREQ_SETJOB, idJob)
};


static IPPATTRX s_GJQ[] = { // GetJobAtr Request

    IPP_TAG_CHR_URI    , 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_GETJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, 0, IPP_ATR_OFFSET, s_szJobId , (LPVOID)offs(PIPPREQ_GETJOB, idJob)
};

static IPPATTRX s_SPQ[] = { // PauPrn, CanPrn, RsmPrn, RstPrn Request

    IPP_TAG_CHR_URI , 0, IPP_ATR_OFFSET, s_szPrtUri    , (LPVOID)offs(PIPPREQ_SETPRN, pPrnUri) ,
    IPP_TAG_CHR_NAME, 0, IPP_ATR_OFFSET, s_szJobReqUser, (LPVOID)offs(PIPPREQ_SETPRN, pUserName)
};

static IPPATTRX s_GPQ[] = { // GetPrnAtr Request

    IPP_TAG_CHR_URI, 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_GETPRN, pPrnUri)
};

static IPPATTRX s_PJR[] = { // PrintJob Response

    IPP_TAG_DEL_JOB    , 0                 , IPP_ATR_TAG       , NULL                  , (LPVOID)NULL                                  ,
    IPP_TAG_INT_INTEGER, RA_JOBID          , IPP_ATR_OFFSET    , s_szJobId             , (LPVOID)offs(PIPPRET_JOB, ji.ji2.JobId)       ,
    IPP_TAG_INT_ENUM   , RA_JOBSTATE       , IPP_ATR_OFFSETCONV, s_szJobState          , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBPRIORITY    , IPP_ATR_OFFSET    , s_szJobPri            , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Priority)    ,
    IPP_TAG_INT_INTEGER, RA_JOBSIZE        , IPP_ATR_OFFSETCONV, s_szJobKOctetsProcess , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Size)        ,
    IPP_TAG_INT_INTEGER, RA_SHEETSTOTAL    , IPP_ATR_OFFSET    , s_szJobSheets         , (LPVOID)offs(PIPPRET_JOB, ji.ji2.TotalPages)  ,
    IPP_TAG_INT_INTEGER, RA_SHEETSCOMPLETED, IPP_ATR_OFFSET    , s_szJobSheetsCompleted, (LPVOID)offs(PIPPRET_JOB, ji.ji2.PagesPrinted),
    IPP_TAG_CHR_NAME   , RA_JOBNAME        , IPP_ATR_OFFSET    , s_szJobName           , (LPVOID)offs(PIPPRET_JOB, ji.ji2.pDocument)   ,
    IPP_TAG_CHR_NAME   , RA_JOBUSER        , IPP_ATR_OFFSET    , s_szJobOrgUser        , (LPVOID)offs(PIPPRET_JOB, ji.ji2.pUserName)   ,
    IPP_TAG_CHR_URI    , RA_JOBURI         , IPP_ATR_OFFSET    , s_szJobUri            , (LPVOID)offs(PIPPRET_JOB, ji.ipp.pJobUri)     ,
    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET    , s_szJobPrtUri         , (LPVOID)offs(PIPPRET_JOB, ji.ipp.pPrnUri)
};

static IPPATTRX s_EJR[] = { // GetJobs Response

    IPP_TAG_DEL_JOB    , 0                 , IPP_ATR_TAG   , NULL                  , (LPVOID)NULL                           ,
    IPP_TAG_INT_INTEGER, RA_JOBID          , IPP_ATR_OFFSET, s_szJobId             , (LPVOID)offs(PIPPJI2, ji2.JobId)       ,
    IPP_TAG_INT_ENUM   , RA_JOBSTATE       , IPP_ATR_OFFSET, s_szJobState          , (LPVOID)offs(PIPPJI2, ji2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBPRIORITY    , IPP_ATR_OFFSET, s_szJobPri            , (LPVOID)offs(PIPPJI2, ji2.Priority)    ,
    IPP_TAG_INT_INTEGER, RA_JOBSIZE        , IPP_ATR_OFFSET, s_szJobKOctetsProcess , (LPVOID)offs(PIPPJI2, ji2.Size)        ,
    IPP_TAG_INT_INTEGER, RA_SHEETSTOTAL    , IPP_ATR_OFFSET, s_szJobSheets         , (LPVOID)offs(PIPPJI2, ji2.TotalPages)  ,
    IPP_TAG_INT_INTEGER, RA_SHEETSCOMPLETED, IPP_ATR_OFFSET, s_szJobSheetsCompleted, (LPVOID)offs(PIPPJI2, ji2.PagesPrinted),
    IPP_TAG_INT_INTEGER, RA_TIMEATCREATION , IPP_ATR_OFFSET, s_szTimeAtCreation    , (LPVOID)offs(PIPPJI2, ji2.Submitted)   ,
    IPP_TAG_CHR_NAME   , RA_JOBNAME        , IPP_ATR_OFFSET, s_szJobName           , (LPVOID)offs(PIPPJI2, ji2.pDocument)   ,
    IPP_TAG_CHR_NAME   , RA_JOBUSER        , IPP_ATR_OFFSET, s_szJobOrgUser        , (LPVOID)offs(PIPPJI2, ji2.pUserName)   ,
    IPP_TAG_CHR_URI    , RA_JOBURI         , IPP_ATR_OFFSET, s_szJobUri            , (LPVOID)offs(PIPPJI2, ipp.pJobUri)     ,
    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET, s_szJobPrtUri         , (LPVOID)offs(PIPPJI2, ipp.pPrnUri)
};

static IPPATTRX s_GPR[] = { // GetPrnAtr Response

    IPP_TAG_DEL_PRINTER, 0                  , IPP_ATR_TAG       , NULL                  , (LPVOID)NULL                                  ,
    IPP_TAG_INT_ENUM   , RA_PRNSTATE        , IPP_ATR_OFFSETCONV, s_szPrtState          , (LPVOID)offs(PIPPRET_PRN, pi.pi2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBCOUNT        , IPP_ATR_OFFSET    , s_szPrtJobs           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.cJobs)       ,
    IPP_TAG_CHR_URI    , RA_URISUPPORTED    , IPP_ATR_OFFSET    , s_szPrtUriSupported   , (LPVOID)offs(PIPPRET_PRN, pi.ipp.pPrnUri)     ,
    IPP_TAG_CHR_KEYWORD, RA_URISECURITY     , IPP_ATR_ABSOLUTE  , s_szPrtUriSecurity    , (LPVOID)s_szPrtSecNone                        ,
    IPP_TAG_CHR_NAME   , RA_PRNNAME         , IPP_ATR_OFFSET    , s_szPrtName           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.pPrinterName),
    IPP_TAG_CHR_TEXT   , RA_PRNMAKE         , IPP_ATR_OFFSET    , s_szPrtMake           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.pDriverName) ,
    IPP_TAG_INT_BOOLEAN, RA_ACCEPTINGJOBS   , IPP_ATR_ABSOLUTE  , s_szPrtAcceptingJobs  , (LPVOID)TRUE                                  ,
    IPP_TAG_CHR_CHARSET, RA_CHRSETCONFIGURED, IPP_ATR_ABSOLUTE  , s_szCharSetConfigured , (LPVOID)s_szUtf8                              ,
    IPP_TAG_CHR_CHARSET, RA_CHRSETSUPPORTED , IPP_ATR_ABSOLUTE  , s_szCharSetSupported  , (LPVOID)s_szUtf8                              ,
    IPP_TAG_CHR_CHARSET, 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)s_szUsAscii                           ,
    IPP_TAG_CHR_NATURAL, RA_NATLNGCONFIGURED, IPP_ATR_ABSOLUTE  , s_szNatLangConfigured , (LPVOID)s_szEnUS                              ,
    IPP_TAG_CHR_NATURAL, RA_NATLNGSUPPORTED , IPP_ATR_ABSOLUTE  , s_szNatLangSupported  , (LPVOID)s_szEnUS                              ,
    IPP_TAG_CHR_MEDIA  , RA_DOCDEFAULT      , IPP_ATR_ABSOLUTE  , s_szDocFormatDefault  , (LPVOID)s_szMimeOctStream                     ,
    IPP_TAG_CHR_MEDIA  , RA_DOCSUPPORTED    , IPP_ATR_ABSOLUTE  , s_szDocFormatSupported, (LPVOID)s_szMimeOctStream                     ,
    IPP_TAG_CHR_KEYWORD, RA_PDLOVERRIDE     , IPP_ATR_ABSOLUTE  , s_szPdlOverride       , (LPVOID)s_szNotAttempted                      ,
    IPP_TAG_INT_INTEGER, RA_UPTIME          , IPP_ATR_ABSOLUTE  , s_szPrtUpTime         , (LPVOID)1                                     ,
    IPP_TAG_INT_ENUM   , RA_OPSSUPPORTED    , IPP_ATR_ABSOLUTE  , s_szPrtOpsSupported   , (LPVOID)IPP_REQ_PRINTJOB                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_VALIDATEJOB                   ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_CANCELJOB                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_GETJOB                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_ENUJOB                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_GETPRN                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_PAUSEJOB                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESUMEJOB                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESTARTJOB                    ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_PAUSEPRN                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESUMEPRN                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_CANCELPRN
};


/*****************************************************************************\
* Request/Response string-mappings.
*
*
\*****************************************************************************/
static FLGSTR s_ReqRspStr[] = {

    RA_JOBUSER, s_szJobReqUser,
    RA_JOBSIZE, s_szJobKOctets
};


/*****************************************************************************\
* Receive/Response group forms.
*
* These tables defines the order and layout of ipp group tags.
*
\*****************************************************************************/
static BYTE s_FormA[] = {

    IPP_TAG_DEL_OPERATION | IPP_MANDITORY,
    IPP_TAG_DEL_JOB       | IPP_OPTIONAL,
    IPP_TAG_DEL_DATA      | IPP_MANDITORY,
    0
};

static BYTE s_FormB[] = {

    IPP_TAG_DEL_OPERATION | IPP_MANDITORY,
    IPP_TAG_DEL_DATA      | IPP_MANDITORY,
    0
};

static BYTE s_FormC[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_JOB         | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormD[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_PRINTER     | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormE[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormF[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY              ,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL               ,
    IPP_TAG_DEL_JOB         | IPP_OPTIONAL | IPP_MULTIPLE,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY              ,
    0
};


/*****************************************************************************\
* Structure Offsets
*
*
\*****************************************************************************/
static DWORD s_IPPJI2Offs[] = {

    offs(LPIPPJI2, ji2.pPrinterName),
    offs(LPIPPJI2, ji2.pMachineName),
    offs(LPIPPJI2, ji2.pUserName),
    offs(LPIPPJI2, ji2.pDocument),
    offs(LPIPPJI2, ji2.pNotifyName),
    offs(LPIPPJI2, ji2.pDatatype),
    offs(LPIPPJI2, ji2.pPrintProcessor),
    offs(LPIPPJI2, ji2.pParameters),
    offs(LPIPPJI2, ji2.pDriverName),
    offs(LPIPPJI2, ji2.pDevMode),
    offs(LPIPPJI2, ji2.pStatus),
    offs(LPIPPJI2, ji2.pSecurityDescriptor),
    offs(LPIPPJI2, ipp.pPrnUri),
    offs(LPIPPJI2, ipp.pJobUri),
    0xFFFFFFFF
};

static DWORD s_IPPPI2Offs[] = {

    offs(LPIPPPI2, pi2.pServerName),
    offs(LPIPPPI2, pi2.pPrinterName),
    offs(LPIPPPI2, pi2.pShareName),
    offs(LPIPPPI2, pi2.pPortName),
    offs(LPIPPPI2, pi2.pDriverName),
    offs(LPIPPPI2, pi2.pComment),
    offs(LPIPPPI2, pi2.pLocation),
    offs(LPIPPPI2, pi2.pDevMode),
    offs(LPIPPPI2, pi2.pSepFile),
    offs(LPIPPPI2, pi2.pPrintProcessor),
    offs(LPIPPPI2, pi2.pDatatype),
    offs(LPIPPPI2, pi2.pParameters),
    offs(LPIPPPI2, pi2.pSecurityDescriptor),
    offs(LPIPPPI2, ipp.pPrnUri),
    offs(LPIPPPI2, ipp.pUsrName),
    0xFFFFFFFF
};

static DWORD s_JI2Off[] = {

    offs(LPJOB_INFO_2, pPrinterName),
    offs(LPJOB_INFO_2, pMachineName),
    offs(LPJOB_INFO_2, pUserName),
    offs(LPJOB_INFO_2, pDocument),
    offs(LPJOB_INFO_2, pNotifyName),
    offs(LPJOB_INFO_2, pDatatype),
    offs(LPJOB_INFO_2, pPrintProcessor),
    offs(LPJOB_INFO_2, pParameters),
    offs(LPJOB_INFO_2, pDriverName),
    // Do not include DEVMODE
    offs(LPJOB_INFO_2, pStatus),
    // Do not include SECURITY-DESCRIPTOR
    0xFFFFFFFF
};

static DWORD s_PI2Off[] = {

    offs(LPPRINTER_INFO_2, pServerName),
    offs(LPPRINTER_INFO_2, pPrinterName),
    offs(LPPRINTER_INFO_2, pShareName),
    offs(LPPRINTER_INFO_2, pPortName),
    offs(LPPRINTER_INFO_2, pDriverName),
    offs(LPPRINTER_INFO_2, pComment),
    offs(LPPRINTER_INFO_2, pLocation),
    // Do not include DEVMODE
    offs(LPPRINTER_INFO_2, pSepFile),
    offs(LPPRINTER_INFO_2, pPrintProcessor),
    offs(LPPRINTER_INFO_2, pDatatype),
    offs(LPPRINTER_INFO_2, pParameters),
    // Do not include SECURITY-DESCRIPTOR
    0xFFFFFFFF
};

static DWORD s_IPJOff[] = {

    offs(LPJOB_INFO_IPP, pPrnUri),
    offs(LPJOB_INFO_IPP, pJobUri),
    0xFFFFFFFF
};

static DWORD s_IPPOff[] = {

    offs(LPPRINTER_INFO_IPP, pPrnUri) ,
    offs(LPPRINTER_INFO_IPP, pUsrName),
    0xFFFFFFFF
};


/*****************************************************************************\
* ipp_SetReq (Local Routine)
*
* Sets a bit in the request flag.  If the index (upper 4 bits) is greater
* than 7, then we use this as a special enum flag.
*
\*****************************************************************************/
VOID x_SetReq(
    PDWORD pfReq,
    DWORD  fSet)
{
    DWORD  idz;
    PDWORD pFlg;
    DWORD  cFlg = 0;
    DWORD  idx  = ((fSet >> 28) & 0x0000000F);

    static DWORD s_fReqEnu[] = {

        RA_JOBID,
        RA_JOBURI
    };

    static DWORD s_fJobTmp[] = {

        RA_JOBPRIORITY     ,
        RA_SHEETSTOTAL     ,
        RA_SHEETSCOMPLETED
    };

    static DWORD s_fJobDsc[] = {

        RA_JOBURI          ,
        RA_JOBID           ,
        RA_JOBNAME         ,
        RA_JOBUSER         ,
        RA_JOBSTATE        ,
        RA_JOBSTATE_REASONS,
        RA_JOBSTATE_MESSAGE,
        RA_JOBSIZE
    };

    static DWORD s_fPrtDsc[] = {

        RA_URISUPPORTED    ,
        RA_URISECURITY     ,
        RA_PRNNAME         ,
        RA_PRNMAKE         ,
        RA_PRNSTATE        ,
        RA_OPSSUPPORTED    ,
        RA_CHRSETCONFIGURED,
        RA_CHRSETSUPPORTED ,
        RA_NATLNGCONFIGURED,
        RA_NATLNGSUPPORTED ,
        RA_DOCDEFAULT      ,
        RA_DOCSUPPORTED    ,
        RA_ACCEPTINGJOBS   ,
        RA_JOBCOUNT        ,
        RA_PDLOVERRIDE     ,
        RA_UPTIME
    };


    switch (idx) {

    case IPP_REQALL_IDX:
        pfReq[0] = 0x0FFFFFFF;
        pfReq[1] = 0x0FFFFFFF;
        break;

    case IPP_REQCLEAR_IDX:
        pfReq[0] = 0x00000000;
        pfReq[1] = 0x00000000;
        break;

    case IPP_REQENU_IDX:
        pFlg = s_fReqEnu;
        cFlg = sizeof(s_fReqEnu) / sizeof(s_fReqEnu[0]);
        break;

    case IPP_REQJDSC_IDX:
        pFlg = s_fJobDsc;
        cFlg = sizeof(s_fJobDsc) / sizeof(s_fJobDsc[0]);
        break;

    case IPP_REQJTMP_IDX:
        pFlg = s_fJobTmp;
        cFlg = sizeof(s_fJobTmp) / sizeof(s_fJobTmp[0]);
        break;

    case IPP_REQPDSC_IDX:
        pFlg = s_fPrtDsc;
        cFlg = sizeof(s_fPrtDsc) / sizeof(s_fPrtDsc[0]);
        break;
    }


    if (idx >= IPP_REQALL_IDX) {

        for (idz = 0; idz < cFlg; idz++) {

            idx = ((pFlg[idz] >> 28) & 0x0000000F);

            pfReq[idx] |= (pFlg[idz] & 0x0FFFFFFF);
        }

    } else {

        pfReq[idx] |= (fSet & 0x0FFFFFFF);
    }
}


/*****************************************************************************\
* ipp_ChkReq (Local Routine)
*
* Checks to se if bit-flag is set in the request flag.
*
\*****************************************************************************/
BOOL x_ChkReq(
    PDWORD pfReq,
    DWORD  fChk)
{
    DWORD idx = ((fChk >> 28) & 0x0000000F);

    return pfReq[idx] & (fChk & 0x0FFFFFFF);
}


/*****************************************************************************\
* ipp_CopyAligned (Local Routine)
*
* Copies memory to an aligned-buffer.
*
\*****************************************************************************/
inline LPBYTE ipp_CopyAligned(
    LPBYTE lpDta,
    DWORD  cbDta)
{
    LPBYTE lpAln;

    if (lpAln = (LPBYTE)webAlloc(cbDta))
        CopyMemory((LPVOID)lpAln, lpDta, cbDta);

    return lpAln;
}


/*****************************************************************************\
* ipp_WriteData (Local Routine)
*
* Sets the data in an IPP-Data-Stream.  This adjusts the pointer to the
* next byte-location in the stream.
*
* NOTE: Make sure that cbData is never greater than size of lplpPtr in bytes.
*
\*****************************************************************************/
inline VOID ipp_WriteData(
    LPBYTE* lplpPtr,
    LPVOID  lpData,
    DWORD   cbData)
{
    CopyMemory(*lplpPtr, lpData, cbData);

    *lplpPtr += cbData;
}


/*****************************************************************************\
* ipp_WriteByte (Local Routine)
*
* Write out a byte to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteByte(
    LPBYTE* lplpIppPtr,
    BYTE    bVal)
{
    ipp_WriteData(lplpIppPtr, (LPVOID)&bVal, IPP_SIZEOFTAG);
}


/*****************************************************************************\
* ipp_ReadByte (Local Routine)
*
* Read a byte from the stream.
*
\*****************************************************************************/
inline BYTE ipp_ReadByte(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    return (*(BYTE *)((LPBYTE)(lpbPtr) + cbIdx));
}


/*****************************************************************************\
* ipp_WriteWord (Local Routine)
*
* Write out a word to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteWord(
    LPBYTE* lplpIppPtr,
    WORD    wVal)
{
    WORD wNBW = htons (wVal);

    ipp_WriteData(lplpIppPtr, (LPVOID)&wNBW, IPP_SIZEOFLEN);
}


/*****************************************************************************\
* ipp_ReadWord (Local Routine)
*
* Read a word from the stream.
*
\*****************************************************************************/
inline WORD ipp_ReadWord(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    WORD wVal = (*(WORD UNALIGNED *)((LPBYTE)(lpbPtr) + cbIdx));

    return ntohs (wVal);
}


/*****************************************************************************\
* ipp_WriteDWord (Local Routine)
*
* Write out a dword to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteDWord(
    LPBYTE* lplpIppPtr,
    DWORD   dwVal)
{
    DWORD dwNBDW = htonl(dwVal);

    ipp_WriteData(lplpIppPtr, (LPVOID)&dwNBDW, IPP_SIZEOFINT);
}


/*****************************************************************************\
* ipp_ReadDWord (Local Routine)
*
* Read a dword from the stream.
*
\*****************************************************************************/
inline DWORD ipp_ReadDWord(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    DWORD dwVal = (*(DWORD UNALIGNED *)((LPBYTE)(lpbPtr) + cbIdx));

    return ntohl(dwVal);
}


/*****************************************************************************\
* ipp_MapReqToJobCmd (Local Routine)
*
* Returns a job-command from a request.
*
\*****************************************************************************/
inline DWORD ipp_MapReqToJobCmd(
    WORD wReq)
{
    if (wReq == IPP_REQ_CANCELJOB)
        return JOB_CONTROL_DELETE;

    if (wReq == IPP_REQ_PAUSEJOB)
        return JOB_CONTROL_PAUSE;

    if (wReq == IPP_REQ_RESUMEJOB)
        return JOB_CONTROL_RESUME;

    if (wReq == IPP_REQ_RESTARTJOB)
        return JOB_CONTROL_RESTART;

    return 0;
}


/*****************************************************************************\
* ipp_MapReqToPrnCmd (Local Routine)
*
* Returns a printer-command from a request.
*
\*****************************************************************************/
inline DWORD ipp_MapReqToPrnCmd(
    WORD wReq)
{
    if (wReq == IPP_REQ_RESUMEPRN)
        return PRINTER_CONTROL_RESUME;

    if (wReq == IPP_REQ_PAUSEPRN)
        return PRINTER_CONTROL_PAUSE;

    if (wReq == IPP_REQ_CANCELPRN)
        return PRINTER_CONTROL_PURGE;

    return 0;
}


/*****************************************************************************\
* ipp_W32ToIppJobPriority (Local Routine)
*
* Maps a JOB_INFO_2 priority to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobPriority(
    DWORD dwPriority)
{
    return dwPriority;
}


/*****************************************************************************\
* ipp_IppToW32JobPriority (Local Routine)
*
* Maps an IPP job priority to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobPriority(
    DWORD dwPriority)
{
    return dwPriority;
}

/*****************************************************************************\
* ipp_W32ToIppJobSize (Local Routine)
*
* Maps a JOB_INFO_2 size to an IPP size.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobSize(
    DWORD dwSize)
{
    return (1023 + dwSize) / 1024;
}


/*****************************************************************************\
* ipp_IppToW32JobSize (Local Routine)
*
* Maps an IPP job size to a JOB_INFO_2 size.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobSize(
    DWORD dwSize)
{
    return dwSize * 1024;
}


/*****************************************************************************\
* ipp_W32ToIppJobTotalPages (Local Routine)
*
* Maps a JOB_INFO_2 TotalPages to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobTotalPages(
    DWORD dwTotalPages)
{
    return dwTotalPages;
}


/*****************************************************************************\
* ipp_IppToW32JobTotalPages (Local Routine)
*
* Maps an IPP TotalPages to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobTotalPages(
    DWORD dwTotalPages)
{
    return dwTotalPages;
}


/*****************************************************************************\
* ipp_W32ToIppJobPagesPrinted (Local Routine)
*
* Maps a JOB_INFO_2 PagesPrinted to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobPagesPrinted(
    DWORD dwPagesPrinted)
{
    return dwPagesPrinted;
}


/*****************************************************************************\
* ipp_IppToW32JobPagesPrinted (Local Routine)
*
* Maps an IPP PagesPrinted to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobPagesPrinted(
    DWORD dwPagesPrinted)
{
    return dwPagesPrinted;
}


/*****************************************************************************\
* ipp_W32ToIppJobState (Local Routine)
*
* Maps a Job-Status flag to that of an IPP State flag.
*
\*****************************************************************************/
DWORD ipp_W32ToIppJobState(
    DWORD dwState)
{
    if (dwState & (JOB_STATUS_OFFLINE | JOB_STATUS_PAPEROUT | JOB_STATUS_ERROR | JOB_STATUS_USER_INTERVENTION | JOB_STATUS_BLOCKED_DEVQ))
        return IPP_JOBSTATE_PROCESSEDSTOPPED;

    if (dwState & JOB_STATUS_DELETED)
        return IPP_JOBSTATE_CANCELLED;

    if (dwState & JOB_STATUS_PAUSED)
        return IPP_JOBSTATE_PENDINGHELD;

    if (dwState & JOB_STATUS_PRINTED)
        return IPP_JOBSTATE_COMPLETED;

    if (dwState & (JOB_STATUS_PRINTING | JOB_STATUS_SPOOLING | JOB_STATUS_DELETING))
        return IPP_JOBSTATE_PROCESSING;

    if ((dwState == 0) || (dwState & JOB_STATUS_RESTART))
        return IPP_JOBSTATE_PENDING;

    return IPP_JOBSTATE_UNKNOWN;
}


/*****************************************************************************\
* ipp_IppToW32JobState (Local Routine)
*
* Maps a IPP State flag to that of a W32 Status flag.
*
\*****************************************************************************/
DWORD ipp_IppToW32JobState(
    DWORD dwState)
{
    switch (dwState) {

    case IPP_JOBSTATE_PENDINGHELD:
        return JOB_STATUS_PAUSED;

    case IPP_JOBSTATE_PROCESSEDSTOPPED:
        return JOB_STATUS_ERROR;

    case IPP_JOBSTATE_PROCESSING:
        return JOB_STATUS_PRINTING;

    case IPP_JOBSTATE_CANCELLED:
    case IPP_JOBSTATE_ABORTED:
        return JOB_STATUS_DELETING;

    case IPP_JOBSTATE_COMPLETED:
        return JOB_STATUS_PRINTED;

    default:
    case IPP_JOBSTATE_PENDING:
        return 0;
    }
}


/*****************************************************************************\
* ipp_W32ToIppPrnState (Local Routine)
*
* Maps a W32-Prn-State to Ipp-Prn-State.
*
\*****************************************************************************/
DWORD ipp_W32ToIppPrnState(
    DWORD dwState)
{
    if (dwState == 0)
        return IPP_PRNSTATE_IDLE;

    if (dwState & PRINTER_STATUS_PAUSED)
        return IPP_PRNSTATE_STOPPED;

    if (dwState & (PRINTER_STATUS_PROCESSING | PRINTER_STATUS_PRINTING))
        return IPP_PRNSTATE_PROCESSING;

    return IPP_PRNSTATE_UNKNOWN;
}


/*****************************************************************************\
* ipp_IppToW32PrnState (Local Routine)
*
* Maps a Ipp-Prn-State to W32-Prn-State.
*
\*****************************************************************************/
DWORD ipp_IppToW32PrnState(
    DWORD dwState)
{
    switch (dwState) {

    case IPP_PRNSTATE_STOPPED:
        return PRINTER_STATUS_PAUSED;

    case IPP_PRNSTATE_PROCESSING:
        return PRINTER_STATUS_PROCESSING;

    default:
    case IPP_PRNSTATE_IDLE:
        return 0;
    }
}

/*****************************************************************************\
* ipp_IppCurTime (Local Routine)
*
* Returns the base seconds printer has been alive.  This is used for the
* printer-up-time attribute.  Since our implementation can't determine the
* true printer up-time, we're going to use the relative seconds returned
* from the time() function.
*
\*****************************************************************************/
DWORD ipp_IppCurTime(VOID)
{
    time_t tTime;

    ZeroMemory(&tTime, sizeof(time_t));
    time(&tTime);

    return (DWORD) tTime;
}


/*****************************************************************************\
* ipp_IppToW32Time (Local Routine)
*
* Converts an IPP (DWORD) time to a win32 SYSTEMTIME. Note that we pass in the
* printers' normalised start time as a straight overwrite of the first fields
* of the LPSYSTEMTIME structure. This is nasty but since the code has no concept
* of session, we have to pass it back to code that does.
*
\*****************************************************************************/
BOOL ipp_IppToW32Time(
    time_t        dwTime,
    LPSYSTEMTIME pst)
{

    // All we do is brutally overwrite the structure with the time and send it back
    //
    // *(time_t *)pst = dwTime;
    // Change to use CopyMemory to avoid 64bit alignment error
    //
    CopyMemory (pst, &dwTime, sizeof (time_t));

    return TRUE;
}

/*******************************************************************************
** ippConvertSystemTime
**
** This receives the system time (which has actually been packed with the time
** retrieved from the printers) and converts it to the Real System time based
** on the original T0 of the printer
**
******************************************************************************/
BOOL WebIppConvertSystemTime(
    IN OUT LPSYSTEMTIME pST,
    IN     time_t       dwPrinterT0) 
{
    //
    // First we need to get the time stored in the LPSYSTEMTIME structure
    // time_t      dwSubmitTime = *(time_t *)pST;
    // Use CopyMemory to avoid alignment error in 64bit machine.
    //
    time_t      dwSubmitTime;

    CopyMemory (&dwSubmitTime, pST, sizeof (time_t));


    SYSTEMTIME TmpST;

    //
    // If the submitted time is zero, it means that either the job was submitted before
    // the printer was rebooted, or, the printer does not support the submitted time of the
    // job
    //

    if (!dwSubmitTime) {
        ZeroMemory( &pST, sizeof(LPSYSTEMTIME));
    } else {
        //
        // Next we have to normalise the time to that of the PrinterT0
        //
        dwSubmitTime += dwPrinterT0;

        tm *ptm;

        //
        // Convert the time into a struct and return the SYSTEMTIME
        // structure.
        //
        ptm = gmtime(&dwSubmitTime);

        if (ptm) {

            TmpST.wYear      = (WORD)(1900 + ptm->tm_year);
            TmpST.wMonth     = (WORD)(ptm->tm_mon + 1);
            TmpST.wDayOfWeek = (WORD)ptm->tm_wday;
            TmpST.wDay       = (WORD)ptm->tm_mday;
            TmpST.wHour      = (WORD)ptm->tm_hour;
            TmpST.wMinute    = (WORD)ptm->tm_min;
            TmpST.wSecond    = (WORD)ptm->tm_sec;
            TmpST.wMilliseconds = 0;

            CopyMemory (pST, &TmpST, sizeof (SYSTEMTIME));
        } else {
            ZeroMemory( &pST, sizeof(LPSYSTEMTIME));
        }
    }

    return TRUE;
}



/*****************************************************************************\
* ipp_W32ToIppTime (Local Routine)
*
* Converts a Win32 SYSTEMTIME to UCT.
*
\*****************************************************************************/
DWORD ipp_W32ToIppTime(
    LPSYSTEMTIME pst)               // We pass in the T0 for the system in here
{
    tm   tmCvt;
    struct _timeb tiTimeb;

    _ftime(&tiTimeb);               // We obtain the time zone difference from here,
                                    // mktime assumes local time in doing the conversion

    ZeroMemory(&tmCvt, sizeof(tm));
    tmCvt.tm_sec   = (int)(short)pst->wSecond;
    tmCvt.tm_min   = (int)(short)pst->wMinute;
    tmCvt.tm_hour  = (int)(short)pst->wHour;
    tmCvt.tm_mday  = (int)(short)pst->wDay;
    tmCvt.tm_mon   = (int)(short)(pst->wMonth - 1);
    tmCvt.tm_year  = ((int)(short)pst->wYear - 1900);
    tmCvt.tm_wday  = (int)(short)pst->wDayOfWeek;

    INT iUCT = (INT)mktime(&tmCvt);

    iUCT -= tiTimeb.timezone * 60;      // Normalise for timezone difference

    return (DWORD)iUCT;
}


/*****************************************************************************\
* ipp_JidFromUri
*
* Returns a job-id from a job-uri string.
*
\*****************************************************************************/
DWORD ipp_JidFromUri(
   LPTSTR lpszUri)
{
    LPTSTR lpszPtr;
    DWORD  jid = 0;

    if (lpszPtr = webFindRChar(lpszUri, TEXT('=')))
        jid = webAtoI(++lpszPtr);

    return jid;
}


/*****************************************************************************\
* ipp_PackStrings
*
* This routine packs strings to the end of a buffer.  This is used for
* building a JOB_INFO_2 list from IPP information.
*
\*****************************************************************************/
LPBYTE ipp_PackStrings(
   LPTSTR* ppszSrc,
   LPBYTE  pbDst,
   LPDWORD pdwDstOffsets,
   LPBYTE  pbEnd)
{
    DWORD cbStr;


    while (*pdwDstOffsets != (DWORD)-1) {
        //
        // We fill in the strings from the end of the structure and fill in the 
        // structure forwards, if our string pointer is ever less than the address 
        // we are copying into, the initial block allocated was too small
        //

        if (*ppszSrc) {

            cbStr  = webStrSize(*ppszSrc);
            pbEnd -= cbStr;

            CopyMemory(pbEnd, *ppszSrc, cbStr);

            LPTSTR *strWriteLoc = (LPTSTR *)(pbDst + *pdwDstOffsets);

            WEB_IPP_ASSERT( (LPBYTE)pbEnd >= (LPBYTE)strWriteLoc );

            *strWriteLoc = (LPTSTR)pbEnd;

        } else {

            *(LPTSTR *)(pbDst + *pdwDstOffsets) = TEXT('\0');
        }

        ppszSrc++;
        pdwDstOffsets++;
    }

    return pbEnd;
}


/*****************************************************************************\
* ipp_NextVal (Local Routine)
*
* Returns next value-field in a tag-attribute.
*
* Parameters:
* ----------
* lpIppHdr - Pointer to the IPP-Stream.
* lpcbIdx  - Current Byte offset into the IPP-Stream.
* cbIppHdr - Size of the IPP-Stream.
*
\*****************************************************************************/
LPBYTE ipp_NextVal(
    LPBYTE  lpIppHdr,
    LPDWORD lpcbIdx,
    DWORD   cbIppHdr)
{
    DWORD cbIdx;
    DWORD cbSize;

    //
    // The (cbIdx) is positioned at the location where a length
    // is to be read.
    //
    cbIdx = *lpcbIdx;

    //
    // Make sure we have enough to read a WORD value.
    //
    if ((cbIdx + IPP_SIZEOFTAG) >= cbIppHdr)
        return NULL;

    //
    // Get the name-length of the attribute.  Adjust our
    // offset by this amount and add size of length-field to
    // position to the next attribute-length.
    //
    cbSize  = (DWORD)ipp_ReadWord(lpIppHdr, cbIdx);
    cbIdx  += (cbSize + IPP_SIZEOFLEN);

    if (cbIdx >= cbIppHdr)
        return NULL;

    *lpcbIdx = cbIdx;

    return lpIppHdr + cbIdx;
}


/*****************************************************************************\
* ipp_NextTag (Local Routine)
*
* Returns a pointer to the next tag in the header.  If this routine returns
* NULL, then we do not have enough data to advance to the next-tag.
*
* Parameters:
* ----------
* lpTag   - Pointer to the current-tag postion.
* lpcbIdx - Bytes offset from the header.
* cbHdr   - Size of the header-stream we're working with.
*
\*****************************************************************************/
LPBYTE ipp_NextTag(
    LPBYTE  lpIppHdr,
    LPDWORD lpcbIdx,
    DWORD   cbIppHdr)
{
    BYTE  bTag;
    DWORD cbIdx;
    DWORD cbSize;

    //
    // Out current byte-offset is at a tag.  Grab the tag, and advance
    // our index past it to proced to get past the possible attribute.
    //
    cbIdx  = *lpcbIdx;
    bTag   = ipp_ReadByte(lpIppHdr, cbIdx);
    cbIdx += IPP_SIZEOFTAG;

    //
    // If our tag is a deliminator, then we need only advance to the
    // next byte where the next tag should be.
    //
    if (IS_TAG_DELIMITER(bTag)) {
        //
        // Make sure we have enough bytes to return an offset
        // to the next tag.
        //
        if (cbIdx >= cbIppHdr)
            return NULL;

        *lpcbIdx = cbIdx;

        return lpIppHdr + cbIdx;
    }

    //
    // Otherwise, we are currently at an attribute-tag.  We need to
    // calculate bytes offset to the next tag.
    //
    if (IS_TAG_ATTRIBUTE(bTag)) {
        //
        // This logic calculates the byte-offsets to the
        // value-tags.  We need to do two value adjustments
        // since there is both a (name) and a (value) component
        // to an attribute.
        //
        if (ipp_NextVal(lpIppHdr, &cbIdx, cbIppHdr)) {
            //
            // This last adjustment will return the position
            // of the next tag.
            //
            if (ipp_NextVal(lpIppHdr, &cbIdx, cbIppHdr)) {

                *lpcbIdx = cbIdx;

                return lpIppHdr + cbIdx;
            }
        }
    }

    return NULL;
}


/*****************************************************************************\
* ipp_RelAttr (Local Routine)
*
* Release (Free) the attribute block.
*
\*****************************************************************************/
BOOL ipp_RelAttr(
    LPIPPATTR lpAttr)
{
    if (lpAttr) {

        webFree(lpAttr->lpszName);
        webFree(lpAttr->lpValue);
        webFree(lpAttr);

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_GetAttr (Local Routine)
*
* Returns an attribute in a structured-from.
*
\*****************************************************************************/
LPIPPATTR ipp_GetAttr(
    LPBYTE   lpTag,
    DWORD    cbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr = NULL;
    WORD      wIdx;
    BYTE      bTag   = ipp_ReadByte(lpTag, 0);
    DWORD     cbSize;


    if (IS_TAG_ATTRIBUTE(bTag)) {

        if (lpAttr = (LPIPPATTR)webAlloc(sizeof(IPPATTR))) {

            __try {

                lpAttr->bTag    = bTag;
                lpTag          += IPP_SIZEOFTAG;

                lpAttr->cbName  = ipp_ReadWord(lpTag, 0);
                lpTag          += IPP_SIZEOFLEN;


                if (lpAttr->cbName) {

                    lpAttr->lpszName  = webMBtoTC(CP_UTF8, (LPSTR)lpTag, lpAttr->cbName);
                    lpTag            += lpAttr->cbName;
                }

                // This is added to support name-with-language attributes.  To
                // do this temporarily, this code will work but ignore the language
                // part of the attribute.  In the future, we can look at dealing with
                // the language appropriately.
                if (IS_TAG_COMPOUND(bTag)) {

                    if (ipp_ReadWord(lpTag, 0)) {

                        lpTag += IPP_SIZEOFLEN;
                        lpTag += ipp_ReadWord(lpTag, 0);
                        lpTag += IPP_SIZEOFLEN;
                    }
                }

                lpAttr->cbValue  = ipp_ReadWord(lpTag, 0);
                lpTag           += IPP_SIZEOFLEN;

                //
                // If there's a value, then make sure that the size doesn't
                // exceed our IPP-Stream.
                //
                if (lpAttr->cbValue && (lpAttr->cbValue < (lpObj->cbIppHdr - cbIdx))) {
                    //
                    // Convert the value to the appropriate format.  This
                    // block currently makes the assumption that all strings
                    // are dealt with as Octet-Strings.  When this parser
                    // supports other character-sets, then the conversion
                    // for Character-Strings can utilize a different codepage.
                    //
                    if (IS_TAG_OCTSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(CP_UTF8, (LPSTR)lpTag, lpAttr->cbValue);

                    } else if (IS_TAG_CHARSETSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(lpObj->uCPRcv, (LPSTR)lpTag, lpAttr->cbValue);

                    } else if (IS_TAG_CHRSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(CP_ACP, (LPSTR)lpTag, lpAttr->cbValue);

                    } else {

                        if (lpAttr->cbValue <= sizeof(DWORD))
                            lpAttr->lpValue = (LPVOID)webAlloc(sizeof(DWORD));
                        else
                            lpAttr->lpValue = (LPVOID)webAlloc(lpAttr->cbValue);

                        if (lpAttr->lpValue) {

                            if (lpAttr->cbValue == sizeof(BYTE))
                                *(LPDWORD)(lpAttr->lpValue) = (DWORD)ipp_ReadByte(lpTag, 0);
                            else if (lpAttr->cbValue == sizeof(WORD))
                                *(LPDWORD)(lpAttr->lpValue) = (DWORD)ipp_ReadWord(lpTag, 0);
                            else if (lpAttr->cbValue == sizeof(DWORD))
                                *(LPDWORD)(lpAttr->lpValue) = ipp_ReadDWord(lpTag, 0);
                            else
                                CopyMemory((LPVOID)lpAttr->lpValue, (LPVOID)lpTag, lpAttr->cbValue);
                        }
                    }
                }

            } __except (1) {

                ipp_RelAttr(lpAttr);

                lpAttr = NULL;
            }
        }
    }

    return lpAttr;
}


/*****************************************************************************\
* ipp_WriteAttr (Local Routine)
*
* Write out the attribute.  If NULL is passed in as the (lplpIppPtr), then
* this routine returns the size necessary to write the info.
*
\*****************************************************************************/
DWORD ipp_WriteAttr(
    LPBYTE* lplpIppPtr,
    BYTE    bTag,
    DWORD   cbName,
    LPVOID  lpName,
    DWORD   cbValue,
    LPVOID  lpValue)
{
    DWORD cbSize;

    //
    // Set the size that this attribute occupies.
    //
    cbSize = (cbName + cbValue + IPP_SIZEOFTAG + IPP_SIZEOFLEN + IPP_SIZEOFLEN);

    //
    // Write out the attribute to the buffer (if available).
    //
    if (lplpIppPtr) {

        ipp_WriteByte(lplpIppPtr, bTag);

        if (cbName) {

            ipp_WriteWord(lplpIppPtr, (WORD)cbName);
            ipp_WriteData(lplpIppPtr, (LPVOID)lpName, cbName);

        } else {

            ipp_WriteWord(lplpIppPtr, (WORD)cbName);
        }

        ipp_WriteWord(lplpIppPtr, (WORD)cbValue);

        switch (bTag) {
        case IPP_TAG_INT_INTEGER:
        case IPP_TAG_INT_ENUM:
            ipp_WriteDWord(lplpIppPtr, * (DWORD*)lpValue);
            break;
        case IPP_TAG_INT_BOOLEAN:
            ipp_WriteByte(lplpIppPtr, * (BYTE*)lpValue);
            break;
        default:
            ipp_WriteData(lplpIppPtr, (LPVOID)lpValue , cbValue);
            break;
        }
    }

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeAttr (Local Routine)
*
* Return the size necessary to store the attribute.
*
\*****************************************************************************/
inline DWORD ipp_SizeAttr(
    DWORD cbName,
    DWORD cbValue)
{
    return ipp_WriteAttr(NULL, 0, cbName, NULL, cbValue, NULL);
}


/*****************************************************************************\
* ipp_WriteHead (Local Routine)
*
* Write out our "generic" type header.  This includes the character-set
* that we support.
*
\*****************************************************************************/
DWORD ipp_WriteHead(
    LPBYTE* lplpIppPtr,
    WORD    wReq,
    DWORD   idReq,
    UINT    cpReq)
{
    DWORD   cbNamCS;
    DWORD   cbValCS;
    DWORD   cbNamNL;
    DWORD   cbValNL;
    LPCTSTR lpszCS;
    LPSTR   lputfNamCS;
    LPSTR   lputfValCS;
    LPSTR   lputfNamNL;
    LPSTR   lputfValNL;
    DWORD   cbSize = 0;

    //
    // Encode in the specified character-set.
    //
    lpszCS = ((cpReq == CP_ACP) ? s_szUsAscii : s_szUtf8);


    lputfNamCS = webTCtoMB(CP_ACP, s_szCharSet        , &cbNamCS);
    lputfValCS = webTCtoMB(CP_ACP, lpszCS             , &cbValCS);
    lputfNamNL = webTCtoMB(CP_ACP, s_szNaturalLanguage, &cbNamNL);
    lputfValNL = webTCtoMB(CP_ACP, s_szEnUS           , &cbValNL);


    if (lputfNamCS && lputfValCS && lputfNamNL && lputfValNL) {
        //
        // Calculate the size necessary to hold the IPP-Header.
        //
        cbSize = IPP_SIZEOFHDR                   +   // Version-Request.
                 IPP_SIZEOFTAG                   +   // Operation Tag
                 ipp_SizeAttr(cbNamCS, cbValCS)  +   // CharSet Attribute.
                 ipp_SizeAttr(cbNamNL, cbValNL);     // NaturalLang Attribute.


        if (lplpIppPtr) {

            ipp_WriteWord(lplpIppPtr, IPP_VERSION);
            ipp_WriteWord(lplpIppPtr, wReq);
            ipp_WriteDWord(lplpIppPtr, idReq);
            ipp_WriteByte(lplpIppPtr, IPP_TAG_DEL_OPERATION);
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_CHR_CHARSET, cbNamCS, lputfNamCS, cbValCS, lputfValCS);
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_CHR_NATURAL, cbNamNL, lputfNamNL, cbValNL, lputfValNL);
        }
    }

    webFree(lputfValCS);
    webFree(lputfNamCS);
    webFree(lputfValNL);
    webFree(lputfNamNL);

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeHdr (Local Routine)
*
* Return the size necessary to store the header and operation tags.
*
\*****************************************************************************/
inline DWORD ipp_SizeHdr(
    UINT cpReq)
{
    return ipp_WriteHead(NULL, 0, 0, cpReq);
}


/*****************************************************************************\
* ipp_ValDocFormat (Local Routine)
*
* Validates the document-format.
*
\*****************************************************************************/
BOOL ipp_ValDocFormat(
    LPCTSTR lpszFmt)
{
    DWORD idx;
    DWORD cCnt;

    static PCTSTR s_szFmts[] = {

        s_szMimeTxtHtml   ,
        s_szMimeTxtPlain  ,
        s_szMimePostScript,
        s_szMimePCL       ,
        s_szMimeOctStream
    };

    cCnt = sizeof(s_szFmts) / sizeof(s_szFmts[0]);

    for (idx = 0; idx < cCnt; idx++) {

        if (lstrcmpi(lpszFmt, s_szFmts[idx]) == 0)
            return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_ValAtrFidelity (Local Routine)
*
* Validates the attribute-fidelity.
*
\*****************************************************************************/
BOOL ipp_ValAtrFidelity(
    DWORD  dwVal,
    LPBOOL lpbFidelity)
{
    if (dwVal == 1) {

        *lpbFidelity = TRUE;

    } else if (dwVal == 0) {

        *lpbFidelity = FALSE;

    } else {

        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_ValWhichJobs (Local Routine)
*
* Validates the which-jobs.
*
\*****************************************************************************/
BOOL ipp_ValWhichJobs(
    PDWORD  pfReq,
    LPCTSTR lpszWJ)
{
    DWORD idx;
    DWORD cCnt;

    static FLGSTR s_fsVal[] = {

        RA_JOBSCOMPLETED  , s_szCompleted   ,
        RA_JOBSUNCOMPLETED, s_szNotCompleted
    };

    cCnt = sizeof(s_fsVal) / sizeof(s_fsVal[0]);

    for (idx = 0; idx < cCnt; idx++) {

        if (lstrcmpi(lpszWJ, s_fsVal[idx].pszStr) == 0) {

            x_SetReq(pfReq, s_fsVal[idx].fFlag);

            return TRUE;
        }
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_GetRspSta (Local Routine)
*
* Returns the response-code and any status messages if failure.
*
\*****************************************************************************/
WORD ipp_GetRspSta(
    WORD    wRsp,
    UINT    cpReq,
    LPSTR*  lplputfNamSta,
    LPDWORD lpcbNamSta,
    LPSTR*  lplputfValSta,
    LPDWORD lpcbValSta)
{
    DWORD idx;
    DWORD cErrors;


    *lplputfNamSta = NULL;
    *lplputfValSta = NULL;
    *lpcbNamSta    = 0;
    *lpcbValSta    = 0;


    if (SUCCESS_RANGE(wRsp) == FALSE) {
        //
        // Get the status-name.
        //
        *lplputfNamSta = webTCtoMB(CP_ACP, s_szStaMsg, lpcbNamSta);

        //
        // Get the string we will be using to encode the error.
        //
        cErrors = sizeof(s_LEIpp) / sizeof(s_LEIpp[0]);

        for (idx = 0; idx < cErrors; idx++) {

            if (wRsp == s_LEIpp[idx].wRsp) {

                *lplputfValSta = webTCtoMB(cpReq, s_LEIpp[idx].pszStr, lpcbValSta);

                break;
            }
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_CvtW32Val (Local Routine - Server)
*
* Converts a value to the appropriate ipp-value.
*
\*****************************************************************************/
VOID ipp_CvtW32Val(
    LPCTSTR lpszName,
    LPVOID  lpvVal)
{
    if (lstrcmpi(lpszName, s_szPrtState) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppPrnState(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobState) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobState(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobKOctets) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobSize(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobKOctetsProcess) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobSize(*(LPDWORD)lpvVal);
    }
}


/*****************************************************************************\
* ipp_AllocUnsVals
*
* Allocates an array of ipp-values used to write to a stream.
*
\*****************************************************************************/
LPIPPATTRY ipp_AllocUnsVals(
    PWEBLST pwlUns,
    LPDWORD pcUns,
    LPDWORD lpcbAtrs)
{
    DWORD      idx;
    DWORD      cUns;
    DWORD      cbUns;
    PCTSTR     pszStr;
    LPIPPATTRY pUns = NULL;


    *pcUns = 0;

    if (pwlUns && (cUns = pwlUns->Count())) {

        if (pUns = (LPIPPATTRY)webAlloc(cUns * sizeof(IPPATTRY))) {

            *lpcbAtrs += IPP_SIZEOFTAG;
            *pcUns     = cUns;

            //
            // Loop through each item and convert for addition to stream.
            //
            pwlUns->Reset();

            for (idx = 0; idx < cUns; idx++) {

                if (pszStr = pwlUns->Get()) {

                    pUns[idx].pszNam = webTCtoMB(CP_ACP, pszStr, &pUns[idx].cbNam);
                    
                    //
                    // Unsupported-values should be null.
                    //
                    pUns[idx].pszVal = NULL;
                    pUns[idx].cbVal  = 0;

                    *lpcbAtrs += ipp_SizeAttr(pUns[idx].cbNam, pUns[idx].cbVal);
                }

                pwlUns->Next();
            }
        }
    }

    return pUns;
}


/*****************************************************************************\
* ipp_AllocAtrVals
*
* Allocates an array of ipp-values used to write to a stream.
*
\*****************************************************************************/
LPIPPATTRY ipp_AllocAtrVals(
    WORD       wReq,
    PDWORD     pfReq,
    UINT       cpReq,
    LPBYTE     lpbData,
    LPIPPATTRX pRsp,
    DWORD      cAtr,
    LPDWORD    lpcbAtrs)
{
    BOOL       bRet = FALSE;
    BOOL       fWr;
    DWORD      idx;
    BOOL       bDel;
    LPVOID     lpvVal;
    LPIPPATTRY pAtr = NULL;


    if (cAtr && (pAtr = (LPIPPATTRY)webAlloc(cAtr * sizeof(IPPATTRY)))) {
        //
        // Allocate the attribute-values.
        //
        for (idx = 0, fWr = TRUE; idx < cAtr; idx++) {

            bDel = FALSE;
            //
            // Build the attribute-name.
            //
            if (pRsp[idx].pszNam) {

                pAtr[idx].pszNam = webTCtoMB(CP_ACP, pRsp[idx].pszNam, &pAtr[idx].cbNam);
                //
                // If the value is absolute, then assign the
                // attribute directly.  Otherwise, it's an offset into
                // the return-structure, and as such, must be indirectly
                // built.
                //
                if (pRsp[idx].nVal == IPP_ATR_ABSOLUTE) {
                    //
                    // Special-case the printer-up-time to reflect the number
                    // of seconds it's been up and running.  Since we can't
                    // determine the time the printer's been up, use the time
                    // windows has been started.
                    //
                    if (lstrcmpi(pRsp[idx].pszNam, s_szPrtUpTime) == 0)
                        pRsp[idx].pvVal = (LPVOID)ULongToPtr (ipp_IppCurTime());
                    else
                        lpvVal = (LPVOID)&pRsp[idx].pvVal;

                } else {

                    lpvVal = (LPVOID)(lpbData + (DWORD_PTR)pRsp[idx].pvVal);
                }

                fWr = x_ChkReq(pfReq, pRsp[idx].fReq);
            }

            //
            // Add it to the stream if it is a request or if
            // the response requires it.
            //
            if (fWr || !(wReq & IPP_RESPONSE)) {
                //
                // If the value is absolute, then assign the
                // attribute directly.  Otherwise, it's an offset into
                // the return-structure, and as such, must be indirectly
                // built.
                //
                if (pRsp[idx].nVal == IPP_ATR_ABSOLUTE)
                    lpvVal = (LPVOID)&pRsp[idx].pvVal;
                else
                    lpvVal = (LPVOID)(lpbData + (DWORD_PTR)pRsp[idx].pvVal);

                //
                // Build the attribute-value.
                //
                if (IS_TAG_DELIMITER(pRsp[idx].bTag)) {

                    bDel = TRUE;

                } else if (IS_TAG_OCTSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(CP_UTF8, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else if (IS_TAG_CHARSETSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(cpReq, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else if (IS_TAG_CHRSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(CP_ACP, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else {

                    pAtr[idx].pszVal = (LPSTR)webAlloc(sizeof(DWORD));

                    if ( !pAtr[idx].pszVal )
                        goto Cleanup;

                    if (pRsp[idx].bTag == IPP_TAG_INT_BOOLEAN) {

                        pAtr[idx].cbVal = IPP_SIZEOFBYTE;

                    } else {

                        pAtr[idx].cbVal = IPP_SIZEOFINT;
                    }

                    CopyMemory(pAtr[idx].pszVal, lpvVal, pAtr[idx].cbVal);

                    //
                    // Do we need to convert the value.
                    //
                    if (pRsp[idx].nVal == IPP_ATR_OFFSETCONV)
                        ipp_CvtW32Val(pRsp[idx].pszNam, (LPVOID)pAtr[idx].pszVal);
                }

                //
                // If this is a delimiter then it only occupies 1 byte.
                //
                if (bDel)
                    *lpcbAtrs += IPP_SIZEOFTAG;
                else
                    *lpcbAtrs += ipp_SizeAttr(pAtr[idx].cbNam, pAtr[idx].cbVal);
            }
        }
    }

    bRet = TRUE;

Cleanup:
    if ( !bRet && pAtr ) {

        for (idx = 0 ; idx < cAtr; ++idx)
            if ( pAtr[idx].pszVal )
                webFree(pAtr[idx].pszVal);

        webFree(pAtr);
        pAtr = NULL;
    }

    return pAtr;
}


/*****************************************************************************\
* ipp_WriteUnsVals
*
* Writes an array of ipp-values to an ipp-stream.
*
\*****************************************************************************/
BOOL ipp_WriteUnsVals(
    LPBYTE*    lplpIppPtr,
    LPIPPATTRY pUns,
    DWORD      cUns)
{
    DWORD idx;


    if (pUns && cUns) {

        ipp_WriteByte(lplpIppPtr, IPP_TAG_DEL_UNSUPPORTED);

        //
        // Unsupported values should be null.
        //
        for (idx = 0; idx < cUns; idx++)
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_OUT_UNSUPPORTED, pUns[idx].cbNam, pUns[idx].pszNam, 0, NULL);
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_WriteAtrVals
*
* Writes an array of ipp-values to an ipp-stream.
*
\*****************************************************************************/
BOOL ipp_WriteAtrVals(
    WORD       wReq,
    PDWORD     pfReq,
    LPBYTE*    lplpIppPtr,
    LPIPPATTRX pRsp,
    LPIPPATTRY pAtr,
    DWORD      cAtr)
{
    BOOL  fWr;
    DWORD idx;


    for (idx = 0, fWr = TRUE; idx < cAtr; idx++) {
        //
        // If this item has a name-tag, then determine if the
        // originator wants it in the stream.
        //
        if (pRsp[idx].pszNam)
            fWr = x_ChkReq(pfReq, pRsp[idx].fReq);

        //
        // Only write out the item if it is requested, or if
        // it is a request-operation.
        //
        if (fWr || !(wReq & IPP_RESPONSE)) {

            if (pRsp[idx].nVal == IPP_ATR_TAG)
                ipp_WriteByte(lplpIppPtr, pRsp[idx].bTag);
            else
                ipp_WriteAttr(lplpIppPtr, pRsp[idx].bTag, pAtr[idx].cbNam, pAtr[idx].pszNam, pAtr[idx].cbVal, pAtr[idx].pszVal);
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_FreeAtrVals
*
* Frees array of attribute values.
*
\*****************************************************************************/
VOID ipp_FreeAtrVals(
    LPIPPATTRY pAtr,
    DWORD      cAtr)
{
    DWORD idx;

    //
    // Free up the attribute-values.
    //
    for (idx = 0; idx < cAtr; idx++) {

        webFree(pAtr[idx].pszNam);
        webFree(pAtr[idx].pszVal);
    }

    webFree(pAtr);
}


/*****************************************************************************\
* ipp_FreeIPPJI2 (Local Routine)
*
* Frees up the IPPJI2 memory.
*
\*****************************************************************************/
VOID ipp_FreeIPPJI2(
    LPIPPJI2 lpji)
{
    DWORD cCnt;
    DWORD idx;

    //
    // Free JI2-Data.
    //
    cCnt = ((sizeof(s_JI2Off) / sizeof(s_JI2Off[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lpji->ji2) + s_JI2Off[idx]));

    //
    // Free IPP-Data.
    //
    cCnt = ((sizeof(s_IPJOff) / sizeof(s_IPJOff[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lpji->ipp) + s_IPJOff[idx]));
}


/*****************************************************************************\
* ipp_FreeIPPPI2 (Local Routine)
*
* Frees up the IPPPI2 memory.
*
\*****************************************************************************/
VOID ipp_FreeIPPPI2(
    LPIPPPI2 lppi)
{
    DWORD cCnt;
    DWORD idx;

    //
    // Free PI2-Data.
    //
    cCnt = ((sizeof(s_PI2Off) / sizeof(s_PI2Off[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lppi->pi2) + s_PI2Off[idx]));

    //
    // Free IPP-Data.
    //
    cCnt = ((sizeof(s_IPPOff) / sizeof(s_IPPOff[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lppi->ipp) + s_IPPOff[idx]));

}


/*****************************************************************************\
* ipp_GetIPPJI2 (Local Routine)
*
* Returns the info for a complete job in the IPP stream.  We essentially
* loop through the attributes looking for the next IPP_TAG_DEL_JOB to
* signify another job-info-item.
*
\*****************************************************************************/
LPBYTE ipp_GetIPPJI2(
    LPBYTE   lpbTag,
    LPIPPJI2 lpji,
    LPDWORD  lpcbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    BYTE      bTag;
    DWORD     idx;
    DWORD     cAtr;
    BOOL      bReq;
    BOOL      bFound;
    DWORD     fAtr[IPPOBJ_MASK_SIZE];
    BOOL      bFid = FALSE;
    BOOL      bAtr = FALSE;
    BOOL      bEnu = FALSE;


    x_SetReq(fAtr, IPP_REQALL);

    bTag = ipp_ReadByte(lpbTag, 0);
    bReq = ((lpObj->wReq & IPP_RESPONSE) ? FALSE : TRUE);
    bEnu = (BOOL)(lpObj->wReq & IPP_REQ_ENUJOB);

    while ((!bEnu || (bTag != IPP_TAG_DEL_JOB)) && (bTag != IPP_TAG_DEL_DATA)) {

        if (lpAttr = ipp_GetAttr(lpbTag, *lpcbIdx, lpObj)) {

            if (lpAttr->lpszName && lpAttr->lpValue) {

                if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpAttr->cbValue > SIZE_CHARSET)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpAttr->cbValue > SIZE_NATLANG)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobId) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.JobId = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobLimit) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ipp.cJobs = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobState) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Status = ipp_IppToW32JobState(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobPri) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Priority = ipp_IppToW32JobPriority(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobKOctets) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Size = ipp_IppToW32JobSize(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobKOctetsProcess) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Size = ipp_IppToW32JobSize(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobSheets) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.TotalPages = ipp_IppToW32JobTotalPages(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobSheetsCompleted) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.PagesPrinted = ipp_IppToW32JobPagesPrinted(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pDocument);
                        lpji->ji2.pDocument = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pDocument);
                        lpji->ji2.pDocument = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobOrgUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pUserName);
                        lpji->ji2.pUserName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pUserName);
                        lpji->ji2.pUserName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pJobUri);
                        lpji->ipp.pJobUri = webAllocStr((LPTSTR)lpAttr->lpValue);

                        if (bReq && lpji->ipp.pJobUri)
                            lpji->ji2.JobId = ipp_JidFromUri(lpji->ipp.pJobUri);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pPrnUri);
                        lpji->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pPrnUri);
                        lpji->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocFormat) == 0) {

                    if (lpAttr->cbValue > SIZE_MIMEMEDIA) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValDocFormat((PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40A;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szAtrFidelity) == 0) {

                    if (lpAttr->cbValue != SIZE_BOOLEAN) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValAtrFidelity(*(LPDWORD)lpAttr->lpValue, &bFid) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_400;
                        else
                            lpObj->fState |= (bFid ? IPPFLG_USEFIDELITY : 0);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szWhichJobs) == 0) {

                    if (lpAttr->cbValue > SIZE_KEYWORD) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValWhichJobs(fAtr, (PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40B;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szTimeAtCreation) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        ipp_IppToW32Time(*(LPDWORD)lpAttr->lpValue, &lpji->ji2.Submitted);
                    }

                } else if (bReq && (lstrcmpi(lpAttr->lpszName, s_szReqAttr) == 0)) {

                    bAtr = TRUE;

                    x_SetReq(fAtr, IPP_REQCLEAR);

                    goto ProcessVal;

                } else {

                    lpObj->pwlUns->Add(lpAttr->lpszName);
                }

            } else if (bAtr && lpAttr->lpValue) {

ProcessVal:
                if (lpAttr->cbValue > SIZE_KEYWORD) {

                    lpObj->wError = IPPRSP_ERROR_409;

                } else {

                    if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szAll) == 0) {

                        x_SetReq(fAtr, IPP_REQALL);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobTemplate) == 0) {

                        x_SetReq(fAtr, IPP_REQJTMP);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobDescription) == 0) {

                        x_SetReq(fAtr, IPP_REQJDSC);

                    } else {
                        //
                        // Walk through the possible response attributes
                        // and look for those requested.
                        //
                        cAtr = sizeof(s_PJR) / sizeof(s_PJR[0]);

                        for (idx = 0, bFound = FALSE; idx < cAtr; idx++) {

                            if (s_PJR[idx].pszNam) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_PJR[idx].pszNam) == 0) {

                                    x_SetReq(fAtr, s_PJR[idx].fReq);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }

                        //
                        // Look through potential request/response mappings.  This
                        // is necessary for request that have a different name
                        // than that we give back in a response.  i.e. JobReqUser
                        // verses JobOrgUser.
                        //
                        if (bFound == FALSE) {

                            cAtr = sizeof(s_ReqRspStr) / sizeof(s_ReqRspStr[0]);

                            for (idx = 0; idx < cAtr; idx++) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_ReqRspStr[idx].pszStr) == 0) {

                                    x_SetReq(fAtr, s_ReqRspStr[idx].fFlag);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }

                        if (!bFound)
                            lpObj->pwlUns->Add((PCTSTR)lpAttr->lpValue);
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }

        if (ERROR_RANGE(lpObj->wError))
            break;

        //
        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, lpcbIdx, lpObj->cbIppHdr))
            bTag = ipp_ReadByte(lpbTag, 0);
        else
            break;
    }

    //
    // If the fidelity is desired, then we should have
    // no unsupported attributes.
    //
    if (bFid && (lpObj->pwlUns->Count()))
        lpObj->wError = IPPRSP_ERROR_40B;

    //
    // Set the internal-state
    //
    if (bAtr)
        CopyMemory(lpObj->fReq, fAtr, IPPOBJ_MASK_SIZE * sizeof(DWORD));

    return lpbTag;
}


/*****************************************************************************\
* ipp_GetIPPPI2 (Local Routine)
*
* Returns the info for a complete job in the IPP stream.  We essentially
* loop through the attributes looking for the next IPP_TAG_DEL_JOB to
* signify another printer-info-item.
*
\*****************************************************************************/
LPBYTE ipp_GetIPPPI2(
    LPBYTE   lpbTag,
    LPIPPPI2 lppi,
    LPDWORD  lpcbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    BYTE      bTag;
    DWORD     cAtr;
    DWORD     idx;
    BOOL      bReq;
    BOOL      bFound;
    DWORD     fAtr[IPPOBJ_MASK_SIZE];
    BOOL      bAtr = FALSE;


    x_SetReq(fAtr, IPP_REQALL);


    bTag = ipp_ReadByte(lpbTag, 0);
    bReq = ((lpObj->wReq & IPP_RESPONSE) ? FALSE : TRUE);


    while ((bTag != IPP_TAG_DEL_PRINTER) && (bTag != IPP_TAG_DEL_DATA)) {

        if (lpAttr = ipp_GetAttr(lpbTag, *lpcbIdx, lpObj)) {
            //
            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName && lpAttr->lpValue) {

                if (lstrcmpi(lpAttr->lpszName, s_szPrtUpTime) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER) {
                        lpObj->wError = IPPRSP_ERROR_409;
                    } else {
                        //
                        // What we want to do is get the current time in seconds and then
                        // work out what the T0 of the printer must be in this renormalised
                        // time
                        //
                        // These will be positive, we assume [0..2^31-1]
                        //
                        DWORD dwCurTime = ipp_IppCurTime();  
                        DWORD  dwPrtTime = *(LPDWORD) lpAttr->lpValue;   

                        lppi->ipp.dwPowerUpTime = (time_t)dwCurTime - (time_t)dwPrtTime;
                   }

                } else if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpAttr->cbValue > SIZE_CHARSET)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpAttr->cbValue > SIZE_NATLANG)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtState) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lppi->pi2.Status = ipp_IppToW32PrnState(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtJobs) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lppi->pi2.cJobs = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->pi2.pPrinterName);
                        lppi->pi2.pPrinterName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pPrnUri);
                        lppi->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pUsrName);
                        lppi->ipp.pUsrName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUriSupported) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pPrnUri);
                        lppi->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtMake) == 0) {

                    if (lpAttr->cbValue > SIZE_TEXT) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->pi2.pDriverName);
                        lppi->pi2.pDriverName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocFormat) == 0) {

                    if (lpAttr->cbValue > SIZE_MIMEMEDIA) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValDocFormat((PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40A;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (bReq && (lstrcmpi(lpAttr->lpszName, s_szReqAttr) == 0)) {

                    bAtr = TRUE;

                    x_SetReq(fAtr, IPP_REQCLEAR);

                    goto ProcessVal;

                } else {

                    lpObj->pwlUns->Add(lpAttr->lpszName);
                }

            } else if (bAtr && lpAttr->lpValue) {

ProcessVal:
                if (lpAttr->cbValue > SIZE_KEYWORD) {

                    lpObj->wError = IPPRSP_ERROR_409;

                } else {

                    if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szAll) == 0) {

                        x_SetReq(fAtr, IPP_REQALL);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobTemplate) == 0) {

                        x_SetReq(fAtr, IPP_REQPTMP);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szPrtDescription) == 0) {

                        x_SetReq(fAtr, IPP_REQPDSC);

                    } else {
                        //
                        // Walk through the possible response attributes
                        // and look for those requested.
                        //
                        cAtr = sizeof(s_GPR) / sizeof(s_GPR[0]);

                        for (idx = 0, bFound = FALSE; idx < cAtr; idx++) {

                            if (s_GPR[idx].pszNam) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_GPR[idx].pszNam) == 0) {

                                    x_SetReq(fAtr, s_GPR[idx].fReq);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }
                        
                        //
                        // Look through potential request/response mappings.  This
                        // is necessary for request that have a different name
                        // than that we give back in a response.  i.e. JobReqUser
                        // verses JobOrgUser.
                        //
                        if (bFound == FALSE) {

                            cAtr = sizeof(s_ReqRspStr) / sizeof(s_ReqRspStr[0]);

                            for (idx = 0; idx < cAtr; idx++) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_ReqRspStr[idx].pszStr) == 0)
                                    x_SetReq(fAtr, s_ReqRspStr[idx].fFlag);
                            }
                        }

                        if (!bFound)
                            lpObj->pwlUns->Add((PCTSTR)lpAttr->lpValue);
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;

        //
        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, lpcbIdx, lpObj->cbIppHdr))
            bTag = ipp_ReadByte(lpbTag, 0);
        else
            break;
    }

    //
    // Set the internal-state
    //
    if (bAtr)
        CopyMemory(lpObj->fReq, fAtr, IPPOBJ_MASK_SIZE * sizeof(DWORD));

    return lpbTag;
}


/*****************************************************************************\
* ipp_CopyJI2toIPPJI2 (Local Routine)
*
* Copies a JOB_INFO_2 to IPPJI2.
*
\*****************************************************************************/
LPBYTE ipp_CopyJI2toIPPJI2(
    LPIPPJI2     lpjiDst,
    LPJOB_INFO_2 lpJI2,
    LPTSTR       lpszJobBase,
    LPBYTE       lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  lpszPtr;
    LPTSTR  lpszJobUri;
    LPTSTR  lpszPrnUri;
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];

    //
    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc , sizeof(aszSrc));
    ZeroMemory(lpjiDst, sizeof(IPPJI2));

    //
    // Copy fixed values.
    //
    lpjiDst->ji2.JobId        = lpJI2->JobId;
    lpjiDst->ji2.Status       = ipp_W32ToIppJobState(lpJI2->Status);
    lpjiDst->ji2.Priority     = ipp_W32ToIppJobPriority(lpJI2->Priority);
    lpjiDst->ji2.Size         = ipp_W32ToIppJobSize(lpJI2->Size);
    lpjiDst->ji2.TotalPages   = ipp_W32ToIppJobTotalPages(lpJI2->TotalPages);
    lpjiDst->ji2.PagesPrinted = ipp_W32ToIppJobPagesPrinted(lpJI2->PagesPrinted);

    *((LPDWORD)&lpjiDst->ji2.Submitted) = ipp_W32ToIppTime(&lpJI2->Submitted);

    //
    // Build a job-uri.
    //
    if (lpszJobUri = (LPTSTR)webAlloc(webStrSize(lpszJobBase) + 80))
        StringCbPrintf(lpszJobUri, webStrSize(lpszJobBase)+80, TEXT("%s%d"), lpszJobBase, lpJI2->JobId);

    //
    // Build a printer-uri.
    //
    lpszPrnUri = NULL;

    if (lpszJobBase && (lpszPtr = webFindRChar(lpszJobBase, TEXT('?')))) {

        *lpszPtr = TEXT('\0');
        lpszPrnUri = (LPTSTR)webAllocStr(lpszJobBase);
        *lpszPtr = TEXT('?');
    }

    //
    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = lpJI2->pPrinterName;
    *lpszSrc++ = lpJI2->pMachineName;
    *lpszSrc++ = lpJI2->pUserName;
    *lpszSrc++ = lpJI2->pDocument;
    *lpszSrc++ = lpJI2->pNotifyName;
    *lpszSrc++ = lpJI2->pDatatype;
    *lpszSrc++ = lpJI2->pPrintProcessor;
    *lpszSrc++ = lpJI2->pParameters;
    *lpszSrc++ = lpJI2->pDriverName;
    *lpszSrc++ = NULL;
    *lpszSrc++ = lpJI2->pStatus;
    *lpszSrc++ = NULL;
    *lpszSrc++ = lpszPrnUri;
    *lpszSrc++ = lpszJobUri;

    lpbEnd = ipp_PackStrings(aszSrc, (LPBYTE)lpjiDst, s_IPPJI2Offs, lpbEnd);

    webFree(lpszJobUri);
    webFree(lpszPrnUri);

    return lpbEnd;
}


/*****************************************************************************\
* ipp_SizeofIPPPI2 (Local Routine)
*
* Returns the size necessary to store a IPPPI2 struct.  This excludes the
* DEVMODE and SECURITYDESCRIPTOR fields.
*
\*****************************************************************************/
DWORD ipp_SizeofIPPPI2(
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp)
{
    DWORD  cCnt;
    DWORD  idx;
    DWORD  cbSize;
    LPTSTR lpszStr;
    //
    // Default Size.
    //
    cbSize = 0;

    //
    // Get the size necessary for PRINTER_INFO_2 structure.
    //
    if (lppi2) {

        cCnt = ((sizeof(s_PI2Off) / sizeof(s_PI2Off[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lppi2) + s_PI2Off[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }

    //
    // Get the size necessary for PRINTER_INFO_IPP structure.
    //
    if (lpipp) {

       cCnt = ((sizeof(s_IPPOff) / sizeof(s_IPPOff[0])) - 1);

       for (idx = 0; idx < cCnt; idx++) {

           lpszStr = *(LPTSTR*)(((LPBYTE)lpipp) + s_IPPOff[idx]);

           cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
       }
   }

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeofIPPJI2 (Local Routine)
*
* Returns the size necessary to store a IPPJI2 struct.  This excludes the
* DEVMODE and SECURITYDESCRIPTOR fields.
*
\*****************************************************************************/
DWORD ipp_SizeofIPPJI2(
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp)
{
    DWORD  cCnt;
    DWORD  idx;
    DWORD  cbSize;
    LPTSTR lpszStr;

    //
    // Default Size.
    //
    cbSize = 0;

    //
    // Get the size necessary for JOB_INFO_2 structure.
    //
    if (lpji2) {

        cCnt = ((sizeof(s_JI2Off) / sizeof(s_JI2Off[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lpji2) + s_JI2Off[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }

    //
    // Get the size necessary for JOB_INFO_IPP structure.
    //
    if (lpipp) {

        cCnt = ((sizeof(s_IPJOff) / sizeof(s_IPJOff[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lpipp) + s_IPJOff[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }

    return cbSize;
}


/*****************************************************************************\
* ipp_BuildPI2 (Local Routine)
*
* Builds a IPPPI2 struct from PRINTER_INFO_2 and PRINTER_INFO_IPP.
*
\*****************************************************************************/
LPBYTE ipp_BuildPI2(
    LPIPPPI2           lppi,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp,
    LPBYTE             lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  aszSrc[(sizeof(IPPPI2) / sizeof(LPTSTR))];

    //
    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc, sizeof(aszSrc));
    ZeroMemory(lppi  , sizeof(IPPPI2));

    //
    // Copy fixed values.
    //
    if (lppi2) {

        lppi->pi2.Attributes      = lppi2->Attributes;
        lppi->pi2.Priority        = lppi2->Priority;
        lppi->pi2.DefaultPriority = lppi2->DefaultPriority;
        lppi->pi2.StartTime       = lppi2->StartTime;
        lppi->pi2.UntilTime       = lppi2->UntilTime;
        lppi->pi2.Status          = lppi2->Status;
        lppi->pi2.cJobs           = lppi2->cJobs;
        lppi->pi2.AveragePPM      = lppi2->AveragePPM;
     }


    lppi->ipp.dwPowerUpTime       = (lpipp ? lpipp->dwPowerUpTime : 0);
    //
    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = (lppi2 ? lppi2->pServerName     : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPrinterName    : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pShareName      : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPortName       : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pDriverName     : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pComment        : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pLocation       : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lppi2 ? lppi2->pSepFile        : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPrintProcessor : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pDatatype       : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pParameters     : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpipp ? lpipp->pPrnUri         : NULL);
    *lpszSrc++ = (lpipp ? lpipp->pUsrName        : NULL);

    return ipp_PackStrings(aszSrc, (LPBYTE)lppi, s_IPPPI2Offs, lpbEnd);
}


/*****************************************************************************\
* ipp_BuildJI2 (Local Routine)
*
* Builds a IPPJI2 struct from JOB_INFO_2 and JOB_INFO_IPP.
*
\*****************************************************************************/
LPBYTE ipp_BuildJI2(
    LPIPPJI2       lpji,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp,
    LPBYTE         lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];
    //
    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc, sizeof(aszSrc));
    ZeroMemory(lpji, sizeof(IPPJI2));

    //
    // Copy fixed values.
    //
    if (lpji2) {

        lpji->ji2.JobId        = lpji2->JobId;
        lpji->ji2.Status       = lpji2->Status;
        lpji->ji2.Priority     = lpji2->Priority;
        lpji->ji2.Position     = lpji2->Position;
        lpji->ji2.StartTime    = lpji2->StartTime;
        lpji->ji2.UntilTime    = lpji2->UntilTime;
        lpji->ji2.TotalPages   = lpji2->TotalPages;
        lpji->ji2.Size         = lpji2->Size;
        lpji->ji2.Time         = lpji2->Time;
        lpji->ji2.PagesPrinted = lpji2->PagesPrinted;
        lpji->ji2.StartTime    = lpji2->StartTime;

        CopyMemory(&lpji->ji2.Submitted, &lpji2->Submitted, sizeof(SYSTEMTIME));
    }

    //
    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = (lpji2 ? lpji2->pPrinterName    : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pMachineName    : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pUserName       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDocument       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pNotifyName     : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDatatype       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pPrintProcessor : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pParameters     : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDriverName     : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpji2 ? lpji2->pStatus         : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpipp ? lpipp->pPrnUri         : NULL);
    *lpszSrc++ = (lpipp ? lpipp->pJobUri         : NULL);

    return ipp_PackStrings(aszSrc, (LPBYTE)lpji, s_IPPJI2Offs, lpbEnd);
}


/*****************************************************************************\
* ipp_GetJobCount (Local Routine)
*
* Returns the total number of jobs in an enumerated GETJOB response.
*
\*****************************************************************************/
DWORD ipp_GetJobCount(
    LPBYTE lpbHdr,
    DWORD  cbHdr)
{
    DWORD  cbIdx;
    LPBYTE lpbTag;
    DWORD  cJobs = 0;
   
    //
    // Position the tag at the start of the header.
    //
    lpbTag = lpbHdr + IPP_SIZEOFHDR;


    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {
        //
        // If we hit a job-deliminator, then we have a job-info item.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB)
            cJobs++;

        //
        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpbHdr, &cbIdx, cbHdr);
    }

    return cJobs;
}


/*****************************************************************************\
* ipp_IppToW32 (Local Routine - Client/Server)
*
* Converts an Ipp-Header to a W32-Structure.
*
\*****************************************************************************/
DWORD ipp_IppToW32(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    DWORD        cbIdx;
    DWORD        dwCmd;
    IPPJI2       ji;
    IPPPI2       pi;
    PIPPREQ_ALL  pr;
    UINT         uType = IPPTYPE_UNKNOWN;
    DWORD        dwRet = WEBIPP_FAIL;

    //
    // Position the tag at the Tag/Attributes and fetch the information
    // for the request.
    //
    cbIdx = IPP_SIZEOFHDR;

    switch (lpObj->wReq) {

    case IPP_REQ_PRINTJOB:
    case IPP_REQ_VALIDATEJOB:
    case IPP_REQ_GETJOB:
    case IPP_REQ_CANCELJOB:
    case IPP_REQ_PAUSEJOB:
    case IPP_REQ_RESUMEJOB:
    case IPP_REQ_RESTARTJOB:
    case IPP_REQ_ENUJOB:
        ZeroMemory(&ji, sizeof(IPPJI2));
        ji.ipp.cJobs = IPP_GETJOB_ALL;

        ipp_GetIPPJI2(lpObj->lpIppHdr + IPP_SIZEOFHDR, &ji, &cbIdx, lpObj);

        uType = IPPTYPE_JOB;
        break;

    case IPP_REQ_GETPRN:
    case IPP_REQ_PAUSEPRN:
    case IPP_REQ_CANCELPRN:
    case IPP_REQ_RESUMEPRN:
        ZeroMemory(&pi, sizeof(IPPPI2));
        ipp_GetIPPPI2(lpObj->lpIppHdr + IPP_SIZEOFHDR, &pi, &cbIdx, lpObj);

        uType = IPPTYPE_PRT;
        break;

    case IPP_REQ_FORCEAUTH:
        uType = IPPTYPE_AUTH;
        break;
    }

    //
    // If a failure occured, then there's no need to proceed.
    //
    if (ERROR_RANGE(lpObj->wError))
        goto EndCvt;

    //
    // Initialize any default-values, that may have been overlooked
    // in the request-stream.
    //
    switch (uType) {

    case IPPTYPE_JOB:

        if (ji.ji2.pUserName == NULL)
            ji.ji2.pUserName = webAllocStr(s_szUnknown);

        if (ji.ji2.pDocument == NULL)
            ji.ji2.pDocument = webAllocStr(s_szUnknown);
        break;

    case IPPTYPE_PRT:

        if (pi.pi2.pPrinterName == NULL)
            pi.pi2.pPrinterName = webAllocStr(s_szUnknown);
        break;
    }

    //
    // Build the request structure based upon the request command.
    //
    switch (lpObj->wReq) {

    case IPP_REQ_PRINTJOB:
        pr = (PIPPREQ_ALL)WebIppCreatePrtJobReq(FALSE, ji.ji2.pUserName, ji.ji2.pDocument, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_VALIDATEJOB:
        pr = (PIPPREQ_ALL)WebIppCreatePrtJobReq(TRUE, ji.ji2.pUserName, ji.ji2.pDocument, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_ENUJOB:
        pr = (PIPPREQ_ALL)WebIppCreateEnuJobReq(ji.ipp.cJobs, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_CANCELJOB:
    case IPP_REQ_PAUSEJOB:
    case IPP_REQ_RESUMEJOB:
    case IPP_REQ_RESTARTJOB:
        dwCmd = ipp_MapReqToJobCmd(lpObj->wReq);
        pr = (PIPPREQ_ALL)WebIppCreateSetJobReq(ji.ji2.JobId, dwCmd, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_GETJOB:
        pr = (PIPPREQ_ALL)WebIppCreateGetJobReq(ji.ji2.JobId, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_GETPRN:
        pr = (PIPPREQ_ALL)WebIppCreateGetPrnReq(0, pi.ipp.pPrnUri);
        break;

    case IPP_REQ_PAUSEPRN:
    case IPP_REQ_CANCELPRN:
    case IPP_REQ_RESUMEPRN:
        dwCmd = ipp_MapReqToPrnCmd(lpObj->wReq);
        pr = (PIPPREQ_ALL)WebIppCreateSetPrnReq(dwCmd, pi.ipp.pUsrName, pi.ipp.pPrnUri);
        break;

    case IPP_REQ_FORCEAUTH:
        pr = (PIPPREQ_AUTH)WebIppCreateAuthReq();
        break;

    default:
        pr = NULL;
        break;
    }

    //
    // Set the return values.
    //
    if (pr) {

        *lplpRawHdr = (LPBYTE)pr;
        *lpcbRawHdr = pr->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


EndCvt:
    //
    // Cleanup.
    //
    switch (uType) {

    case IPPTYPE_JOB:
        ipp_FreeIPPJI2(&ji);
        break;

    case IPPTYPE_PRT:
        ipp_FreeIPPPI2(&pi);
        break;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_W32ToIpp (Local Routine - Client/Server)
*
* Converts a W32 information to an IPP Header (both request and responses).
*
\*****************************************************************************/
DWORD ipp_W32ToIpp(
    WORD       wReq,
    LPREQINFO  lpri,
    LPBYTE     lpbData,
    LPIPPATTRX pSnd,
    DWORD      cSnd,
    LPBYTE*    lplpIppHdr,
    LPDWORD    lpcbIppHdr)
{
    LPIPPRET_ENUJOB pej;
    LPBYTE          lpIppHdr;
    LPBYTE          lpIppPtr;
    DWORD           cbIppHdr;
    LPIPPJI2        lpji;
    DWORD           cUns;
    DWORD           idx;
    DWORD           cbSize;
    DWORD           dwRet;
    DWORD           dwState;
    DWORD           cbUns;
    WORD            wOut;
    LPIPPATTRY      pAtr = NULL;
    LPIPPATTRY      pUns = NULL;

    //
    // Zero out our return pointer/count.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;

    //
    // Is this a request or response.
    //
    if (wReq & IPP_RESPONSE) {

        if (((LPIPPRET_ALL)lpbData)->wRsp == IPPRSP_SUCCESS) {

            wOut = ((lpri->pwlUns && lpri->pwlUns->Count()) ? IPPRSP_SUCCESS1 : IPPRSP_SUCCESS);

        } else {

            wOut = ((LPIPPRET_ALL)lpbData)->wRsp;
        }

    } else {

        wOut = wReq;
    }

    //
    // Minimum header size.
    //
    cbIppHdr = ipp_SizeHdr(lpri->cpReq) + IPP_SIZEOFTAG;

    // 
    // Treat the EnumJob response differently from the others, since this
    // returns a dynamic list of jobs.
    //
    if (wReq == IPP_RET_ENUJOB) {
        //
        // Build the unsupported-attributes if there
        // are any.
        //
        cbUns = 0;
        pUns  = ipp_AllocUnsVals(lpri->pwlUns, &cUns, &cbUns);


        pej = (PIPPRET_ENUJOB)lpbData;

        cbSize = cbIppHdr +
                 cbUns    +
                 ((pej->cItems && pej->cbItems) ? (3 * pej->cbItems) : 0);

        if (lpIppHdr = (LPBYTE)webAlloc(cbSize)) {

            cbIppHdr += cbUns;
            lpIppPtr  = lpIppHdr;

            //
            // Output the ipp-stream.
            //
            ipp_WriteHead(&lpIppPtr, wOut, lpri->idReq, lpri->cpReq);
            ipp_WriteUnsVals(&lpIppPtr, pUns, cUns);


            for (idx = 0, lpji = pej->pItems; idx < pej->cItems; idx++) {

                dwState = ipp_IppToW32JobState(lpji[idx].ji2.Status);
                //
                // Check for any requested-attributes that include this job-entry.
                //
                if ((x_ChkReq(lpri->fReq, RA_JOBSCOMPLETED)   &&  (dwState & JOB_STATUS_PRINTED)) ||
                    (x_ChkReq(lpri->fReq, RA_JOBSUNCOMPLETED) && !(dwState & JOB_STATUS_PRINTED)) ||
                    (x_ChkReq(lpri->fReq, (RA_JOBSCOMPLETED | RA_JOBSUNCOMPLETED)) == FALSE)) {

                    if (pAtr = ipp_AllocAtrVals(wReq, lpri->fReq, lpri->cpReq, (LPBYTE)&lpji[idx], pSnd, cSnd, &cbIppHdr)) {

                        ipp_WriteAtrVals(wReq, lpri->fReq, &lpIppPtr, pSnd, pAtr, cSnd);

                        ipp_FreeAtrVals(pAtr, cSnd);
                    }
                }
            }

            ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);
        
            //
            // Set the return values for the IPP-Stream-Header
            // as well as the size.
            //
            dwRet = WEBIPP_OK;

            *lplpIppHdr = lpIppHdr;
            *lpcbIppHdr = cbIppHdr;

        } else {

            dwRet = WEBIPP_NOMEMORY;
        }

        ipp_FreeAtrVals(pUns, cUns);

    } else {

        if ((cSnd == 0) ||
            (pAtr = ipp_AllocAtrVals(wReq, lpri->fReq, lpri->cpReq, lpbData, pSnd, cSnd, &cbIppHdr))) {

            //
            // Build the unsupported-attributes if there
            // are any.
            //
            pUns = ipp_AllocUnsVals(lpri->pwlUns, &cUns, &cbIppHdr);

            //
            // Write the IPP-Stream.
            //
            if (lpIppHdr = (LPBYTE)webAlloc(cbIppHdr)) {

                lpIppPtr = lpIppHdr;

                ipp_WriteHead(&lpIppPtr, wOut, lpri->idReq, lpri->cpReq);
                ipp_WriteUnsVals(&lpIppPtr, pUns, cUns);
                ipp_WriteAtrVals(wReq, lpri->fReq, &lpIppPtr, pSnd, pAtr, cSnd);
                ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);

                //
                // Set the return values for the IPP-Stream-Header
                // as well as the size.
                //
                dwRet = WEBIPP_OK;

                *lplpIppHdr = lpIppHdr;
                *lpcbIppHdr = cbIppHdr;

            } else {

                dwRet = WEBIPP_NOMEMORY;
            }

            if (pUns)
            {
                ipp_FreeAtrVals(pUns, cUns);
            }

            if (pAtr)
            {
                ipp_FreeAtrVals(pAtr, cSnd);
            }


        } else {

            dwRet = WEBIPP_NOMEMORY;
        }
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToFailure (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_ALL  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToFailure(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_ALL pbr;
    WORD        wRsp;
    BOOL        bRet;
    DWORD       dwRet;

    //
    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);
    bRet = SUCCESS_RANGE(wRsp);

    //
    // Build the response structure.
    //
    if (pbr = WebIppCreateBadRet(wRsp, bRet)) {

        *lplpRawHdr = (LPBYTE)pbr;
        *lpcbRawHdr = pbr->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToJobRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_JOB.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToJobRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    LPBYTE       lpbTag;
    PIPPRET_JOB  pj;
    WORD         wRsp;
    IPPJI2       ji;
    DWORD        cbIdx;
    BOOL         bRet;
    DWORD        dwRet;
    BOOL         bValidate = FALSE;

    //
    // Set our default-settings necessary for our PIPPRET_JOB.
    //
    ZeroMemory(&ji, sizeof(IPPJI2));

    //
    // Position the tag at the Tag/Attributes.
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

    //
    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);

    //
    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);

    //
    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {
        //
        // Look for a IPP_TAG_DEL_JOB to indicate we have a job-info
        // item.  Otherwise, skip to the next attribute.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB) {
            //
            // Since were currently at a deliminator, we need to get to
            // the next for the start of the job.
            //
            if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr)) {

                lpbTag = ipp_GetIPPJI2(lpbTag, &ji, &cbIdx, lpObj);
            }

        } else {

            lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
        }
    }

    //
    // Determine the correct return-code based upon the request response.
    //
    switch (lpObj->wReq) {

    case IPP_RET_PRINTJOB:
        bRet = (SUCCESS_RANGE(wRsp) ? (BOOL)ji.ji2.JobId : FALSE);
        break;

    case IPP_RET_VALIDATEJOB:
        bValidate = TRUE;
        //
        // Fall Through.
        //

    default:
        bRet = SUCCESS_RANGE(wRsp);
        break;
    }

    //
    // Build the response structure.
    //
    if (pj = WebIppCreateJobRet(wRsp, bRet, bValidate, &ji.ji2, &ji.ipp)) {

        *lplpRawHdr = (LPBYTE)pj;
        *lpcbRawHdr = pj->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    ipp_FreeIPPJI2(&ji);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToPrnRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_PRN.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToPrnRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_PRN pp;
    IPPPI2      pi;
    WORD        wRsp;
    LPBYTE      lpbTag;
    LPBYTE      lpbEnd;
    DWORD       cbIdx;
    DWORD       idx;
    DWORD       dwRet;

    //
    // Set our default-settings necessary for our PIPPRET_PRN.
    //
    ZeroMemory(&pi, sizeof(IPPPI2));

    //
    // Position the tag at the Tag/Attributes.
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

    //
    // Pull out response code.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);

    //
    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);

    //
    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {
        //
        // Look for a IPP_TAG_DEL_PRINTER to indicate we have a printer-info
        // item.  Otherwise, skip to the next attribute.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_PRINTER) {
            //
            // Since were currently at a deliminator, we need to get to
            // the next for the start of the job.
            //
            if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr))
                lpbTag = ipp_GetIPPPI2(lpbTag, &pi, &cbIdx, lpObj);

        } else {

            lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
        }
    }

    //
    // If none is specified for the pertinent information, then
    // use a default-str.
    //
    if (pi.ipp.pPrnUri == NULL)
        pi.ipp.pPrnUri = webAllocStr(s_szUnknown);

    if (pi.ipp.pUsrName == NULL)
        pi.ipp.pUsrName = webAllocStr(s_szUnknown);

    if (pi.pi2.pPrinterName == NULL)
        pi.pi2.pPrinterName = webAllocStr(s_szUnknown);

    if (pi.pi2.pDriverName == NULL)
        pi.pi2.pDriverName = webAllocStr(s_szUnknown);

    //
    // Build the response structure.
    //
    pp = WebIppCreatePrnRet(wRsp, SUCCESS_RANGE(wRsp), &pi.pi2, &pi.ipp);

    if (pp != NULL) {

        *lplpRawHdr = (LPBYTE)pp;
        *lpcbRawHdr = pp->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    ipp_FreeIPPPI2(&pi);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToEnuRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_ENUJOB.
*
\*****************************************************************************/
DWORD ipp_IppToEnuRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_ENUJOB pgj;
    LPIPPJI2       lpjiSrc;
    LPIPPJI2       lpjiDst;
    WORD           wRsp;
    DWORD          cJobs;
    DWORD          cbJobs;
    LPBYTE         lpbTag;
    LPBYTE         lpbEnd;
    DWORD          cbIdx;
    DWORD          idx;
    DWORD          dwRet;

    //
    // Set our default-settings necessary for our PIPPRET_ENUJOB.
    //
    cJobs   = 0;
    cbJobs  = 0;
    lpjiDst = NULL;

    //
    // Get the response-code.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);

    //
    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);

    //
    // See if we have jobs to enumerate.
    //
    if (cJobs = ipp_GetJobCount(lpObj->lpIppHdr, lpObj->cbIppHdr)) {

        if (lpjiSrc = (LPIPPJI2)webAlloc(cJobs * sizeof(IPPJI2))) {
            //
            // Get the job-info.
            //
            lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

            for (idx = 0, cbIdx = IPP_SIZEOFHDR; lpbTag && (idx < cJobs); ) {
                //
                // Look for a IPP_TAG_DEL_JOB to indicate we have a job-info
                // item.  Otherwise, skipp to the next attribute.
                //
                if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB) {
                    //
                    // Since were currently at a deliminator, we need to get to
                    // the next for the start of the job.
                    //
                    if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr))
                        lpbTag = ipp_GetIPPJI2(lpbTag, &lpjiSrc[idx++], &cbIdx, lpObj);

                } else {

                    lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
                }
            }
            
            //
            // Get storage necessary for packed IPPJI2 structures.
            //
            cbJobs = (cJobs * sizeof(IPPJI2));

            for (idx = 0; idx < cJobs; idx++)
                cbJobs += ipp_SizeofIPPJI2(&lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp);

            //
            // Allocate an array of JI2 structs to contain our
            // enumeration.
            //
            if (lpjiDst = (LPIPPJI2)webAlloc(cbJobs)) {
                //
                // For each job-item, initialize.
                //
                lpbEnd = ((LPBYTE)lpjiDst) + cbJobs;

                for (idx = 0; idx < cJobs; idx++)
                    lpbEnd = ipp_BuildJI2(&lpjiDst[idx], &lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp, lpbEnd);
            }

            //
            // Free the memory allocated for the job-item.
            //
            for (idx = 0; idx < cJobs; idx++)
                ipp_FreeIPPJI2(&lpjiSrc[idx]);

            webFree(lpjiSrc);
        }
    }

    //
    // Build the response structure.
    //
    pgj = WebIppCreateEnuJobRet(wRsp, SUCCESS_RANGE(wRsp), cbJobs, cJobs, lpjiDst);

    if (pgj != NULL) {

        *lplpRawHdr = (LPBYTE)pgj;
        *lpcbRawHdr = pgj->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    webFree(lpjiDst);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToAthRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_AUTH.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToAthRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_AUTH pfa;
    WORD         wRsp;
    BOOL         bRet;
    DWORD        dwRet;

    //
    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);
    bRet = SUCCESS_RANGE(wRsp);

    //
    // Build the response structure.
    //
    if (pfa = WebIppCreateAuthRet(wRsp, bRet)) {

        *lplpRawHdr = (LPBYTE)pfa;
        *lpcbRawHdr = pfa->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_FailureToIpp (Local Routine - Server)
*
* Converts a IPPRET_ALL to an IPP Header.  This is used for responding to
* clients that an operation is not supported, or returning a failure.
*
\*****************************************************************************/
DWORD ipp_FailureToIpp(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpbData,
    LPBYTE*   lplpIppHdr,
    LPDWORD   lpcbIppHdr)
{
    LPBYTE      lpIppHdr;
    LPBYTE      lpIppPtr;
    DWORD       cbIppHdr;
    DWORD       dwRet;
    DWORD       cbNamSta;
    DWORD       cbValSta;
    LPSTR       lputfNamSta;
    LPSTR       lputfValSta;
    PIPPRET_ALL pbr = (PIPPRET_ALL)lpbData;

    //
    // Zero out our return pointer/count.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;


    ipp_GetRspSta(pbr->wRsp, lpri->cpReq, &lputfNamSta, &cbNamSta, &lputfValSta, &cbValSta);

    //
    // Calculate the space necessary to generate our
    // IPP-Header-Stream.
    //
    cbIppHdr = ipp_SizeHdr(lpri->cpReq)                                                  +
               (lputfNamSta && lputfValSta ? ipp_SizeAttr(cbNamSta, cbValSta) : 0) +
               IPP_SIZEOFTAG;

    //
    // Allocate the header for the IPP-Stream.
    //
    if (lpIppHdr = (LPBYTE)webAlloc(cbIppHdr)) {
        //
        // Initialize the pointer which will keep track
        // of where we are in writing the IPP-Stream-Header.
        //
        lpIppPtr = lpIppHdr;

        //
        // Write out the IPP-Header-Stream.
        //
        ipp_WriteHead(&lpIppPtr, pbr->wRsp, lpri->idReq, lpri->cpReq);

        if (lputfNamSta && lputfValSta)
            ipp_WriteAttr(&lpIppPtr, IPP_TAG_CHR_TEXT, cbNamSta, lputfNamSta, cbValSta, lputfValSta);

        ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);

        //
        // Set the return values for the IPP-Stream-Header
        // as well as the size.
        //
        dwRet = WEBIPP_OK;

        *lplpIppHdr = lpIppHdr;
        *lpcbIppHdr = cbIppHdr;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    webFree(lputfNamSta);
    webFree(lputfValSta);

    return dwRet;
}


/*****************************************************************************\
* Ipp Send/Receive Table
*
*
*
\*****************************************************************************/
static IPPSNDRCV s_pfnIpp[] = {

    // Operation         Req Form Rsp Form Req X  Req X Size     Rsp X  Rsp X Size     Rsp (cli)
    // ----------------- -------- -------- ------ -------------- ------ -------------- ----------------
    //
    IPP_REQ_PRINTJOB   , s_FormA, s_FormC, s_PJQ, sizeof(s_PJQ), s_PJR, sizeof(s_PJR), ipp_IppToJobRet,
    IPP_REQ_VALIDATEJOB, s_FormA, s_FormE, s_PJQ, sizeof(s_PJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_CANCELJOB  , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_GETJOB     , s_FormB, s_FormC, s_GJQ, sizeof(s_GJQ), s_PJR, sizeof(s_PJR), ipp_IppToJobRet,
    IPP_REQ_ENUJOB     , s_FormB, s_FormF, s_EJQ, sizeof(s_EJQ), s_EJR, sizeof(s_EJR), ipp_IppToEnuRet,
    IPP_REQ_GETPRN     , s_FormB, s_FormD, s_GPQ, sizeof(s_GPQ), s_GPR, sizeof(s_GPR), ipp_IppToPrnRet,
    IPP_REQ_PAUSEJOB   , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_RESUMEJOB  , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_RESTARTJOB , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_PAUSEPRN   , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_RESUMEPRN  , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_CANCELPRN  , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_FORCEAUTH  , s_FormB, s_FormB, NULL , 0            , NULL , 0            , ipp_IppToAthRet
};


/*****************************************************************************\
* ipp_ValidateRcvReq (Local Routine)
*
* Returns whether the header is a supported request.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvReq(
    LPIPPOBJ lpObj)
{
    DWORD idx;
    DWORD cCnt;
    DWORD dwId = ipp_ReadDWord(lpObj->lpIppHdr, IPP_SIZEOFINT);
    WORD  wVer = ipp_ReadWord(lpObj->lpIppHdr, 0);
    WORD  wReq = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);

    //
    // First check that we are the correct-version, then proceed
    // to validate the request.
    //
    if (wVer == IPP_VERSION) {

        if (REQID_RANGE(dwId)) {
            //
            // See if we're in the range of response codes.
            //
            if (SUCCESS_RANGE(wReq) || ERROR_RANGE(wReq))
                return WEBIPP_OK;

            //
            // Validate supported operations.
            //
            cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

            for (idx = 0; idx < cCnt; idx++) {

                if (wReq == s_pfnIpp[idx].wReq)
                    return WEBIPP_OK;
            }

            lpObj->wError = IPPRSP_ERROR_400;

        } else {

            lpObj->wError = IPPRSP_ERROR_400;
        }

    } else {

        lpObj->wError = IPPRSP_ERROR_503;
    }

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* ipp_ValForm (Local Routine)
*
* Checks the tag-order for delimiters.
*
\*****************************************************************************/
BOOL ipp_ValForm(
    BYTE  bTag,
    PBYTE pbVal)
{
    DWORD idx;

    //
    // Look to see if the tag is one of our supported groups for
    // this request.
    //
    for (idx = 0; pbVal[idx] != (BYTE)0; idx++) {
        //
        // Is this a tag we're interested in.
        //
        if ((pbVal[idx] & 0x0F) == bTag) {

            // If we're already encountered this tag, then we
            // have an error (duplication of groups).
            //
            if ((pbVal[idx] & IPP_HIT) && !(pbVal[idx] & IPP_MULTIPLE))
                return FALSE;

            //
            // Otherwise, mark this group as hit.
            //
            pbVal[idx] |= IPP_HIT;

            return TRUE;

        } else {
            //
            // If this is not our tag, then we need to check
            // that this has at least been hit, or is an
            // optional group (verifies order).
            //
            if (IS_RANGE_DELIMITER(bTag))
                if (!(pbVal[idx] & (IPP_HIT | IPP_OPTIONAL)))
                    return FALSE;
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_AllocVal (Local Routine)
*
* Allocates a byte-array of tags that specify order.
*
\*****************************************************************************/
PBYTE ipp_AllocVal(
    WORD wReq)
{
    DWORD cCnt;
    DWORD idx;
    PBYTE pbGrp;
    PBYTE pbVal = NULL;

    //
    // Build the byte-array for validation of form.
    //
    cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

    for (idx = 0, pbGrp = NULL; idx < cCnt; idx++) {

        if (wReq == s_pfnIpp[idx].wReq) {

            pbGrp = s_pfnIpp[idx].pbReqForm;
            break;

        } else if (wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq)) {

            pbGrp = s_pfnIpp[idx].pbRspForm;
            break;
        }
    }


    if (pbGrp) {

        for (idx = 0; pbGrp[idx++] != (BYTE)0; );

        if (idx && (pbVal = (PBYTE)webAlloc(idx)))
            CopyMemory(pbVal, pbGrp, idx);
    }

    return pbVal;
}


/*****************************************************************************\
* ipp_ValidateRcvForm (Local Routine)
*
* Returns whether the header is well-formed.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvForm(
    LPIPPOBJ lpObj,
    LPDWORD  lpcbSize)
{
    LPBYTE lpbTag;
    BYTE   bTag;
    DWORD  cbIdx;
    PBYTE  pbVal;
    DWORD  dwRet = WEBIPP_MOREDATA;

    //
    // Zero out the return buffer.
    //
    *lpcbSize = 0;

    //
    // Allocate our array of tags that represent order.
    //
    if (pbVal = ipp_AllocVal(lpObj->wReq)) {
        //
        // Advance our pointer to the start of our attributes
        // in the byte-stream (i.e. skip version/request).
        //
        lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

        //
        // Check to be sure that our headers always start
        // off with an operations-attribute-tag.
        //
        if (IS_TAG_DELIMITER(ipp_ReadByte(lpbTag, 0))) {
            //
            // Traverse through the header, advancing through the attributes,
            // until the IPP_TAG_DEL_DATA is encountered.  This will verify
            // that we have a well-formed header.
            //
            for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {
                //
                // Get the tag.
                //
                bTag = ipp_ReadByte(lpbTag, 0);

                //
                // Only check our delimiter tags for this
                // validation.
                //
                if (IS_TAG_DELIMITER(bTag)) {

                    if (bTag == IPP_TAG_DEL_DATA) {

                        if (ipp_ValForm(bTag, pbVal)) {

                            *lpcbSize = (cbIdx + 1);

                            dwRet = WEBIPP_OK;

                            goto EndVal;

                        } else {

                            goto BadFrm;
                        }

                    } else {

                        if (ipp_ValForm(bTag, pbVal) == FALSE)
                            goto BadFrm;
                    }
                }

                //
                // Advance to next Tag.  This routine also increments
                // the (cbIdx) count.  If we run out of bytes in the
                // header before we can get to the next-tag, then this
                // will return NULL.
                //
                lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
            }

        } else {

BadFrm:
            lpObj->wError = IPPRSP_ERROR_400;

            dwRet = WEBIPP_FAIL;
        }

EndVal:
        webFree(pbVal);

    } else {

        lpObj->wError = IPPRSP_ERROR_505;

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvCharSet (Local Routine)
*
* Returns whether we support the character-set.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvCharSet(
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    LPBYTE    lpbTag;
    BYTE      bTag;
    DWORD     cbIdx;
    DWORD     dwRet = WEBIPP_FAIL;

    //
    // Advance our pointer to the start of our attributes
    // in the byte-stream (i.e. skip version/request).
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

    //
    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.  This will verify
    // that we have a well-formed header.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {

        bTag = ipp_ReadByte(lpbTag, 0);

        //
        // If we walked through the end of our stream, then
        // the stream does not contain character-set information.
        //
        if (IS_TAG_DELIMITER(bTag) && (bTag != IPP_TAG_DEL_OPERATION))
            break;

        //
        // If we are pointing at an attribute, then retrieve
        // it in a format we understand.
        //
        if (lpAttr = ipp_GetAttr(lpbTag, cbIdx, lpObj)) {
            //
            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName) {

                if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpObj->fState & IPPFLG_CHARSET) {

                        lpObj->wError = IPPRSP_ERROR_400;
                        dwRet         = WEBIPP_FAIL;

                    } else {

                        lpObj->fState |= IPPFLG_CHARSET;

                        if (lpAttr->cbValue > SIZE_CHARSET) {

                            lpObj->wError = IPPRSP_ERROR_409;

                        } else {

                            if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szUtf8) == 0) {

                                lpObj->uCPRcv = CP_UTF8;

                                dwRet = WEBIPP_OK;

                            } else if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szUsAscii) == 0) {

                                lpObj->uCPRcv = CP_ACP;

                                dwRet = WEBIPP_OK;

                            } else {

                                lpObj->wError = IPPRSP_ERROR_40D;
                            }
                        }
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;

        //
        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
    }

    if ((dwRet != WEBIPP_OK) && (lpObj->wError == IPPRSP_SUCCESS))
        lpObj->wError = IPPRSP_ERROR_400;

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvLang (Local Routine)
*
* Returns whether we support the natural-language.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvLang(
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    LPBYTE    lpbTag;
    BYTE      bTag;
    DWORD     cbIdx;
    DWORD     dwRet = WEBIPP_FAIL;

    //
    // Advance our pointer to the start of our attributes
    // in the byte-stream (i.e. skip version/request).
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

    //
    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.  This will verify
    // that we have a well-formed header.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {

        bTag = ipp_ReadByte(lpbTag, 0);
        //
        // If we walked through the end of our stream, then
        // the stream does not contain natural-language information.
        //
        if (IS_TAG_DELIMITER(bTag) && (bTag != IPP_TAG_DEL_OPERATION))
            break;

        //
        // If we are pointing at an attribute, then retrieve
        // it in a format we understand.
        //
        if (lpAttr = ipp_GetAttr(lpbTag, cbIdx, lpObj)) {
            //
            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName) {

                if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpObj->fState & IPPFLG_NATLANG) {

                        lpObj->wError = IPPRSP_ERROR_400;
                        dwRet         = WEBIPP_FAIL;

                    } else {

                        lpObj->fState |= IPPFLG_NATLANG;

                        if (lpAttr->cbValue > SIZE_NATLANG) {

                            lpObj->wError = IPPRSP_ERROR_409;

                        } else {

                            if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szEnUS) == 0) {

                                dwRet = WEBIPP_OK;

                            } else {

                                dwRet = WEBIPP_OK;
                            }
                        }
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;

        //
        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
    }

    if ((dwRet != WEBIPP_OK) && (lpObj->wError == IPPRSP_SUCCESS))
        lpObj->wError = IPPRSP_ERROR_400;

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvHdr (Local Routine)
*
* Parses through the (lpbHdr) and returns whether it's a full (complete)
* header.  Essentially, this need only look through the byte-stream until
* it finds the IPP_TAG_DEL_DATA attribute.
*
* Returns the size of the header (in bytes).
*
\*****************************************************************************/
DWORD ipp_ValidateRcvHdr(
    LPIPPOBJ lpObj,
    LPDWORD  lpcbSize)
{
    LPBYTE lpbTag;
    DWORD  cbIdx;
    DWORD  cbSize;
    DWORD  dwRet;

    //
    // Initialize our return-size so that we are reporting
    // clean data.
    //
    *lpcbSize = 0;

    //
    // Make sure we have enough in our header to handle
    // the basic verification.
    //
    if (lpObj->cbIppHdr <= (IPP_SIZEOFHDR + IPP_SIZEOFTAG))
        return WEBIPP_MOREDATA;

    //
    // Set the request-type for the header.  This will help
    // us determine the appropriate conversion to the data-
    // structure.
    //
    lpObj->idReq = ipp_ReadDWord(lpObj->lpIppHdr, IPP_SIZEOFINT);

    //
    // Validate the fixed header values, then proceed with
    // other validation of the operational-attributes.
    //
    if ((dwRet = ipp_ValidateRcvReq(lpObj)) == WEBIPP_OK) {

        if ((dwRet = ipp_ValidateRcvForm(lpObj, &cbSize)) == WEBIPP_OK) {

            if ((dwRet = ipp_ValidateRcvCharSet(lpObj)) == WEBIPP_OK) {

                if ((dwRet = ipp_ValidateRcvLang(lpObj)) == WEBIPP_OK) {

                    *lpcbSize = cbSize;
                }
            }
        }
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_ConvertIppToW32 (Local Routine)
*
* This routine takes in an IPP stream-buffer and generates the appropriate
* structure in which NT-Spooler-API's can process.
*
* Returns the pointer to the converted-header as well as the bytes that
* this converted header occupies.
*
\*****************************************************************************/
DWORD ipp_ConvertIppToW32(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    DWORD cCnt;
    DWORD idx;

    //
    // Perform the request.  If the request has NULL function-pointers, then
    // the request/response is not supported.
    //
    cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

    for (idx = 0; idx < cCnt; idx++) {
        //
        // Check for request
        //
        if (lpObj->wReq == s_pfnIpp[idx].wReq)
            return ipp_IppToW32(lpObj, lplpRawHdr, lpcbRawHdr);

        //
        // Check for response
        //
        if (lpObj->wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq))
            return s_pfnIpp[idx].pfnRcvRet(lpObj, lplpRawHdr, lpcbRawHdr);

    }

    lpObj->wError = IPPRSP_ERROR_501;

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* WebIppSndData
*
* This routine takes the (lpRawHdr) and packages it up in IPP 1.1 protocol
* and returns the pointer to the Ipp-Header.
*
* Parameters:
* ----------
* dwReq      - Describes the type of IPP-Header to package.
* lpRawHdr   - Input pointer to raw (spooler) data-structure.
* cbRawHdr   - Input byte-count of (lpRawHdr).
* lplpIppHdr - Output pointer to IPP-Header stream.
* lpcbIppHdr - Output to byte-count of Ipp-Header stream (lplpIppHdr).
*
\*****************************************************************************/
DWORD WebIppSndData(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpRawHdr,
    DWORD     cbRawHdr,
    LPBYTE*   lplpIppHdr,
    LPDWORD   lpcbIppHdr)
{
    DWORD      cCnt;
    DWORD      idx;
    LPIPPATTRX pSnd;
    DWORD      cSnd;

    //
    // Zero out the return pointers/sizes.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;

    //
    // Make sure the code-pages are something we can support.
    //
    if ((lpri->cpReq == CP_ACP) || (lpri->cpReq == CP_UTF8)) {
        //
        // Perform the request.  If the request has NULL function-pointers,
        // then the request/response is not supported.
        //
        cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

        for (idx = 0; idx < cCnt; idx++) {
            //
            // Check for request.
            //
            if (wReq == s_pfnIpp[idx].wReq) {

                pSnd = s_pfnIpp[idx].paReq;
                cSnd = s_pfnIpp[idx].cbReq / sizeof(IPPATTRX);

                return ipp_W32ToIpp(wReq, lpri, lpRawHdr, pSnd, cSnd, lplpIppHdr, lpcbIppHdr);
            }

            //
            // Check for response.
            //
            if (wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq)) {
                //
                // Check response for any fail-cases.
                //
                if (SUCCESS_RANGE(((LPIPPRET_ALL)lpRawHdr)->wRsp)) {

                    pSnd = s_pfnIpp[idx].paRsp;
                    cSnd = s_pfnIpp[idx].cbRsp / sizeof(IPPATTRX);

                    return ipp_W32ToIpp(wReq, lpri, lpRawHdr, pSnd, cSnd, lplpIppHdr, lpcbIppHdr);
                }

                break;
            }
        }

        //
        // If this was sent by our server, then we want to reply to the client
        // with an ipp-stream.
        //
        return ipp_FailureToIpp(wReq, lpri, lpRawHdr, lplpIppHdr, lpcbIppHdr);
    }

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* WebIppRcvOpen
*
* This routine creates an IPP-state-object which parses IPP stream-data.  The
* parameter (dwReq) specifies which request we expect the stream to provide.
*
* We allocate a default-size buffer to contain the header.  If more memory
* is necessary, then it is reallocated to append the data.
*
\*****************************************************************************/
HANDLE WebIppRcvOpen(
    WORD wReq)
{
    LPIPPOBJ lpObj;


    if (lpObj = (LPIPPOBJ)webAlloc(sizeof(IPPOBJ))) {

        if (lpObj->pwlUns = (PWEBLST)new CWebLst()) {

            lpObj->wReq     = wReq;
            lpObj->wError   = IPPRSP_SUCCESS;
            lpObj->idReq    = 0;
            lpObj->uCPRcv   = CP_UTF8;
            lpObj->fState   = 0;
            lpObj->cbIppHdr = 0;
            lpObj->cbIppMax = IPP_BLOCK_SIZE;
            lpObj->lpRawDta = NULL;

            x_SetReq(lpObj->fReq, (wReq == IPP_REQ_ENUJOB ? IPP_REQENU : IPP_REQALL));

            //
            // Allocate a default buffer-size to hold the IPP
            // header.  This may not be large enough to hold
            // the complete header so we reserve the right to
            // reallocate it until it contains the entire header.
            //
            if (lpObj->lpIppHdr = (LPBYTE)webAlloc(lpObj->cbIppMax)) {

                return (HANDLE)lpObj;
            }

            delete lpObj->pwlUns;
        }

        webFree(lpObj);
    }

    return NULL;
}


/*****************************************************************************\
* WebIppRcvData
*
* This routine takes in IPP stream-data and builds a complete IPP-Header.  It
* is possible that the header-information is not provided in one chunk of
* stream-data.  Therefore, we will not return the converted header information
* until our header is complete.
*
* Once the header is complete, it's returned in the output-buffer in the
* format that the caller can utilized in spooler-related calls.
*
* Not only does this handle the header, but it is also used to process raw
* stream-data which is returned unmodified to the caller.  In the case that
* we encounter data during the processing of the IPP-Header, we need to
* return an allocated buffer pointing to DWORD-Aligned bits.
*
* Parameters:
* ----------
* hObj       - Handle to the Ipp-Parse-Object.
* lpIppDta   - Input pointer to ipp-stream-data.  This is header and/or data.
* cbIppDta   - Input byte-count contained in the (lpIppData).
* lplpRawHdr - Output pointer to spooler-define (raw) structure.
* lpcbRawHdr - Output pointer to byte-count in (lplpRawHdr).
* lplpRawDta - Output pointer to data-stream.
* lpcbRawDta - Output pointer to byte-count in (lplpRawDta).
*
* Returns:
* -------
* WEBIPP_OK           - Information in lplpHdr or lplpData is valid.
* WEBIPP_FAIL         - Failed in validation.  Use WebIppGetError.
* WEBIPP_MOREDATA     - Needs more data to complete header.
* WEBIPP_BADHANDLE    - Ipp-Object-Handle is invalid.
* WEBIPP_NOMEMORY     - Failed allocation request (out-of-memory).
*
\*****************************************************************************/
DWORD WebIppRcvData(
    HANDLE  hObj,
    LPBYTE  lpIppDta,
    DWORD   cbIppDta,
    LPBYTE* lplpRawHdr,
    LPDWORD lpcbRawHdr,
    LPBYTE* lplpRawDta,
    LPDWORD lpcbRawDta)
{
    LPIPPOBJ lpObj;
    LPBYTE   lpNew;
    DWORD    cbSize;
    DWORD    cbData;
    DWORD    cBlks;
    DWORD    dwRet;

    //
    // Initialize the output pointers to NULL.  We return two distinct
    // references since it is possible that the buffer passed in contains
    // both header and data.
    //
    *lplpRawHdr = NULL;
    *lpcbRawHdr = 0;
    *lplpRawDta = NULL;
    *lpcbRawDta = 0;

    //
    // Process the stream-data.
    //
    if (lpObj = (LPIPPOBJ)hObj) {
        //
        // If our header is complete, then the stream is raw-data meant
        // to be return directly.  In this case we only need to return the
        // data-stream passed in.
        //
        // Otherwise, the default-case is that we are building our header
        // from the stream-data.
        //
        if (lpObj->fState & IPPFLG_VALID) {
            //
            // Free up the memory occupied by our header (only done on
            // the first hit of this block).  Since we aren't using
            // this anymore during the processing of the stream, we
            // shouldn't occupy any more memory than necessary.
            //
            if (lpObj->lpIppHdr) {

                webFree(lpObj->lpIppHdr);
                lpObj->lpIppHdr = NULL;
                lpObj->cbIppHdr = 0;

                //
                // Likewise, if we had need of a temporary data-buffer
                // to hold aligned-bits, then we need to free this up
                // as well.
                //
                webFree(lpObj->lpRawDta);
                lpObj->lpRawDta = NULL;
            }

            //
            // Return the data-stream passed in.
            //
            dwRet       = WEBIPP_OK;
            *lplpRawDta = lpIppDta;
            *lpcbRawDta = cbIppDta;

        } else {
            //
            // Check to see if our buffer can accomodate the
            // size of the buffer being passed in.  If not, realloc
            // a new buffer to accomodate the new chunk.
            //
            if ((lpObj->cbIppHdr + cbIppDta) >= lpObj->cbIppMax) {
                //
                // Determine the number of memory-blocks that we
                // need to hold the (cbData) coming in.
                //
                cBlks = (cbIppDta / IPP_BLOCK_SIZE) + 1;

                cbSize = lpObj->cbIppMax + (IPP_BLOCK_SIZE * cBlks);

                lpNew = (LPBYTE)webRealloc(lpObj->lpIppHdr,
                                           lpObj->cbIppMax,
                                           cbSize);

                if (lpNew != NULL) {

                    lpObj->lpIppHdr = lpNew;
                    lpObj->cbIppMax = cbSize;

                } else {

                    return WEBIPP_NOMEMORY;
                }
            }

            //
            // Copy/Append the stream-data to our header-buffer.
            //
            memcpy(lpObj->lpIppHdr + lpObj->cbIppHdr, lpIppDta, cbIppDta);
            lpObj->cbIppHdr += cbIppDta;

            //
            // Validate the header.  If this is successful, then we have
            // a well-formed-header.  Otherwise, we need to request
            // more data from the caller.  This returns the actual size
            // of the header in (cbSize).
            //
            if ((dwRet = ipp_ValidateRcvHdr(lpObj, &cbSize)) == WEBIPP_OK) {
                //
                // Convert the IPP-Heade to a structure (stream)
                // that the caller understands (depends on dwReq).
                //
                dwRet = ipp_ConvertIppToW32(lpObj, lplpRawHdr, lpcbRawHdr);

                if (dwRet == WEBIPP_OK) {
                    //
                    // The validation returns the actual-size occupied by
                    // the header.  Therefore, if our (cbHdr) is larger, then
                    // the remaining information is pointing at data.
                    //
                    if (cbSize < lpObj->cbIppHdr) {

                        cbData = (lpObj->cbIppHdr - cbSize);

                        lpObj->lpRawDta = ipp_CopyAligned(lpObj->lpIppHdr + cbSize, cbData);

                        *lplpRawDta = lpObj->lpRawDta;
                        *lpcbRawDta = cbData;
                    }

                    //
                    // Set the flag indicating we have a full-header.  This
                    // assures that subsequent calls to this routine returns
                    // only the lpData.
                    //
                    lpObj->fState |= IPPFLG_VALID;
                }
            }
        }

    } else {

        dwRet = WEBIPP_BADHANDLE;
    }

    return dwRet;
}


/*****************************************************************************\
* WebIppRcvClose
*
* This routine Frees up our IPP object.  This is called once the caller wishes
* to end the parsing/handling of ipp-stream-data.
*
\*****************************************************************************/
BOOL WebIppRcvClose(
    HANDLE hObj)
{
    LPIPPOBJ lpObj;


    if (lpObj = (LPIPPOBJ)hObj) {

        webFree(lpObj->lpIppHdr);
        webFree(lpObj->lpRawDta);

        delete lpObj->pwlUns;

        webFree(lpObj);

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* WebIppGetError
*
* This routine returns the specific error in the ipp-object.  This is called
* on a failure during the receive.
*
\*****************************************************************************/
WORD WebIppGetError(
    HANDLE hIpp)
{
    LPIPPOBJ lpObj;

    if (lpObj = (LPIPPOBJ)hIpp)
        return lpObj->wError;

    return IPPRSP_ERROR_500;
}


/*****************************************************************************\
* WebIppGetReqInfo
*
* This routine returns the request-info.
*
\*****************************************************************************/
BOOL WebIppGetReqInfo(
    HANDLE    hIpp,
    LPREQINFO lpri)
{
    LPIPPOBJ lpObj;


    if ((lpObj = (LPIPPOBJ)hIpp) && lpri) {

        lpri->idReq     = lpObj->idReq;
        lpri->cpReq     = lpObj->uCPRcv;
        lpri->pwlUns    = lpObj->pwlUns;
        lpri->bFidelity = (lpObj->fState & IPPFLG_USEFIDELITY);

        CopyMemory(lpri->fReq, lpObj->fReq, IPPOBJ_MASK_SIZE * sizeof(DWORD));

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* WebIppLeToRsp
*
* This routine returns an IPP-Response-Code from a Win32-LastError.
*
\*****************************************************************************/
WORD WebIppLeToRsp(
    DWORD dwLastError)
{
    DWORD idx;
    DWORD cErrors;

    if (dwLastError == ERROR_SUCCESS)
        return IPPRSP_SUCCESS;

    //
    // Lookup lasterror.
    //
    cErrors = sizeof(s_LEDef) / sizeof(s_LEDef[0]);

    for (idx = 0; idx < cErrors; idx++) {

        if (dwLastError == s_LEDef[idx].dwLE)
            return s_LEDef[idx].wRsp;
    }

    return IPPRSP_ERROR_500;
}


/*****************************************************************************\
* WebIppRspToLe
*
* This routine returns a Win32 LastError from an IPP-Response-Code.
*
\*****************************************************************************/
DWORD WebIppRspToLe(
    WORD wRsp)
{
    DWORD idx;
    DWORD cErrors;

    if (SUCCESS_RANGE(wRsp))
        return ERROR_SUCCESS;

    //
    // Lookup lasterror.
    //
    cErrors = sizeof(s_LEIpp) / sizeof(s_LEIpp[0]);

    for (idx = 0; idx < cErrors; idx++) {

        if (wRsp == s_LEIpp[idx].wRsp)
            return s_LEIpp[idx].dwLE;
    }

    return ERROR_INVALID_DATA;
}


/*****************************************************************************\
* WebIppCreatePrtJobReq
*
* Creates a IPPREQ_PRTJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_PRTJOB WebIppCreatePrtJobReq(
    BOOL    bValidate,
    LPCTSTR lpszUser,
    LPCTSTR lpszDoc,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_PRTJOB ppj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_PRTJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_PRTJOB, pDocument),
        offs(LPIPPREQ_PRTJOB, pUserName),
        offs(LPIPPREQ_PRTJOB, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_PRTJOB information.
    //
    cbSize = sizeof(IPPREQ_PRTJOB)    +
             webStrSize(lpszUser)     +
             webStrSize(lpszDoc)      +
             webStrSize(lpszPrnUri);

    //
    // Allocate the print-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (ppj = (PIPPREQ_PRTJOB)webAlloc(cbSize)) {

        ppj->cbSize    = cbSize;
        ppj->bValidate = bValidate;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszDoc;
        *lpszSrc++ = (LPTSTR)lpszUser;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)ppj, s_Offs, ((LPBYTE)ppj) + cbSize);
    }

    return ppj;
}


/*****************************************************************************\
* WebIppCreateGetJobReq
*
* Creates a IPPREQ_GETJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_GETJOB WebIppCreateGetJobReq(
    DWORD   idJob,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_GETJOB pgj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_GETJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_GETJOB, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_GETJOB information.
    //
    cbSize = sizeof(IPPREQ_GETJOB) + webStrSize(lpszPrnUri);

    //
    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgj = (PIPPREQ_GETJOB)webAlloc(cbSize)) {

        pgj->cbSize = cbSize;
        pgj->idJob  = idJob;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgj, s_Offs, ((LPBYTE)pgj) + cbSize);
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateSetJobReq
*
* Creates a IPPREQ_SETJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_SETJOB WebIppCreateSetJobReq(
    DWORD   idJob,
    DWORD   dwCmd,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_SETJOB psj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_SETJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_SETJOB, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_SETJOB information.
    //
    cbSize = sizeof(IPPREQ_SETJOB) + webStrSize(lpszPrnUri);

    //
    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (psj = (PIPPREQ_SETJOB)webAlloc(cbSize)) {

        psj->cbSize = cbSize;
        psj->idJob  = idJob;
        psj->dwCmd  = dwCmd;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)psj, s_Offs, ((LPBYTE)psj) + cbSize);
    }

    return psj;
}


/*****************************************************************************\
* WebIppCreateEnuJobReq
*
* Creates a IPPREQ_ENUJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_ENUJOB WebIppCreateEnuJobReq(
    DWORD   cJobs,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_ENUJOB pgj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_ENUJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_ENUJOB, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_ENUJOB information.
    //
    cbSize = sizeof(IPPREQ_ENUJOB) + webStrSize(lpszPrnUri);

    //
    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgj = (PIPPREQ_ENUJOB)webAlloc(cbSize)) {

        pgj->cbSize = cbSize;
        pgj->cJobs  = cJobs;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgj, s_Offs, ((LPBYTE)pgj) + cbSize);
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateSetPrnReq
*
* Creates a IPPREQ_SETPRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_SETPRN WebIppCreateSetPrnReq(
    DWORD   dwCmd,
    LPCTSTR lpszUsrName,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_SETPRN psp;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_SETPRN) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_SETPRN, pUserName),
        offs(LPIPPREQ_SETPRN, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_SETPRN information.
    //
    cbSize = sizeof(IPPREQ_SETPRN)    +
             webStrSize(lpszUsrName)  +
             webStrSize(lpszPrnUri);

    //
    // Allocate the set-prn-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (psp = (PIPPREQ_SETPRN)webAlloc(cbSize)) {

        psp->cbSize = cbSize;
        psp->dwCmd  = dwCmd;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszUsrName;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)psp, s_Offs, ((LPBYTE)psp) + cbSize);
    }

    return psp;
}


/*****************************************************************************\
* WebIppCreateGetPrnReq
*
* Creates a IPPREQ_GETPRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_GETPRN WebIppCreateGetPrnReq(
    DWORD   dwAttr,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_GETPRN pgp;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_GETPRN) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_GETPRN, pPrnUri),
        0xFFFFFFFF
    };

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_GETPRN information.
    //
    cbSize = sizeof(IPPREQ_GETPRN) + webStrSize(lpszPrnUri);

    //
    // Allocate the get-prt-attribute-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgp = (PIPPREQ_GETPRN)webAlloc(cbSize)) {

        pgp->cbSize = cbSize;
        pgp->dwAttr = dwAttr;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgp, s_Offs, ((LPBYTE)pgp) + cbSize);
    }

    return pgp;
}


/*****************************************************************************\
* WebIppCreateAuthReq
*
* Creates a IPPREQ_AUTH structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_AUTH WebIppCreateAuthReq(VOID)
{
    PIPPREQ_AUTH pfa;
    DWORD        cbSize;

    //
    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_AUTH information.
    //
    cbSize = sizeof(IPPREQ_AUTH);

    //
    // Allocate the request structure.
    //
    if (pfa = (PIPPREQ_AUTH)webAlloc(cbSize)) {

        pfa->cbSize = cbSize;
    }

    return pfa;
}


/*****************************************************************************\
* WebIppCreateJobRet
*
* Creates a IPPRET_JOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_JOB WebIppCreateJobRet(
    WORD           wRsp,
    BOOL           bRet,
    BOOL           bValidate,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp)
{
    PIPPRET_JOB pjr;
    DWORD       cbSize;

    //
    // Calculate our structure size.
    //
    cbSize = sizeof(IPPRET_JOB) + ipp_SizeofIPPJI2(lpji2, lpipp);

    //
    // Build our response.
    //
    if (pjr = (PIPPRET_JOB)webAlloc(cbSize)) {

        pjr->cbSize      = cbSize;
        pjr->dwLastError = WebIppRspToLe(wRsp);
        pjr->wRsp        = wRsp;
        pjr->bRet        = bRet;
        pjr->bValidate   = bValidate;

        ipp_BuildJI2(&pjr->ji, lpji2, lpipp, ((LPBYTE)pjr) + cbSize);
    }

    return pjr;
}


/*****************************************************************************\
* WebIppCreatePrnRet
*
* Creates a IPPRET_PRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_PRN WebIppCreatePrnRet(
    WORD               wRsp,
    BOOL               bRet,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp)
{
    PIPPRET_PRN ppr;
    DWORD       cbSize;

    //
    // Calculate our structure size.
    //
    cbSize = sizeof(IPPRET_PRN) + ipp_SizeofIPPPI2(lppi2, lpipp);

    //
    // Build our response.
    //
    if (ppr = (PIPPRET_PRN)webAlloc(cbSize)) {

        ppr->cbSize      = cbSize;
        ppr->dwLastError = WebIppRspToLe(wRsp);
        ppr->wRsp        = wRsp;
        ppr->bRet        = bRet;

        ipp_BuildPI2(&ppr->pi, lppi2, lpipp, ((LPBYTE)ppr) + cbSize);
    }

    return ppr;
}


/*****************************************************************************\
* WebIppCreateEnuJobRet
*
* Creates a IPPRET_ENUJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_ENUJOB WebIppCreateEnuJobRet(
    WORD     wRsp,
    BOOL     bRet,
    DWORD    cbJobs,
    DWORD    cJobs,
    LPIPPJI2 lpjiSrc)
{
    PIPPRET_ENUJOB pgj;
    LPIPPJI2       lpjiDst;
    LPBYTE         lpbEnd;
    DWORD          idx;
    DWORD          cbSize;

    cbSize = sizeof(IPPRET_ENUJOB) + ((cJobs && cbJobs && lpjiSrc) ? cbJobs : 0);

    if (pgj = (PIPPRET_ENUJOB)webAlloc(cbSize)) {

        pgj->cbSize      = cbSize;
        pgj->dwLastError = WebIppRspToLe(wRsp);
        pgj->wRsp        = wRsp;
        pgj->bRet        = bRet;
        pgj->cItems      = 0;
        pgj->cbItems     = 0;
        pgj->pItems      = NULL;


        if (cJobs && cbJobs && lpjiSrc) {
            //
            // Initialize defaults.
            //
            pgj->cItems  = cJobs;
            pgj->cbItems = cbJobs;
            pgj->pItems  = (LPIPPJI2)(((LPBYTE)pgj) + sizeof(IPPRET_ENUJOB));


            lpjiDst = pgj->pItems;
            lpbEnd  = ((LPBYTE)lpjiDst) + cbJobs;

            for (idx = 0; idx < cJobs; idx++) {

                lpbEnd = ipp_BuildJI2(&lpjiDst[idx], &lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp, lpbEnd);
            }
        }
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateBadRet
*
* Creates a IPPRET_ALL structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_ALL WebIppCreateBadRet(
    WORD wRsp,
    BOOL bRet)
{
    PIPPRET_ALL pra;
    DWORD       cbSize;

    cbSize = sizeof(IPPRET_ALL);

    if (pra = (PIPPRET_ALL)webAlloc(cbSize)) {

        pra->cbSize      = cbSize;
        pra->dwLastError = WebIppRspToLe(wRsp);
        pra->wRsp        = wRsp;
        pra->bRet        = bRet;
    }

    return pra;
}


/*****************************************************************************\
* WebIppCreateAuthRet
*
* Creates a IPPRET_AUTH structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_AUTH WebIppCreateAuthRet(
    WORD wRsp,
    BOOL bRet)
{
    return (PIPPRET_AUTH)WebIppCreateBadRet(wRsp, bRet);
}


/*****************************************************************************\
* WebIppFreeMem
*
* Free memory allocated through the WebIpp routines.
*
\*****************************************************************************/
BOOL WebIppFreeMem(
    LPVOID lpMem)
{
    return webFree(lpMem);
}


/*****************************************************************************\
* WebIppCvtJI2toIPPJI2
*
* Converts an array of JOB_INFO_2 structures to an array of IPPJI2 structures.
*
* This code is only called from inetsrv/spool.cxx. It was better to change the
* the buffer calculation here than in the calling function since IPPJI2 is a
* web printing only call. This will return the new required Job size in the
* cbJobs Parameter that is passed in.
*
\*****************************************************************************/
LPIPPJI2 WebIppCvtJI2toIPPJI2(
    LPCTSTR      lpszJobBase,
    LPDWORD      lpcbJobs,
    DWORD        cJobs,
    LPJOB_INFO_2 lpjiSrc)
{
    LPBYTE   lpbEnd;
    DWORD    idx;
    DWORD    cbSize;
    DWORD    cbUri;
    LPIPPJI2 lpjiDst = NULL;

    WEB_IPP_ASSERT(lpcbJobs);

    if (*lpcbJobs && cJobs && lpjiSrc) {
        //
        // For each job, we need to add enough to hold the extra
        // information.
        //
        cbUri  = 2*(webStrSize(lpszJobBase) + sizeof(DWORD)) * cJobs;
        //
        // There can be two of these strings allocated, one for the JobUri and the 
        // other for the Printer Uri
        //
        cbSize = (sizeof(IPPJI2) - sizeof(JOB_INFO_2)) * cJobs + *lpcbJobs + cbUri;
        //
        // cbJobs already contains the correct size for the JOB_INFO_2 structure and its
        // strings we need the space for the JOB_INFO_IPP part of the structure plus the
        // extra strings that will be added.
        //

        *lpcbJobs = cbSize;  // Pass the required size back


        if (lpjiDst = (LPIPPJI2)webAlloc(cbSize)) {
            //
            // Position string end at the end of our buffer.
            //
            lpbEnd = ((LPBYTE)lpjiDst) + cbSize;

            //
            // For each job, copy.
            //
            for (idx = 0; idx < cJobs; idx++) {

                lpbEnd = ipp_CopyJI2toIPPJI2(&lpjiDst[idx],
                                             &lpjiSrc[idx],
                                             (LPTSTR)lpszJobBase,
                                             lpbEnd);
            }
        }
    }

    return lpjiDst;
}

/*****************************************************************************\
* WebIppPackJI2
*
* This takes in a JOB_INFO_2 structure whose members are note packed correctly
* and returns a correctly filled out and allocated JOB_INFO_2. It does not
* copy the DEVMODE and SECURITY-DESCRIPTOR fields.
*
\*****************************************************************************/
LPJOB_INFO_2 WebIppPackJI2(
    IN  LPJOB_INFO_2  lpji2,
    OUT LPDWORD       lpcbSize,
    IN  ALLOCATORFN   pfnAlloc
    )  {

    WEB_IPP_ASSERT(lpji2);
    WEB_IPP_ASSERT(pfnAlloc);
    WEB_IPP_ASSERT(lpcbSize);

    *lpcbSize = 0;

    //
    // This is used to perform the ipp_PackStrings operation
    //
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];
    
    //
    // First get the required allocation size
    //
    DWORD dwSize = ipp_SizeofIPPJI2( lpji2, NULL ) + sizeof(JOB_INFO_2);

    //
    // Allocate the memory required to store the data
    //

    LPJOB_INFO_2 pji2out = (LPJOB_INFO_2)pfnAlloc( dwSize );

    if (pji2out) {
        //
        // First, do a straight copy of the memory from the incoming JI2 to the outgoing
        // ji2
        //

        LPTSTR* lpszSrc = aszSrc;
        LPBYTE  lpbEnd  = (LPBYTE)pji2out + dwSize;

        *lpcbSize = dwSize;

        CopyMemory( pji2out, lpji2, sizeof(JOB_INFO_2) );

        pji2out->pDevMode            = NULL; // These two pointers cannot be set
        pji2out->pSecurityDescriptor = NULL;

        *lpszSrc++ = lpji2->pPrinterName;
        *lpszSrc++ = lpji2->pMachineName;
        *lpszSrc++ = lpji2->pUserName;
        *lpszSrc++ = lpji2->pDocument;
        *lpszSrc++ = lpji2->pNotifyName;
        *lpszSrc++ = lpji2->pDatatype;
        *lpszSrc++ = lpji2->pPrintProcessor;
        *lpszSrc++ = lpji2->pParameters;
        *lpszSrc++ = lpji2->pDriverName;
        *lpszSrc++ = lpji2->pStatus;

        ipp_PackStrings(aszSrc, (LPBYTE)pji2out, s_JI2Off, lpbEnd);
    }

    return pji2out;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\clusupg.cxx ===
/*++

  Copyright (c) 2000 Microsoft Corporation
  All rights reserved.

  Module Name: 
      
      clusupg.cxx

  Purpose: 
  
      Upgrade printer drivers for clusters spoolers 

  Author: 
        

  Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/*++

Routine Name:

    PSetupUpgradeClusterDriversW

Routine Description:

    Upgrade function. Called by a cluster spooler to upgrade its drivers. This function
    is called the first time when the cluster spooler fails over to a node that was
    upgraded. SplCreatespooler spins a thread executing SplCreateSpoolerWorkerThread.
    So SplCreateSpoolerWorkerThread runs in the context of the spooler process, which
    is local system. This function then creates a rundll32 process (with CreateProcess)
    that invokes PSetupUpgradeClusterDrivers and thus runs in local system context.
    PSetupUpgradeClusterDrivers  enumerates all the printer drivers, loads printui.dll
    and calls the function PrintUIEntryW in printui.dll.

Arguments:

    hwnd            - Window handle of stub window.
    hInstance,      - Rundll instance handle.
    pszCmdLine      - Pointer to command line.
    nCmdShow        - Show command value always TRUE.

Return Value:

    Returns the last error code.  This can be read by the spooler by getting the return code from the process.

--*/
DWORD
PSetupUpgradeClusterDriversW(
    IN HWND        hWnd,
    IN HINSTANCE   hInstance,
    IN LPCTSTR     pszCmdLine,
    IN UINT        nCmdShow
    )
{
    LPBYTE  pDriverEnum = NULL;
    DWORD   cbNeeded;
    DWORD   cStrucs;
    DWORD   dwError = ERROR_INVALID_PARAMETER;
    LPTSTR  pszServer = const_cast<LPTSTR>(pszCmdLine);
    
    if (pszServer)
    {
        //
        // Enumerate all the drivers on the server
        //
        dwError = EnumPrinterDrivers(pszServer,
                                     _T("all"),
                                     6,
                                     NULL,
                                     0,
                                     &cbNeeded,
                                     &cStrucs) ? ERROR_SUCCESS : GetLastError();
    
        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            if (pDriverEnum = static_cast<LPBYTE>(LocalAllocMem(cbNeeded)))
            {
                if (EnumPrinterDrivers(pszServer,
                                       _T("all"),
                                       6,
                                       pDriverEnum,
                                       cbNeeded,
                                       &cbNeeded,
                                       &cStrucs))
                {
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    LocalFreeMem(pDriverEnum);

                    pDriverEnum = NULL;
    
                    dwError = GetLastError();
                }
            }
            else
            {
                dwError = GetLastError();
            }
        }

        if (dwError==ERROR_SUCCESS && cStrucs) 
        {
             DRIVER_INFO_6 *pDrv     = NULL;
             UINT           uIndex   = 0;
             HINSTANCE      hLibrary = NULL;
             typedef (* PFNENTRY)(HWND, HINSTANCE, LPCTSTR, UINT);
             PFNENTRY       pfnEntry;

             //
             // Load printui and get the entry point
             //
             if ((hLibrary = LoadLibraryUsingFullPath(_T("printui.dll"))) &&
                 (pfnEntry = (PFNENTRY)GetProcAddress(hLibrary, "PrintUIEntryW"))
                )
             {
                 //
                 // Loop through drivers and try to upgrade them using the cab
                 //
                 for (uIndex = 0, pDrv=reinterpret_cast<LPDRIVER_INFO_6>(pDriverEnum); 
                      dwError == ERROR_SUCCESS && uIndex < cStrucs;
                      uIndex++, pDrv++
                     ) 
                 {
                     TString strCommand;
                     DWORD   cbNeeded   = 0;
                     LPCTSTR pszFormat  = _T("/q /Gw /ia /K /c \"%ws\" /m \"%ws\" /h \"%ws\" /v %u");
    
                     //
                     // Format the string that will be used as aparameter for printui
                     //
                     if (strCommand.bFormat(pszFormat, pszServer, pDrv->pName, pDrv->pEnvironment, pDrv->cVersion))
                     {
                         //
                         // The printer we install will never have a print processor associated
                         // with it.
                         // The call into printui goes thrgouh the following path:
                         // PSetupUpgradeClusterDriversW -> PrintUIEntryW -> bDoCommand ->
                         // bExecuteCommand( XX, kInstallDriverWithInf, XX ) -> bDoInfPrinterInstall ->
                         // PnPInterface(kInfInstall, XX) -> bInfInstall
                         //
                         
                         //
                         // This will try to upgrade the driver/ We don't care about the error. Even if a driver 
                         // couldn't be upgraded, we still want to loop and try to upgrade the other drivers
                         // 
                         dwError = (pfnEntry)(hWnd, hInstance, strCommand, 0);
                         
                         DBGMSG(DBG_WARN, ("Command %ws   dwError from printui %u\n", (LPCTSTR)strCommand, dwError));                      
                         
                         //
                         // The case statements reperesent errors where we cannot continue executing the
                         // printer driver update. This is when the spooler dies or the cluster group 
                         // becomes active on a different node
                         //
                         switch (dwError) 
                         {
                             case RPC_S_SERVER_UNAVAILABLE:
                             
                             //
                             // We can get access deined when the cluster group moves to a different node.
                             // Since this process executes in the local system acocunt, this account doesn't
                             // have permissins to install printer drivers on a remote machine
                             //    
                             case ERROR_ACCESS_DENIED:
                              
                             //
                             // The spooler returns this error when it cannot create temporary directories
                             // for driver upgrade
                             //
                             case ERROR_NO_SYSTEM_RESOURCES:

                             //
                             // printui returns this error when it cannot do OpenPrinter(\\server name).
                             // This means the cluster group is off line (inaccessible)
                             //
                             case ERROR_INVALID_PRINTER_NAME:    
                                 
                                 //
                                 // We will exit the loop since dwError is not error success
                                 //
                                 break;

                             default:

                                 //
                                 // We continue looping
                                 //
                                 dwError = ERROR_SUCCESS;
                         }
                     }                                  
                 }                 
             }
             else
             {
                 dwError = GetLastError();
             }

             if (hLibrary) 
             {
                 FreeLibrary(hLibrary);
             }
        }

        LocalFreeMem(pDriverEnum);
        pDriverEnum = NULL;
    }
    
    DBGMSG(DBG_WARN, ("PSetupClusterDrivers Error %u \n", dwError));

    //
    // If an error occurs we call ExitProcess. Then the spooler picks up the 
    // error code using GetExitCodeProcess. If no error occurs, then we
    // terminate normally
    //
    if (dwError != ERROR_SUCCESS) 
    {
        ExitProcess(dwError);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\data.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Data.c

Abstract:

    Driver Setup data

Author:

    Muhunthan Sivapragasam  (MuhuntS) 28-Mar-1997

Revision History:

--*/

#include "precomp.h"

#define offsetof(type, identifier) (ULONG_PTR)(&(((type)0)->identifier))

ULONG_PTR   LocalDataOffsets[]={offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszInfName),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszModelName),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszDriverSection),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszHardwareID),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszManufacturer),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszOEMUrl),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszProvider),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszzPreviousNames),
                               (ULONG_PTR)-1};

ULONG_PTR   InfInfoOffsets[]={offsetof(PPARSEINF_INFO, pszInstallSection),
                             offsetof(PPARSEINF_INFO, pszzICMFiles),
                             offsetof(PPARSEINF_INFO, pszPrintProc),
                             offsetof(PPARSEINF_INFO, pszVendorSetup),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pName),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDriverPath),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pConfigFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDataFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pHelpFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDependentFiles),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pMonitorName),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDefaultDataType),
                             (ULONG_PTR)-1};

ULONG_PTR   PnPInfoOffsets[]={offsetof(PPNP_INFO, pszPortName),
                             offsetof(PPNP_INFO, pszDeviceInstanceId),
                             (ULONG_PTR)-1};


#if DBG
//
// The following are to catch any inconsistency in splsetup.h
// Which can break the printui/ntprint interface
//
pfPSetupCreatePrinterDeviceInfoList             _pfn1   = PSetupCreatePrinterDeviceInfoList;
pfPSetupDestroyPrinterDeviceInfoList            _pfn2   = PSetupDestroyPrinterDeviceInfoList;
pfPSetupSelectDriver                            _pfn3   = PSetupSelectDriver;
pfPSetupCreateDrvSetupPage                      _pfn4   = PSetupCreateDrvSetupPage;
pfPSetupGetSelectedDriverInfo                   _pfn5   = PSetupGetSelectedDriverInfo;
pfPSetupDestroySelectedDriverInfo               _pfn6   = PSetupDestroySelectedDriverInfo;
pfPSetupInstallPrinterDriver                    _pfn7   = PSetupInstallPrinterDriver;
pfPSetupIsDriverInstalled                       _pfn8   = PSetupIsDriverInstalled;
pfPSetupIsTheDriverFoundInInfInstalled          _pfn9   = PSetupIsTheDriverFoundInInfInstalled;
pfPSetupThisPlatform                            _pfn11  = PSetupThisPlatform;
pfPSetupGetPathToSearch                         _pfn12  = PSetupGetPathToSearch;
pfPSetupDriverInfoFromName                      _pfn13  = PSetupDriverInfoFromName;
pfPSetupPreSelectDriver                         _pfn14  = PSetupPreSelectDriver;
pfPSetupCreateMonitorInfo                       _pfn15  = PSetupCreateMonitorInfo;
pfPSetupDestroyMonitorInfo                      _pfn16  = PSetupDestroyMonitorInfo;
pfPSetupEnumMonitor                             _pfn17  = PSetupEnumMonitor;
pfPSetupInstallMonitor                          _pfn18  = PSetupInstallMonitor;
pfPSetupProcessPrinterAdded                     _pfn20  = PSetupProcessPrinterAdded;
pfPSetupBuildDriversFromPath                    _pfn21  = PSetupBuildDriversFromPath;
pfPSetupSetSelectDevTitleAndInstructions        _pfn22  = PSetupSetSelectDevTitleAndInstructions;
pfPSetupInstallPrinterDriverFromTheWeb          _pfn23  = PSetupInstallPrinterDriverFromTheWeb;
pfPSetupGetLocalDataField                       _pfn25  = PSetupGetLocalDataField;
pfPSetupFreeDrvField                            _pfn26  = PSetupFreeDrvField;
pfPSetupIsCompatibleDriver                      _pfn27  = PSetupIsCompatibleDriver;
pfPSetupAssociateICMProfiles                    _pfn28  = PSetupAssociateICMProfiles;
pfPSetupInstallICMProfiles                      _pfn29  = PSetupInstallICMProfiles;
pfPSetupFreeMem                                 _pfn30  = PSetupFreeMem;
pfPSetupFindMappedDriver                        _pfn31  = PSetupFindMappedDriver;
pfPSetupInstallInboxDriverSilently              _pfn32  = PSetupInstallInboxDriverSilently;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spllib\webutil.cxx ===
/*****************************************************************************\
* MODULE: webutil.cxx
*
* PURPOSE:  functions to handle printer name encoding
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     02/26/98 weihaic     Added DecodePrinterName/EncodePrinterName
*                                GetWebpnpUrl
*     04/23/97 weihaic     Created based on spooler/inersrv/inetio.cxx
*
\*****************************************************************************/

#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"

#ifdef DEBUG
DWORD g_cbIppMem = 0;
#endif

/*****************************************************************************\
* web_WCtoMB (Local Routine)
*
* Converts Wide-Char to Multi-Byte string.  This routine specifies a codepage
* for translation.
*
\*****************************************************************************/
LPSTR web_WCtoMB(
    UINT    uCP,
    LPCWSTR lpszWC,
    LPDWORD lpcbSize)
{
    DWORD cbSize;
    LPSTR lpszMB = NULL;

    //
    // Get the size necessary to hold a multibyte string.
    //
    cbSize = WideCharToMultiByte(uCP, 0, lpszWC, -1, NULL, 0, NULL, NULL);

    if (cbSize) {

        if (lpszMB = (LPSTR)webAlloc(cbSize)) {

            WideCharToMultiByte(uCP, 0, lpszWC, -1, lpszMB, cbSize, NULL, NULL);
            //
            // If a size-return is requested, then return
            // the bytes-occupied (no terminator).
            //
            if (lpcbSize)
                *lpcbSize = --cbSize;
        }
    }

    return lpszMB;
}


/*****************************************************************************\
* web_WCtoUtf8 (Local Routine)
* web_Utf8toWC (Local Routine)
*
* Converts Wide-Char to Multi-Byte string.  This routine is used for ansi
* 9X platforms since the CP_UTF8 codepage isn't supported.
*
\*****************************************************************************/

#define ASCII            0x007f                // ascii range.
#define UTF8_2_MAX       0x07ff                // max UTF8 2byte seq (32 * 64 = 2048)
#define UTF8_1ST_OF_2    0xc0                  // 110x xxxx
#define UTF8_1ST_OF_3    0xe0                  // 1110 xxxx
#define UTF8_TRAIL       0x80                  // 10xx xxxx
#define HIGER_6_BIT(u)   ((u) >> 12)           //
#define MIDDLE_6_BIT(u)  (((u) & 0x0fc0) >> 6) //
#define LOWER_6_BIT(u)   ((u) & 0x003f)        //
#define BIT7(a)          ((a) & 0x80)          //
#define BIT6(a)          ((a) & 0x40)          //
#define SIZEOF_UTF8      (sizeof(WCHAR) + sizeof(CHAR))

LPSTR web_WCtoUtf8(
    LPCWSTR lpszSrc,
    DWORD   cchSrc,
    LPDWORD lpcbSize)
{
    LPSTR   lpszU8;
    LPCWSTR lpszWC;
    LPSTR   lpszDst = NULL;
    DWORD   cchDst  = 0;

    //
    // Allocate our buffer for the translation.
    //
    if (cchSrc && (lpszDst = (LPSTR)webAlloc(cchSrc * SIZEOF_UTF8))) {

        for (lpszU8 = lpszDst, lpszWC = lpszSrc; cchSrc; lpszWC++, cchSrc--) {

            if (*lpszWC <= ASCII) {

                *lpszU8++ = (CHAR)*lpszWC;

                cchDst++;

            } else if (*lpszWC <= UTF8_2_MAX) {
                //
                //  Use upper 5 bits in first byte.
                //  Use lower 6 bits in second byte.
                //
                *lpszU8++ = (UTF8_1ST_OF_2 | (*lpszWC >> 6));
                *lpszU8++ = (UTF8_TRAIL    | LOWER_6_BIT(*lpszWC));

                cchDst+=2;
            } else {
                //
                //  Use upper  4 bits in first byte.
                //  Use middle 6 bits in second byte.
                //  Use lower  6 bits in third byte.
                //
                *lpszU8++ = (UTF8_1ST_OF_3 | (*lpszWC >> 12));
                *lpszU8++ = (UTF8_TRAIL    | MIDDLE_6_BIT(*lpszWC));
                *lpszU8++ = (UTF8_TRAIL    | LOWER_6_BIT(*lpszWC));
                cchDst+=3;
            }
        }

    } else {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Return our buffer-size.
    //
    *lpcbSize = cchDst;

    return lpszDst;
}

LPWSTR web_Utf8toWC(
    LPCSTR lpszSrc,
    DWORD  cchSrc)
{
    LPCSTR lpszU8;
    LPWSTR lpszWC;
    int    nTB;
    CHAR   cU8;
    LPWSTR lpszDst = NULL;


    if (cchSrc && (lpszDst = (LPWSTR)webAlloc((cchSrc + 1) * sizeof(WCHAR)))) {

        for (lpszU8 = lpszSrc, lpszWC = lpszDst, nTB = 0; cchSrc ; cchSrc--) {

            if (BIT7(*lpszU8) == 0) {
                //
                // Ascii.
                //
                *lpszWC++ = (WCHAR)*lpszU8;

            } else if (BIT6(*lpszU8) == 0) {

                if (nTB != 0) {

                    //
                    //  Decrement the trail byte counter.
                    //
                    nTB--;

                    //
                    // Make room for the trail byte and add the trail byte
                    // value.
                    //
                    *lpszWC <<= 6;
                    *lpszWC |= LOWER_6_BIT(*lpszU8);


                    if (nTB == 0)
                        lpszWC++;
                }

            } else {
                //
                // Found a lead byte.
                //
                if (nTB > 0) {
                    //
                    // Error - previous sequence not finished.
                    //
                    nTB = 0;
                    lpszWC++;

                } else {
                    //
                    // Calculate the number of bytes to follow.
                    // Look for the first 0 from left to right.
                    //
                    for (cU8 = *lpszU8; BIT7(cU8) != 0; ) {

                        cU8 <<= 1;
                        nTB++;
                    }

                    //
                    // Store the value from the first byte and decrement
                    // the number of bytes to follow.
                    //
                    *lpszWC = (cU8 >> nTB--);
                }
            }

            lpszU8++;
        }
    }

    return lpszDst;
}


/*****************************************************************************\
* web_MBtoWC (Local Routine)
*
* Converts Multi-Byte to Wide-Char string.  This specifies a translation
* codepage.  The (cchMB) does not include the null-terminator, so we need
*
\*****************************************************************************/
LPWSTR web_MBtoWC(
    UINT   uCP,
    LPCSTR lpszMB,
    DWORD  cchMB)
{
    DWORD  cch;
    LPWSTR lpszWC = NULL;

    //
    // Get the size necessary to hold a widechar string.
    //
    cch = MultiByteToWideChar(uCP, 0, lpszMB, cchMB, NULL, 0);

    if (cch) {

        cch = ((cchMB == (DWORD)-1) ? cch : cch + 1);

        if (lpszWC = (LPWSTR)webAlloc(cch * sizeof(WCHAR))) {

            MultiByteToWideChar(uCP, 0, lpszMB, cchMB, lpszWC, cch);
        }
    }

    return lpszWC;
}


/*****************************************************************************\
* webMBtoTC (Local Routine)
*
* Converts Multi-Byte to a TChar string.
*
\*****************************************************************************/
LPTSTR webMBtoTC(
    UINT  uCP,
    LPSTR lpszUT,
    DWORD cch)
{
    LPTSTR lpszTC = NULL;


#ifdef UNICODE
    if (lpszUT != NULL)
        lpszTC = web_MBtoWC(uCP, lpszUT, cch);

    return lpszTC;

#else
    LPWSTR lpszWC = NULL;
    //
    // First convert the string to unicode so we can go through
    // the translation process.
    //

    if (lpszUT != NULL) {
        if (uCP == CP_UTF8) {
            DWORD cbSize = 0;

            lpszWC = web_Utf8toWC(lpszUT, cch);
            if (lpszWC) {
                lpszTC = web_WCtoMB(CP_ACP, lpszWC, &cbSize);
                webFree(lpszWC);
             }
         } else {
             if ( lpszTC = (LPSTR)webAlloc(cch+1) ) {
                memcpy( lpszTC, lpszUT, cch);
                lpszTC[cch] = '\0';
             }
        }
    }
    return lpszTC;
#endif

}


/*****************************************************************************\
* webTCtoMB (Local Routine)
*
* Converts a TChar to a Multi-Byte string.
*
\*****************************************************************************/
LPSTR webTCtoMB(
    UINT    uCP,
    LPCTSTR lpszTC,
    LPDWORD lpcbSize)
{
    LPWSTR lpszWC;
    LPSTR  lpszUT = NULL;


    *lpcbSize = 0;


    if (lpszTC != NULL) {

#ifdef UNICODE

        if (lpszWC = webAllocStr(lpszTC)) {

            lpszUT = web_WCtoMB(uCP, lpszWC, lpcbSize);
#else
        //
        // Convert to unicode then back again so we can go
        // through the code-page translation.
        //
        if (lpszWC = web_MBtoWC(CP_ACP, lpszTC, (DWORD)-1)) {

            DWORD cch = webStrSize(lpszTC);

            if (uCP == CP_UTF8)
                lpszUT = web_WCtoUtf8(lpszWC, cch, lpcbSize);
            else
                lpszUT = web_WCtoMB(uCP, lpszWC, lpcbSize);
#endif

            webFree(lpszWC);
        }
    }

    return lpszUT;
}


/*****************************************************************************\
* webStrSize (Local Routine)
*
* Returns bytes occupied by string (including NULL terminator).
*
\*****************************************************************************/
DWORD webStrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*****************************************************************************\
* webAlloc (Local Routine)
*
* Allocates a block of memory.
*
\*****************************************************************************/
LPVOID webAlloc(
    DWORD cbSize)
{
    PDWORD_PTR lpdwPtr;

#ifdef DEBUG

    if (cbSize && (lpdwPtr = (LPDWORD)new BYTE[cbSize + sizeof(DWORD_PTR)])) {

        ZeroMemory(lpdwPtr, cbSize + sizeof(DWORD_PTR));

        *lpdwPtr = cbSize;

        g_cbIppMem += cbSize;

        return (LPVOID)(lpdwPtr + 1);
    }

#else

    if (cbSize && (lpdwPtr = (PDWORD_PTR) new BYTE[cbSize])) {

        ZeroMemory(lpdwPtr, cbSize);

        return (LPVOID)lpdwPtr;
    }

#endif

    return NULL;
}


/*****************************************************************************\
* webFree (Local Routine)
*
* Deletes the memory-block allocated via webAlloc().
*
\*****************************************************************************/
BOOL webFree(
    LPVOID lpMem)
{
    if (lpMem) {

#ifdef DEBUG

        DWORD cbSize;

        lpMem = ((LPDWORD)lpMem) - 1;

        cbSize = *((LPDWORD)lpMem);

        g_cbIppMem -= cbSize;

#endif

        delete [] lpMem;

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* webRealloc (Local Routine)
*
* Reallocates a block of memory. Only for expanding memory NOT safe
* for contracting memory.
*
\*****************************************************************************/
LPVOID webRealloc(
    LPVOID lpMem,
    DWORD  cbOldSize,
    DWORD  cbNewSize)
{
    LPVOID lpNew;

    if (lpNew = (LPVOID)webAlloc(cbNewSize)) {

        CopyMemory(lpNew, lpMem, cbOldSize);

        webFree(lpMem);
    }

    return lpNew;
}


/*****************************************************************************\
* webAllocStr (Local Routine)
*
* Allocates a string.
*
\*****************************************************************************/
LPTSTR webAllocStr(
    LPCTSTR lpszStr)
{
    LPTSTR lpszMem;
    DWORD  cbSize;


    if (lpszStr == NULL)
        return NULL;

    cbSize = webStrSize(lpszStr);

    if (lpszMem = (LPTSTR)webAlloc(cbSize))
        memcpy(lpszMem, lpszStr, cbSize);

    return lpszMem;
}


/*****************************************************************************\
* webFindRChar
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPTSTR webFindRChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlen(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* webAtoI
*
* Convert Ascii to Integer.
*
\*****************************************************************************/
DWORD webAtoI(
    LPTSTR pszInt)
{
    DWORD dwRet = 0;


    while ((*pszInt >= TEXT('0')) && (*pszInt <= TEXT('9')))
        dwRet = (dwRet * 10) + *pszInt++ - TEXT('0');

    return dwRet;
}


BOOL
IsWebServerInstalled(
    LPCTSTR     pszServer
    )
{
    HANDLE              hServer;
    DWORD               dwDontCare, dwW3SvcInstalled, dwLastError;
    PRINTER_DEFAULTS    Defaults    = {NULL, NULL, 0};

    if ( !OpenPrinter((LPTSTR)pszServer, &hServer, &Defaults) )
        return FALSE;

    dwLastError = GetPrinterData(hServer,
                                 SPLREG_W3SVCINSTALLED,
                                 &dwDontCare,
                                 (LPBYTE)&dwW3SvcInstalled,
                                 sizeof(dwW3SvcInstalled),
                                 &dwDontCare);

    ClosePrinter(hServer);

    return  dwLastError == ERROR_SUCCESS && dwW3SvcInstalled != 0;

}

/********************************************************************************

Name:
    EncodePrinterName

Description:

    Encode the printer name to avoid special characters, also encode any chars
    with ASC code between 0x80 and 0xffff. This is to avoid the conversion betwwen
    different codepages when the client  and the server have different language
    packages.

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL EncodePrinterName (LPCTSTR lpText, LPTSTR lpHTMLStr, LPDWORD lpdwSize)
{
#define MAXLEN_PER_CHAR 6
#define BIN2ASC(bCode,lpHTMLStr)   *lpHTMLStr++ = HexToAsc ((bCode) >> 4);\
                                   *lpHTMLStr++ = HexToAsc ((bCode) & 0xf)

    DWORD   dwLen;
    BYTE    bCode;

    if (!lpText || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = MAXLEN_PER_CHAR * lstrlen (lpText) + 1;

    if (!lpHTMLStr || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpText) {
        if ((DWORD) (*lpText) > 0xff ) {
            //
            // Encode as ~0hhll hh is the high byte, ll is the low byte
            //
            *lpHTMLStr++ = TEXT ('~');
            *lpHTMLStr++ = TEXT ('0');

            //
            // Get the high byte
            //
            bCode = (*lpText & 0xff00) >> 8;
            BIN2ASC(bCode,lpHTMLStr);

            //
            // Get the low byte
            //
            bCode = (*lpText & 0xff);
            BIN2ASC(bCode,lpHTMLStr);
        }
        else if ((DWORD) (*lpText) > 0x7f) {
            //
            // Encode as ~xx
            //
            *lpHTMLStr++ = TEXT ('~');
            bCode = *lpText & 0xff;
            BIN2ASC(bCode,lpHTMLStr);
        }
        else {
            if (! _istalnum( *lpText)) {
                *lpHTMLStr++ = TEXT ('~');
                BIN2ASC(*lpText,lpHTMLStr);
            }
            else {
                *lpHTMLStr++ = *lpText;
            }
        }
        lpText++;
    }
    *lpHTMLStr = NULL;
    return TRUE;
}

/********************************************************************************

Name:
    DncodePrinterName

Description:

    Dncode the printer name encoded in from EncodePrinterName

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL DecodePrinterName (LPCTSTR pPrinterName, LPTSTR pDecodedName, LPDWORD lpdwSize)
{
    LPTSTR  lpParsedStr     = pDecodedName;
    LPCTSTR lpUnparsedStr   = pPrinterName;
    TCHAR   chMark          = TEXT ('~');
    TCHAR   chZero          = TEXT ('0');
    BOOL    bRet            = TRUE;
    DWORD   dwLen;
    TCHAR   b1, b2, b3, b4;

    //
    // Verify that we're getting non-Null input pointers
    //
    if ((!pPrinterName) || (!lpdwSize)) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = lstrlen (pPrinterName) + 1;

    if (!pDecodedName || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpUnparsedStr) {

        if (*lpUnparsedStr == chMark) {
            if (! (b1 = *++lpUnparsedStr)) {
                SetLastError (ERROR_INVALID_DATA);
                bRet = FALSE;
                break;
            }

            if (b1 == chZero) {
                //
                // Decode ~0hhll
                //
                if ( !(b1 = *++lpUnparsedStr) ||
                     !(b2 = *++lpUnparsedStr) ||
                     !(b3 = *++lpUnparsedStr) ||
                     !(b4 = *++lpUnparsedStr)) {
                    SetLastError (ERROR_INVALID_DATA);
                    bRet = FALSE;
                    break;
                }

                lpUnparsedStr++;
                *lpParsedStr++ = (AscToHex (b1) << 12) |
                                 (AscToHex (b2) << 8) |
                                 (AscToHex (b3) << 4) |
                                 AscToHex (b4);
            }
            else {
                //
                // To take care the case when the DecodeString ends with %
                //
                if (! (b2 = *++lpUnparsedStr)) {
                    SetLastError (ERROR_INVALID_DATA);
                    bRet = FALSE;
                    break;
                }

                lpUnparsedStr++;
                *lpParsedStr++ = (AscToHex (b1) << 4) | AscToHex (b2);
            }
        }
        else {
            *lpParsedStr++ = *lpUnparsedStr++;
        }
    }
    *lpParsedStr = NULL;
    return bRet;
}

/********************************************************************************

Name:
    AscToHex

Description:

    Convert a hex character to the corresponding value (0-0xf);

Arguments:

    c:      The character

Return Value:

    0xff    if the character is not a hex digit
    the corresponding numberical value otherwise

********************************************************************************/
BYTE AscToHex (TCHAR c)
{
    UINT uValue = 0xff;

    if (_istxdigit (c))
    {
        if (_istdigit (c))
        {
            uValue = c - TEXT('0');
        }
        else
        {
            uValue = _totlower (c) - TEXT('a') + 10;
        }
    }
    return (BYTE)uValue;
}

/********************************************************************************

Name:
    HexToAsc

Description:

    Convert a hex character to the corresponding value (0-0xf);

Arguments:

    b:      The byte (0 to F)

Return Value:

    0  if the character is out of range
    the corresponding ASCII of the hex number

********************************************************************************/
TCHAR HexToAsc( INT b )
{
    UINT uValue = 0;

    if (0 <= b && b <= 0xf)
    {
        if (b < 0xa)
        {
            uValue = TEXT('0') + b;
        }
        else
        {
            uValue = TEXT('a') + b - 10;
        }
    }
    return (TCHAR)uValue;
}


/********************************************************************************

Name:
    EncodeString

Description:

    Convert the normal text string to HTML text string by replace special
    characters such as ", <, > with the corresponding HTML code

Arguments:

    lpText:     the normal text string
    bURL:       TRUE for encoding a URL string. FALSE otherwise.

Return Value:

    Pointer to the HTML string. The caller is responsible to call LocalFree to
    free the pointer. NULL is returned if no enougth memory
********************************************************************************/
LPTSTR EncodeString (LPCTSTR lpText, BOOL bURL)
{
    DWORD   dwLen;
    DWORD   dwMaxLen = bURL?3:6;    // The maximum length of the encoding characters.
                                    // if it is URL, we enocde it with %xx, so the max len is 3
                                    // otherwise the max len of HTML char is 5,
                                    // it happens when " is encoded (&quot;)
    LPTSTR  lpHTMLStr       = NULL;

    if (!lpText || !(dwLen = lstrlen (lpText))) return NULL;

    //
    // To make life simpler, we allocate the necessary buffer at once instead of
    // calling realloc later. Since the encoded string is always freed after it is dumped
    // to the client, and the length of the string is limited to the nax length of the URL
    // so the modification does not pose extra burden on the system memroy.
    //

    dwLen = dwMaxLen * dwLen + 1;
    if (! (lpHTMLStr = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
        return NULL;

    if (bURL) {
        LPTSTR lpDst = lpHTMLStr;

        while (*lpText) {
            switch (*lpText) {
            case TEXT ('<'):
            case TEXT ('>'):
            case TEXT ('"'):
            case TEXT ('&'):
            case TEXT (' '):
            case TEXT ('?'):
                *lpDst++ = TEXT ('%');
                *lpDst++ = HexToAsc ((*lpText & 0xf0) >> 4);
                *lpDst++ = HexToAsc (*lpText & 0x0f);
                break;
            default:
                *lpDst++ = *lpText;
                break;
            }
            lpText++;
        }
    }
    else {
        TCHAR   szDestChar[3]   = {0, 0};
        LPTSTR  lpChar;
        DWORD   dwIndex = 0;

        while (*lpText) {
            switch (*lpText) {
            case TEXT ('<'):    lpChar = TEXT ("&lt;");     break;
            case TEXT ('>'):    lpChar = TEXT ("&gt;");     break;
            case TEXT ('"'):    lpChar = TEXT ("&quot;");   break;
            case TEXT ('&'):    lpChar = TEXT ("&amp;");    break;
            default:

                szDestChar[0] = *lpText;
                szDestChar[1] = 0;
                lpChar = szDestChar;
            }
            StringCchCopy(lpHTMLStr + dwIndex, dwLen-dwIndex, lpChar);
            dwIndex += lstrlen (lpChar);
            lpText++;
        }
    }

    return lpHTMLStr;
}

/********************************************************************************

Name:
    GetWebpnpUrl

Description:

    Given the server name and the printer name, return the Url for webpnp
    Currently, the URL is
        http://servername/encoded printername/.printer[querystrings]

Arguments:

    pszServer:      The server name
    pszPrinterName: The printer name (unicode string)
    pszQueryString: The querystring (optional)
    pszURL:         The output URL buffer
    lpdwSize:       The size of the URL buffer (in Character)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL GetWebpnpUrl (LPCTSTR pszServer, LPCTSTR pszPrinterName, LPCTSTR pszQueryString,
                   BOOL bSecure, LPTSTR pszURL, LPDWORD lpdwSize)
{
    static TCHAR szHttp[]       = TEXT ("http://");
    static TCHAR szHttps[]      = TEXT ("https://");
    static TCHAR szSlash[]      = TEXT ("/printers/"); //Remove scripts in the URL . Previous value: TEXT ("/scripts/");
    static TCHAR szPrinter[]    = TEXT ("/.printer");
    LPTSTR pszEncodedName       = NULL;
    DWORD dwEncodedSize         = 0;
    DWORD dwSize                = 0;
    DWORD bRet                  = FALSE;
    size_t cUrlLen              = static_cast<size_t>(*lpdwSize);

    if (!pszPrinterName || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    //
    // Calculate buffer size
    //
    EncodePrinterName (pszPrinterName, NULL, &dwEncodedSize);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    dwSize = (DWORD)(2 + dwEncodedSize
             + COUNTOF (szHttps) + COUNTOF (szSlash) + COUNTOF (szPrinter)
             + ((pszServer)? lstrlen (pszServer):0)
             + ((pszQueryString)?lstrlen (pszQueryString):0));

    if (!pszURL || dwSize > *lpdwSize ) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwSize;
        return FALSE;
    }

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwEncodedSize)))
        goto Cleanup;

    if (!EncodePrinterName (pszPrinterName, pszEncodedName, &dwEncodedSize))
        goto Cleanup;

    if (pszServer) {
        if (bSecure) {
            StringCchCopy (pszURL, cUrlLen, szHttps);
        } else {
            StringCchCopy (pszURL, cUrlLen, szHttp);
        }

        StringCchCat (pszURL, cUrlLen, pszServer);
    }

    StringCchCat (pszURL, cUrlLen, szSlash);
    StringCchCat (pszURL, cUrlLen, pszEncodedName);
    StringCchCat (pszURL, cUrlLen, szPrinter);

    if (pszQueryString) {
        StringCchCat (pszURL, cUrlLen, TEXT ("?"));
        StringCchCat (pszURL, cUrlLen, pszQueryString);
    }

    bRet = TRUE;

Cleanup:
    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return bRet;

}

/********************************************************************************

Name:
    GetWebUIUrl

Description:

    Given the server name and the printer name, return the Url for webpnp
    Currently, the URL is
        http://servername/printers/ipp_0004.asp?epirnter=encoded printername

Arguments:

    pszServer:      The server name
    pszPrinterName: The printer name (unicode string)
    pszURL:         The output URL buffer
    lpdwSize:       The size of the URL buffer (in Character)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL GetWebUIUrl (LPCTSTR pszServer, LPCTSTR pszPrinterName, LPTSTR pszURL,
                  LPDWORD lpdwSize)
{
    static TCHAR szHttp[]       = TEXT ("http://");
    static TCHAR szPrinter[]    = TEXT ("/printers/ipp_0004.asp?eprinter=");
    LPTSTR pszEncodedName       = NULL;
    DWORD dwEncodedSize         = 0;
    DWORD dwSize                = 0;
    DWORD bRet                  = FALSE;
    size_t cUrlLen              = static_cast<size_t>(*lpdwSize);

    if (!pszPrinterName || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    //
    // Calculate buffer size
    //
    EncodePrinterName (pszPrinterName, NULL, &dwEncodedSize);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    dwSize = (DWORD)(2 + dwEncodedSize
             + COUNTOF (szHttp) + COUNTOF (szPrinter)
             + ((pszServer)? lstrlen (pszServer):0));


    if (!pszURL || dwSize > *lpdwSize ) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwSize;
        return FALSE;
    }

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwEncodedSize)))
        goto Cleanup;

    if (!EncodePrinterName (pszPrinterName, pszEncodedName, &dwEncodedSize))
        goto Cleanup;

    if (pszServer) {
        StringCchCopy (pszURL, cUrlLen, szHttp);
        StringCchCat (pszURL, cUrlLen, pszServer);
    }

    StringCchCat(pszURL, cUrlLen, szPrinter);
    StringCchCat(pszURL, cUrlLen, pszEncodedName);

    bRet = TRUE;

Cleanup:
    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return bRet;

}

/********************************************************************************

Name:
    AssignString

Description:

    Perform an assign operation
     l = r

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL AssignString (
    LPTSTR &l,
    LPCTSTR r)
{

    if (l) {
        LocalFree (l);
        l = NULL;
    }

    if (!r) {
        return TRUE;
    }
    else if (l = (LPTSTR) LocalAlloc (LPTR, (1 + lstrlen (r)) * sizeof (TCHAR))) {
        StringCchCopy( l, 1+lstrlen(r), r);
        return TRUE;
    }

    return FALSE;
}


/****************************************************************** Method ***\
* CWebLst::CWebLst (Constructor)
*
*   Initializes the CWebLst object.
*
\*****************************************************************************/
CWebLst::CWebLst(VOID)
{
    m_cbMax  = WEBLST_BLKSIZE;
    m_cbLst  = 0;
    m_pbLst  = (PBYTE)webAlloc(m_cbMax);
    m_pbPtr  = m_pbLst;
    m_cItems = 0;
}


/****************************************************************** Method ***\
* CWebLst::~CWebLst (Destructor)
*
*   Free up the CWebLst object.
*
\*****************************************************************************/
CWebLst::~CWebLst(VOID)
{
    webFree(m_pbLst);
}


/****************************************************************** Method ***\
* CWebLst::Add
*
*   Add an item to our list.
*
\*****************************************************************************/
BOOL CWebLst::Add(
    PCTSTR lpszName)
{
    PBYTE pbNew;
    DWORD cbPtr;
    DWORD cbNew;
    DWORD cbStr;
    BOOL  bRet = FALSE;


    if (m_pbLst) {
        //
        // Reallocate the buffer is a bigger size is necessary.
        //
        cbStr = webStrSize(lpszName);

        if ((m_cbLst + cbStr) > m_cbMax) {

            cbNew = m_cbMax + WEBLST_BLKSIZE;
            cbPtr = (DWORD)(m_pbPtr - m_pbLst);

            if (pbNew = (PBYTE)webRealloc(m_pbLst, m_cbMax, cbNew)) {

                m_cbMax = cbNew;
                m_pbLst = pbNew;
                m_pbPtr = m_pbLst + (DWORD_PTR)cbPtr;

            } else {

                goto AddEnd;
            }
        }

        //
        // Copy the item.
        //
        memcpy(m_pbPtr, lpszName, cbStr);
        m_cbLst += cbStr;
        m_pbPtr += cbStr;

        m_cItems++;

        bRet = TRUE;
    }

AddEnd:

    return bRet;
}


/****************************************************************** Method ***\
* CWebLst::Count
*
*   Returns a count of items.
*
\*****************************************************************************/
DWORD CWebLst::Count(VOID)
{
    return m_cItems;
}


/****************************************************************** Method ***\
* CWebLst::Get
*
*   Retrieve current string.
*
\*****************************************************************************/
PCTSTR CWebLst::Get(VOID)
{
    return (m_cItems ? (PCTSTR)m_pbPtr : NULL);
}


/****************************************************************** Method ***\
* CWebLst::Next
*
*
\*****************************************************************************/
BOOL CWebLst::Next(VOID)
{
    m_pbPtr += webStrSize((PCTSTR)m_pbPtr);

    return (*m_pbPtr ? TRUE : FALSE);
}


/****************************************************************** Method ***\
* CWebLst::Reset
*
*
\*****************************************************************************/
VOID CWebLst::Reset(VOID)
{
    m_pbPtr = m_pbLst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\install.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Install.c

Abstract:

    File queue functions

Author:

    Muhunthan Sivapragasam (MuhuntS)  18-Nov-96

Revision History:

--*/

#include "precomp.h"
#include <winsprlp.h>

const TCHAR       szWebDirPrefix[]        = TEXT("\\web\\printers\\");
const TCHAR       szNtPrintInf[]          = TEXT("inf\\ntprint.inf");

//
//  File queue flags, and structure
//
#define     CALLBACK_MEDIA_CHECKED          0x01
#define     CALLBACK_SOURCE_SET             0x02
#define     CALLBACK_PATH_MODIFIED          0x04

typedef struct _FILE_QUEUE_CONTEXT {

    HWND        hwnd;
    PVOID       QueueContext;
    LPCTSTR     pszSource;
    BOOL        dwCallbackFlags;
    DWORD       dwInstallFlags;
    LPCTSTR     pszFileSrcPath;
    TCHAR       szInfPath[MAX_PATH];
    PLATFORM    platform;
    DWORD       dwVersion;

} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;

BOOL
FileExistsOnMedia(
    PSOURCE_MEDIA   pSourceMedia
    )
{
    BOOL    bRes                   = FALSE;
    TCHAR   *pszFile               = NULL;
    DWORD   cchLength               = 0;
    DWORD   cchAdditionalSymbolsLen = 0;
    DWORD   dwLen1                 = 0;
    DWORD   dwLen2                 = 0;
    LPTSTR  p                      = NULL;
    LPTSTR  q                      = NULL; 


    if ( !pSourceMedia->SourcePath || !*pSourceMedia->SourcePath ||
         !pSourceMedia->SourceFile || !*pSourceMedia->SourceFile )
    {
        goto Cleanup;   
    }

    cchAdditionalSymbolsLen = lstrlen(TEXT("\\")) + lstrlen(TEXT("_")) + 1;
    cchLength = lstrlen(pSourceMedia->SourcePath) + lstrlen(pSourceMedia->SourceFile) + 
               cchAdditionalSymbolsLen;
    if (cchLength == cchAdditionalSymbolsLen) 
    {
        goto Cleanup;
    }

    //
    // First check if file is there on source path
    //
    pszFile = LocalAllocMem(cchLength * sizeof(TCHAR));
    if (!pszFile) 
    {
        goto Cleanup;
    }
    StringCchCopy(pszFile, cchLength, pSourceMedia->SourcePath);
    dwLen1 = lstrlen(pszFile);
    if  ( *(pszFile + (dwLen1-1)) != TEXT('\\') ) 
    {
        *(pszFile + dwLen1) = TEXT('\\');
        ++dwLen1;
    }

    StringCchCopy(pszFile + dwLen1, cchLength - dwLen1, pSourceMedia->SourceFile);
    dwLen2 = dwLen1 + lstrlen(pSourceMedia->SourceFile);

    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    p = lstrchr(pszFile, TEXT('.'));
    q = lstrchr(pszFile, TEXT('\\'));

    //
    // A dot present in filename?
    //
    if ( q < p ) 
    {
        //
        // For files with 0, 1, 2 characters after the dot append underscore.
        //
        if ( (lstrlen(p) < 4) && (dwLen2 < (cchLength-1)) ) 
        {

            *(pszFile + dwLen2) = TEXT('_');
            ++dwLen2;
            *(pszFile + dwLen2) = TEXT('\0');
        } 
        else 
        {
            //
            // If 3+ characters after dot then replace last character with _
            // to get the compressed file name
            //
            *(pszFile + (dwLen2-1)) = TEXT('_');
        }
    } 
    else 
    {
        //
        // If no dot then replace last character with _ for compressed name
        //
        *(pszFile + (dwLen2-1)) = TEXT('_');
    }

    //
    // Does the compressed file exist on source path?
    //
    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    //
    // Check for the file in compressed form with $ as the character
    //
    *(pszFile + (dwLen2-1)) = TEXT('$');
    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    if ( !pSourceMedia->Tagfile || !*pSourceMedia->Tagfile )
    {
        goto Cleanup;
    }

    //
    // Look for tag file
    //
    StringCchCopy(pszFile + dwLen1, cchLength - dwLen1, pSourceMedia->Tagfile);
    bRes = FileExists(pszFile);

Cleanup:

    LocalFreeMem(pszFile);
    return bRes;
}


UINT
MyQueueCallback(
    IN  PVOID     QueueContext,
    IN  UINT      Notification,
    IN  UINT_PTR  Param1,
    IN  UINT_PTR  Param2
    )
{
    PFILE_QUEUE_CONTEXT     pFileQContext=(PFILE_QUEUE_CONTEXT)QueueContext;
    PSOURCE_MEDIA           pSourceMedia;
    LPTSTR                  pszPathOut;
    PFILEPATHS              pFilePaths;


    switch (Notification) {

        case SPFILENOTIFY_NEEDMEDIA:

            pSourceMedia    = (PSOURCE_MEDIA)Param1;
            pszPathOut      = (LPTSTR)Param2;

            //
            // If pszSource is specified then we have a flat share where
            // all the files are available. Setup is looking for the file
            // in the sub-directory (ex. ..\i386) based on the layout info.
            // We need to tell setup to look in the root directory
            //
            if ( !(pFileQContext->dwCallbackFlags & CALLBACK_SOURCE_SET)    &&
                 pFileQContext->pszSource                                   &&
                 lstrcmpi(pFileQContext->pszSource,
                          pSourceMedia->SourcePath) ) {

                    StringCchCopy(pszPathOut, MAX_PATH, pFileQContext->pszSource);
                    pFileQContext->dwCallbackFlags |= CALLBACK_SOURCE_SET;
                    return FILEOP_NEWPATH;
            }

            //
            // If DRVINST_PROMPTLESS is set then we can't allow prompt
            //
            if ( pFileQContext->dwInstallFlags & DRVINST_PROMPTLESS ) {

                if ( !(pFileQContext->dwCallbackFlags & CALLBACK_MEDIA_CHECKED) ) {

                    pFileQContext->dwCallbackFlags |= CALLBACK_MEDIA_CHECKED;
                    if ( FileExistsOnMedia(pSourceMedia) )
                        return FILEOP_DOIT;
                }

                return FILEOP_ABORT;
            }

            //
            // If we do a non-native platform install and the user points
            // to a server CD, the inf will specify a subdir \i386 which is
            // correct on an installed machine but not on a CD. Remove that dir
            // and try again.
            //
            if ( (pFileQContext->dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL) &&
                !(pFileQContext->dwCallbackFlags & CALLBACK_PATH_MODIFIED))
            {
                LPSTR pCur;
                size_t  Pos, Len, OverrideLen;

                //
                // for NT4 installations we have possibly expanded the INF
                // from a server CD. Point there if that's the case
                //
                if ((pFileQContext->dwVersion == 2) &&
                    (pFileQContext->pszFileSrcPath))
                {
                    Len = _tcslen(pFileQContext->szInfPath);

                    if (_tcsnicmp(pSourceMedia->SourcePath,
                                  pFileQContext->szInfPath, Len) == 0)
                    {
                        StringCchCopy(pszPathOut, MAX_PATH, pFileQContext->pszFileSrcPath);

                        pFileQContext->dwCallbackFlags |= CALLBACK_PATH_MODIFIED;

                        return FILEOP_NEWPATH;
                    }
                }

                //
                // Find the spot where the platform ID begins
                //
                Pos = Len = _tcslen(pFileQContext->szInfPath);

                //
                // sanity check
                //
                if (_tcslen(pSourceMedia->SourcePath) <= Len)
                    goto Default;

                if (pSourceMedia->SourcePath[Len] == _T('\\'))
                {
                    Pos++;
                }

                OverrideLen = _tcslen(PlatformOverride[pFileQContext->platform].pszName);

                if (_tcsnicmp(pSourceMedia->SourcePath,
                              pFileQContext->szInfPath, Len) == 0 &&
                    _tcsnicmp(&(pSourceMedia->SourcePath[Pos]),
                              PlatformOverride[pFileQContext->platform].pszName,
                              OverrideLen) == 0)
                {
                    StringCchCopy(pszPathOut, MAX_PATH, pFileQContext->szInfPath);

                    pFileQContext->dwCallbackFlags |= CALLBACK_PATH_MODIFIED;

                    return FILEOP_NEWPATH;
                }


            }
            goto Default;

        case SPFILENOTIFY_STARTCOPY:
            pFilePaths = (PFILEPATHS)Param1;
            if ( gpszSkipDir &&
                 !lstrncmpi(gpszSkipDir, pFilePaths->Target, lstrlen(gpszSkipDir)) )
                return FILEOP_SKIP;

            goto Default;

        case SPFILENOTIFY_ENDCOPY:
            // Here we set the bMediaChecked flag to FALSE, this is because some OEM drivers
            // have more than one media, so we assume NEEDMEDIA,STARTCOPY,ENDCOPY,NEEDMEDIA
            // So if we reset the NEEDMEDIA flag after the ENDCOPY, we are OK

            //
            // Clear the per file flags
            //
            pFileQContext->dwCallbackFlags  &= ~(CALLBACK_MEDIA_CHECKED |
                                                 CALLBACK_SOURCE_SET |
                                                 CALLBACK_PATH_MODIFIED);
            goto Default;

        case SPFILENOTIFY_COPYERROR:

            pFilePaths = (PFILEPATHS)Param1;
            // If there is a copy error happens in webpnp, we force it retry
            // the orginal flat directory
            if ( pFileQContext->dwInstallFlags & DRVINST_WEBPNP) {

                 pszPathOut = (LPTSTR)Param2;

                 // We need to make sure the path used in the copy operation is not as same as we're going
                 // to replace, otherwise, it will go to indefinite loop.
                 //
                 if (lstrncmpi(pFileQContext->pszSource, pFilePaths->Source, lstrlen(pFileQContext->pszSource)) ||
                     lstrchr (pFilePaths->Source + lstrlen(pFileQContext->pszSource) + 1, TEXT ('\\'))) {

                    if(SUCCEEDED(StringCchCopy(pszPathOut, MAX_PATH, pFileQContext->pszSource)))
                    {
                        return FILEOP_NEWPATH;
                    }
                 }
                 
                 if ( pFileQContext->dwInstallFlags & DRVINST_PROMPTLESS )
                 {
                     return FILEOP_ABORT;
                 }

            }
            goto Default;

    }

Default:
    return SetupDefaultQueueCallback(pFileQContext->QueueContext,
                                     Notification,
                                     Param1,
                                     Param2);
}

VOID
CheckAndEnqueueOneFile(
    IN      LPCTSTR     pszFileName,
    IN      LPCTSTR     pszzDependentFiles, OPTIONAL
    IN      HSPFILEQ    CopyQueue,
    IN      LPCTSTR     pszSourcePath,
    IN      LPCTSTR     pszTargetPath,
    IN      LPCTSTR     pszDiskName,        OPTIONAL
    IN OUT  LPBOOL      lpFail
)
/*++

Routine Description:
    Ensure that a file is enqueue only once for copying. To do so we check
    if the given file name also appears in the list of dependent files and
    enqueue it only if it does not.

Arguments:
    pszFileName         : File name to be checked and enqueued
    pszzDependentFiles  : Dependent files (multi-sz) list
    CopyQueue           : CopyQueue used to enqueue files
    pszSourcePath       : Source directory to look for the files
    pszTargetPath       : Target directory to copy the files to
    pszDiskName         : Title of the disk where files are
    lpBool              : Will be set to TRUE on error

Return Value:
    Nothing

--*/
{
    LPCTSTR  psz;

    if ( *lpFail )
        return;

    //
    // If the file also appears as a dependent file do not enqueue it
    //
    if ( pszzDependentFiles ) {

        for ( psz = pszzDependentFiles ; *psz ; psz += lstrlen(psz) + 1 )
            if ( !lstrcmpi(pszFileName, psz) )
                return;
    }

    *lpFail = !SetupQueueCopy(
                    CopyQueue,
                    pszSourcePath,
                    NULL,           // Path relative to source
                    pszFileName,
                    pszDiskName,    // "Supplies a description of the source media to be used during disk prompts"
                    NULL,           // Source Tag file
                    pszTargetPath,
                    NULL,           // Target file name
                    0);             // Copy style flags
}


BOOL
CopyPrinterDriverFiles(
    IN  LPDRIVER_INFO_6     pDriverInfo6,
    IN  LPCTSTR             pszInfName,
    IN  LPCTSTR             pszSourcePath,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszTargetPath,
    IN  HWND                hwnd,
    IN  DWORD               dwInstallFlags,
    IN  BOOL                bForgetSource
    )
/*++

Routine Description:
    Copy printer driver files to a specified directory using SetupQueue APIs

Arguments:
    pDriverInfo6    : Points to a valid SELECTED_DRV_INFO
    szTargetPath    : Target directory to copy to
    szSourcePath    : Source directory to look for the files, if none is
                      specified will use the one from prev. operation
    pszDiskName     : Title of the disk where files are
    hwnd            : Windows handle of current top-level window
    bForgetSource   : TRUE if the path where driver files were copied from
                      should not be remembered for future use

Return Value:
    TRUE    on succes
    FALSE   else, use GetLastError() to get the error code

--*/
{
    HSPFILEQ            CopyQueue;
    BOOL                bFail = FALSE;
    DWORD               dwOldCount, dwNewCount, dwIndex;
    LPTSTR              psz, *List = NULL;
    FILE_QUEUE_CONTEXT  FileQContext;

    //
    // Valid DriverInfo6
    //
    if ( !pDriverInfo6                  ||
         !pDriverInfo6->pDriverPath     ||
         !pDriverInfo6->pDataFile       ||
         !pDriverInfo6->pConfigFile )
        return FALSE;

    //
    // If no additions should be made to the source list findout the count
    //
    if ( bForgetSource ) {

        dwOldCount = 0;
        if ( !SetupQuerySourceList(SRCLIST_USER | SRCLIST_SYSTEM,
                                   &List, &dwOldCount) ) {

            return FALSE;
        }

        SetupFreeSourceList(&List, dwOldCount);
    }

    //
    // Create a setup file copy queue and initialize setup queue callback
    //
    ZeroMemory(&FileQContext, sizeof(FileQContext));
    FileQContext.hwnd           = hwnd;
    FileQContext.pszSource      = NULL;
    FileQContext.dwInstallFlags = dwInstallFlags;

    if ( dwInstallFlags & DRVINST_PROGRESSLESS ) {

        FileQContext.QueueContext   = SetupInitDefaultQueueCallbackEx(
                                            hwnd,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);
    } else {

        FileQContext.QueueContext   = SetupInitDefaultQueueCallback(hwnd);
    }

    CopyQueue                   = SetupOpenFileQueue();

    if ( CopyQueue == INVALID_HANDLE_VALUE || !FileQContext.QueueContext )
        goto Cleanup;

    CheckAndEnqueueOneFile(pDriverInfo6->pDriverPath,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    CheckAndEnqueueOneFile(pDriverInfo6->pDataFile,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    CheckAndEnqueueOneFile(pDriverInfo6->pConfigFile,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    if ( pDriverInfo6->pHelpFile && *pDriverInfo6->pHelpFile )
        CheckAndEnqueueOneFile(pDriverInfo6->pHelpFile,
                               pDriverInfo6->pDependentFiles,
                               CopyQueue,
                               pszSourcePath,
                               pszTargetPath,
                               pszDiskName,
                               &bFail);

    //
    // Add each file in the dependent files field to the setup queue
    //
    if ( pDriverInfo6->pDependentFiles ) {

        for ( psz = pDriverInfo6->pDependentFiles ;
              *psz ;
              psz += lstrlen(psz) + 1 )

            CheckAndEnqueueOneFile(psz,
                                   NULL,
                                   CopyQueue,
                                   pszSourcePath,
                                   pszTargetPath,
                                   pszDiskName,
                                   &bFail);

    }

    if ( bFail )
        goto Cleanup;

    {
       // Before adding files to the File Queue set the correct Platform/Version
       //  info for Driver Signing
       // Setup the structure for SETUPAPI
       SP_ALTPLATFORM_INFO AltPlat_Info;
       HINF                hInf;
       TCHAR               CatalogName[ MAX_PATH ];
       LPTSTR              pszCatalogFile = NULL;

       AltPlat_Info.cbSize                     = sizeof(SP_ALTPLATFORM_INFO);
       AltPlat_Info.Platform                   =  VER_PLATFORM_WIN32_WINDOWS;
       AltPlat_Info.MajorVersion               = 4;
       AltPlat_Info.MinorVersion               = 0;
       AltPlat_Info.ProcessorArchitecture      = PROCESSOR_ARCHITECTURE_INTEL;
       AltPlat_Info.Reserved                   = 0;
       AltPlat_Info.FirstValidatedMajorVersion = AltPlat_Info.MajorVersion;
       AltPlat_Info.FirstValidatedMinorVersion = AltPlat_Info.MinorVersion;

       if ( CheckForCatalogFileInInf(pszInfName, &pszCatalogFile) && pszCatalogFile )
       {
           if ( (lstrlen(pszSourcePath)+lstrlen(pszCatalogFile)+2) < MAX_PATH )
           {
               StringCchCopy(CatalogName, COUNTOF(CatalogName), pszSourcePath);
               StringCchCat( CatalogName, COUNTOF(CatalogName), TEXT("\\"));
               StringCchCat( CatalogName, COUNTOF(CatalogName), pszCatalogFile );
           }
           else
           {
               bFail = TRUE;
           }

           LocalFreeMem( pszCatalogFile );
           pszCatalogFile = CatalogName;
       }

       if (bFail)
          goto Cleanup;


       // Now call the Setup API to change the parms on the FileQueue
       bFail = !SetupSetFileQueueAlternatePlatform( CopyQueue, &AltPlat_Info, pszCatalogFile );

    }

    if ( bFail )
        goto Cleanup;

    bFail = !SetupCommitFileQueue(hwnd,
                                  CopyQueue,
                                  MyQueueCallback,
                                  &FileQContext);

    //
    // If bForegetSource is set fix source list
    //
    if ( bForgetSource &&
         SetupQuerySourceList(SRCLIST_USER | SRCLIST_SYSTEM,
                              &List, &dwNewCount) ) {

         dwOldCount = dwNewCount - dwOldCount;
         if ( dwOldCount < dwNewCount )
         for ( dwIndex = 0 ; dwIndex < dwOldCount ; ++dwIndex ) {

            SetupRemoveFromSourceList(SRCLIST_SYSIFADMIN,
                                      List[dwIndex]);
         }

        SetupFreeSourceList(&List, dwNewCount);
    }
Cleanup:

    if ( CopyQueue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue(CopyQueue);

    if ( FileQContext.QueueContext )
        SetupTermDefaultQueueCallback(FileQContext.QueueContext);

    return !bFail;
}


BOOL
AddPrinterDriverUsingCorrectLevel(
    IN  LPCTSTR         pszServerName,
    IN  LPDRIVER_INFO_6 pDriverInfo6,
    IN  DWORD           dwAddDrvFlags
    )
{
    BOOL    bReturn;
    DWORD   dwLevel;

    bReturn = AddPrinterDriverEx((LPTSTR)pszServerName,
                                 6,
                                 (LPBYTE)pDriverInfo6,
                                 dwAddDrvFlags );

    for ( dwLevel = 4 ;
          !bReturn && GetLastError() == ERROR_INVALID_LEVEL && dwLevel > 1 ;
          --dwLevel ) {

        //
        // Since DRIVER_INFO_2, 3, 4 are subsets of DRIVER_INFO_6 and all fields
        // are at the beginning these calls can be made with same buffer
        //
        bReturn = AddPrinterDriverEx((LPTSTR)pszServerName,
                                   dwLevel,
                                   (LPBYTE)pDriverInfo6,
                                   dwAddDrvFlags);
    }

    return bReturn;
}


typedef struct _MONITOR_SCAN_INFO {

    LPTSTR  pszMonitorDll;
    LPTSTR  pszTargetDir;
    BOOL    bFound;
} MONITOR_SCAN_INFO, *PMONITOR_SCAN_INFO;


UINT
MonitorCheckCallback(
    IN  PVOID    pContext,
    IN  UINT     Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:
    This callback routine is to check language monitor dll is getting copied
    to system32 directory.

Arguments:
    pContext        : Gives the MONITOR_SCAN_INFO structure
    Notification    : Ignored
    Param1          : Gives the target file name
    Param2          : Ignored

Return Value:
    Win32 error code

--*/
{
    size_t              dwLen;
    LPTSTR              pszTarget = (LPTSTR)Param1, pszFileName;
    PMONITOR_SCAN_INFO  pScanInfo = (PMONITOR_SCAN_INFO)pContext;

    if ( !pScanInfo->bFound ) {

        if ( !(pszFileName = FileNamePart(pszTarget)) )
            return ERROR_INVALID_PARAMETER;

        if ( !lstrcmpi(pScanInfo->pszMonitorDll, pszFileName) ) {

            //
            // Length excludes \ (i.e. D:\winnt\system32)
            //
            dwLen = (size_t)(pszFileName - pszTarget - 1);
            if ( !lstrncmpi(pScanInfo->pszTargetDir, pszTarget, dwLen)  &&
                 dwLen == (DWORD) lstrlen(pScanInfo->pszTargetDir) )
                pScanInfo->bFound = TRUE;
        }
    }

    return NO_ERROR;
}


BOOL
CheckAndEnqueueMonitorDll(
    IN  LPCTSTR     pszMonitorDll,
    IN  LPCTSTR     pszSource,
    IN  HSPFILEQ    CopyQueue,
    IN  HINF        hInf
    )
/*++

Routine Description:
    This routine is to check language monitor dll is getting copied to system32
    directory. On NT 4.0 we did not list LM as a file to be copied. ntprint.dll
    automatically did it. Now we use a DRID for it. But for backward
    compatibility this routine is there to get NT 4.0 INFs to work.

Arguments:
    pszMonitorDll   : Monitor dll to enqueue
    pszSource       : Source directory to look for files
    CopyQueue       : File queue
    hInf            : Printer driver INF file handle

Return Value:
    TRUE    on success, FALSE else

--*/
{
    BOOL                bRet = FALSE;
    DWORD               dwNeeded;
    LPTSTR              pszPathOnSource = NULL, pszDescription = NULL,
                        pszTagFile = NULL;
    TCHAR               szDir[MAX_PATH];
    MONITOR_SCAN_INFO   ScanInfo;
    SP_FILE_COPY_PARAMS FileCopyParams = {0};

    if ( !GetSystemDirectory(szDir, SIZECHARS(szDir)) )
        goto Cleanup;

    ScanInfo.pszMonitorDll  = (LPTSTR)pszMonitorDll;
    ScanInfo.pszTargetDir   = szDir;
    ScanInfo.bFound         = FALSE;

    if ( !SetupScanFileQueue(CopyQueue,
                             SPQ_SCAN_USE_CALLBACK,
                             0,
                             MonitorCheckCallback,
                             &ScanInfo,
                             &dwNeeded) )
        goto Cleanup;

    if ( !ScanInfo.bFound ) {

        pszPathOnSource = (LPTSTR) LocalAllocMem(MAX_PATH * sizeof(TCHAR));
        if ( !pszPathOnSource )
            goto Cleanup;

        //
        // This gives which subdirectory to look for. By default in same dir
        //
        if ( !FindPathOnSource(pszMonitorDll, hInf,
                               pszPathOnSource, MAX_PATH,
                               &pszDescription, &pszTagFile) ) {

            LocalFreeMem(pszPathOnSource);
            pszPathOnSource = NULL;
        }

        FileCopyParams.cbSize             = sizeof( SP_FILE_COPY_PARAMS );
        FileCopyParams.QueueHandle        = CopyQueue;
        FileCopyParams.SourceRootPath     = pszSource;
        FileCopyParams.SourcePath         = pszPathOnSource;
        FileCopyParams.SourceFilename     = pszMonitorDll;
        FileCopyParams.SourceDescription  = pszDescription;
        FileCopyParams.SourceTagfile      = pszTagFile;
        FileCopyParams.TargetDirectory    = szDir;
        FileCopyParams.TargetFilename     = NULL;
        FileCopyParams.CopyStyle          = SP_COPY_NEWER;
        FileCopyParams.LayoutInf          = hInf;
        FileCopyParams.SecurityDescriptor = NULL;

        if ( !SetupQueueCopyIndirect(&FileCopyParams) )
        {
            goto Cleanup;
        }
    }

    bRet = TRUE;

Cleanup:
    LocalFreeMem(pszPathOnSource);
    LocalFreeMem(pszDescription);
    LocalFreeMem(pszTagFile);

    return bRet;
}


BOOL
GetWebPageDir(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDir[MAX_PATH]
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLen;

    if(!pLocalData->DrvInfo.pszManufacturer || !pLocalData->DrvInfo.pszModelName)
    {
        goto Done;
    }

    if ( !GetSystemWindowsDirectory(szDir, MAX_PATH) )
        goto Done;

    dwLen = lstrlen(szDir) + lstrlen(szWebDirPrefix)
                           + lstrlen(pLocalData->DrvInfo.pszManufacturer)
                           + lstrlen(pLocalData->DrvInfo.pszModelName)
                           + 2;

    if ( dwLen >= MAX_PATH ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Done;
    }

    StringCchCat(szDir, MAX_PATH, szWebDirPrefix);
    StringCchCat(szDir, MAX_PATH, pLocalData->DrvInfo.pszManufacturer);
    StringCchCat(szDir, MAX_PATH, TEXT("\\"));
    StringCchCat(szDir, MAX_PATH, pLocalData->DrvInfo.pszModelName);
    bRet = TRUE;

Done:
    return bRet;
}

BOOL
SetTargetDirectories(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  HINF                hInf,
    IN  DWORD               dwInstallFlags
    )
/*++

Routine Description:
    Set all the target directories listed in the INF file for file copy
    operations. Also gets the source directory where we should look for
    driver files

Arguments:
    hDevInfo        : Handle to printer device info list
    pLocalData      : INF parsing information
    platform        : Gives the platform
    pszSource       : Source directory to look for files
    CopyQueue       : File queue
    hInf            : Printer driver INF file handle
    dwInstallFlags  : Driver installation flags

Return Value:
    TRUE    on success, FALSE else

--*/
{
    BOOL                bRet=FALSE;
    DWORD               dwNeeded, dwBytes, dwIndex, dwIndex2, dwCount, dwCount2;
    INT                 DRID;
    TCHAR               szDir[MAX_PATH];
    INFCONTEXT          InfContext;

    if ( (dwCount = SetupGetLineCount(hInf, TEXT("DestinationDirs"))) == -1 )
        goto Cleanup;

    // Setup the Skip Dir
    if ( !SetupSkipDir( platform, pszServerName ) )
        goto Cleanup;

    //
    // Process every line in the DestinationDirs section
    //
    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        if ( !SetupGetLineByIndex(hInf, TEXT("DestinationDirs"),
                                  dwIndex, &InfContext) )
            goto Cleanup;

        //
        // A file could be copied to multiple destination directories
        //
        if ( (dwCount2 = SetupGetFieldCount(&InfContext)) == 0 )
            continue;

        for ( dwIndex2 = 1 ; dwIndex2 <= dwCount2 ; ++dwIndex2 ) {

            //
            // Not all directories are specified with a DRID
            // for ex. %ProgramFiles%\%OLD_ICWDIR% could be used
            // If DRID is smaller than DIRID_USER setup has predefined
            // meaning to it
            //
            if ( !SetupGetIntField(&InfContext, dwIndex2, &DRID)    ||
                 ( DRID < DIRID_USER ) )
                continue;

            dwNeeded = SIZECHARS(szDir);
            dwBytes  = sizeof(szDir);

            switch (DRID) {

                case PRINTER_DRIVER_DIRECTORY_ID:
                    if ( !GetPrinterDriverDirectory(
                                (LPTSTR)pszServerName,
                                PlatformEnv[platform].pszName,
                                1,
                                (LPBYTE)szDir,
                                sizeof(szDir),
                                &dwNeeded) )
                    {
                        goto Cleanup;
                    }
                    if ( dwInstallFlags & DRVINST_PRIVATE_DIRECTORY ) 
                    {                        
                        //
                        // if we have a pnp-ID, and it's an installation of a native driver
                        // and it's not an inbox driver, make the files stick around for 
                        // pnp-reinstallations, else the user gets prompted over and over again
                        //
                        if ((lstrlen(pLocalData->DrvInfo.pszHardwareID) != 0)   &&
                            !(dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL)    &&
                            !IsSystemNTPrintInf(pLocalData->DrvInfo.pszInfName))
                        {
                            //
                            // add the pnp-ID to szDir and set flag to not clean up this directory
                            // this is to get around users getting prompted for pnp-reinstallation
                            //
                            AddPnpDirTag( pLocalData->DrvInfo.pszHardwareID, szDir, sizeof(szDir)/sizeof(TCHAR));

                            pLocalData->Flags |= LOCALDATAFLAG_PNP_DIR_INSTALL;
                        }
                        else
                        {
                            //
                            // Add PID\TID to szDir.
                            // If this fails, add the dir info held in szDir to the DRIVER_INFO struct
                            // anyway as we'll attempt the install with this.
                            //
                            AddDirectoryTag( szDir, sizeof(szDir)/sizeof(TCHAR) );

                        }
                        ASSERT(pLocalData);

                        //
                        // Change DI6 to have the full szDir path included.
                        // Can't do anything if this fails, so try finish install anyway.
                        //
                        AddDirToDriverInfo( szDir, &(pLocalData->InfInfo.DriverInfo6) );

                    }
                    break;

                case PRINT_PROC_DIRECTORY_ID:
                    if ( dwInstallFlags & DRVINST_DRIVERFILES_ONLY ) {

                        StringCchCopy(szDir, COUNTOF(szDir), gpszSkipDir);
                    } else if ( !GetPrintProcessorDirectory(
                                    (LPTSTR)pszServerName,
                                    PlatformEnv[platform].pszName,
                                    1,
                                    (LPBYTE)szDir,
                                    sizeof(szDir),
                                    &dwNeeded) )
                        goto Cleanup;

                    break;

                case SYSTEM_DIRECTORY_ID_ONLY_FOR_NATIVE_ARCHITECTURE:
                    if ( !(dwInstallFlags & DRVINST_DRIVERFILES_ONLY)   &&
                         platform == MyPlatform                         &&
                         MyName(pszServerName) ) {

                        if ( !GetSystemDirectory(szDir, dwNeeded) )
                            goto Cleanup;

                    } else {

                        StringCchCopy(szDir, COUNTOF(szDir),gpszSkipDir);
                    }
                    break;

                case  ICM_PROFILE_DIRECTORY_ID:
                    if ( !GetColorDirectory(pszServerName, szDir, &dwBytes) )
                        goto Cleanup;
                    break;

                case WEBPAGE_DIRECTORY_ID:
                    if ( !GetWebPageDir(pLocalData, szDir) )
                        goto Cleanup;
                    break;

                default:
                    //
                    // This is for any new DRIDs we may add in the future
                    //
                    StringCchCopy(szDir, COUNTOF(szDir), gpszSkipDir);
            }

            if ( !SetupSetDirectoryId(hInf, DRID, szDir) )
                goto Cleanup;
        }
    }

    bRet = TRUE;

Cleanup:
    return bRet;
}


BOOL
PSetupInstallICMProfiles(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    )
/*++

Routine Description:
    Install ICM color profiles associated with a printer driver.

Arguments:
    pszServerName   : Server name to which we are installing
    pszzICMFiles    : ICM profiles to install (multi-sz)

Return Value:
    TRUE on success, FALSE else

--*/
{
    TCHAR   szDir[MAX_PATH], *p;
    DWORD   dwSize, dwNeeded;
    BOOL    bRet = TRUE;

    if ( !pszzICMFiles || !*pszzICMFiles )
        return bRet;

    dwSize      = SIZECHARS(szDir);
    dwNeeded    = sizeof(szDir);

    if ( !GetColorDirectory(pszServerName, szDir, &dwNeeded) )
        return FALSE;

    dwNeeded           /= sizeof(TCHAR);
    szDir[dwNeeded-1]   = TEXT('\\');

    //
    // Install and assoicate each profiles from the multi-sz field
    //
    for ( p = (LPTSTR) pszzICMFiles; bRet && *p ; p += lstrlen(p) + 1 ) {

        if ( dwNeeded + lstrlen(p) + 1 > dwSize ) {

            ASSERT(dwNeeded + lstrlen(p) + 1 <= dwSize);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        StringCchCopy(szDir + dwNeeded, dwSize - dwNeeded, p);

        //
        // This function only supports NULL as the servername
        //
        bRet = InstallColorProfile( NULL, szDir);
    }

    return bRet;
}

BOOL
MonitorRedirectDisable(
    IN  LPCTSTR pszMonitorDll,
    OUT PTCHAR  *ppszDir
    )
{
    BOOL   bRet        = FALSE;
    PTCHAR pszBuffer   = NULL;
    DWORD  dwDirLen    = 0; 
    
    if( IsInWow64() )
    {
        pszBuffer = (PTCHAR)LocalAllocMem( MAX_PATH * sizeof( TCHAR ) );

        if((pszBuffer != NULL) && GetSystemDirectory(pszBuffer, MAX_PATH))
        {
            dwDirLen = lstrlen(pszBuffer);

            //
            // Size of the returned string + size of file name + '\' + terminating null. 
            //
            if( (dwDirLen + lstrlen(pszMonitorDll) + 2) < MAX_PATH )
            {
                if( *(pszBuffer + dwDirLen-1) != _T('\\') )
                {
                    *(pszBuffer + dwDirLen++) = _T('\\');
                    *(pszBuffer + dwDirLen)   = 0;
                }
                StringCchCat(pszBuffer, MAX_PATH, pszMonitorDll);
#if !_WIN64
                Wow64DisableFilesystemRedirector(pszBuffer);
#endif
                bRet = TRUE;
            }
        }
        if (ppszDir != NULL)
        {
            *ppszDir = pszBuffer;
        }
    }

    return bRet;
}

BOOL
MonitorRedirectEnable(
    IN OUT PTCHAR *ppszDir
    )
{
    BOOL bRet = FALSE;

    if( IsInWow64() )
    {
        //
        // This MACRO works on the current thread.  Only one file can be disabled for redirection at a time.
        //
#if !_WIN64
        Wow64EnableFilesystemRedirector();
#endif
    }

    if ((ppszDir != NULL) && (*ppszDir != NULL))
    {
        LocalFreeMem( *ppszDir );
        *ppszDir = NULL;
        bRet = TRUE;
    }

    return bRet;
}

BOOL
UseUniqueDirectory(
    IN LPCTSTR pszServerName
    )
/*++

Routine Description:
    Determines whether the unique install directory flags should be used or not.

Arguments:
    pszServerName - the name of the remote server.  NULL means local machine.

Return Value:
    TRUE if we are going remote to a whistler or more recent server
         or we are installing locally but not in setup.
    FALSE else

--*/
{
    BOOL bRet = FALSE;

    if( pszServerName && *pszServerName )
    {
        bRet = IsWhistlerOrAbove(pszServerName);
    }
    else
    {
        if( !IsSystemSetupInProgress() )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

DWORD
PSetupShowBlockedDriverUI(HWND hwnd, 
                          DWORD BlockingStatus)
/*++

Routine Description:
    Throws UI to ask user what to do with a blocked/warned driver

Arguments:
    hwnd: parent window
    BlockingStatus: the DWORD containing the BSP_* flags that indicate whether driver is blocked

Return Value:
    New blocking status, the user selection is OR'd. Treats errors as if the user cancelled.
    
--*/

{
    DWORD NewBlockingStatus = BlockingStatus;
    LPTSTR pszTitle = NULL, pszPrompt = NULL;

    switch (BlockingStatus & BSP_BLOCKING_LEVEL_MASK)
    {
    
    case BSP_PRINTER_DRIVER_WARNED:

        if (BlockingStatus & BSP_INBOX_DRIVER_AVAILABLE)
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_WARN_WITH_INBOX);

            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_YESNOCANCEL | MB_ICONWARNING))
            {
            case IDYES:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_PROCEEDED;
                break;
            case IDNO:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_REPLACED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        else // warned but not inbox available
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_WARN_NO_INBOX);

            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }
            
            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_OKCANCEL | MB_ICONWARNING))
            {
            case IDOK:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_PROCEEDED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        break;
    
    case BSP_PRINTER_DRIVER_BLOCKED:

        if (BlockingStatus & BSP_INBOX_DRIVER_AVAILABLE)
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_BLOCK_WITH_INBOX);
            
            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_OKCANCEL | MB_ICONWARNING))
            {
            case IDOK:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_REPLACED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        else // blocked and no inbox available - don't allow installation
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_ERROR);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_BLOCK_NO_INBOX);
            
            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            MessageBox(hwnd, pszPrompt, pszTitle, MB_OK | MB_ICONSTOP);
            NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
        }
        break;
    }

Cleanup:
    if (pszTitle)
    {
        LocalFreeMem(pszTitle);
    }

    if (pszPrompt)
    {
        LocalFreeMem(pszPrompt);
    }

    return NewBlockingStatus; 
}

BOOL
ValidPlatform(
             IN PLATFORM platform
             )
{

    BOOL bRet = FALSE;

    switch (platform)
    {
    
    case PlatformAlpha:
        bRet = TRUE;
        break;

    case PlatformX86:
        bRet = TRUE;
        break;

    case PlatformMIPS:
        bRet = TRUE;
        break;

    case PlatformPPC:
        bRet = TRUE;
        break;

    case PlatformWin95:
        bRet = TRUE;
        break;
    
    case PlatformIA64:
        bRet = TRUE;
        break;

    case PlatformAlpha64:
        bRet = TRUE;
        break;    
    
    default:
        bRet = FALSE;
    }

    return bRet;

}

DWORD
InstallDriverFromCurrentInf(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  HWND                hwnd,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HSPFILEQ            CopyQueue,
    IN  PVOID               QueueContext,
    IN  PSP_FILE_CALLBACK   InstallMsgHandler,
    IN  DWORD               Flags,
    IN  LPCTSTR             pszSource,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    IN  LPCTSTR             pszFileSrcPath,
    OUT LPTSTR              *ppszNewDriverName,
    OUT PDWORD              pBlockingStatus
)
{
    HINF                 hPrinterInf        = INVALID_HANDLE_VALUE;
    BOOL                 bRet               = FALSE;
    BOOL                 bAddMon            = FALSE;
    BOOL                 bKeepMonName       = FALSE;
    BOOL                 bCatInInf          = FALSE;
    DWORD                dwStatus           = EXIT_FAILURE;
    LPTSTR               pszMonitorDll,
                         psz;
    PSELECTED_DRV_INFO   pDrvInfo;
    PPARSEINF_INFO       pInfInfo;
    PVOID                pDSInfo            = NULL;   // Holds pointer to the driver signing class that C can't understand.
    FILE_QUEUE_CONTEXT   FileQContext;

    //
    // The following are only used during Cleanup
    //
    BOOL                bZeroInf  = FALSE,
                        bCopyInf = FALSE;
    DWORD dwMediaType = SPOST_NONE;
    DWORD dwInstallLE = ERROR_SUCCESS;               // We record the LastError in case Cleanup
                                                     // alters it
    LPTSTR pszINFName = NULL;                        // This will record whether the inf was
                                                     // copied in
    LPTSTR pszNewINFName = NULL;                     // Hold the name of the inf to be zeroed if necessary
    TCHAR  szFullINFName[ MAX_PATH ];                // The Original Inf Name
    TCHAR  szFullNewINFName[ MAX_PATH ];             // The fully qualified inf name as copied onto the system.
    HANDLE hDriverFile          = INVALID_HANDLE_VALUE;
    LPTSTR pszNewDriverName     = NULL;
    DWORD  fBlockingStatus      = BSP_PRINTER_DRIVER_OK;
    PTCHAR pszDirPtr            = NULL;
    DWORD  ScanResult           = 0;

    //
    // Those below are used to manage the situation when the driver is not signed
    //
    BOOL   bIsPersonalOrProfessional = FALSE;
    HANDLE hRestorePointHandle       = NULL; 
    BOOL   bDriverNotInstalled       = TRUE;
    BOOL   bIsWindows64              = FALSE;
    BOOL   bPreviousNames            = FALSE;

    DWORD        dwOEMInfFileAttrs   = 0;
    const  DWORD dwGetFileAttrsError = INVALID_FILE_ATTRIBUTES;
    
    szFullINFName[0]    = TEXT('\0');
    szFullNewINFName[0] = TEXT('\0');

    if(!pLocalData || !ValidPlatform(platform))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;

    }

    pDrvInfo = &pLocalData->DrvInfo;
    pInfInfo = &pLocalData->InfInfo;


    //
    // Set the unique directory flags if we are in a situation that uses them.
    //
    if( UseUniqueDirectory(pszServerName) ) {

        dwInstallFlags |= DRVINST_PRIVATE_DIRECTORY;
        dwAddDrvFlags  |= APD_COPY_FROM_DIRECTORY;
    }

    //
    // If this is a Windows update install, we need to ensure that all
    // cluster spooler resources get their drivers updated.
    //
    if (dwInstallFlags & DRVINST_WINDOWS_UPDATE)
    {
        dwAddDrvFlags |= APD_COPY_TO_ALL_SPOOLERS;

        pInfInfo->DriverInfo6.cVersion = dwVersion;
    }

    //
    // Open INF file and append layout.inf specified in Version section
    // Layout inf is optional
    //
    hPrinterInf = SetupOpenInfFile(pDrvInfo->pszInfName,
                                   NULL,
                                   INF_STYLE_WIN4,
                                   NULL);

    if ( hPrinterInf == INVALID_HANDLE_VALUE )
        goto Cleanup;

    SetupOpenAppendInfFile(NULL, hPrinterInf, NULL);

    pInfInfo->DriverInfo6.pEnvironment = PlatformEnv[platform].pszName;

    //
    // DI_VCP tells us not to create new file-queue and use user provided one
    //
    if ( !(Flags & DI_NOVCP) ) {

        CopyQueue = SetupOpenFileQueue();
        if ( CopyQueue == INVALID_HANDLE_VALUE )
           goto Cleanup;

        if ( dwInstallFlags & DRVINST_PROGRESSLESS ) {

            QueueContext   = SetupInitDefaultQueueCallbackEx(
                                            hwnd,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);
        } else {

            QueueContext   = SetupInitDefaultQueueCallback(hwnd);
        }

        InstallMsgHandler   = MyQueueCallback;

        ZeroMemory(&FileQContext, sizeof(FileQContext));
        FileQContext.hwnd           = hwnd;
        FileQContext.QueueContext   = QueueContext;
        FileQContext.dwInstallFlags = dwInstallFlags;
        FileQContext.pszSource      = (dwInstallFlags & DRVINST_FLATSHARE)
                                        ? pszSource : NULL;
        FileQContext.platform       = platform;
        FileQContext.dwVersion      = dwVersion;
        FileQContext.pszFileSrcPath = pszFileSrcPath;

        if (pDrvInfo->pszInfName)
        {
            StringCchCopy(FileQContext.szInfPath, COUNTOF(FileQContext.szInfPath), pDrvInfo->pszInfName);

            //
            // Cut off the inf file name
            //
            psz = _tcsrchr(FileQContext.szInfPath, _T('\\'));
            if (psz)
            {
                *psz = 0;
            }
        }
    }

    //
    // Setup the driver signing info.
    //
    if(NULL == (pDSInfo = SetupDriverSigning(hDevInfo, pszServerName,pDrvInfo->pszInfName,
                                             pszSource, platform, dwVersion, CopyQueue, dwInstallFlags & DRVINST_WEBPNP)))
    {
        goto Cleanup;
    }

    //
    // Find out if the cat was listed in a CatalogFile= entry.
    // This is used in the cleanup.
    //
    bCatInInf = IsCatInInf(pDSInfo);

    //
    // Check if this Driver is from CDM.
    // IF it is pass in the correct MediaType to Setup.
    //
    if ( (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER) || (dwInstallFlags & DRVINST_WINDOWS_UPDATE) )
       dwMediaType = SPOST_URL;

    //
    // For non admins, we install the catalog by calling AddDriverCatalog
    //
    // Do not fail the call when AddDriverCatalog fails
    //
    (void)AddDriverCatalogIfNotAdmin(pszServerName, pDSInfo, pDrvInfo->pszInfName, NULL, dwMediaType, 0);

    //
    // To support same INFs to install both NT and Win95 drivers actual
    // section to install could be different than the one corresponding
    // to the selected driver.
    //
    // SetupSetPlatformOverride tells setup which platform drivers we need
    // from the media
    // Also note setup does not reset PlatformPath override. So we need to
    // call this always
    //
    if ( !ParseInf(hDevInfo, pLocalData, platform, pszServerName, dwInstallFlags, FALSE)    ||
         !SetupSetPlatformPathOverride(PlatformOverride[platform].pszName) ) {

        goto Cleanup;
    }

    // Now do the actual file copies...
    if ( !InstallAllInfSections( pLocalData,
                                 platform,
                                 pszServerName,
                                 CopyQueue,
                                 pszSource,
                                 dwInstallFlags,
                                 hPrinterInf,
                                 pInfInfo->pszInstallSection ) )
        goto Cleanup;

    //
    // If there is a language monitor make sure it is getting copied to
    // system32. On NT 4 we used to manually queue it to system32
    //
    if ( pInfInfo->DriverInfo6.pMonitorName             &&
         platform == MyPlatform                         &&
         !(dwInstallFlags & DRVINST_DRIVERFILES_ONLY)   &&
         !pszServerName)
    {

        //
        // NOTICE-2001/06/18-rorleth -- see bug NTBUG9-416129 Installing NT4 additional driver loses LM registry information.
        //

        //
        // If it's an alternate platform but the platform really is the same (checked above)
        // it's an NT4 driver on an x86 server. In this case install the LM too if not
        // already installed else point-and-print from an NT4 client that has the same driver
        // installed locally will delete the LM info from the NT4 driver.
        // The logic is a little twisted: install the monitor if it's not an alternate platform 
        // or if it is (within the limits checked above) but no monitor with this name is installed yet.
        //
        if (!(dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL) ||
            !IsLanguageMonitorInstalled(pInfInfo->DriverInfo6.pMonitorName))
             
        {
            pszMonitorDll = pInfInfo->DriverInfo6.pMonitorName +
                                lstrlen(pInfInfo->DriverInfo6.pMonitorName) + 1;
            //
            // When we parse the INF we put the monitor dll name after \0
            //
            if ( !CheckAndEnqueueMonitorDll(pszMonitorDll,
                                            pszSource,
                                            CopyQueue,
                                            hPrinterInf) )
                goto Cleanup;

            MonitorRedirectDisable( pszMonitorDll, &pszDirPtr );

            bAddMon = TRUE;
        }
        else
        {
            //
            // we get here if it's an alternate platform driver and the monitor is already installed
            // in this case, don't clean out the monitor name from the driver info 6 below.
            // 
            bKeepMonName = TRUE;
        }
    }

    //
    // DI_NOVCP is used for pre-install when the class installer is just
    // supposed to queue the files and return. Printing needs special
    // handling since APIs need to be called. But we will obey the flags
    // as much as possible for those who use it
    //
    if ( Flags & DI_NOVCP ) {

        bRet = TRUE;
        goto Cleanup;
    }

    // We need a Queue Context to actually install files
    if ( !QueueContext )
        goto Cleanup;

    // Check if this is a WebPnP install
    if ( dwInstallFlags & DRVINST_WEBPNP || !(bAddMon || bKeepMonName) )
    {
        //
        // Check to see if there is a Monitor. If so clear out.
        // There is no need to call IsLanguageMonitorInstalled here, since if we
        // get to this point in the code either it is a Web-PnP installation
        // in which case the language monitor is useless, or the printer driver
        // (and language monitor) is for a different platform or we are installing
        // on a server different than our local machine, in which case we cannot
        // enumerate the language monitors. Note EnumMonitors does NOT enumerate
        // language monitors.
        //
        if ( pInfInfo->DriverInfo6.pMonitorName )
        {
            LocalFreeMem( pInfInfo->DriverInfo6.pMonitorName );
            pInfInfo->DriverInfo6.pMonitorName = NULL;
        }
    }
    if (!PruneInvalidFilesIfNotAdmin( hwnd,
                                      CopyQueue ))
         goto Cleanup;

    //
    // prune files that are already present (correct version etc. checked by signature), ignore return value
    //
    SetupScanFileQueue( CopyQueue,
                        (SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE),
                        hwnd,
                        NULL,
                        NULL,
                        &ScanResult);

    
    if (!pszServerName || !lstrlen(pszServerName))
    {
        bIsPersonalOrProfessional = IsProductType( VER_NT_WORKSTATION, VER_EQUAL) == S_OK;
    }
    else
    {
        bIsPersonalOrProfessional = FALSE;
    }

    if (bIsPersonalOrProfessional)
    {
        SetupSetFileQueueFlags( CopyQueue,
                                SPQ_FLAG_ABORT_IF_UNSIGNED,
                                SPQ_FLAG_ABORT_IF_UNSIGNED );
    }

    if ( !SetupCommitFileQueue(hwnd,
                               CopyQueue,
                               (PSP_FILE_CALLBACK)InstallMsgHandler,
                               (PVOID)&FileQContext) )
    {

        bIsWindows64 = IsInWow64();
        if ((bIsWindows64 == FALSE) && bIsPersonalOrProfessional && 
            (GetLastError() == ERROR_SET_SYSTEM_RESTORE_POINT))
        {

            //
            // Here we have to start a Restore Point because there is 
            // something unsigned and this is either a personal or 
            // professional.
            //
            hRestorePointHandle = StartSystemRestorePoint( NULL,
                                                           (PCWSTR)(pLocalData->DrvInfo.pszModelName),
                                                           ghInst,
                                                           IDS_BSP_WARN_UNSIGNED_DRIVER );

            //
            // Terminate the default setupapi callback
            //
            SetupTermDefaultQueueCallback( QueueContext );       
            QueueContext = NULL;

            //             
            // Initialize the QueueContext structure            
            //
            if ( dwInstallFlags & DRVINST_PROGRESSLESS ) 
            {
                QueueContext = SetupInitDefaultQueueCallbackEx(hwnd,
                                                               INVALID_HANDLE_VALUE,
                                                               0,
                                                               0,
                                                               NULL);
            } 
            else 
            {
                QueueContext = SetupInitDefaultQueueCallback(hwnd);
            }

            if (!QueueContext)
            {
                goto Cleanup;
            }             
            else
            {
                FileQContext.QueueContext = QueueContext;
            } 

            // 
            //  Reset the flag and call the function again
            //
            SetupSetFileQueueFlags( CopyQueue,
                                    SPQ_FLAG_ABORT_IF_UNSIGNED,
                                    0 );

            if ( !SetupCommitFileQueue(hwnd,
                                       CopyQueue,
                                       (PSP_FILE_CALLBACK)InstallMsgHandler,
                                       (PVOID)&FileQContext) )
            {
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }

    //
    // Now that we did the file copy part of install we will do anything
    // else specified in the INF
    //
    if ( !pszServerName && platform == MyPlatform ) 
    {

        SetupInstallFromInfSection(hwnd,
                                   hPrinterInf,
                                   pInfInfo->pszInstallSection,
                                   SPINST_ALL & (~SPINST_FILES),
                                   NULL,
                                   pszSource,
                                   0,
                                   NULL,
                                   QueueContext,
                                   hDevInfo,
                                   pDrvInfo->pDevInfoData);
    }

    if ( bAddMon )
    {
        if( !AddPrintMonitor(pInfInfo->DriverInfo6.pMonitorName, pszMonitorDll) ) 
        {
            DWORD dwSavedLastError = EXIT_FAILURE;

            //
            // If we can not add monitor, check whether this
            // driver is in printupg. If it is, consider it blocked then and 
            // popups a UI asking whether to install the replacement driver.
            //
            // After this point bRet is allways false, we only try to change
            // the error code in last error.
            //

            //
            // Save the last error first
            //
            dwSavedLastError = GetLastError();

            if (BlockedDriverPrintUpgUI(pszServerName,
                                        &pInfInfo->DriverInfo6,
                                        dwInstallFlags & DRVINST_PRIVATE_DIRECTORY,    // whether use full path
                                        !(dwInstallFlags & DRVINST_DONT_OFFER_REPLACEMENT), // whether to offer replacement
                                        !(dwInstallFlags & (DRVINST_NO_WARNING_PROMPT | DRVINST_PROMPTLESS)), // whether to popup UI
                                        &pszNewDriverName,
                                        &fBlockingStatus) &&
                (fBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
            {
                SetLastError(ERROR_PRINTER_DRIVER_BLOCKED);
            } 
            else
            {
                SetLastError(dwSavedLastError); // restore the error code
            }
               
            goto Cleanup;
        }

        MonitorRedirectEnable( &pszDirPtr );
    }

    //
    // If a print processor is specified in the INF need to install it.
    // For non-native architectur spooler fails this call (for remote case)
    // We have to install a Print Processor only in the case of a local installation AND
    // same platform.
    //
    if ( !(dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL)                   &&
         !pszServerName                                                     &&
         pInfInfo->pszPrintProc                                             &&
         !AddPrintProcessor((LPTSTR)pszServerName,
                            PlatformEnv[platform].pszName,
                            pInfInfo->pszPrintProc
                                   + lstrlen(pInfInfo->pszPrintProc) + 1,
                            pInfInfo->pszPrintProc)                         &&
         GetLastError() != ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED          &&
         GetLastError() != ERROR_INVALID_ENVIRONMENT ) 
    {
        goto Cleanup;
    }

    if (IsTheSamePlatform(pszServerName, platform) && IsWhistlerOrAbove(pszServerName))
    {
        bPreviousNames = CheckAndKeepPreviousNames( pszServerName, &pInfInfo->DriverInfo6, platform );
    }

    bRet = AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(pszServerName,
                                                              &pInfInfo->DriverInfo6,
                                                              dwAddDrvFlags | APD_DONT_SET_CHECKPOINT,
                                                              dwInstallFlags & DRVINST_PRIVATE_DIRECTORY,    // whether use full path
                                                              !(dwInstallFlags & DRVINST_DONT_OFFER_REPLACEMENT), // whether to offer replacement
                                                              !(dwInstallFlags & (DRVINST_NO_WARNING_PROMPT | DRVINST_PROMPTLESS)), // whether to popup UI
                                                              &pszNewDriverName,
                                                              &fBlockingStatus) &&
           PSetupInstallICMProfiles(pszServerName, pInfInfo->pszzICMFiles);

    if (bPreviousNames) 
    {
        LocalFreeMem( pInfInfo->DriverInfo6.pszzPreviousNames );
        pInfInfo->DriverInfo6.pszzPreviousNames = NULL;
    }

    bDriverNotInstalled = FALSE;

Cleanup:

    dwInstallLE = GetLastError(); // Get the real error message

    if (bAddMon && pszDirPtr)
    {
        MonitorRedirectEnable( &pszDirPtr );
    }

    if ((bIsWindows64 == FALSE) && hRestorePointHandle)
    {
        //
        // Here we have to end the Restore Point because one was 
        // started
        //
        EndSystemRestorePoint(hRestorePointHandle, bDriverNotInstalled);
    }

    if (hDriverFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDriverFile);
    }

    //
    // Zero the inf if DI_NOVCP and - either we've fail, it is a Web PNP 
    // install. or - this is installing from a non-system ntprint.inf AND 
    // there is a cat to be protected. - not yet!!
    //
    bZeroInf = (!bRet || ( dwInstallFlags & DRVINST_WEBPNP )
                      || (IsNTPrintInf( pDrvInfo->pszInfName ) && bCatInInf)) &&
               !(Flags & DI_NOVCP);

    //
    // We have to copy the INF if the following conditions are satisfied
    //

    bCopyInf = // bRet is TRUE (the call to AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry succeeded)
               bRet                                                           &&
               // and the Installation flags say the INF to be copied 
               !(dwInstallFlags & DRVINST_DONOTCOPY_INF)                      &&
               // and the platform is the same as ours 
               platform == MyPlatform                                         &&
               // and the INF it's not the system ntprint.inf (obviously) or
               // it's from WU 
               (!IsSystemNTPrintInf(pDrvInfo->pszInfName) || (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER)) &&
               // and DI_NOVCP flag is not set
               !(Flags & DI_NOVCP)                                            &&
               // and this is not Web PnP or there is a cat to protect
               !((dwInstallFlags & DRVINST_WEBPNP) && !bCatInInf)             &&
               // and this is not ntprint.inf or there is a cat to protect
               !(IsNTPrintInf( pDrvInfo->pszInfName ) && !bCatInInf);


    //
    // How we have to call SetupCopyOEMInf to take the name of the INF which
    // has been copied on our system when we called SetupCommitFileQueue
    //
    if (!SetupCopyOEMInf(pDrvInfo->pszInfName,
                         NULL,
                         dwMediaType,
                         SP_COPY_REPLACEONLY,
                         szFullINFName,
                         MAX_PATH,
                         NULL,
                         &pszINFName) ) 
    {
        // If we can't find the original name might as well not copy or
        // zero

        if (bZeroInf && !bCopyInf)
        {
            bZeroInf = FALSE;
        }
    } 
    else 
    {
        if (bZeroInf) 
        {
            bCopyInf = FALSE;
        }
    }

    //
    // If we succesfully installed a native architecture driver
    // then is when we copy the OEM INF file and give it a unique name
    //
    if ( bCopyInf ) 
    {

        //
        // Earlier we used to call CopyOEMInfFileAndGiveUniqueName here
        // Now that Setup API has this and we are going to support CDM
        // we call this setup API
        //
        (VOID)SetupCopyOEMInf(pDrvInfo->pszInfName,
                              NULL,
                              dwMediaType,
                              SP_COPY_NOOVERWRITE,
                              szFullNewINFName,
                              MAX_PATH,
                              NULL,
                              &pszNewINFName);
       //
       // If this fails we don't give the proverbial, since the file won't 
       // be there
       // 
    }
    else
    {
        if (!bZeroInf && !(Flags & DI_NOVCP))
        {
            //
            // We have to remove the INF in the case of unsuccessful installation and ONLY if the DI_NOVCP
            // flag is not set. If the flag is set then we don't have to change the state because the file
            // queue hasn't been commited and the INF just has been already there before the call to our
            // function.
            //

            //
            // Remove the READONLY file attribute if set
            //
            dwOEMInfFileAttrs = GetFileAttributes( szFullINFName );
            if ((dwOEMInfFileAttrs != dwGetFileAttrsError) &&
                (dwOEMInfFileAttrs & FILE_ATTRIBUTE_READONLY))
            {
                dwOEMInfFileAttrs &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes( szFullINFName, dwOEMInfFileAttrs);
            }
            DeleteFile( szFullINFName );
        }
    }

    // Ignore the error message from SetupCopyOEMInf and DeleteFile
    dwStatus = bRet ? ERROR_SUCCESS : dwInstallLE;

    // If the install failed or this was Web Point&Print
    // we may need to get rid of the INF
    if ( bZeroInf )
    {
       // If INFName is different then possibly set to 0 length
       // Or this is ntprint.inf being renamed to OEMx.inf - we want it zeroed.
       if (( pszINFName                                 &&
             (psz=FileNamePart( pDrvInfo->pszInfName )) &&
             lstrcmp( psz, pszINFName )                   ) ||
           ( IsNTPrintInf( pDrvInfo->pszInfName )       &&
             bCatInInf                                  &&
             pszNewINFName                              &&
             (psz=FileNamePart( pDrvInfo->pszInfName )) &&
             lstrcmp( psz, pszINFName )                   )   )
       {
          HANDLE       hFile;

          //
          // Remove the READONLY file attribute if set
          //
          dwOEMInfFileAttrs = GetFileAttributes(szFullINFName ? szFullINFName : szFullNewINFName);
          if ((dwOEMInfFileAttrs != dwGetFileAttrsError) &&
              (dwOEMInfFileAttrs & FILE_ATTRIBUTE_READONLY))
          {
              dwOEMInfFileAttrs &= ~FILE_ATTRIBUTE_READONLY;
              SetFileAttributes(szFullINFName ? szFullINFName : szFullNewINFName, dwOEMInfFileAttrs);
          }

          // Open the File
          hFile = CreateFile( szFullINFName ? szFullINFName : szFullNewINFName,
                              (GENERIC_READ | GENERIC_WRITE),
                              ( FILE_SHARE_READ | FILE_SHARE_WRITE ),
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

          // If we opened a file
          if ( hFile != INVALID_HANDLE_VALUE )
          {
                SetFilePointer( hFile, 0, 0, FILE_BEGIN );
                SetEndOfFile( hFile );
                CloseHandle( hFile );
          }
       }
    }

    if ( hPrinterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(hPrinterInf);

    //
    // Free the Driver Signing class.
    //
    if(pDSInfo)
    {
        CleanupDriverSigning(pDSInfo);
    }

    if ( !(Flags & DI_NOVCP) ) {

        //
        // The driver signing code may have associated the queue to the SP_DEVINSTALL_PARAMS.
        // We've finished with this and need to remove the queue from the SP_DEVINSTALL_PARAMS before we delete it.
        //
        SP_DEVINSTALL_PARAMS DevInstallParams = {0};
        DevInstallParams.cbSize = sizeof(DevInstallParams);

        if(SetupDiGetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams))
        {
            if(DevInstallParams.FileQueue == CopyQueue)
            {
                DevInstallParams.FlagsEx &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
                DevInstallParams.Flags &= ~DI_NOVCP;
                DevInstallParams.FileQueue = INVALID_HANDLE_VALUE;
                SetupDiSetDeviceInstallParams(hDevInfo,
                                              NULL,
                                              &DevInstallParams);
            }
        }

        //
        // Now free up the queue.
        //
        if ( CopyQueue != INVALID_HANDLE_VALUE )
        {
            SetupCloseFileQueue(CopyQueue);
        }

        if ( QueueContext )
        {
            SetupTermDefaultQueueCallback(QueueContext);
        }

        if( dwAddDrvFlags & APD_COPY_FROM_DIRECTORY ) 
        {

            //
            // if this was an installation with a path derived from the Pnp-ID,
            // do not cleanup, else users will get prompted for media when they re-pnp the driver
            //
            if ( ! (pLocalData->Flags & LOCALDATAFLAG_PNP_DIR_INSTALL) )
            {
                CleanupUniqueScratchDirectory( pszServerName, platform );
            }
        } 
        else 
        {

            CleanupScratchDirectory( pszServerName, platform );
        }
    }

    //
    // Return the new driver name and the blocking flags if they were asked for.
    // 
    if (ppszNewDriverName)
    {
        *ppszNewDriverName = pszNewDriverName;
    }
    else if (pszNewDriverName)
    {
        LocalFreeMem(pszNewDriverName);
    }

    if (pBlockingStatus)
    {
        *pBlockingStatus = fBlockingStatus;
    }

    return  dwStatus;
}


DWORD
InstallDriverAfterPromptingForInf(
    IN      PLATFORM    platform,
    IN      LPCTSTR     pszServerName,
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModelName,
    IN      DWORD       dwVersion,
    IN OUT  TCHAR       szInfPath[MAX_PATH],
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags,
    OUT     LPTSTR      *ppszNewDriverName
    )
{
    DWORD               dwRet, dwTitleId, dwMediaId;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    LPTSTR               pszFileSrcPath = NULL;
    DWORD               dwBlockingStatus = BSP_PRINTER_DRIVER_OK;

    switch (platform) {

        case PlatformAlpha:
            dwTitleId = IDS_DRIVERS_FOR_NT4_ALPHA;
            break;

        case PlatformX86:
            if( dwVersion == 2 )
            {
                dwTitleId = IDS_DRIVERS_FOR_NT4_X86;
            }
            else
            {
                dwTitleId = IDS_DRIVERS_FOR_X86;
            }
            break;

        case PlatformMIPS:
            dwTitleId = IDS_DRIVERS_FOR_NT4_MIPS;
            break;

        case PlatformPPC:
            dwTitleId = IDS_DRIVERS_FOR_NT4_PPC;
            break;

        case PlatformIA64:
            dwTitleId = IDS_DRIVERS_FOR_IA64;
            break;

        default:
            ASSERT(0);
            return  ERROR_INVALID_PARAMETER;
    }

    dwMediaId = IDS_PROMPT_ALT_PLATFORM_DRIVER;

    dwInstallFlags |= DRVINST_ALT_PLATFORM_INSTALL | DRVINST_NO_WARNING_PROMPT;
    
    hDevInfo = GetInfAndBuildDrivers(hwnd,
                                     dwTitleId,
                                     dwMediaId,
                                     szInfPath,
                                     dwInstallFlags,
                                     platform, dwVersion,
                                     pszModelName,
                                     &pLocalData,
                                     &pszFileSrcPath);

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {

        dwRet = GetLastError();
        goto Cleanup;
    }

    //
    // we want the printupg prompt
    //
    dwInstallFlags &= ~DRVINST_NO_WARNING_PROMPT;

    dwRet = InstallDriverFromCurrentInf(hDevInfo,
                                        pLocalData,
                                        hwnd,
                                        platform,
                                        dwVersion,
                                        pszServerName,
                                        INVALID_HANDLE_VALUE,
                                        NULL,
                                        NULL,
                                        0,
                                        szInfPath,
                                        dwInstallFlags,
                                        dwAddDrvFlags,
                                        pszFileSrcPath,
                                        ppszNewDriverName,
                                        &dwBlockingStatus);

    if (((ERROR_PRINTER_DRIVER_BLOCKED == dwRet) || (ERROR_PRINTER_DRIVER_WARNED == dwRet)) && 
        (ppszNewDriverName && *ppszNewDriverName) &&
        (dwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
    {
        //
        // We pass NULL instead of pLocalData here since InstallDriverAfterPromptingForInf
        // is not called when we want to setup a printer queue, but when the platform
        // and/or version of the driver matches that of our local platform or version
        // does not match our dwMajorVersion (note when installing a printer queue
        // through the APW that uses an NT4 driver dwVersion will be set to 3 so
        // InstallDriverFromCurrentInf will be called instead!). Thus we do not
        // need to pass back e.g. print processor, color profiles and vendor setup dlls.
        //
        dwRet = InstallReplacementDriver(hwnd, 
                                         pszServerName, 
                                         *ppszNewDriverName,
                                         platform,
                                         dwVersion,
                                         dwInstallFlags,
                                         dwAddDrvFlags,
                                         NULL);
    }
    else if (ppszNewDriverName && *ppszNewDriverName)
    {
        LocalFreeMem(*ppszNewDriverName);
        *ppszNewDriverName = NULL;
    }

Cleanup:

    if (pszFileSrcPath)
    {
        //
        // we did the NT4 copy/expand thing -> delete the expanded inf!
        //
        if(SUCCEEDED(StringCchCat(szInfPath, MAX_PATH, _T("ntprint.inf"))))
        {
            DeleteFile(szInfPath);
        }

        LocalFreeMem(pszFileSrcPath);
    }

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    DestroyLocalData(pLocalData);

    return dwRet;
}


const TCHAR   gcszNTPrint[]  = _TEXT("inf\\ntprint.inf");

DWORD GetNtprintDotInfPath(LPTSTR pszNTPrintInf, DWORD len)
{
    DWORD dwLastError = ERROR_INVALID_DATA, dwSize, dwRemainingSize;
    LPTSTR pData;

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //  If the return is greater than MAX_PATH we want to fail as something has managed to change
    //  the system dir to longer than MAX_PATH which is invalid.
    //
    dwSize = GetSystemWindowsDirectory( pszNTPrintInf, len );
    if( !dwSize || dwSize > len )
        goto Cleanup;

    //
    // If we don't end in a \ then add one.
    //
    dwSize = _tcslen(pszNTPrintInf);
    pData = &(pszNTPrintInf[ dwSize-1 ]);
    if (*pData++ != _TEXT('\\') )
    {
        if (dwSize + 1 < len)
        {
            *(pData++) = _TEXT('\\');
            dwSize++;
        }
        else
        {
            goto Cleanup;
        }
    }

    dwRemainingSize = len - dwSize;

    *(pData) = 0;
    dwSize += _tcslen( gcszNTPrint ) + 1;

    //
    // If what we've got sums up to a longer string than the allowable length MAX_PATH - fail
    //
    if ( dwSize > len )
        goto Cleanup;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    StringCchCopy( pData, dwRemainingSize, gcszNTPrint);

    dwLastError = ERROR_SUCCESS;

Cleanup:

    if (dwLastError != ERROR_SUCCESS)
    {
        //
        // Got here due to some error.  Get what the called function set the last error to.
        // If the function set a success, set some error code.
        //
        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS)
        {
            dwLastError = ERROR_INVALID_DATA;
        }

        if (len)
        {
            pszNTPrintInf[0] = 0;
        }
    }
    return dwLastError;
}

DWORD
InstallReplacementDriver(HWND                hwnd, 
                         LPCTSTR             pszServerName, 
                         LPCTSTR             pszModelName, 
                         PLATFORM            platform,
                         DWORD               version,
                         DWORD               dwInstallFlags,
                         DWORD               dwAddDrvFlags,
                         PPSETUP_LOCAL_DATA  pOldLocalData)

/*++

Routine Description:
    Install an inbox replacement driver for blocked/warned drivers.

Arguments:
    hwnd            : parent windows handle.
    pszServerName   : Server name to which we are installing
    pszModelName    : driver model name to install
Return Value:
    ERROR_SUCCESS on success, error code otherwise

--*/

{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    PPSETUP_LOCAL_DATA pLocalData = NULL;
    TCHAR szNtprintDotInf[MAX_PATH];
    DWORD dwLastError;

    if ((dwLastError = GetNtprintDotInfPath(szNtprintDotInf, COUNTOF(szNtprintDotInf))) != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    if ((hDevInfo = PSetupCreatePrinterDeviceInfoList(NULL)) != INVALID_HANDLE_VALUE    &&
        PSetupBuildDriversFromPath(hDevInfo, szNtprintDotInf, TRUE)                     &&
        PSetupPreSelectDriver(hDevInfo, NULL, pszModelName)                             &&
        (pLocalData = BuildInternalData(hDevInfo, NULL)) != NULL                        &&
        ParseInf(hDevInfo, pLocalData, platform, NULL, dwInstallFlags, FALSE))
    {
        //
        // Don't prompt for blocked or warned drivers.
        // 
        dwInstallFlags |= DRVINST_NO_WARNING_PROMPT;

        dwLastError = InstallDriverFromCurrentInf(  hDevInfo,
                                                    pLocalData,
                                                    hwnd,
                                                    platform,
                                                    version,
                                                    pszServerName,
                                                    INVALID_HANDLE_VALUE,
                                                    NULL,
                                                    NULL,
                                                    0,
                                                    szNtprintDotInf,
                                                    dwInstallFlags,
                                                    dwAddDrvFlags,
                                                    NULL,
                                                    NULL,
                                                    NULL);
    }
    else
    {
        dwLastError = GetLastError();
    }

Cleanup:
   if(pOldLocalData && pLocalData)
   {
       //
       // The following code is almost identical to PSetupDestroySelectedDriverInfo,
       // only that we do not free the memory allocated for the pOldLocalData structure.
       //
       if ( pLocalData->Flags & VALID_INF_INFO )
           FreeStructurePointers((LPBYTE)&pOldLocalData->InfInfo,
                                 InfInfoOffsets,
                                 FALSE);

       if ( pLocalData->Flags & VALID_PNP_INFO )
           FreeStructurePointers((LPBYTE)&pOldLocalData->PnPInfo,
                                 PnPInfoOffsets,
                                 FALSE);

       FreeStructurePointers((LPBYTE)pOldLocalData, LocalDataOffsets, FALSE);

       //
       // Now copy the new data into the old pLocalData structure
       //
       *pOldLocalData = *pLocalData;
   }
   else if(pLocalData)
    {
        PSetupDestroySelectedDriverInfo(pLocalData);
    }

    //
    // Release the driver setup parameter handle.
    //
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        PSetupDestroyPrinterDeviceInfoList( hDevInfo );
    }

    return dwLastError;
}

//
// Paths where we search for the driver files
//
SPLPLATFORMINFO szPlatformExtn[] = {

    { TEXT("\\alpha") },
    { TEXT("\\i386") },
    { TEXT("\\mips") },
    { TEXT("\\ppc") },
    { TEXT("") },
    { TEXT("\\ia64") }
};


VOID
GetCDRomDrive(
    TCHAR   szDrive[5]
    )
{
    DWORD   dwDrives;
    INT     iIndex;

    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\\');
    szDrive[3] = TEXT('\0');
    dwDrives = GetLogicalDrives();

    for ( iIndex = 0 ; iIndex < 26 ; ++iIndex )
        if ( dwDrives & (1 << iIndex) ) {

            szDrive[0] = TEXT('A') + iIndex;
            if ( GetDriveType(szDrive) == DRIVE_CDROM )
                goto Done;
        }

    szDrive[0] = TEXT('A');

Done:
    return;
}


BOOL
BuildPathToPrompt(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  TCHAR               szPathOut[MAX_PATH]
    )
/*++
--*/
{
    LPTSTR  pszExtn = TEXT("");
    DWORD   dwLen;

    //
    // NTRAID#NTBUG9-527971-2002/03/06-mikaelho
    // The function BuildPathToPromp in ntprint.dll does not take into account that x86 NT4 drivers
    // are delivered with the OS (on IA64 server installations) and will always prompt you for driver,
    // even if the OS was installed from a network share and we know where to retrieve the driver.
    //
    
    //
    // The CD we installed from OS can have only the following drivers:
    //      -- NT5 same platform drivers
    //      -- NT4 same platform drivers (only on server CD)
    //      -- Win9x drivers (only on server CD)
    //
    if ( (platform == MyPlatform && dwVersion >= 2)     ||
         platform == PlatformWin95 ) {

        GetDriverPath(hDevInfo, pLocalData, szPathOut);
    } else {

        GetCDRomDrive(szPathOut);
    }

    if ( dwVersion >= dwThisMajorVersion && platform == MyPlatform )
        return TRUE;

    //
    // append a backslash if needed
    //
    dwLen = lstrlen(szPathOut);

    if (dwLen && (dwLen + 1 < MAX_PATH) && (szPathOut[dwLen-1] != TEXT('\\')))
    {
        szPathOut[dwLen] = TEXT('\\');
        szPathOut[++dwLen]   = 0;
    }

    switch (dwVersion) {

        case    0:
            if ( platform == PlatformWin95 )
                pszExtn   = TEXT("printers\\Win9X\\");

            //
            // For NT 3.51 and 3.1 we do not include drivers on CD, so
            // nothing to add to the base path
            //
        case    1:
            break;

        case    2:
            if ( platform == PlatformX86 )  // Alpha is now on the NT4.0 CD
                pszExtn = TEXT("printers\\NT4\\");
            break;

        case    3:
            break;

        default:
            ASSERT(dwVersion <= 3);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    if ( dwLen + lstrlen(pszExtn) + lstrlen(szPlatformExtn[platform].pszName) + 1
                > MAX_PATH ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    StringCchCat(szPathOut, MAX_PATH, pszExtn);

    //
    // Skip the leading \ of the platform extension as we have one already.
    //
    StringCchCat(szPathOut, MAX_PATH, &(szPlatformExtn[platform].pszName[1]));

    return TRUE;
}


DWORD
PSetupInstallPrinterDriver(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszDriverName,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszSource       OPTIONAL,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    OUT LPTSTR             *ppszNewDriverName
    )
/*++

Routine Description:
    Copies all the necessary driver files to the printer driver directory so
    that an AddPrinterDriver call could be made. . This function also prompt
    user for disk if necessary, prompt in case of unsigned driver or if the
    printer driver is warned or block. In addition to printer drivers it also
    installs language monitors, Color Profiles and Print Processors.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pLocalData      : Gives information got by parsing the inf
    pszDriverName   : Printer driver name, used only if pLocalData is NULL
    platform        : Platform for which drivers need to be installed
    dwVersion       : Version of the driver to install
    pszServerName   : Server on which driver should be installed
    hwnd            : Parent windows handle for UI
    pszDiskName     : Disk name for prompting
    pszSource       : If provided this is a flat directory having all the files
    dwAddDrvFlags   : Flags for AddPrinterDriverEx

Return Value:
    On succesfully copying files ERROR_SUCCESS, else the error code

--*/
{
    BOOL            bDeleteLocalData = pLocalData == NULL;
    DWORD           dwRet;
    TCHAR           szPath[MAX_PATH];
    
    szPath[0] = 0;

    if( !( (dwVersion == 0) || (dwVersion == 2) || (dwVersion == 3) ) )
    {
        SetLastError(dwRet = ERROR_INVALID_PARAMETER);
        return dwRet;
    }

    if ( pszSource && !*pszSource )
        pszSource = NULL;

    if ( pLocalData )
    {
        ASSERT(pLocalData->signature == PSETUP_SIGNATURE && !pszDriverName);
    }
    else
    {
        ASSERT(pszDriverName && *pszDriverName);
    }

    //
    // If FLATSHARE bit is set then a path should be given
    //
    ASSERT( (dwInstallFlags & DRVINST_FLATSHARE) == 0 || pszSource != NULL );

Retry:

    //
    // If a path is given use it. Otherwise if this is a driver for different
    // version or platform then we determine the path, otherwise let SetupAPI determine the
    // path.
    //
    if ( dwVersion != dwThisMajorVersion || platform != MyPlatform ) {

        // If this is not an NT5 driver and we are asked to get it
        //  from the web, then just return.....
        if ( pLocalData &&
             ( pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER ) )
           return ERROR_SUCCESS;

        if ( pszSource )
            StringCchCopy(szPath, COUNTOF(szPath), pszSource);
        else if ( !BuildPathToPrompt(hDevInfo,
                                     pLocalData,
                                     platform,
                                     dwVersion,
                                     szPath) ) {

            if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
                dwRet = STG_E_UNKNOWN;

            return dwRet;
        }
    }

    //
    // For Win95 drivers we need to parse their INFs,
    // For non native environemnt dirvers ask user for path
    //
    if ( platform == PlatformWin95 ) {

        if ( pLocalData ) {

            //
            // Parse the inf so that we can pick up any
            // previous names entries and use them.
            //
            if ( !ParseInf(hDevInfo, pLocalData, MyPlatform,
                           pszServerName, dwInstallFlags, FALSE) )
                return GetLastError();

            dwRet = InstallWin95Driver(hwnd,
                                       pLocalData->DrvInfo.pszModelName,
                                       pLocalData->DrvInfo.pszzPreviousNames,
                                       (pLocalData->DrvInfo.Flags &
                                            SDFLAG_PREVNAME_SECTION_FOUND),
                                       pszServerName,
                                       szPath,
                                       pszDiskName,
                                       dwInstallFlags,
                                       dwAddDrvFlags);
        } else {
            dwRet = InstallWin95Driver(hwnd,
                                       pszDriverName,
                                       NULL,
                                       TRUE, // Exact model name match only
                                       pszServerName,
                                       szPath,
                                       pszDiskName,
                                       dwInstallFlags,
                                       dwAddDrvFlags);
        }
    } else if ( dwVersion != dwThisMajorVersion || platform != MyPlatform ) {

        dwRet = InstallDriverAfterPromptingForInf(
                            platform,
                            pszServerName,
                            hwnd,
                            pLocalData ?
                                pLocalData->DrvInfo.pszModelName :
                                pszDriverName,
                            dwVersion,
                            szPath,
                            dwInstallFlags,
                            dwAddDrvFlags,
                            ppszNewDriverName);

    } else if ( pLocalData  &&
                (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER) ) {

        dwRet = PSetupInstallPrinterDriverFromTheWeb(hDevInfo,
                                                     pLocalData,
                                                     platform,
                                                     pszServerName,
                                                     &OsVersionInfo,
                                                     hwnd,
                                                     pszSource);
    } else {

        if ( !pLocalData )
        {
            pLocalData = PSetupDriverInfoFromName(hDevInfo, pszDriverName);
        }

        if ( pLocalData )
        {
            DWORD dwBlockingStatus = BSP_PRINTER_DRIVER_OK;

            dwRet = InstallDriverFromCurrentInf(hDevInfo,
                                                pLocalData,
                                                hwnd,
                                                platform,
                                                dwVersion,
                                                pszServerName,
                                                INVALID_HANDLE_VALUE,
                                                NULL,
                                                NULL,
                                                0,
                                                pszSource,
                                                dwInstallFlags,
                                                dwAddDrvFlags,
                                                NULL,
                                                ppszNewDriverName,
                                                &dwBlockingStatus);

            if ((ppszNewDriverName && *ppszNewDriverName)         &&
                (dwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
            {
                dwRet = InstallReplacementDriver(hwnd, 
                                                 pszServerName, 
                                                 *ppszNewDriverName,
                                                 platform,
                                                 dwVersion,
                                                 dwInstallFlags,
                                                 dwAddDrvFlags,
                                                 pLocalData);
            }
            else if (ppszNewDriverName && *ppszNewDriverName)
            {
                LocalFreeMem(*ppszNewDriverName);
                *ppszNewDriverName = NULL;
            }
        }
        else
        {
            dwRet = GetLastError();
        }

    }

    if (
         (dwRet == ERROR_EXE_MACHINE_TYPE_MISMATCH) &&
         !(dwInstallFlags & DRVINST_PROMPTLESS)
       ) 
    {

        int i;
        TCHAR   szTitle[256], szMsg[256];

        LoadString(ghInst,
                   IDS_INVALID_DRIVER,
                   szTitle,
                   SIZECHARS(szTitle));

        LoadString(ghInst,
                   IDS_WRONG_ARCHITECTURE,
                   szMsg,
                   SIZECHARS(szMsg));

        i = MessageBox(hwnd,
                       szMsg,
                       szTitle,
                       MB_RETRYCANCEL | MB_ICONSTOP | MB_DEFBUTTON1 | MB_APPLMODAL);

        if ( i == IDRETRY )
        {
            if ( bDeleteLocalData )
            {
                DestroyLocalData(pLocalData);
                pLocalData = NULL;
            }

            goto Retry;
        }
        else
        {
            SetLastError(dwRet =ERROR_CANCELLED);
        }
    }    

    if ( bDeleteLocalData )
        DestroyLocalData(pLocalData);

    return dwRet;
}


//
// SCAN_INFO structure is used with SetupScanFileQueue to find dependent files
// and ICM files
//
typedef struct _SCAN_INFO {

    BOOL                bWin95;
    PPSETUP_LOCAL_DATA  pLocalData;
    DWORD               cchDependentFiles, cchICMFiles;
    DWORD               cchDriverDir, cchColorDir;
    LPTSTR              p1, p2;
    TCHAR               szDriverDir[MAX_PATH], szColorDir[MAX_PATH];
} SCAN_INFO, *PSCAN_INFO;


UINT
DriverInfoCallback(
    IN  PVOID    pContext,
    IN  UINT     Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:

    This callback routine is used with SetupScanFileQueue to findout the
    dependent files and ICM files associated in an INF. All files going to the
    printer driver directory are dependent files in DRIVER_INFO_6, and all
    files goint to the Color directory are ICM files.

    We use SetupScanFileQueue twice. We find the size of the buffers required
    for the multi-sz fields in the first pass. After allocating buffers of size
    found in first pass second pass is used to copy the strings and build the
    multi-sz fields.

Arguments:

    pContext        : Gives the SCAN_INFO structure
    Notification    : Ignored
    Param1          : Gives the target file name
    Param2          : Ignored

Return Value:
    Win32 error code

--*/
{
    DWORD               dwLen;
    LPTSTR              pszTarget = (LPTSTR)Param1, pszFileName;
    PSCAN_INFO          pScanInfo = (PSCAN_INFO)pContext;
    LPDRIVER_INFO_6     pDriverInfo6;

    pszFileName = FileNamePart(pszTarget);

    if ( pszFileName )
    {
        dwLen = lstrlen(pszFileName) + 1;

        if ( !lstrncmpi(pszTarget,
                        gpszSkipDir,
                        lstrlen( gpszSkipDir ) ) )
           goto Done;

        if ( !lstrncmpi(pszTarget,
                        pScanInfo->szDriverDir,
                        pScanInfo->cchDriverDir) ) {

            pDriverInfo6 = &pScanInfo->pLocalData->InfInfo.DriverInfo6;
            //
            // On NT dependent file list will not include files appearing as
            // other DRIVER_INFO_6 fields
            //
            if ( !pScanInfo->bWin95 &&
                 ( !lstrcmpi(pszFileName, pDriverInfo6->pDriverPath)  ||
                   !lstrcmpi(pszFileName, pDriverInfo6->pConfigFile)  ||
                   !lstrcmpi(pszFileName, pDriverInfo6->pDataFile)    ||
                   ( pDriverInfo6->pHelpFile &&
                     !lstrcmpi(pszFileName, pDriverInfo6->pHelpFile))) )
                goto Done;

            //
            // If pointer is not NULL this is pass 2
            //
            if ( pScanInfo->p1 ) {

                StringCchCopy(pScanInfo->p1, dwLen, pszFileName);
                pScanInfo->p1 += dwLen;
            } else {

                pScanInfo->cchDependentFiles  += dwLen;
            }
        } else if ( !lstrncmpi(pszTarget,
                               pScanInfo->szColorDir,
                               pScanInfo->cchColorDir) ) {

            //
            // If pointer is not NULL this is pass 2
            //
            if ( pScanInfo->p2 ) {

                StringCchCopy(pScanInfo->p2, dwLen, pszFileName);
                pScanInfo->p2 += dwLen;
            } else {

                pScanInfo->cchICMFiles  += dwLen;
            }
        }
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

Done:
    return NO_ERROR;
}


BOOL
InfGetDependentFilesAndICMFiles(
    IN      HDEVINFO            hDevInfo,
    IN      HINF                hInf,
    IN      BOOL                bWin95,
    IN OUT  PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      LPCTSTR             pszSectionNameWithExt,
    IN OUT  LPDWORD             pcchSize
    )
/*++

Routine Description:
    Findout the dependent files for the DRIVER_INFO_6 and the ICM files
    for the selected driver

    This is done by simulating the install operation by create a setup
    queue to do the install operations and scanning the queue to find out
    where files are getting copied to

    Dependent files are those getting copied to driver scratch directory
    without including other DRIVER_INFO_6 fields like pDriverPath. For Win95
    case all files getting copied to the driver directory are dependent files.

    ICM files are those getting copied to the color directory

Arguments:
    hInf                    : INF handle
    bWin95                  : TRUE if it is a Win95 INF
    pLocalData              : INF parsing information
    pszSectionNameWithExt   : Section name with extension for install
    pcchSize                : Size needed for DRIVER_INFO_6 and strings in it

Return Value:
    TRUE on success, FALSE on error

--*/
{
    BOOL        bRet         = FALSE;
    DWORD       dwResult;
    PSCAN_INFO  pScanInfo    = NULL;
    HSPFILEQ    ScanQueue    = INVALID_HANDLE_VALUE;
    LPTSTR      ppszDepFiles = NULL,
                pszzICMFiles = NULL;

    PSP_DEVINSTALL_PARAMS pStoreDevInstallParams = NULL;
    PSP_DEVINSTALL_PARAMS pDevInstallParams      = NULL;
    SP_ALTPLATFORM_INFO   AltPlat_Info           = {0};
    POSVERSIONINFO        pOSVer                 = NULL;

    pStoreDevInstallParams = LocalAllocMem(sizeof(SP_DEVINSTALL_PARAMS));
    if(!pStoreDevInstallParams)
    {
        goto Cleanup;
    }
       
    pDevInstallParams = LocalAllocMem(sizeof(SP_DEVINSTALL_PARAMS));
    if(!pDevInstallParams)
    {
        goto Cleanup;
    }

    pOSVer = LocalAllocMem(sizeof(OSVERSIONINFO));
    if(!pOSVer)
    {
        goto Cleanup;
    }
    
    pScanInfo = LocalAllocMem(sizeof(SCAN_INFO));
    if(!pScanInfo)
    {
        goto Cleanup;
    }

    pScanInfo->p1 = pScanInfo->p2 = NULL;
    pScanInfo->cchDependentFiles = pScanInfo->cchICMFiles = 0;

    pScanInfo->cchColorDir    = sizeof(pScanInfo->szColorDir);
    pScanInfo->cchDriverDir   = sizeof(pScanInfo->szDriverDir);

    if ( !GetColorDirectory( pszServerName, pScanInfo->szColorDir, &pScanInfo->cchColorDir) ||
         !GetSystemDirectory(pScanInfo->szDriverDir, (pScanInfo->cchDriverDir / sizeof(TCHAR)) ) ) {

        goto Cleanup;
    }

    //
    // Set pScanInfo->cchColorDir to char count of pScanInfo->szColorDir without \0
    //
    pScanInfo->cchColorDir /= sizeof(TCHAR);
    --pScanInfo->cchColorDir;

    //
    // Win95 INFs tell setup to copy the driver files to system32 directory
    // NT INFs expect install programs to set the target using
    // SetupSetDirectoryId
    //
    if ( bWin95 ) {

        pScanInfo->cchDriverDir = lstrlen(pScanInfo->szDriverDir);
    } else {
        if ( !GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                        PlatformEnv[platform].pszName,
                                        1,
                                        (LPBYTE)pScanInfo->szDriverDir,
                                        pScanInfo->cchDriverDir,
                                        &pScanInfo->cchDriverDir) )
            goto Cleanup;
        //
        // Set pScanInfo->cchDriverDir to char count of pScanInfo->szDriverDir
        // without \0
        //
        pScanInfo->cchDriverDir   /= sizeof(TCHAR);
        --pScanInfo->cchDriverDir;
    }

    //
    // Inf MAY refer to another one (like layout.inf)
    //
    SetupOpenAppendInfFile(NULL, hInf, NULL);

    pScanInfo->bWin95     = bWin95;
    pScanInfo->pLocalData = pLocalData;

    ScanQueue = SetupOpenFileQueue();

    if (ScanQueue == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    pDevInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                      NULL,
                                      pDevInstallParams))
    {
        goto Cleanup;
    }

    if(!GetOSVersion(pszServerName, pOSVer))
    {
        goto Cleanup;
    }
    //
    // Save the current config...
    //
    memcpy(pStoreDevInstallParams, pDevInstallParams, sizeof(SP_DEVINSTALL_PARAMS));

    pDevInstallParams->FlagsEx   |= DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
    pDevInstallParams->Flags     |= DI_NOVCP;
    pDevInstallParams->FileQueue = ScanQueue;

    AltPlat_Info.cbSize                     = sizeof(SP_ALTPLATFORM_INFO);
    AltPlat_Info.MajorVersion               = pOSVer->dwMajorVersion;
    AltPlat_Info.MinorVersion               = pOSVer->dwMinorVersion;
    AltPlat_Info.Platform                   = PlatformArch[ platform ][OS_PLATFORM];
    AltPlat_Info.ProcessorArchitecture      = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];
    AltPlat_Info.Reserved                   = 0;
    AltPlat_Info.FirstValidatedMajorVersion = AltPlat_Info.MajorVersion;
    AltPlat_Info.FirstValidatedMinorVersion = AltPlat_Info.MinorVersion;

    if(!SetupDiSetDeviceInstallParams(hDevInfo,
                                      NULL,
                                      pDevInstallParams) ||
       !SetupSetFileQueueAlternatePlatform(ScanQueue,
                                           &AltPlat_Info,
                                           NULL))
    {
        goto Cleanup;
    }

    //
    // First pass using SetupScanFileQueue will find the sizes required
    //
    if ( !InstallAllInfSections( pLocalData,
                                 platform,
                                 pszServerName,
                                 ScanQueue,
                                 NULL,
                                 dwInstallFlags,
                                 hInf,
                                 pszSectionNameWithExt ) ||
         !SetupScanFileQueue(ScanQueue,
                             SPQ_SCAN_USE_CALLBACK,
                             0,
                             DriverInfoCallback,
                             pScanInfo,
                             &dwResult) ) {

        goto Cleanup;
    }

    if ( pScanInfo->cchDependentFiles ) {

        ++pScanInfo->cchDependentFiles;

        ppszDepFiles = (LPTSTR) LocalAllocMem(pScanInfo->cchDependentFiles * sizeof(TCHAR));
        if ( !ppszDepFiles )
            goto Cleanup;

        pScanInfo->p1 = ppszDepFiles;
    }

    if ( pScanInfo->cchICMFiles ) {

        ++pScanInfo->cchICMFiles;
        pszzICMFiles = (LPTSTR) LocalAllocMem(pScanInfo->cchICMFiles * sizeof(TCHAR));

        if ( !pszzICMFiles )
            goto Cleanup;

        pScanInfo->p2 = pszzICMFiles;
    }

    //
    // Second call to SetupScanFileQueue build the actual multi-sz fields
    //
    bRet = SetupScanFileQueue(ScanQueue,
                              SPQ_SCAN_USE_CALLBACK,
                              0,
                              DriverInfoCallback,
                              pScanInfo,
                              &dwResult);

Cleanup:

    //
    // Save the last error as it may get toasted by the following calls.
    //
    dwResult = GetLastError();

    if ( ScanQueue != INVALID_HANDLE_VALUE )
    {
        if (pDevInstallParams) 
        {
            pDevInstallParams->FlagsEx   &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            pDevInstallParams->Flags     &= ~DI_NOVCP;
            pDevInstallParams->FileQueue = INVALID_HANDLE_VALUE;

            if (!SetupDiSetDeviceInstallParams(hDevInfo, NULL, pDevInstallParams))
            {
                dwResult = (ERROR_SUCCESS == dwResult) ? GetLastError() : dwResult;
            }
        }

        SetupCloseFileQueue(ScanQueue);
    }

    if (pStoreDevInstallParams)
    {
        if (pStoreDevInstallParams->cbSize == sizeof(SP_DEVINSTALL_PARAMS))
        {
            //
            // Reset the HDEVINFO params.
            //
            SetupDiSetDeviceInstallParams(hDevInfo,
                                          NULL,
                                          pStoreDevInstallParams);
        }
        LocalFreeMem(pStoreDevInstallParams);
    }

    if ( bRet ) {

        *pcchSize  += pScanInfo->cchDependentFiles;
        pLocalData->InfInfo.DriverInfo6.pDependentFiles = ppszDepFiles;
        pLocalData->InfInfo.pszzICMFiles = pszzICMFiles;
    } else {

        LocalFreeMem(ppszDepFiles);
        LocalFreeMem(pszzICMFiles);
    }

    if (pDevInstallParams)
    {
        LocalFreeMem(pDevInstallParams);
    }

    if (pOSVer)
    {
        LocalFreeMem(pOSVer);
    }

    if (pScanInfo)
    {
        LocalFreeMem(pScanInfo);
    }


    SetLastError(dwResult);

    return bRet;
}


VOID
DestroyCodedownload(
    PCODEDOWNLOADINFO   pCodeDownLoadInfo
    )
{
    if ( pCodeDownLoadInfo ) {

        pCodeDownLoadInfo->pfnClose(pCodeDownLoadInfo->hConnection);

        if ( pCodeDownLoadInfo->hModule )
            FreeLibrary(pCodeDownLoadInfo->hModule);

        LocalFreeMem(pCodeDownLoadInfo);

    }
}


BOOL
InitCodedownload(
    HWND    hwnd
    )
{
    BOOL                bRet = FALSE;
    PCODEDOWNLOADINFO   pCDMInfo = NULL;


    EnterCriticalSection(&CDMCritSect);

    // We already have a context & function pointers
    // So reuse them...
    if (gpCodeDownLoadInfo)
    {
       LeaveCriticalSection(&CDMCritSect);
       return TRUE;
    }

    pCDMInfo = (PCODEDOWNLOADINFO) LocalAllocMem(sizeof(CODEDOWNLOADINFO));

    if ( !pCDMInfo )
        goto Cleanup;

    pCDMInfo->hModule = LoadLibraryUsingFullPath(TEXT("cdm.dll"));

    if ( !pCDMInfo->hModule )
        goto Cleanup;

    (FARPROC)pCDMInfo->pfnOpen = GetProcAddress(pCDMInfo->hModule,
                                                "OpenCDMContext");

    (FARPROC)pCDMInfo->pfnDownload = GetProcAddress(pCDMInfo->hModule,
                                                    "DownloadUpdatedFiles");

    (FARPROC)pCDMInfo->pfnClose = GetProcAddress(pCDMInfo->hModule,
                                                 "CloseCDMContext");

    bRet = pCDMInfo->pfnOpen       &&
           pCDMInfo->pfnDownload   &&
           pCDMInfo->pfnClose;

    if ( bRet )
        pCDMInfo->hConnection = pCDMInfo->pfnOpen(hwnd);

Cleanup:

    if ( !bRet ||
         ( pCDMInfo && !pCDMInfo->hConnection ) ) {

        DestroyCodedownload(pCDMInfo);
        pCDMInfo = NULL;
        bRet = FALSE;
    }

    if (bRet)
       gpCodeDownLoadInfo = pCDMInfo;

    LeaveCriticalSection(&CDMCritSect);
    return bRet;
}


DWORD
PSetupInstallPrinterDriverFromTheWeb(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  LPOSVERSIONINFO     pOsVersionInfo,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszSource
    )
/*++

Routine Description:
    Downloads driver files from server and installs it by calling 
    InstallDriverFromCurrentInf.
    
Arguments:

Return Value:
    ERROR_SUCCESS is successful. 
--*/
{
   BOOL                bRet = FALSE;
   DWORD               dwLen, dwReturn = ERROR_SUCCESS;
   UINT                uNeeded;
   TCHAR               szSourceDir[MAX_PATH];
   DOWNLOADINFO        DownLoadInfo;
   PPSETUP_LOCAL_DATA  pNewLocalData = NULL;

   INT                 clpFileBufferLength     = 0;
   INT                 cProviderNameLength     = 0;
   INT                 cManufacturerNameLength = 0;
   INT                 cDriverNameLength       = 0;

   ZeroMemory(&DownLoadInfo, sizeof(DownLoadInfo));

    if (!pLocalData || !pOsVersionInfo)
    {
        SetLastError(dwReturn = ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }


   if ( !gpCodeDownLoadInfo )
      goto Cleanup;

   DownLoadInfo.dwDownloadInfoSize = sizeof(DownLoadInfo);
   DownLoadInfo.localid            = lcid;

   // dwLen = lstrlen( cszWebNTPrintPkg );
   dwLen = lstrlen(pLocalData->DrvInfo.pszHardwareID);

   //
   // lpHardwareIDs is multi-sz
   //
   if ( !(DownLoadInfo.lpHardwareIDs = LocalAllocMem((dwLen + 2 ) * sizeof(TCHAR))) )
      goto Cleanup;

   // lstrcpy(DownLoadInfo.lpHardwareIDs, cszWebNTPrintPkg );
   StringCchCopy( (LPTSTR) DownLoadInfo.lpHardwareIDs, dwLen + 2, pLocalData->DrvInfo.pszHardwareID);

   CopyMemory(&DownLoadInfo.OSVersionInfo,
              pOsVersionInfo,
              sizeof(OSVERSIONINFO));

   // Assign the correct Processor Architecture to the download
   DownLoadInfo.dwArchitecture = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];

   DownLoadInfo.lpFile = NULL;

   //
   // Below we have to check if we have valid Provider, Manufacturer, and
   // driver names and if this is the case then we have to prepare a
   // MULTISZ including Provider, Manufacturer, and Driver Names,
   // and to set a pointer to that MULTISZ into DownLoadInfo.lpFile
   //
   if (pLocalData->DrvInfo.pszProvider &&
       pLocalData->DrvInfo.pszManufacturer &&
       pLocalData->DrvInfo.pszModelName) 
   {
       cProviderNameLength = lstrlen(pLocalData->DrvInfo.pszProvider);
       if (cProviderNameLength) 
       {
           cManufacturerNameLength = lstrlen(pLocalData->DrvInfo.pszManufacturer);
           if (cManufacturerNameLength) 
           {
               cDriverNameLength = lstrlen(pLocalData->DrvInfo.pszModelName);
               if (cDriverNameLength) 
               {
                   clpFileBufferLength = cProviderNameLength + 1 +
                                         cManufacturerNameLength + 1 +
                                         cDriverNameLength + 1 +
                                         1;
                   DownLoadInfo.lpFile = (LPTSTR)LocalAllocMem(clpFileBufferLength * sizeof(TCHAR));
                   if (DownLoadInfo.lpFile) 
                   {
                       StringCchCopy( (LPTSTR)(DownLoadInfo.lpFile), cProviderNameLength + 1, (LPTSTR)(pLocalData->DrvInfo.pszProvider));
                       StringCchCopy( (LPTSTR)(DownLoadInfo.lpFile + cProviderNameLength + 1), cManufacturerNameLength + 1, (LPTSTR)(pLocalData->DrvInfo.pszManufacturer));
                       StringCchCopy( (LPTSTR)(DownLoadInfo.lpFile + cProviderNameLength + 1 + cManufacturerNameLength + 1), cDriverNameLength + 1, (LPTSTR)(pLocalData->DrvInfo.pszModelName));
                   }
               }
           }
       }
   }

   if ( !gpCodeDownLoadInfo->pfnDownload(gpCodeDownLoadInfo->hConnection,
                                         hwnd,
                                         &DownLoadInfo,
                                         szSourceDir,
                                         SIZECHARS(szSourceDir),
                                         &uNeeded) )
      goto Cleanup;

   // Now rework install data based on the actual INF
   pNewLocalData = RebuildDeviceInfo( hDevInfo, pLocalData, szSourceDir );

   if ( pNewLocalData == NULL )
      goto Cleanup;

   pNewLocalData->DrvInfo.Flags |= SDFLAG_CDM_DRIVER;

   dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                          pNewLocalData,
                                          hwnd,
                                          platform,
                                          dwThisMajorVersion,
                                          pszServerName,
                                          INVALID_HANDLE_VALUE,
                                          NULL,
                                          NULL,
                                          0,
                                          szSourceDir,
                                          DRVINST_FLATSHARE | DRVINST_NO_WARNING_PROMPT,
                                          APD_COPY_NEW_FILES,
                                          NULL,
                                          NULL,
                                          NULL);

   (VOID) DeleteAllFilesInDirectory(szSourceDir, TRUE);

   if ( dwReturn == ERROR_SUCCESS )
      bRet = TRUE;

Cleanup:

   if ( pNewLocalData )
      DestroyLocalData( pNewLocalData );

   LocalFreeMem((PVOID)DownLoadInfo.lpHardwareIDs);
   LocalFreeMem((PVOID)DownLoadInfo.lpFile);

   CleanupScratchDirectory(pszServerName, platform);

   if ( !bRet && ( dwReturn == ERROR_SUCCESS ) )
      dwReturn = STG_E_UNKNOWN;

   return dwReturn;
}


/*++

Routine Name:

    PSetupInstallInboxDriverSilently

Routine Description:

    This is used to install inbox drivers silently. The driver must exist in
    ntprint.inf. The inf isn't passed in to make the only code that needs to know
    about ntprint.inf reside in setup. No UIs are popped up and the function
    will fail if UI would be required.

Arguments:

    pszDriverName       -   The driver name that we want to install.

Return Value:

    BOOL, Last error

--*/
DWORD
PSetupInstallInboxDriverSilently(
    IN      LPCTSTR     pszDriverName
    )
{
    DWORD   Status  = ERROR_SUCCESS;
    TCHAR   szInfFile[MAX_PATH];

    Status = pszDriverName ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Get the system directory.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = GetSystemWindowsDirectory(szInfFile, COUNTOF(szInfFile)) ? ERROR_SUCCESS : GetLastError();
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = StrNCatBuff(szInfFile, COUNTOF(szInfFile), szInfFile, TEXT("\\"), szNtPrintInf, NULL);
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = InstallDriverSilently(szInfFile, pszDriverName, NULL);
    }

    return Status;
}

/*++

Routine Name:

    InstallDriverSilently

Routine Description:

    Install the given printer driver from the given inf from the optional
    source directory, do not pop up UI and fail if UI would be required.

Arguments:

    pszInfFile      -   The inf file to install the driver from.
    pszDriverName   -   The driver name.
    pszSource       -   The source installation location.

Return Value:

    BOOL, Last error

--*/
DWORD
InstallDriverSilently(
    IN      LPCTSTR     pszInfFile,
    IN      LPCTSTR     pszDriverName,
    IN      LPCTSTR     pszSource
    )
{
    HDEVINFO            hDevInfo        = INVALID_HANDLE_VALUE;
    DWORD               dwInstallFlags  = DRVINST_PROGRESSLESS | DRVINST_PROMPTLESS;
    PPSETUP_LOCAL_DATA  pData           = NULL;
    DWORD               Status          = ERROR_SUCCESS;

    Status = pszInfFile && pszDriverName ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Ensure that setupapi does not throw any UI
    //
    SetupSetNonInteractiveMode(TRUE);

    if (Status == ERROR_SUCCESS)
    {
        if ((hDevInfo = PSetupCreatePrinterDeviceInfoList(NULL)) != INVALID_HANDLE_VALUE    &&
            PSetupBuildDriversFromPath(hDevInfo, pszInfFile, TRUE)                          &&
            PSetupPreSelectDriver(hDevInfo, NULL, pszDriverName)                            &&
            (pData = BuildInternalData(hDevInfo, NULL)) != NULL                             &&
            ParseInf(hDevInfo, pData, MyPlatform, NULL, dwInstallFlags, FALSE))
        {
            Status = ERROR_SUCCESS;
        }
        else
        {
            //
            // Ensure that if we have a failure the return is shown as such.
            //
            Status = GetLastError();

            Status = Status == ERROR_SUCCESS ? ERROR_INVALID_DATA : Status;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // We don't want to launch a vendor setup entry, but vendor setup
        // only gets launch after an AddPrinter call, which we're not doing - just adding drivers here.
        // NOTE: For future if this included Queue creation we WILL have to handle this.
        //
        Status = PSetupInstallPrinterDriver(hDevInfo,
                                            pData,
                                            NULL,
                                            MyPlatform,
                                            dwThisMajorVersion,
                                            NULL,
                                            NULL,
                                            NULL,
                                            pszSource,
                                            dwInstallFlags,
                                            APD_COPY_NEW_FILES,
                                            NULL);
    }

    //
    // Switch on setupapi UI again
    //
    SetupSetNonInteractiveMode(FALSE);

    if(pData != NULL)
    {
        PSetupDestroySelectedDriverInfo(pData);
    }

    //
    // Release the driver setup parameter handle.
    //
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        PSetupDestroyPrinterDeviceInfoList( hDevInfo );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\local.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Holds spooler install headers.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#if defined(__cplusplus)
extern "C"
{
#endif


#define     MAX_SETUP_LEN                        250
#define     MAX_SETUP_ALLOC_STRING_LEN          4000 // in characters, used in GetLongStringFromRcFile
#define     MAX_DWORD                     0xFFFFFFFF

#define     IDS_PRINTERWIZARD                   1001
#define     IDS_WINNTDEV_INSTRUCT               1002
#define     IDS_WIN95DEV_INSTRUCT               1003
#define     IDS_SELECTDEV_LABEL                 1004
#define     IDS_DRIVERS_FOR_PLATFORM            1005
#define     IDS_INSTALLING_PORT_MONITOR         1006
#define     IDS_WRONG_ARCHITECTURE              1007
#define     IDS_INVALID_DRIVER                  1008
#define     IDS_PROMPT_PORT_MONITOR             1009
#define     IDS_ERROR_INST_PORT_MONITOR         1010

#define     IDS_PROMPT_ALT_PLATFORM_DRIVER      1027
#define     IDS_WARN_NO_ALT_PLATFORM_DRIVER     1028
#define     IDS_WARN_NO_DRIVER_FOUND            1029

#define     IDS_DRIVERS_FOR_WIN95               1031
#define     IDS_DRIVERS_FOR_NT4_X86             1032
#define     IDS_DRIVERS_FOR_NT4_ALPHA           1033
#define     IDS_DRIVERS_FOR_NT4_MIPS            1034
#define     IDS_DRIVERS_FOR_NT4_PPC             1035
#define     IDS_DRIVERS_FOR_X86                 1036
#define     IDS_DRIVERS_FOR_IA64                1037

//
// Setuplog entried used during upgrade
//
#define     IDS_UPGRADE_FAILED                  1051
#define     IDS_DRIVER_UPGRADE_FAILED           1052
#define     IDS_PRINTER_UPGRADE_FAILED          1053
#define     IDS_PRINTER_DELETED                 1054
#define     IDS_DRIVER_CHANGED                  1055
#define     IDS_CONNECTION_DELETED              1056

//
// entries for printupg warnings
//
#define     IDS_TITLE_BSP_WARN                  1060
#define     IDS_TITLE_BSP_ERROR                 1061
#define     IDS_BSP_WARN_NO_INBOX               1062
#define     IDS_BSP_WARN_WITH_INBOX             1063
#define     IDS_BSP_BLOCK_NO_INBOX              1064
#define     IDS_BSP_BLOCK_WITH_INBOX            1065
#define     IDS_BSP_WARN_UNSIGNED_DRIVER        1066

//
//   Text for Internet Printing in IIS Snap-in
//
#define     IDS_INTERNET_PRINTING               1067

//
// Printer driver directory set in ntprint.inf
//
#define     PRINTER_DRIVER_DIRECTORY_ID                         66000
#define     PRINT_PROC_DIRECTORY_ID                             66001
#define     SYSTEM_DIRECTORY_ID_ONLY_FOR_NATIVE_ARCHITECTURE    66002
#define     ICM_PROFILE_DIRECTORY_ID                            66003
#define     WEBPAGE_DIRECTORY_ID                                66004

#define     PSETUP_SIGNATURE                   0x9585

// Defines for the columns in the Architecture Platform Table for Driver Signing & CDM

#define  OS_PLATFORM    0
#define  PROCESSOR_ARCH 1

#define lstrchr     wcschr
#define lstrncmp    wcsncmp
#define lstrncmpi   _wcsnicmp

#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

//
// Type definitions
//
typedef struct _SPLPLATFORMINFO {

    LPTSTR pszName;
} SPLPLATFORMINFO, *PSPLPLATFORMINFO;

typedef struct _SELECTED_DRV_INFO {

    LPTSTR              pszInfName;
    LPTSTR              pszModelName;
    LPTSTR              pszDriverSection;
    PSP_DEVINFO_DATA    pDevInfoData;
    LPTSTR              pszHardwareID;
    LPTSTR              pszManufacturer;
    LPTSTR              pszOEMUrl;
    LPTSTR              pszProvider;
    FILETIME            ftDriverDate;
    DWORDLONG           dwlDriverVersion;
    DWORD               Flags;
    LPTSTR              pszzPreviousNames;
} SELECTED_DRV_INFO, *PSELECTED_DRV_INFO;

#define             SDFLAG_PREVNAME_SECTION_FOUND     0x00000001
#define             SDFLAG_CDM_DRIVER                 0x00000002

typedef struct  _PARSEINF_INFO {

    PLATFORM            platform;
    LPTSTR              pszInstallSection;  // Can be platform dependent
    LPTSTR              pszzICMFiles;
    LPTSTR              pszPrintProc;
    LPTSTR              pszVendorSetup;
    DWORD               cbDriverInfo6;
    DRIVER_INFO_6       DriverInfo6;
} PARSEINF_INFO, *PPARSEINF_INFO;

typedef struct _PNP_INFO {

    LPTSTR              pszPortName;
    LPTSTR              pszDeviceInstanceId;
} PNP_INFO, *PPNP_INFO;

#define             VALID_INF_INFO      0x00000001
#define             VALID_PNP_INFO      0x00000002
//
// Set if the installation files are copied into a directory whose name is derived from
// the pnp ID. Since the spooler copies files around, setupapi can't find the files anymore
// when the device is re-pnp'd and prompts the user for them. We copy the files into this directory
// and don't delete it, that way setupapi can find them.
//
#define LOCALDATAFLAG_PNP_DIR_INSTALL   0x00000004


typedef struct  _PSETUP_LOCAL_DATA {

    SELECTED_DRV_INFO   DrvInfo;
    DWORD               signature;
    DWORD               Flags;
    PARSEINF_INFO       InfInfo;
    PNP_INFO            PnPInfo;
} PSETUP_LOCAL_DATA;

//
// Global data
//
extern OSVERSIONINFO        OsVersionInfo;
extern LCID                 lcid;
extern DWORD                dwThisMajorVersion;
extern TCHAR                sComma;
extern TCHAR                sZero;
extern const GUID           GUID_DEVCLASS_PRINTER;
extern PLATFORM             MyPlatform;
extern HINSTANCE            ghInst;
extern SPLPLATFORMINFO      PlatformEnv[], PlatformOverride[];
extern DWORD                PlatformArch[][2];
extern TCHAR                cszNtprintInf[];
extern TCHAR                cszDataSection[];
extern TCHAR                cszComma[];
extern ULONG_PTR            DriverInfo6Offsets[];
extern ULONG_PTR            LocalDataOffsets[];
extern ULONG_PTR            InfInfoOffsets[];
extern ULONG_PTR            PnPInfoOffsets[];
extern TCHAR                cszWebNTPrintPkg[];
extern PCODEDOWNLOADINFO    gpCodeDownLoadInfo;
extern TCHAR                cszCatExt[];
extern TCHAR                cszInfExt[];
extern CRITICAL_SECTION     CDMCritSect;

extern CRITICAL_SECTION     SkipCritSect;
extern LPTSTR               gpszSkipDir;

extern TCHAR                cszHardwareID[];
extern TCHAR                cszBestDriverInbox[];
extern TCHAR                cszPnPKey[];
extern TCHAR                cszDeviceInstanceId[];

extern TCHAR                cszMonitorKey[];


//
// Function prototypes
//
VOID
GetDriverPath(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDriverPath[MAX_PATH]
    );

PVOID
LocalAllocMem(
        IN UINT cbSize
        );

VOID
LocalFreeMem(
    IN PVOID pMem
    );

LPTSTR
AllocStr(
    IN LPCTSTR  pszStr
    );

DWORD
InstallWin95Driver(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModel,
    IN      LPCTSTR     pszzPreviousNames,
    IN      BOOL        bPreviousNamesSection,
    IN      LPCTSTR     pszServerName,
    IN  OUT LPTSTR      pszInfPath,
    IN      LPCTSTR     pszDiskName,
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags
    );

VOID
InfGetString(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    );

LPTSTR
GetStringFromRcFile(
    UINT    uId
    );

LPTSTR
GetLongStringFromRcFile(
    UINT    uId
    );

BOOL
SetSelectDevParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  BOOL                bWin95,
    IN  LPCTSTR             pszModel    OPTIONAL
    );

BOOL
SetDevInstallParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  LPCTSTR             pszDriverPath   OPTIONAL
    );

HDEVINFO
CreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    );

LPDRIVER_INFO_6
Win95DriverInfo6FromName(
    IN  HDEVINFO    hDevInfo,
    IN  PPSETUP_LOCAL_DATA*  ppLocalData,
    IN  LPCTSTR     pszModel,
    IN  LPCTSTR     pszzPreviousNames
    );

BOOL
CopyPrinterDriverFiles(
    IN  LPDRIVER_INFO_6     pDriverInfo6,
    IN  LPCTSTR             pszInfName,
    IN  LPCTSTR             pszSourcePath,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszTargetPath,
    IN  HWND                hwnd,
    IN  DWORD               dwInstallFlags,
    IN  BOOL                bForgetSource
    );

BOOL
ParseInf(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      BOOL                bCrossPlatformAllowed
    );

BOOL
BuildClassDriverList(
    IN HDEVINFO    hDevInfo
    );

DWORD
InstallDriverFromCurrentInf(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  HWND                hwnd,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HSPFILEQ            CopyQueue,
    IN  PVOID               QueueContext,
    IN  PSP_FILE_CALLBACK   InstallMsgHandler,
    IN  DWORD               Flags,
    IN  LPCTSTR             pszSource,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    IN  LPCTSTR             pszFileSrcPath, // can be different from INF source in case we had to decompress NT4 CD-ROM inf
    OUT LPTSTR             *ppszNewModelName,
    OUT PDWORD              pBlockingInfo
    );

HRESULT
IsProductType(
    IN  BYTE  ProductType,
    IN  BYTE  Comparison
);

BOOL
AddPrintMonitor(
    IN  LPCTSTR     pszName,
    IN  LPCTSTR     pszDllName
    );

BOOL
FindPathOnSource(
    IN      LPCTSTR     pszFileName,
    IN      HINF        MasterInf,
    IN OUT  LPTSTR      pszPathOnSource,
    IN      DWORD       dwLen,
    OUT     LPTSTR     *ppszMediaDescription,       OPTIONAL
    OUT     LPTSTR     *ppszTagFile                 OPTIONAL
    );

VOID
DestroyLocalData(
    IN  PPSETUP_LOCAL_DATA   pLocalData
    );

LPDRIVER_INFO_6
CloneDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  DWORD           cbDriverInfo6
    );

PPSETUP_LOCAL_DATA
BuildInternalData(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pSpDevInfoData
    );

VOID
PackDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  LPDRIVER_INFO_6 pTargetDriverInfo6,
    IN  DWORD           cbDriverInfo6
    );

BOOL
InfGetDependentFilesAndICMFiles(
    IN      HDEVINFO            hDevInfo,
    IN      HINF                hInf,
    IN      BOOL                bWin95,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      LPCTSTR             pszSectionNameWithExt,
    IN OUT  LPDWORD             pcchSize
    );

BOOL
IdenticalDriverInfo6(
    IN  LPDRIVER_INFO_6 p1,
    IN  LPDRIVER_INFO_6 p2
    );

BOOL
DeleteAllFilesInDirectory(
    LPCTSTR     pszDir,
    BOOL        bDeleteDir
    );

LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    );

HDEVINFO
GetInfAndBuildDrivers(
    IN  HWND                hwnd,
    IN  DWORD               dwTitleId,
    IN  DWORD               dwDiskId,
    IN  TCHAR               szInfPath[MAX_PATH],
    IN  DWORD               dwInstallFlags,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszDriverName,              OPTIONAL
    OUT PPSETUP_LOCAL_DATA *ppLocalData,                OPTIONAL
    OUT LPTSTR             *ppFileSrcPath               OPTIONAL
    );

BOOL
MyName(
    IN  LPCTSTR     pszServerName
    );

VOID
FreeStructurePointers(
    LPBYTE      pStruct,
    PULONG_PTR  pOffSets,
    BOOL        bFreeStruct
    );

BOOL
AddPrinterDriverUsingCorrectLevel(
    IN  LPCTSTR             pszServerName,
    IN  DRIVER_INFO_6       *pDriverInfo6,
    IN  DWORD               dwAddDrvFlags
    );

BOOL
AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(
    IN     LPCTSTR          pszServerName,            OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    );

BOOL
BlockedDriverPrintUpgUI(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    );

BOOL
InfIsCompatibleDriver(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     HINF             hInf,
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    );

HRESULT
GetPrinterDriverVersion(
    IN     LPCTSTR           pszFileName,
       OUT DWORD             *pdwFileMajorVersion,           OPTIONAL
       OUT DWORD             *pdwFileMinorVersion            OPTIONAL
     );

BOOL
FileExists(
    IN  LPCTSTR  pszFileName
    );

BOOL
SetPnPInfoForPrinter(
    IN  HANDLE      hPrinter,
    IN  LPCTSTR     pszDeviceInstanceId,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszOEMUrl
    );

BOOL
InstallAllInfSections(
   IN  PPSETUP_LOCAL_DATA  pLocalData,
   IN  PLATFORM            platform,
   IN  LPCTSTR             pszServerName,
   IN  HSPFILEQ            CopyQueue,
   IN  LPCTSTR             pszSource,
   IN  DWORD               dwInstallFlags,
   IN  HINF                hInf,
   IN  LPCTSTR             pszInstallSection
   );

BOOL
SetTargetDirectories(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  HINF                hInf,
    IN  DWORD               dwInstallFlags
    );

BOOL
IsLanguageMonitorInstalled(
   IN PCTSTR pszMonitorName
   );

BOOL
CleanupUniqueScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    );

BOOL
CleanupScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    );

BOOL
InitCodedownload(
    HWND    hwnd
    );

VOID
DestroyCodedownload(
    PCODEDOWNLOADINFO   pCodeDownLoadInfo
    );

BOOL
DestroyOnlyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    );

LPTSTR
GetSystemInstallPath(
    VOID
    );

PPSETUP_LOCAL_DATA
RebuildDeviceInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszSource
    );

BOOL
SetupSkipDir(
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName
    );

void
CleanupSkipDir(
    VOID
    );

LPTSTR
AllocAndCatStr(
    IN  LPCTSTR  pszStr1,
    IN  LPCTSTR  pszStr2
    );

LPTSTR
AllocAndCatStr2(
    IN LPCTSTR  pszStr1,
    IN LPCTSTR  pszStr2,
    IN LPCTSTR  pszStr3
    );

VOID
PSetupKillBadUserConnections(
    VOID
    );

DWORD
PSetupInstallInboxDriverSilently(
    IN      LPCTSTR     pszDriverName
    );

BOOL
PruneInvalidFilesIfNotAdmin(
    IN     HWND      hWnd,
    IN OUT HSPFILEQ  CopyQueue
    );

BOOL
AddDirectoryTag(
        IN LPTSTR pszDir,
        IN DWORD  dwSize
        );

BOOL
AddPnpDirTag(
        IN LPTSTR     pszHardwareId,
        IN OUT LPTSTR pszDir,
        IN DWORD      dwSize
        );

BOOL
AddDirToDriverInfo(
        IN LPTSTR          pszDir,
        IN LPDRIVER_INFO_6 pDriverInfo6
        );

VOID
GetCDRomDrive(
    TCHAR   szDrive[5]
    );

BOOL
IsSystemSetupInProgress(
        VOID
        );

BOOL
IsSpoolerRunning(
    VOID
    );

LPTSTR
GetMyTempDir(
    VOID
    );

BOOL
IsNTPrintInf(
    IN LPCTSTR pszInfName
    );

BOOL
IsSystemNTPrintInf(
    IN LPCTSTR pszInfName
    );

PVOID
SetupDriverSigning(
    IN HDEVINFO hDevInfo,
    IN LPCTSTR   pszServerName,
    IN LPTSTR    pszInfName,
    IN LPCTSTR   pszSource,
    IN PLATFORM  platform,
    IN DWORD     dwVersion,
    IN HSPFILEQ  CopyQueue,
    IN BOOL      bWeb
    );

BOOL
IsLocalAdmin(
    OUT BOOL    *pbAdmin
    );

BOOL
GetCatalogFile(
    IN  HANDLE   hDriverSigning,
    OUT PCWSTR   *ppszCat
    );

BOOL
DrvSigningIsLocalAdmin(
    IN  HANDLE   hDriverSigning,
    OUT BOOL     *pbIsLocalAdmin
    );

BOOL
AddDriverCatalogIfNotAdmin(
    IN PCWSTR   pszServer,
    IN HANDLE   hDriverSigningInfo,
    IN PCWSTR   pszInfPath,
    IN PCWSTR   pszSrcLoc,
    IN DWORD    dwMediaType,
    IN DWORD    dwCopyStyle
    );

BOOL
CleanupDriverSigning(
    IN PVOID pDSInfo
    );

BOOL
CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
    );

BOOL
IsCatInInf(
    IN PVOID pDSInfo
    );

BOOL
GetOSVersion(
    IN     LPCTSTR        pszServerName,
    OUT    POSVERSIONINFO pOSVer
    );

BOOL
GetArchitecture(
    IN     LPCTSTR   pszServerName,
    OUT    LPTSTR    pszArch,
    IN OUT LPDWORD   pcArchSize
    );

DWORD
InstallDriverSilently(
    IN      LPCTSTR     pszInfFile,
    IN      LPCTSTR     pszDriverName,
    IN      LPCTSTR     pszSource
    );

BOOL
IsInWow64(
    );
BOOL
IsWhistlerOrAbove(
    IN LPCTSTR pszServerName
    );

DWORD
InstallReplacementDriver(
    IN     HWND                hwnd,
    IN     LPCTSTR             pszServerName,
    IN     LPCTSTR             pszModelName,
    IN     PLATFORM            platform,
    IN     DWORD               version,
    IN     DWORD               dwInstallFlags,
    IN     DWORD               dwAddDrvFlags,
    IN OUT PPSETUP_LOCAL_DATA  pOldLocalData
    );

HMODULE LoadLibraryUsingFullPath(
    LPCTSTR lpFileName
    );

BOOL
CheckAndKeepPreviousNames(
    IN  LPCTSTR          pszServer,
    IN  PDRIVER_INFO_6   pDriverInfo6,
    IN  PLATFORM         platform
);

BOOL
IsTheSamePlatform(
    IN  LPCTSTR          pszServer,
    IN PLATFORM          platform
);

LPTSTR
GetArchitectureName(
    IN     LPCTSTR   pszServerName
);

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\ippocm.cxx ===
/*****************************************************************************\
* MODULE: IppOcm.cxx
*
* The module contains routines for the setting up the WWW Printer Service. The main entry point is
*   IppOCEntry which will be called by the Optional Component Manager.
*
* Copyright (C) 2002 Microsoft Corporation
*
\*****************************************************************************/

//
//
// Note: We cannot use precomp.h here since we requrie ATL which can only be included in C++ source files.
//
//


#define INITGUID     // Needed to do it to get GUID_NULL defined.

#include "precomp.h"
#pragma hdrstop

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#include <ocmanage.h>   // OC_ defines

// for adsi objects
#include <Iads.h>
#include <Adshlp.h>

// for the IID_IISWebService object
#include "iiisext.h"
#include "iisext_i.c"

#define MY_META_TIMEOUT 1000

TCHAR const cszMimeMap[]       = TEXT("MimeMap");
TCHAR const cszWebPnPMap[]     = TEXT(".webpnp,application/octet-stream");
TCHAR const cszW3SvcRootPath[] = TEXT("/LM/W3svc/1/Root");
TCHAR const cszPrinters[]      = TEXT("Printers");
TCHAR const cszWebSvcExtRestrictionListADSILocation[] = TEXT("IIS://LOCALHOST/W3SVC");

//
//  Component ID for the OCM
//
TCHAR const cszComponentId[]       = TEXT("InetPrint");
TCHAR const cszExtPathFmt[]        = TEXT("%ws\\msw3prt.dll");
TCHAR const cszGroupId[]           = TEXT("W3PRT");
TCHAR const cszGroupDescription[]  = TEXT("Internet Printing");
TCHAR const cszASPId[]             = TEXT("ASP");

//
// Service ID & Reg Key for the WWW Service
//
TCHAR const cszW3Svc[]       = TEXT("w3svc");
TCHAR const cszW3SvcReg[]    = TEXT("System\\CurrentControlSet\\Services\\W3SVC");

//
//  Strings to fire up the RunDll32 process
//
TCHAR const cszInstallInetPrint[]       = TEXT("rundll32 ntprint.dll,SetupInetPrint Install");
TCHAR const cszRemoveInetPrint[]        = TEXT("rundll32 ntprint.dll,SetupInetPrint Remove");
CHAR const  cszInstall[]                = "Install";
CHAR const  cszRemove[]                 = "Remove";

typedef struct MySetupStruct
{
    OCMANAGER_ROUTINES OCHelpers;
    SETUP_DATA         OCData;
    BOOL               bFirstCall;
    BOOL               bInitState;
} MYSETUPSTRUCT;

//
//   Function Prototypes
//

HRESULT
AddVirtualDir(
             IMSAdminBase *pIMetaBase
             );

HRESULT
AddWebExtension(
               VOID
               );

HRESULT
AddScriptAtPrinterVDir(
                      IMSAdminBase *pIMetaBase
                      );

HRESULT
AddMimeType(
           IMSAdminBase *pIMetaBase
           );

HRESULT
RemoveWebExtension(
                  VOID
                  );


DWORD
WriteStrippedScriptValue(
                        IMSAdminBase *pIMetaBase,
                        METADATA_HANDLE hMeta,     // Handle to /LM tree
                        PWCHAR pszScripts          // MULTI_SZ string already there
                        );

DWORD
WriteStrippedMimeMapValue(
                        IMSAdminBase *pIMetaBase,
                        METADATA_HANDLE hMeta,     // Handle to /LM tree
                        PWCHAR pszMimeMap          // MULTI_SZ string already there
                        );
LPWSTR
mystrstrni(
          LPWSTR pSrc,
          LPWSTR pSearch
          );

LPWSTR
IsStrInMultiSZ(
              LPWSTR pMultiSzSrc,
              LPWSTR pSearch
              );

DWORD
GetMultiSZLen(
    IN      LPWSTR              pMultiSzSrc
    );


BOOL
IsVDIRInstalled(
               VOID
               )
{
    IMSAdminBase    *pIMetaBase = NULL;
    BOOL            bInstalled = FALSE;

    //
    // Init up the MetaBase
    //
    if ( SUCCEEDED(CoInitializeEx( NULL, COINIT_MULTITHREADED )) &&
         SUCCEEDED(::CoCreateInstance(CLSID_MSAdminBase,
                                      NULL,
                                      CLSCTX_ALL,
                                      IID_IMSAdminBase,
                                      (void **)&pIMetaBase)) )
    {
        WCHAR           szVirPath[MAX_PATH];
        HRESULT         hr;                 // com error status
        METADATA_HANDLE hMeta = NULL;       // handle to metabase
        DWORD           dwMDRequiredDataLen;
        METADATA_RECORD mr;


        // open key to ROOT on website #1 (default)
        hr = pIMetaBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                      cszW3SvcRootPath,
                                      METADATA_PERMISSION_READ,
                                      MY_META_TIMEOUT,
                                      &hMeta);
        if ( SUCCEEDED( hr ) )
        {
            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = 0;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = sizeof( szVirPath );
            mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

            // Read LM/W3Svc/1/Root/Printers see if MD_VR_PATH exists.
            hr = pIMetaBase->GetData( hMeta, cszPrinters, &mr, &dwMDRequiredDataLen );
            if ( SUCCEEDED(hr) )
                bInstalled = TRUE;

            //
            // Close the Web Server Key
            //
            pIMetaBase->CloseKey( hMeta );
        }

        pIMetaBase->Release();
    }

    CoUninitialize();

    return bInstalled;
}

DWORD
InstallWebPrinting(
                  VOID
                  )

{
    IMSAdminBase    *pIMetaBase = NULL;
    BOOL            bInstalled = FALSE;
    HRESULT         hr = S_OK;

    DBGMSG(DBG_INFO, ("Installing Web Printing.\n"));
    //
    // Init up the MetaBase
    //
    if ( SUCCEEDED(CoInitializeEx( NULL, COINIT_MULTITHREADED )) &&
         SUCCEEDED(::CoCreateInstance(CLSID_MSAdminBase,
                                      NULL,
                                      CLSCTX_ALL,
                                      IID_IMSAdminBase,
                                      (void **)&pIMetaBase)) )
    {

        //
        // Add the Virtual Directory
        //
        hr = AddVirtualDir(pIMetaBase);

        if (SUCCEEDED(hr))
        {
            //
            // Add Inet Print to the Security Console
            //
            hr = AddWebExtension();
        }

        if (SUCCEEDED(hr))
        {
            //
            // Add the .printer Script Map
            //
            hr = AddScriptAtPrinterVDir(pIMetaBase);
        }

        if (SUCCEEDED(hr))
        {
            //
            // Add the .webpnp MimeType
            //
            hr = AddMimeType(pIMetaBase);
        }

        pIMetaBase->Release();

    }

    CoUninitialize();

    return HRESULT_CODE(hr);
}

HRESULT
AddVirtualDir(
             IMSAdminBase *pIMetaBase
             )
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    WCHAR           szVirPath[MAX_PATH];
    WCHAR           szPath[MAX_PATH];
    DWORD           dwMDRequiredDataLen;
    DWORD           dwAccessPerm;
    METADATA_RECORD mr;
    HRESULT         hr;

    DBGMSG(DBG_INFO, ("Adding the Virtual Dir\r\n"));

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                 cszW3SvcRootPath,
                                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                 MY_META_TIMEOUT,
                                 &hMeta );

    // Create the key if it does not exist.
    if ( SUCCEEDED( hr ) )
    {
        mr.dwMDIdentifier = MD_VR_PATH;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = sizeof( szVirPath );
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

        // Read LM/W3Svc/1/Root/Printers see if MD_VR_PATH exists.
        hr = pIMetaBase->GetData( hMeta, cszPrinters, &mr, &dwMDRequiredDataLen );

        if ( FAILED( hr ) )
        {
            if ( hr == MD_ERROR_DATA_NOT_FOUND ||
                 HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
            {
                // Write both the key and the values if GetData() failed with any of the two errors.
                pIMetaBase->AddKey( hMeta, cszPrinters );

                if ( GetWindowsDirectory( szPath, sizeof(szPath) / sizeof (TCHAR)) )
                {      // Return value is the length in chars w/o null char.

                    DBGMSG(DBG_INFO, ("Writing our virtual dir.\n"));

                    hr = StringCchPrintf(szVirPath, COUNTOF(szVirPath), L"%ws\\web\\printers", szPath);

                    if ( SUCCEEDED(hr) )
                    {
                        mr.dwMDIdentifier = MD_VR_PATH;
                        mr.dwMDAttributes = METADATA_INHERIT;
                        mr.dwMDUserType   = IIS_MD_UT_FILE;
                        mr.dwMDDataType   = STRING_METADATA;
                        mr.dwMDDataLen    = (wcslen(szVirPath) + 1) * sizeof(WCHAR);
                        mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

                        //
                        // Write MD_VR_PATH value
                        //
                        hr = pIMetaBase->SetData( hMeta, cszPrinters, &mr );
                    }

                    //
                    // Set the default authentication method
                    //
                    if ( SUCCEEDED(hr) )
                    {
                        DWORD dwAuthorization = MD_AUTH_NT;     // NTLM only.

                        mr.dwMDIdentifier = MD_AUTHORIZATION;
                        mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                        mr.dwMDUserType   = IIS_MD_UT_FILE;
                        mr.dwMDDataType   = DWORD_METADATA;
                        mr.dwMDDataLen    = sizeof(DWORD);
                        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);

                        // Write MD_AUTHORIZATION value
                        hr = pIMetaBase->SetData( hMeta, cszPrinters, &mr );
                    }
                }
            }
        }

        // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.
        if ( SUCCEEDED(hr) )
        {
            dwAccessPerm = MD_ACCESS_READ | MD_ACCESS_SCRIPT;

            mr.dwMDIdentifier = MD_ACCESS_PERM;
            mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = DWORD_METADATA;
            mr.dwMDDataLen    = sizeof(DWORD);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

            // Write MD_ACCESS_PERM value
            hr = pIMetaBase->SetData( hMeta, cszPrinters, &mr );
        }

        if ( SUCCEEDED(hr) )
        {

            PWCHAR  szDefLoadFile = L"ipp_0001.asp";

            mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);

            // Write MD_DEFAULT_LOAD_FILE value
            hr = pIMetaBase->SetData( hMeta, cszPrinters, &mr );
        }

        if ( SUCCEEDED(hr) )
        {

            PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

            mr.dwMDIdentifier = MD_KEY_TYPE;
            mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
            mr.dwMDUserType   = IIS_MD_UT_SERVER;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

            // Write MD_DEFAULT_LOAD_FILE value
            hr = pIMetaBase->SetData( hMeta, cszPrinters, &mr );
        }
    }
    pIMetaBase->CloseKey( hMeta );

    return hr;
}

HRESULT
AddWebExtension(
               VOID
               )
{
    WCHAR           szExtPath[MAX_PATH];
    WCHAR           szSystemPath[MAX_PATH];
    LPTSTR          pszGroupDesc = NULL;

    IISWebService*  pWeb = NULL;

    DBGMSG(DBG_INFO, ("Adding the Web Extension\r\n"));

    HRESULT hr = ADsGetObject(cszWebSvcExtRestrictionListADSILocation, IID_IISWebService, (void**)&pWeb);

    if (SUCCEEDED(hr) && NULL != pWeb)
    {

        VARIANT var1,var2;
        VariantInit(&var1);
        VariantInit(&var2);

        var1.vt = VT_BOOL;
        var1.boolVal = VARIANT_TRUE;

        var2.vt = VT_BOOL;
        var2.boolVal = VARIANT_FALSE;

        pszGroupDesc = GetStringFromRcFile(IDS_INTERNET_PRINTING);
        hr = (pszGroupDesc ? S_OK : E_FAIL);

        if (SUCCEEDED(hr))
        {
            hr = GetSystemDirectory(szSystemPath, COUNTOF (szSystemPath)) > 0 ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hr = StringCchPrintf(szExtPath, COUNTOF(szExtPath), cszExtPathFmt, szSystemPath);
        }

        if (SUCCEEDED(hr))
        {
            hr = pWeb->AddExtensionFile(szExtPath,var1,(LPWSTR) cszGroupId,var2,(LPWSTR) pszGroupDesc);
        }

        if (FAILED(hr))
        {
            if (ERROR_DUP_NAME == HRESULT_CODE(hr))
            {
                hr = S_OK;
            }
            else
            {
                DBGMSG(DBG_INFO, ("AddExtension failed,probably already exists\r\n"));
            }
        }

        VariantClear(&var1);
        VariantClear(&var2);
    }

    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        hr = pWeb->AddDependency((LPWSTR) pszGroupDesc,(LPWSTR) cszASPId);
        if (FAILED(hr))
        {
            if (ERROR_DUP_NAME == HRESULT_CODE(hr))
            {
                hr = S_OK;
            }
            else
            {
                DBGMSG(DBG_INFO, ("AddDependency failed,probably already exists\r\n"));
            }
        }
    }

    if (NULL != pWeb)
        pWeb->Release();

    if (pszGroupDesc)
        LocalFreeMem(pszGroupDesc);

    return hr;
}


/*++

Routine Name:

    AddScriptAtPrinterVDir

Description:

    Add the .printer and .asp script mapping at printers virtual directory

Arguments:

    pIMetaBase   - Pointer to the IIS Admin base

Returns:

    An HRESULT

--*/
HRESULT
AddScriptAtPrinterVDir(
                      IMSAdminBase *pIMetaBase
                      )
{
    static WCHAR szScritMapFmt[] = L"%ws%c.printer,%ws\\msw3prt.dll,1,GET,POST%c";
    static WCHAR szPrinterVDir[] = L"w3svc/1/root/printers";

    METADATA_HANDLE hMeta           = NULL;       // handle to metabase
    PWCHAR          pszFullFormat   = NULL;
    DWORD           dwMDRequiredDataLen;
    METADATA_RECORD mr;
    HRESULT         hr              = S_OK;
    DWORD           nLen;
    WCHAR           szSystemDir[MAX_PATH];
    PWCHAR          pszAspMapping   = NULL;
    DWORD           dwMappingLen    = 0;
    PWCHAR          pszScriptMap    = NULL;

    DBGMSG(DBG_INFO, ("Adding the ScriptMap\r\n"));

    //
    // Read any script map set at the top, on LM\w3svc where all other default ones are (e.g. .asp, etc.)
    //
    hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                 L"/LM",
                                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                 MY_META_TIMEOUT,
                                 &hMeta);

    if ( SUCCEEDED(hr) )
    {
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = 0;
        mr.pbMDData       = NULL;

        hr = pIMetaBase->GetData( hMeta, cszW3Svc, &mr, &dwMDRequiredDataLen );

        hr = hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) ? S_OK : E_FAIL;
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // allocate for existing stuff plus our new script map.
        //
        pszFullFormat = new WCHAR[dwMDRequiredDataLen];
        hr = pszFullFormat? S_OK : E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = dwMDRequiredDataLen * sizeof (WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(pszFullFormat);

        hr = pIMetaBase->GetData( hMeta, cszW3Svc, &mr, &dwMDRequiredDataLen );
    }

    if ( SUCCEEDED(hr) )
    {
        pszAspMapping = IsStrInMultiSZ( pszFullFormat, L".asp" );

        hr = pszAspMapping? S_OK: E_FAIL;
    }

    if ( SUCCEEDED(hr) )
    {
        nLen = COUNTOF (szScritMapFmt) + MAX_PATH + lstrlen (pszAspMapping);

        pszScriptMap = new WCHAR[nLen];

        hr = pszScriptMap ? S_OK : E_OUTOFMEMORY;
    }


    if ( SUCCEEDED(hr) )
    {
        //
        // Return value is the length in chars w/o null char.
        //
        hr = GetSystemDirectory(szSystemDir, COUNTOF (szSystemDir)) > 0 ? S_OK : E_FAIL;
    }

    if ( SUCCEEDED(hr) )
    {
        PWSTR   pszNewPos = NULL;

        hr = StringCchPrintfEx(pszScriptMap, nLen, &pszNewPos, NULL, 0, szScritMapFmt, pszAspMapping, L'\0', szSystemDir, L'\0');

        //
        // The actual number of characters in the string will be the number of
        // characters in the original string minus the remaining characters.
        //
        dwMappingLen = (DWORD)(pszNewPos - pszScriptMap);
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // Write the new SCRIPT value
        //
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = sizeof (WCHAR) * (dwMappingLen + 1) ;
        mr.pbMDData       = reinterpret_cast<unsigned char *>(pszScriptMap);

        hr = pIMetaBase->SetData(hMeta, szPrinterVDir, &mr );
    }

    if ( hMeta )
    {
        pIMetaBase->CloseKey( hMeta );
        hMeta = NULL;
    }

    delete [] pszScriptMap;
    delete [] pszFullFormat;

    return hr;
}


/*++

Routine Name:

    AddMimeType

Description:

    Add the .webpnp MimeType to the standard MimeType mappings

Arguments:

    pIMetaBase   - Pointer to the IIS Admin base

Returns:

    An HRESULT

--*/
HRESULT
AddMimeType(
           IMSAdminBase *pIMetaBase
           )
{
    METADATA_HANDLE hMeta           = NULL;       // handle to metabase
    DWORD           dwMDRequiredDataLen,
                    dwCurrentMapBytes,
                    dwWebPnPMapLen;
    METADATA_RECORD mr;
    HRESULT         hr              = S_OK;
    DWORD           nLen;
    PWCHAR          pszCurrentMimeMap  = NULL;
    PWCHAR          pszNewMimeMap   = NULL;
    PWCHAR          pszWebPnPMap     = NULL;
    DWORD           dwMappingLen     = 0;

    DBGMSG(DBG_INFO, ("Adding the MimeType\r\n"));

    //
    // Read the current MimeType mapping, on LM\MimeMap
    //
    hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                 L"/LM",
                                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                 MY_META_TIMEOUT,
                                 &hMeta);

    if ( SUCCEEDED(hr) )
    {
        mr.dwMDIdentifier = MD_MIME_MAP;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = 0;
        mr.pbMDData       = NULL;

        hr = pIMetaBase->GetData( hMeta, cszMimeMap, &mr, &dwCurrentMapBytes );
        hr = hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) ? S_OK : E_FAIL;
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // allocate for existing stuff plus our new script map.
        //
        pszCurrentMimeMap = (PWCHAR) new BYTE[dwCurrentMapBytes];
        hr = pszCurrentMimeMap? S_OK : E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        mr.dwMDIdentifier = MD_MIME_MAP;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = dwCurrentMapBytes;
        mr.pbMDData       = reinterpret_cast<unsigned char *>(pszCurrentMimeMap);

        hr = pIMetaBase->GetData( hMeta, cszMimeMap, &mr, &dwMDRequiredDataLen );
    }

    if ( SUCCEEDED(hr) )
    {
        pszWebPnPMap = IsStrInMultiSZ( pszCurrentMimeMap, L".webpnp" );

        //
        // If the map doesn't currently exist
        //
        if (!pszWebPnPMap)
        {
            dwWebPnPMapLen = COUNTOF (cszWebPnPMap);
            nLen = (dwWebPnPMapLen * sizeof(WCHAR)) + dwCurrentMapBytes;

            pszNewMimeMap = (PWCHAR) new BYTE[nLen];

            hr = pszNewMimeMap ? S_OK : E_OUTOFMEMORY;

            if ( SUCCEEDED(hr) )
            {
                CopyMemory( pszNewMimeMap,          // Remove our script map by copying the remainder of the multi_sz on top of the string containing the map.
                            pszCurrentMimeMap,
                            dwCurrentMapBytes);
                pszWebPnPMap = pszNewMimeMap + (dwCurrentMapBytes/sizeof(WCHAR));
                pszWebPnPMap--;       // Back up onto the Double NULL

                hr = StringCchCopy(pszWebPnPMap, dwWebPnPMapLen, cszWebPnPMap);
            }

            if ( SUCCEEDED(hr) )
            {
                pszWebPnPMap+=dwWebPnPMapLen;
                *pszWebPnPMap = 0x00;

                //
                // Write the new MimeType Map value
                //
                mr.dwMDIdentifier = MD_MIME_MAP;
                mr.dwMDAttributes = METADATA_INHERIT;
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = MULTISZ_METADATA;
                mr.dwMDDataLen    = nLen;
                mr.pbMDData       = reinterpret_cast<unsigned char *>(pszNewMimeMap);

                hr = pIMetaBase->SetData(hMeta, cszMimeMap, &mr );

                if (FAILED(hr))
                {
                    DBGMSG(DBG_INFO, ("AddMimeType Failed. RC = %d\r\n", HRESULT_CODE(hr)));
                }
            }
        }
    }

    if ( hMeta )
    {
        pIMetaBase->CloseKey( hMeta );
        hMeta = NULL;
    }

    delete [] pszCurrentMimeMap;
    delete [] pszNewMimeMap;

    return hr;
}



DWORD
RemoveWebPrinting(
                 VOID
                 )

{
    IMSAdminBase* pIMetaBase = NULL;
    DWORD         dwRet = NO_ERROR;
    HKEY          hKey;

    DBGMSG(DBG_INFO, ("Removing Web Printing.\n"));
    //
    // Before we try to uninstall check to see is the WWW
    //  service has already been uninstalled. If it is gone so are
    //  all of our reg entries.
    //
    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, cszW3SvcReg, 0, KEY_READ, &hKey))
    {
        RegCloseKey( hKey );
        //
        // Init up the MetaBase
        //
        if ( SUCCEEDED(CoInitializeEx( NULL, COINIT_MULTITHREADED )))
        {
            if ( SUCCEEDED(::CoCreateInstance(CLSID_MSAdminBase,
                                              NULL,
                                              CLSCTX_ALL,
                                              IID_IMSAdminBase,
                                              (void **)&pIMetaBase)) )
            {
                HRESULT         hr;                 // com error status
                METADATA_HANDLE hMeta = NULL;       // handle to metabase

                //
                // First Remove the Virtual Directory
                //
                // Attempt to open the virtual dir set on Web server #1 (default server)
                hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                               cszW3SvcRootPath,
                                               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                               MY_META_TIMEOUT,
                                               &hMeta );

                // Create the key if it does not exist.
                if ( SUCCEEDED( hr ) )
                {
                    pIMetaBase->DeleteKey( hMeta, cszPrinters );  // We don't check the retrun value since the key may already not exist and we could get an error for that reason.
                    pIMetaBase->CloseKey( hMeta );
                    hMeta = NULL;

                    //
                    // Next Remove the Web Extention Record & App Dependency
                    //
                    hr = RemoveWebExtension();

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Next Remove the .printers ScriptMap
                        //
                        PWCHAR          pszScripts = NULL,
                                        pszMimeMap = NULL;

                        DWORD           dwMDRequiredDataLen;
                        METADATA_RECORD mr;

                        // Read any script map set at the top, on LM\w3svc where all other default ones are (e.g. .asp, etc.)
                        hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                  L"/LM",
                                                  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                                  MY_META_TIMEOUT,
                                                  &hMeta);

                        if ( SUCCEEDED( hr ) )
                        {
                            mr.dwMDIdentifier = MD_SCRIPT_MAPS;
                            mr.dwMDAttributes = 0;
                            mr.dwMDUserType   = IIS_MD_UT_FILE;
                            mr.dwMDDataType   = MULTISZ_METADATA;
                            mr.dwMDDataLen    = 0;
                            mr.pbMDData       = NULL;

                            hr = pIMetaBase->GetData( hMeta, cszW3Svc, &mr, &dwMDRequiredDataLen );

                            if ( FAILED( hr ) )
                            {
                                if ( HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER )
                                {

                                    // allocate for existing stuff
                                    pszScripts = new WCHAR[dwMDRequiredDataLen];
                                    if ( pszScripts )
                                    {
                                        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
                                        mr.dwMDAttributes = 0;
                                        mr.dwMDUserType   = IIS_MD_UT_FILE;
                                        mr.dwMDDataType   = MULTISZ_METADATA;
                                        mr.dwMDDataLen    = dwMDRequiredDataLen;
                                        mr.pbMDData       = reinterpret_cast<unsigned char *>(pszScripts);

                                        hr = pIMetaBase->GetData( hMeta, cszW3Svc, &mr, &dwMDRequiredDataLen );

                                        if ( SUCCEEDED( hr ) )
                                            dwRet = WriteStrippedScriptValue( pIMetaBase, hMeta, pszScripts );    // Remove the .printer map from the multi_sz if there;

                                        delete pszScripts;
                                    }
                                }
                            }

                            if ( SUCCEEDED( hr ) )
                            {
                                mr.dwMDIdentifier = MD_MIME_MAP;
                                mr.dwMDAttributes = 0;
                                mr.dwMDUserType   = IIS_MD_UT_FILE;
                                mr.dwMDDataType   = MULTISZ_METADATA;
                                mr.dwMDDataLen    = 0;
                                mr.pbMDData       = NULL;

                                hr = pIMetaBase->GetData( hMeta, cszMimeMap, &mr, &dwMDRequiredDataLen );

                                if ( FAILED( hr ) )
                                {
                                    if ( HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER )
                                    {

                                        // allocate for existing stuff
                                        pszMimeMap = (PWCHAR) new BYTE[dwMDRequiredDataLen];
                                        if ( pszMimeMap )
                                        {
                                            mr.dwMDIdentifier = MD_MIME_MAP;
                                            mr.dwMDAttributes = 0;
                                            mr.dwMDUserType   = IIS_MD_UT_FILE;
                                            mr.dwMDDataType   = MULTISZ_METADATA;
                                            mr.dwMDDataLen    = dwMDRequiredDataLen;
                                            mr.pbMDData       = reinterpret_cast<unsigned char *>(pszMimeMap);

                                            hr = pIMetaBase->GetData( hMeta, cszMimeMap, &mr, &dwMDRequiredDataLen );

                                            if ( SUCCEEDED( hr ) )
                                                dwRet = WriteStrippedMimeMapValue( pIMetaBase, hMeta, pszMimeMap );    // Remove the .printer map from the multi_sz if there;

                                            delete pszMimeMap;
                                        }
                                    }
                                }
                            }

                            pIMetaBase->CloseKey( hMeta );
                        }
                        else
                            dwRet = GetLastError();
                    }
                    else
                        dwRet = GetLastError();
                }
                else
                    dwRet = GetLastError();

                if (SUCCEEDED(hr))
                {
                    hr = pIMetaBase->SaveData();
                    dwRet = HRESULT_CODE(hr);
                }

                pIMetaBase->Release();
            }
            CoUninitialize();
        }
    }

    return dwRet;

}


HRESULT
RemoveWebExtension(
                  VOID
                  )
{
    WCHAR           szExtPath[MAX_PATH];
    WCHAR           szSystemPath[MAX_PATH];
    IISWebService*  pWeb = NULL;

    DBGMSG(DBG_INFO, ("Removing the Web Extension\r\n"));

    HRESULT hr = ADsGetObject(cszWebSvcExtRestrictionListADSILocation, IID_IISWebService, (void**)&pWeb);
    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        hr = GetSystemDirectory(szSystemPath, COUNTOF (szSystemPath)) > 0 ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            hr = StringCchPrintf(szExtPath, COUNTOF(szExtPath), cszExtPathFmt, szSystemPath);
        }

        if (SUCCEEDED(hr))
        {
            hr = pWeb->DeleteExtensionFileRecord(szExtPath);
        }

        if (FAILED(hr))
        {
            DBGMSG(DBG_INFO, ("DeleteExtension failed,probably already gone\r\n"));
        }
    }

    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        LPTSTR pszGroupDesc = GetStringFromRcFile(IDS_INTERNET_PRINTING);
        hr = (pszGroupDesc ? S_OK : E_FAIL);

        if (SUCCEEDED(hr))
        {
            hr = pWeb->RemoveDependency((LPWSTR) pszGroupDesc,(LPWSTR) cszASPId);
        }

        if (FAILED(hr))
        {
            DBGMSG(DBG_INFO, ("RemoveDep failed,probably already gone\r\n"));
        }

        if (pszGroupDesc)
            LocalFreeMem(pszGroupDesc);

    }

    if (NULL != pWeb)
        pWeb->Release();

    return hr;
}



//
//
// Finds and removed our script map from the multi_sz, and writes it back to the metabase.
//
//
DWORD
WriteStrippedScriptValue(
                        IMSAdminBase *pIMetaBase,
                        METADATA_HANDLE hMeta,     // Handle to /LM tree
                        PWCHAR pszScripts          // MULTI_SZ string already there
                        )
{
    LPWSTR  pStrToKill, pNextStr;
    HRESULT hr;

    DBGMSG(DBG_INFO, ("Removing the ScriptMap\r\n"));

    // See if our script map is already there.
    if ( !(pStrToKill = IsStrInMultiSZ( pszScripts, L".printer" )) )
        return NO_ERROR;

    // Find the next string (could be the final NULL char)
    pNextStr = pStrToKill + (wcslen(pStrToKill) + 1);

    if ( !*pNextStr )
        *pStrToKill = 0;       // Our scipt map was at the end of multi_sz. Write the 2nd NULL char and we are done.
    else
        CopyMemory( pStrToKill,          // Remove our script map by copying the remainder of the multi_sz on top of the string containing the map.
                    pNextStr,
                    GetMultiSZLen(pNextStr) * sizeof(WCHAR));

    // Write the new SCRIPT value
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_SCRIPT_MAPS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiSZLen(pszScripts) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pszScripts);

    hr = pIMetaBase->SetData( hMeta, cszW3Svc, &mr );

    return( HRESULT_CODE( hr ));
}


//
//
// Finds and removed our .webpnp MimeType from the multi_sz, and writes it back to the metabase.
//
//
DWORD
WriteStrippedMimeMapValue(
                        IMSAdminBase *pIMetaBase,
                        METADATA_HANDLE hMeta,     // Handle to /LM tree
                        PWCHAR pszMimeMap          // MULTI_SZ string already there
                        )
{
    LPWSTR  pStrToKill, pNextStr;
    HRESULT hr;

    DBGMSG(DBG_INFO, ("Removing the MimeType\r\n"));

    // See if our script map is already there.
    if ( !(pStrToKill = IsStrInMultiSZ( pszMimeMap, L".webpnp" )) )
        return NO_ERROR;

    // Find the next string (could be the final NULL char)
    pNextStr = pStrToKill + (wcslen(pStrToKill) + 1);

    if ( !*pNextStr )
        *pStrToKill = 0;       // Our scipt map was at the end of multi_sz. Write the 2nd NULL char and we are done.
    else
        CopyMemory( pStrToKill,          // Remove our script map by copying the remainder of the multi_sz on top of the string containing the map.
                    pNextStr,
                    GetMultiSZLen(pNextStr) * sizeof(WCHAR));

    // Write the new SCRIPT value
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_MIME_MAP;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiSZLen(pszMimeMap) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pszMimeMap);

    hr = pIMetaBase->SetData( hMeta, cszMimeMap, &mr );

    return( HRESULT_CODE( hr ));
}


//
//
// Finds the string pSearch in pSrc buffer and returns a ptr to the occurance of pSearch in pSrc.
//
//
LPWSTR mystrstrni( LPWSTR pSrc, LPWSTR pSearch )
{
    UINT uSearchSize = wcslen( pSearch );
    UINT uSrcSize    = wcslen( pSrc );
    LPCTSTR  pEnd;

    if ( uSrcSize < uSearchSize )
        return(NULL);

    pEnd = pSrc + uSrcSize - uSearchSize;

    for ( ; pSrc <= pEnd; ++pSrc )
    {
        if ( !_wcsnicmp( pSrc, pSearch, uSearchSize ) )
            return((LPWSTR)pSrc);
    }

    return(NULL);
}

//
// Determines if the string pSearch can be found inside of a MULTI_SZ string. If it can, it retunrs a
// pointer to the beginning of the string in multi-sz that contains pSearch.
//
LPWSTR IsStrInMultiSZ( LPWSTR pMultiSzSrc, LPWSTR pSearch )
{
    LPWSTR pTmp = pMultiSzSrc;

    while ( TRUE )
    {
        if ( mystrstrni( pTmp, pSearch ) )  // See pSearch (i.e. ".printer" appears anywhere within this string. If it does, it must be ours.
            return pTmp;

        pTmp = pTmp + (wcslen(pTmp) + 1);   // Point to the beginning of the next string in the MULTI_SZ

        if ( !*pTmp )
            return NULL;             // reached the end of the MULTI_SZ string.
    }
}

/*++

Routine Name

    GetMultiSZLen

Routine Description:

    This returns the number of characters in a multisz string, including NULLs.

Arguments:

    pMultiSzSrc     -   The multisz string to search.

Return Value:

    The number of characters in the string.

--*/
DWORD
GetMultiSZLen(
    IN      LPWSTR              pMultiSzSrc
    )
{
    DWORD  dwLen = 0;
    LPWSTR pTmp = pMultiSzSrc;

    while( TRUE ) {
        dwLen += wcslen(pTmp) + 1;     // Incude the terminating NULL char

        pTmp = pMultiSzSrc + dwLen;           // Point to the beginning of the next string in the MULTI_SZ

        if( !*pTmp )
            return ++dwLen;     // Reached the end of the MULTI_SZ string. Add 1 to the count for the last NULL char.
    }
}

//
// Routine: IppOcEntry
//

DWORD
IppOcEntry(
          IN LPCVOID ComponentId,
          IN LPCVOID SubcomponentId,
          IN UINT Function,
          IN UINT Param1,
          IN OUT PVOID Param2
          )

{
    BOOL bWrongCompId = TRUE;
    DWORD dwRet = NO_ERROR;

    static MYSETUPSTRUCT* pMySetupInfo = NULL;

    //
    // Check if the ComponentId is correct
    //
    if ( ComponentId )
        bWrongCompId = _tcsicmp(cszComponentId, (LPCTSTR) ComponentId);

    switch ( Function )
    {
        case OC_PREINITIALIZE:
            DBGMSG(DBG_INFO, ("In OC_PREINITIALIZE.\n"));
            //
            // We are just starting up
            //
            if ( bWrongCompId ||
                 !(Param1 && OCFLAG_UNICODE) )
                dwRet = 0;
            else
                dwRet = OCFLAG_UNICODE;

            //
            // Cleanup Any leftover data
            //
            if ( pMySetupInfo )
            {
                LocalFree(pMySetupInfo);
                pMySetupInfo = NULL;
            }
            break;
        case OC_INIT_COMPONENT:
            DBGMSG(DBG_INFO, ("In OC_INIT_COMPONENT.\n"));
            {
                //
                // Setup our Internal info
                //
                PSETUP_INIT_COMPONENT pInputData = (PSETUP_INIT_COMPONENT) Param2;
                if ( bWrongCompId ||
                     !pInputData  ||
                     (HIWORD(pInputData->OCManagerVersion) < OCVER_MAJOR) )
                {
                    dwRet = ERROR_CALL_NOT_IMPLEMENTED;
                }
                else
                {
                    //
                    // We have a good version of the OCM
                    //

                    // Set our desired version
                    pInputData->ComponentVersion = OCMANAGER_VERSION;

                    //
                    // Save away the usefal data
                    //
                    pMySetupInfo = (MYSETUPSTRUCT*) LocalAlloc(LPTR, sizeof(MYSETUPSTRUCT));
                    if ( pMySetupInfo )
                    {
                        // Copy the SetupData
                        CopyMemory(&pMySetupInfo->OCData, &pInputData->SetupData, sizeof(SETUP_DATA));
                        // Copy Helper Routines Function Pointers
                        CopyMemory(&pMySetupInfo->OCHelpers, &pInputData->HelperRoutines, sizeof(OCMANAGER_ROUTINES));

                        // Set the FirstPass flag
                        pMySetupInfo->bFirstCall = TRUE;

                        dwRet = NO_ERROR;
                    }
                    else
                        dwRet = GetLastError();
                }
            }
            break;
        case OC_SET_LANGUAGE:
            //
            // Don't Fail since we doan't actually need language support
            //
            dwRet = TRUE;
            break;
        case OC_QUERY_CHANGE_SEL_STATE:
            //
            // If we are getting asked to be turned on because our parent was selected -
            //
            if (Param1  &&
                (((UINT) (ULONG_PTR)Param2) & OCQ_DEPENDENT_SELECTION) &&
                !(((UINT) (ULONG_PTR)Param2) & OCQ_ACTUAL_SELECTION ))
            {
                //  Don't do it...
                dwRet = FALSE;
            }
            else
            {
                // Otherwise it is OK.
                dwRet = TRUE;

            }
            break;
        case OC_QUERY_STEP_COUNT:
            //
            // We only have one step
            //   Create/Delete the VDIR & ScriptMap
            //
            dwRet = 1;
            break;
        case OC_COMPLETE_INSTALLATION:
            DBGMSG(DBG_INFO, ("In OC_COMPLETE_INSTALLATION.\n"));
            //
            // Check the state of the Checkbox and either create or delete the VDIR.
            //
            if ( !bWrongCompId &&
                 pMySetupInfo && pMySetupInfo->OCHelpers.QuerySelectionState )
            {
                //
                // If this is the first call then skip until more things are installed.
                //
                if (pMySetupInfo->bFirstCall)
                {
                    pMySetupInfo->bFirstCall = FALSE;
                }
                else
                {
                    BOOL bDoInstall;

                    //
                    // Get the current selection state
                    //
                    bDoInstall = pMySetupInfo->OCHelpers.QuerySelectionState( pMySetupInfo->OCHelpers.OcManagerContext,
                                                                              cszComponentId, OCSELSTATETYPE_CURRENT);

                    if ( (NO_ERROR == GetLastError()) &&
                         (bDoInstall != pMySetupInfo->bInitState) )
                    {
                        //
                        // We got a valid state
                        //
                        LPTSTR              pszProcessInfo = NULL;
                        STARTUPINFO         StartUpInfo;
                        PROCESS_INFORMATION ProcInfo;

                        //
                        // Call Create Process
                        //
                        if ( bDoInstall )
                            pszProcessInfo = AllocStr(cszInstallInetPrint);
                        else
                            pszProcessInfo = AllocStr(cszRemoveInetPrint);

                        if (pszProcessInfo)
                        {
                            //
                            // Init the Startup Info
                            //
                            memset(&StartUpInfo, 0, sizeof(STARTUPINFO));
                            StartUpInfo.cb = sizeof(STARTUPINFO);


                            if (CreateProcess( NULL, pszProcessInfo, NULL, NULL, FALSE,
                                    (CREATE_NO_WINDOW|NORMAL_PRIORITY_CLASS), NULL, NULL, &StartUpInfo, &ProcInfo))
                            {
                                //
                                // Wait on the process handle
                                //
                                WaitForSingleObject( ProcInfo.hProcess, INFINITE);

                                //
                                //   Get the Process Exit Code
                                //
                                if (!GetExitCodeProcess( ProcInfo.hProcess, &dwRet ))
                                    dwRet = GetLastError();

                                //
                                //  CLose the Preocess & Thread Handles
                                //
                                CloseHandle(ProcInfo.hProcess);
                                CloseHandle(ProcInfo.hThread);
                            }
                            else
                                dwRet = GetLastError();

                            LocalFree(pszProcessInfo);
                        }
                        else
                            dwRet = GetLastError();


                        if (NO_ERROR == dwRet)
                        {
                            HANDLE              hServer;
                            DWORD               dwInstallWebPrinting = bDoInstall,
                                                dwLastError,
                                                dwType = REG_DWORD;
                            PRINTER_DEFAULTS    Defaults    = {NULL, NULL, SERVER_ACCESS_ADMINISTER};

                            if ( !OpenPrinter(NULL, &hServer, &Defaults) )
                                return FALSE;

                            dwLastError = SetPrinterData(hServer,
                                                         SPLREG_WEBSHAREMGMT,
                                                         dwType,
                                                         (LPBYTE)&dwInstallWebPrinting,
                                                         sizeof(dwInstallWebPrinting));

                            ClosePrinter(hServer);
                        }
                    }
                }
            }

            DBGMSG(DBG_INFO, ("Exitting OC_COMPLETE_INSTALLATION. RC = %d\n", dwRet));

            break;
        case OC_CLEANUP:
            DBGMSG(DBG_INFO, ("In OC_CLEANUP.\n"));
            //
            // The install is done or cancelled so cleanup the allocated memory
            //
            if ( pMySetupInfo )
            {
                LocalFree(pMySetupInfo);
                pMySetupInfo = NULL;
            }
            break;
        case OC_QUERY_STATE:

            DBGMSG(DBG_INFO, ("In OC_QUERY_STATE.\n"));
            //
            // Figure out if the VDIR exists to set the initial state of the checkbox.
            //
            if ( !bWrongCompId &&
                 (Param1 == OCSELSTATETYPE_ORIGINAL) )
            {
                //
                // If we are upgrading we need to run the install code as if we aren't currently installed
                //  otherwise save away the initial state
                //
                pMySetupInfo->bInitState = IsVDIRInstalled();

                if (pMySetupInfo->bInitState)
                    dwRet = SubcompOn;
                else
                    dwRet = SubcompOff;

                if (pMySetupInfo->OCData.OperationFlags & SETUPOP_NTUPGRADE)
                {
                    pMySetupInfo->bInitState = FALSE;
                    DBGMSG(DBG_INFO, ("Performing NT Upgrade.\n"));
                }

                DBGMSG(DBG_INFO, ("Current Componenet state = %d.\n", dwRet));
            }
            break;
        default:
            break;

    }

    return dwRet;
}

void CALLBACK SetupInetPrint(
                            IN   HWND       hwnd,        // handle to owner window
                            IN   HINSTANCE  hinst,  // instance handle for the DLL
                            IN   LPSTR     lpCmdLine, // string the DLL will parse
                            IN   int        nCmdShow      // show state
                            )

{
    DWORD  dwRet;

    //
    // Check Cmdline for either Install or Remove parameters
    if ( !_strnicmp( lpCmdLine, cszInstall, COUNTOF(cszInstall)) )
        dwRet = InstallWebPrinting();
    else if ( !_strnicmp( lpCmdLine, cszRemove, COUNTOF(cszRemove)) )
        dwRet = RemoveWebPrinting();
    else
        dwRet = ERROR_INVALID_PARAMETER;

    ExitProcess(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\monitor.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Monitor.c

Abstract:

    Routines for installing monitors

Author:

    Muhunthan Sivapragasam (MuhuntS)  30-Nov-1995

Revision History:

--*/

#include "precomp.h"


//
// Keys to search INF files
//
TCHAR   cszPortMonitorSection[]     = TEXT("PortMonitors");
TCHAR   cszPortMonitorDllKey []     = TEXT("PortMonitorDll");
TCHAR   cszMonitorInf[]             = TEXT("*.inf");


typedef struct _MON_INFO {
    LPTSTR  pszName;
    LPTSTR  pszDllName;
    BOOL    bInstalled;
} MON_INFO, *PMON_INFO;

typedef struct _MONITOR_SETUP_INFO {
    PMON_INFO  *ppMonInfo;
    DWORD       dwCount;
    LPTSTR      pszInfFile;         // Valid only for OEM disk INF
    LPTSTR      pszServerName;
} MONITOR_SETUP_INFO, *PMONITOR_SETUP_INFO;


VOID
FreeMonInfo(
    PMON_INFO   pMonInfo
    )
/*++

Routine Description:
    Free memory for a MON_INFO structure and the strings in it

Arguments:
    pMonInfo    : MON_INFO structure pointer

Return Value:
    Nothing

--*/
{
    if ( pMonInfo ) {

        LocalFreeMem(pMonInfo->pszName);
        LocalFreeMem(pMonInfo->pszDllName);

        LocalFreeMem(pMonInfo);
    }
}


PMON_INFO
AllocMonInfo(
    IN  LPTSTR  pszName,
    IN  LPTSTR  pszDllName,     OPTIONAL
    IN  BOOL    bInstalled,
    IN  BOOL    bAllocStrings
    )
/*++

Routine Description:
    Allocate memory for a MON_INFO structure and create strings

Arguments:
    pszName         : Monitor name
    pszDllName      : Monitor DLL name
    bAllocStrings   : TRUE if routine should allocated memory and create string
                      copies, else just assign the pointers

Return Value:
    Pointer to the created MON_INFO structure. NULL on error.

--*/
{
    PMON_INFO   pMonInfo;

    pMonInfo    = (PMON_INFO) LocalAllocMem(sizeof(*pMonInfo));

    if ( !pMonInfo )
        return NULL;

    if ( bAllocStrings ) {

        pMonInfo->pszName    = AllocStr(pszName);
        pMonInfo->pszDllName = AllocStr(pszDllName);

        if ( !pMonInfo->pszName ||
             (pszDllName && !pMonInfo->pszDllName) ) {

            FreeMonInfo(pMonInfo);
            return NULL;

        }
    } else {

        pMonInfo->pszName       = pszName;
        pMonInfo->pszDllName    = pszDllName;
    }

    pMonInfo->bInstalled = bInstalled;

    return pMonInfo;
}


VOID
PSetupDestroyMonitorInfo(
    IN OUT HANDLE h
    )
/*++

Routine Description:
    Free memory allocated to a MONITOR_SETUP_INFO structure and its contents

Arguments:
    h   : A handle got by call to PSetupCreateMonitorInfo

Return Value:
    Nothing

--*/
{
    PMONITOR_SETUP_INFO pMonitorSetupInfo = (PMONITOR_SETUP_INFO) h;
    DWORD   Index;

    if ( pMonitorSetupInfo ) {

        if ( pMonitorSetupInfo->ppMonInfo ) {

            for ( Index = 0 ; Index < pMonitorSetupInfo->dwCount ; ++Index )
                FreeMonInfo(pMonitorSetupInfo->ppMonInfo[Index]);

            LocalFreeMem(pMonitorSetupInfo->ppMonInfo);
            pMonitorSetupInfo->ppMonInfo = NULL;
        }

        LocalFreeMem(pMonitorSetupInfo->pszInfFile);
        LocalFreeMem(pMonitorSetupInfo->pszServerName);
        pMonitorSetupInfo->pszInfFile = NULL;
        pMonitorSetupInfo->pszServerName = NULL;

        LocalFreeMem(pMonitorSetupInfo);
    }
}


PMONITOR_SETUP_INFO
CreateMonitorInfo(
    LPCTSTR     pszServerName
    )
/*++

Routine Description:
    Finds all installed and installable monitors.

Arguments:
    pSelectedDrvInfo    : Pointer to the selected driver info (optional)

Return Value:
    A pointer to MONITOR_SETUP_INFO on success,
    NULL on error

--*/
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = NULL;
    PMON_INFO               *ppMonInfo;
    PMONITOR_INFO_2         pMonitor2;
    LONG                    Index, Count = 0;
    BOOL                    bFail = TRUE;
    DWORD                   dwNeeded, dwReturned;
    LPBYTE                  pBuf = NULL;
    LPTSTR                  pszMonName;

    //
    // First query spooler for installed monitors. If we fail let's quit
    //
    if ( !EnumMonitors((LPTSTR)pszServerName, 2, NULL,
                       0, &dwNeeded, &dwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
             !(pBuf = LocalAllocMem(dwNeeded)) ||
             !EnumMonitors((LPTSTR)pszServerName,
                           2,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           &dwReturned) ) {

            goto Cleanup;
        }
    }

    //
    // We know how many monitors we have to display now
    //
    pMonitorSetupInfo = (PMONITOR_SETUP_INFO) LocalAllocMem(sizeof(*pMonitorSetupInfo));

    if ( !pMonitorSetupInfo )
        goto Cleanup;

    ZeroMemory(pMonitorSetupInfo, sizeof(*pMonitorSetupInfo));

    //
    // pMonitorSetupInfo->dwCount could be adjusted later not to list duplicate
    // entries. We are allocating max required buffer here
    //
    pMonitorSetupInfo->dwCount = dwReturned;

    pMonitorSetupInfo->ppMonInfo = (PMON_INFO *)
                        LocalAllocMem(pMonitorSetupInfo->dwCount*sizeof(PMON_INFO));

    ppMonInfo = pMonitorSetupInfo->ppMonInfo;

    if ( !ppMonInfo )
        goto Cleanup;

    for ( Index = 0, pMonitor2 = (PMONITOR_INFO_2) pBuf ;
          Index < (LONG) dwReturned ;
          ++Index, (LPBYTE)pMonitor2 += sizeof(MONITOR_INFO_2) ) {

        *ppMonInfo++ = AllocMonInfo(pMonitor2->pName,
                                    pMonitor2->pDLLName,
                                    TRUE,
                                    TRUE);
    }

    bFail = FALSE;

Cleanup:
    if ( pBuf )
        LocalFreeMem(pBuf);

    if ( bFail ) {

        PSetupDestroyMonitorInfo(pMonitorSetupInfo);
        pMonitorSetupInfo = NULL;
    }

    return pMonitorSetupInfo;
}


BOOL
AddPrintMonitor(
    IN  LPCTSTR     pszName,
    IN  LPCTSTR     pszDllName
    )
/*++

Routine Description:
    Add a print monitor by calling AddMonitor to spooler

Arguments:
    pszName     : Name of the monitor
    pszDllName  : Monitor dll name

Return Value:
    TRUE if monitor was succesfully added or it is already installed,
    FALSE on failure

--*/
{
    MONITOR_INFO_2  MonitorInfo2;

    MonitorInfo2.pName          = (LPTSTR) pszName;
    MonitorInfo2.pEnvironment   = NULL;
    MonitorInfo2.pDLLName       = (LPTSTR) pszDllName;

    //
    // Call is succesful if add returned TRUE, or monitor is already installed
    //
    if ( AddMonitor(NULL, 2, (LPBYTE) &MonitorInfo2) ||
         GetLastError() == ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) {

        return TRUE;
    } else {

        return FALSE;
    }
}

BOOL
InstallOnePortMonitor(HWND hwnd, 
                      HINF hInf, 
                      LPTSTR pMonitorName, 
                      LPTSTR pSectionName, 
                      LPTSTR pSourcePath)
/*++

Routine Description:
    Install one port monitor by copying files and calling spooler to add it

Arguments:
    hwnd                : Window handle of current top-level window
    hInf                : handle to the INF file
    pMonitorName        : port monitor display name
    pSectionName        : install section within the INF for the port monitor 

Return Value:
    TRUE if a port monitor was successfully installed
    FALSE if not

--*/

{
    DWORD  NameLen = MAX_PATH;
    BOOL   bSuccess = FALSE;
    HSPFILEQ InstallQueue = {0};
    PVOID  pQueueContext = NULL;
    LPTSTR  pMonitorDllName;

    if ((pMonitorDllName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL)
    {
        goto Cleanup;
    }
    
    //
    // Find the port monitor DLL name
    //
    if (!SetupGetLineText(NULL, hInf, pSectionName, cszPortMonitorDllKey, pMonitorDllName, NameLen, NULL))
    {
        goto Cleanup;
    }

    //
    // perform the installation
    //
    
    if ((InstallQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    if (!SetupInstallFilesFromInfSection(hInf, NULL, InstallQueue, pSectionName, pSourcePath, 
                                         SP_COPY_IN_USE_NEEDS_REBOOT | SP_COPY_NOSKIP))
    {
        goto Cleanup;
    }

    //
    // Commit the file queue. This gets all files copied over.
    //
    pQueueContext = SetupInitDefaultQueueCallback(hwnd);
    if ( !pQueueContext ) 
    {
        goto Cleanup;
    }

    bSuccess = SetupCommitFileQueue(hwnd,
                                  InstallQueue,
                                  SetupDefaultQueueCallback,
                                  pQueueContext);


    if ( !bSuccess )
        goto Cleanup;

    bSuccess = AddPrintMonitor(pMonitorName, pMonitorDllName);

Cleanup:
    if (pQueueContext)
    {
        SetupTermDefaultQueueCallback(pQueueContext);
    }

    if (pMonitorDllName)
    {
        LocalFreeMem(pMonitorDllName);
        pMonitorDllName = NULL;
    }
    
    SetupCloseFileQueue(InstallQueue);

    if (!bSuccess)
    {
        LPTSTR pszFormat = NULL, pszPrompt = NULL, pszTitle = NULL;

        pszFormat   = GetStringFromRcFile(IDS_ERROR_INST_PORT_MONITOR);
        pszTitle    = GetStringFromRcFile(IDS_INSTALLING_PORT_MONITOR);

        if ( pszFormat && pszTitle)
        {
            DWORD dwBufSize;

            dwBufSize = (lstrlen(pszFormat) + lstrlen(pMonitorName) + 2) * sizeof(TCHAR);
            pszPrompt = LocalAllocMem(dwBufSize);

            if ( pszPrompt )
            {
                StringCbPrintf(pszPrompt, dwBufSize, pszFormat, pMonitorName);

                MessageBox(hwnd, pszPrompt, pszTitle, MB_OK);

                LocalFreeMem(pszPrompt);
            }

        }
        LocalFreeMem(pszFormat);
        LocalFreeMem(pszTitle);
    
    }

    return bSuccess;
}

BOOL
InstallAllPortMonitorsFromInf(HWND hwnd, 
                              HINF hInfFile, 
                              LPTSTR pSourcePath)
/*++

Routine Description:
    Install all port monitors listed in one INF

Arguments:
    hwnd                : Window handle of current top-level window
    hInfFile            : handle of the INF file
    pSourcePath         : path to the INF file (without the name of the INF)

Return Value:
    TRUE if at least one port monitor was successfully installed
    FALSE if not

--*/

{
    LPTSTR pMonitorName = NULL, pSectionName= NULL;
    DWORD  NameLen = MAX_PATH;
    BOOL   bSuccess = FALSE;
    INFCONTEXT Context = {0};

    if (((pMonitorName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL) ||
        ((pSectionName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL))
    {
        goto Cleanup;
    }

    //
    // Go through the list of port monitors
    //
    if (!SetupFindFirstLine(hInfFile, cszPortMonitorSection, NULL, &Context))
    {
        goto Cleanup;
    }

    do 
    {
        //
        // get the key name
        //
        if (!SetupGetStringField(&Context, 0, pMonitorName, NameLen, NULL))
        {
            goto Cleanup;
        }
        //
        // get the section name
        //
        if (!SetupGetStringField(&Context, 1, pSectionName, NameLen, NULL))
        {
            goto Cleanup;
        }
        
        bSuccess = InstallOnePortMonitor(hwnd, hInfFile, pMonitorName, pSectionName, pSourcePath) ||
                   bSuccess;

    } while (SetupFindNextLine(&Context, &Context));

Cleanup:
    if (pMonitorName)
    {
        LocalFreeMem(pMonitorName);
    }
    if (pSectionName)
    {
        LocalFreeMem(pSectionName);
    }

    return bSuccess;
}

BOOL
PSetupInstallMonitor(
    IN  HWND                hwnd
    )
/*++

Routine Description:
    Install a print monitor by copying files, and calling spooler to add it

Arguments:
    hwnd                : Window handle of current top-level window

Return Value:
    TRUE if at least one port monitor was successfully installed
    FALSE if not

--*/
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = NULL;
    PMON_INFO              *ppMonInfo, pMonInfo;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              InfContext;
    TCHAR                   szInfPath[MAX_PATH];
    LPTSTR                  pszTitle, pszPrintMonitorPrompt;
    WIN32_FIND_DATA         FindData ={0};
    HANDLE                  hFind;
    size_t                  PathLen;
    BOOL                    bRet = FALSE;
    

    pszTitle              = GetStringFromRcFile(IDS_INSTALLING_PORT_MONITOR);
    pszPrintMonitorPrompt = GetStringFromRcFile(IDS_PROMPT_PORT_MONITOR);

    if (!pszTitle || ! pszPrintMonitorPrompt) 
    {
        goto Cleanup;
    }

    //
    // Ask the user where the inf file with the port monitor info resides
    //
    GetCDRomDrive(szInfPath);

    if ( !PSetupGetPathToSearch(hwnd,
                                pszTitle,
                                pszPrintMonitorPrompt,
                                cszMonitorInf,
                                TRUE,
                                szInfPath) ) {

        goto Cleanup;
    }

    //
    // find the INF(s) in the path. There must be one else SetupPromptForPath would've complained
    //
    PathLen = _tcslen(szInfPath);
    if (PathLen > MAX_PATH - _tcslen(cszMonitorInf) - 2) // -2 for terminating zero and backslash
    {
        DBGMSG(DBG_WARN, ("PSetupInstallMonitor: Path too long\n"));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        goto Cleanup;
    }

    ASSERT(PathLen);

    if (szInfPath[PathLen-1] != _T('\\'))
    {
        szInfPath[PathLen++] = _T('\\');
        szInfPath[PathLen] = 0;
    }

    StringCchCat(szInfPath, COUNTOF(szInfPath), cszMonitorInf);

    hFind = FindFirstFile(szInfPath, &FindData);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        HANDLE hInfFile;

        do
        {
            if (PathLen + _tcslen(FindData.cFileName) >= MAX_PATH)
            {
                DBGMSG(DBG_WARN, ("PSetupInstallMonitor: Path for %s%s too long - file skipped\n", szInfPath, FindData.cFileName));
                SetLastError(ERROR_BUFFER_OVERFLOW);
                continue;
            }

            StringCchCopy(&(szInfPath[PathLen]), COUNTOF(szInfPath) - PathLen, FindData.cFileName);

            hInfFile = SetupOpenInfFile(szInfPath, _T("Printer"), INF_STYLE_WIN4, NULL);

            if (hInfFile != INVALID_HANDLE_VALUE)
            {
                //
                // if the file has a section on port monitors, install it
                //
                if ( SetupGetLineCount(hInfFile, cszPortMonitorSection) > 0 )
                {
                    //
                    // cut off the INF name from the path
                    //
                    szInfPath[PathLen -1] = 0;

                    //
                    // bRet should be TRUE if there was at least one print monitor successfully installed
                    //
                    bRet = InstallAllPortMonitorsFromInf(hwnd, hInfFile, szInfPath) || bRet;                    
                    
                    //
                    // Put the trailing backslash back on
                    //
                    szInfPath[PathLen -1] = _T('\\');
                
                }

                SetupCloseInfFile(hInfFile);
            }
        } while ( FindNextFile(hFind, &FindData) );

        FindClose(hFind);
    }

Cleanup:
    if (pszTitle)
    {
        LocalFreeMem(pszTitle);
    }
    if (pszPrintMonitorPrompt)
    {
        LocalFreeMem(pszPrintMonitorPrompt);
    }

    return bRet;
}


HANDLE
PSetupCreateMonitorInfo(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszServerName
    )
/*++
   Routing Description:
       Returns structure (MONITOR_SETUP_INFO) with all installed port monitors.
   
   Arguments:
      hwnd - usused window handle
      pszServerName - the server on which to look for installed monitors
    
   Return Value:
      A pointer to MONITOR_SETUP_INFO on success,
      NULL on error  
--*/
{
    return (HANDLE) CreateMonitorInfo(pszServerName);
}


BOOL
PSetupEnumMonitor(
    IN     HANDLE   h,
    IN     DWORD    dwIndex,
    OUT    LPTSTR   pMonitorName,
    IN OUT LPDWORD  pdwSize
    )
/*++
   Routing Description:
      Gets the name of the monitor at "position" dwIndex in the MONITOR_SETUP_INFO
      structure pointed to by h.
   
   Arguments:
      hwnd - usused window handle
      pszServerName - the server on which to look for installed monitors
    
   Return Value:
      A pointer to MONITOR_SETUP_INFO on success,
      NULL on error  
--*/
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = (PMONITOR_SETUP_INFO) h;
    PMON_INFO               pMonInfo;
    DWORD                   dwNeeded;

    if(!pMonitorSetupInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwIndex >= pMonitorSetupInfo->dwCount ) {

        SetLastError(ERROR_NO_MORE_ITEMS);
        return FALSE;
    }

    pMonInfo = pMonitorSetupInfo->ppMonInfo[dwIndex];

    dwNeeded = lstrlen(pMonInfo->pszName) + 1;
    if ( dwNeeded > *pdwSize ) {

        *pdwSize = dwNeeded;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    StringCchCopy(pMonitorName, *pdwSize, pMonInfo->pszName);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\printupg.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    printupg.cxx
    
Abstract:

    Code to implement printupg. Please refer to printupg.hxx for an overview 
    of printupg feature set.
    
Author:

    Larry Zhu (LZhu) 20-Feb-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "printupg.hxx"

/*++

Routine Name

    PSetupIsCompatibleDriver
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver is blocked 
    or warned, return the blocking status and the replacement driver, if any.
    
Arguments:
    
    pszServer             - The server that needs to check for bad driver. If
                            pszServer is NULL, that means the local machine
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path 
                            or the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    dwVersion             - The major version of the driver
    pFileTimeDriver       - The FileTime of the driver
    puBlockingStatus      - Points to status of blocking
    ppszReplacementDriver - Points to the NULL terminating name of the replacement 
                            driver. A *NULL* string (instead of an empty string) 
                            means there is no replacement driver

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code. Pass a NULL to ppszReplacementDriver 
                           will not receive the name of replacement driver otherwise
                           Call PSetupFreeMem to free the received string pointed by
                           ppszReplacementDriver

--*/
BOOL
PSetupIsCompatibleDriver(
    IN     LPCTSTR          pszServer,                OPTIONAL
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     DWORD            dwVersion,
    IN     FILETIME         *pFileTimeDriver,        
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    )
{
    HRESULT hRetval         = E_FAIL;
    UINT    uBlockingStatus = 0;
    TString strReplacementDriver;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pFileTimeDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = 0;
        if (ppszReplacementDriver)
        {
            *ppszReplacementDriver = NULL;
        }
        
        hRetval = IsLocalMachineServer();
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = InternalCompatibleDriverCheck(pszDriverModel,
                                                pszDriverPath,
                                                pszEnvironment,
                                                pFileTimeDriver,
                                                cszUpgradeInf,
                                                dwVersion,
                                                S_OK == hRetval ? TRUE : FALSE,  // bIsServer
                                                &uBlockingStatus,
                                                &strReplacementDriver);
    }
                                         
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = uBlockingStatus;
        if ((BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) && ppszReplacementDriver && !strReplacementDriver.bEmpty())
        {
            *ppszReplacementDriver = AllocStr(strReplacementDriver);
            hRetval = ppszReplacementDriver ? S_OK : E_OUTOFMEMORY;
            
            if (SUCCEEDED(hRetval))
            {
                *pdwBlockingStatus |= BSP_INBOX_DRIVER_AVAILABLE;
            }
        }
    } 
          
    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));   
    return SUCCEEDED(hRetval);                                     
}

/*++

Routine Name:

    AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry

Routine Description:

    This routine tries to add the printer driver and it is blocked or
    warned, it popups a message box either indicates the driver is blocked 
    and installation will abort or at the case of warned driver, whether 
    to preceed the driver installation.

Arguments:

    pszServer                     - The server that needs to check for bad driver. If
                                    pszServer is NULL, that means the local machine
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    dwAddDrvFlags                 - Flags used in AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOfferReplacement             - Whether to offer replacement
    bPopupUI                      - Whether to popup UI
    ppszReplacementDriver         - Points to the replacement driver
    pdwBlockingStatus             - Points to blocking status of the driver    
    
Return Value:

    An BOOL                      - GetLastError() on failure                 

--*/  
BOOL
AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    )
{  
    HRESULT   hRetval         = E_FAIL;
    DWORD     dwLevel         = 6;
    FILETIME  DriverFileTime;

    hRetval = pDriverInfo6 && ppszReplacementDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
    
    //
    // Set APD_NO_UI flag and call AddPrinterDriver.
    //
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = BSP_PRINTER_DRIVER_OK;
        *ppszReplacementDriver = NULL;
        dwAddDrvFlags |= APD_NO_UI;
        hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                     dwLevel,
                                     reinterpret_cast<BYTE*>(pDriverInfo6),
                                     dwAddDrvFlags) ? ERROR_SUCCESS : GetLastErrorAsHResult();
    }

    for ( dwLevel = 4; (FAILED(hRetval) && (ERROR_INVALID_LEVEL == HRESULT_CODE(hRetval))) && (dwLevel > 1) ; --dwLevel ) {
        
        //
        // Since DRIVER_INFO_2, 3, 4 are subsets of DRIVER_INFO_6 and all fields
        // are at the beginning these calls can be made with same buffer
        //
        hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                     dwLevel,
                                     reinterpret_cast<BYTE*>(pDriverInfo6),
                                     dwAddDrvFlags) ? S_OK : GetLastErrorAsHResult();
    }
   
    //
    // Set the blocking status information (either blocked or warned) from the 
    // server.
    //
    // Show printupg ui and get the replacement driver from printupg.inf on 
    // client and get user's response and retry AddPrinterDriver with level
    // dwLevel.
    //
    if (FAILED(hRetval) && bPopupUI && ((ERROR_PRINTER_DRIVER_BLOCKED == HRESULT_CODE(hRetval)) || (ERROR_PRINTER_DRIVER_WARNED == HRESULT_CODE(hRetval))))
    {       
        *pdwBlockingStatus = (ERROR_PRINTER_DRIVER_BLOCKED == HRESULT_CODE(hRetval)) ? BSP_PRINTER_DRIVER_BLOCKED : BSP_PRINTER_DRIVER_WARNED;
    
        hRetval = PrintUpgRetry(pszServer,                               
                                dwLevel,
                                pDriverInfo6,
                                dwAddDrvFlags,
                                bIsDriverPathFullPath,
                                bOfferReplacement,
                                pdwBlockingStatus,
                                ppszReplacementDriver);
    }   

    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));
    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    BlockedDriverPrintUpgUI
   
Routine Description:

    This routine checks the printupg.inf and see if the driver is there. If the
    driver is there, consider it blocked even if it is warned. Then it popups a
    message box either indicates the driver is blocked and ask whether the user
    wants to proceed to install a replacement driver it has one.

Arguments:

    pszServer                     - The server that needs to check for bad driver. If
                                    pszServer is NULL, that means the local machine
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOfferReplacement             - Whether to offer replacement
    bPopupUI                      - Whether to popup UI
    ppszReplacementDriver         - Points to the replacement driver
    pdwBlockingStatus             - Points to blocking status of the driver    
    
Return Value:

    An BOOL                      - GetLastError() on failure                 

--*/  
BOOL
BlockedDriverPrintUpgUI(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    )
{  
    HRESULT hRetval                  = E_FAIL;
    DWORD   dwBlockingStatusOnClient = BSP_PRINTER_DRIVER_OK;

    hRetval = pDriverInfo6 && ppszReplacementDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
             
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = BSP_PRINTER_DRIVER_OK;
        *ppszReplacementDriver = NULL;
        hRetval = IsDriverBadLocally(pszServer,
                                     pDriverInfo6,
                                     bIsDriverPathFullPath,
                                     &dwBlockingStatusOnClient,
                                     ppszReplacementDriver); 

        //
        // Get the replacement driver information
        //
        if (SUCCEEDED(hRetval) && (BSP_PRINTER_DRIVER_OK != (dwBlockingStatusOnClient & BSP_BLOCKING_LEVEL_MASK)))
        {
            *pdwBlockingStatus |= (dwBlockingStatusOnClient & ~BSP_BLOCKING_LEVEL_MASK) | BSP_PRINTER_DRIVER_BLOCKED; 
        }
    }

    if (SUCCEEDED(hRetval) && bPopupUI && (BSP_PRINTER_DRIVER_BLOCKED & *pdwBlockingStatus))
    {
        hRetval = PrintUpgRetry(pszServer,                               
                                6, // dwLevel, do not care in the case of blocked driver
                                pDriverInfo6,
                                0, // dwAddDrvFlags, do not care in the case of blocked driver
                                bIsDriverPathFullPath,
                                bOfferReplacement,
                                pdwBlockingStatus,
                                ppszReplacementDriver);
    }

    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));
    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    PrintUpgRetry

Routine Description:

    This routine popups up a message box either indicates the driver is blocked
    or warned and asks the user how to preceed. In the case of warned driver, 
    whether to preceed the driver installation and retry AddPrinterDriver if 
    the user wants to proceed with a warned driver.

Arguments:

    pszServer                     - Remote machine that has the driver files
    dwLevel                       - Driver info level, since DRIVER_INFO_6
                                    is a super set of level 4, 3, and 2,
                                    the driver info structure is shared
    pDriverInfo6                  - Points to DRIVER_INFO_6 structure
    dwAddDrvFlags                 - Flags used to AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOffereReplacement            - Whether to offer a replacement driver
    pdwBlockingStatus             - Points to blocking status on server
    ppszReplacementDriver         - Points to the replacement driver

Return Value:

    An HRESULT                                 

--*/
HRESULT
PrintUpgRetry(
    IN     LPCTSTR          pszServer,              OPTIONAL
    IN     DWORD            dwLevel,    
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver && ((6 == dwLevel) || (dwLevel >= 2) && (dwLevel <= 4)) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppszReplacementDriver = NULL;
        hRetval = PrintUpgUI(pszServer,
                             pDriverInfo6,
                             bIsDriverPathFullPath,
                             bOfferReplacement,
                             pdwBlockingStatus,
                             ppszReplacementDriver);
        
        //
        //  There are 4 cases here:
        //  1. For warned driver and the user instructs to install it, try 
        //     AddPrinterDriverEx again with APD_INSTALL_WARNED_DRIVER.
        //  2. If the user wants to cancel, set the last error correctly and 
        //     abort.
        //  3. If the user wants to install the replacement driver, we will 
        //     set the error code correctly and do not install the replacement
        //     driver at this moment since we shall clean ourself up first.
        //  4. If other errors occur, we will just return the correct error 
        //     code.
        //
        //  For case 1, 2, 4, we do not return the replacement driver because
        //  I can not see any reason to do so.
        //
        if (FAILED(hRetval) || !(*pdwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))         // except case 3 
        {
            LocalFreeMem(*ppszReplacementDriver);
            *ppszReplacementDriver = NULL;
        }
        
        if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_PROCEEDED))      // case 1
        {
             dwAddDrvFlags |= APD_INSTALL_WARNED_DRIVER;

             hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                          dwLevel,
                                          reinterpret_cast<BYTE*>(pDriverInfo6),
                                          dwAddDrvFlags) ? ERROR_SUCCESS : GetLastErrorAsHResult();
        } 
        else if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_CANCELLED)) // case 2
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))  // case 3
        {
            hRetval = HResultFromWin32((*pdwBlockingStatus & BSP_PRINTER_DRIVER_BLOCKED) ? ERROR_PRINTER_DRIVER_BLOCKED : ERROR_PRINTER_DRIVER_WARNED);
        }
    }

    return hRetval;
}

/*++

Routine Name:

    PrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    pszServer                     - Remote machine that has the driver files
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOffereReplacement            - Whether to offer a replacement driver
    pdwBlockingStatus             - Points to blocking status on server
    ppszReplacementDriver         - Points to the replacement driver

Return Value:

    An HRESULT                                

--*/  
HRESULT
PrintUpgUI(
    IN     LPCTSTR          pszServer,              OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT  hRetval                  = E_FAIL;     
    DWORD    dwBlockingStatusOnClient = BSP_PRINTER_DRIVER_OK;
    
    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver ? S_OK : E_INVALIDARG;

    //
    // Take the replacement driver information from local client.
    //    
    if (SUCCEEDED(hRetval) && bOfferReplacement)
    {
        *ppszReplacementDriver = NULL;
        hRetval = IsDriverBadLocally(pszServer,
                                     pDriverInfo6,
                                     bIsDriverPathFullPath,
                                     &dwBlockingStatusOnClient,
                                     ppszReplacementDriver); 

        //
        // Get the replacement driver information
        //
        if (SUCCEEDED(hRetval))
        {
            *pdwBlockingStatus |= (dwBlockingStatusOnClient & ~BSP_BLOCKING_LEVEL_MASK); 
        }
   }
   
   //
   // Get the user's response
   //  
   if (SUCCEEDED(hRetval))
   {   
       *pdwBlockingStatus &= ~BSP_USER_RESPONSE_MASK;
       hRetval = InternalPrintUpgUI(pDriverInfo6->pName,
                                    pDriverInfo6->pDriverPath,        // main rendering driver dll
                                    pDriverInfo6->pEnvironment,
                                    pDriverInfo6->cVersion,  
                                    pdwBlockingStatus);
   }
           
   return hRetval;
}

/*++

Routine Name

    InfIsCompatibleDriver
        
Routine Description:

    Check whether the driver is blocked or warned and if the driver is blocked 
    or warned, return the blocking status and the replacement driver, if any.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path 
                            or the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    hInf                  - Handle to printupg inf
    puBlockingStatus      - Points to status of blocking
    ppszReplacementDriver - Points to the NULL terminating name of the replacement 
                            driver. A *NULL* string (instead of an empty string) 
                            means there is no replacement driver

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code. Pass a NULL to ppszReplacementDriver 
                           will not receive the name of replacement driver otherwise
                           Call PSetupFreeMem to free the received string pointed by
                           ppszReplacementDriver

--*/
BOOL
InfIsCompatibleDriver(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     HINF             hInf,       
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    )
{
    HRESULT  hRetval         = E_FAIL;
    UINT     uBlockingStatus = 0;      
    DWORD    dwMajorVersion  = 0;
    BOOL     bIsServer       = FALSE;
    TString  strReplacementDriver;
    FILETIME DriverFileTime;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && (hInf != INVALID_HANDLE_VALUE) && pdwBlockingStatus ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = 0;
        if (ppszReplacementDriver)
        {
            *ppszReplacementDriver = NULL;
        }

        hRetval = GetPrinterDriverVersion(pszDriverPath, &dwMajorVersion, NULL);
    }
        
    if (SUCCEEDED(hRetval))
    {
       hRetval = IsLocalMachineServer();
    }
    
    if (SUCCEEDED(hRetval))
    {   
        bIsServer = S_OK == hRetval ? TRUE : FALSE;

        hRetval = GetFileTimeByName(pszDriverPath, &DriverFileTime);
    }
            
    if (S_OK == hRetval)
    {
        hRetval = InternalCompatibleInfDriverCheck(pszDriverModel,
                                                   pszDriverPath,
                                                   pszEnvironment,
                                                   &DriverFileTime,
                                                   hInf,
                                                   dwMajorVersion,
                                                   bIsServer,
                                                   &uBlockingStatus,
                                                   &strReplacementDriver);

    }
                                             
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = uBlockingStatus;
        if ((BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) && ppszReplacementDriver && !strReplacementDriver.bEmpty())
        {
            *ppszReplacementDriver = AllocStr(strReplacementDriver);
            hRetval = ppszReplacementDriver ? S_OK : E_OUTOFMEMORY;
            
            if (SUCCEEDED(hRetval))
            {
                *pdwBlockingStatus |= BSP_INBOX_DRIVER_AVAILABLE;
            }
        }
    } 
          
    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));   
    return SUCCEEDED(hRetval);                                     
}

/*++

Routine Name:

    GetPrinterDriverVersion

Routine Description:

    Gets version information about an executable file. If the file is not an
    executable, it will return 0 for both major and minor version.

Arguments:

    pszFileName                 -   file name, this is either a full path for
                                    the file is under the path in  the search 
                                    sequence specified used the LoadLibrary 
                                    function. 
    pdwFileMajorVersion         -   pointer to major version
    pdwFileMinorVersion         -   pointer to minor version
    
Return Value:

    An HRESULT

--*/
HRESULT
GetPrinterDriverVersion(
    IN     LPCTSTR           pszFileName,               
       OUT DWORD             *pdwFileMajorVersion,           OPTIONAL
       OUT DWORD             *pdwFileMinorVersion            OPTIONAL
     )
{
    HRESULT           hRetval             = E_FAIL;
    DWORD             dwSize              = 0;
    UINT              uLen                = 0;
    BYTE              *pbBlock            = NULL;     
    VS_FIXEDFILEINFO  *pFileVersion       = NULL;  
    DWORD             dwHandle            = 0;

    hRetval = pszFileName && *pszFileName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        dwSize = GetFileVersionInfoSize(const_cast<LPTSTR>(pszFileName), &dwHandle );

        if (dwSize == 0)
        {
            hRetval = GetLastErrorAsHResult();
        }      
    }
   
    if (SUCCEEDED(hRetval))
    {
        pbBlock = new BYTE[dwSize];
        hRetval = pbBlock ? S_OK : E_OUTOFMEMORY;
    }
   
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileVersionInfo(const_cast<LPTSTR>(pszFileName), 0, dwSize, pbBlock) ? S_OK : GetLastErrorAsHResult();
    }
 
    //
    // VerQueryValue does not set last error.
    // 
    if (SUCCEEDED(hRetval))
    {
        hRetval = VerQueryValue(pbBlock, _T("\\"), reinterpret_cast<VOID **> (&pFileVersion), &uLen) && pFileVersion && uLen ? S_OK : E_INVALIDARG; 
    }
  
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetDriverVersionFromFileVersion(pFileVersion, pdwFileMajorVersion, pdwFileMinorVersion);
    }
     
    delete [] pbBlock;
    return hRetval;
} 

/*++

Routine Name:

    GetDriverVersionFromFileVersion

Routine Description:

    Gets driver info from a FileVersion structure.
    
Arguments:

    pFileVersion                -   Points to a file info structure 
    pdwFileMajorVersion         -   pointer to major version
    pdwFileMinorVersion         -   pointer to minor version
    
Return Value:

    An HRESULT

--*/ 
HRESULT    
GetDriverVersionFromFileVersion(
    IN     VS_FIXEDFILEINFO  *pFileVersion,
       OUT DWORD             *pdwFileMajorVersion,      OPTIONAL
       OUT DWORD             *pdwFileMinorVersion       OPTIONAL
    )
{
    HRESULT  hRetval = E_FAIL;
    
    hRetval = pFileVersion ? S_OK : E_INVALIDARG;
    
    //
    //  Return versions for drivers designed for Windows NT/Windows 2000,
    //  and marked as printer drivers.
    //  Hold for all dlls Pre-Daytona.
    //  After Daytona, printer driver writers must support
    //  version control or we'll dump them as Version 0 drivers.
    //            
    if (SUCCEEDED(hRetval))
    {
        if (pdwFileMajorVersion) 
        {
            *pdwFileMajorVersion = 0;
        }
    
        if (pdwFileMinorVersion) 
        {
            *pdwFileMinorVersion = 0;
        }

        if (VOS_NT_WINDOWS32 == pFileVersion->dwFileOS)
        {
            if ((VFT_DRV == pFileVersion->dwFileType) && (VFT2_DRV_VERSIONED_PRINTER == pFileVersion->dwFileSubtype))
            {
                if (pdwFileMajorVersion)
                {
                    *pdwFileMajorVersion = pFileVersion->dwFileVersionMS;       
                }            
                if (pdwFileMinorVersion)
                {
                    *pdwFileMinorVersion = pFileVersion->dwFileVersionLS;       
                }
            } 
            else if (pdwFileMajorVersion)
            {
                if (pFileVersion->dwProductVersionMS == pFileVersion->dwFileVersionMS) 
                {
                     *pdwFileMajorVersion = 0;
                }
                else
                {
                    *pdwFileMajorVersion = pFileVersion->dwFileVersionMS;
                }
            }
        }
    }
     
    return hRetval;
}

/*++

Routine Name:

    IsDriverBadLocally

Routine Description:

    This routine loads the file and gets the FILETIME of the driver and check 
    whether the driver is blokced or warned according the printupg.inf on the 
    local machine.
    
Arguments:

    pszServer                     - The server that has the driver files
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    dwAddDrvFlags                 - Flags used in AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    pdwBlockingStatus             - Points to blocking status of the driver     
    ppszReplacementDriver         - Points to the replacement driver   
    
Return Value:

    An HRESULT                

--*/
HRESULT
IsDriverBadLocally(
    IN     LPCTSTR          pszServer,            OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT  hRetval            = E_FAIL;
    DWORD    dwMajorVersion     = 0;
    FILETIME DriverFileTime;
    TString  strDriverFullPath;
    
    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {            
        hRetval = GetPrinterDriverPath(pszServer,
                                       pDriverInfo6->pDriverPath,
                                       pDriverInfo6->pEnvironment,
                                       bIsDriverPathFullPath,
                                       &strDriverFullPath);
    }
    
    if (SUCCEEDED(hRetval))
    {           
        hRetval = GetFileTimeByName(strDriverFullPath, &DriverFileTime);
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetPrinterDriverVersion(strDriverFullPath, &dwMajorVersion, NULL);
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = PSetupIsCompatibleDriver(NULL, 
                                           pDriverInfo6->pName, 
                                           pDriverInfo6->pDriverPath, 
                                           pDriverInfo6->pEnvironment, 
                                           dwMajorVersion, 
                                           &DriverFileTime, 
                                           pdwBlockingStatus,
                                           ppszReplacementDriver) ? S_OK : GetLastErrorAsHResult();
    }                                          
    
    if (FAILED(hRetval) && ppszReplacementDriver && *ppszReplacementDriver)
    {
        LocalFreeMem(*ppszReplacementDriver);
        *ppszReplacementDriver = NULL;
    }
    
    return hRetval;
}

/*++

Routine Name:

    InternalPrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    pszDriverModel                - The name of the driver to check
    pszDriverPath                 - The path of the driver, this can be a full path 
                                    or the filename
    pszEnvironment                - The environment of the server, such as 
                                    "Windows NT x86"
    dwVersion                     - The major version of the driver
    pdwBlockingStatus             - Points to blocking status on the client
    ppszReplacementDriver         - Points to the name of replacement driver
    
Return Value:

    An HRESULT                    - When this function is successful, user choose 
                                    either proceed to install warned driver or install 
                                    replacement driver. 

--*/
HRESULT
InternalPrintUpgUI(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     DWORD            dwVersion,   
    IN OUT DWORD            *pdwBlockingStatus         
    )
{
    DWORD            hRetval              = E_FAIL;
    HWND             hWndParent           = NULL;
    DWORD            dwStatusResponsed    = BSP_PRINTER_DRIVER_OK;
    
    hRetval  = pszDriverModel && pszDriverPath && pszEnvironment && pdwBlockingStatus ? S_OK : E_INVALIDARG;
        
    if (SUCCEEDED(hRetval) && (BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)))
    {      
        *pdwBlockingStatus &= ~BSP_USER_RESPONSE_MASK; 
        hWndParent = SUCCEEDED(GetCurrentThreadLastPopup(&hWndParent)) ? hWndParent : NULL;

        //
        // Ask the user what they want to do. If they don't want to proceed, 
        // then the error is what the would get from the localspl call.
        // 
        // PSetupShowBlockedDriverUI can not fail!
        //
        *pdwBlockingStatus |= (PSetupShowBlockedDriverUI(hWndParent, *pdwBlockingStatus) & BSP_USER_RESPONSE_MASK); 
    } 
        
    return hRetval;
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT
GetCurrentThreadLastPopup(
        OUT HWND    *phwnd
    )
{
    HWND hwndOwner, hwndParent;
    HRESULT hr = E_INVALIDARG;
    GUITHREADINFO ti = {0};

    if( phwnd )
    {
        hr = E_FAIL;
        *phwnd = NULL;

        ti.cbSize = sizeof(ti);
        if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
        {
            *phwnd = ti.hwndActive;
            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner window
            if( *phwnd)
            {
                *phwnd = GetLastActivePopup(*phwnd);
            }
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}

/*++

Routine Name

    GetPrinterDriverPath
    
Routine Description:

    Get the file full path of the driver.
    
Arguments:
    
    pszServer             - The server that needs to check for bad driver. If
                            pszServer is NULL, that means the local machine
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    bIsDriverpathFullPath - Whether pszDriverPath is the full path or just the
                            the file name of the driver
    pstrFull              - The full path of the driver

Return Value:

    An HRESULT

--*/
HRESULT
GetPrinterDriverPath(
    IN     LPCTSTR          pszServer,                OPTIONAL
    IN     LPCTSTR          pszDriverPath,
    IN     LPCTSTR          pszEnvironment,
    IN     BOOL             bIsDriverPathFullPath,
       OUT TString          *pstrFullPath
    )
{
    HRESULT hRetval         = E_FAIL;
    TCHAR   szDir[MAX_PATH] = {0};
    DWORD   dwNeeded        = 0;
    
    hRetval = pszEnvironment && *pszEnvironment && pszDriverPath && *pszDriverPath && pstrFullPath ? S_OK : E_INVALIDARG;
     
    if (SUCCEEDED(hRetval) && !bIsDriverPathFullPath)
    {      
        hRetval = GetPrinterDriverDirectory(const_cast<LPTSTR>(pszServer), // This API is designed wrongly.
                                            const_cast<LPTSTR>(pszEnvironment),
                                            1,                             // This value must be 1
                                            (LPBYTE)szDir,
                                            sizeof(szDir),
                                            &dwNeeded) ? S_OK : GetLastErrorAsHResult();
    }

    if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval)))
    {
        hRetval = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }
    
    //
    // Add 1 '\\' between driverpath and filename. Note if the path is too
    // long StrNCatBuff will truncate it and StrNCatBuff always NULL terminates
    // the buffer.
    //  
    if (SUCCEEDED(hRetval))
    {
        hRetval = HResultFromWin32(StrNCatBuff(szDir, COUNTOF(szDir), szDir, *szDir ? _T("\\") : _T(""), pszDriverPath, NULL));
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = pstrFullPath->bUpdate(szDir) ? S_OK : E_OUTOFMEMORY;
    }
    
    return hRetval;
}

/*++

Routine Name

    GetFileTimeByName
    
Routine Description:

    Get the file time of the file given a full path.
    
Arguments:
    
    pszPath               - Full path of the driver
    pFileTime             - Points to the file time
    
Return Value:

    An HRESULT

--*/
HRESULT
GetFileTimeByName(
    IN      LPCTSTR         pszPath,
       OUT  FILETIME        *pFileTime
    )
{
    HRESULT     hRetval     = E_FAIL;
    HANDLE      hFile       = INVALID_HANDLE_VALUE;

    hRetval = pszPath && *pszPath && pFileTime ? S_OK : E_INVALIDARG;
             
    if (SUCCEEDED(hRetval))
    {
        hFile = CreateFile(pszPath, 
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        hRetval = (INVALID_HANDLE_VALUE != hFile) ? S_OK : GetLastErrorAsHResult();
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileTime(hFile, NULL, NULL, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }   
    
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }           
    
    return hRetval;
}

/*++

Routine Name

    InternalCompatibleDriverCheck
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver
    is blocked or warned, return the replacement driver.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    pFileTimeDriver       - The FileTime of the driver
    pszPrintUpgInf        - The PrintUpg Inf filename
    uVersion              - The major version of the driver
    bIsServer             - Where the printing services runs on an NT Server SKU
    puBlockingStatus      - Points to status of blocking
    pstrReplacementDriver - The replacement driver.

Return Value:

    An HRESULT

--*/
HRESULT
InternalCompatibleDriverCheck(
    IN     LPCTSTR        pszDriverModel,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     FILETIME       *pFileTimeDriver,
    IN     LPCTSTR        pszPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus,
       OUT TString        *pstrReplacementDriver
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the InternalCompatibleDriverCheck routine\n")));

    HRESULT hRetval = E_FAIL;    
    HINF    hInf    = INVALID_HANDLE_VALUE;
    
    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pFileTimeDriver &&  pszPrintUpgInf && puBlockingStatus && pstrReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        *puBlockingStatus = 0;

        //
        // NOTICE-rorleth-2002/01/10: fixed bug 761840 by using flag INF_STYLE_CACHE_IGNORE
        // in case we're called from the spooler's context and printupg.pnf needs to be
        // created, the user's hive would not be unloaded on logoff as the cryptoapi
        // cache lives partially in the user's hive but the spooler is still running
        //
        hInf  = SetupOpenInfFile(pszPrintUpgInf, NULL, INF_STYLE_WIN4 | INF_STYLE_CACHE_IGNORE, NULL);
        hRetval = (INVALID_HANDLE_VALUE != hInf) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = InternalCompatibleInfDriverCheck(pszDriverModel,
                                                   pszDriverPath,
                                                   pszEnvironment,
                                                   pFileTimeDriver,
                                                   hInf,
                                                   uVersion,
                                                   bIsServer,
                                                   puBlockingStatus,
                                                   pstrReplacementDriver);
    }
    
    if (INVALID_HANDLE_VALUE != hInf)
    {
        SetupCloseInfFile(hInf);
    }
    
    return hRetval;
}

/*++

Routine Name

    InternalCompatibleInfDriverCheck
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver
    is blocked or warned, return the replacement driver.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    pFileTimeDriver       - The FileTime of the driver
    hPrintUpgInf          - The handle to the PrintUpg Inf file
    uVersion              - The major version of the driver
    bIsServer             - Where the printing services runs on an NT Server SKU
    puBlockingStatus      - Points to status of blocking
    pstrReplacementDriver - The replacement driver.

Return Value:

    An HRESULT

--*/
HRESULT
InternalCompatibleInfDriverCheck(
    IN     LPCTSTR        pszModelName,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     FILETIME       *pFileTimeDriver,
    IN     HINF           hPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus,
       OUT TString        *pstrReplacementDriver       OPTIONAL
    )
{
    HRESULT  hRetval           = E_FAIL;    
    HINF     hInf              = INVALID_HANDLE_VALUE;
    UINT     uWarnLevelSrv     = 0;
    UINT     uWarnLevelWks     = 0;

    hRetval = pszModelName && pszDriverPath && pszEnvironment && pFileTimeDriver && (INVALID_HANDLE_VALUE != hPrintUpgInf) && puBlockingStatus && pstrReplacementDriver? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = IsDriverDllInExcludedSection(pszDriverPath, hPrintUpgInf);
    }
    
    if (S_FALSE == hRetval)
    {
        hRetval = IsDriverInMappingSection(pszModelName,
                                           pszEnvironment,
                                           uVersion,
                                           hPrintUpgInf, 
                                           pFileTimeDriver,                                       
                                           &uWarnLevelSrv,
                                           &uWarnLevelWks,
                                           pstrReplacementDriver);

        if (S_OK == hRetval) 
        {
            hRetval = GetBlockingStatusByWksType(uWarnLevelSrv, uWarnLevelWks, bIsServer, puBlockingStatus);
        }
    }

    if (SUCCEEDED(hRetval)) 
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" Driverpath \"%s\" Environment \"%s\" Version %d WarnLevel Server %d WarnLevel Wks %d bIsServer %d *Blocking Status* 0X%X *Replacement Driver* \"%s\"\n"), pszModelName, pszDriverPath, pszEnvironment,uVersion, uWarnLevelSrv, uWarnLevelSrv, bIsServer, *puBlockingStatus, static_cast<LPCTSTR>(*pstrReplacementDriver)));
        hRetval = (BSP_PRINTER_DRIVER_OK == (*puBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) ? S_OK : S_FALSE;
    }

    return hRetval;
}

/*++

Routine Name

    IsDriverInMappingSection
    
Routine Description:

    Check whether the driver is mapped, aka a bad driver.
    
Arguments:
    
    pszDriverModel         - The name of the driver to check
    pszEnvironment         - The environment of the server, such as 
    uVersion               - The major version of the driver
    hPrintUpgInf           - The handle to the PrintUpg Inf file
    pFileTimeDriver        - Points to the file time of the driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver

Return Value:

    An HRESULT            - S_OK means the driver is a bad driver and is mapped to
                            some inbox driver, S_FALSE means the driver is not.

--*/
HRESULT
IsDriverInMappingSection(
    IN     LPCTSTR        pszModelName,
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
    IN     HINF           hPrintUpgInf,
    IN     FILETIME       *pFileTimeDriver,
       OUT UINT           *puWarnLevelSrv,
       OUT UINT           *puWarnLevelWks,
       OUT TString        *pstrReplacementDriver   
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the IsDriverInMappingSection routine\n")));

    HRESULT       hRetval        = E_FAIL;    
    UINT          uWarnLevelSrv  = 0;
    UINT          uWarnLevelWks  = 0;
    INFCONTEXT    InfContext;
    TString       strMappingSection;
    TString       strReplacementDriver;
    
    hRetval = pszModelName && pszEnvironment && (INVALID_HANDLE_VALUE != hPrintUpgInf) && pFileTimeDriver && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *puWarnLevelSrv = 0;
        *puWarnLevelWks = 0;
        hRetval = GetSectionName(pszEnvironment, uVersion, &strMappingSection); 
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf, strMappingSection, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();        
    }
       
    //
    // This code assumes that:
    //  
    //  There can be multiple lines for the same printer driver, but they
    //  are sorted in non-descreasing order by date, the last field of the 
    //  line. The fist line that has the date no older than the driver's
    //  date is used.
    //
    //  An interesting case would be like (since date is optional)
    //
    // "HP LaserJet 4"         = "HP LaserJet 4",       1, 2, "11/28/1999"
    // "HP LaserJet 4"         = "HP LaserJet 4",       2, 1
    //
    //  If a date is empty then the driver of all dates are blocked, hence
    //  an empty date means close to a very late date in the future.
    //
    for (;S_FALSE == hRetval;)
    {
        hRetval = IsDateInLineNoOlderThanDriverDate(&InfContext, pFileTimeDriver, &uWarnLevelSrv, &uWarnLevelWks, &strReplacementDriver);

        if (S_FALSE == hRetval)
        {
            hRetval = SetupFindNextMatchLine(&InfContext, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();
        }
    }
    
    //
    // ERROR_LINE_NOT_FOUND is an HRESULT!
    // 
    if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" is not mapped\n"), pszModelName));
        hRetval = S_FALSE;
    }
     
    if (S_OK == hRetval)
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" is mapped\n"), pszModelName));
        *puWarnLevelSrv = uWarnLevelSrv;
        *puWarnLevelWks = uWarnLevelWks;
        hRetval = pstrReplacementDriver->bUpdate(strReplacementDriver) ? S_OK : E_OUTOFMEMORY;
    }
    
    return hRetval;
}

/*++

Routine Name

    IsDateInLineNoOlderThanDriverDate
    
Routine Description:

    This routines process the current line of inf and determinate whether the 
    date in the line is not older than that of driver. 
    
Arguments:
    
    pInfContext            - Points to the current context of an INF
    pDriverFileTime        - File time of the actual driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver.
   
Return Value:

    An HRESULT            - S_OK means the date in the current line is no older
                            than that of the driver
--*/
HRESULT
IsDateInLineNoOlderThanDriverDate(
    IN     INFCONTEXT       *pInfContext,
    IN     FILETIME         *pDriverFileTime,
       OUT UINT             *puWarnLevelSrv,
       OUT UINT             *puWarnLevelWks,
       OUT TString          *pstrReplacementDriver
    )
{
    HRESULT  hRetval     = E_FAIL;
    INT      iWarnLevel = 0;
    FILETIME FileTimeInInf;
    
    hRetval = pInfContext && pDriverFileTime && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupGetIntField(pInfContext, kWarnLevelSrv, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval)) 
        {
            *puWarnLevelSrv = iWarnLevel;
            hRetval = SetupGetIntField(pInfContext, kWarnLevelWks, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();
        }
        
        if (SUCCEEDED(hRetval)) 
        {
            *puWarnLevelWks = iWarnLevel;
            hRetval = InfGetString(pInfContext, kReplacementDriver, pstrReplacementDriver);
        }

        if (SUCCEEDED(hRetval)) 
        {
            hRetval = InfGetStringAsFileTime(pInfContext, kFileTime, &FileTimeInInf);
        
            //
            //  Date field is optional.
            //
            if (FAILED(hRetval) && (ERROR_INVALID_PARAMETER == HRESULT_CODE(hRetval)))
            {
                DBG_MSG(DBG_TRACE, (_T("Date in inf is empty, drivers of all dates are blocked.\n")));
                hRetval = S_OK;
            } 
            else if (SUCCEEDED(hRetval))
            {
                hRetval = CompareFileTime(pDriverFileTime, &FileTimeInInf) <= 0 ? S_OK : S_FALSE ;
            }
        }
    }
    
    return hRetval;
}

/*++

Routine Name

    GetSectionName
    
Routine Description:

    Get the Section name in terms of environment and driver version.
    
Arguments:
    
    pszEnvironment         - The environment of the server, such as 
    uVersion               - The major version of the driver
    pstrSection            - Points the name of section of driver mapping

Return Value:

    An HRESULT            

--*/
HRESULT
GetSectionName(
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
       OUT TString        *pstrSection
    )
{
    HRESULT hRetval = E_FAIL;
    
    hRetval = pszEnvironment && pstrSection ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = pstrSection->bFormat(_T("%s_%s_%s %d"), cszPrintDriverMapping, pszEnvironment, cszVersion, uVersion); 
    }

    return hRetval;
}
 
/*++

Routine Name

    InfGetString
    
Routine Description:

    This routine is a wrapper to SetupGetStringField using TString.
    
Arguments:
    
    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pstrField              - Points to the string field as TString

Return Value:

    An HRESULT            

--*/
HRESULT
InfGetString(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT TString        *pstrField
    )
{
    HRESULT hRetval           = E_FAIL;
    TCHAR   szField[MAX_PATH] = {0};
    DWORD   dwNeeded          = 0;
    TCHAR   *pszField         = NULL;
    
    hRetval = pInfContext && pstrField ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupGetStringField(pInfContext,
                                      uFieldIndex,
                                      szField,
                                      COUNTOF(szField),
                                      &dwNeeded) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval)) 
        {
            hRetval = pstrField->bUpdate(szField) ? S_OK : E_OUTOFMEMORY;
        } 
        else if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval))) 
        {
            pszField = new TCHAR[dwNeeded];
            hRetval = pszField ? S_OK : E_OUTOFMEMORY;
            
            DBG_MSG(DBG_TRACE, (_T("Long string encountered\n")));

            if (SUCCEEDED(hRetval)) 
            {
                hRetval = SetupGetStringField(pInfContext,
                                              uFieldIndex,
                                              pszField,
                                              dwNeeded,
                                              &dwNeeded) ? S_OK : GetLastErrorAsHResult();
            }
        
            if (SUCCEEDED(hRetval)) 
            {
                hRetval = pstrField->bUpdate(pszField) ? S_OK : E_OUTOFMEMORY;
            }
        }
    }
    
    delete [] pszField;
    return hRetval;
}

/*++

Routine Name

    InfGetStringAsFileTime
    
Routine Description:

    This routine get the time of driver in printupg and converts it to FILETIME.
    
Arguments:
    
    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pFielTime              - Points to the FILETIME structure

Return Value:

    An HRESULT            

--*/
HRESULT
InfGetStringAsFileTime(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT hRetval = E_FAIL;
    TString strDate;

    hRetval = pInfContext && pFileTime ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = InfGetString(pInfContext, uFieldIndex, &strDate);
    }

    if (SUCCEEDED(hRetval)) 
    {
        DBG_MSG(DBG_TRACE, (_T("FileTime in INF as string \"%s\"\n"), static_cast<LPCTSTR>(strDate)));
        hRetval = StringTimeToFileTime(strDate, pFileTime);
    }
  
    return hRetval;
}

/*++

Routine Name

    StringTimeToFileTime
    
Routine Description:

    Converts a string of time in the form of "11/27/1999" to FILETIME.
    
Arguments:
 
    pszFileTime            - The file time as string such as "11/27/1999"
    pFileTime              - Points to the converted FILETIME

Return Value:

    An HRESULT            

--*/
HRESULT
StringTimeToFileTime(
    IN     LPCTSTR        pszFileTime,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT    hRetval = E_FAIL;
    SYSTEMTIME SystemTime;

    hRetval = pszFileTime && pFileTime ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        //
        // StringToDate should take pszFileTime as const.
        //
        hRetval = StringToDate(const_cast<LPTSTR>(pszFileTime), &SystemTime) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SystemTimeToFileTime(&SystemTime, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}

/*++

Routine Name

    GetBlockingStatusByWksType
    
Routine Description:

    Fill out the status of blocking according to the type of SKU that runs the
    service.
    
Arguments:
 
    uWarnLevelSrv          - The warn level for server SKU
    uWarnLevelSrv          - The warn level for wks SKU
    bIsServer              - Whether the SKU running printing service is server
    puBlockingStatus       - Points to the result as status of blocking

Return Value:

    An HRESULT            

--*/
HRESULT
GetBlockingStatusByWksType(
    IN     UINT           uWarnLevelSrv,
    IN     UINT           uWarnLevelWks,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus
    ) 
{
    HRESULT hRetval    = E_FAIL;
    UINT    uWarnLevel = 0;

    hRetval = puBlockingStatus ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *puBlockingStatus &= ~BSP_BLOCKING_LEVEL_MASK;
        *puBlockingStatus |= BSP_PRINTER_DRIVER_OK;

        uWarnLevel = bIsServer ? uWarnLevelSrv : uWarnLevelWks;

        switch (uWarnLevel)
        {
        case kBlocked:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_BLOCKED;
            break;
        case kWarned:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_WARNED;
            break;
            
        default: 
            hRetval = E_FAIL;
            break;
        }
    }

    return hRetval;
}

/*++

Routine Name

    IsDriverDllInExcludedSection
    
Routine Description:

    Determine Whether the driver dll name is in the excluded section of printupg.
    
Arguments:

     pszDriverPath       - The path of the driver and this can be a full path or
                           the file name
     hPrintUpgInf        - The handle to printupg INF file

Return Value:

    An HRESULT           - S_OK means the driver dll is in the excluded section,
                           S_FALSE means it is not. 

--*/
HRESULT
IsDriverDllInExcludedSection(
    IN     LPCTSTR        pszDriverPath,
    IN     HINF           hPrintUpgInf
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the IsDriverDllInExcludedSection routine\n")));

    HRESULT    hRetval = E_FAIL;
    TString    strDriverFileName;
    INFCONTEXT InfContext;

    hRetval = pszDriverPath && (INVALID_HANDLE_VALUE != hPrintUpgInf) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = strDriverFileName.bUpdate(FileNamePart(pszDriverPath)) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval) && !strDriverFileName.bEmpty()) 
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf, 
                                     cszExcludeSection, 
                                     strDriverFileName,
                                     &InfContext) ? S_OK : GetLastErrorAsHResult();

        //
        // ERROR_LINE_NOT_FOUND is an HRESULT!
        // 
        if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
        {
            hRetval = S_FALSE;
        }

        DBG_MSG(DBG_TRACE, (_T("Driver Path %s driver dll %s excluded section \"%s\" Is not excluded? %d\n"), pszDriverPath, static_cast<LPCTSTR>(strDriverFileName), cszExcludeSection, hRetval));
    }
    
    return hRetval;
}

/*++

Routine Name

    IsLocalMachineServer
    
Routine Description:

    This routine determines whether the local machine is a server SKU.
    
Arguments:

     None

Return Value:

    An HRESULT            - S_OK if it is a server, S_FALSE otherwise.          

--*/
HRESULT
IsLocalMachineServer(
    VOID
    )
{
    HRESULT         hRetval          = E_FAIL;
    DWORDLONG       dwlConditionMask = 0;
    OSVERSIONINFOEX OsVerEx;
    
    (VOID)ZeroMemory(&OsVerEx, sizeof(OSVERSIONINFOEX));
    OsVerEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    
    OsVerEx.wProductType = VER_NT_SERVER;
    VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );

    hRetval = VerifyVersionInfo(&OsVerEx, VER_PRODUCT_TYPE, dwlConditionMask) ? S_OK : GetLastErrorAsHResult();
   
    if (FAILED(hRetval) && (ERROR_OLD_WIN_VERSION == HRESULT_CODE(hRetval)))
    {
       hRetval = S_FALSE;
    }
    
    return hRetval;
}
#if DBG_PRINTUPG

LPTSTR
ReadDigit(
    LPTSTR  ptr,
    LPWORD  pW
    )
{
    TCHAR   c;
    //
    // Skip spaces
    //
    while ( !iswdigit(c = *ptr) && c != TEXT('\0') )
        ++ptr;

    if ( c == TEXT('\0') )
        return NULL;

    //
    // Read field
    //
    for ( *pW = 0 ; iswdigit(c = *ptr) ; ++ptr )
        *pW = *pW * 10 + c - TEXT('0');

    return ptr;
}

BOOL
StringToDate(
    LPTSTR          pszDate,
    SYSTEMTIME     *pInfTime
    )
{
    BOOL    bRet = FALSE;

    ZeroMemory(pInfTime, sizeof(*pInfTime));

    bRet = (pszDate = ReadDigit(pszDate, &(pInfTime->wMonth)))      &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wDay)))        &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wYear)));

    //
    // Y2K compatible check
    //
    if ( bRet && pInfTime->wYear < 100 ) {

        if ( pInfTime->wYear < 10 )
            pInfTime->wYear += 2000;
        else
            pInfTime->wYear += 1900;
    }

    return bRet;
}


LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    )
{
    LPTSTR pszSlash, pszTemp;

    if ( !pszFullName )
        return NULL;

    //
    // First find the : for the drive
    //
    if ( pszTemp = lstrchr(pszFullName, TEXT(':')) )
        pszFullName = pszFullName + 1;

    for ( pszTemp = (LPTSTR)pszFullName ;
          pszSlash = lstrchr(pszTemp, TEXT('\\')) ;
          pszTemp = pszSlash + 1 )
    ;

    return *pszTemp ? pszTemp : NULL;

}

PVOID
LocalAllocMem(
    IN UINT cbSize
    )
{
    return LocalAlloc( LPTR, cbSize );
}

VOID
LocalFreeMem(
    IN PVOID p
    )
{
    LocalFree(p);
}

//
// For some reason these are needed by spllib when you use StrNCatBuf.
// This doesn't make any sense, but just implement them.
//
extern "C"
LPVOID
DllAllocSplMem(
    DWORD cbSize
)
{
    return LocalAllocMem(cbSize);
}

HRESULT
TestPrintUpgOne(
    IN     LPCTSTR        pszDriverModel,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     LPCTSTR        pszDriverTime,
    IN     LPCTSTR        pszPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
    IN     UINT           uBlockingStatusInput,
    IN     LPCTSTR        pszReplacementDriver,
    IN     BOOL           bSuccess
    )
{
    HRESULT  hRetval         = E_FAIL;
    UINT     uBlockingStatus = 0;
    TString  strReplacementDriver;
    FILETIME FileTimeDriver;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pszDriverTime && pszPrintUpgInf &&  pszReplacementDriver ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = StringTimeToFileTime(pszDriverTime, &FileTimeDriver);
    }

    //if (SUCCEEDED(hRetval)) 
    //{
    //    hRetval = IsEnvironmentAndVersionNeededToCheck(pszEnvironment, uVersion);
    //}

    //if (S_OK == hRetval) 
    if (SUCCEEDED(hRetval))
    {
        DBG_MSG(DBG_TRACE, (_T("TEST case: Driver of time %s Expected status %d Expected Replacement \"%s\"\n"), pszDriverTime, uBlockingStatusInput, pszReplacementDriver));

        hRetval = InternalCompatibleDriverCheck(pszDriverModel,
                                                pszDriverPath,
                                                pszEnvironment,
                                                &FileTimeDriver,
                                                pszPrintUpgInf,
                                                uVersion,
                                                bIsServer,
                                                &uBlockingStatus,
                                                &strReplacementDriver);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = ((uBlockingStatusInput & BSP_BLOCKING_LEVEL_MASK) == (uBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) ? S_OK : S_FALSE;
    }

    if ((S_OK == hRetval) && (BSP_PRINTER_DRIVER_OK != (uBlockingStatus & BSP_BLOCKING_LEVEL_MASK))) 
    {
        hRetval = !lstrcmp(pszReplacementDriver, strReplacementDriver) ? S_OK : S_FALSE;
        
        //
        //  we can not test whether BSP_INBOX_DRIVER_AVAILABLE is set
        //
        //if((S_OK == hRetval) && pszReplacemtDriver && *ppszReplacementDriver)
        //{
        //    hRetval = (BSP_INBOX_DRIVER_AVAILABLE & uBlockingStatus) ? S_OK : S_FALSE; 
        //}
    }

    if (SUCCEEDED(hRetval))
    {   
        hRetval = (((S_FALSE == hRetval) && !bSuccess) || (S_OK == hRetval) && bSuccess) ? S_OK : E_FAIL;
    }
 
    return hRetval;
}

TCHAR szModel1[] = _T("HP LaserJet 4");
TCHAR szModel2[] = _T("HP LaserJet 4P");
TCHAR szModel3[] = _T("");
TCHAR szModel4[] = _T("HP LaserJet 4M Plus");
TCHAR szModel5[] = _T("HP LaserJet 4Si");
TCHAR szModel6[] = _T("HP LaserJet 4PPP");
TCHAR szModel7[] = _T("Lexmark Optra T612");
TCHAR szModel8[] = _T("HP LaserJet 4V");
TCHAR szModel9[] = _T("Apple LaserJet 400PS");
TCHAR szModel0[] = _T("HP Laserjet 4Si mx");

TCHAR szDriverPath1[] = _T("H:\\WINDOWS\\system32\\spool\\drivers\\w32x86\\3\\ps5ui.dll");
TCHAR szDriverPath2[] = _T("pscript5.dll");
TCHAR szDriverPath3[] = _T("H:\\WINDOWS\\system32\\spool\\drivers\\w32x86\\3\\ps5ui.dll");
TCHAR szDriverPath4[] = _T("psCrIpt5.dll");
TCHAR szDriverPath5[] = _T("ps5ui.dll");

TCHAR szEnvironment1[] = _T("Windows NT x86");
TCHAR szEnvironment2[] = _T("Windows 4.0");
TCHAR szEnvironment3[] = _T("Windows IA64");
TCHAR szEnvironment4[] = _T("Windows XP");

TCHAR szDriverTime1[] = _T("11/27/1999");
TCHAR szDriverTime2[] = _T("11/27/2999");
TCHAR szDriverTime3[] = _T("11/27/2001");
TCHAR szDriverTime4[] = _T("10/27/1999");
TCHAR szDriverTime5[] = _T("11/28/1998");
TCHAR szDriverTime6[] = _T("11/28/1999");
TCHAR szDriverTime7[] = _T("10/28/1999");

DWORD dwStatus1 = BSP_PRINTER_DRIVER_OK;
DWORD dwStatus2 = BSP_PRINTER_DRIVER_WARNED;
DWORD dwStatus3 = BSP_PRINTER_DRIVER_BLOCKED;

TCHAR cszUpgradeInf[] = _T("printupg.inf");
TCHAR cszPrintDriverMapping[] = _T("Printer Driver Mapping");
TCHAR cszVersion[] = _T("Version");
TCHAR cszExcludeSection[] = _T("Excluded Driver Files");
TCHAR cszPrintUpgInf[] = _T("\\\\lzhu0\\zdrive\\sdroot\\printscan\\print\\spooler\\test\\printupg\\printupg.inf");

HRESULT
TestPrintUpgAll(
    VOID
    )
{
    HRESULT hRetval = S_OK;

    const struct PrintUpgTest aPrintUpgTests [] =
    {
        //
        // model    driverPath     environment   drivertime    ver isServer status   replacement isSuccess
        //
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime4, 2, TRUE,  dwStatus2, szModel1, TRUE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel1, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel1, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus1, szModel1, TRUE},

        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel6, TRUE}, 
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel6, TRUE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel6, TRUE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel1, TRUE},

        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel1, FALSE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel1, FALSE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel1, FALSE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus3, szModel1, FALSE},

        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel1, FALSE}, 
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel6, FALSE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus1, szModel6, FALSE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel1, FALSE},

        //
        // case 16 is next
        //
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel3, TRUE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus1, szModel3, TRUE},

        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel3, TRUE}, 
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel3, TRUE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},

        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel7, FALSE}, 
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel7, FALSE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel7, FALSE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus3, szModel7, FALSE},

        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel7, FALSE}, 
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus3, szModel8, FALSE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus1, szModel8, FALSE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel7, FALSE},

        //
        // case 32 is next
        // 
        {szModel4, szDriverPath2, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel4, FALSE},
        {szModel4, szDriverPath5, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel4, FALSE},
        {szModel4, szDriverPath5, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath4, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus1, szModel7, TRUE},

        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus3, szModel4, TRUE}, 
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus2, szModel4, TRUE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel4, TRUE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus1, szModel4, TRUE},

        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus3, szModel4, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus3, szModel4, FALSE},

        {szModel0, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus2, szModel3, TRUE},
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus1, szModel3, TRUE},

        //
        // case 48 is next
        //
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus2, szModel8, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel2, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus1, szModel8, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus1, szModel8, TRUE},

        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel8, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus3, szModel8, FALSE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus2, szModel8, FALSE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus3, szModel8, FALSE},

        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel3, TRUE},
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus1, szModel3, TRUE},

        {szModel5, szDriverPath1, szEnvironment2, szDriverTime1, 3, TRUE,  dwStatus1, szModel3, TRUE}, 
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 1, FALSE, dwStatus2, szModel3, FALSE},
        {szModel9, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel9, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus2, szModel3, FALSE},

        //
        // case 64 is next
        //
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 2, TRUE,  dwStatus3, szModel8, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel2, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime5, 2, TRUE,  dwStatus3, szModel1, TRUE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime6, 2, TRUE,  dwStatus2, szModel1, TRUE}, 
        
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime7, 2, TRUE,  dwStatus2, szModel1, TRUE},
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus2, szModel3, TRUE},  
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus3, szModel3, TRUE}, 
        {szModel2, szDriverPath1, szEnvironment4, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 4, FALSE, dwStatus1, szModel3, TRUE},
    };

    DBG_MSG(DBG_TRACE, (L"tests started\n"));

    for (int i = 0; SUCCEEDED(hRetval) && i < COUNTOF(aPrintUpgTests); i++)
    {
        DBG_MSG(DBG_TRACE, (_T("************************ %d **********************\n"), i));
        hRetval = TestPrintUpgOne(aPrintUpgTests[i].pszDriverModel,
                                  aPrintUpgTests[i].pszDriverPath,
                                  aPrintUpgTests[i].pszEnvironment,
                                  aPrintUpgTests[i].pszDriverTime,
                                  cszPrintUpgInf,
                                  aPrintUpgTests[i].uVersion,
                                  aPrintUpgTests[i].bIsServer,
                                  aPrintUpgTests[i].uBlockingStatus,
                                  aPrintUpgTests[i].pszReplacementDriver,
                                  aPrintUpgTests[i].bSuccess);
    }

    DBG_MSG(DBG_TRACE, (L"tests ended\n"));

    return hRetval;
}

#endif // DBG_PRINTUPG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\splsetup\ntprint.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Ntprint.c

Abstract:

    Ntprint.dll main functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"
#include "splcom.h"
#include "regstr.h"

HINSTANCE   ghInst;
DWORD       dwThisMajorVersion  =   3;

PCODEDOWNLOADINFO   gpCodeDownLoadInfo = NULL;

HANDLE      hPrintui = NULL;
DWORD       (*dwfnPnPInterface)(
                IN EPnPFunctionCode Function,
                IN TParameterBlock  *pParameterBlock
                )   = NULL;

TCHAR   cszPortName[]                   = TEXT("PortName");
TCHAR   cszPnPKey[]                     = TEXT("PnPData");
TCHAR   cszDeviceInstanceId[]           = TEXT("DeviceInstanceId");
TCHAR   cszHardwareID[]                 = TEXT("HardwareID");
TCHAR   cszManufacturer[]               = TEXT("Manufacturer");
TCHAR   cszOEMUrl[]                     = TEXT("OEM URL");
TCHAR   cszProcessAlways[]              = TEXT(".ProcessPerPnpInstance");
TCHAR   cszRunDll32[]                   = TEXT("rundll32.exe");
TCHAR   cszBestDriverInbox[]            = TEXT("InstallInboxDriver");

const   DWORD dwFourMinutes             = 240000;

OSVERSIONINFO       OsVersionInfo;
LCID                lcid;

#define MAX_PRINTER_NAME    MAX_PATH

MODULE_DEBUG_INIT(DBG_WARN|DBG_ERROR, DBG_ERROR);

BOOL 
DllMain(
    IN HINSTANCE  hInst,
    IN DWORD      dwReason,
    IN LPVOID     lpRes   
    )
/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:

            ghInst              = hInst;

            if( !bSplLibInit(NULL))
            {
                DBGMSG( DBG_WARN,
                      ( "DllEntryPoint: Failed to init SplLib %d\n", GetLastError( )));

                return FALSE;
            }

            DisableThreadLibraryCalls(hInst);
            OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

            if ( !GetVersionEx(&OsVersionInfo) )
                return FALSE;
            lcid = GetUserDefaultLCID();

            InitializeCriticalSection(&CDMCritSect);
            InitializeCriticalSection(&SkipCritSect);

            if(IsInWow64())
            {
                //
                // 32-bit code running on Win64 -> set platform appropriately
                //
                MyPlatform = PlatformIA64;
            }

            break;

        case DLL_PROCESS_DETACH:
            if ( hPrintui )
                FreeLibrary(hPrintui);

            DeleteCriticalSection(&CDMCritSect);
            // Cleanup and CDM Context  created by windows update.
            DestroyCodedownload( gpCodeDownLoadInfo );
            gpCodeDownLoadInfo = NULL;
            //
            // We call DeleteCriticalSection(&SkipCritSect) from here
            //
            CleanupSkipDir();
            vSplLibFree();
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL
LoadAndInitializePrintui(
    VOID
    )
/*++

Routine Description:
    Check the refcount on printui, load it on 0 and increment the refcount.

Arguments:
    None

Return Value:
    TRUE on success, FALSE on error

--*/
{
    LPTSTR   szDll = TEXT("printui.dll");

    if ( hPrintui ) {

        return TRUE;
    }

    if ( hPrintui = LoadLibraryUsingFullPath(szDll) ) {

        if ( (FARPROC)dwfnPnPInterface = GetProcAddress(hPrintui,
                                                        "PnPInterface") ) {

            return TRUE;
        } else {

            FreeLibrary(hPrintui);
            hPrintui = NULL;
        }
    }

    return FALSE;
}

BOOL
PSetupAssociateICMProfiles(
    IN  LPCTSTR     pszzICMFiles,
    IN  LPCTSTR     pszPrinterName
    )
/*++

Routine Description:
    Install ICM color profiles for a printer driver and associate it with
    the printer name given

Arguments:
    pszzICMFiles    : Multi-sz field giving ICM profile names
    pszPrinterName  : Printer name

Return Value:
    None

--*/
{
    TCHAR   szDir[MAX_PATH], *p;
    DWORD   dwSize, dwNeeded;

    dwSize      = SIZECHARS(szDir);
    dwNeeded    = sizeof(szDir);

    if( !pszzICMFiles || !pszPrinterName)
    {
        return FALSE;
    }

    if ( !GetColorDirectory(NULL, szDir, &dwNeeded) )
        return FALSE;

    dwNeeded           /= sizeof(TCHAR);
    szDir[dwNeeded-1]   = TEXT('\\');

    //
    // Install and assoicate each profiles from the multi-sz field
    //
    for ( p = (LPTSTR)pszzICMFiles; *p ; p += lstrlen(p) + 1 ) {

        if ( dwNeeded + lstrlen(p) + 1 > dwSize ) {

            ASSERT(dwNeeded + lstrlen(p) + 1 <= dwSize);
            continue;
        }

        StringCchCopy(szDir + dwNeeded, COUNTOF(szDir) - dwNeeded, p);
        //
        // We do not need the right server name here since ICM should send it
        // to the right server
        //
        if ( !AssociateColorProfileWithDevice(NULL, szDir, pszPrinterName) )
            return FALSE;
    }

    return TRUE;
}


DWORD
GetPlugAndPlayInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
/*++

Routine Description:
    Get necessary PnP info LPT enumerator would have setup in the config
    manager registry

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer
    pLocalData      : Gives installation data

Return Value:
    TRUE on success, FALSE else.

--*/
{
    HKEY        hKey = NULL;
    TCHAR       buf[MAX_PATH];
    DWORD       dwType, dwSize, dwReturn;
    PNP_INFO    PnPInfo;

    if(!pDevInfoData || !pLocalData)
    {
        return ERROR_INVALID_PARAMETER;
    }    
    
    ASSERT( !(pLocalData->Flags & VALID_PNP_INFO) );

    ZeroMemory(&PnPInfo, sizeof(PnPInfo));

    //
    // Look in the devnode for the printer created to get the port name and
    // the device instance id
    //
    if ( dwReturn = CM_Open_DevNode_Key(pDevInfoData->DevInst, KEY_READ, 0,
                                        RegDisposition_OpenExisting, &hKey,
                                        CM_REGISTRY_HARDWARE) )
        goto Cleanup;

    dwSize = sizeof(buf);

    if ( dwReturn = RegQueryValueEx(hKey, cszPortName, NULL, &dwType,
                                    (LPBYTE)&buf, &dwSize) ) {

        if ( dwReturn == ERROR_FILE_NOT_FOUND )
            dwReturn = ERROR_UNKNOWN_PORT;
        goto Cleanup;
    }

    buf[COUNTOF(buf)-1] = TEXT('\0');

    if ( !(PnPInfo.pszPortName = AllocStr(buf)) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

    //
    // This can't be bigger than MAX_DEVICE_ID_LEN so it is ok
    //
    if ( !SetupDiGetDeviceInstanceId(hDevInfo,
                                     pDevInfoData,
                                     buf,
                                     SIZECHARS(buf),
                                     NULL) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

    buf[COUNTOF(buf)-1] = TEXT('\0');

    if ( !(PnPInfo.pszDeviceInstanceId =  AllocStr(buf)) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if ( dwReturn == ERROR_SUCCESS ) {

        CopyMemory(&pLocalData->PnPInfo, &PnPInfo, sizeof(PnPInfo));
        pLocalData->Flags   |= VALID_PNP_INFO;
    } else {

        FreeStructurePointers((LPBYTE)&PnPInfo, PnPInfoOffsets, FALSE);
    }

    if ( hKey )
        RegCloseKey(hKey);

    return dwReturn;
}


BOOL
PrinterGoingToPort(
    IN  LPPRINTER_INFO_2    pPrinterInfo2,
    IN  LPCTSTR             pszPortName
    )
/*++

Routine Description:
    Find out if a printer is going to a port (it may go to other ports also)

Arguments:
    pPrinterInfo2   : Gives the PRINTER_INFO_2 for the print queue
    pszPortName     : The port name

Return Value:
    If the print queue is going to the port TRUE, else FALSE

--*/
{
    LPTSTR  pszStr1, pszStr2;

    if (!pPrinterInfo2 || !pszPortName)
    {
        return FALSE;
    }

    pszStr1 = pPrinterInfo2->pPortName;

    //
    // Port names are returned comma separated by spooler; and there are blanks
    //
    while ( pszStr2 = lstrchr(pszStr1, sComma) ) {
        //
        // ISSUE-2002/03/08-mikaelho
        // Should we reset the '\0's to ',' in this function so we do not
        // alter the PRINTER_INFO_2 structure passed in? Check how NewDriverForInstalledDevice
        // uses this function.
        //
         *pszStr2 = sZero;
        ++pszStr2;

        if ( !lstrcmpi(pszPortName, pszStr1) )
            return TRUE;
        pszStr1 = pszStr2;

        //
        // Skip spaces
        //
        while ( *pszStr1 == TEXT(' ') )
            ++pszStr1;
    }

    if ( !lstrcmpi(pszPortName, pszStr1) )
        return TRUE;

    return FALSE;
}


BOOL
SetPnPInfoForPrinter(
    IN  HANDLE      hPrinter,
    IN  LPCTSTR     pszDeviceInstanceId,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszOEMUrl
    )
/*++

Routine Description:
    Set registry values in the PnPInfo subkey

Arguments:
    hPrinter            : Printer handle
    pszDeviceInstanceId : DeviceInstance Id
    pszHardwareID       : Device PnP or Compat Id
    pszManufacturer     : Manufacturer (from the inf)
    pszOEMUrl           : Manufacturer URL (from the inf)

Return Value:
    TRUE on success, FALSE else.

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;

    if ( pszDeviceInstanceId && *pszDeviceInstanceId)
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszDeviceInstanceId,
                                       REG_SZ,
                                       (LPBYTE)pszDeviceInstanceId,
                                       (lstrlen(pszDeviceInstanceId) + 1)
                                                * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszHardwareID && *pszHardwareID )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszHardwareID,
                                       REG_SZ,
                                       (LPBYTE)pszHardwareID,
                                       (lstrlen(pszHardwareID) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszManufacturer && *pszManufacturer )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszManufacturer,
                                       REG_SZ,
                                       (LPBYTE)pszManufacturer,
                                       (lstrlen(pszManufacturer) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszOEMUrl && *pszOEMUrl )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszOEMUrl,
                                       REG_SZ,
                                       (LPBYTE)pszOEMUrl,
                                       (lstrlen(pszOEMUrl) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


BOOL
PrinterInfo2s(
    OUT LPPRINTER_INFO_2   *ppPI2,
    OUT LPDWORD             pdwReturned
    )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_2s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPI2       : Points to PRINTER_INFO_2s on return
    pdwReturned : Tells how many PRINTER_INFO_2s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL    bRet = FALSE;
    DWORD   dwNeeded = 0x1000;
    LPBYTE  pBuf;

    if ( !(pBuf = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       pdwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            goto Cleanup;

        LocalFreeMem(pBuf);
        if ( !(pBuf = LocalAllocMem(dwNeeded))   ||
             !EnumPrinters(PRINTER_ENUM_LOCAL,
                           NULL,
                           2,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           pdwReturned) ) {

            goto Cleanup;
        }
   }

   bRet = TRUE;

Cleanup:

    if ( bRet ) {

        *ppPI2 = (LPPRINTER_INFO_2)pBuf;
    } else {

        if ( pBuf )
            LocalFreeMem(pBuf);

        *ppPI2 = NULL;
        *pdwReturned = 0;
    }

    return bRet;
}


BOOL
DuplicateDevice(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
/*++

Routine Description:
    Find out if a PnP reported printer is already installed

Arguments:
    pLocalData  : Gives installation data

Return Value:
    If the printer is already install TRUE, else FALSE

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    LPPRINTER_INFO_2    p = NULL, pPrinterInfo2;
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded;
    HANDLE              hPrinter;
    LPTSTR              pszDriverName = pLocalData->DrvInfo.pszModelName,
                        pszPortName = pLocalData->PnPInfo.pszPortName;

    ASSERT( (pLocalData->Flags & VALID_PNP_INFO)    &&
            (pLocalData->Flags & VALID_INF_INFO) );

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Cleanup;

    //
    // If there is a local printer using the same driver and going to the
    // same port then it is a duplicate
    //
    for ( dwNeeded = 0, pPrinterInfo2 = p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, pPrinterInfo2++ ) {

        if ( !lstrcmpi(pszDriverName, pPrinterInfo2->pDriverName) &&
             PrinterGoingToPort(pPrinterInfo2, pszPortName) )
            break; // for loop
    }

    if ( dwNeeded == dwReturned )
        goto Cleanup;

    bReturn = TRUE;

    if ( bReturn ) {

        if ( OpenPrinter(pPrinterInfo2->pPrinterName,
                         &hPrinter,
                         &PrinterDefault) ) {

            //
            // If it fails can't help
            //
            (VOID)SetPnPInfoForPrinter(hPrinter,
                                       pLocalData->PnPInfo.pszDeviceInstanceId,
                                       pLocalData->DrvInfo.pszHardwareID,
                                       pLocalData->DrvInfo.pszManufacturer,
                                       pLocalData->DrvInfo.pszOEMUrl);

            ClosePrinter(hPrinter);
        }
    }

Cleanup:
    LocalFreeMem(p);

    return bReturn;
}


BOOL
PrinterPnPDataSame(
    IN LPTSTR pszDeviceInstanceId,
    IN LPTSTR pszPrinterName
)
/*

Routine Description:
    Find out if a PnP printer has been installed with different driver name.
    We need to associate the queue previously used with this new driver as
    pnp says it's the new best driver for the device.

Arguments:
    pszDeviceInstanceId  : Gives the device ID instance string of the pnped device.
    pszPrinterName       : The name of the printer to compare the device instance ID to.

Return Value:
    If printer's pnp data holds the same device instance ID as the passed ID returns TRUE, else FALSE.

*/
{
    BOOL              bRet           = FALSE;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    HANDLE            hPrinter;
    DWORD             dwNeeded, dwType;
    TCHAR             szPrnId[MAX_DEVICE_ID_LEN];

    if( pszPrinterName && pszDeviceInstanceId ) {

        if ( OpenPrinter(pszPrinterName,
                         &hPrinter,
                         &PrinterDefault) ) {

            if ( ERROR_SUCCESS == GetPrinterDataEx(hPrinter,
                                                   cszPnPKey,
                                                   cszDeviceInstanceId,
                                                   &dwType,
                                                   (LPBYTE)szPrnId,
                                                   sizeof(szPrnId),
                                                   &dwNeeded)           &&
                 (dwType == REG_SZ)                                     &&
                 !lstrcmp(szPrnId, pszDeviceInstanceId) ) {

                bRet = TRUE;
            }

            ClosePrinter(hPrinter);
        }
    }

    return bRet;
}


BOOL
NewDriverForInstalledDevice(
    IN     PPSETUP_LOCAL_DATA  pLocalData,
    OUT    LPTSTR              pszPrinterName
    )
/*++

Routine Description:
    Find out if a PnP printer has been installed with different driver name.
    We need to associate the queue previously used with this new driver as
    pnp says it's the new best driver for the device.

Arguments:
    pLocalData     : Gives installation data
    pszPrinterName : Gives the printer name to return and use.
                     Must be at least MAX_PRINTER_NAME TCHARs in size

Return Value:
    If a printer is already installed which uses another driver TRUE, else FALSE

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    LPPRINTER_INFO_2    p = NULL, pPrinterInfo2;
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded;
    HANDLE              hPrinter;
    LPTSTR              pszPortName = pLocalData->PnPInfo.pszPortName;
    LPTSTR              pszDeviceInstanceId = pLocalData->PnPInfo.pszDeviceInstanceId;

    ASSERT( (pLocalData->Flags & VALID_PNP_INFO)    &&
            (pLocalData->Flags & VALID_INF_INFO) );

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Cleanup;

    //
    // If there is a printer going to that same port and with the same pnp
    // info, then it has been reinstalled with a newer driver.
    //
    for ( dwNeeded = 0, pPrinterInfo2 = p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, pPrinterInfo2++ ) {

        if ( PrinterGoingToPort(pPrinterInfo2, pszPortName) &&
            PrinterPnPDataSame(pszDeviceInstanceId, pPrinterInfo2->pPrinterName) ) {

            break; // for loop
        }
    }

    if ( dwNeeded == dwReturned ) {
        //
        // We didn't find anything...
        //
        goto Cleanup;
    }

    if ( OpenPrinter(pPrinterInfo2->pPrinterName,
                     &hPrinter,
                     &PrinterDefault) ) {

        pPrinterInfo2->pDriverName     = pLocalData->DrvInfo.pszModelName;
        pPrinterInfo2->pPrintProcessor = pLocalData->InfInfo.pszPrintProc;

        //
        // ISSUE-2002/03/08-mikaelho
        // Should we set the port name in the pPrinterInfo2 structure to pszPortName?
        // Check comment in PrinterGoingToPort. Seems like we will now only
        // use the first of the ports associated with the print queue.
        // 
        if( SetPrinter( hPrinter, 2, (LPBYTE)pPrinterInfo2, 0 ) ) {

            StringCchCopy( pszPrinterName, MAX_PRINTER_NAME, pPrinterInfo2->pPrinterName );
            bReturn = TRUE;
        }

        ClosePrinter(hPrinter);
    }

Cleanup:
    if( p ) {

        LocalFreeMem(p);
    }

    return bReturn;
}


VOID
CallVendorDll(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    )
/*++

Routine Description:
    A VendorSetup was specified in the INF. Call the dll with the name of the
    printer just created

Arguments:
    pLocalData      : Gives installation data
    pszPrinterName  : Name of the printer which got installed
    hwnd            : Window handle for any UI

Return Value:
    If the printer is already install TRUE, else FALSE

--*/
{
    TCHAR               szCmd[MAX_PATH];
    SHELLEXECUTEINFO    ShellExecInfo;
    TCHAR               *pszExecutable  = NULL;
    TCHAR               *pszParams      = NULL;
    LPTSTR              pszVendorSetup  = pLocalData->InfInfo.pszVendorSetup;
    INT                 cParamsLength   = 0;
    INT                 cLength         = 0;

    
    if (IsSystemSetupInProgress())
    {
        goto Cleanup;
    }

    ASSERT(pLocalData->Flags & VALID_INF_INFO);

    cParamsLength = lstrlen(pszVendorSetup) + lstrlen(pszPrinterName) + 4;
    pszParams     = LocalAllocMem(cParamsLength * sizeof(TCHAR));
    if (!pszParams) 
    {
        goto Cleanup;
    }

    StringCchPrintf(pszParams, cParamsLength, TEXT("%s \"%s\""), pszVendorSetup, pszPrinterName);

    GetSystemDirectory( szCmd, SIZECHARS(szCmd) );
    cLength = lstrlen( szCmd ) + lstrlen( cszRunDll32 ) + 2;
    pszExecutable = LocalAllocMem( cLength * sizeof(TCHAR) );
    if (!pszExecutable) 
    {
        goto Cleanup;
    }
    StringCchCopy(pszExecutable, cLength, szCmd);

    if (*(pszExecutable + (lstrlen( pszExecutable ) - 1)) != TEXT('\\'))
    {
        StringCchCat( pszExecutable, cLength, TEXT("\\"));
    }
    StringCchCat(pszExecutable, cLength, cszRunDll32 );

    ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
    ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
    ShellExecInfo.hwnd          = hwnd;
    ShellExecInfo.lpFile        = pszExecutable;
    ShellExecInfo.nShow         = SW_SHOWNORMAL;
    ShellExecInfo.fMask         = SEE_MASK_NOCLOSEPROCESS;
    ShellExecInfo.lpParameters  = pszParams;

    //
    // Call run32dll and wait for the vendor dll to return before proceeding
    //
    if ( ShellExecuteEx(&ShellExecInfo) && ShellExecInfo.hProcess ) {

        WaitForSingleObject(ShellExecInfo.hProcess, dwFourMinutes );
        CloseHandle(ShellExecInfo.hProcess);
    }

Cleanup:

    LocalFreeMem(pszExecutable);
    LocalFreeMem(pszParams);
    return;
}


BOOL
SetPackageName (
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
{
   SP_WINDOWSUPDATE_PARAMS     WinUpParams;

   //
   // Get current SelectDevice parameters, and then set the fields
   // we wanted changed from default
   //
   WinUpParams.ClassInstallHeader.cbSize = sizeof(WinUpParams.ClassInstallHeader);
   WinUpParams.ClassInstallHeader.InstallFunction = DIF_GETWINDOWSUPDATEINFO;
   if ( !SetupDiGetClassInstallParams( hDevInfo,
                                       pDevInfoData,
                                       &WinUpParams.ClassInstallHeader,
                                       sizeof(WinUpParams),
                                       NULL) )
   {
       return FALSE;
   }

   StringCchCopy( WinUpParams.PackageId, COUNTOF(WinUpParams.PackageId), cszWebNTPrintPkg );
   WinUpParams.CDMContext = gpCodeDownLoadInfo->hConnection;

   if ( !SetupDiSetClassInstallParams( hDevInfo,
                                       pDevInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &WinUpParams,
                                       sizeof(WinUpParams) ) )
   {
       return FALSE;
   }

   return TRUE;
}

DWORD
ProcessPerInstanceAddRegSections(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  PPSETUP_LOCAL_DATA  pLocalData
)
/*++

Routine Description:
    Processes the AddReg section for this printer that is marked as to process per instance of this
    device

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pLocalData          : Pointer to the print setup local data

Return Value:
    Win 32 error code

--*/
{
    DWORD dwReturn;
    HINF hPrinterInf;
    TCHAR *pszSection = NULL;

    dwReturn = StrCatAlloc(&pszSection, pLocalData->InfInfo.pszInstallSection, cszProcessAlways, NULL);

    if (dwReturn != ERROR_SUCCESS)
    {
        goto Done;
    }
    
    hPrinterInf = SetupOpenInfFile(pLocalData->DrvInfo.pszInfName, 
                                   NULL, 
                                   INF_STYLE_WIN4,
                                   NULL);

    if (hPrinterInf != INVALID_HANDLE_VALUE)
    {
        //
        // Ignore return value - it doesn't make much sense to fail the install here
        //
        if (!SetupInstallFromInfSection(NULL,
                                        hPrinterInf,
                                        pszSection,
                                        SPINST_REGISTRY,
                                        NULL,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL,
                                        hDevInfo,
                                        pDevInfoData))
        {
            DBGMSG( DBG_ERROR,("ProcessPerInstanceAddRegSections: SetupInstallFromInfSection failed: %d\n", GetLastError( )));
        }
        
        SetupCloseInfFile(hPrinterInf);
    }
    else
    {
        DBGMSG( DBG_ERROR,("ProcessPerInstanceAddRegSections: SetupOpenInfFile %s failed: %d\n", pLocalData->DrvInfo.pszInfName, GetLastError( )));
    }

Done:
    FreeSplMem(pszSection);

    return dwReturn;
}

DWORD
ClassInstall_SelectDevice(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_SELECTDEVICE

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer

Return Value:
    Win 32 error code

--*/
{

    return SetSelectDevParams(hDevInfo, pDevInfoData, FALSE, NULL)  &&
           SetDevInstallParams(hDevInfo, pDevInfoData, NULL)
                ? ERROR_DI_DO_DEFAULT
                : GetLastError();
}


DWORD
ClassInstall_InstallDevice(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLDEVICE

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    TPrinterInstall     TPrnInstData;
    TParameterBlock     TParm;
    TCHAR               szPrinterName[MAX_PRINTER_NAME];
    HANDLE              hPrinter = NULL;
    DWORD               dwReturn;
    SP_DRVINFO_DATA     DrvInfoData = {0};


    if ( !pDevInfoData ) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // check whether this is the NULL driver - we get that request if we fail DIF_ALLOW_INSTALL.
    // If the DI_FLAGSEX_SETFAILEDINSTALL we must succeed. In this case call the default class installer
    // to do it's thing, then set the REINSTALL flag on the devnode so on first boot 
    // they will try to reinstall the device
    //
    DrvInfoData.cbSize = sizeof(DrvInfoData);
    
    if ( 
         !SetupDiGetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData) &&
         (ERROR_NO_DRIVER_SELECTED == GetLastError()) &&
         IsSystemSetupInProgress() &&
         (pDevInstallParams->FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)
       )
    {
        DWORD dwConfigFlags = 0, cbRequiredSize =0, dwDataType = REG_DWORD;

        //
        // run the default class installer
        //
        if (SetupDiInstallDevice(hDevInfo, pDevInfoData))
        {
            //
            // now set the appropriate config flags
            //
            dwReturn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                        pDevInfoData,
                                                        SPDRP_CONFIGFLAGS,
                                                        &dwDataType,
                                                        (PBYTE) &dwConfigFlags,
                                                        sizeof(dwConfigFlags),
                                                        &cbRequiredSize) ? 
                                                            (REG_DWORD == dwDataType ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER) 
                                                            : GetLastError();                   

            if (ERROR_SUCCESS == dwReturn) 
            {
                dwConfigFlags |= CONFIGFLAG_REINSTALL;      // to make setupapi reinstall this on first boot
                dwConfigFlags &= ~CONFIGFLAG_FAILEDINSTALL; // per LonnyM's request in order not to screw up anything setupapi-internal

                dwReturn = SetupDiSetDeviceRegistryProperty(hDevInfo,
                                                            pDevInfoData,
                                                            SPDRP_CONFIGFLAGS,
                                                            (PBYTE) &dwConfigFlags,
                                                            sizeof(dwConfigFlags)) ? 
                                                                ERROR_SUCCESS : GetLastError();
            }
        }
        else
        {
            dwReturn = GetLastError();
        }
       
        //
        // don't go through the normal cleanup path that would munge the error code to 
        // DI_DO_DEFAULT - we have already called the default class installer and it would
        // clean out the flags we've set.
        //

        return dwReturn;
    }

    //
    //
    // Parse the inf and also get PnP info from config manger registry
    //
    if ( !(pLocalData = BuildInternalData(hDevInfo, pDevInfoData))  ||
         !ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0, FALSE) ) {

        dwReturn = GetLastError();
        goto Done;
    }
    
    if ( dwReturn = ProcessPerInstanceAddRegSections(hDevInfo, pDevInfoData, pLocalData)) {
        goto Done;
    }

    if ( dwReturn = GetPlugAndPlayInfo(hDevInfo, pDevInfoData, pLocalData) ) {
        goto Done;
    }

    //
    // Install printer driver if FORCECOPY is set or if the driver is not
    // available and it is ok to put up ui
    //
    if ( (pDevInstallParams->Flags & DI_FORCECOPY)  ||
         DRIVER_MODEL_INSTALLED_AND_IDENTICAL !=
                PSetupIsTheDriverFoundInInfInstalled(NULL,
                                                     pLocalData,
                                                     MyPlatform,
                                                     KERNEL_MODE_DRIVER_VERSION) ) {

        if ( pDevInstallParams->Flags & DI_NOFILECOPY ) {

            dwReturn = ERROR_UNKNOWN_PRINTER_DRIVER;
            goto Done;
        }

        dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                               pLocalData,
                                               pDevInstallParams->hwndParent,
                                               MyPlatform,
                                               dwThisMajorVersion,
                                               NULL,
                                               pDevInstallParams->FileQueue,
                                               pDevInstallParams->InstallMsgHandlerContext,
                                               pDevInstallParams->InstallMsgHandler,
                                               pDevInstallParams->Flags,
                                               NULL,
                                               DRVINST_NO_WARNING_PROMPT,
                                               APD_COPY_NEW_FILES, 
                                               NULL,
                                               NULL,
                                               NULL);

        if ( dwReturn != ERROR_SUCCESS )
            goto Done;
    }

    //
    // If the printer is already installed nothing to do
    //
    if ( DuplicateDevice(pLocalData) ) {

        dwReturn = ERROR_SUCCESS;
        goto Done;
    }

    if( !NewDriverForInstalledDevice(pLocalData, (LPTSTR)&szPrinterName) ) {

        if ( !LoadAndInitializePrintui() ) {

            dwReturn = GetLastError();
            goto Done;
        }

        TPrnInstData.cbSize                 = sizeof(TPrinterInstall);
        TPrnInstData.pszServerName          = NULL;
        TPrnInstData.pszDriverName          = pLocalData->DrvInfo.pszModelName;
        TPrnInstData.pszPortName            = pLocalData->PnPInfo.pszPortName;
        TPrnInstData.pszPrinterNameBuffer   = szPrinterName;
        TPrnInstData.pszPrintProcessor      = pLocalData->InfInfo.pszPrintProc;
        TPrnInstData.cchPrinterName         = SIZECHARS(szPrinterName);
        TParm.pPrinterInstall   = &TPrnInstData;

        if ( dwReturn = dwfnPnPInterface(kPrinterInstall, &TParm) )
            goto Done;
    } else {

        dwReturn = ERROR_SUCCESS;
    }

    //
    // Set the device instance id with spooler
    //
    if ( OpenPrinter(szPrinterName, &hPrinter, &PrinterDefault) ) {

        (VOID)SetPnPInfoForPrinter(hPrinter,
                                   pLocalData->PnPInfo.pszDeviceInstanceId,
                                   pLocalData->DrvInfo.pszHardwareID,
                                   pLocalData->DrvInfo.pszManufacturer,
                                   pLocalData->DrvInfo.pszOEMUrl);
    }

    //
    // If a vendor dll is given we need to call into it
    //
    if ( pLocalData->InfInfo.pszVendorSetup )
        CallVendorDll(pLocalData, szPrinterName, pDevInstallParams->hwndParent);

    //
    // If ICM files need to installed and associated do it
    //
    if ( pLocalData->InfInfo.pszzICMFiles )
        (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                         szPrinterName);

Done:
    if ( hPrinter )
        ClosePrinter(hPrinter);

    DestroyLocalData(pLocalData);

    //
    // On everything going smoothly we want setup to whatever it needs to do
    // to make PnP system happy so that the devnode is marked as configured
    // But we do not want them to copy files again
    //
    if ( dwReturn == ERROR_SUCCESS ) {

        pDevInstallParams->Flags |= DI_NOFILECOPY;

        SetupDiSetDeviceInstallParams(hDevInfo,
                                      pDevInfoData,
                                      pDevInstallParams);

        dwReturn = ERROR_DI_DO_DEFAULT;
    }

    return dwReturn;
}


DWORD
ClassInstall_DestroyWizardData(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_DESTROYWIZARDDATA
Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    SP_INSTALLWIZARD_DATA   InstallWizData;
    TDestroyWizard          TDestroyWsd;
    TParameterBlock         TParams;
    DWORD                   dwReturn;

    ASSERT(hPrintui && dwfnPnPInterface);
    if(!dwfnPnPInterface)
    {
        return ERROR_DI_DO_DEFAULT;
    }

    InstallWizData.ClassInstallHeader.cbSize
                = sizeof(InstallWizData.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData),
                                       NULL)    ||
         InstallWizData.ClassInstallHeader.InstallFunction != DIF_DESTROYWIZARDDATA ) {

        return ERROR_DI_DO_DEFAULT;
    }

    TDestroyWsd.cbSize          = sizeof(TDestroyWsd);
    TDestroyWsd.pszServerName   = NULL;
    TDestroyWsd.pData           = &InstallWizData;
    TDestroyWsd.pReferenceData  = (PVOID)pDevInstallParams->ClassInstallReserved;

    TParams.pDestroyWizard      = &TDestroyWsd;

    dwReturn = dwfnPnPInterface(kDestroyWizardData, &TParams);

    return dwReturn;
}


DWORD
ClassInstall_InstallWizard(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLWIZARD

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/

{
    SP_INSTALLWIZARD_DATA   InstallWizData;
    TInstallWizard          TInstWzd;
    TParameterBlock         TParams;
    DWORD                   dwReturn;

    InstallWizData.ClassInstallHeader.cbSize
                = sizeof(InstallWizData.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData),
                                       NULL)    ||
         InstallWizData.ClassInstallHeader.InstallFunction != DIF_INSTALLWIZARD ) {

        return ERROR_DI_DO_DEFAULT;
    }

    if ( !LoadAndInitializePrintui() )
        return GetLastError();

    TInstWzd.cbSize         = sizeof(TInstWzd);
    TInstWzd.pszServerName  = NULL;
    TInstWzd.pData          = &InstallWizData;
    TInstWzd.pReferenceData = (PVOID)pDevInstallParams->ClassInstallReserved;

    TParams.pInstallWizard  = &TInstWzd;

    if ( dwReturn = dwfnPnPInterface(kInstallWizard, &TParams) )
        goto Cleanup;

    if ( !SetupDiSetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData)) ) {

        dwReturn = GetLastError();
    }

    pDevInstallParams->ClassInstallReserved = (LPARAM)TInstWzd.pReferenceData;
    if ( !SetupDiSetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        pDevInstallParams) ) {

        dwReturn = GetLastError();
    }

Cleanup:
    if ( dwReturn != ERROR_SUCCESS ) {

        ClassInstall_DestroyWizardData(hDevInfo,
                                       pDevInfoData,
                                       pDevInstallParams);
    }

    return dwReturn;
}

            

DWORD
ClassInstall_InstallDeviceFiles(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLDEVICEFILES

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    PPSETUP_LOCAL_DATA      pLocalData;
    DWORD                   dwReturn;

    if ( pLocalData = BuildInternalData(hDevInfo, pDevInfoData) ) 
    {
        dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                               pLocalData,
                                               pDevInstallParams->hwndParent,
                                               MyPlatform,
                                               dwThisMajorVersion,
                                               NULL,
                                               pDevInstallParams->FileQueue,
                                               pDevInstallParams->InstallMsgHandlerContext,
                                               pDevInstallParams->InstallMsgHandler,
                                               pDevInstallParams->Flags,
                                               NULL,
                                               DRVINST_NO_WARNING_PROMPT,
                                               APD_COPY_NEW_FILES,
                                               NULL,
                                               NULL,
                                               NULL);
        
        DestroyLocalData(pLocalData);
    } 
    else 
    {
        dwReturn = GetLastError();
    }

    return dwReturn;
}


DWORD
ClassInstall_RemoveDevice(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_REMOVEDEVICE

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    DWORD               dwRet = ERROR_SUCCESS, dwIndex, dwCount, dwNeeded, dwType;
    HANDLE              hPrinter;
    LPPRINTER_INFO_2    pPrinterInfo2, pBuf = NULL;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    TCHAR               szDevId[MAX_DEVICE_ID_LEN], szPrnId[MAX_DEVICE_ID_LEN];

    if ( !SetupDiGetDeviceInstanceId(hDevInfo,
                                     pDevInfoData,
                                     szDevId,
                                     SIZECHARS(szDevId),
                                     NULL)                  ||
         !PrinterInfo2s(&pBuf, &dwCount) )
        return GetLastError();

    for ( dwIndex = 0, pPrinterInfo2 = pBuf ;
          dwIndex < dwCount ;
          ++dwIndex, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName,
                          &hPrinter,
                          &PrinterDefault) )
            continue;

        if ( ERROR_SUCCESS == GetPrinterDataEx(hPrinter,
                                               cszPnPKey,
                                               cszDeviceInstanceId,
                                               &dwType,
                                               (LPBYTE)szPrnId,
                                               sizeof(szPrnId),
                                               &dwNeeded)           &&
             (dwType == REG_SZ)                                     &&
             !lstrcmp(szPrnId, szDevId) ) {

            dwRet = DeletePrinter(hPrinter) ? ERROR_SUCCESS : GetLastError();
            ClosePrinter(hPrinter);
            goto Done;
        }

        ClosePrinter(hPrinter);
    }

    //
    // If we did not find the printer with spooler let setup do whatever they
    // want to. Note even if a printer failed to install they can call us to
    // remove it when Uninstall is selected from DevMan
    //
    dwRet = ERROR_DI_DO_DEFAULT;

Done:
    LocalFreeMem(pBuf);

    return dwRet;
}

DWORD
ClassInstall_SelectBestCompatDrv(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for
    DIF_SELECTBESTCOMPATDRV.

    We try to handle the broken OEM models which return same PnP id for
    multiple devices. For that we do the following:
        1. If only one compatible driver has been found by setup we got
           nothing to do. We ask setup to do the default since this is a good
           devive.
        2. If multiple drivers are found we do the following:
            2.1 What is the port this printer is attached to
            2.2 Find list of printers installed currently
            2.3 If we have a printer going to the port the PnP printer is
                attached to AND the driver for that printer is one of the
                compatible drivers then we got nothing to do. User has already
                manually installed it.

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    BOOL                    bFound = FALSE, Rank0IHVMatchFound = FALSE;
    HKEY                    hKey = NULL;
    DWORD                   dwReturn = ERROR_DI_DO_DEFAULT, dwRank0Matches;
    DWORD                   dwSize, dwType, dwIndex1, dwIndex2, dwReturned;
    SP_DRVINFO_DATA         DrvInfoData;
    TCHAR                   szPortName[MAX_PATH];
    LPPRINTER_INFO_2        p = NULL, pPrinterInfo2;
    SP_DRVINSTALL_PARAMS    DrvInstData;
    LPTSTR                  pszModelName = NULL;
    PSP_DRVINFO_DETAIL_DATA pDetailData;
    DWORD                   dwDetailDataSize = sizeof(SP_DRVINFO_DETAIL_DATA); 

    //
    // Allocate pDetailData on the heap, it's quite chunky
    //
    pDetailData = LocalAllocMem(dwDetailDataSize);
    if ( !pDetailData )
    {
        goto Done;
    }

    //
    // If we do not have more than 1 compatible driver do default
    //   Note: API uses 0 based index.
    //
    for ( dwIndex1 = dwRank0Matches = 0 ; ; ++dwIndex1 ) {

        DrvInfoData.cbSize = sizeof(DrvInfoData);
        if ( !SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER,
                                    dwIndex1, &DrvInfoData) )
            break;

        DrvInstData.cbSize = sizeof(DrvInstData);
        if ( SetupDiGetDriverInstallParams(hDevInfo,
                                           pDevInfoData,
                                           &DrvInfoData,
                                           &DrvInstData))
        {
            if (DrvInstData.Rank < 0x1000 ) 
            {
               if (!pszModelName)
               {
                  pszModelName = AllocStr( DrvInfoData.Description );
                  if(!pszModelName)
                  {
                      goto Done;
                  }
                  ++dwRank0Matches;
               }
               else if ( lstrcmpi( pszModelName, DrvInfoData.Description ) )
               {
                  ++dwRank0Matches;
               }
            }
            
            //
            // Check for whether this match is in ntprint.inf. If so, set flag to prefer other drivers
            //
            ZeroMemory(pDetailData, dwDetailDataSize);
            pDetailData->cbSize = dwDetailDataSize;

            //
            // check whether it's ntprint.inf
            // function may return insufficient buffer if it couldn't stuff all the
            // hardware IDs at the end of the structure.
            //
            if ((SetupDiGetDriverInfoDetail(hDevInfo, 
                                            pDevInfoData, 
                                            &DrvInfoData,
                                            pDetailData,
                                            dwDetailDataSize,
                                            NULL))              || 
                (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
            {
                SetLastError(ERROR_SUCCESS);
                if (IsSystemNTPrintInf( pDetailData->InfFileName ) )
                {
                    DrvInstData.Flags |= DNF_BASIC_DRIVER;
                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDevInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstData);

                }
                else if (DrvInstData.Rank < 0x1000 ) 
                {
                    Rank0IHVMatchFound = TRUE;
                }
            }

        }
    }

    //
    // Free the memory if allocated
    //
    LocalFreeMem( pszModelName );
    pszModelName = NULL;
    LocalFreeMem( pDetailData );
    pDetailData = NULL;

    if ( dwRank0Matches <= 1 )
        goto Done;

    //
    // Look in the devnode of the printer for the port name
    //
    dwSize = sizeof(szPortName);
    if ( ERROR_SUCCESS != CM_Open_DevNode_Key(pDevInfoData->DevInst, KEY_READ,
                                              0, RegDisposition_OpenExisting,
                                              &hKey, CM_REGISTRY_HARDWARE)  ||
         ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortName, NULL, &dwType,
                                          (LPBYTE)&szPortName, &dwSize) )
        goto Done;

    szPortName[COUNTOF(szPortName)-1] = TEXT('\0');

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Done;


    //
    // If there is a local printer using a driver with rank-0 match and
    // going to the same port then it is a duplicate
    //
    for ( dwIndex1 = 0, pPrinterInfo2 = p ;
          dwIndex1 < dwReturned ;
          ++dwIndex1, pPrinterInfo2++ ) {

        if ( !PrinterGoingToPort(pPrinterInfo2, szPortName) )
            continue;

        dwIndex2 = 0;
        DrvInfoData.cbSize = sizeof(DrvInfoData);
        while ( SetupDiEnumDriverInfo(hDevInfo, pDevInfoData,
                                      SPDIT_COMPATDRIVER, dwIndex2,
                                      &DrvInfoData) ) {

            DrvInstData.cbSize = sizeof(DrvInstData);
            if ( SetupDiGetDriverInstallParams(hDevInfo,
                                               pDevInfoData,
                                               &DrvInfoData,
                                               &DrvInstData)            &&
                 DrvInstData.Rank < 0x1000                              &&
                 !lstrcmpi(DrvInfoData.Description,
                           pPrinterInfo2->pDriverName) ) {

                bFound = TRUE;
                break;
            }

            ++dwIndex2;
            DrvInfoData.cbSize = sizeof(DrvInfoData);
        }

        if ( bFound )
            break;
    }

    //
    // If we found a manually installed printer which matches one of the
    // compatible drivers that is what we want to install
    //
    if ( bFound ) {

        //
        // This means newdev will choose this as the driver to install
        //
        if ( SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData) )
            dwReturn = ERROR_SUCCESS;
    } 
    else if (!Rank0IHVMatchFound)
    {
        //
        // We did not find a printer. So bump up the rank of all drivers
        // to force newdev to ask the user to select a driver
        //
        dwIndex2 = 0;
        DrvInfoData.cbSize = sizeof(DrvInfoData);
        while ( SetupDiEnumDriverInfo(hDevInfo, pDevInfoData,
                                      SPDIT_COMPATDRIVER, dwIndex2,
                                      &DrvInfoData) ) {

            DrvInstData.cbSize = sizeof(DrvInstData);
            if ( SetupDiGetDriverInstallParams(hDevInfo,
                                               pDevInfoData,
                                               &DrvInfoData,
                                               &DrvInstData)            &&
                 DrvInstData.Rank < 0x1000 ) {

                DrvInstData.Rank += 0x1000;
                SetupDiSetDriverInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &DrvInfoData,
                                              &DrvInstData);
            }

            ++dwIndex2;
            DrvInfoData.cbSize = sizeof(DrvInfoData);

        }
    }

Done:
    LocalFreeMem(p);

    if ( hKey )
        RegCloseKey(hKey);

    return dwReturn;
}

DWORD
StoreDriverTypeInDevnode(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    SP_DRVINFO_DATA DrvInfoData = {0};
    DWORD dwRet = ERROR_SUCCESS;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if (SetupDiGetSelectedDriver(hDevInfo, pDevInfoData,