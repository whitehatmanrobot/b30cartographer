ce count
// on the volume goes to zero the StopIo flag is set TRUE and a cancel IO
// request for the volume is posted to the journal completion port.  When the
// journal thread picks this up it does a CancelIo() on the volume handle.
// When the outstanding read completes (with either data or with status
// ERROR_OPERATION_ABORTED) the IoActive Flag is set false, the volume monitor
// entry is put on the VolumeMonitorStopQueue and no further read request to
// the journal is issued.
//
// Note: FSVolLabel must be AFTER FSVolInfo and MAXIMUM_VOLUME_LABEL_LENGTH
// is defined to account for WCHARS.
//
//


typedef struct _VOLUME_MONITOR_ENTRY {
    FRS_NODE_HEADER      Header;
    LIST_ENTRY           ListEntry;       // MUST FOLLOW HEADER

    //
    // This is the list head for all replica sets on the this volume.  It links
    // the REPLICA structs together.
    //
    FRS_LIST  ReplicaListHead;     // List of Replica Sets on Vol.
    //
    // The following USNs are for managing the NTFS USN journal on the volume.
    //
    USN    JrnlRecoveryEnd;        // Point where recovery is complete.

    USN    CurrentUsnRecord;       // USN of record currently being processed.
    USN    CurrentUsnRecordDone;   // USN of most recent record done processing.

    USN    LastUsnSavePoint;       // USN of last vol wide save.
    USN    MonitorMaxProgressUsn;  // Farthest progress made in this journal.

    USN    JrnlReadPoint;          // The current active read point for journal.

    USN_JOURNAL_DATA UsnJournalData; // FSCTL_QUERY_USN_JOURNAL data at journal open.

    USN    MonitorProgressUsn;     // Start journal from here after pause.
    USN    ReplayUsn;              // Start journal here after replica startup request
    BOOL   ReplayUsnValid;         // above has valid data.
    //
    // The FrsVsn is a USN kept by FRS and exported by all replica sets on the
    // volume.  It is unaffected by disk reformats and is saved in the config
    // record of each replica set.  At startup we use the maximum value for all
    // replica sets on a given volume. The only time they might differ is when
    // service on a given replica set is not started.
    //
    ULONGLONG            FrsVsn;          // Private FRS volume seq num.
    CRITICAL_SECTION     Lock;            // To sync access to VME.
    CRITICAL_SECTION     QuadWriteLock;   // To sync updates to quadwords.

    OVERLAPPED           CancelOverlap;   // Overlap struct for cancel req
    ULONG                WStatus;         // Win32 status on error
    ULONG                ActiveReplicas;  // Num replica sets active on journal
    HANDLE               Event;           // Event handle for pause journal.
    HANDLE               VolumeHandle;    // The vol handle for journal.
    WCHAR                DriveLetter[4];  // Drive letter for this volume.

    //
    // A change order table is kept on each volume to track the pending
    // change orders.  Tracking it for each replica set would be nice but
    // that approach has a problem with renames that move files or dirs
    // across replica sets on the volume.  If there are prior change orders
    // outstanding on a parent dir (MOVEOUT) in RS-A followed by a MOVEIN on
    // a child file X to RS-B we must be sure the MOVEOUT on the parent happens
    // before the MOVEIN on X.  Similar problems arise with a MOVEOUT of file X
    // followed by a MOVEIN to a different R.S. on the same volume.  We need to
    // locate the pending MOVEOUT change order on the volume or ensure it is
    // processed first.  One list per volume solves these problems.
    //
    PGENERIC_HASH_TABLE  ChangeOrderTable;// The Replica Change Order table.
    FRS_QUEUE            ChangeOrderList; // Change order processing list head.
    LIST_ENTRY           UpdateList;      // Link for the Replica Update Process Queue.
    ULONG                InitTime;        // Time reference for the ChangeOrderList.

    //
    // THe Active Inbound Change Order table holds the change order structs
    // indexed by File ID.  An entry in the table means that we have an
    // inbound (either local or remote) change order active on this file.
    //
    PGENERIC_HASH_TABLE  ActiveInboundChangeOrderTable;
    //
    // The ActiveChildren hash table is used to record the parent FID of each
    // active change order.  This is used to prevent a change order from starting
    // on the parent while a change order is active on one or more children.
    // For example if the child change order was a create and the parent change
    // order was an ACL change to prevent further creates, we must ensure the
    // child completes before starting the parent change order.  Each entry has
    // a count of the number of active children and a flag that is set if the
    // change order process queue is blocked because of a pending change order
    // on the parent.  When the count goes to zero the queue is unblocked.
    //
    PQHASH_TABLE  ActiveChildren;
    //
    // The Parent Table is a simple hash table used to keep the parent File ID
    // for each file and dir in any Replica Set on the volume.  It is used in
    // renames to find the old parent.
    //
    PQHASH_TABLE  ParentFidTable;
    //
    // The FRS Write Filter table filters out journal entries caused
    // by file system write from the File Replication Service (Us) when we
    // install files in the replica tree.
    //
    PQHASH_TABLE  FrsWriteFilter;
    //
    // The Recovery Conflict Table contains the FIDs of files that were in
    // the inbound log when we crashed.  At the start of recovery the inbound
    // log for the given replica set is scanned and the FIDs are entered into
    // the table.  During journal processing any USN records with a matching
    // FID are deemed to caused by FRS so we skip the record.  (This is because
    // the FrsWriteFilter table was lost in the crash).
    PQHASH_TABLE  RecoveryConflictTable;

    //
    // The name space table controls the merging of USN records into COs
    // that use the same file name.  If a name usage conflict exists in the
    // USN record stream then we can't merge the USN record into a previous
    // change order on the same file.
    //
    PQHASH_TABLE  NameSpaceTable;
    ULONG StreamSequenceNumberFetched;
    ULONG StreamSequenceNumberClean;
    ULONG StreamSequenceNumber;

    //
    // THe RenOldNameTable contains the USN records of the old file names
    // when a rename operation was performed.  THese are used later when the
    // Close record is processed for a rename to make the proper entry in the
    // NameSpace Table above.
    //
    PQHASH_TABLE  RenOldNameTable;

    //
    // The Filter Table contains an entry for each direcctory that is within a
    // replica set on this volume.  It is used to filter out Journal records for
    // files/dirs that are not in a Replica set.  For those Journal records that
    // are in a replica set, a lookup on the parent FileId tells us which one.
    //
    PGENERIC_HASH_TABLE  FilterTable;     // THe directory filter table.
    BOOL                 StopIo;          // True means StopIo requested.
    BOOL                 IoActive;        // True means I/O active on volume.
    ULONG                JournalState;    // Current journal state.
    ULONG                ReferenceCount;  // Free all hash tables when it hits 0.
    LONG                 ActiveIoRequests;// Number of Journal reads currently outstanding.
    FILE_OBJECTID_BUFFER RootDirObjectId; // Object ID for volume

    FILE_FS_VOLUME_INFORMATION    FSVolInfo;       // NT volume info.
    CHAR                          FSVolLabel[MAXIMUM_VOLUME_LABEL_LENGTH];

} VOLUME_MONITOR_ENTRY, *PVOLUME_MONITOR_ENTRY;

#define LOCK_VME(_pVme_)   EnterCriticalSection(&(_pVme_)->Lock)
#define UNLOCK_VME(_pVme_) LeaveCriticalSection(&(_pVme_)->Lock)
//
// Once the ref count goes to zero return 0 so the caller knows they didn't get it.
// Caller must check result and abort current op if RefCount is zero.
// Note: May need to move to interlocked compare an exchange if a race between
// final decrement to zero and another increment can actually occur.  The VME
// memory is not actually freed but such a race with the cleanup code
// could be a problem as could execution of the cleanup code multiple times.
// Could also wrap the deal with the Vme Lock.  Sigh.
//
#define AcquireVmeRef(_pVme_)                                      \
    ((_pVme_)->ReferenceCount == 0) ?                              \
        0 : InterlockedIncrement(&((_pVme_)->ReferenceCount))

#define ReleaseVmeRef(_pVme_)                                      \
    if (InterlockedDecrement(&((_pVme_)->ReferenceCount)) == 0) {  \
        DPRINT1(5, "VMEREF-- = %d\n", (_pVme_)->ReferenceCount);   \
        JrnlCleanupVme(_pVme_);                                    \
    }                                                              \
    DPRINT1(5, "VMEREF-- = %d\n", (_pVme_)->ReferenceCount);

//
// NEW_VSN hands out new VSNs and every 'VSN_SAVE_INTERVAL' VSNs that
// are handed out, save the state in the config record.  On restart we
// take the largest value and add 2*(VSN_SAVE_INTERVAL+1) to it so if a
// crash occurred we ensure that it never goes backwards.
//

VOID
JrnlNewVsn(
    IN PCHAR                 Debsub,
    IN ULONG                 uLineNo,
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN OUT PULONGLONG        NewVsn
    );


#define NEW_VSN(_pVme_, _pResult_)                                           \
    JrnlNewVsn(DEBSUB, __LINE__, _pVme_, _pResult_)



//
// Replay Mode means we have backed up the journal read point because another
// replica set has started and needs to see some earlier records. All other
// currently active Replica Sets sharing the same journal are implicitly in
// Replay Mode, skipping all records directed at them, since they have already
// been processed.
//
// The replica set is in replay mode if the LastUsnRecordProcessed is < than the
// current USN record being processed (pVme->CurrentUsnRecord).  Likewise the
// journal is in replay mode if MonitorMaxProgressUsn > CurrentUsnRecord.
//
#define REPLICA_REPLAY_MODE(_Replica_, _pVme_)  \
    ((_Replica_)->LastUsnRecordProcessed > (_pVme_)->CurrentUsnRecord)

#define JOURNAL_REPLAY_MODE(_pVme_)  \
    ((_pVme_)->MonitorMaxProgressUsn > (_pVme_)->CurrentUsnRecord)

#define CAPTURE_JOURNAL_PROGRESS(_pVme_, _pp_)        \
    if ((_pVme_)->MonitorProgressUsn == (USN) 0) {    \
        (_pVme_)->MonitorProgressUsn = (_pp_);        \
    }

#define CAPTURE_MAX_JOURNAL_PROGRESS(_pVme_, _pp_)    \
    if (!JOURNAL_REPLAY_MODE(_pVme_)) {               \
        (_pVme_)->MonitorMaxProgressUsn = (_pp_);     \
    }

#define LOAD_JOURNAL_PROGRESS(_pVme_, _alternate_pp_)           \
     (((_pVme_)->MonitorProgressUsn != (USN) 0) ?               \
      (_pVme_)->MonitorProgressUsn : (_alternate_pp_))

#define RESET_JOURNAL_PROGRESS(_pVme_) (_pVme_)->MonitorProgressUsn = (USN) 0


//
// The following macro is used to prevent quadword tearing in references
// to CurrentUsnRecordDone
//
#define UpdateCurrentUsnRecordDone(_pVme, _CurrentUsn)     \
    AcquireQuadLock(&((_pVme)->QuadWriteLock));            \
    (_pVme)->CurrentUsnRecordDone = (_CurrentUsn);         \
    ReleaseQuadLock(&((_pVme)->QuadWriteLock))

//
// Journal States (these track the Replica States).
//
#define JRNL_STATE_ALLOCATED                         0
#define JRNL_STATE_INITIALIZING                      1
#define JRNL_STATE_STARTING                          2
#define JRNL_STATE_ACTIVE                            3
#define JRNL_STATE_PAUSE1                            4
#define JRNL_STATE_PAUSE2                            5
#define JRNL_STATE_PAUSED                            6
#define JRNL_STATE_STOPPING                          7
#define JRNL_STATE_STOPPED                           8
#define JRNL_STATE_ERROR                             9
#define JRNL_STATE_JRNL_WRAP_ERROR                   10
#define JRNL_STATE_REPLICA_DELETED                   11
#define JRNL_STATE_MISMATCHED_VOLUME_SERIAL_NO       12
#define JRNL_STATE_MISMATCHED_REPLICA_ROOT_OBJECT_ID 13
#define JRNL_STATE_MISMATCHED_REPLICA_ROOT_FILE_ID   14
#define JRNL_STATE_MISMATCHED_JOURNAL_ID             15
#define JRNL_STATE_MAX                               15

#define JRNL_IN_ERROR_STATE(_x_) (          \
    ((_x_) == JRNL_STATE_ERROR) ||          \
    ((_x_) == JRNL_STATE_JRNL_WRAP_ERROR)   \
    )

#define JRNL_STATE_NEEDS_RESTORE(_x_) (                                 \
    ((_x_) == JRNL_STATE_JRNL_WRAP_ERROR)                   ||          \
    ((_x_) == JRNL_STATE_MISMATCHED_VOLUME_SERIAL_NO)       ||          \
    ((_x_) == JRNL_STATE_MISMATCHED_REPLICA_ROOT_OBJECT_ID) ||          \
    ((_x_) == JRNL_STATE_MISMATCHED_REPLICA_ROOT_FILE_ID)   ||          \
    ((_x_) == JRNL_STATE_MISMATCHED_JOURNAL_ID)                         \
    )

#define RSS_LIST(_state_) ReplicaServiceState[_state_].ServiceList
#define RSS_NAME(_state_) (((_state_) <= JRNL_STATE_MAX) ?                     \
                               ReplicaServiceState[_state_].Name :             \
                               ReplicaServiceState[JRNL_STATE_ALLOCATED].Name)


//
// The loop iterator pE is of type REPLICA.
// Update the state of the journal VME and the associated replicas.
//
#define SET_JOURNAL_AND_REPLICA_STATE(_pVme_, _NewState_)                    \
{                                                                            \
    PVOLUME_MONITOR_ENTRY  ___pVme = (_pVme_);                               \
                                                                             \
    DPRINT3(4, ":S: JournalState from %s to %s for %ws\n",                   \
        RSS_NAME(___pVme->JournalState),                                     \
        RSS_NAME(_NewState_),                                                \
        ___pVme->FSVolInfo.VolumeLabel);                                     \
    ___pVme->JournalState = (_NewState_);                                    \
    ForEachListEntry( &(___pVme->ReplicaListHead), REPLICA, VolReplicaList,  \
        JrnlSetReplicaState(pE, (_NewState_));                               \
    )                                                                        \
}

#define REPLICA_ACTIVE_INLOG_RETRY_SIZE    sizeof(QHASH_ENTRY)*64
#define REPLICA_NAME_CONFLICT_TABLE_SIZE   sizeof(QHASH_ENTRY)*100
#define NAME_SPACE_TABLE_SIZE              sizeof(QHASH_ENTRY)*100
#define RENAME_OLD_TABLE_SIZE              sizeof(QHASH_ENTRY)*100
#define FRS_WRITE_FILTER_SIZE              sizeof(QHASH_ENTRY)*100
#define RECOVERY_CONFLICT_TABLE_SIZE       sizeof(QHASH_ENTRY)*100
#define PARENT_FILEID_TABLE_SIZE           sizeof(QHASH_ENTRY)*500
#define ACTIVE_CHILDREN_TABLE_SIZE         sizeof(QHASH_ENTRY)*100
#define OUTLOG_RECORD_LOCK_TABLE_SIZE      sizeof(QHASH_ENTRY)*10
#define OUTLOG_DOMINANT_FILE_TABLE_SIZE    sizeof(QHASH_ENTRY)*128
#define OUTLOG_MUSTSEND_FILE_TABLE_SIZE    sizeof(QHASH_ENTRY)*32
#define PARTNER_NAME_TABLE_SIZE            sizeof(QHASH_ENTRY)*128
#define PARTNER_CONNECTION_TABLE_SIZE      sizeof(QHASH_ENTRY)*128


#define QHASH_EXTENSION_MAX                sizeof(QHASH_ENTRY)*50


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                             J B U F F E R                                 **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// Journal buffers are allocated in SizeOfJournalBuffer chunks.
// The first part of each buffer has a descriptor as defined below.
//

#define SizeOfJournalBuffer (4*1024)

typedef struct _JBUFFER {
    FRS_NODE_HEADER        Header;
    LIST_ENTRY             ListEntry;        // MUST FOLLOW HEADER

    IO_STATUS_BLOCK        Iosb;             // Iosb for this read.
    OVERLAPPED             Overlap;          // Overlap struct for this I/O
    HANDLE                 FileHandle;       // File handle where I/O was done.
    PVOLUME_MONITOR_ENTRY  pVme;             // Vol Mon Entry I/O is for.
    ULONG                  DataLength;       // Data len Returned from read.
    ULONG                  BufferSize;       // Size of buffer
    PLONGLONG              DataBuffer;       // ptr to Buffer
    ULONG                  WStatus;          // Win32 status after async I/O req.
    USN                    JrnlReadPoint;    // Starting USN for journal read.
    ULONGLONG              Buffer[1];        // Buffer to put journal data.
} JBUFFER, *PJBUFFER;


#define SizeOfJournalBufferDesc (OFFSET(JBUFFER, Buffer))


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**              T H R E A D   C O M M A N D   P A C K E T                    **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/

// Command packets are used to request a subsystem to perform some service.
// For example the Journal sub-system uses a command packet to initialize
// journal processing for a given replica set.  Another command is used
// to begin journal processing (once all the replica sets have been
// initialized.  Another command is to stop journal processing on a given
// volume.
//
// The structure is derived from the NT I/O request packet structure.
//

//
// Define completion routine types for use in command packet.
//

//
// The database field descriptor is used to update selected fields in a
// database record.
//

typedef struct _DB_FIELD_DESC_ {
    ULONG       FieldCode;          // The data field ID number (ENUM symbol)
    PVOID       Data;               // The new data value
    ULONG       Length;             // Data length
    ULONG       FStatus;            // Returned stats from field update.
} DB_FIELD_DESC, *PDB_FIELD_DESC;




//
// The DB_SERVICE_REQUEST is used to pass a request to the database command
// server.  It is pulled out as a seperate struct so the caller can create a
// pointer to it for easier manipulation.
//
// The TableCtx is a handle to a struct that describes what table is being
// accessed.  It also contains the storage for the data record being read
// or written.  Access to a pointer to this record is via the macro
// DBS_GET_RECORD_ADDRESS(DbsRequest) where DbsRequest is a ptr to the
// DB_SERVICE_REQUEST struct in the command packet.
//
// On the first access to a specific table, TableCtx is NULL.  All subsequent
// accesses should return the value unchanged.  The caller must cleanup by
// closing the table with a CMD_CLOSE_TABLE command packet or the DB will be
// left with open tables.  For single, one time requests, set the Close
// flag in the AccessRequest field to close the table before returning.
// The close flag can also be set on the last of a series of requests to
// avoid the need to send a CMD_CLOSE_TABLE command packet.
//
// The Context used by Database service commands is the
// Config Table record.  This is pointed to from the Replica Struct.
// The ConfigTableRecord has the info about the replica set.
// e.g. replica number, root path, volume ID, etc.
//
// AccessRequest specifies how the record access for reads and updates is done.
// DBS_ACCESS_BYKEY means use the index type and key value to access the record.
// DBS_ACCESS_FIRST means use the index type and access the first table record.
// DBS_ACCESS_LAST means use the index type and access the last table record.
// DBS_ACCESS_NEXT means use the index type and access the next record following
//                 a previous access.
// DBS_ACCESS_CLOSE means close the table after performing the operation.
//     *NOTE* this close only closes the table in the database.  It does not
//            release the table context struct or record storage (which has
//            the read data).  The caller must do this by calling
//            DBS_FREE_TABLECTX(DbsRequest) when the data has been consumed.
//            This is different from the CMD_CLOSE_TABLE command which both
//            closes the database table and frees the storage.
//
// The IndexType field specifies which index to use when accessing the table.
// It is table specific and each table has one or more indexes defined when
// the table schema was defined.  An ENUM defines the code values for the
// table index.
//
// The CallContext pointer is command specific.
//

//
// WARNING:  The table context is only valid within the thread that opened the
//  table.  If multiple DB service threads are added later we need to get a
//  request back to the same thread.
//


typedef struct _DB_SERVICE_REQUEST_ {
    PTABLE_CTX  TableCtx;         // Table context handle (NULL on first call)
    PREPLICA    Replica;          // Replica context ptr.
    ULONG       TableType;        // Type code for the table.
    PVOID       CallContext;      // Call specific context
    ULONG       AccessRequest;    // (ByKey, First, Last, Next) | Close
    ULONG       IndexType;        // The table index to use
    PVOID       KeyValue;         // The record key value for lookup
    ULONG       KeyValueLength;   // The Length of the key value
    FRS_ERROR_CODE FStatus;       // FRS Error status
    PULONG      SimpleFieldIDS;   // A ptr to an array of record field id numbers.
    ULONG       FieldCount;       // Count of Field Descriptors that follow or number of SimpleFieldIDs above.

    DB_FIELD_DESC Fields[1];      // One or more Field descriptors.


} DB_SERVICE_REQUEST, *PDB_SERVICE_REQUEST;

typedef
VOID
(*PCOMMAND_PACKET_COMPLETION_ROUTINE) (
    IN struct _COMMAND_PACKET *CmdPkt,
    IN PVOID Context
    );

typedef struct _CHANGE_ORDER_ENTRY_ CHANGE_ORDER_ENTRY, *PCHANGE_ORDER_ENTRY;
typedef struct _COMMAND_PACKET  COMMAND_PACKET, *PCOMMAND_PACKET;
struct _COMMAND_PACKET {
    FRS_NODE_HEADER        Header;
    LIST_ENTRY             ListEntry;       // MUST FOLLOW HEADER

    //
    // Command is the command to the subsystem.
    // Flags and control are command specific.
    //
#define CMD_PKT_FLAGS_SYNC        ((UCHAR) 0x01)
    USHORT  Command;
    UCHAR   Flags;
    UCHAR   Control;

    //
    // Used by the wait thread. The caller sets Timeout and TimeoutCommand.
    // The wait thread owns TimeoutFileTime. and TimeoutFlags
    //
#define CMD_PKT_WAIT_FLAGS_ONLIST ((USHORT) 0x0001)
#define CmdWaitFlagIs(_cmd_, _f_)       FlagOn((_cmd_)->WaitFlags, _f_)
#define SetCmdWaitFlag(_cmd_, _f_)      SetFlag((_cmd_)->WaitFlags, _f_)
#define ClearCmdWaitFlag(_cmd_, _f_)    ClearFlag((_cmd_)->WaitFlags, _f_)
    USHORT      TimeoutCommand; // Caller - Disposition of pkt after timeout
    USHORT      WaitFlags;      // Internal - flags for wait thread
    DWORD       Timeout;        // Caller - milliseconds
    LONGLONG    WaitFileTime;   // Internal - 100 nanoseconds


    //
    // If this command request is synchronous then the caller waits on the
    // event handle.  The submitter's Completion routine is saved in
    // SavedCompletionRoutine and we put our own completion routine in the
    // packet so we get the packet back and can return the status as the
    // function return value.  This way if the caller provides no completion
    // routine the default is to free the packet but we can always return the
    // status code.
    //
    HANDLE  WaitEvent;
    VOID    (*SavedCompletionRoutine)(PCOMMAND_PACKET, PVOID);

    //
    // For scheduled commands the following parameter specifies the delay
    // in milliseconds before the command is to execute.  When that time
    // arrives the command is queued to the target queue.
    //
    PFRS_QUEUE TargetQueue;

    //
    // Set by FrsCompleteCommand().
    //
    DWORD ErrorStatus;

    //
    // Called by FrsCompleteCommand()
    //
    VOID    (*CompletionRoutine)(PCOMMAND_PACKET, PVOID);

    //
    // Passed to the CompletionRoutine
    //
    PVOID CompletionArg;

    //
    // The following  parameters are based on the service that is being
    // invoked.  The service determines which set to use based
    // on the above major and minor function codes.
    //

    union {

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                            Test                                 //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////

        struct {
            DWORD Index;
        } UnionTest;

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                         Replica Set                             //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////

        struct {
            HANDLE      CompletionEvent;
            PVOID       From;
            PVOID       To;
            PVOID       Replica;
            PVOID       NewReplica;
            PVOID       ReplicaName;
            PVOID       Cxtion;
            PVOID       VVector;
            PVOID       ReplicaVv;
            ULONG       Timeout;
            PVOID       Block;
            LONGLONG    BlockSize;
            LARGE_INTEGER   FileSize;
            LARGE_INTEGER   FileOffset;
            ULONGLONG   LastJoinTime;
            PVOID       ChangeOrderEntry;
            PVOID       PartnerChangeOrderCommand;
            PVOID       GVsn;
            PVOID       ChangeOrderGuid;
            ULONG       ChangeOrderSequenceNumber;
            PVOID       JoinGuid;
            PVOID       JoinTime;
            PVOID       CommPktRcvTime;
            PVOID       AuthClient;
            PVOID       AuthName;
            PVOID       AuthSid;
            DWORD       AuthLevel;
            DWORD       AuthN;
            DWORD       AuthZ;
            PVOID       NewCxtion;
            PVOID       ReplicaVersionGuid;
            ULONG       COTx;
            ULONG       CommPkts;
            PVOID       Md5Digest;
            PVOID       PartnerChangeOrderCommandExt;
            PGEN_TABLE  CompressionTable;
        } UnionRs;

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                    Change Order Retry Command                   //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////

        struct {
            PREPLICA             Replica;
            PCHANGE_ORDER_ENTRY  ChangeOrderEntry;
            ULONG                ChangeOrderSequenceNumber;
            PCXTION              Cxtion;
        } UnionCoRetry;

#define CoRetryReplica(Cmd)          (Cmd->Parameters.UnionCoRetry.Replica)
#define CoRetryCxtion(Cmd)          (Cmd->Parameters.UnionCoRetry.Cxtion)
#define CoRetryChangeOrderEntry(Cmd) (Cmd->Parameters.UnionCoRetry.ChangeOrderEntry)
#define CoRetrySequenceNumber(Cmd)   (Cmd->Parameters.UnionCoRetry.ChangeOrderSequenceNumber)

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                    Delayed Command                              //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {
            PVOID       Cs;
            PVOID       Cmd;
            PVOID       Queue;
            ULONGLONG   Timeout;
        } UnionDs;

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                            Thread                               //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {
            PVOID FrsThread;
        } UnionTh;

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                            Snd/Rcv                              //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {
            PVOID       CommPkt;
            PVOID       To;
            PVOID       Replica;
            PVOID       Cxtion;
            BOOL        JoinGuidValid;
            GUID        JoinGuid;
            BOOL        SetTimeout;
            PVOID       PrincName;
            ULONG       AuthLevel;
            PVOID       Cs;
            PVOID       Cmd;
            ULONGLONG   TimeoutSetTime;
            ULONGLONG   LastJoinTime;
        } UnionSndRcv;


        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                Journal Subsystem Parameters                     //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {

            //
            // The Context used by journal commands are the Config Table
            // record and the Volume Monitor Entry.  Both of these structs
            // are pointed to from the Replica Struct.
            //
            // The ConfigTableRecord has the info about the replica set.
            // e.g. replica number, root path, volume ID, etc.
            //
            // After an initialize call the Journal subsystem creates a
            // volume monitor entry and stores a pointer to it in Replica->pVme.
            // There is a single VME for all the replica sets on a volume.
            // The VME has a ref count tracking the number of active replica sets.
            // The VME is used to manage journal processing on the volume.
            //

            PREPLICA Replica;
            PVOLUME_MONITOR_ENTRY  pVme; // pause only uses a VME
            ULONGLONG DFileID;

        } JournalRequest;


#define JrReplica(Cmd)    ((Cmd)->Parameters.JournalRequest.Replica)
#define JrpVme(Cmd)       ((Cmd)->Parameters.JournalRequest.pVme)
#define JrDFileID(Cmd)    ((Cmd)->Parameters.JournalRequest.DFileID)

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //              Outbound Log Subsystem Parameters                  //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {

            //
            // The Context used by outbound log commands is the Replica struct
            // and partner information.
            //
            PREPLICA Replica;
            PCXTION PartnerCxtion;
            struct _CHANGE_ORDER_ENTRY_  *ChangeOrder;
            ULONG SequenceNumber;
            HANDLE CompletionEvent;

        } OutLogRequest;


        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //                Databse Subsystem Parameters                     //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        DB_SERVICE_REQUEST  DbsRequest;



        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //           ReplicaState Subsystem Parameters                     //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {

            //
            // The ReplicaState subsystem manages the data base state for
            // a replica set and provides the means for resyncing that state
            // with the Replica Tree.  There are several when a resync
            // is required:
            //     1. Initial creation of replica set state, perhaps with
            //        existing data on disk.
            //     2. We lost journal data so we have to do state verification.
            //     3. We lost the database and need to reconstruct.
            //     4. Replica set was restored from a backup tape so the
            //        the file ID info and FS USN data needs to be reconstructed.
            //

            USN PickupUsn;

            PREPLICA Replica;

        } ReplicaStateRequest;


        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //           Staging File Generator Command Server                 //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////


        struct {

            //
            // The staging file subsystem generates staging files. This
            // structure is used to pass in parameters to the stageCs

            DWORD StagingSpaceRequestedInKB;

        } StageCsRequest;

#define StSpaceRequested(Cmd)    ((Cmd)->Parameters.StageCsRequest.StagingSpaceRequestedInKB)

    } Parameters;
};

#define RsOffsetSkip              (0)
#define RsOffset(_var_)            OFFSET(COMMAND_PACKET, Parameters.UnionRs._var_)

#define RsCompletionEvent(Cmd)    (Cmd->Parameters.UnionRs.CompletionEvent)
#define RsReplicaName(Cmd)        ((PGNAME)Cmd->Parameters.UnionRs.ReplicaName)
#define RsFrom(Cmd)               ((PGNAME)Cmd->Parameters.UnionRs.From)
#define RsTo(Cmd)                 ((PGNAME)Cmd->Parameters.UnionRs.To)
#define RsCxtion(Cmd)             ((PGNAME)Cmd->Parameters.UnionRs.Cxtion)
#define RsReplica(Cmd)            ((PREPLICA)Cmd->Parameters.UnionRs.Replica)
#define RsNewReplica(Cmd)         ((PREPLICA)Cmd->Parameters.UnionRs.NewReplica)
#define RsVVector(Cmd)            ((PGEN_TABLE)Cmd->Parameters.UnionRs.VVector)
#define RsReplicaVv(Cmd)          ((PGEN_TABLE)Cmd->Parameters.UnionRs.ReplicaVv)
#define RsCompressionTable(Cmd)   (Cmd->Parameters.UnionRs.CompressionTable)
#define RsJoinGuid(Cmd)           ((GUID *)Cmd->Parameters.UnionRs.JoinGuid)
#define RsJoinTime(Cmd)           ((ULONGLONG *)Cmd->Parameters.UnionRs.JoinTime)
#define RsCommPktRcvTime(Cmd)     ((ULONGLONG *)Cmd->Parameters.UnionRs.CommPktRcvTime)
#define RsLastJoinTime(Cmd)       (Cmd->Parameters.UnionRs.LastJoinTime)
#define RsTimeout(Cmd)            ((ULONG)Cmd->Parameters.UnionRs.Timeout)
#define RsReplicaVersionGuid(Cmd) ((GUID *)Cmd->Parameters.UnionRs.ReplicaVersionGuid)
#define RsCOTx(Cmd)               (Cmd->Parameters.UnionRs.COTx)
#define RsCommPkts(Cmd)           (Cmd->Parameters.UnionRs.CommPkts)
#define RsMd5Digest(Cmd)          (Cmd->Parameters.UnionRs.Md5Digest)
//
// Delayed Command Service
//
#define DsCs(Cmd)           ((PCOMMAND_SERVER)Cmd->Parameters.UnionDs.Cs)
#define DsCmd(Cmd)          ((PCOMMAND_PACKET)Cmd->Parameters.UnionDs.Cmd)
#define DsQueue(Cmd)        ((PFRS_QUEUE)Cmd->Parameters.UnionDs.Queue)
#define DsTimeout(Cmd)      ((ULONGLONG)Cmd->Parameters.UnionDs.Timeout)
//
// Thread Subsystem
//
#define ThThread(Cmd)       ((PFRS_THREAD)Cmd->Parameters.UnionTh.FrsThread)
//
// Send/Receive
//
#define SRCommPkt(Cmd)      ((PCOMM_PACKET)Cmd->Parameters.UnionSndRcv.CommPkt)
#define SRTo(Cmd)           ((PGNAME)Cmd->Parameters.UnionSndRcv.To)
#define SRCxtion(Cmd)       ((PCXTION)Cmd->Parameters.UnionSndRcv.Cxtion)
#define SRReplica(Cmd)      ((PREPLICA)Cmd->Parameters.UnionSndRcv.Replica)
#define SRSetTimeout(Cmd)   (Cmd->Parameters.UnionSndRcv.SetTimeout)
#define SRJoinGuidValid(Cmd)(Cmd->Parameters.UnionSndRcv.JoinGuidValid)
#define SRJoinGuid(Cmd)     (Cmd->Parameters.UnionSndRcv.JoinGuid)
#define SRPrincName(Cmd)    ((PWCHAR)Cmd->Parameters.UnionSndRcv.PrincName)
#define SRAuthLevel(Cmd)    ((ULONG)Cmd->Parameters.UnionSndRcv.AuthLevel)
#define SRCmd(Cmd)          ((PCOMMAND_PACKET)Cmd->Parameters.UnionSndRcv.Cmd)
#define SRCs(Cmd)           ((PCOMMAND_SERVER)Cmd->Parameters.UnionSndRcv.Cs)
#define SRTimeoutSetTime(Cmd) (Cmd->Parameters.UnionSndRcv.TimeoutSetTime)
#define SRLastJoinTime(Cmd)   (Cmd->Parameters.UnionSndRcv.TimeoutSetTime)
//
// Test
//
#define TestIndex(Cmd)      ((ULONG)Cmd->Parameters.UnionTest.Index)

//
// block of file data for copy
//
#define RsFileOffset(Cmd)   (Cmd->Parameters.UnionRs.FileOffset)
#define RsFileSize(Cmd)     (Cmd->Parameters.UnionRs.FileSize)
#define RsBlockSize(Cmd)    ((LONGLONG)Cmd->Parameters.UnionRs.BlockSize)
#define RsBlock(Cmd)        ((PUCHAR)Cmd->Parameters.UnionRs.Block)
//
// Change Order
//
#define RsCoe(Cmd)          ((PCHANGE_ORDER_ENTRY) \
                                Cmd->Parameters.UnionRs.ChangeOrderEntry)
#define RsCoc(Cmd)          ((PCHANGE_ORDER_COMMAND)&RsCoe(Cmd)->Cmd)
#define RsPartnerCoc(Cmd)   ((PCHANGE_ORDER_COMMAND) \
                                Cmd->Parameters.UnionRs.PartnerChangeOrderCommand)
#define RsPartnerCocExt(Cmd) ((PCHANGE_ORDER_RECORD_EXTENSION) \
                                Cmd->Parameters.UnionRs.PartnerChangeOrderCommandExt)

#define RsGVsn(Cmd)         ((PGVSN)Cmd->Parameters.UnionRs.GVsn)
#define RsCoGuid(Cmd)       ((GUID *)Cmd->Parameters.UnionRs.ChangeOrderGuid)
#define RsCoSn(Cmd)         ((ULONG) \
                             Cmd->Parameters.UnionRs.ChangeOrderSequenceNumber)
//
// Authentication info
//
#define RsAuthClient(Cmd)   ((PWCHAR)Cmd->Parameters.UnionRs.AuthClient)
#define RsAuthName(Cmd)     ((PWCHAR)Cmd->Parameters.UnionRs.AuthName)
#define RsAuthLevel(Cmd)    (Cmd->Parameters.UnionRs.AuthLevel)
#define RsAuthN(Cmd)        (Cmd->Parameters.UnionRs.AuthN)
#define RsAuthZ(Cmd)        (Cmd->Parameters.UnionRs.AuthZ)
#define RsAuthSid(Cmd)      ((PWCHAR)Cmd->Parameters.UnionRs.AuthSid)

//
// Seeding cxtion
//
#define RsNewCxtion(Cmd)     ((PCXTION)Cmd->Parameters.UnionRs.NewCxtion)


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**                    G E N E R I C   H A S H   T A B L E                    **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/

//
// A generic hash table is an array of GENERIC_HASH_ROW_ENTRY structs.  Each
// row entry contains an FRS_LIST struct that has a critical section, a list
// head and a count.  Each entry in the table has a GENERIC_HASH_ENTRY_HEADER
// at the front of it with a list entry, a ULONG hash value and a reference
// count.  Access to a row of the hash table is controlled by the critical
// section in the FRS_LIST struct.  See genhash.h for more details.
//
typedef struct _GENERIC_HASH_TABLE_ {
    FRS_NODE_HEADER                Header;
    CHAR                           Name[16];
    ULONG                          NumberRows;
    PGENERIC_HASH_FREE_ROUTINE     GhtFree;
    PGENERIC_HASH_COMPARE_ROUTINE  GhtCompare;
    PGENERIC_HASH_CALC_ROUTINE     GhtHashCalc;
    PGENERIC_HASH_PRINT_ROUTINE    GhtPrint;
    ULONG                          KeyOffset;
    ULONG                          KeyLength;
    BOOL                           RowLockEnabled;
    BOOL                           RefCountEnabled;
    HANDLE                         HeapHandle;
    BOOL                           UseOffsets;
    ULONG                          OffsetBase;
    ULONG                          LockTimeout;

    PGENERIC_HASH_ROW_ENTRY        HashRowBase;

} GENERIC_HASH_TABLE, *PGENERIC_HASH_TABLE;



/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**                  C H A N G E   O R D E R   E N T R Y                      **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/
//
// The following defines a file or directory change order entry built by the
// Journal subsystem.  These reside in a generic hash table associated with
// each replica called the ChangeOrderTable.  A ptr to the ChangeOrderTable
// is kept in the REPLICA struct for that replica.  The data in an entry
// comes from the NTFS USN Journal.  The FileID is used as the hash table
// index.  In addition the entries are linked on a time ordered list so the
// Update process can handle them in sequence.  An entry in the Change Order
// Process List is not processed until ChangeOrderAgingDelay seconds has
// elapsed.  This allows time for the NTFS tunnel cache to propagate the
// tunnelled state into the target file (in particular the object ID).  In
// addition it allows some time to accumulate other file changes into the
// change order to provide some batching of updates.  Each time an existing
// change order is updated its timestamp is updated to the time of the latest
// change and the entry moves to the end of the list.  To avoid the problem
// of an entry remaining on the list for an excessive amount of time the time
// of the initial entry creation is kept.  If this time is older than the
// CHANGE_ORDER_RESIDENCY_DELAY then the entry keeps its place in the list.
//
// The Change Order Command is what is actually transmitted to our partners
// and stored in the database while the operation is pending.  Generally the
// data elements declared in the change order entry are relevant to the local
// system only while the data elements in the change order command are
// invarient across replica set members.  The Change Order Command is defined
// in schema.h.
//
// Synchronize access to a change order entry using the change order lock table
// and the macros ChgOrdAcquireLock() and ChgOrdReleaseLock().
//

typedef struct _CHANGE_ORDER_ENTRY_ {
    GENERIC_HASH_ENTRY_HEADER  HashEntryHeader;   // Change Order hash Table support

    UNICODE_STRING   UFileName;           // Used in renames to make file name bigger
    ULONG            EntryFlags;          // misc state flags. See below.
    ULONG            CoMorphGenCount;     // for debugging.
    //
    // Change order process list management.
    //
    LIST_ENTRY        ProcessList;        // Link on the change order process list.
    ULONG             TimeToRun;          // Time to process the change order.
    ULONG             EntryCreateTime;    // Tick Count at entry create time.
    SINGLE_LIST_ENTRY DupCoList;          // Duplicate change order list.
    //
    //
    ULONG     DirNestingLevel;            // Number levels file is down in tree.
    ULONGLONG FileReferenceNumber;        // File's FID
    ULONGLONG ParentFileReferenceNumber;  // File's parent FID

    PREPLICA  OriginalReplica;            // ptr to original replica
    PREPLICA  NewReplica;                 // ptr to new replica

    ULONGLONG OriginalParentFid;          // For rename processing
    ULONGLONG NewParentFid;               // For rename processing
    ULONGLONG NameConflictHashValue;      // Key value for NameConflict table cleanup.

    ULONG     StreamLastMergeSeqNum;      // Stream seq num of last Usn record merged with this CO.
    PREPLICA_THREAD_CTX  RtCtx;           // For DB access during CO processing.
    GUID                *pParentGuid;     // ptr to the File's parent Guid in CoCmd.

    GUID                FileObjectId;     // Object ID read from the file for
                                          // local change orders.  Picked up for tunnelling.

    //
    // The joinguid is a cxtion's session id and, in this case,
    // is used to retry change orders that were accepted by
    // the change order accept thread for a cxtion that has since
    // unjoined from its partner. The change orders for previous
    // sessions are retried because they are out-of-order wrt the
    // change orders for the current session id. In other words,
    // order is maintained per session by coordinating the partners
    // at join time.
    GUID                JoinGuid;         // Cxtion's session id
                                          // undefined if local co

    //
    // Remote and control change orders are associated with a cxtion.
    // If this field is non-null, then the field
    // ChangeOrderCount has been incremente for this change
    // order. The count should be decremented when the
    // change order is freed in ChgOrdIssueCleanup().
    //
    PCXTION             Cxtion;           // NULL if local co
    //
    // Issue cleanup flags -- As a change order is processed it acquires
    // various resources that must be released when it retires or goes thru
    // retry.  The ISCU flag bits below are used to set these bits.  Note:
    // Not all bits may be set here.  Some may get set just before the CO goes
    // thru cleanup.
    //
    ULONG               IssueCleanup;
    //
    // Save full path name when the install code generates it for tracking.
    //
    PWCHAR          FullPathName;

    //
    // Needed to dampen basic info changes (e.g., resetting the archive bit)
    // Copied from the idtable entry when the change order is created and
    // used to update the change order when the change order is retired.
    //
    ULONG           FileAttributes;
    LARGE_INTEGER   FileCreateTime;
    LARGE_INTEGER   FileWriteTime;

    //
    // Store the current offset of the staging file that we are waiting for.
    // Used to discard responses that do not match the current offset we are
    // expecting.
    //
    //LARGE_INTEGER   FileOffset;

    //
    // Change order command parameters.
    // (must be last since it ends with FileName)
    //
    CHANGE_ORDER_COMMAND Cmd;

} CHANGE_ORDER_ENTRY, *PCHANGE_ORDER_ENTRY;

//
// This structure is used by the JrnlDoesChangeOrderHaveChildren to pass data to the
// JrnlDoesChangeOrderHaveChildrenWorker function.
//
typedef struct _VALID_CHILD_CHECK_DATA {
    PTHREAD_CTX ThreadCtx;
    PTABLE_CTX  TmpIDTableCtx;
    ULONGLONG   FileReferenceNumber;
} VALID_CHILD_CHECK_DATA, *PVALID_CHILD_CHECK_DATA;


//
// EntryFlags defs.
//
#define COE_FLAG_VOL_COLIST_BLOCKED  0x00000001
#define COE_FLAG_STAGE_ABORTED       0x00000002
#define COE_FLAG_STAGE_DELETED       0x00000004
#define COE_FLAG_NEED_RENAME         0x00000008

#define COE_FLAG_IN_AGING_CACHE      0x00000010
#define COE_FLAG_RECOVERY_CO         0x00000020 // CO is part of cxtion recovery/restart
#define COE_FLAG_NO_INBOUND          0x00000040 // The inbound partner cxtion is gone.
#define COE_FLAG_JUST_TOMBSTONE      0x00000080 // Creating file delete tombstone in IDTable

#define COE_FLAG_REJECT_AT_RECONCILE 0x00000100 // Always reject during reconcile
#define COE_FLAG_MOVEOUT_ENUM_DONE   0x00000200 // Set when the moveout enum is done for this CO
#define COE_FLAG_DELETE_GEN_CO       0x00000400 // Set for delete COs created by moveout ENUMS.
#define COE_FLAG_REANIMATION         0x00000800 // This CO is a reanimation request.

#define COE_FLAG_PARENT_REANIMATION  0x00001000 // This CO is for a reanimated parent.
#define COE_FLAG_PARENT_RISE_REQ     0x00002000 // This CO has previously requested
                                                // reanimation of its parent.
#define COE_FLAG_MORPH_GEN_FOLLOWER  0x00004000 // This is the MorphGenFollower of a Morph Gen pair.
#define COE_FLAG_MG_FOLLOWER_MADE    0x00008000 // Set in the MorphGenLeader when the Follower
                                                // CO is fabricated.
#define COE_FLAG_NEED_DELETE         0x00010000 // This CO must retry target delete.
#define COE_FLAG_PREINSTALL_CRE      0x00020000 // A preinstall file was created for this CO.
#define COE_FLAG_PRE_EXIST_MD5_MATCH 0x00040000 // The MD5 check with a pre-existing file is a match.
#define COE_FLAG_OID_FROM_FILE       0x00080000 // The incoming file has an OID (stored in Coe->FileObjectId)

#define COE_FLAG_IDT_NEW_PARENT_DEL_DEF  0x01000000 // IDTable shows New parent dir is delete deferred.
#define COE_FLAG_TRY_OVRIDE_INSTALL  0x02000000 // We hit a sharing violation on destination. Try rename to unblock.
#define COE_FLAG_IDT_ORIG_PARENT_DEL 0x04000000 // IDTable shows orig parent dir is deleted.
#define COE_FLAG_IDT_ORIG_PARENT_ABS 0x08000000 // IDTable shows orig parent dir record is absent.

#define COE_FLAG_IDT_NEW_PARENT_DEL  0x10000000 // IDTable shows New parent dir is deleted.
#define COE_FLAG_IDT_NEW_PARENT_ABS  0x20000000 // IDTable shows New parent dir record is absent.
#define COE_FLAG_IDT_TARGET_DEL      0x40000000 // IDTable shows Target file/dir of CO is deleted.
#define COE_FLAG_IDT_TARGET_ABS      0x80000000 // IDTable shows Target file/dir of CO is absent.



#define COE_FLAG_GROUP_REANIMATE (COE_FLAG_REANIMATION | \
                                  COE_FLAG_PARENT_REANIMATION | \
                                  COE_FLAG_PARENT_RISE_REQ)

#define COE_FLAG_GROUP_RAISE_DEAD_PARENT (COE_FLAG_REANIMATION | \
                                          COE_FLAG_PARENT_REANIMATION)

#define RecoveryCo(_COE_) COE_FLAG_ON(_COE_, COE_FLAG_RECOVERY_CO)

#define COE_FLAG_ON(_COE_, _F_)    (BooleanFlagOn((_COE_)->EntryFlags, (_F_)))
#define SET_COE_FLAG(_COE_, _F_)    SetFlag((_COE_)->EntryFlags, (_F_))
#define CLEAR_COE_FLAG(_COE_, _F_)  ClearFlag((_COE_)->EntryFlags, (_F_))

//
// The change order cleanup flags are used to control the state that needs
// to be updated when a change order fails to issue, is rejected or retires.
//
#define ISCU_DEL_PREINSTALL      0x00000001
#define ISCU_DEL_IDT_ENTRY       0x00000002
#define ISCU_UPDATE_IDT_ENTRY    0x00000004
#define ISCU_DEL_INLOG           0x00000008    // conditioned on ref count zero

#define ISCU_AIBCO               0x00000010
#define ISCU_ACTIVE_CHILD        0x00000020
#define ISCU_UPDATE_IDT_VVFLAGS  0x00000040
#define ISCU_CHECK_ISSUE_BLOCK   0x00000080

#define ISCU_DEL_RTCTX           0x00000100    // conditioned on ref count zero
#define ISCU_ACTIVATE_VV         0x00000200
#define ISCU_UPDATEVV_DB         0x00000400
#define ISCU_ACTIVATE_VV_DISCARD 0x00000800

#define ISCU_ACK_INBOUND         0x00001000
#define ISCU_INS_OUTLOG          0x00002000
#define ISCU_UPDATE_INLOG        0x00004000
#define ISCU_DEL_STAGE_FILE      0x00008000

#define ISCU_DEL_STAGE_FILE_IF   0x00010000
#define ISCU_FREE_CO             0x00020000    // conditioned on ref count zero
#define ISCU_DEC_CO_REF          0x00040000
#define ISCU_CO_ABORT            0x00080000

#define ISCU_NC_TABLE            0x00100000
#define ISCU_SPARE1              0x00200000
#define ISCU_UPDATE_IDT_FLAGS    0x00400000
#define ISCU_UPDATE_IDT_FILEUSN  0x00800000

#define ISCU_INS_OUTLOG_NEW_GUID 0x01000000   // modifier on _INS_OUTLOG
#define ISCU_UPDATE_IDT_VERSION  0x02000000

#define ISCU_NO_CLEANUP_MERGE    0x80000000


#define SET_ISSUE_CLEANUP(_Coe_, _Flag_) \
    SetFlag((_Coe_)->IssueCleanup, (_Flag_))

#define CLEAR_ISSUE_CLEANUP(_Coe_, _Flag_) \
    ClearFlag((_Coe_)->IssueCleanup, (_Flag_))

#define ZERO_ISSUE_CLEANUP(_Coe_)  (_Coe_)->IssueCleanup = 0


//
// ISCU_GOIS_CLEANUP clears Issue Clean up flags once we decide to issue CO.
//
#define ISCU_GOIS_CLEANUP (ISCU_DEL_PREINSTALL   |  \
                            ISCU_DEL_IDT_ENTRY)

//
// HOLDIS_CLEANUP removes state from the CO hold issue conflict tables.
//
#define ISCU_HOLDIS_CLEANUP (ISCU_AIBCO            |  \
                            ISCU_ACTIVE_CHILD      |  \
                            ISCU_NC_TABLE          |  \
                            ISCU_CHECK_ISSUE_BLOCK)

//
// FREEMEM_CLEANUP decrements the CO reference count and deletes the CO if the
// count goes to zero.
//
#define ISCU_FREEMEM_CLEANUP (ISCU_DEC_CO_REF        |  \
                              ISCU_DEL_RTCTX         |  \
                              ISCU_FREE_CO)

//
// ISSUE_CLEANUP does the hold issue conflict cleanup and deletes the CO if the
// reference count goes to zero.
//
#define ISCU_ISSUE_CLEANUP (ISCU_HOLDIS_CLEANUP    |  \
                            ISCU_FREEMEM_CLEANUP)


#define REPLICA_CHANGE_ORDER_ENTRY_KEY \
    OFFSET(CHANGE_ORDER_ENTRY, FileReferenceNumber)

#define  REPLICA_CHANGE_ORDER_ENTRY_KEY_LENGTH  sizeof(ULONGLONG)

#define REPLICA_CHANGE_ORDER_FILEGUID_KEY \
    OFFSET(CHANGE_ORDER_ENTRY, Cmd.FileGuid)

#define  REPLICA_CHANGE_ORDER_FILEGUID_KEY_LENGTH  sizeof(GUID)


#define REPLICA_CHANGE_ORDER_HASH_TABLE_ROWS 128

#define ACTIVE_INBOUND_CHANGE_ORDER_HASH_TABLE_ROWS 32

//
// Change order aging delay should be a min of 3 sec to allow for tunnel cache
// data to propagate.  Units are in milliseconds.
//
#define CHANGE_ORDER_RESIDENCY_DELAY 600

#define CO_TIME_TO_RUN(_pVme_) (GetTickCount() + ChangeOrderAgingDelay)

#define CO_TIME_NOW(_pVme_) (GetTickCount())


#define CO_REPLICA(_coe_)  \
    (((_coe_)->NewReplica != NULL) ? (_coe_)->NewReplica  \
                                   : (_coe_)->OriginalReplica)

#define CHANGE_ORDER_TRACE(_sev, _coe, _text)                                  \
    ChgOrdTraceCoe(_sev, DEBSUB, __LINE__, _coe, _text)

#define CHANGE_ORDER_TRACEW(_sev, _coe, _text, _wstatus)                       \
    ChgOrdTraceCoeW(_sev, DEBSUB, __LINE__, _coe, _text, _wstatus)

#define CHANGE_ORDER_TRACEX(_sev, _coe, _text, _data)                          \
    ChgOrdTraceCoeX(_sev, DEBSUB, __LINE__, _coe, _text, _data)

#define CHANGE_ORDER_TRACEF(_sev, _coe, _text, _fstatus)                       \
    ChgOrdTraceCoeF(_sev, DEBSUB, __LINE__, _coe, _text, _fstatus)

#define CHANGE_ORDER_TRACEXP(_sev, _coe, _text, _data)                         \
    ChgOrdTraceCoeX(_sev, DEBSUB, __LINE__, _coe, _text, PtrToUlong(_data))


#define CHANGE_ORDER_COMMAND_TRACE(_sev, _coc, _text)                          \
    ChgOrdTraceCoc(_sev, DEBSUB, __LINE__, _coc, _text)

#define CHANGE_ORDER_COMMAND_TRACEW(_sev, _coc, _text, _wstatus)               \
    ChgOrdTraceCocW(_sev, DEBSUB, __LINE__, _coc, _text, _wstatus)

#define CHANGE_ORDER_TRACE2_OLOG(_sev, _cmd, _text, _Replica, _Cxtion)       \
{                                                                            \
    CHAR Tstr[256];                                                          \
    _snprintf(Tstr, sizeof(Tstr), "OL%s "FORMAT_CXTION_PATH2, _text,         \
              PRINT_CXTION_PATH2(_Replica, _Cxtion));                        \
    Tstr[sizeof(Tstr)-1] = '\0';                                             \
    ChgOrdTraceCoc(_sev, DEBSUB, __LINE__, _cmd, Tstr);                      \
}


#define FRS_TRACK_RECORD(_coe, _text)                                         \
    FrsTrackRecord(2, DEBSUB, __LINE__, _coe, _text)


#define INCREMENT_CHANGE_ORDER_REF_COUNT(_coe)                                \
    InterlockedIncrement(&((_coe)->HashEntryHeader.ReferenceCount));          \
    ChgOrdTraceCoeX(3, DEBSUB, __LINE__, _coe, "Co Inc Ref to ",              \
                    (_coe)->HashEntryHeader.ReferenceCount)


#define DECREMENT_CHANGE_ORDER_REF_COUNT(_coe)                                \
    InterlockedDecrement(&((_coe)->HashEntryHeader.ReferenceCount));          \
    ChgOrdTraceCoeX(3, DEBSUB, __LINE__, _coe, "Co Dec Ref to ",              \
                    (_coe)->HashEntryHeader.ReferenceCount)
    // Note:  add coe delete code if we care that refcount goes to zero.


#define GET_CHANGE_ORDER_REF_COUNT(_coe)                                      \
    ((_coe)->HashEntryHeader.ReferenceCount);                                 \
    ChgOrdTraceCoeX(3, DEBSUB, __LINE__, _coe, "Co Get Ref Cnt",              \
                    (_coe)->HashEntryHeader.ReferenceCount)



/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**           J O U R N A L   F I L T E R   T A B L E   E N T R Y             **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/
//
// The Volume Filter Table Entry holds the file ID of a directory in
// a replica set.  As journal entries are processed the parent file ID of
// each journal record is used to lookup the filter table entry in the
// volume filter hash table (for the volume).  If it finds a match we
// know that the journal entry is for a file in a replica set on the
// volume.  The replica number field tells us which replica set it belongs
// too.  Consecutive lookups on the parent file ID yields the relative
// directory path for the file.
//
// The DTransition field is used to manage directory renames.  It contains a
// sequence number and a type field describing the nature of the directory
// rename operation.  See JrnlFilterUpdate() for details.
//

typedef struct _FILTER_TABLE_ENTRY_ {
    GENERIC_HASH_ENTRY_HEADER  HashEntryHeader;
    PREPLICA     Replica;
    ULONG        DTransition;       // used?? // <31:2> are seq number, <1:0> are Trans Type
    LIST_ENTRY   ChildHead;         // List head for this entry's children.
    LIST_ENTRY   ChildEntry;        // Entry link for children.
    ULONGLONG    FrsVsn;            // used?? // The FrsVsn for latest DIR change.
    UNICODE_STRING UFileName;       // Used in renames to make file name bigger
    //
    // The layout of the following MUST match the DIRTable Record layout
    // in schema.h
    //
    ULONGLONG    DFileID;
    ULONGLONG    DParentFileID;
    ULONG        DReplicaNumber;
    WCHAR        DFileName[1];
} FILTER_TABLE_ENTRY, *PFILTER_TABLE_ENTRY;

#define VOLUME_FILTER_HASH_TABLE_ROWS 256

#define FILTER_ENTRY_TRANS_STABLE    0
#define FILTER_ENTRY_TRANS_MOVE      1
#define FILTER_ENTRY_TRANS_DELETE    2

#define FILTER_ENTRY_TRANS_MASK     0x3
#define FILTER_ENTRY_TRANS_SHIFT      2

#define INCREMENT_FILTER_SEQ_NUMBER(_Entry_) \
    (((_Entry_)->DTransition += (1<<FILTER_ENTRY_TRANS_SHIFT)) >> \
                                                     FILTER_ENTRY_TRANS_SHIFT)

#define READ_FILTER_SEQ_NUMBER(_Entry_)     \
    (((_Entry_)->DTransition) >> FILTER_ENTRY_TRANS_SHIFT)

#define SET_FILTER_TRANS_TYPE(_Entry_, _TYPE_)   \
    (_Entry_)->DTransition = \
       ((_Entry_)->DTransition & ~FILTER_ENTRY_TRANS_MASK)  | _TYPE_

#define READ_FILTER_TRANS_TYPE(_Entry_)   \
    (_Entry_)->DTransition &= FILTER_ENTRY_TRANS_MASK


#define INCREMENT_FILTER_REF_COUNT(_Entry_) \
    InterlockedIncrement(&((_Entry_)->HashEntryHeader.ReferenceCount));  \
    DPRINT2(5, "inc ref: %08x, %d\n", (PtrToUlong(_Entry_)), (_Entry_)->HashEntryHeader.ReferenceCount);

#define DECREMENT_FILTER_REF_COUNT(_Entry_) \
    InterlockedDecrement(&((_Entry_)->HashEntryHeader.ReferenceCount));  \
    DPRINT2(5, "dec ref: %08x, %d\n", (PtrToUlong(_Entry_)), (_Entry_)->HashEntryHeader.ReferenceCount);


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**           W I L D C A R D   F I L T E R  E N T R Y                        **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/
//
// There are two wildcard filter lists in FRS.  One is for files and the other
// is for directories.  These filters are per-replica set and get loaded from
// the DS when the service starts on the given replica set.
//

typedef struct _WILDCARD_FILTER_ENTRY_ {
    FRS_NODE_HEADER Header;
    LIST_ENTRY      ListEntry;       // MUST FOLLOW HEADER
    ULONG           Flags;
    UNICODE_STRING  UFileName;
    WCHAR           FileName[1];
} WILDCARD_FILTER_ENTRY, *PWILDCARD_FILTER_ENTRY;


#define WILDCARD_FILTER_ENTRY_IS_WILD     0x1


//
// Global Jet Instance handle
//
extern JET_INSTANCE  GJetInstance;

//
// Note: Would be nice to clean this up.
// Note: Defs depend on PREPLICA, TABLE_CTX and JET_SESID but shouldn't be here.
//

ULONG
FrsSupMakeFullFileName(
    IN  PREPLICA Replica,
    IN  PWCHAR   RelativeName,
    OUT PWCHAR   FullName,
    IN  ULONG    MaxLength
    );

BOOL
FrsCloseWithUsnDampening(
    IN     PWCHAR       Name,
    IN OUT PHANDLE      Handle,
    IN     PQHASH_TABLE FrsWriteFilter,
    OUT    USN          *RetUsn
    );


//
// frsalloc.c needs the next two.
//

NTSTATUS
DbsAllocTableCtx(
    IN     TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx
    );


NTSTATUS
DbsAllocTableCtxWithRecord(
    IN TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx,
    IN PVOID DataRecord
    );

VOID
DbsFreeTableCtx(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG NodeType
    );


//
// MEMORY MANAGEMENT ROUTINES
//

//
// Allocate and zero a chunk of memory. An exception is raised if memory
// could not be allocated.
//
PVOID
FrsAlloc(
    IN DWORD NodeSize
    );

//
// Reallocate and zero a chunk of memory. An exception is raised if memory
// could not be allocated.
//
PVOID
FrsRealloc(
    IN PVOID OldNode,
    IN DWORD NodeSize
    );

//
// Allocate and initialize a struct of the specified type. The memory is
// zeroed and the FRS_NODE_HEADER is initialized.  The total allocation is
// the size of the base type PLUS the SizeDelta.
//
PVOID
FrsAllocTypeSize(
    IN NODE_TYPE NodeType,
    IN ULONG SizeDelta
    );

//
// Free the memory allocated with FrsAlloc.
//
PVOID
FrsFree(
    IN PVOID Node
    );

//
// Free the memory allocated with FrsAllocType.
//
// Check the embedded FRS_NODE_HEADER for correctness, Scribble on
// the memory, and then free it.
//
PVOID
FrsFreeType(
    IN PVOID Node
    );


VOID
FrsPrintTypeReplica(
    IN ULONG            Severity,   OPTIONAL
    IN PVOID            Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PREPLICA         Replica,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    );

VOID
FrsPrintTypeSchedule(
    IN ULONG            Severity,   OPTIONAL
    IN PVOID            Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PSCHEDULE        Schedule,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    );

//
// Print out the contents of a node.
//
VOID
FrsPrintType(
    IN ULONG Severity,
    IN PVOID Node,
    IN PCHAR Debsub,
    IN ULONG uLineNo
    );

#define FRS_PRINT_TYPE(_Severity, _Node) \
    FrsPrintType(_Severity, _Node, DEBSUB, __LINE__)

#define FRS_PRINT_TYPE_DEBSUB(_Severity, _DebSub, _Node) \
    FrsPrintType(_Severity, _Node, _DebSub, __LINE__)

//
// Take a list of "Typed" entries and free each entry.
//   *** Note ***  Each entry must be linked through a LIST_ENTRY struct that
//                 is declared immediately after the FRS_NODE_HEADER.
//
VOID
FrsFreeTypeList(
    PLIST_ENTRY Head
    );

//
// Duplicate a wide char string into a char string
//
PCHAR
FrsWtoA(
    IN PWCHAR Wstr
    );

//
// Duplicate a wide char string into a char string
//
PWCHAR
FrsAtoW(
    IN PCHAR Astr
    );

//
// Duplicate a string using our memory management routines
//
PWCHAR
FrsWcsDup(
    IN PWCHAR OldStr
    );

//
// Extract the volume name (drive:\) from Path
//
PWCHAR
FrsWcsVolume(
    IN PWCHAR Path
    );

//
// Concatenate first and second into a new string using our
// memory management routines
//
PWCHAR
FrsWcsCat(
    IN PWCHAR First,
    IN PWCHAR Second
    );

PWCHAR
FrsWcsCat3(
    IN PWCHAR First,
    IN PWCHAR Second,
    IN PWCHAR Third
    );
//
// Char version of FrsWcsCat()
//
PCHAR
FrsCsCat(
    IN PCHAR First,
    IN PCHAR Second
    );

//
// Concatenate first and second into a new path string using our
// memory management routines
//
PWCHAR
FrsWcsPath(
    IN PWCHAR First,
    IN PWCHAR Second
    );

//
// Char version of FrsWcsPath
//
PCHAR
FrsCsPath(
    IN PCHAR First,
    IN PCHAR Second
    );

//
// Initialize a unicode string with the contents of Wstr if the two are
// not already the same.  If the length of the new string is greater than
// the buffer space currently allocated in Ustr then allocate a new
// buffer for Ustr.  In some structures the initial Ustr buffer allocation
// is allocated as part of the initial structure allocation.  The address
// of this internal buffer is passed so it can be compared with the address
// in Ustr->Buffer.  If they match then no free memory call is made on
// the Ustr->Buffer address.  WstrLength is in bytes and should not include the
// trailing UNICODE_NULL.  Space is allocated for the NULL in the new buffer
// and a UNICODE_NULL is placed at the end of the string so it can be printed.
//
VOID
FrsAllocUnicodeString(
    PUNICODE_STRING Ustr,
    PWCHAR          InternalBuffer,
    PWCHAR          Wstr,
    USHORT          WstrLength
    );

//
// Remove the Trim char from the trailing end of the string.
// return a ptr to the first non Trim-Char in the string.
//
PWCHAR
FrsWcsTrim(
    PWCHAR Wstr,
    WCHAR  Trim
    );


/*
VOID
FrsCopyUnicodeStringFromRawString(
    PUNICODE_STRING _UStr,
    ULONG  _Maxlen,
    PWSTR  _WStr,
    ULONG  _Len
    )

     Init the unicode string struct by coping the data from _WStr.

     _UStr - ptr to unicode string struct
     _Maxlen is the size of the unicode string buffer
     _WStr is ptr to non-terminated unicode string.
     _Len is the length of the unicode string.
     Terminate the copied string with a Unicode null if room in the buffer.
     The terminating null is not included in the length.
*/

#define FrsCopyUnicodeStringFromRawString(_UStr, _Maxlen, _WStr, _Len) \
    FRS_ASSERT((_Maxlen) >= (_Len));                                   \
    FRS_ASSERT((_UStr) != NULL);                                       \
    FRS_ASSERT((_WStr) != NULL);                                       \
                                                                       \
    (_UStr)->Length = (USHORT)(_Len);                                  \
    CopyMemory((_UStr)->Buffer, _WStr, _Len);                          \
    (_UStr)->MaximumLength = (USHORT)(_Maxlen);                        \
    if ((_Maxlen) > (_Len)) {                                          \
        (_UStr)->Buffer[(_Len)/2] = UNICODE_NULL;                      \
    }



/*
VOID
FrsSetUnicodeStringFromRawString(
    PUNICODE_STRING _UStr,
    ULONG  _Maxlen,
    PWSTR  _WStr,
    ULONG  _Len
    )

     Init the unicode string struct by setting the address of _WStr into _UStr.
     No string copy is done.

     _UStr - ptr to unicode string struct
     _Maxlen is the size of the unicode string buffer
     _WStr is ptr to non-terminated unicode string.
     _Len is the length of the unicode string.
     Terminate the string with a Unicode null if room in the buffer.
     The terminating null is not included in the length.
*/

#define FrsSetUnicodeStringFromRawString(_UStr, _Maxlen, _WStr, _Len)  \
    FRS_ASSERT((_Maxlen) >= (_Len));                                   \
    FRS_ASSERT((_UStr) != NULL);                                       \
    FRS_ASSERT((_WStr) != NULL);                                       \
                                                                       \
    (_UStr)->Length = (USHORT)(_Len);                                  \
    (_UStr)->Buffer = (_WStr);                                         \
    (_UStr)->MaximumLength = (USHORT)(_Maxlen);                        \
    if ((_Maxlen) > (_Len)) {                                          \
        (_UStr)->Buffer[(_Len)/2] = UNICODE_NULL;                      \
    }

//
// Replica Startup / Shutdown Trace
//
#define REPLICA_STATE_TRACE(_sev, _cmd, _replica, _status, _text)             \
    ReplicaStateTrace(_sev, DEBSUB, __LINE__, (PCOMMAND_PACKET)(_cmd), _replica, _status, _text)


//
// Cxtion state Trace
//
#define CXTION_STATE_TRACE(_sev, _cxtion, _replica, _status, _text)           \
    CxtionStateTrace(_sev, DEBSUB, __LINE__, (PCXTION)(_cxtion), _replica, _status, _text)


//
// Trace command packet
//
#define COMMAND_TRACE(_sev, _cmd, _text)                                      \
    CmdPktTrace(_sev, DEBSUB, __LINE__, (_cmd), _text)

//
// Trace command with snd-comm packet
//
#define COMMAND_SND_COMM_TRACE(_sev, _cmd, _wstatus, _text) \
    SendCmdTrace(_sev, DEBSUB, __LINE__, _cmd, _wstatus, _text)

//
// Trace command with rcv-comm packet
//
#define COMMAND_RCV_TRACE(_sev, _cmd, _cxtion, _wstatus, _text) \
    ReceiveCmdTrace(_sev, DEBSUB, __LINE__, _cmd, _cxtion, _wstatus, _text)

//
// Trace command with comm packet
//
#define COMMAND_RCV_AUTH_TRACE(_sev, _comm, _wstatus, _authl, _authn, _client, _princname, _text) \
DPRINT8(_sev, ":SR: Comm %08x, Len %d, WS %d, Lev %d, AuthN %d, From %ws, To %ws [%s]\n", \
       (PtrToUlong(_comm)), \
       (_comm) ? _comm->PktLen : 0, \
       _wstatus, \
       _authl, \
       _authn, \
       _client, \
       _princname, \
       _text)


//
// Various trace functions.  (frsalloc.c)
//
VOID
ChgOrdTraceCoe(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    );

VOID
ChgOrdTraceCoeW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  WStatus
    );

VOID
ChgOrdTraceCoeF(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  FStatus
    );

VOID
ChgOrdTraceCoeX(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  Data
    );

VOID
ChgOrdTraceCoc(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text
    );

VOID
ChgOrdTraceCocW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text,
    IN ULONG  WStatus
    );

VOID
FrsTrackRecord(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    );

VOID
ReplicaStateTrace(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PREPLICA        Replica,
    IN ULONG           Status,
    IN PCHAR           Text
    );

VOID
ReplicaStateTrace2(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PREPLICA        Replica,
    IN PCHAR           Text
    );

VOID
CxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN PREPLICA Replica,
    IN ULONG    Status,
    IN PCHAR    Text
    );

VOID
CmdPktTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCHAR    Text
    );

VOID
SendCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN ULONG    WStatus,
    IN PCHAR    Text
    );

VOID
ReceiveCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCXTION  Cxtion,
    IN ULONG    WStatus,
    IN PCHAR    Text
    );

VOID
StageFileTrace(
    IN ULONG      Severity,
    IN PCHAR      Debsub,
    IN ULONG      uLineNo,
    IN GUID       *CoGuid,
    IN PWCHAR     FileName,
    IN PULONGLONG pFileSize,
    IN PULONG     pFlags,
    IN PCHAR      Text
    );

VOID
SetCxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN ULONG    NewState
    );

VOID
FrsPrintLongUStr(
    IN ULONG   Severity,
    IN PCHAR   Debsub,
    IN ULONG   uLineNo,
    IN PWCHAR  UStr
    );

#endif // _FRSALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frssup.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    frssup.h

Abstract:
    Collection of functions used by ntfrsapi and other frs tools.
    An attempt to reduce duplication of code.


Author:
    Sudarshan Chitre 20-Mar-2001

Environment
    User mode winnt

--*/

typedef struct _FRS_LDAP_SEARCH_CONTEXT {

    ULONG                     EntriesInPage;     // Number of entries in the current page.
    ULONG                     CurrentEntry;      // Location of the pointer into the page.
    LDAPMessage             * LdapMsg;           // Returned from ldap_search_ext_s()
    LDAPMessage             * CurrentLdapMsg;    // Current entry from current page.
    PWCHAR                    Filter;            // Filter to add to the DS query.
    PWCHAR                    BaseDn;            // Dn to start the query from.
    DWORD                     Scope;             // Scope of the search.
    PWCHAR                  * Attrs;             // Attributes requested by the search.

} FRS_LDAP_SEARCH_CONTEXT, *PFRS_LDAP_SEARCH_CONTEXT;

#define MK_ATTRS_1(_attr_, _a1)                                                \
    _attr_[0] = _a1;   _attr_[1] = NULL;

#define MK_ATTRS_2(_attr_, _a1, _a2)                                           \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = NULL;

#define MK_ATTRS_3(_attr_, _a1, _a2, _a3)                                      \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = NULL;

#define MK_ATTRS_4(_attr_, _a1, _a2, _a3, _a4)                                 \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = NULL;

#define MK_ATTRS_5(_attr_, _a1, _a2, _a3, _a4, _a5)                            \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = NULL;

#define MK_ATTRS_6(_attr_, _a1, _a2, _a3, _a4, _a5, _a6)                       \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = NULL;

#define MK_ATTRS_7(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7)                  \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = NULL;

#define MK_ATTRS_8(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)             \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = _a8;  \
    _attr_[8] = NULL;

#define FRS_SUP_FREE(_x_) { if (_x_) { free(_x_); (_x_) = NULL; } }


DWORD
FrsSupBindToDC (
    IN  PWCHAR    pszDC,
    IN  PSEC_WINNT_AUTH_IDENTITY_W pCreds,
    OUT PLDAP     *ppLDAP
    );

PVOID *
FrsSupFindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    );

PWCHAR
FrsSupWcsDup(
    PWCHAR OldStr
    );

PWCHAR
FrsSupFindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    );

BOOL
FrsSupLdapSearch(
    IN PLDAP        Ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Msg
    );

PWCHAR *
FrsSupGetValues(
    IN PLDAP Ldap,
    IN PWCHAR Base,
    IN PWCHAR DesiredAttr
    );

PWCHAR
FrsSupExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    );

PWCHAR
FrsSupGetRootDn(
    PLDAP    Ldap,
    PWCHAR   NamingContext
    );

BOOL
FrsSupLdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    );

PLDAPMessage
FrsSupLdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    );

DWORD
FrsSupLdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    );

PLDAPMessage
FrsSupLdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    );

VOID
FrsSupLdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\eventlog.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.h

Abstract:

    Header file for the internal eventlog interfaces (util\eventlog.c)

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _NTFRS_EVENTLOG_INCLUDED_
#define _NTFRS_EVENTLOG_INCLUDED_
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Similar eventlog messages are written to the EventLog
// once in EVENTLOG_FILTER_TIME seconds.
//
#define EVENTLOG_FILTER_TIME   86400 // 86400(Dec) secs = 1 day
#define CONVERTTOSEC           10000000 // 10^7
//
// Hash Table definitions
//
PQHASH_TABLE HTEventLogTimes;
//
// Hash Table size
//
#define ELHASHTABLESIZE        sizeof(QHASH_ENTRY)*100

#define EPRINT0(_Id) \
    FrsEventLog0(_Id)

#define EPRINT1(_Id, _p1) \
    FrsEventLog1(_Id, _p1)

#define EPRINT2(_Id, _p1, _p2) \
    FrsEventLog2(_Id, _p1, _p2)

#define EPRINT3(_Id, _p1, _p2, _p3) \
    FrsEventLog3(_Id, _p1, _p2, _p3)

#define EPRINT4(_Id, _p1, _p2, _p3, _p4) \
    FrsEventLog4(_Id, _p1, _p2, _p3, _p4)

#define EPRINT5(_Id, _p1, _p2, _p3, _p4, _p5) \
    FrsEventLog5(_Id, _p1, _p2, _p3, _p4, _p5)

#define EPRINT6(_Id, _p1, _p2, _p3, _p4, _p5, _p6) \
    FrsEventLog6(_Id, _p1, _p2, _p3, _p4, _p5, _p6)

#define EPRINT7(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7) \
    FrsEventLog7(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7)

#define EPRINT8(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8) \
    FrsEventLog8(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8)

#define EPRINT9(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9) \
    FrsEventLog9(_Id, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9)

VOID
FrsEventLog0(
    IN DWORD    EventMessageId
    );
/*++

Routine Description:

    Logs an event to the event log with no insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

Return Value:

    None.

--*/

VOID
FrsEventLog1(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1
    );
/*++

Routine Description:

    Logs an event to the event log with one insertion string.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1       - Insertion strings

Return Value:

    None.

--*/

VOID
FrsEventLog2(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2
    );
/*++

Routine Description:

    Logs an event to the event log with two insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..2    - Insertion strings

Return Value:

    None.

--*/

VOID
FrsEventLog3(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3
    );
/*++

Routine Description:

    Logs an event to the event log with three insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..3    - Insertion strings

Return Value:

    None.

--*/

VOID
FrsEventLog4(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4
    );
/*++

Routine Description:

    Logs an event to the event log with four insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..4    - Insertion strings

Return Value:

    None.

--*/

VOID
FrsEventLog5(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5
    );
/*++

Routine Description:

    Logs an event to the event log with five insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..5    - Insertion strings

Return Value:

    None.

--*/

VOID
FrsEventLog6(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6
    );
/*++

Routine Description:

    Logs an event to the event log with six insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..6    - Insertion strings

Return Value:

    None.

--*/



VOID
FrsEventLog7(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7
    );
/*++

Routine Description:

    Logs an event to the event log with seven insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..7    - Insertion strings

Return Value:

    None.

--*/


VOID
FrsEventLog8(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8
    );
/*++

Routine Description:

    Logs an event to the event log with nine insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..8    - Insertion strings

Return Value:

    None.

--*/



VOID
FrsEventLog9(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8,
    IN PWCHAR   EventMessage9
    );
/*++

Routine Description:

    Logs an event to the event log with nine insertion strings.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..9    - Insertion strings

Return Value:

    None.

--*/


#ifdef __cplusplus
}
#endif _NTFRS_EVENTLOG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\ntreppch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       NTreppch.H
//
//  Contents:   Common Header Files For the NT File Replication Project - Precompiled.
//              #include <NTreppch.h>
//              #pragma  hdrstop
//
//  History:    3/3/97  Davidor  Created  (from ntdspch.h)
//
//--------------------------------------------------------------------------
#ifndef _NTreppch_
#define _NTreppch_


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>


//
// Common Replication Headers
//
#include <ReplUtil.h>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\ntreppcx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       NTreppch.H
//
//  Contents:   Common Header Files For the NT File Replication Project - Precompiled.
//              #include <NTreppcx.h>
//              #pragma  hdrstop
//
//  History:    3/3/97  Davidor  Created  (from ntdspch.h)
//
//--------------------------------------------------------------------------
#ifndef _NTreppch_
#define _NTreppch_
extern "C" {


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// UNICODE or ANSI compilation
//
#include <tchar.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>

//
// Common Replication Headers
//
#include <ReplUtil.h>

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\genhash.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    genhash.h

Abstract:


*******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**                    G E N E R I C   H A S H   T A B L E                    **
**                                                                           **
**                                                                           **
*******************************************************************************
*******************************************************************************

 A generic hash table is an array of GENERIC_HASH_ROW_ENTRY structs.  Each
 row entry contains an FRS_LIST struct that has a critical section, a list
 head and a count.  Each entry in the table has a GENERIC_HASH_ENTRY_HEADER
 at the front of it with a list entry, a ULONG hash value and a reference
 count.  Access to a row of the hash table is controlled by the critical
 section in the FRS_LIST struct.


Parameters for a generic hash table:


Number of rows in the hash table.

    Table name for error messages.

    A compare function for insert (collisions) and for lookups,

    A key offset into the node entry to the start of the key data for the compare
    function.

    A key length for the compare.

    A  memory free function to use if the ref count goes to zero.

    A hash function on the key data,

    A display node routine that takes the address of an entry.  For error msgs
    and dump table.

    RowLockEnabled, TRUE means row locking is enabled (i.e.  multithread
    usage of table).  (Always enabled.  FALSE is TBI)

    RefCountEnabled,  TRUE if ref counting on data entries is enabled.
    (Always enabled.  FALSE is TBI)

    A LockTimeout value in milliseconds.   (TBI)

    AN optional heap handle to pass to the memory free function usefull if all the
    table entries are coming out of a special heap.   (TBI)

    OffsetsEnabled - If TRUE then all the pointers in the table are calculated
    as offsets relative to the the OffsetBase.  This is useful if you want to save
    the table contents to disk and you have a designated chunk of memory that the
    table elements are allocated out of (including the table structs).   (TBI)

    OffsetBase - see above.   (TBI)


Author:

    David Orbits          [davidor]   22-Apr-1997

Environment:

    User Mode Service

Revision History:


--*/
#ifndef _GENHASH_DEFINED_
#define _GENHASH_DEFINED_


typedef struct _GENERIC_HASH_TABLE_ *PGENERIC_HASH_TABLE;

//
//  The free routine is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PGENERIC_HASH_FREE_ROUTINE) (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );

//
// The compare routine is called on lookups to find an entry and on inserts
// to check for duplicates.
//

typedef
BOOL
(NTAPI *PGENERIC_HASH_COMPARE_ROUTINE) (
    PVOID Buf1,
    PVOID Buf2,
    ULONG Length
);

//
// The hash calc routine is called to generate the hash value of the key data
// on lookups and inserts.
//

typedef
ULONG
(NTAPI *PGENERIC_HASH_CALC_ROUTINE) (
    PVOID Buf,
    ULONG Length
);


//
// The filter function for use by GhtCleanTableByFilter.
//

typedef
BOOL
(NTAPI *PGENERIC_HASH_FILTER_ROUTINE) (
    PGENERIC_HASH_TABLE Table,
    PVOID Buf,
    PVOID Context
);

//
// The print routine is called to dump an element.
//
typedef
VOID
(NTAPI *PGENERIC_HASH_PRINT_ROUTINE) (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );


//
// The argument function passed to GhtEnumerateTable().
//
typedef
ULONG_PTR
(NTAPI *PGENERIC_HASH_ENUM_ROUTINE) (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );




#define GHT_ACTION_NOOP    0
#define GHT_ACTION_REMOVE  1
#define GHT_ACTION_DELETE  2

//
// Status code defs.  DON'T REORDER.  ADD TO END ONLY.
//
typedef enum _GHT_STATUS {
    GHT_STATUS_SUCCESS = 0,
    GHT_STATUS_REMOVED,
    GHT_STATUS_LOCKCONFLICT,
    GHT_STATUS_LOCKTIMEOUT,
    GHT_STATUS_NOT_FOUND,
    GHT_STATUS_FAILURE
} GHT_STATUS;

//
// Each entry that is placed in a hash table must start with a
// GENERIC_HASH_ENTRY_HEADER.  It is used to link the entries in a hash row,
// holds the ULONG hash value for quick lookups and holds the reference
// count on the entry.
//
typedef struct _GENERIC_HASH_ENTRY_HEADER {
    USHORT      Type;            // Type and size must match def in
    USHORT      Size;            // FRS_NODE_HEADER to use FrsAllocType().
    LIST_ENTRY  ListEntry;
    ULONG       HashValue;
    LONG        ReferenceCount;

} GENERIC_HASH_ENTRY_HEADER, *PGENERIC_HASH_ENTRY_HEADER;

//
// The GENERIC_HASH_ROW_ENTRY is the list head for each row in the table.
// It has the lock for the row, a row count and some row access stats.
//

typedef struct _GENERIC_HASH_ROW_ENTRY {
    FRS_LIST HashRow;
    ULONG RowInserts;
    ULONG RowRemoves;
    ULONG RowCompares;
    ULONG RowLookups;
    ULONG RowLookupFails;

} GENERIC_HASH_ROW_ENTRY, *PGENERIC_HASH_ROW_ENTRY;



VOID
GhtDestroyTable(
    PGENERIC_HASH_TABLE HashTable
    );

ULONG
GhtCleanTableByFilter(
    PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    PVOID Context
    );

#if DBG
#define GHT_DUMP_TABLE(_Sev_, _HashTable_) GhtDumpTable(_Sev_, _HashTable_)
VOID
GhtDumpTable(
    ULONG Severity,
    PGENERIC_HASH_TABLE HashTable
    );
#else DBG
#define GHT_DUMP_TABLE(_Sev_, _HashTable_)
#endif DBG


ULONG_PTR
GhtEnumerateTable(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    );

ULONG_PTR
GhtEnumerateTableNoRef(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    );

PGENERIC_HASH_ENTRY_HEADER
GhtGetNextEntry(
    IN PGENERIC_HASH_TABLE HashTable,
    PGENERIC_HASH_ENTRY_HEADER HashEntry
    );

ULONG
GhtCountEntries(
    IN PGENERIC_HASH_TABLE HashTable
    );

PGENERIC_HASH_ENTRY_HEADER
GhtGetEntryNumber(
    IN PGENERIC_HASH_TABLE HashTable,
    IN LONG EntryNumber
    );

PGENERIC_HASH_TABLE
GhtCreateTable(
    PCHAR ArgName,
    ULONG NumberRows,
    ULONG KeyOffset,
    ULONG KeyLength,
    PGENERIC_HASH_FREE_ROUTINE     GhtFree,
    PGENERIC_HASH_COMPARE_ROUTINE  GhtCompare,
    PGENERIC_HASH_CALC_ROUTINE     GhtHashCalc,
    PGENERIC_HASH_PRINT_ROUTINE    GhtPrint
    );

GHT_STATUS
GhtLookup2(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry,
    ULONG DupIndex
    );

//
// If duplicates are present then Return the first one in the list.
// This is the oldest duplicate based on insertion order.  New Inserts always
// go to the end of the duplicate list.
//
#define GhtLookup(_Table, _key, _wait, _retval) \
    GhtLookup2(_Table, _key, _wait, _retval, 1)

//
// If duplicates are present then return the last one in the list.
// This is the most recent duplicate inserted.
//
#define GhtLookupNewest(_Table, _key, _wait, _retval) \
    GhtLookup2(_Table, _key, _wait, _retval, 0)


GHT_STATUS
GhtInsert(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked,
    BOOL DuplicatesOk
    );

GHT_STATUS
GhtDeleteEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    );

GHT_STATUS
GhtRemoveEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    );

GHT_STATUS
GhtReferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    );

GHT_STATUS
GhtDereferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    );


GHT_STATUS
GhtAdjustRefCountByKey(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    LONG Delta,
    ULONG ActionIfZero,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry
    );

GHT_STATUS
GhtSwapEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID OldHashEntryArg,
    PVOID NewHashEntryArg,
    BOOL WaitIfLocked
    );


/*

The hash function returns a 32 bit ULONG used to index the table.                     kernrate
It keeps stats on # acitve entries, ...
Each hash row header element has an FRS_LIST, a count of lookups,
deletes, collisions, ...

Each hash entry (allocated by the caller for inserts) has a standard header.
The GENERIC_HASH_ENTRY_HEADER has list_entry, ULONG HashValue, Ref Count.
This is followed by user node specific data.



PGENERIC_HASH_TABLE
GhtCreateTable(
    PCHAR ArgName,
    ULONG NumberRows,
    ULONG KeyOffset,
    ULONG KeyLength,
    PGENERIC_HASH_FREE_ROUTINE     GhtFree,
    PGENERIC_HASH_COMPARE_ROUTINE  GhtCompare,
    PGENERIC_HASH_CALC_ROUTINE     GhtHashCalc,
    PGENERIC_HASH_PRINT_ROUTINE    GhtPrint
    )

Create a hash table.


VOID
GhtDestroyTable(PGEN_HASH_TABLE)

Free all the elements in the table and free the hash table structures.



GHT_STATUS
GhtInsert(PGEN_HASH_HEADER, WaitIfLocked)

takes the tablectx, and a PGEN_HASH_HEADER.  It calls the hash function with a
ptr to the key data (entry+key offset) which returns a ULONG that is stored in
GEN_HASH_HEADER.HashValue.  Insert then calculates the index of HashValue Mod
TableLenth.  With the index it finds the hash row header and acquires the row
lock (optional).  It then walks the list looking for a hash value match.  The
entires are kept in ascending order so the lookup stops as soon as new entry
value is < the list entry value.  It then inserts the entry in the table,
updates the counts in the row header and releases the lock and returns.  If it
finds a match it calls the user compare function with NewEntry+offset and
ListEntry+offset to validate the match.  The validate returns true if it matches
and false if it fails (i.e.  continue walking the list).  Handling Duplicates
????  Insert returns GHT_STATUS_SUCCESS if the entry was inserted and
GHT_STATUS_FAILURE if this is a duplicate node (the compare function returned
TRUE).  The refcount is incremented if the node was inserted and RefCounting is
enabled.  If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT else wait on the row.


GHT_STATUS
GhtInsertAndLockRow(PGEN_HASH_HEADER, WaitIfLocked, &PGEN_HASH_ROW_HANDLE)

Same as GhtInsert but leave the row locked if insert was successful.
It returns a Row handle for unlock.



GHT_STATUS
GhtLookup(pKeyValue, WaitIfLocked, &PGEN_HASH_HEADER)

like an insert but it takes a pointer to a key value as an argument
along with the table ctx.  The row index is computed, the row is optionally
locked and the list is searched for the entry.  In this case the validation
routine is called with a ptr to the arg key value and the ListEntry+NodeKeyOffset.

If the entry is found then a ptr to the entry is returned with an optional
reference count incremented and status GHT_STATUS_SUCCESS.  If the entry is
not found return status GHT_STATUS_NOT_FOUND.

If the row is locked and WaitIfLocked is TRUE then we wait on the row event.
If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT.  In this case you can't tell if the entry is in
the table.


GHT_STATUS
GHTLookupAndLockRow(pKeyValue, WaitIfLocked, &PGEN_HASH_HEADER, &PGEN_HASH_ROW_HANDLE)

Do a lookup and leave row locked if entry found.  Returns entry address
if found or NULL if not found or row was locked and WaitIfLocked is FALSE.
Return the RowHandle if the entry was found or NULL if the row was locked and
WaitIfLocked is FALSE.  Status returns:

GHT_STATUS_SUCCESS                  found entry and row is locked.
GHT_STATUS_LOCKCONFLICT             row is locked, don't know status of entry
GHT_STATUS_NOT_FOUND                Entry is not in table.



GHT_STATUS
GhtDeleteEntryByKey(pKeyValue, WaitIfLocked, &PGEN_HASH_HEADER)

Does a lookup and a delete entry.  Locks the row after the lookup and unlocks
the row after the delete.  Returns a pointer to the entry or if a free memory
routine is provided, it frees the entry.  Return GHT_STATUS_NOT_FOUND if the
entry is not in the table.  Return GHT_STATUS_SUCCESS if the entry was deleted.
Return GHT_STATUS_FAILURE if the ref count was not 1.  The entry was not
deleted.  Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.


GHT_STATUS
GhtDeleteEntryByAddress(PGEN_HASH_HEADER, WaitIfLocked)

takes an entry address and fetches the hash value to acquire the row lock.
Remove the entry from the row and call the memory free function to release
the entries memory.  Drop the row lock.  Return GHT_STATUS_SUCCESS if we
deleted the entry and the ref count was 1.  Return GHT_STATUS_FAILURE if
the ref count was not 1.  The entry was not deleted.
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry.


GHT_STATUS
GhtRemoveEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )

Takes HashEntry address and fetches the hash value to acquire the row lock.
Remove the entry from the table.  The reference count is decremented.
If the ref count is > 2 when this call is made (1 for the caller and 1 for
being in the table) then another thread may have a ref to the entry.  If you
move the entry to another hash table the caller should be sure that other threads
with references can deal with the table change.


GHT_STATUS
GhtLockRowByKey(pKeyValue, WaitIfLocked, &PGEN_HASH_ROW_HANDLE)

takes a key value and locks the row and returns the row handle for use by
unlock.  This routine does not do a lookup so it doesn't matter if the entry
specified by the key is in the table or not.  Return GHT_STATUS_SUCCESS if we
got the lock.  Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.



GHT_STATUS
GhtLockRowByAddress(PGEN_HASH_HEADER, WaitIfLocked, &PGEN_HASH_ROW_HANDLE)

takes an entry address and fetches the hash value to acquire the row lock.
It returns the row handle for unlock.  Return GHT_STATUS_SUCCESS if we
got the lock.  Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry.


GHT_STATUS
GhtLockTable(WaitTime)

Locks all the rows in the table and returns with GHT_STATUS_SUCCESS.
Fails with GHT_STATUS_LOCKTIMEOUT if it takes > WaitTime millisec.
This is useful if you need to snapshot the table.


GHT_STATUS
UnlockTable()

Unlock all the rows in the table.  Only do this if you locked 'em all.



GHT_STATUS
GhtUnLockRowByKey(pKeyValue)

takes a key value, generates the row handle and unlocks the row.
This routine does not do a lookup so it doesn't matter if the entry
specified by the key is in the table or not.  Return GHT_STATUS_SUCCESS if we
released the lock.

Raises an exception if the ROW lock was not held by this thread.



GHT_STATUS
GHTUnlockRowByAddress(PGEN_HASH_HEADER)

takes an entry address and fetches the hash value to release the row lock and
signal the event.  Raises an exception if the ROW lock was not held by this thread.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry making the saved hash
value invalid.




GHT_STATUS
GHTUnlockRowByHandle(PGEN_HASH_ROW_HANDLE)

takes a hashvalue as a row handle to release the lock (and signal the event).
Raises an exception if the ROW lock was not held by this thread.




GHT_STATUS
GHTDecrementRefCount(PGEN_HASH_HEADER, FreeIfZero)

take the entry address and use the hash value to get the row lock and decrement
the ref count.  If the refcount goes to zero remove the entry from the table.
If FreeIfZero is TRUE then delete the entry.  Return GHT_STATUS_REMOVED if the
entry is removed from the table.  Otherwise return GHT_STATUS_SUCCESS.
Since the caller already has a ref count there is no possiblity of the entry
having been deleted.




GHT_STATUS
GhtIncrementRefCount(PGEN_HASH_HEADER)

take the entry address and use the hash value to get the row lock and increment
the ref count.  Return GHT_STATUS_SUCCESS.  Since the caller already has a ref
count (since they have an address) there is no possiblity of the entry having
been deleted.


GHT_STATUS
GhtAdjustRefCountByKey(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    LONG Delta,
    ULONG ActionIfZero,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry
    )

#define GHT_ACTION_NOOP    0
#define GHT_ACTION_REMOVE  1
#define GHT_ACTION_DELETE  2


Use the keyValue to get the row lock and find the entry.
Add delta to the ref count.  If ref cnt is zero The value of ActionIfZero
determines one of noop, remove entry, remove and delete entry.
Return GHT_STATUS_NOT_FOUND if the entry is not found in the table.
Otherwise return GHT_STATUS_SUCCESS.  If the element is removed from the
table the address is returned in RethashEntry.



GHT_STATUS
GhtSwapEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID OldHashEntryArg,
    PVOID NewHashEntryArg,
    BOOL WaitIfLocked
    )

This routine replaces an existing old hash entry with a new entry.  It verifies
tha the old hash entry is still in the table.  It assumes that the key value of
the new entry is the same as the old entry.  NO CHECK IS MADE.

The expected use is when the caller needs to reallocate an entry with
more storage.

NOTE ALSO:  The reference count is copied from the old entry to the new one.
Using this routine means that the caller is using  GhtDecrementRefCountByKey()
and GhtIncrementRefCountByKey() to access the ref counts on any element in the
table since the entry could get swapped making the pointer invalid.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.



GHT_STATUS
GHTResizeTable()

Acquire all the row locks, build a new row header array.
walk thru the old table removing the elements and using the saved hash value
to insert them into the new row header array.  Update the ptr to the base
of the new row header array and Free the old row header array.  If the wait
to acquire all the row locks is excessive (> 3 sec) then return GHT_STATUS_LOCKTIMEOUT
to avoid deadlock.



GHT_STATUS
GhtEnumerateTable




GhtDumpTable




GhtEnumTableWithFunction
walk the table and call the specified function for each entry.



GhtGetTableStats










Return status codes.


GHT_STATUS_SUCCESS
GHT_STATUS_REMOVED
GHT_STATUS_LOCKCONFLICT
GHT_STATUS_LOCKTIMEOUT
GHT_STATUS_NOT_FOUND
GHT_STATUS_FAILURE

*/




#endif // _GENHASH_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\global.h ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global flags and parameters for the NT File Replication Service.

Author:

    David Orbits (davidor) - 4-Mar-1997

Revision History:
--*/

//
// Limit the amount of staging area used (in Kilobytes). This is
// a soft limit, the actual usage may be higher.
//
extern DWORD StagingLimitInKb;

//
// Default staging limit in kb to be assigned to a new staging area.
//
extern DWORD DefaultStagingLimitInKb;

//
// Running as service or as exe
//
extern BOOL RunningAsAService;

//
// Running with or without the DS
//
extern BOOL NoDs;

#if DBG
//
// Allow multiple servers on one machine
//
extern PWCHAR   ServerName;
extern PWCHAR   IniFileName;
extern GUID     *ServerGuid;
#endif DBG

//
// Working directory
//
extern PWCHAR   WorkingPath;

//
// Server Principle Name
//
extern PWCHAR   ServerPrincName;

//
// Running as a server in a domain
//
extern BOOL     IsAMember;

//
// Running as a DC
//
extern BOOL     IsADc;
extern BOOL     IsAPrimaryDc;

//
// Handle to the DC.
//
extern HANDLE   DsHandle;

//
// The NtFrs Service is shutting down.  Set TRUE when the ShutDownEvent is set.
//
extern BOOL     FrsIsShuttingDown;

//
// Set TRUE if the shutdown request came from Service Control Manager rather
// than from an internally triggered shutdown.  e.g. insufficient resources.
//
extern BOOL     FrsScmRequestedShutdown;

//
// Global set to TRUE when FRS asserts.
//
extern BOOL     FrsIsAsserting;

//
// Location of Jet Database (UNICODE and ASCII)
//
extern PWCHAR   JetPath;
extern PWCHAR   JetFile;
extern PWCHAR   JetSys;
extern PWCHAR   JetTemp;
extern PWCHAR   JetLog;

extern PCHAR    JetPathA;
extern PCHAR    JetFileA;
extern PCHAR    JetSysA;
extern PCHAR    JetTempA;
extern PCHAR    JetLogA;

extern PWCHAR   ServiceLongName;

//
// Shared between the journal, database, and replica command servers
//
extern FRS_QUEUE        ReplicaListHead;
extern FRS_QUEUE        ReplicaFaultListHead;
extern BOOL             DBSEmptyDatabase;
extern COMMAND_SERVER   DBServiceCmdServer;
extern COMMAND_SERVER   ReplicaCmdServer;
extern COMMAND_SERVER   InitSyncCs;



#define bugbug(_text_)
#define bugmor(_text_)

//
// The Change Order Lock table is used to synchronize access to change orders.
// The lock index is based on a hash of the change order FileGuid.  This ensures
// that when a duplicate change order (from another inbound partner) is trying
// to issue we will interlock against the retire operation on the same change
// order with the same Guid. The FileGuid is used because checks are also needed
// against other change orders on the same file and to check for conflicting
// activity on the parent change order.
//
// The lock array reduces contention and it also avoids the allocating and
// freeing the crit sec resource if it lived in the change order itself
// (which doesn't work anyway because of the race between issue check and
// retire of duplicate change orders).
// *** The array size must be pwr of 2.
//
#define NUMBER_CHANGE_ORDER_LOCKS 16
CRITICAL_SECTION ChangeOrderLockTable[NUMBER_CHANGE_ORDER_LOCKS];

// FidHashValue = (HighPart >> 12) + LowPart + (HighPart << (32-12));

#define HASH_FID(_pUL_, _TABLE_SIZE_) \
(( (_pUL_[1] >> 12) + _pUL_[0] + (_pUL_[1] << (32-12))) & ((_TABLE_SIZE_)-1))

#define HASH_GUID(_pUL_, _TABLE_SIZE_) \
((_pUL_[0] ^ _pUL_[1] ^ _pUL_[2] ^ _pUL_[3]) & ((_TABLE_SIZE_)-1))

//#define ChgOrdAcquireLockGuid(_coe_) {                                  \
//     PULONG pUL =  (PULONG) &((_coe_)->Cmd.FileGuid);                   \
//     EnterCriticalSection(                                              \
//    &ChangeOrderLockTable[HASH_GUID(pUL, NUMBER_CHANGE_ORDER_LOCKS)] ); \
//}
//
//#define ChgOrdReleaseLockGuid(_coe_)  {                                 \
//     PULONG pUL =  (PULONG) &((_coe_)->Cmd.FileGuid);                   \
//     LeaveCriticalSection(                                              \
//    &ChangeOrderLockTable[HASH_GUID(pUL, NUMBER_CHANGE_ORDER_LOCKS)] ); \
//}


#define UNDEFINED_LOCK_SLOT  (0xFFFFFFFF)

#define ChgOrdGuidLock(_pGuid_) \
    HASH_GUID(((PULONG)(_pGuid_)), NUMBER_CHANGE_ORDER_LOCKS)

//
// Get/Release the change order lock based on the lock slot.
//
#define ChgOrdAcquireLock(_slot_)                                       \
    FRS_ASSERT((_slot_) != UNDEFINED_LOCK_SLOT);                        \
    EnterCriticalSection(&ChangeOrderLockTable[(_slot_)])

#define ChgOrdReleaseLock(_slot_)                                       \
    FRS_ASSERT((_slot_) != UNDEFINED_LOCK_SLOT);                        \
    LeaveCriticalSection(&ChangeOrderLockTable[(_slot_)])


//
// Get/Release the change order lock based on the File Guid
//
#define ChgOrdAcquireLockGuid(_coe_) {                                  \
     ULONG __Slot =  ChgOrdGuidLock( &((_coe_)->Cmd.FileGuid));         \
     ChgOrdAcquireLock(__Slot);                                         \
}

#define ChgOrdReleaseLockGuid(_coe_)  {                                 \
     ULONG __Slot =  ChgOrdGuidLock( &((_coe_)->Cmd.FileGuid));         \
     ChgOrdReleaseLock(__Slot);                                         \
}


//
// Process Handle
//
extern HANDLE   ProcessHandle;

//
// if TRUE then preserve existing file GUIDs whenever possible.
//
extern BOOL  PreserveFileOID;

#define  QUADZERO  ((ULONGLONG)0)

//
// Some Time Conversions.
//
#define CONVERT_FILETIME_TO_HOURS         ((ULONGLONG)60L * 60L * 1000L * 1000L * 10L)
#define CONVERT_FILETIME_TO_MINUTES             ((ULONGLONG)60L * 1000L * 1000L * 10L)
#define CONVERT_FILETIME_TO_DAYS    ((ULONGLONG)24L * 60L * 60L * 1000L * 1000L * 10L)
#define ONEDAY                 ((ULONGLONG)1L * 24L * 60L * 60L * 1000L * 1000L * 10L)



#define  WSTR_EQ(_a_, _b_)  (_wcsicmp(_a_, _b_) == 0)
#define  WSTR_NE(_a_, _b_)  (_wcsicmp(_a_, _b_) != 0)

#define  ASTR_EQ(_a_, _b_)  (_stricmp(_a_, _b_) == 0)
#define  ASTR_NE(_a_, _b_)  (_stricmp(_a_, _b_) != 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\info.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    info.h

Abstract:

    Header file for the internal information interfaces (util\info.c)

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _NTFRS_INFO_INCLUDED_
#define _NTFRS_INFO_INCLUDED_
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define IPRINT0(_Info, _Format)   \
    InfoPrint(_Info, _Format)

#define IPRINT1(_Info, _Format, _p1)   \
    InfoPrint(_Info, _Format, _p1)

#define IPRINT2(_Info, _Format, _p1, _p2)   \
    InfoPrint(_Info, _Format, _p1, _p2)

#define IPRINT3(_Info, _Format, _p1, _p2, _p3)   \
    InfoPrint(_Info, _Format, _p1, _p2, _p3)

#define IPRINT4(_Info, _Format, _p1, _p2, _p3, _p4)   \
    InfoPrint(_Info, _Format, _p1, _p2, _p3, _p4)

#define IPRINT5(_Info, _Format, _p1, _p2, _p3, _p4, _p5)   \
    InfoPrint(_Info, _Format, _p1, _p2, _p3, _p4, _p5)

#define IPRINT6(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6)   \
    InfoPrint(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6)

#define IPRINT7(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)   \
    InfoPrint(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)


#define IDPRINT0(_Severity, _Info, _Format) \
    if (_Info) { \
        IPRINT0(_Info, _Format); \
    } else { \
        DPRINT(_Severity, _Format); \
    }

#define IDPRINT1(_Severity, _Info, _Format, _p1) \
    if (_Info) { \
        IPRINT1(_Info, _Format, _p1); \
    } else { \
        DPRINT1(_Severity, _Format, _p1); \
    }

#define IDPRINT2(_Severity, _Info, _Format, _p1, _p2) \
    if (_Info) { \
        IPRINT2(_Info, _Format, _p1, _p2); \
    } else { \
        DPRINT2(_Severity, _Format, _p1, _p2); \
    }

#define IDPRINT3(_Severity, _Info, _Format, _p1, _p2, _p3) \
    if (_Info) { \
        IPRINT3(_Info, _Format, _p1, _p2, _p3); \
    } else { \
        DPRINT3(_Severity, _Format, _p1, _p2, _p3); \
    }

#define IDPRINT4(_Severity, _Info, _Format, _p1, _p2, _p3, _p4) \
    if (_Info) { \
        IPRINT4(_Info, _Format, _p1, _p2, _p3, _p4); \
    } else { \
        DPRINT4(_Severity, _Format, _p1, _p2, _p3, _p4); \
    }

#define IDPRINT5(_Severity, _Info, _Format, _p1, _p2, _p3, _p4, _p5) \
    if (_Info) { \
        IPRINT5(_Info, _Format, _p1, _p2, _p3, _p4, _p5); \
    } else { \
        DPRINT5(_Severity, _Format, _p1, _p2, _p3, _p4, _p5); \
    }

#define IDPRINT6(_Severity, _Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6) \
    if (_Info) { \
        IPRINT6(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6); \
    } else { \
        DPRINT6(_Severity, _Format, _p1, _p2, _p3, _p4, _p5, _p6); \
    }

#define IDPRINT7(_Severity, _Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7) \
    if (_Info) { \
        IPRINT7(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7); \
    } else { \
        DPRINT7(_Severity, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7); \
    }

//
// Used by FrsPrintType and its subroutines
//
//  WARNING - THESE MACROS DEPEND ON LOCAL VARIABLES!
//
#define ITPRINT0(_Format) \
{ \
    if (Info) { \
        IPRINT0(Info, _Format); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo); \
    } \
}
#define ITPRINT1(_Format, _p1) \
{ \
    if (Info) { \
        IPRINT1(Info, _Format, _p1); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, _p1); \
    } \
}
#define ITPRINT2(_Format, _p1, _p2) \
{ \
    if (Info) { \
        IPRINT2(Info, _Format, _p1, _p2); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, _p1, _p2); \
    } \
}
#define ITPRINT3(_Format, _p1, _p2, _p3) \
{ \
    if (Info) { \
        IPRINT3(Info, _Format, _p1, _p2, _p3); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, _p1, _p2, _p3); \
    } \
}
#define ITPRINT4(_Format, _p1, _p2, _p3, _p4) \
{ \
    if (Info) { \
        IPRINT4(Info, _Format, _p1, _p2, _p3, _p4); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, _p1, _p2, _p3, _p4); \
    } \
}
#define ITPRINT5(_Format, _p1, _p2, _p3, _p4, _p5) \
{ \
    if (Info) { \
        IPRINT3(Info, _Format, _p1, _p2, _p3, _p4, _p5); \
    } else { \
        DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, _p1, _p2, _p3, _p4, _p5); \
    } \
}

#define ITPRINTGNAME(_GName, _Format)                                          \
{                                                                              \
    if ((_GName) && (_GName)->Guid && (_GName)->Name) {                        \
        GuidToStr(_GName->Guid, Guid);                                         \
        if (Info) {                                                            \
            IPRINT3(Info, _Format, TabW, (_GName)->Name, Guid);                \
        } else {                                                               \
            DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, TabW, (_GName)->Name, Guid); \
        }                                                                      \
    }                                                                          \
}

#define ITPRINTGUID(_Guid, _Format)                                            \
{                                                                              \
    if ((_Guid)) {                                                             \
        GuidToStr((_Guid), Guid);                                              \
        if (Info) {                                                            \
            IPRINT2(Info, _Format, TabW, Guid);                                \
        } else {                                                               \
            DebPrintNoLock(Severity, TRUE, _Format, Debsub, uLineNo, TabW, Guid); \
        }                                                                      \
    }                                                                          \
}


VOID
FrsPrintAllocStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );
/*++
Routine Description:
    Print the memory stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/

//
// PrettyPrint (set tabs at 3 wchars)
//
#define MAX_TABS        (16)
#define MAX_TAB_WCHARS  (MAX_TABS * 3)
VOID
InfoTabs(
    IN DWORD    Tabs,
    IN PWCHAR   TabW
    );
/*++
Routine Description:
    Create a string of tabs for prettyprint

Arguments:
    Tabs    - number of tabs
    TabW    - preallocated string to receive tabs

Return Value:
    Win32 Status
--*/

DWORD
Info(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    );
/*++
Routine Description:
    Return internal info (see private\net\inc\ntfrsapi.h).

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/

VOID
InfoPrint(
    IN PNTFRSAPI_INFO   Info,
    IN PCHAR            Format,
    IN ... );
/*++
Routine Description:
    Format and print a line of information output into the info buffer.

Arguments:
    Info    - Info buffer
    Format  - printf format

Return Value:
    None.
--*/

DWORD
InfoVerify(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    );
/*++
Routine Description:
    Verify the consistency of the blob.

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/

//
// Context global to InfoPrintIDTable...
//
typedef struct _INFO_TABLE{
    PREPLICA            Replica;
    PTHREAD_CTX         ThreadCtx;
    PTABLE_CTX          TableCtx;
    PNTFRSAPI_INFO      Info;
    DWORD               Tabs;
} INFO_TABLE, *PINFO_TABLE;

//
// Context used to resume dumps of ntfrs tables across calls from ntfrsutl.exe
// see info.c
//

typedef struct _FRS_INFO_CONTEXT{
    ULONG       ContextIndex;        // Index into the Hash table of contexts.
    ULONG       SaveTotalChars;      // Saved value from Info struct.
                                     // Needed to continue non table dumps (threads, stage).
    FILETIME    LastAccessTime;      // Last time this context was used.
    PINFO_TABLE InfoTable;           // Info about the open table.
    ULONG       ReplicaNumber;
    PWCHAR      TableName;
    TABLE_TYPE  TableType;
    ULONG       Indexx;
    PVOID       KeyValue;
    INT         ScanDirection;       // -1,0,1 (only -1 and 1 used at this point)
} FRS_INFO_CONTEXT, *PFRS_INFO_CONTEXT;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\perrepsr.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perrepsr.h

Abstract:

    This header file contains definitions of data structures used by the
    functions in the perrepsr.c file.

Author:

    Rohan Kumar          [rohank]   13-Sept-1998

Environment:

    User Mode Service

Revision History:


--*/

#ifndef _PERREPSR_H_
#define _PERREPSR_H_

#include <NTreppch.h>
#pragma hdrstop

#include <wchar.h>
#include <frs.h>

#include <winperf.h>

//
//  REMOVE THE BELOW ONCE THE CHECKIN IS DONE TO WINPERF.H
//
#ifndef  WINPERF_LOG_NONE

//
// The following are the possible values for
// HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\EventLogLevel
// The default is WINPERF_LOG_NONE if the registry value is not defined.
// This should be adopted by all perfdlls to avoid flooding the application
// event log.
//

#define  WINPERF_LOG_NONE       0           // No event reported
#define  WINPERF_LOG_USER       1           // Report only errors
#define  WINPERF_LOG_DEBUG      2           // Report debug errors as well
#define  WINPERF_LOG_VERBOSE    3           // Report everything

#endif



//
// Used in the RegEnumValue function
//
#define SIZEOFVALUENAME 10
#define SIZEOFVALUEDATA 10000
#define INVALIDKEY 0
#define HASHTABLESIZE sizeof(QHASH_ENTRY)*100
#define PERFMON_MAX_INSTANCE_LENGTH 1024

#define REPSETOBJSUBKEY   L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet"
#define REPSETPERFSUBKEY  L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Performance"
#define REPSETLINSUBKEY   L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Linkage"
#define REPSETOPENFN      L"OpenReplicaSetPerformanceData"
#define REPSETCLOSEFN     L"CloseReplicaSetPerformanceData"
#define REPSETCOLLECTFN   L"CollectReplicaSetPerformanceData"
#define LDCTRAPP          L"%SystemRoot%\\system32\\lodctr.exe"
#define REPSETINI         LDCTRAPP L" %SystemRoot%\\system32\\NTFRSREP.ini"
#define UNLDCTRAPP        L"%SystemRoot%\\system32\\unlodctr.exe"
#define REPSETUNLD        UNLDCTRAPP L" FileReplicaSet"

#define REPCONNOBJSUBKEY  L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn"
#define REPCONNPERFSUBKEY L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Performance"
#define REPCONNLINSUBKEY  L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Linkage"
#define REPCONNOPENFN     L"OpenReplicaConnPerformanceData"
#define REPCONNCLOSEFN    L"CloseReplicaConnPerformanceData"
#define REPCONNCOLLECTFN  L"CollectReplicaConnPerformanceData"
#define REPCONNINI        LDCTRAPP L" %SystemRoot%\\system32\\NTFRSCON.ini"
#define REPCONNUNLD       UNLDCTRAPP L" FileReplicaConn"

#define PERFDLLDIRECTORY  L"%SystemRoot%\\system32\\NTFRSPRF.dll"



//
// Name of the Total Instance
//
#define TOTAL_NAME L"_Total"

//
// Macros used for incrementing or setting counter values for Replica Set
// objects, connection objects and Service total counters.
//

//
// Increment a replica set counter value.
//
#define PM_INC_CTR_REPSET(_Replica_, _Ctr_, _Value_)                           \
{                                                                              \
    if (((_Replica_) != NULL) &&                                               \
         ((_Replica_)->PerfRepSetData != NULL) &&                              \
         ((_Replica_)->PerfRepSetData->oid != NULL)) {                         \
                                                                               \
        (_Replica_)->PerfRepSetData->FRSCounter._Ctr_ += (_Value_);            \
    }                                                                          \
}

//
// Set a new value for a replica set perfmon counter.
//
#define PM_SET_CTR_REPSET(_Replica_, _Ctr_, _Value_)                           \
{                                                                              \
    if (((_Replica_) != NULL) &&                                               \
         ((_Replica_)->PerfRepSetData != NULL) &&                              \
         ((_Replica_)->PerfRepSetData->oid != NULL)) {                         \
                                                                               \
        (_Replica_)->PerfRepSetData->FRSCounter._Ctr_ = (_Value_);             \
    }                                                                          \
}

//
// Read the value for a replica set perfmon counter.
//
#define PM_READ_CTR_REPSET(_Replica_, _Ctr_)                                   \
(                                                                              \
    (((_Replica_) != NULL) &&                                                  \
     ((_Replica_)->PerfRepSetData != NULL) &&                                  \
     ((_Replica_)->PerfRepSetData->oid != NULL)) ?                             \
         ((_Replica_)->PerfRepSetData->FRSCounter._Ctr_) : 0                   \
)


//
// Increment a Cxtion counter value.
//
#define PM_INC_CTR_CXTION(_Cxtion_, _Ctr_, _Value_)                            \
{                                                                              \
    if (((_Cxtion_) != NULL) &&                                                \
        ((_Cxtion_)->PerfRepConnData != NULL) &&                               \
        ((_Cxtion_)->PerfRepConnData->oid != NULL)) {                          \
        (_Cxtion_)->PerfRepConnData->FRCCounter._Ctr_ += (_Value_);            \
    }                                                                          \
}

//
// Set a new value for a Cxtion perfmon counter.
//
#define PM_SET_CTR_CXTION(_Cxtion_, _Ctr_, _Value_)                            \
{                                                                              \
    if (((_Cxtion_) != NULL) &&                                                \
        ((_Cxtion_)->PerfRepConnData != NULL) &&                               \
        ((_Cxtion_)->PerfRepConnData->oid != NULL)) {                          \
        (_Cxtion_)->PerfRepConnData->FRCCounter._Ctr_ = (_Value_);             \
    }                                                                          \
}

//
// Read the value for a Cxtion perfmon counter.
//
#define PM_READ_CTR_CXTION(_Cxtion_, _Ctr_)                                    \
(                                                                              \
    (((_Cxtion_) != NULL) &&                                                   \
     ((_Cxtion_)->PerfRepConnData != NULL) &&                                  \
     ((_Cxtion_)->PerfRepConnData->oid != NULL)) ?                             \
         ((_Cxtion_)->PerfRepConnData->FRCCounter._Ctr_) : 0                   \
)


//
// Increment a Service Wide Total counter value.
//
#define PM_INC_CTR_SERVICE(_Total_, _Ctr_, _Value_)                            \
{                                                                              \
    if (((_Total_) != NULL) && ((_Total_)->oid != NULL)) {                     \
        (_Total_)->FRSCounter._Ctr_ += (_Value_);                              \
    }                                                                          \
}

//
// Set a new value for a Service Wide Total counter value.
//
#define PM_SET_CTR_SERVICE(_Total_, _Ctr_, _Value_)                            \
{                                                                              \
    if (((_Total_) != NULL) && ((_Total_)->oid != NULL)) {                     \
        (_Total_)->FRSCounter._Ctr_ = (_Value_);                               \
    }                                                                          \
}

//
// Read the value for a Service Wide Total counter.
//
#define PM_READ_CTR_SERVICE(_Total_, _Ctr_)                                    \
(                                                                              \
    (((_Total_) != NULL) && ((_Total_)->oid != NULL)) ?                        \
         ((_Total_)->FRSCounter._Ctr_) : 0                                     \
)


//
// The global variables below are used to synchronize access to the variables
// FRS_dwOpenCount and FRC_dwOpenCount respectively.
//
CRITICAL_SECTION FRS_ThrdCounter;
CRITICAL_SECTION FRC_ThrdCounter;

//
// EventLog Handle and severity level which controls if log entry is made.
//
extern HANDLE hEventLog;
//extern BOOLEAN DoLogging;
extern DWORD   PerfEventLogLevel;
//
// Macro to filter eventlog messages
//
// Only print if severity level of message is less than or equal to the current
// perfmon event log level from the registry value:
//   "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\EventLogLevel"
// Each eventlog message is only printed once per loading of the dll.
//
#define FilterAndPrintToEventLog(_sev_, _once_, _evid_)         \
{                                                               \
        if (/*DoLogging && */ (PerfEventLogLevel >= (_sev_))) { \
            if (_once_) {                                       \
                ReportEvent(hEventLog,                          \
                            EVENTLOG_ERROR_TYPE,                \
                            0,                                  \
                            _evid_,                             \
                            (PSID)NULL,                         \
                            0,                                  \
                            0,                                  \
                            NULL,                               \
                            (PVOID)NULL);                       \
                _once_ = FALSE;                                 \
            }                                                   \
        }                                                       \
}

//
// This is used in the Open function where memory gets allocated.
// If memory allocation fails, just return failure.
//
#define NTFRS_MALLOC_TEST(_x_, _y_, _z_)             \
{                                                    \
    if ((_x_) == NULL) {                             \
        if (_z_) {                                   \
            RpcBindingFree(&Handle);                 \
        }                                            \
        _y_;                                         \
        return  ERROR_NO_SYSTEM_RESOURCES;           \
    }                                                \
}

//
// Object Types
//
enum object { REPLICASET, REPLICACONN };

//
// The PERFMON_OBJECT_ID data structure
//
typedef struct _PERFMON_OBJECT_ID {
    PWCHAR name;   // name of the Instance
    ULONGLONG key; // The Instances's Unique Key
} PERFMON_OBJECT_ID, *PPERFMON_OBJECT_ID;


//
// WARNING !!!! The fields in the structure below should be changed
// if any new counters are to be added or deleted for the REPLICASET Object
// The counter structure for the ReplicaSet Object Instance
//
typedef struct _REPLICASET_COUNTERS {
    ULONGLONG SFGeneratedB;     // Bytes of Staging Generated
    ULONGLONG SFFetchedB;       // Bytes of Staging Fetched
    ULONGLONG SFReGeneratedB;   // Bytes of Staging Regenerated
    ULONGLONG FInstalledB;      // Bytes of Files Installed
    ULONGLONG SSInUseKB;        // KB of Staging Space In Use
    ULONGLONG SSFreeKB;         // KB of Staging Space Free
    ULONGLONG PacketsRcvdBytes; // Packets Received in Bytes
    ULONGLONG PacketsSentBytes; // Packets Sent in Bytes
    ULONGLONG FetBSentBytes;    // Fetch Blocks Sent in Bytes
    ULONGLONG FetBRcvdBytes;    // Fetch Blocks Received in Bytes
    ULONG SFGenerated;          // Staging Files Generated
    ULONG SFGeneratedError;     // Staging Files Generated with Error
    ULONG SFFetched;            // Staging Files Fetched
    ULONG SFReGenerated;        // Staging Files Regenerated
    ULONG FInstalled;           // Files Installed
    ULONG FInstalledError;      // Files Installed with Error
    ULONG COIssued;             // Change Orders Issued
    ULONG CORetired;            // Change Orders Retired
    ULONG COAborted;            // Change Orders Aborted
    ULONG CORetried;            // Change Orders Retried
    ULONG CORetriedGen;         // Change Orders Retried at Generate
    ULONG CORetriedFet;         // Change Orders Retried at Fetch
    ULONG CORetriedIns;         // Change Orders Retried at Install
    ULONG CORetriedRen;         // Change Orders Retried at Rename
    ULONG COMorphed;            // Change Orders Morphed
    ULONG COPropagated;         // Change Orders Propagated
    ULONG COReceived;           // Change Orders Received
    ULONG COSent;               // Change Orders Sent
    ULONG COEvaporated;         // Change Orders Evaporated
    ULONG LCOIssued;            // Local Change Orders Issued
    ULONG LCORetired;           // Local Change Orders Retired
    ULONG LCOAborted;           // Local Change Orders Aborted
    ULONG LCORetried;           // Local Change Orders Retried
    ULONG LCORetriedGen;        // Local Change Orders Retried at Generate
    ULONG LCORetriedFet;        // Local Change Orders Retried at Fetch
    ULONG LCORetriedIns;        // Local Change Orders Retried at Install
    ULONG LCORetriedRen;        // Local Change Orders Retried at Rename
    ULONG LCOMorphed;           // Local Change Orders Morphed
    ULONG LCOPropagated;        // Local Change Orders Propagated
    ULONG LCOSent;              // Local Change Orders Sent
    ULONG LCOSentAtJoin;        // Local Change Orders Sent At Join
    ULONG RCOIssued;            // Remote Change Orders Issued
    ULONG RCORetired;           // Remote Change Orders Retired
    ULONG RCOAborted;           // Remote Change Orders Aborted
    ULONG RCORetried;           // Remote Change Orders Retried
    ULONG RCORetriedGen;        // Remote Change Orders Retried at Generate
    ULONG RCORetriedFet;        // Remote Change Orders Retried at Fetch
    ULONG RCORetriedIns;        // Remote Change Orders Retried at Install
    ULONG RCORetriedRen;        // Remote Change Orders Retried at Rename
    ULONG RCOMorphed;           // Remote Change Orders Morphed
    ULONG RCOPropagated;        // Remote Change Orders Propagated
    ULONG RCOSent;              // Remote Change Orders Sent
    ULONG RCOReceived;          // Remote Change Orders Received
    ULONG InCODampned;          // Inbound Change Orders Dampened
    ULONG OutCODampned;         // Outbound Change Orders Dampened
    ULONG UsnReads;             // Usn Reads
    ULONG UsnRecExamined;       // Usn Records Examined
    ULONG UsnRecAccepted;       // Usn Records Accepted
    ULONG UsnRecRejected;       // Usn Records Rejected
    ULONG PacketsRcvd;          // Packets Received
    ULONG PacketsRcvdError;     // Packets Received in Error
    ULONG PacketsSent;          // Packets Sent
    ULONG PacketsSentError;     // Packets Sent in Error
    ULONG CommTimeouts;         // Communication Timeouts
    ULONG FetRSent;             // Fetch Requests Sent
    ULONG FetRReceived;         // Fetch Requests Received
    ULONG FetBSent;             // Fetch Blocks Sent
    ULONG FetBRcvd;             // Fetch Blocks Received
    ULONG JoinNSent;            // Join Notifications Sent
    ULONG JoinNRcvd;            // Join Notifications Received
    ULONG Joins;                // Joins
    ULONG Unjoins;              // Unjoins
    ULONG Bindings;             // Bindings
    ULONG BindingsError;        // Bindings in Error
    ULONG Authentications;      // Authentications
    ULONG AuthenticationsError; // Authentications in Error
    ULONG DSPolls;              // DS Polls
    ULONG DSPollsWOChanges;     // DS Polls without Changes
    ULONG DSPollsWChanges;      // DS Polls with Changes
    ULONG DSSearches;           // DS Searches
    ULONG DSSearchesError;      // DS Searches in Error
    ULONG DSObjects;            // DS Objects
    ULONG DSObjectsError;       // DS Objects in Error
    ULONG DSBindings;           // DS Bindings
    ULONG DSBindingsError;      // DS Bindings in Error
    ULONG RSCreated;            // Replica Sets Created
    ULONG RSDeleted;            // Replica Sets Deleted
    ULONG RSRemoved;            // Replica Sets Removed
    ULONG RSStarted;            // Replica Sets Started
//    ULONG RSRepaired;           // Replica Sets Repaired
//    ULONG Threads;              // Threads
    ULONG ThreadsStarted;       // Threads started
    ULONG ThreadsExited;        // Threads exited
} ReplicaSetCounters, *PReplicaSetCounters;

//
// Size of the structure above
//
#define SIZEOF_REPSET_COUNTER_DATA sizeof(ReplicaSetCounters)


//
// The data structure for the ReplicaSet Object Instance
//
typedef struct _HASHTABLEDATA_REPLICASET {
    PPERFMON_OBJECT_ID oid;       // The Instance ID
    PREPLICA RepBackPtr;           // Back pointer to the replica structure
    ReplicaSetCounters FRSCounter; // The counter structure
} HT_REPLICA_SET_DATA, *PHT_REPLICA_SET_DATA;

//
// The Total Instance
//
extern PHT_REPLICA_SET_DATA PMTotalInst;

//
// WARNING !!!! The fields in the structure below should be changed
// if any new counters are to be added or deleted for the REPLICACONN Object
// The counter structure for the ReplicaConn Object Instance
//
typedef struct _REPLICACONN_COUNTERS {
    ULONGLONG PacketsSentBytes; // Packets Sent in Bytes
    ULONGLONG FetBSentBytes;    // Fetch Blocks Sent in Bytes
    ULONGLONG FetBRcvdBytes;    // Fetch Blocks Received in Bytes
    ULONG LCOSent;              // Local Change Orders Sent
    ULONG LCOSentAtJoin;        // Local Change Orders Sent At Join
    ULONG RCOSent;              // Remote Change Orders Sent
    ULONG RCOReceived;          // Remote Change Orders Received
    ULONG InCODampned;          // Inbound Change Orders Dampened
    ULONG OutCODampned;         // Outbound Change Orders Dampened
    ULONG PacketsSent;          // Packets Sent
    ULONG PacketsSentError;     // Packets Sent in Error
    ULONG CommTimeouts;         // Communication Timeouts
    ULONG FetRSent;             // Fetch Requests Sent
    ULONG FetRReceived;         // Fetch Requests Received
    ULONG FetBSent;             // Fetch Blocks Sent
    ULONG FetBRcvd;             // Fetch Blocks Received
    ULONG JoinNSent;            // Join Notifications Sent
    ULONG JoinNRcvd;            // Join Notifications Received
    ULONG Joins;                // Joins
    ULONG Unjoins;              // Unjoins
    ULONG Bindings;             // Bindings
    ULONG BindingsError;        // Bindings in Error
    ULONG Authentications;      // Authentications
    ULONG AuthenticationsError; // Authentications in Error
} ReplicaConnCounters, *PReplicaConnCounters;


//
// Size of the structure above
//
#define SIZEOF_REPCONN_COUNTER_DATA  sizeof(ReplicaConnCounters)

//
// The data structure for the ReplicaConn Object Instance
//
typedef struct _HASHTABLEDATA_REPLICACONN {
    PPERFMON_OBJECT_ID oid;         // The Instance ID
    ReplicaConnCounters FRCCounter; // The counter structure
} HT_REPLICA_CONN_DATA, *PHT_REPLICA_CONN_DATA;



//
// Signature's of exported functions defined in the perrepsr.c file
//
VOID
InitializePerfmonServer (
    VOID
    );

VOID
ShutdownPerfmonServer (
    VOID
    );

ULONG
AddPerfmonInstance (
    IN DWORD ObjectType,
    IN PVOID addr,
    IN PWCHAR InstanceName
    );

DWORD
DeletePerfmonInstance(
    IN DWORD ObjectType,
    IN PVOID addr
    );


#endif // perrepsr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\replutil.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    replutil.h

Abstract:

    Header file for utility routines for the NT File Replication Service.

Author:

    David A. Orbits (davidor)  3-Mar-1997 Created

Environment:

    User Mode Service

Revision History:

--*/
#ifndef _REPLUTIL_INCLUDED_
#define _REPLUTIL_INCLUDED_
#endif

#ifdef __cplusplus
extern "C" {
#endif



#include <frserror.h>

#include <config.h>


#define BACKSLASH_CHAR  TEXT('\\')
#define COLON_CHAR      TEXT(':')
#define DOT_CHAR        TEXT('.')

#define UNICODE_STAR    (L'*')
#define UNICODE_QMARK   (L'?')
#define UNICODE_SPACE   0x0020
#define UNICODE_TAB     0x0009


#define TIME_STRING_LENGTH 32
//
// The maximum length of a volume label.  This is defined in ntos\inc\io.h
// but since this is the only def needed from io.h it is copied here.  sigh!
//
#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

#define GUID_CHAR_LEN 40

#define OBJECT_ID_LENGTH  sizeof(GUID)
#define FILE_ID_LENGTH    sizeof(ULONGLONG)

//#define GUIDS_EQUAL(_a_, _b_) (memcmp((_a_), (_b_), sizeof(GUID)) == 0)

__inline
int
GuidsEqual( GUID UNALIGNED * a, GUID UNALIGNED * b){
            return (memcmp( a, b, sizeof(GUID)) == 0);
}

#define GUIDS_EQUAL(_a_, _b_) GuidsEqual((GUID UNALIGNED *)(_a_), (GUID UNALIGNED *)(_b_))

//#define COPY_GUID(_a_, _b_)    CopyMemory((_a_), (_b_), sizeof(GUID))

__inline
VOID
CopyGuid( GUID UNALIGNED * a, GUID UNALIGNED * b){
            CopyMemory( a, b, sizeof(GUID));
}

#define COPY_GUID(_a_, _b_)    CopyGuid((GUID UNALIGNED *)(_a_), (GUID UNALIGNED *)(_b_))

#define IS_GUID_ZERO(_g_) ((*((PULONG)(_g_)+0) |                     \
                            *((PULONG)(_g_)+1) |                     \
                            *((PULONG)(_g_)+2) |                     \
                            *((PULONG)(_g_)+3) ) == 0)


//#define COPY_TIME(_a_, _b_)   CopyMemory((_a_), (_b_), sizeof(FILETIME))

__inline
VOID
CopyTime( FILETIME UNALIGNED * a, FILETIME UNALIGNED * b){
            CopyMemory( a, b, sizeof(FILETIME));
}

#define COPY_TIME(_a_, _b_)   CopyTime((FILETIME UNALIGNED *)(_a_), (FILETIME UNALIGNED *)(_b_))

#define IS_TIME_ZERO(_g_) ((*((PULONG)(&(_g_))+0) | *((PULONG)(&(_g_))+1) ) == 0)

//
// A few macros for working with MD5 checksums.
//
#define IS_MD5_CHKSUM_ZERO(_x_)                                              \
    (((*(((PULONG) (_x_))+0)) | (*(((PULONG) (_x_))+1)) |                    \
      (*(((PULONG) (_x_))+2)) | (*(((PULONG) (_x_))+3)) ) == (ULONG) 0)

#define MD5_EQUAL(_a_, _b_) (memcmp((_a_), (_b_), MD5DIGESTLEN) == 0)



//
// Is a handle valid?
//      Some functions set the handle to NULL and some to
//      INVALID_HANDLE_VALUE (-1). This define handles both
//      cases.
//
#define HANDLE_IS_VALID(_Handle)  ((_Handle) && ((_Handle) != INVALID_HANDLE_VALUE))

//
// Only close valid handles and then set the handle invalid.
//   FRS_CLOSE(handle);
//
#define FRS_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        CloseHandle(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }

//
// Only close valid registry key handles and then set the handle invalid.
//   FRS_REG_CLOSE(handle);
//
#define FRS_REG_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        RegCloseKey(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }

#define FRS_FIND_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        FindClose(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }


DWORD
FrsResetAttributesForReplication(
    PWCHAR  Name,
    HANDLE  Handle
    );

LONG
FrsIsParent(
    IN PWCHAR   Directory,
    IN PWCHAR   Path
    );

LPTSTR
FrsSupInitPath(
    OUT LPTSTR OutPath,
    IN  LPTSTR InPath,
    IN  ULONG  MaxOutPath
    );

ULONG
FrsForceDeleteFile(
    PTCHAR DestName
    );

VOID
FrsForceDeleteFileByWildCard(
    PWCHAR      DirPath,
    PWCHAR      WildCard
    );

HANDLE
FrsCreateEvent(
    IN  BOOL    ManualReset,
    IN  BOOL    InitialState
    );

HANDLE
FrsCreateWaitableTimer(
    IN  BOOL    ManualReset
    );

ULONG
FrsUuidCreate(
    OUT GUID *Guid
    );

VOID
FrsNowAsFileTime(
    IN  PLONGLONG   Now
    );

VOID
FileTimeToString(
    IN FILETIME *FileTime,
    OUT PCHAR    Buffer         // buffer must be at least 32 bytes long.
    );


VOID
FileTimeToStringClockTime(
    IN FILETIME *FileTime,
    OUT PCHAR     Buffer        // buffer must be at least 9 bytes long.
    );


DWORD
GeneralizedTimeToSystemTime(
    IN PWCHAR          szTime,
    OUT PSYSTEMTIME    psysTime
    );

VOID
FormatGeneralizedTime(
    IN PWCHAR  GTimeStr,
    IN ULONG   Length,
    OUT PCHAR  Buffer
    );

VOID
GuidToStr(
    IN GUID  *pGuid,
    OUT PCHAR  s
    );

VOID
GuidToStrW(
    IN GUID  *pGuid,
    OUT PWCHAR  ws
    );

BOOL
StrWToGuid(
    IN  PWCHAR  ws,
    OUT GUID  *pGuid
    );

VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    );

NTSTATUS
SetupOnePrivilege (
    ULONG Privilege,
    PUCHAR PrivilegeName
    );

PWCHAR
FrsGetResourceStr(
    LONG  Id
);


//
// Convenient DesiredAccess
//
#define READ_ATTRIB_ACCESS  (FILE_READ_ATTRIBUTES | SYNCHRONIZE)

#define WRITE_ATTRIB_ACCESS  (FILE_WRITE_ATTRIBUTES | SYNCHRONIZE)

#define READ_ACCESS         (GENERIC_READ | GENERIC_EXECUTE | SYNCHRONIZE)

#define ATTR_ACCESS         (READ_ACCESS  | FILE_WRITE_ATTRIBUTES)

#define WRITE_ACCESS        (GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE)

#define RESTORE_ACCESS      (READ_ACCESS        | \
                             WRITE_ACCESS       | \
                             WRITE_DAC          | \
                             WRITE_OWNER)

#define OPLOCK_ACCESS       (FILE_READ_ATTRIBUTES)

//
// Convenient CreateOptions
//
#define OPEN_OPTIONS        (FILE_OPEN_FOR_BACKUP_INTENT     | \
                             FILE_SEQUENTIAL_ONLY            | \
                             FILE_OPEN_NO_RECALL             | \
                             FILE_OPEN_REPARSE_POINT         | \
                             FILE_SYNCHRONOUS_IO_NONALERT)
#define ID_OPTIONS          (OPEN_OPTIONS | FILE_OPEN_BY_FILE_ID)

#define OPEN_OPLOCK_OPTIONS (FILE_RESERVE_OPFILTER | FILE_OPEN_REPARSE_POINT)
#define ID_OPLOCK_OPTIONS   (FILE_OPEN_FOR_BACKUP_INTENT | \
                             FILE_RESERVE_OPFILTER       | \
                             FILE_OPEN_REPARSE_POINT     | \
                             FILE_OPEN_BY_FILE_ID)

//
// convenient ShareMode
//
#define SHARE_ALL   (FILE_SHARE_READ |  \
                     FILE_SHARE_WRITE | \
                     FILE_SHARE_DELETE)
#define SHARE_NONE  (0)

//
// File attributes that prevent installation and prevent
// hammering the object id.
//
#define NOREPL_ATTRIBUTES   (FILE_ATTRIBUTE_READONLY | \
                             FILE_ATTRIBUTE_SYSTEM   | \
                             FILE_ATTRIBUTE_HIDDEN)

DWORD
FrsOpenSourceFileW(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions
    );

DWORD
FrsOpenSourceFile2W(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode
    );

DWORD
FrsCheckReparse(
    IN     PWCHAR Name,
    IN     PVOID  Id,
    IN     DWORD  IdLen,
    IN     HANDLE VolumeHandle
    );

DWORD
FrsDeleteReparsePoint(
    IN  HANDLE  Handle
    );

DWORD
FrsChaseSymbolicLink(
    IN  PWCHAR  SymLink,
    OUT PWCHAR  *OutPrintName,
    OUT PWCHAR  *OutSubstituteName
    );

DWORD
FrsTraverseReparsePoints(
    IN  PWCHAR  SuppliedPath,
    OUT PWCHAR  *RealPath
    );

DWORD
FrsOpenSourceFileById(
    OUT PHANDLE     Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo,
    OUT OVERLAPPED  *OverLap,
    IN  HANDLE      VolumeHandle,
    IN  PVOID       ObjectId,
    IN  ULONG       Length,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode,
    IN  ULONG       CreateDispostion
    );

PWCHAR
FrsGetFullPathByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    );

PWCHAR
FrsGetRelativePathByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    );

DWORD
FrsCreateFileRelativeById(
    OUT PHANDLE Handle,
    IN  HANDLE  VolumeHandle,
    IN  PVOID   ParentObjectId,
    IN  ULONG   OidLength,
    IN  ULONG   FileCreateAttributes,
    IN  PWCHAR  BaseFileName,
    IN  USHORT  FileNameLength,
    IN  PLARGE_INTEGER  AllocationSize,
    IN  ULONG           CreateDisposition,
    IN  ACCESS_MASK     DesiredAccess
    );

DWORD
FrsCreateFileRelativeById2(
    OUT PHANDLE Handle,
    IN  HANDLE  VolumeHandle,
    IN  PVOID   ParentObjectId,
    IN  ULONG   OidLength,
    IN  ULONG   FileCreateAttributes,
    IN  PWCHAR  BaseFileName,
    IN  USHORT  FileNameLength,
    IN  PLARGE_INTEGER  AllocationSize,
    IN  ULONG           CreateDisposition,
    IN  ACCESS_MASK     DesiredAccess,
    IN  ULONG           ShareMode
    );

DWORD
FrsOpenFileRelativeByName(
    IN  HANDLE     VolumeHandle,
    IN  PULONGLONG FileReferenceNumber,
    IN  PWCHAR     FileName,
    IN  GUID       *ParentGuid,
    IN  GUID       *FileGuid,
    OUT HANDLE     *Handle
    );

typedef struct _QHASH_TABLE_ QHASH_TABLE, *PQHASH_TABLE;
DWORD
FrsDeleteFileRelativeByName(
    IN  HANDLE       VolumeHandle,
    IN  GUID         *ParentGuid,
    IN  PWCHAR       FileName,
    IN  PQHASH_TABLE FrsWriteFilter
    );

DWORD
FrsDeleteFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName
    );

DWORD
FrsGetOrSetFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName,
    IN  BOOL CallerSupplied,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

DWORD
FrsReadFileUsnData(
    IN  HANDLE Handle,
    OUT USN *UsnBuffer
    );

DWORD
FrsMarkHandle(
    IN HANDLE   VolumeHandle,
    IN HANDLE   Handle
    );

DWORD
FrsReadFileParentFid(
    IN  HANDLE     Handle,
    OUT ULONGLONG *ParentFid
    );

DWORD
FrsDeletePath(
    IN  PWCHAR  Path,
    IN DWORD    DirectoryFlags
    );

DWORD
FrsRestrictAccessToFileOrDirectory(
    PWCHAR  Name,
    HANDLE  Handle,
    BOOL    InheritFromParent,
    BOOL    PushToChildren
    );


VOID
FrsAddToMultiString(
    IN     PWCHAR   AddStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    );

VOID
FrsCatToMultiString(
    IN     PWCHAR   CatStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    );

BOOL
FrsSearchArgv(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PWCHAR *ArgValue
    );

BOOL
FrsSearchArgvDWord(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PDWORD  ArgValue
    );

BOOL
FrsDissectCommaList (
    IN UNICODE_STRING RawArg,
    OUT PUNICODE_STRING FirstArg,
    OUT PUNICODE_STRING RemainingArg
    );

BOOL
FrsCheckNameFilter(
    IN  PUNICODE_STRING Name,
    IN  PLIST_ENTRY FilterListHead
    );

VOID
FrsEmptyNameFilter(
    IN PLIST_ENTRY FilterListHead
);

VOID
FrsLoadNameFilter(
    IN PUNICODE_STRING FilterString,
    IN PLIST_ENTRY FilterListHead
);

ULONG
FrsParseIntegerCommaList(
    IN PWCHAR ArgString,
    IN ULONG MaxResults,
    OUT PLONG Results,
    OUT PULONG NumberResults,
    OUT PULONG Offset
);

//
//  Unicode Name support routines, implemented in Name.c
//
//  The routines here are used to manipulate unicode names
//  The code is copied here from FsRtl because it calls the pool allocator.
//

//
//  The following macro is used to determine if a character is wild.
//
#define FrsIsUnicodeCharacterWild(C) (                               \
    (((C) == UNICODE_STAR) || ((C) == UNICODE_QMARK))                \
)

VOID
FrsDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    );

BOOLEAN
FrsDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    );

BOOLEAN
FrsAreNamesEqual (
    IN PUNICODE_STRING ConstantNameA,
    IN PUNICODE_STRING ConstantNameB,
    IN BOOLEAN IgnoreCase,
    IN PCWCH UpcaseTable OPTIONAL
    );

BOOLEAN
FrsIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable OPTIONAL
    );


//
// The following is taken from clusrtl.h
//
//
//  Routine Description:
//
//      Initializes the FRS run time library.
//
//  Arguments:
//
//      RunningAsService  - TRUE if the process is running as an NT service.
//                          FALSE if running as a console app.
//
//  Return Value:
//
//      ERROR_SUCCESS if the function succeeds.
//      A Win32 error code otherwise.
//
DWORD
FrsRtlInitialize(
    IN  BOOL    RunningAsService
    );


//
//  Routine Description:
//
//      Cleans up the FRS run time library.
//
//  Arguments:
//
//      RunningAsService  - TRUE if the process is running as an NT service.
//                          FALSE if running as a console app.
//
//  Return Value:
//
//      None.
//
VOID
FrsRtlCleanup(
    VOID
    );


//
//  PLIST_ENTRY
//  GetListHead(
//      PLIST_ENTRY ListHead
//      );
//
#define GetListHead(ListHead) ((ListHead)->Flink)

//
//  PLIST_ENTRY
//  GetListTail(
//      PLIST_ENTRY ListHead
//      );
//
#define GetListTail(ListHead) ((ListHead)->Blink)
//
//  PLIST_ENTRY
//  GetListNext(
//      PLIST_ENTRY Entry
//      );
//
#define GetListNext(Entry) ((Entry)->Flink)

//
//  VOID
//  FrsRemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//
// *NOTE*  The Flink/Blink of the removed entry are set to NULL to cause an
// Access violation if a thread is following a list and an element is removed.
// UNFORTUNATELY there is still code that depends on this, perhaps through
// remove head/tail.  Sigh.  For now leave as is.
//
#define FrsRemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_Entry;\
    _EX_Entry = (Entry);\
    _EX_Flink = _EX_Entry->Flink;\
    _EX_Blink = _EX_Entry->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_Entry->Flink = _EX_Entry->Blink = _EX_Entry;\
    }


//
//  VOID
//  RemoveEntryListB(
//      PLIST_ENTRY Entry
//      );
//
// The BillyF version of remove entry list.  The Flink/Blink of the removed
// entry are set to the entry address.
//
#define RemoveEntryListB(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_Entry;\
    _EX_Entry = (Entry);\
    _EX_Flink = _EX_Entry->Flink;\
    _EX_Blink = _EX_Entry->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_Entry->Flink = _EX_Entry->Blink = _EX_Entry;\
    }


//
// Traverse a singlely linked NULL terminated list.
// Pass in the address of the list head, the type of the containing record,
// the offset to the link entry in the conatining record, and code for
// the loop body.  pE is the iterator and is of type specified.
// Within the loop body the macros InsertSingleListEntry() and
// RemoveSingleListEntry() can be used to do the obvious things.
//

#define ForEachSingleListEntry( _HEAD_, _TYPE_, _OFFSET_, _STMT_ ) \
{                                                             \
    PSINGLE_LIST_ENTRY __Entry, __NextEntry, __PrevEntry;     \
    _TYPE_ *pE;                                               \
                                                              \
    __Entry = (_HEAD_);                                       \
    __NextEntry = (_HEAD_)->Next;                             \
                                                              \
    while (__PrevEntry = __Entry, __Entry = __NextEntry, __Entry != NULL) { \
                                                              \
        __NextEntry = __Entry->Next;                          \
        pE = CONTAINING_RECORD(__Entry, _TYPE_, _OFFSET_);    \
                                                              \
        { _STMT_ }                                            \
                                                              \
    }                                                         \
                                                              \
}
//
// The following three macros are only valid within the loop body above.
// Insert an entry before the current entry with pointer pE.
//
#define InsertSingleListEntry( _Item_, _xOFFSET_ ) \
    (_Item_)->_xOFFSET_.Next = __Entry;            \
    __PrevEntry->Next = (PSINGLE_LIST_ENTRY) &((_Item_)->_xOFFSET_);

//
// Note that after you remove an entry the value for __Entry is set back to
// the __PrevEntry so when the loop continues __PrevEntry doesn't change
// since current entry had been removed.
//
#define RemoveSingleListEntry( _UNUSED_ )  \
    __PrevEntry->Next = __NextEntry;       \
    __Entry->Next = NULL;                  \
    __Entry = __PrevEntry;

//
// Return ptr to the previous node.  Only valid inside above FOR loop.
// Useful when deleting the current entry.
//
#define PreviousSingleListEntry( _TYPE_, _OFFSET_)  \
    CONTAINING_RECORD(__PrevEntry, _TYPE_, _OFFSET_)


//
// General-purpose queue package.  Taken from cluster\clusrtl.c
// *** WARNING ***  To make the macros work properly for both lists and queues
// the first five items in FRS_LIST and FRS_QUEUE MUST match.
//
typedef struct _FRS_QUEUE FRS_QUEUE, *PFRS_QUEUE;
struct _FRS_QUEUE {
    LIST_ENTRY          ListHead;
    CRITICAL_SECTION    Lock;
    DWORD               Count;
    PFRS_QUEUE          Control;
    DWORD               ControlCount;

    HANDLE              Event;
    HANDLE              RunDown;
    ULONG               InitTime;
    LIST_ENTRY          Full;
    LIST_ENTRY          Empty;
    LIST_ENTRY          Idled;
    BOOL                IsRunDown;
    BOOL                IsIdled;
};

VOID
FrsInitializeQueue(
    IN PFRS_QUEUE Queue,
    IN PFRS_QUEUE Control
    );

VOID
FrsRtlDeleteQueue(
    IN PFRS_QUEUE Queue
    );

PLIST_ENTRY
FrsRtlRemoveHeadQueue(
    IN PFRS_QUEUE Queue
    );

VOID
FrsRtlUnIdledQueue(
    IN PFRS_QUEUE   IdledQueue
    );

VOID
FrsRtlUnIdledQueueLock(
    IN PFRS_QUEUE   IdledQueue
    );

VOID
FrsRtlIdleQueue(
    IN PFRS_QUEUE   Queue
    );

VOID
FrsRtlIdleQueueLock(
    IN PFRS_QUEUE Queue
    );

PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeoutIdled(
    IN PFRS_QUEUE   Queue,
    IN DWORD        dwMilliseconds,
    OUT PFRS_QUEUE  *IdledQueue
    );

PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeout(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    );

VOID
FrsRtlRemoveEntryQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    );

DWORD
FrsRtlWaitForQueueFull(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    );

DWORD
FrsRtlInsertTailQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

DWORD
FrsRtlInsertHeadQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

VOID
FrsRtlRunDownQueue(
    IN PFRS_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    );

#define FrsRtlAcquireQueueLock(_pQueue_) \
            EnterCriticalSection(&(((_pQueue_)->Control)->Lock))

#define FrsRtlReleaseQueueLock(_pQueue_) \
            LeaveCriticalSection(&(((_pQueue_)->Control)->Lock))

#define FrsRtlCountQueue(_pQueue_) \
            (((_pQueue_)->Control)->ControlCount)

#define FrsRtlCountSubQueue(_pQueue_) \
            ((_pQueue_)->Count)

#define FrsRtlNoIdledQueues(_pQueue_) \
            (IsListEmpty(&(((_pQueue_)->Control)->Idled)))


//
// The Lock suffix on the routines below means the user already has the
// queue lock.
//
VOID
FrsRtlRemoveEntryQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    );

DWORD
FrsRtlInsertTailQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

DWORD
FrsRtlInsertHeadQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

//
// COMMAND SERVER
// A command server is a dynamic pool of threads and a controlled queue
//      The default queue is set up as a controlled queue. Other
//      controlled queues can be added in a server specific manner.
// A command server exports an initialize, abort, and none or more
// submit routines. The parameters and names of these functions is
// server specific. The consumers of a server's interface are intimate
// with the server.
//
typedef struct _COMMAND_SERVER  COMMAND_SERVER, *PCOMMAND_SERVER;
struct _COMMAND_SERVER {
    DWORD           MaxThreads;     // Max # of threads
    DWORD           FrsThreads;     // current # of frs threads
    DWORD           Waiters;        // current # of frs threads waiting
    PWCHAR          Name;           // Thread's name
    HANDLE          Idle;           // No active threads; no queue entries
    DWORD           (*Main)(PVOID); // Thread's entry point
    FRS_QUEUE       Control;        // controlling queue
    FRS_QUEUE       Queue;          // queue
};

//
// Interlocked list.
// *** WARNING ***  To make the macros work properly for both lists and queues
// the first five items in FRS_LIST and FRS_QUEUE MUST match.
//
typedef struct _FRS_LIST FRS_LIST, *PFRS_LIST;
struct _FRS_LIST {
    LIST_ENTRY ListHead;
    CRITICAL_SECTION Lock;
    DWORD Count;
    PFRS_LIST Control;
    DWORD ControlCount;
};


DWORD
FrsRtlInitializeList(
    PFRS_LIST List
    );

VOID
FrsRtlDeleteList(
    PFRS_LIST List
    );

PLIST_ENTRY
FrsRtlRemoveHeadList(
    IN PFRS_LIST List
    );

VOID
FrsRtlInsertHeadList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );

PLIST_ENTRY
FrsRtlRemoveTailList(
    IN PFRS_LIST List
    );

VOID
FrsRtlInsertTailList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );

VOID
FrsRtlRemoveEntryList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );


#define FrsRtlAcquireListLock(_pList_) EnterCriticalSection(&(((_pList_)->Control)->Lock))

#define FrsRtlReleaseListLock(_pList_) LeaveCriticalSection(&(((_pList_)->Control)->Lock))

#define FrsRtlCountList(_pList_) (((_pList_)->Control)->ControlCount)


VOID
FrsRtlRemoveEntryListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );

VOID
FrsRtlInsertTailListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );

VOID
FrsRtlInsertHeadListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    );


//VOID
//FrsRtlInsertBeforeEntryListLock(
//    IN PFRS_LIST List,
//    IN PLIST_ENTRY BeforeEntry
//    IN PLIST_ENTRY NewEntry
//    )
//
//    Inserts newEntry before the BeforeEntry on the interlocked list (List).
//    This is used to keep the list elements in ascending order by KeyValue.
//
//    Assumes caller already has the list lock.
//

#define  FrsRtlInsertBeforeEntryListLock( _List, _BeforeEntry, _NewEntry ) \
    InsertTailList((_BeforeEntry), (_NewEntry)); \
    (_List)->Count += 1; \
    ((_List)->Control)->ControlCount += 1; \


//
// Walk thru an interlocked queue or list (_QUEUE_) with elements of type
// _TYPE_ and execute {_STMT_} for each one.  The list entry in _TYPE_ is
// at _OFFSET_.  Use pE in the statement body as a pointer to the entry.
// The entry may be removed from within the loop since we capture the
// link to the next entry before executing the loop body.  You may also use
// 'continue' within the loop body because the assignment of nextentry to entry
// is in a comma expression inside the while test.
//

#define ForEachListEntry( _QUEUE_, _TYPE_, _OFFSET_, _STMT_ ) \
{                                                             \
    PLIST_ENTRY __Entry, __NextEntry;                         \
    BOOL __Hold__=FALSE;                                      \
    _TYPE_ *pE;                                               \
                                                              \
    FrsRtlAcquireQueueLock(_QUEUE_);                          \
    __NextEntry = GetListHead(&((_QUEUE_)->ListHead));        \
                                                              \
    while (__Entry = __NextEntry, __Entry != &((_QUEUE_)->ListHead)) { \
                                                              \
        __NextEntry = GetListNext(__Entry);                   \
        pE = CONTAINING_RECORD(__Entry, _TYPE_, _OFFSET_);    \
                                                              \
        { _STMT_ }                                            \
                                                              \
    }                                                         \
                                                              \
    if (!__Hold__) FrsRtlReleaseQueueLock(_QUEUE_);           \
                                                              \
}

#define AquireListLock( _QUEUE_ )  FrsRtlAcquireListLock(_QUEUE_)
#define ReleaseListLock( _QUEUE_ ) FrsRtlReleaseListLock(_QUEUE_)

#define BreakAndHoldLock __Hold__ = TRUE; break


//
// Just like the above except the caller already has the list lock.
//

#define ForEachListEntryLock( _QUEUE_, _TYPE_, _OFFSET_, _STMT_ ) \
{                                                             \
    PLIST_ENTRY __Entry, __NextEntry;                         \
    _TYPE_ *pE;                                               \
                                                              \
    __NextEntry = GetListHead(&((_QUEUE_)->ListHead));        \
                                                              \
    while (__Entry = __NextEntry, __Entry != &((_QUEUE_)->ListHead)) {  \
                                                              \
        __NextEntry = GetListNext(__Entry);                   \
        pE = CONTAINING_RECORD(__Entry, _TYPE_, _OFFSET_);    \
                                                              \
        { _STMT_ }                                            \
                                                              \
    }                                                         \
                                                              \
}


//
// Just like the above except pass in the address of the list head
// instead of using QUEUE->ListHEad.
//

#define ForEachSimpleListEntry( _HEAD_, _TYPE_, _OFFSET_, _STMT_ ) \
{                                                             \
    PLIST_ENTRY __Entry, __NextEntry;                         \
    _TYPE_ *pE;                                               \
                                                              \
    __NextEntry = GetListHead(_HEAD_);                        \
                                                              \
    while (__Entry = __NextEntry, __Entry != (_HEAD_)) {      \
                                                              \
        __NextEntry = GetListNext(__Entry);                   \
        pE = CONTAINING_RECORD(__Entry, _TYPE_, _OFFSET_);    \
                                                              \
        { _STMT_ }                                            \
                                                              \
    }                                                         \
                                                              \
}


//VOID
//FrsRtlInsertQueueOrdered(
//    IN PFRS_QUEUE List,
//    IN PLIST_ENTRY NewEntry,
//    IN <Entry-Data-Type>,
//    IN <LIST_ENTRY-offset-name>,
//    IN <Orderkey-Offset-name>,
//    IN EventHandle or NULL
//    )
//
//    Inserts NewEntry on an ordered queue of <Entry-Data-Type> elements.
//    The offset to the LIST_ENTRY in each element is <LIST_ENTRY-offset-name>
//    The offset to the Ordering key (.eg. a ULONG) is <Orderkey-Offset-name>
//    It acquires the List Lock.
//    The list elements are kept in ascending order by KeyValue.
//    If a new element is placed at the head of the queue and the EventHandle
//    is non-NULL, the event is signalled.
//
//
#define FrsRtlInsertQueueOrdered(                                           \
    _QUEUE_, _NEWENTRY_, _TYPE_, _OFFSET_, _BY_, _EVENT_, _STATUS_)         \
{                                                                           \
    BOOL __InsertDone = FALSE;                                              \
    BOOL __FirstOnQueue = TRUE;                                             \
    _STATUS_ = ERROR_SUCCESS;                                               \
                                                                            \
    FrsRtlAcquireQueueLock(_QUEUE_);                                        \
                                                                            \
    ForEachListEntryLock(_QUEUE_, _TYPE_, _OFFSET_,                         \
                                                                            \
        /* pE is loop iterator of type _TYPE_                          */   \
                                                                            \
        if ((_NEWENTRY_)->_BY_ < pE->_BY_) {                                \
            FrsRtlInsertBeforeEntryListLock( _QUEUE_,                       \
                                             &pE->_OFFSET_,                 \
                                             &((_NEWENTRY_)->_OFFSET_));    \
            __InsertDone = TRUE;                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        __FirstOnQueue = FALSE;                                             \
    );                                                                      \
                                                                            \
    /* Handle new head or new tail case.  If the queue was previously  */   \
    /* the insert will set the event.                                  */   \
                                                                            \
    if (!__InsertDone) {                                                    \
        if (__FirstOnQueue) {                                               \
            _STATUS_ = FrsRtlInsertHeadQueueLock(_QUEUE_, &((_NEWENTRY_)->_OFFSET_));  \
        } else {                                                            \
            _STATUS_ = FrsRtlInsertTailQueueLock(_QUEUE_, &((_NEWENTRY_)->_OFFSET_));  \
        }                                                                   \
    }                                                                       \
                                                                            \
    /* If this command became the new first one on the queue and the   */   \
    /* queue wasn't previously empty we have to set the event here to  */   \
    /* get the thread to readjust its wait time.                       */   \
                                                                            \
    if (__FirstOnQueue &&                                                   \
        (FrsRtlCountQueue(_QUEUE_) != 1)) {                                 \
        if (HANDLE_IS_VALID(_EVENT_)) {                                     \
            SetEvent(_EVENT_);                                              \
        }                                                                   \
    }                                                                       \
                                                                            \
    FrsRtlReleaseQueueLock(_QUEUE_);                                        \
                                                                            \
}



//VOID
//FrsRtlInsertListOrdered(
//    IN PFRS_LIST List,
//    IN PLIST_ENTRY NewEntry,
//    IN <Entry-Data-Type>,
//    IN <LIST_ENTRY-offset-name>,
//    IN <Orderkey-Offset-name>,
//    IN EventHandle or NULL
//    )
//
//    Inserts NewEntry on an ordered list of <Entry-Data-Type> elements.
//    The offset to the LIST_ENTRY in each element is <LIST_ENTRY-offset-name>
//    The offset to the Ordering key (.eg. a ULONG) is <Orderkey-Offset-name>
//    It acquires the List Lock.
//    The list elements are kept in ascending order by KeyValue.
//    If a new element is placed at the head of the queue and the EventHandle
//    is non-NULL, the event is signalled.
//
//
#define FrsRtlInsertListOrdered(                                            \
    _FRSLIST_, _NEWENTRY_, _TYPE_, _OFFSET_, _BY_, _EVENT_)                 \
{                                                                           \
    BOOL __InsertDone = FALSE;                                              \
    BOOL __FirstOnList = TRUE;                                              \
                                                                            \
    FrsRtlAcquireListLock(_FRSLIST_);                                       \
                                                                            \
    ForEachListEntryLock(_FRSLIST_, _TYPE_, _OFFSET_,                       \
                                                                            \
        /* pE is loop iterator of type _TYPE_                          */   \
                                                                            \
        if ((_NEWENTRY_)->_BY_ < pE->_BY_) {                                \
            FrsRtlInsertBeforeEntryListLock( _FRSLIST_,                     \
                                             &pE->_OFFSET_,                 \
                                             &((_NEWENTRY_)->_OFFSET_));    \
            __InsertDone = TRUE;                                            \
            break;                                                          \
        }                                                                   \
                                                                            \
        __FirstOnList = FALSE;                                              \
    );                                                                      \
                                                                            \
    /* Handle new head or new tail case. */                                 \
                                                                            \
    if (!__InsertDone) {                                                    \
        if (__FirstOnList) {                                                \
            FrsRtlInsertHeadListLock(_FRSLIST_, &((_NEWENTRY_)->_OFFSET_)); \
        } else {                                                            \
            FrsRtlInsertTailListLock(_FRSLIST_, &((_NEWENTRY_)->_OFFSET_)); \
        }                                                                   \
    }                                                                       \
                                                                            \
    /* If this command became the new first one on the list              */ \
    /* we set the event here to get the thread to readjust its wait time.*/ \
                                                                            \
    if (__FirstOnList) {                                                    \
        if (HANDLE_IS_VALID(_EVENT_)) {                                     \
            SetEvent(_EVENT_);                                              \
        }                                                                   \
    }                                                                       \
                                                                            \
    FrsRtlReleaseListLock(_FRSLIST_);                                       \
                                                                            \
}



//
// Request counts are used as a simple means for tracking the number of
// command requests that are pending so the requestor can wait until
// all the commands have been processed.
//
typedef struct _FRS_REQUEST_COUNT FRS_REQUEST_COUNT, *PFRS_REQUEST_COUNT;
struct _FRS_REQUEST_COUNT {
    CRITICAL_SECTION    Lock;
    LONG                Count;     // Number of requests active
    HANDLE              Event;     // Event set when count goes to zero.
    ULONG               Status;    // Optional status return
};


#define FrsIncrementRequestCount(_RC_)     \
    EnterCriticalSection(&(_RC_)->Lock);   \
    (_RC_)->Count += 1;                    \
    if ((_RC_)->Count == 1) {              \
        ResetEvent((_RC_)->Event);         \
    }                                      \
    LeaveCriticalSection(&(_RC_)->Lock);


#define FrsDecrementRequestCount(_RC_, _Status_)   \
    EnterCriticalSection(&(_RC_)->Lock);   \
    (_RC_)->Status |= _Status_;            \
    (_RC_)->Count -= 1;                    \
    FRS_ASSERT((_RC_)->Count >= 0);        \
    if ((_RC_)->Count == 0) {              \
        SetEvent((_RC_)->Event);           \
    }                                      \
    LeaveCriticalSection(&(_RC_)->Lock);


ULONG
FrsWaitOnRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount,
    IN ULONG Timeout
    );


struct _COMMAND_PACKET;
VOID
FrsCompleteRequestCount(
    IN struct _COMMAND_PACKET *CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    );

VOID
FrsCompleteRequestCountKeepPkt(
    IN struct _COMMAND_PACKET *CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    );

VOID
FrsCompleteKeepPkt(
    IN struct _COMMAND_PACKET *CmdPkt,
    IN PVOID           CompletionArg
    );

VOID
FrsInitializeRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    );

VOID
FrsDeleteRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    );

VOID
FrsDeleteAllTempFiles(
    );


#define FrsInterlockedIncrement64(_Dest_, _Data_, _Lock_) \
    EnterCriticalSection(_Lock_);                         \
    _Data_ += (ULONGLONG) 1;                              \
    _Dest_ = (_Data_);                                    \
    LeaveCriticalSection(_Lock_);


//
//  ADVANCE_VALUE_INTERLOCKED(
//      IN PULONG _dest,
//      IN ULONG  _newval
//  )
//  Advance the destination to the value given in newval atomically using
//  interlocked exchange.  _dest is never moved to a smaller value so this
//  is a no-op if _newval is < _dest.
//
//  *NOTE* Other operations on _dest MUST be done with interlocked ops like
//  InterlockedIncrement to ensure that an incremented value is not lost if
//  it occurs simultaneously on another processor.
//
#define ADVANCE_VALUE_INTERLOCKED(_dest, _newval)  {                           \
    ULONG CurVal, SaveCurVal, Result, *pDest = (_dest);                        \
    CurVal = SaveCurVal = *pDest;                                              \
    while ((_newval) > CurVal) {                                               \
        Result = (ULONG)InterlockedCompareExchange((PLONG)pDest, (_newval), CurVal); \
        if (Result == CurVal) {                                                \
            break;                                                             \
        }                                                                      \
        CurVal = Result;                                                       \
    }                                                                          \
    FRS_ASSERT(*pDest >= SaveCurVal);                                          \
}

//
//
// Avoiding a torn quadword result (without a crit sect) when 1 thread is
// writing a quadord and another is reading the quadword, or,
// 2 threads are writing the same quadword.
//
// To do this in alpha we need an assembler routine to use load_locked / store_cond.
// To do this in x86 (per DaveC):
#if 0
    if (USER_SHARED_DATA->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] == FALSE) {
        // code to use a crit section.
    } else {
        // code to use inline assembly with cmpxchg8b.
    }
#endif
// KUSER_SHARED_DATA is defined in sdk\inc\ntxapi.h
// USER_SHARED_DATA is an arch specific typecast pointer to KUSER_SHARED_DATA.
// User shared data has a processor feature list with a cell for
// PF_COMPARE_EXCHANGE_DOUBLE that tells if the processor supports
// the cmpxchg8b instruction for x86.  The 486 doesn't have it.
//
#define ReadQuadLock(_qw, _Lock)  \
    (EnterCriticalSection((_Lock)), *(_qw))

#define WriteQuadUnlock(_qw, _newval, _Lock)  \
    *(_qw) = (_newval);                       \
    LeaveCriticalSection((_Lock))

#define AcquireQuadLock(_Lock)  EnterCriticalSection((_Lock))
#define ReleaseQuadLock(_Lock)  LeaveCriticalSection((_Lock))



//
//  SET_FLAG_INTERLOCKED(
//      IN PULONG _dest,
//      IN ULONG  _flags
//  )
//
//  *NOTE* Other operations on _dest MUST be done with interlocked ops like
//  InterlockedIncrement to ensure that an incremented value is not lost if
//  it occurs simultaneously on another processor.
//
#define SET_FLAG_INTERLOCKED(_dest, _flags)  {                                 \
    ULONG CurVal, NewVal, Result, *pDest = (_dest);                            \
    CurVal = *pDest;                                                           \
    NewVal = (_flags) | CurVal;                                                \
    while ((NewVal) != CurVal) {                                               \
        Result = (ULONG)InterlockedCompareExchange((PLONG)pDest, NewVal, CurVal);    \
        if (Result == CurVal) {                                                \
            break;                                                             \
        }                                                                      \
        CurVal = Result;                                                       \
        NewVal = (_flags) | CurVal;                                            \
    }                                                                          \
}


//
//  CLEAR_FLAG_INTERLOCKED(
//      IN PULONG _dest,
//      IN ULONG  _flags
//  )
//
//  *NOTE* Other operations on _dest MUST be done with interlocked ops like
//  InterlockedIncrement to ensure that an incremented value is not lost if
//  it occurs simultaneously on another processor.
//
#define CLEAR_FLAG_INTERLOCKED(_dest, _flags)  {                               \
    ULONG CurVal, NewVal, Result, *pDest = (_dest);                            \
    CurVal = *pDest;                                                           \
    NewVal = CurVal & ~(_flags);                                               \
    while ((NewVal) != CurVal) {                                               \
        Result = (ULONG)InterlockedCompareExchange((PLONG)pDest, NewVal, CurVal);    \
        if (Result == CurVal) {                                                \
            break;                                                             \
        }                                                                      \
        CurVal = Result;                                                       \
        NewVal = CurVal & ~(_flags);                                           \
    }                                                                          \
}



#define FlagOn(Flags,SingleFlag)  ((Flags) & (SingleFlag))

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))

#define SetFlag(_F,_SF) { \
    (_F) |= (_SF);        \
}

#define ClearFlag(_F,_SF) { \
    (_F) &= ~(_SF);         \
}

#define ValueIsMultOf2(_x_)  (((ULONG_PTR)(_x_) & 0x00000001) == 0)
#define ValueIsMultOf4(_x_)  (((ULONG_PTR)(_x_) & 0x00000003) == 0)
#define ValueIsMultOf8(_x_)  (((ULONG_PTR)(_x_) & 0x00000007) == 0)
#define ValueIsMultOf16(_x_) (((ULONG_PTR)(_x_) & 0x0000000F) == 0)


#define ARRAY_SZ(_ar)  (sizeof(_ar)/sizeof((_ar)[0]))
#define ARRAY_SZ2(_ar, _type)  (sizeof(_ar)/sizeof(_type))


//
// This macros below take a pointer (or ulong) and return the value rounded
// up to the next aligned boundary.
//
#define WordAlign(Ptr)     ((PVOID)((((ULONG_PTR)(Ptr)) + 1)  & ~1))
#define LongAlign(Ptr)     ((PVOID)((((ULONG_PTR)(Ptr)) + 3)  & ~3))
#define QuadAlign(Ptr)     ((PVOID)((((ULONG_PTR)(Ptr)) + 7)  & ~7))
#define DblQuadAlign(Ptr)  ((PVOID)((((ULONG_PTR)(Ptr)) + 15) & ~15))
#define QuadQuadAlign(Ptr) ((PVOID)((((ULONG_PTR)(Ptr)) + 31) & ~31))

#define QuadQuadAlignSize(Size) ((((ULONG)(Size)) + 31) & ~31)

//
// Check for a zero FILETIME.
//
#define FILETIME_IS_ZERO(_F_) \
    ((_F_.dwLowDateTime == 0) && (_F_.dwHighDateTime == 0))


//
// Convert a quad to two ULONGs for printing with format: %08x %08x
//
#define PRINTQUAD(__ARG__) (ULONG)((__ARG__)>>32) ,(ULONG)(__ARG__)

//
// Convert to printable cxtion path with format: %ws\%ws\%ws -> %ws\%ws
//
#define FORMAT_CXTION_PATH2  "%ws\\%ws\\%ws %ws %ws %ws"
#define FORMAT_CXTION_PATH2W  L"%ws\\%ws\\%ws %ws %ws %ws"
#define PRINT_CXTION_PATH2(_REPLICA, _CXTION)                       \
    (_REPLICA)->ReplicaName->Name,                                  \
    (_REPLICA)->MemberName->Name,                                   \
    (((_CXTION) != NULL) ? (_CXTION)->Name->Name : L"null"),        \
    (((_CXTION) != NULL) ? (((_CXTION)->Inbound) ? L"<-" : L"->") : \
                           L"?"),                                   \
    (((_CXTION) != NULL) ? (_CXTION)->PartSrvName : L"null"),       \
    (((_CXTION) != NULL) ? (((_CXTION)->JrnlCxtion) ? L"JrnlCxt" : L"RemoteCxt") : L"null")

#define PRINT_CXTION_PATH(_REPLICA, _CXTION)                    \
    (_REPLICA)->ReplicaName->Name,                              \
    (_REPLICA)->MemberName->Name,                               \
    (((_CXTION) != NULL) ? (_CXTION)->Name->Name : L"null"),    \
    (((_CXTION) != NULL) ? (_CXTION)->Partner->Name : L"null"), \
    (((_CXTION) != NULL) ? (_CXTION)->PartSrvName : L"null")

//
// Lower case
//
#define FRS_WCSLWR(_s_) \
{ \
    if (_s_) { \
        _wcslwr(_s_); \
    } \
}

//
// Lock to protect the child lists in the Filter Table.  (must be pwr of 2)
// Instead of paying the overhead of having one per node we just use an array
// to help reduce contention.  We use the ReplicaNumber masked by the lock
// table size as the index.
//
// Acquire the lock on the ReplicaSet Filter table Child List before
// inserting or removing a child from the list.
//
#define NUMBER_FILTER_TABLE_CHILD_LOCKS 8
extern CRITICAL_SECTION JrnlFilterTableChildLock[NUMBER_FILTER_TABLE_CHILD_LOCKS];

#define FILTER_TABLE_CHILD_INDEX(_x_) \
((ULONG)((_x_)->ReplicaNumber) & (NUMBER_FILTER_TABLE_CHILD_LOCKS - 1))

#define JrnlAcquireChildLock(_replica_) EnterCriticalSection( \
    &JrnlFilterTableChildLock[FILTER_TABLE_CHILD_INDEX(_replica_)] )

#define JrnlReleaseChildLock(_replica_) LeaveCriticalSection( \
    &JrnlFilterTableChildLock[FILTER_TABLE_CHILD_INDEX(_replica_)] )

//
// Renaming a subtree from one replica set to another requires the child locks
// for both replica sets.  Always get them in the same order (low to high)
// to avoid deadlock.  Also check if the both use the same lock.
// Note: The caller must use JrnlReleaseChildLockPair() so the check for
// using the same lock can be repeated.  Release in reverse order to avoid
// an extra context switch if another thread was waiting behind the first lock.
//
#define JrnlAcquireChildLockPair(_replica1_, _replica2_)        \
{                                                               \
    ULONG Lx1, Lx2, Lxt;                                        \
    Lx1 = FILTER_TABLE_CHILD_INDEX(_replica1_);                 \
    Lx2 = FILTER_TABLE_CHILD_INDEX(_replica2_);                 \
    if (Lx1 > Lx2) {                                            \
        Lxt = Lx1; Lx1 = Lx2; Lx2 = Lxt;                        \
    }                                                           \
    EnterCriticalSection(&JrnlFilterTableChildLock[Lx1]);       \
    if (Lx1 != Lx2) {                                           \
        EnterCriticalSection(&JrnlFilterTableChildLock[Lx2]);   \
    }                                                           \
}


#define JrnlReleaseChildLockPair(_replica1_, _replica2_)        \
{                                                               \
    ULONG Lx1, Lx2, Lxt;                                        \
    Lx1 = FILTER_TABLE_CHILD_INDEX(_replica1_);                 \
    Lx2 = FILTER_TABLE_CHILD_INDEX(_replica2_);                 \
    if (Lx1 < Lx2) {                                            \
        Lxt = Lx1; Lx1 = Lx2; Lx2 = Lxt;                        \
    }                                                           \
    LeaveCriticalSection(&JrnlFilterTableChildLock[Lx1]);       \
    if (Lx1 != Lx2) {                                           \
        LeaveCriticalSection(&JrnlFilterTableChildLock[Lx2]);   \
    }                                                           \
}

#ifdef __cplusplus
  }
#endif



ULONG
FrsRunProcess(
    IN PWCHAR   AppPathAndName,
    IN PWCHAR   CommandLine,
    IN HANDLE   StandardIn,
    IN HANDLE   StandardOut,
    IN HANDLE   StandardError
    );


VOID
FrsFlagsToStr(
    IN DWORD            Flags,
    IN PFLAG_NAME_TABLE NameTable,
    IN ULONG            Length,
    OUT PSTR            Buffer
    );


//
//######################### COMPRESSION OF STAGING FILE STARTS ###############
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _FRS_COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} FRS_COMPRESSED_CHUNK_HEADER, *PFRS_COMPRESSED_CHUNK_HEADER;

typedef struct _FRS_DECOMPRESS_CONTEXT {
    DWORD   BytesProcessed;
} FRS_DECOMPRESS_CONTEXT, *PFRS_DECOMPRESS_CONTEXT;

#define FRS_MAX_CHUNKS_TO_DECOMPRESS 16
#define FRS_UNCOMPRESSED_CHUNK_SIZE  4096

//
//######################### COMPRESSION OF STAGING FILE ENDS ###############
//


//
// This context is used to send data to the callback functions for the RAW
// encrypt APIs.
//
typedef struct _FRS_ENCRYPT_DATA_CONTEXT {

    PWCHAR         StagePath;
    HANDLE         StageHandle;
    LARGE_INTEGER  RawEncryptedBytes;

} FRS_ENCRYPT_DATA_CONTEXT, *PFRS_ENCRYPT_DATA_CONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\jet.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    jet.h

Abstract:

    Some macros for use with Frs Jet Table routines.

Author:

    David Orbits (davidor) - 7-Mar-1997

Revision History:

--*/

#include <esent.h>

#include <dns.h>
#include <md5.h>

#include "schema.h"

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }


#define OFFSET(type, field) ((LONG)((ULONG_PTR)&((type *)0)->field))

#define SIZEOF(type, field) ((LONG)(sizeof(((type *)0)->field)))

#define RECORD_FIELD(type, field, _dt)   ((LONG)((ULONG_PTR)&((type *)0)->field)) , \
                                      (USHORT)(_dt)                    , \
                                    ((LONG)(sizeof(((type *)0)->field)))


#define JET_COLUMN_ID_NIL 0xFFFFFFFF


//
// DbsRecordOperation options and special cases.
//
#define ROP_SEEK   0x00000000
#define ROP_READ   0x00000001
#define ROP_DELETE 0x00000002


#define DbsSeekRecord(_threadctx, _key, _index, _tablectx) \
        ( DbsRecordOperation(_threadctx, ROP_SEEK, _key, _index, _tablectx) )

#define DbsReadRecord(_threadctx, _key, _index, _tablectx) \
        ( DbsRecordOperation(_threadctx, ROP_READ, _key, _index, _tablectx) )

#define DbsDeleteRecord(_threadctx, _key, _index, _tablectx) \
        ( DbsRecordOperation(_threadctx, ROP_DELETE, _key, _index, _tablectx) )



//
// This macro closes a table and resets the TableCtx Tid and Sessid to Nil.
// It first checks for a mismatch between the current session ID and the ID
// in the TableCtx struct.
//
#define DbsCloseTable(_jerr, _Sesid, _TableCtx)                                \
                                                                               \
    if ((_TableCtx->Tid != JET_tableidNil) &&                                  \
        IS_REPLICA_TABLE(_TableCtx->TableType)) {                              \
        DPRINT4(5,"DbsCloseTable (%s%05d) Tid, Sesid = %08x, %08x\n",          \
                _TableCtx->pJetTableCreate->szTableName,                       \
                _TableCtx->ReplicaNumber,                                      \
                _TableCtx->Tid,                                                \
                _Sesid);                                                       \
                                                                               \
        if (_Sesid != _TableCtx->Sesid) {                                      \
            DPRINT4(0, "++ DbsCloseTable (%s%05d) bad sesid : %d should be %d\n", \
                _TableCtx->pJetTableCreate->szTableName,                       \
                _TableCtx->ReplicaNumber,                                      \
                _Sesid,                                                        \
                _TableCtx->Sesid);                                             \
            _jerr = JET_errInvalidSesid;                                       \
        } else {                                                               \
            _jerr = JetCloseTable(_Sesid, _TableCtx->Tid);                     \
            _TableCtx->Tid = JET_tableidNil;                                   \
            _TableCtx->Sesid = JET_sesidNil;                                   \
        }                                                                      \
    } else {                                                                   \
        DPRINT4(5,"ERROR - DbsCloseTable -- Table Already Closed or invalid tablectx." \
                "  TableType (%d)  ReplicaNum (%d)  Tid (%08x)  Sesid (%08x)\n", \
                _TableCtx->TableType,                                          \
                _TableCtx->ReplicaNumber,                                      \
                _TableCtx->Tid,                                                \
                _Sesid);                                                       \
        _jerr = JET_errSuccess;                                                \
    }



#define DBS_OPEN_TABLE(_ThreadCtx, _TableCtx, _ReplicaNumber, _TableName, _Tid) \
    (FrsOpenTableSaveTid = (_TableCtx)->Tid ,                  \
    DbsOpenTable0((_ThreadCtx), (_TableCtx), (_ReplicaNumber), (_TableName), (_Tid))); \
                                                               \
    if (FrsOpenTableSaveTid == JET_tableidNil) {               \
        DPRINT3(3,"FrsOpenTable  (%20s) Tid, Sesid = %08x, %08x\n",   \
                _TableName,                                    \
                _TableCtx->Tid,                                \
                _TableCtx->Sesid);                             \
    }


//
// Macros to reference fields in the Jet Ret/Set Column structs via a TableCtx.
//
#define FRS_GET_RFIELD_LENGTH_ACTUAL(_TableCtx, _Field)  (_TableCtx->pJetRetCol[_Field].cbActual)
#define FRS_GET_RFIELD_LENGTH_LIMIT( _TableCtx, _Field)  (_TableCtx->pJetRetCol[_Field].cbData)
#define FRS_GET_RFIELD_ERROR(        _TableCtx, _Field)  (_TableCtx->pJetRetCol[_Field].err)
#define FRS_GET_RFIELD_ADDRESS(      _TableCtx, _Field)  (_TableCtx->pJetRetCol[_Field].pvData)
#define FRS_GET_RFIELD_COLUMNID(     _TableCtx, _Field)  (_TableCtx->pJetRetCol[_Field].columnid)


#define FRS_GET_SFIELD_LENGTH_ACTUAL(_TableCtx, _Field)  (_TableCtx->pJetSetCol[_Field].cbData)
#define FRS_GET_SFIELD_LENGTH_LIMIT( _TableCtx, _Field)  (_TableCtx->pJetSetCol[_Field].cbData)
#define FRS_GET_SFIELD_ERROR(        _TableCtx, _Field)  (_TableCtx->pJetSetCol[_Field].err)
#define FRS_GET_SFIELD_ADDRESS(      _TableCtx, _Field)  (_TableCtx->pJetSetCol[_Field].pvData)
#define FRS_GET_SFIELD_COLUMNID(     _TableCtx, _Field)  (_TableCtx->pJetSetCol[_Field].columnid)


#if DBG
#define DBS_DISPLAY_RECORD_SEV(_Severity, _TableCtx, _Read)          \
    DbsDisplayRecord(_Severity, _TableCtx, _Read, DEBSUB, __LINE__, NULL, 0);

#define DBS_DISPLAY_RECORD_SEV_COLS(_Severity, _TableCtx, _Read, _Cols, _NumCols) \
    DbsDisplayRecord(_Severity, _TableCtx, _Read, DEBSUB, __LINE__, _Cols, _NumCols);

#define FRS_DISPLAY_RECORD(_TableCtx, _Read)             \
    DbsDisplayRecord(0, _TableCtx, _Read, DEBSUB, __LINE__, NULL, 0);
#else DBG
#define DBS_DISPLAY_RECORD_SEV(_Severity, _TableCtx, _Read)
#define DBS_DISPLAY_RECORD_SEV_COLS(_Severity, _TableCtx, _Read, _Cols, _NumCols)
#define FRS_DISPLAY_RECORD(_TableCtx, _Read)
#endif DBG



#define JET_SUCCESS(_Status)            ((_Status) == JET_errSuccess)

//
// Debug macro for table ctx struct.
//

#define DUMP_TABLE_CTX(_TableCtx)                                                     \
    DPRINT2(5,"++ TableCtx: %s, pTableCtx %08x\n", _TableCtx->pJetTableCreate->szTableName, _TableCtx);  \
    DPRINT1(5,"++ Sesid           =  %8d\n",  _TableCtx->Sesid);                          \
    DPRINT1(5,"++ Tid             =  %8d\n",  _TableCtx->Tid);                            \
    DPRINT1(5,"++ ReplicaNumber   =  %8d\n",  _TableCtx->ReplicaNumber);                  \
    DPRINT1(5,"++ TableType       =  %8d\n",  _TableCtx->TableType);                      \
    DPRINT1(5,"++ PropertyFlags   =  %08x\n", _TableCtx->PropertyFlags);                  \
    DPRINT1(5,"++ pJetTableCreate =  %08x\n", _TableCtx->pJetTableCreate);                \
    DPRINT1(5,"++ pRecordFields   =  %08x\n", _TableCtx->pRecordFields);                  \
    DPRINT1(5,"++ pJetSetCol      =  %08x\n", _TableCtx->pJetSetCol);                     \
    DPRINT1(5,"++ pJetRetCol      =  %08x\n", _TableCtx->pJetRetCol);                     \
    DPRINT1(5,"++ pDataRecord     =  %08x\n", _TableCtx->pDataRecord);                    \
    DPRINT1(5,"++ cColumns        =  %8d\n",  _TableCtx->pJetTableCreate->cColumns);      \
    DPRINT1(5,"++ rgcolumncreate  =  %08x\n", _TableCtx->pJetTableCreate->rgcolumncreate);\
    DPRINT1(5,"++ ulPages         =  %8d\n",  _TableCtx->pJetTableCreate->ulPages);       \
    DPRINT1(5,"++ ulDensity       =  %8d\n",  _TableCtx->pJetTableCreate->ulDensity);     \
    DPRINT1(5,"++ cIndexes        =  %8d\n",  _TableCtx->pJetTableCreate->cIndexes);      \
    DPRINT1(5,"++ rgindexcreate   =  %08x\n", _TableCtx->pJetTableCreate->rgindexcreate); \
    DPRINT1(5,"++ grbit           =  %08x\n", _TableCtx->pJetTableCreate->grbit);         \
    DPRINT1(5,"++ tableid         =  %8d\n",  _TableCtx->pJetTableCreate->tableid);       \
    DPRINT1(5,"++ cCreated objects=  %8d\n",  _TableCtx->pJetTableCreate->cCreated);      \
    DPRINT1(5,"++ TemplateTableName=  %s\n",  _TableCtx->pJetTableCreate->szTemplateTableName);










#if 0
//
// for future use.  from ntfsprop.h
//
//
//  VARIABLE_STRUCTURE_SIZE returns the size of a structure S that contains
//  an array of C structures V
//

#define VARIABLE_STRUCTURE_SIZE(S,V,C) ((int)sizeof( S ) + ((C) - 1) * (int)sizeof( V ))


typedef struct _PROPERTY_SPECIFIER
{
    ULONG Variant;                  //  Distinguish the type
    union {                         //  Switch on Variant
        PROPID Id;                  //  Property ID
        ULONG NameOffset;           //  Offset to COUNTED_STRING
    };
} PROPERTY_SPECIFIER, *PPROPERTY_SPECIFIER;


//
//  PROPERTY_SPECIFICATIONS is a serialized form of an array PROPERTY_SPECIFIERs.
//  Immediately following PROPERTY_SPECIFICATIONS on a USHORT boundary are
//  of the name strings.  Each name string is a COUNTED_STRING
//

typedef struct _PROPERTY_SPECIFICATIONS {
    ULONG Length;                   //  Length in bytes of structure and name strings
    ULONG Count;                    //  Count of PROPERTY_SPECIFIERS
    PROPERTY_SPECIFIER Specifiers[1];   //  Array of actual specifiers, length Count
} PROPERTY_SPECIFICATIONS, *PPROPERTY_SPECIFICATIONS;

#define PROPERTY_SPECIFICATIONS_SIZE(c) \
    (VARIABLE_STRUCTURE_SIZE( PROPERTY_SPECIFICATIONS, PROPERTY_SPECIFIER, (c) ))

#define PROPERTY_SPECIFIER_ID(PS,I)      \
    ((PS)->Specifiers[(I)].Id)

#define PROPERTY_SPECIFIER_COUNTED_STRING(PS,I)  \
    ((PCOUNTED_STRING)Add2Ptr( (PS), (PS)->Specifiers[(I)].NameOffset))

#define PROPERTY_SPECIFIER_NAME(PS,I)    \
    (&PROPERTY_SPECIFIER_COUNTED_STRING( PS, I )->Text[0])

#define PROPERTY_SPECIFIER_NAME_LENGTH(PS,I) \
    (PROPERTY_SPECIFIER_COUNTED_STRING( PS, I )->Length)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\schema.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    schema.h

Abstract:

    Defines the layout of the tables in Jet for the NT File Replication Service.

    Note:  The initial values for these tables are defined in schema.c
           Any change here must be reflected there.

       To add a new table xx:
           1.  Clone the structs for a current table.
           2.  Change the name prefixes appropriately
           3.  Create the xx_COL_LIST enum
           4.  Create the xxTABLE_RECORD struct
           5.  Create the xxTABLE_INDEX_LIST struct
           6.  Add an entry to the TABLE_TYPE enum

           Then go to schema.c and:

           7.  create the entries for the xxTableColDesc struct.
           8.  create the entries for the xxTableRecordFields struct.
           9.  create the entries for the xxTableIndexDesc struct.
           10. add defines for INIT_xxTABLE_PAGES and INIT_xxTABLE_DENSITY.
           11. Add an entry for the new table in the DBTables struct.
           12. Add an entry for the new table in the FrsTableProperties struct.

           Then go to frsalloc.h and:

           13. Add an entry for the table context struct in the
               REPLICA_THREAD_CTX struct or the REPLICA_CTX struct as appropriate.
           14. if there is any table specific init code needed as part of
               the allocation of another FRS struct then add this to FRS_ALLOC.
               Currently, once you have described the table as above the table
               init code is generic.
           15. Add code to create the record data for the table.


       To add a new column to an existing table:
            In schema.h -
            1. Add entry to the record struct.
            2. Add entry to the field typedef with an 'x' suffix and in the
               correct position relative to the other fields in the table.

            In schema.c -
            3. Add entry in the ColumnCreate struct for the record.
            4. Add entry in the record fields struct.

            5. Add code to update the new record data field.




Author:

    David Orbits (davidor) - 14-Mar-1997

Revision History:

--*/


//
// A Flag name table is an array of structures.  Each entry contains a flag
// mask and a ptr to a string describing the flag.
//
typedef struct _FLAG_NAME_TABLE_ {
    ULONG  Flag;
    PSTR   Name;
} FLAG_NAME_TABLE, *PFLAG_NAME_TABLE;



//
// Flag name tables for log output.
//
extern FLAG_NAME_TABLE CxtionFlagNameTable[];
extern FLAG_NAME_TABLE CoIFlagNameTable[];
extern FLAG_NAME_TABLE CoFlagNameTable[];
extern FLAG_NAME_TABLE CoeFlagNameTable[];
extern FLAG_NAME_TABLE IscuFlagNameTable[];
extern FLAG_NAME_TABLE IDRecFlagNameTable[];
extern FLAG_NAME_TABLE UsnReasonNameTable[];
extern FLAG_NAME_TABLE FileAttrFlagNameTable[];
extern FLAG_NAME_TABLE ConfigFlagNameTable[];

#define JET_DIR             L"jet"
#define JET_FILE            L"ntfrs.jdb"
#define JET_FILE_COMPACT    L"ntfrs_compact.jdb"
#define JET_SYS             L"sys\\"
#define JET_TEMP            L"temp\\"
#define JET_LOG             L"log\\"

//
// System wide defines for the database.
//
#define DBS_TEMPLATE_TABLE_NUMBER  0
#define DBS_FIRST_REPLICA_NUMBER   1
#define DBS_MAX_REPLICA_NUMBER     0xfffffff0

#define FRS_SYSTEM_INIT_REPLICA_NUMBER  0xffffffff
#define FRS_SYSTEM_INIT_RECORD TEXT("<init>")
#define FRS_SYSTEM_INIT_PATH   TEXT("::::Unused")

#define FRS_UNDEFINED_REPLICA_NUMBER  0xfffffffe

#define NTFRS_RECORD_0          L"NtFrs Record Zero (DB Templates)"
#define NTFRS_RECORD_0_ROOT     L"A:\\NtFrs Record Zero (DB Templates)\\Root"
#define NTFRS_RECORD_0_STAGE    L"A:\\NtFrs Record Zero (DB Templates)\\Stage"

//
// Convert local replica pointer to local replica ID for storing in database.
//
#define ReplicaAddrToId(_ra_)  (((_ra_) != NULL) ? \
    (_ra_)->ReplicaNumber : FRS_UNDEFINED_REPLICA_NUMBER)

#define ReplicaIdToAddr(_id_)  RcsFindReplicaById(_id_)

#define GuidToReplicaAddr(_pguid_) RcsFindReplicaByGuid(_pguid_)


//
// The replication state for each file in a replica tree is stored in a Jet
// database because jet provides crash recovery.  This is required because if a
// file is deleted and the system crashes then we have lost the replication
// state associated with the file.
//
// The database consists of several tables each composed of several columns.
//
// IDTable -
//    This table contains information about each file in the replica tree.
// It is indexed by both NTFS File ID and the Object ID Guid associated with
// the file.  Neither of these indexes are clustered since inserts could occur
// anywhere in the table.  When a remote Change Order (CO) arrives the IDTable
// tells us where the file is now (except for local operations on the file that
// have not yet been processed) and the current version info on the file.  When
// a local CO is processed the IDTable tells us where the file exists on the other
// replica set partners (modulo concurrent local operations on the file elsewhere).
//
//
// DIRTable
//
//
// Tunnel Table
//
// Version Vector Table
//
// The Version Vector Table (VVTable) is a per-Replica table.
// It is used by the replication service to dampen propagation of updates
// to replicas that already are up to date.  There is one entry per member of
// the replica set.  Each entry has the GUID of the originating member and
// the Volume Sequence Number (VSN) of the most recent change this member has
// seen from that member.  We keep our own VSN instead of using the NTFS
// volume USN because the replica set can be moved to a different volume
// and the volume could be reformatted and the replica tree restored from backup.
// In both cases the NTFS USN could move backwards.
//
//
// Inbound Change Order Table
//
// When a change order (local or remote) is accepted it is inserted into the
// inbound change order table where it stays until it is completed.  State
// variables in the record track the progress of the change order and determine
// where to continue in the event of a crash or a retry of a failed operation
// (e.g. Install).
//
// Outbound Change Order Table
//
// We need to be able to cancel an outbound change order that is still pending
// if we get either a second local change or an inbound update that wins the
// resolution decision.  If a pile of NEW files get put into the tree and then
// are deleted before they can be replicated we need to be able to cancel
// the replication or we need to send out a delete if the repl has already
// been done.  Note that the combination of local changes and inbound updates
// can generate multiple outbound change orders with the same file Guid.
// If we get several changes to different file properties spread over time
// we need to consolidate them into a single change order and a single file
// snapshot.
//
// Connection Table
//
// This table tracks the state of each inbound and outbound connection for the
// replica set.  In addtion it tracks the delivery state of each outbound
// change order using a bit vector window on the outbound change order stream.
// The outbound change orders are stored in the outbound log in order by
// the originating guid.  When all outbound partners have received the change
// order it is then deleted from the outbound log along with the staging file
// assuming the local install (if any) is complete.
//
//
//
// The Data Structures below provide the definitions of the Jet Tables.
// There are several related structures for each table.  See the comments in
// jet.h for a description of the relationship between them.
//
//
//


typedef struct _RECORD_FIELDS {
    USHORT  Offset;
    USHORT  DataType;
    ULONG   Size;
} RECORD_FIELDS, *PRECORD_FIELDS;

//
// The following data type defs originally came from mapidefs.h
// We use modified names and a different set of values.
//
typedef enum _FRS_DATA_TYPES {
    DT_UNSPECIFIED=0,   // (Reserved for interface use) type doesn't matter to caller
    DT_NULL         ,   // NULL property value
    DT_I2           ,   // Signed 16-bit value
    DT_LONG         ,   // Signed 32-bit value
    DT_ULONG        ,   // Unsigned 32-bit
    DT_R4           ,   // 4-byte floating point
    DT_DOUBLE       ,   // Floating point double
    DT_CURRENCY     ,   // Signed 64-bit int (decimal w/4 digits right of decimal pt)
    DT_APDTIME      ,   // Application time
    DT_ERROR        ,   // 32-bit error value
    DT_BOOL         ,   // 32-bit boolean (non-zero true)
    DT_OBJECT       ,   // Embedded object in a property
    DT_I8           ,   // 8-byte signed integer
    DT_X8           ,   // 8-byte Hex number
    DT_STRING8      ,   // Null terminated 8-bit character string
    DT_UNICODE      ,   // Null terminated Unicode string
    DT_FILETIME     ,   // FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601
    DT_GUID         ,   // GUID
    DT_BINARY       ,   // Uninterpreted (counted byte array)
    DT_OBJID        ,   // NTFS Object ID
    DT_USN          ,   // Update Sequence Number
    DT_FSVOLINFO    ,   // FD Volume Info
    DT_FILENAME     ,   // A unicode file name path (could be dos, NT, UNC, ...)
    DT_IDT_FLAGS    ,   // The flags word in an IDTable record.
    DT_COCMD_FLAGS  ,   // The flags word in a change order command record.
    DT_USN_FLAGS    ,   // The reason flags word in a change order command record.
    DT_CXTION_FLAGS ,   // The reason flags word in a connection record.
    DT_FILEATTR     ,   // The file attribute flags word.
    DT_FILE_LIST    ,   // A comma list of file or dir names, UNICODE.
    DT_DIR_PATH     ,   // A unicode directory path.
    DT_ACCESS_CHK   ,   // A unicode string for access check enable and rights.
    DT_COSTATE      ,   // The change order state in a change order command record.
    DT_COCMD_IFLAGS ,   // The Interlocked flags word in a change order command record.
    DT_IDT_EXTENSION,   // THe data extension field of an IDTable record.
    DT_COCMD_EXTENSION, // THe data extension field of a change order command record.
    DT_CO_LOCN_CMD  ,   // The Change order location command.
    DT_REPLICA_ID   ,   // Local ID number of replica set.
    DT_CXTION_GUID  ,   // A Cxtion guid which we can translate to the string.

    FRS_DATA_TYPES_MAX
} FRS_DATA_TYPES;

//
// Used for those var len binary records that are prefixed with a 4 byte length.
//
#define FIELD_DT_IS_BINARY(_t_)     \
    (((_t_) == DT_BINARY)        || \
     ((_t_) == DT_IDT_EXTENSION) || \
     ((_t_) == DT_COCMD_EXTENSION))

//
// Alternate property type names for ease of use
//
#define DT_SHORT        DT_I2
#define DT_I4           DT_LONG
#define DT_FLOAT        DT_R4
#define DT_R8           DT_DOUBLE
#define DT_LONGLONG     DT_I8

//
// Fields marked spare aren't skipped when buffers are allocated and
// database fields are read/written.  They are part of the Jet schema for
// future use so we don't have to rev the DB.
//
#define DT_SPARE_FLAG               ((USHORT) 0x4000)

//
// Do not allocate a default sized buffer for this field.
//
#define DT_NO_DEFAULT_ALLOC_FLAG    ((USHORT) 0x2000)

//
// The record buffer for this field is of fixed size even though the schema
// may allow a variable amount of data for the field.  An example is the
// IDTable record extension which fixed with any given version of FRS but which
// could grow in a future rev so we use a long bin datatype in the schema with
// a max column width of 2 meg.
//
#define DT_FIXED_SIZE_BUFFER        ((USHORT) 0x1000)

#define IsSpareField(_x_)           (((_x_) & DT_SPARE_FLAG) != 0)
#define IsNoDefaultAllocField(_x_)  (((_x_) & DT_NO_DEFAULT_ALLOC_FLAG) != 0)
#define IsFixedSzBufferField(_x_)   (((_x_) & DT_FIXED_SIZE_BUFFER) != 0)

#define MaskPropFlags(_x_) \
    ((_x_) & (~(DT_SPARE_FLAG | DT_NO_DEFAULT_ALLOC_FLAG | DT_FIXED_SIZE_BUFFER)))

//
//  Define codes for spare fields.  No storage is allocated.
//
#define DT_UNSPECIFIED_SPARE    (DT_UNSPECIFIED  | DT_SPARE_FLAG)
#define DT_NULL_SPARE           (DT_NULL         | DT_SPARE_FLAG)
#define DT_I2_SPARE             (DT_I2           | DT_SPARE_FLAG)
#define DT_LONG_SPARE           (DT_LONG         | DT_SPARE_FLAG)
#define DT_ULONG_SPARE          (DT_ULONG        | DT_SPARE_FLAG)
#define DT_R4_SPARE             (DT_R4           | DT_SPARE_FLAG)
#define DT_DOUBLE_SPARE         (DT_DOUBLE       | DT_SPARE_FLAG)
#define DT_CURRENCY_SPARE       (DT_CURRENCY     | DT_SPARE_FLAG)
#define DT_APDTIME_SPARE        (DT_APDTIME      | DT_SPARE_FLAG)
#define DT_ERROR_SPARE          (DT_ERROR        | DT_SPARE_FLAG)
#define DT_BOOL_SPARE           (DT_BOOL         | DT_SPARE_FLAG)
#define DT_OBJECT_SPARE         (DT_OBJECT       | DT_SPARE_FLAG)
#define DT_I8_SPARE             (DT_I8           | DT_SPARE_FLAG)
#define DT_X8_SPARE             (DT_X8           | DT_SPARE_FLAG)
#define DT_STRING8_SPARE        (DT_STRING8      | DT_SPARE_FLAG)
#define DT_UNICODE_SPARE        (DT_UNICODE      | DT_SPARE_FLAG)
#define DT_FILETIME_SPARE       (DT_FILETIME     | DT_SPARE_FLAG)
#define DT_GUID_SPARE           (DT_GUID         | DT_SPARE_FLAG)
#define DT_BINARY_SPARE         (DT_BINARY       | DT_SPARE_FLAG)
#define DT_OBJID_SPARE          (DT_OBJID        | DT_SPARE_FLAG)
#define DT_USN_SPARE            (DT_USN          | DT_SPARE_FLAG)
#define DT_FSVOLINFO_SPARE      (DT_FSVOLINFO    | DT_SPARE_FLAG)


#define DT_SHORT_SPARE        DT_I2_SPARE
#define DT_I4_SPARE           DT_LONG_SPARE
#define DT_FLOAT_SPARE        DT_R4_SPARE
#define DT_R8_SPARE           DT_DOUBLE_SPARE
#define DT_LONGLONG_SPARE     DT_I8_SPARE


//
// Data Extension Record Fields
//
// The following declarations define data extensions that are assembled into
// a variable length binary data field of a database record.  They are self
// describing, each has a size and type code, so downlevel versions of FRS
// can skip components it doesn't understand.  All components must begin
// on a quadword boundary.
//
// The specific record layout uses the component declarations below and are
// described with the containing table record.
//
typedef enum _DATA_EXTENSION_TYPE_CODES_ {
    DataExtend_End = 0,         // Terminates a data extension record.
    DataExtend_MD5_CheckSum,    // A Data Checksum record.
    DataExtend_Retry_Timeout,   // A Data Retry Timout record.
    DataExtend_Max
} DATA_EXTENSION_TYPE_CODES;


typedef struct _DATA_EXTENSION_PREFIX_ {
    union {
        ULONGLONG SizeType;     // Force quadword alignment.
        struct {
            ULONG Size;         // Size of Data Component including this Prefix.
            LONG  Type;         // omponent type from DATA_EXTENSION_TYPE_CODES
        };
    };
} DATA_EXTENSION_PREFIX, *PDATA_EXTENSION_PREFIX;


//
// All variable length data extension record fields must end with a
// DATA_EXTENSION_END component to terminate the component scan.
//
typedef struct _DATA_EXTENSION_END_ {
    DATA_EXTENSION_PREFIX Prefix;
} DATA_EXTENSION_END, *PDATA_EXTENSION_END;


//
// The DATA_EXTENSION_CHECKSUM component describes an MD5 checksum.
//
typedef struct _DATA_EXTENSION_CHECKSUM_ {
    DATA_EXTENSION_PREFIX Prefix;

    BYTE Data[MD5DIGESTLEN];    // The MD5 Checksum.

} DATA_EXTENSION_CHECKSUM, *PDATA_EXTENSION_CHECKSUM;


//
// The DATA_EXTENSION_RETRY_TIMEOUT component describes the number of times
// we have retied this CO and the time of the first try.
//
typedef struct _DATA_EXTENSION_RETRY_TIMEOUT_ {
    DATA_EXTENSION_PREFIX Prefix;

    DWORD Count;
    LONGLONG FirstTryTime;

} DATA_EXTENSION_RETRY_TIMEOUT, *PDATA_EXTENSION_RETRY_TIMEOUT;


//
// For error checking.  Make it bigger if any data extension record exceeds this.
//
#define REALLY_BIG_EXTENSION_SIZE 8192


//
// The database table descriptions for each replica set are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
// Also note - The addition of new tables to define a replica set may require
//             some lines of init code be added to FrsCreate/Open replica tables
//             and FrsAllocate.
//
// The table names are suffixed by an integer digit string NUM_REPLICA_DIGITS long.
//

#define NUM_REPLICA_DIGITS 5

typedef enum _TABLE_TYPE {
    INLOGTablex = 0,         // The inbound change order table
    OUTLOGTablex,            // the outbound change order table.
    IDTablex,                // The ID table description.
    DIRTablex,               // The DIR table description.
    VVTablex,                // The Version Vector table description.
    CXTIONTablex,            // The connection record table.
                             // <<<--- Add more per-replica tables here.
    _TABLE_TYPE_MAX_,        // The tables above this line are per-replica
    ConfigTablex,            // The config table description (a single table)
    ServiceTablex,           // The config table description (a single table)
                             // <<<--- Add more single tables here.
    TABLE_TYPE_INVALID
} TABLE_TYPE;

#define TABLE_TYPE_MAX _TABLE_TYPE_MAX_

#define IS_REPLICA_TABLE(_TableType_) ((_TableType_) < TABLE_TYPE_INVALID)

#define IS_INLOG_TABLE(_TableCtx_)  ((_TableCtx_)->TableType == INLOGTablex)
#define IS_OUTLOG_TABLE(_TableCtx_) ((_TableCtx_)->TableType == OUTLOGTablex)
#define IS_ID_TABLE(_TableCtx_)     ((_TableCtx_)->TableType == IDTablex)
#define IS_DIR_TABLE(_TableCtx_)    ((_TableCtx_)->TableType == DIRTablex)
#define IS_VV_TABLE(_TableCtx_)     ((_TableCtx_)->TableType == VVTablex)
#define IS_CXTION_TABLE(_TableCtx_) ((_TableCtx_)->TableType == CXTIONTablex)
#define IS_CONFIG_TABLE(_TableCtx_) ((_TableCtx_)->TableType == ConfigTablex)
#define IS_SERVICE_TABLE(_TableCtx_)((_TableCtx_)->TableType == ServiceTablex)
#define IS_INVALID_TABLE(_TableCtx_)((_TableCtx_)->TableType == TABLE_TYPE_INVALID)

#define IS_TABLE_OPEN(_TableCtx_)   ((_TableCtx_)->Tid != JET_tableidNil)

typedef struct _FRS_TABLE_PROPERTIES {
    PCHAR           BaseName;       // Base table name (must match name in Table Create struct)
    PRECORD_FIELDS  RecordFields;   // pointer to the record fields descriptor.
    ULONG           PropertyFlags;  // See below.
} FRS_TABLE_PROPERTIES, *PFRS_TABLE_PROPERTIES;


//
// FRS Table Property Flags.
//
#define FRS_TPF_NONE                0x00000000
#define FRS_TPF_SINGLE              0x00000001
#define FRS_TPF_NOT_CALLER_DATAREC  0x00000002

//
// Max table types is used to limit the max number of table version numbers
// tracked in the database config <init> record.
//
#define FRS_MAX_TABLE_TYPES         16

//
// The table version numbers are a major/minor pair in the upper/lower short.
// The Version Count is the first element in the TableVersionNumbers array.
// The upper short is the count of per-replica tables and the lower short is
// the count of single tables.
//
#define VersionCount                 0x00060002

#define VersionINLOGTable            0x00010000
#define VersionOUTLOGTable           0x00010000
#define VersionIDTable               0x00010000
#define VersionDIRTable              0x00010000
#define VersionVVTable               0x00010000
#define VersionCXTIONTable           0x00010000
#define VersionConfigTable           0x00010000
#define VersionServiceTable          0x00010000

#define VersionInvalid               0xffffffff

//
//  The TableVersionNumbers array as saved in the init record when new tables
//  are created.  This is used to detect a mismatch between a database and
//  the version of FRS running.
//
extern ULONG TableVersionNumbers[FRS_MAX_TABLE_TYPES];

//
// GET_TABLE_VERSION maps a table type ID as compiled to the corresponding
// entry in either the per-replica or single table portion of the TableVersionNumber
// array.  This is used to compare the table version array of the database with
// the version of NTFRS that is running. It is also used to compare table version
// numbers of two copies of NTFRS communicating as partners.  The idea is that
// newer versions of the service will provide conversion functions to allow it
// to talk with data bases created with older versions and / or partner members
// running older versions of the service.
//
//  TBD: How do we store the TableVersionNumbers array in the database so
//       a newer version of the service can read it from an older database
//       Can we use the table descriptors in the DB to get the config record
//       and then use the record descriptor to get the TableVersionNumbers array?
//
#define GET_TABLE_VERSION(_VerArray_, _TableType_)                            \
(((_TableType_) < TABLE_TYPE_MAX)                                             \
    ? (((_TableType_) < ((_VerArray_[0])>>16)                                 \
        ? _VerArray_[(_TableType_)+1)]                                        \
        : VersionInvalid)                                                     \
    : ((((_TableType_)-(TABLE_TYPE_MAX+1)) < ((_VerArray_[0]) & 0xffff)       \
        ? (_VerArray_+((_VerArray_[0])>>16)+1))[(_TableType_)-(TABLE_TYPE_MAX+1)]\
        : VersionInvalid)                                                     \
    )



//
// The list of Jet Tables created for each replica set and their properties.
//

extern JET_TABLECREATE DBTables[];

extern FRS_TABLE_PROPERTIES FrsTableProperties[];



//
// MAX_RDN_VALUE_SIZE is used as a limit on the machine name
// lengths.  It is currently 64 in the Dir Service.
//
#define MAX_RDN_VALUE_SIZE 64
//
// This is what the DS uses.
//
#define CP_NON_UNICODE_FOR_JET 1252
#define CP_UNICODE_FOR_JET     1200

//
// An NTFS File Object ID contains a 16 byte GUID followed by 48 bytes of
// extended information.
//
#define FILE_OBJECTID_SIZE sizeof(FILE_OBJECTID_BUFFER)


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **             P a r t n e r   C o n n e c t i o n   T a b l e               **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
 //
 // The partner connections as defined by the topology are kept in this table.
 // Each connection is marked as either an inbound or outbound, has its own
 // schedule and partner identification info.  In addition, outbound connections
 // record the state describing where we are in the outbound log and what
 // change orders have been acknowledged.
 //
 // The max number of change orders outstanding for any one partner is limited
 // by the ACK_VECTOR_SIZE (number of bits).  This must be a power of 2.

//
// The Connection Record column descriptions are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
//
typedef enum _CXTION_RECORD_COL_LIST_{
    CrCxtionGuidx = 0,         // Cxtion guid from the DS  (DS Cxtion obj guid)
    CrCxtionNamex,             // Cxtion name from the DS  (DS Cxtion obj RDN)
    CrPartnerGuidx,            // Partner guid from the DS (DS Replica set obj)
    CrPartnerNamex,            // Partner name from the DS (DS server obj RDN)
    CrPartSrvNamex,            // Partner server name
    CrPartnerDnsNamex,         // DNS name of partner (from DS server obj)
    CrInboundx,                // TRUE if inbound cxtion
    CrSchedulex,               // schedule
    CrTerminationCoSeqNumx,    // The Seq Num of most recent Termination CO inserted.
    CrLastJoinTimex,           // Time of last Join by this partner.
    CrFlagsx,                  // misc state flags.
    CrCOLxx,                   // Leading change order index / sequence number.
    CrCOTxx,                   // Trailing change order index / sequence number.
    CrCOTxNormalModeSavex,     // Saved Normal Mode COTx while in VV Join Mode.
    CrCOTslotx,                // Slot in Ack Vector corresponding to COTx.
    CrOutstandingQuotax,       // The maximum number of COs outstanding.
    CrAckVectorx,              // The partner ack vector.

    CrPartnerNetBiosNamex,     // SAM-Account-Name from Computer (minus the $)
    CrPartnerPrincNamex,       // NT4 account name cracked from Computer
    CrPartnerCoDnx,            // Distinguished name from Computer
    CrPartnerCoGuidx,          // Object-GUID from Computer
    CrPartnerSidx,             // SID of computer object of NTFRS-Member
    CrOptionsx,                // Options from NTDS-Connection
    CrOverSitex,               // Over-Site-Connection from NTDS-Connection
    CrPartnerAuthLevelx,       // Frs-Partner-Auth-Level

    CrAckVersionx,             // Version number of current AckVector state.
    CrSpare2Ullx,
    CrSpare1Guidx,
    CrSpare2Guidx,
    CrSpare1Binx,
    CrSpare2Binx,

    CXTION_TABLE_MAX_COL
} CXTION_RECORD_COL_LIST;


extern JET_COLUMNCREATE CXTIONTableColDesc[];

//
// Connection record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
//
// ** Note ** a change to this size requires the Data Base to be recreated since
// this is the field length in the DB.
#define ACK_VECTOR_SIZE  128
#define ACK_VECTOR_BYTES  (ACK_VECTOR_SIZE >> 3)
#define ACK_VECTOR_LONGS  (ACK_VECTOR_SIZE >> 5)
#define ACK_VECTOR_LONG_MASK  (ACK_VECTOR_LONGS-1)

//
// Authentication type and levels
//
#define CXTION_AUTH_KERBEROS_FULL   (0) // DEFAULT; Encrypted Kerberos
#define CXTION_AUTH_NONE            (1) // No authentication

typedef struct _CXTION_RECORD_ {
    GUID     CxtionGuid;        // Cxtion name/guid from the DS
    WCHAR    CxtionName[MAX_RDN_VALUE_SIZE+1];

    GUID     PartnerGuid;           // Partner name/guid from the DS
    WCHAR    PartnerName[MAX_RDN_VALUE_SIZE+1];
    WCHAR    PartSrvName[MAX_RDN_VALUE_SIZE+1];

    WCHAR    PartnerDnsName[DNS_MAX_NAME_LENGTH+1];  // DNS name of partner machine
    BOOL     Inbound;               // TRUE if inbound cxtion
    PVOID    Schedule;              // schedule
    ULONG    TerminationCoSeqNum;   // The Seq Num of most recent Termination CO inserted.
    FILETIME LastJoinTime;          // Time of last Join by this partner.

    ULONG    Flags;                 // misc state flags.
    ULONG    COLx;                  // Leading change order index / sequence number.
    ULONG    COTx;                  // Trailing change order index / sequence number.
    ULONG    COTxNormalModeSave;    // Saved Normal Mode COTx while in VV Join Mode.
    ULONG    COTslot;               // Slot in Ack Vector corresponding to COTx.
    ULONG    OutstandingQuota;      // The maximum number of COs outstanding.

    ULONG    AckVector[ACK_VECTOR_LONGS];  // The partner ack vector.

    PWCHAR   PartnerNetBiosName;    // SAM-Account-Name from Computer (minus the $)
    PWCHAR   PartnerPrincName;      // NT4 account name cracked from Computer
    PWCHAR   PartnerCoDn;           // Distinguished name from Computer
    GUID     PartnerCoGuid;         // Object-GUID from Computer
    PWCHAR   PartnerSid;            // Partner's string'ized SID
    ULONG    Options;               // Options from NTDS-Connection
    PWCHAR   OverSite;              // Over-Site-Connection from NTDS-Connection
    ULONG    PartnerAuthLevel;      // Frs-Partner-Auth-Level

    ULONGLONG AckVersion;           // Version number of current AckVector state.
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;
    GUID      Spare2Guid;
    PVOID     Spare1Bin;
    PVOID     Spare2Bin;

} CXTION_RECORD, *PCXTION_RECORD;

//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS CXTIONTableRecordFields[];

extern JET_SETCOLUMN CXTIONTableJetSetCol[CXTION_TABLE_MAX_COL];


//
// The ConnectionRecord index descriptions are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
//
typedef enum _CXTION_TABLE_INDEX_LIST {
    CrCxtionGuidxIndexx,      // The primary index is on the connection GUID.
    CXTION_TABLE_MAX_INDEX
} CXTION_TABLE_INDEX_LIST;


extern JET_INDEXCREATE CXTIONTableIndexDesc[];


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **             I n b o u n d   &   O u t b o u n d   L o g                   **
 **                C h a n g e   O r d e r   R e c o r d                      **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

// The Change Order Command is what is actually transmitted to our partners
// and stored in the database while the operation is pending.  Generally the
// data elements declared in the change order entry are relevant to the local
// system only while the data elements in the change order command are
// invarient across replica set members.  The Change Order Entry is defined
// in frsalloc.h.
//
//
// A change order has two file change components, Content and Location.
//
//    The content changes are cumulative and are the logical OR of the content
// related USN Reason flags.  Content changes don't change the File ID.  A
// Usn Record that specifies a content change where we have a pending change
// order causes the new reason mask to be ORed into the change order reason
// mask.  A rename that changes only the filename is a content change.
//
//    The Location changes are transitive since a file can exist in only one
// location on the volume.  Only the final location matters.  A USN Record that
// specifies a location change where we have a pending change order causes the
// Location command in the change order to be updated with the new location
// information.  Create and Delete are location changes as are renames that
// change the parent directory of the file.
//


//
// The ChangeOrder column descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// ChangeOrders are used in the inbound and outbound log tables.  Initially the
// record structure is the same but that is likely to change.
// ***** WARNING ****** As long as they are the same be sure to update both
//                      the inbound and outbound log table defs in schema.c
//
typedef enum _CHANGE_ORDER_COL_LIST {
    COSequenceNumberx = 0,    // Jet assigned changeorder sequence number
    COFlagsx,                 // Change order flags
    COIFlagsx,                // Change order flags REQUIRING interlocked modify
    COStatex,                 // State is sep DWORD to avoid locking.
    COContentCmdx,            // File content changes from UsnReason
    COLcmdx,                  // The CO location command.
    COFileAttributesx,
    COFileVersionNumberx,     // The file version number, inc on each close.
    COPartnerAckSeqNumberx,   // The sequence number to Ack this CO with.
    COFileSizex,
    COFileOffsetx,            // The current committed progress for staging file.
    COFrsVsnx,                // Originator Volume sequence number
    COFileUsnx,               // Last USN of file being staged
    COJrnlUsnx,               // Latest USN of jrnl record contributing to CO.
    COJrnlFirstUsnx,          // First USN of jrnl record contributing to CO.
    COOriginalReplicaNumx,    // Contains Replica ID when in DB
    CONewReplicaNumx,         // Contains Replica ID when in DB
    COChangeOrderGuidx,       // GUID to identify the change order
    COOriginatorGuidx,        // The GUID of the originating member
    COFileGuidx,              // The obj ID of the file
    COOldParentGuidx,         // The Obj ID of the file's original parent directory
    CONewParentGuidx,         // The Obj ID of the file's current parent directory
    COCxtionGuidx,            // The obj ID of remote CO connection.
    COAckVersionx,            // Version number of AckVector state when this CO was sent.
    COSpare2Ullx,
    COSpare1Guidx,
    COSpare2Guidx,
    COSpare1Wcsx,
    COSpare2Wcsx,
    COExtensionx,
    COSpare2Binx,
    COEventTimex,             // The USN Journal Entry Timestamp.
    COFileNameLengthx,        // The filename length.
    COFileNamex,              // The file name. (Must be Last)

    CHANGE_ORDER_MAX_COL
} CHANGE_ORDER_COL_LIST;


extern JET_COLUMNCREATE ILChangeOrderTableColDesc[];
extern JET_COLUMNCREATE OLChangeOrderTableColDesc[];

//
// ChangeOrder record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
//

//
// The Data Extension Field for a Change Order Record.
//
// Unlike the extension in the IDTable this record field is a pointer to
// allocated memory containing this struct.  This was done so the extension
// can be packed as a separate item by the COMM layer and leave the size of
// the change order command unchanged for compatibility with down rev
// partners.  The change order command size can't change without doing
// format conversions for down rev partners.  The storage for this
// extension field is allocated when the change order is allocated.
//
// WARNING:  While this struct is extensible in the database it is not
// extensible when sent to down level FRS members because the size of the
// friggen struct is checked by the receiving comm routines.  So if you need
// to enlarge this struct you need to send it as COMM_CO_EXTENSION_2
// so it is ignored by down level members.
// Further, you need to build a copy of this struct and send it as type
// COMM_CO_EXT_WIN2K when sending to a down level member.  This is what
// CO_RECORD_EXTENSION_WIN2K is for.
//
typedef struct _CHANGE_ORDER_RECORD_EXTENSION_ {
    ULONG FieldSize;
    USHORT Major;
    USHORT OffsetCount;
    //
    // use offsets from the base of the struct to each component so we avoid
    // problems with alignement packing.
    //
    ULONG Offset[2];    // Offsets to data components.
    ULONG OffsetLast;   // The last offset is always zero.

    DATA_EXTENSION_CHECKSUM     DataChecksum;
    DATA_EXTENSION_RETRY_TIMEOUT DataRetryTimeout;

    // Add new components in here.

} CHANGE_ORDER_RECORD_EXTENSION, *PCHANGE_ORDER_RECORD_EXTENSION;

//
// See comment above for why you can't extend this struct.
//
typedef struct _CO_RECORD_EXTENSION_WIN2K_ {
    ULONG FieldSize;
    USHORT Major;                     // Major is zero for WIN2K extension.
    USHORT OffsetCount;
    //
    // use offsets from the base of the struct to each component so we avoid
    // problems with alignement packing.
    //
    ULONG Offset[1];    // Offsets to data components.
    ULONG OffsetLast;   // The last offset is always zero.

    DATA_EXTENSION_CHECKSUM     DataChecksum;
} CO_RECORD_EXTENSION_WIN2K, *PCO_RECORD_EXTENSION_WIN2K;


#define  CO_RECORD_EXTENSION_VERSION_WIN2K   (0)     // For WIN2K
#define  CO_RECORD_EXTENSION_VERSION_1       (1)     // For Post-Win2K


typedef struct _CO_LOCATION_CMD {
    unsigned DirOrFile :  1;
    unsigned Command   :  4;
    unsigned filler    : 27;
} CO_LOCATION_CMD, *PCO_LOCATION_CMD;



typedef struct _CHANGE_ORDER_RECORD_ {
    ULONG     SequenceNumber;        // Unique sequence number for change order.
    ULONG     Flags;                 // Change order flags
    ULONG     IFlags;                // These flags can ONLY be updated with interlocked exchange.
    ULONG     State;                 // State is sep DWORD to avoid locking.
    ULONG     ContentCmd;            // File content changes from UsnReason

    union {
        ULONG           LocationCmd;
        CO_LOCATION_CMD Field;       // File Location command
    } Lcmd;

    ULONG     FileAttributes;
    ULONG     FileVersionNumber;     // The file version number, inc on each close.
    ULONG     PartnerAckSeqNumber;   // Save seq number for Partner Ack.

    ULONGLONG FileSize;
    ULONGLONG FileOffset;            // The current committed progress for staging file.
    ULONGLONG FrsVsn;                // Originator Volume sequence number
    USN       FileUsn;               // The USN of the file must match on the Fetch request.
    USN       JrnlUsn;               // USN of last journal record contributing to this CO.
    USN       JrnlFirstUsn;          // USN of first journal record contributing to this CO.

    ULONG     OriginalReplicaNum;    // Contains Replica ID number
    ULONG     NewReplicaNum;         // Contains Replica ID number

    GUID      ChangeOrderGuid;       // Guid that identifies the change order everywhere.
    GUID      OriginatorGuid;        // The GUID of the originating member
    GUID      FileGuid;              // The obj ID of the file
    GUID      OldParentGuid;         // The Obj ID of the file's original parent directory
    GUID      NewParentGuid;         // The Obj ID of the file's current parent directory
    GUID      CxtionGuid;            // The obj ID of remote CO connection.

    ULONGLONG AckVersion;            // Version number of AckVector state when this CO was sent.
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;

    //
    // The following four pointers -
    //     Spare1Wcs, Spare2Wcs, Extension, Spare2Bin
    // occupy 16 bytes on 32 bit architectures and 32 bytes on 64 bit architectures.
    // The CO is included in the stage file header and in the change order Comm
    // packet causing 32-64 interop problems in both stage file processing and
    // comm transfers between 32 and 64 bit machines.  The contents of these
    // pointers are irrelevant in both comm packets and staging files since they
    // point to allocated buffers.
    //
    // To preserve the size of the change order in the staging file on 64 bit
    // machines the unused field Spare2Guid is unioned with the two 8 byte
    // pointers Spare1Wcs and Spare2Wcs, saving 16 bytes.  On 32 bit
    // architectures these fields are left separate.
    //
    // Note: in the future you can either used Spare2Guid or the two pointers
    // but not both or the 64 bit version will be broken.  It would have been
    // simpler to just ifdef out Spare1Wcs and Spare2Wcs on the 64 bit compile
    // but the ifdef would then have to be extended to the enum and the DB
    // descriptor tables in schema.c.
    //
    // Note: The only way you can change the size or layout of the change order
    // command is to adjust the version level and provide a translation function
    // for both the change order comm packet and the stage file.  Of course
    // even if you do this you still have a problem of converting the change
    // order in a stage file header from the new format to the old format when
    // you prop the stage file to a down level member.
    //
#ifdef _WIN64
    union {
        GUID      Spare2Guid;
        struct {
            PWCHAR    Spare1Wcs;
            PWCHAR    Spare2Wcs;
        };
    };
#else
    GUID      Spare2Guid;
    PWCHAR    Spare1Wcs;
    PWCHAR    Spare2Wcs;
#endif

    PCHANGE_ORDER_RECORD_EXTENSION Extension; // see above.
    PVOID     Spare2Bin;

    LARGE_INTEGER EventTime;         // The USN Journal Entry Timestamp.
    USHORT    FileNameLength;
    WCHAR     FileName[MAX_PATH+1];  // The file name. (Must be Last)

} CHANGE_ORDER_COMMAND, *PCHANGE_ORDER_COMMAND,
  CHANGE_ORDER_RECORD, *PCHANGE_ORDER_RECORD;


//#define CO_PART1_OFFSET  OFFSET(CHANGE_ORDER_COMMAND, SequenceNumber)
//#define CO_PART1_SIZE    OFFSET(CHANGE_ORDER_COMMAND, Spare1Wcs)

//#define CO_PART2_OFFSET  OFFSET(CHANGE_ORDER_COMMAND, Spare1Wcs)
//#define CO_PART2_SIZE    (4*sizeof(ULONG))

//#define CO_PART3_OFFSET  OFFSET(CHANGE_ORDER_COMMAND, EventTime)
//#define CO_PART3_SIZE    (sizeof(CHANGE_ORDER_COMMAND) - CO_PART3_OFFSET)

//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS ILChangeOrderRecordFields[];
extern RECORD_FIELDS OLChangeOrderRecordFields[];

extern JET_SETCOLUMN ILChangeOrderJetSetCol[CHANGE_ORDER_MAX_COL];
extern JET_SETCOLUMN OLChangeOrderJetSetCol[CHANGE_ORDER_MAX_COL];


//
// The Inbound log ChangeOrder Table index descriptions are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
//
typedef enum _ILCHANGE_ORDER_INDEX_LIST {
    ILSequenceNumberIndexx,    // The primary index on the change order sequence number.
    ILFileGuidIndexx,          // The index on the file object ID.
    ILChangeOrderGuidIndexx,   // The index on the change order GUID.
    ILCxtionGuidCoGuidIndexx,  // The 2 key index on Connection Guid and Change order Guid.
    ILCHANGE_ORDER_MAX_INDEX
} ILCHANGE_ORDER_INDEX_LIST;


//
// The Outbound log ChangeOrder Table index descriptions are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
//
typedef enum _OLCHANGE_ORDER_INDEX_LIST {
    OLSequenceNumberIndexx,    // The primary index on the change order sequence number.
    OLFileGuidIndexx,          // The index on the file object ID.
    OLChangeOrderGuidIndexx,   // The index on the change order GUID.
    OLCHANGE_ORDER_MAX_INDEX
} OLCHANGE_ORDER_INDEX_LIST;


extern JET_INDEXCREATE ILChangeOrderIndexDesc[];
extern JET_INDEXCREATE OLChangeOrderIndexDesc[];


#define SET_CO_LOCATION_CMD(_Entry_, _Field_, _Val_) \
    (_Entry_).Lcmd.Field._Field_ = _Val_

#define GET_CO_LOCATION_CMD(_Entry_, _Field_) \
    (ULONG)((_Entry_).Lcmd.Field._Field_)

#define CO_LOCATION_DIR        1    // Location change is for a directory
#define CO_LOCATION_FILE       0    // Location change is for a file.

//
// Note - Any change here must be reflected in journal.c
//
#define FILE_NOT_IN_REPLICA_SET (-1)

#define CO_LOCATION_CREATE     0    // Create a File or Dir (New FID Generated)
#define CO_LOCATION_DELETE     1    // Delete a file or Dir (FID retired)
#define CO_LOCATION_MOVEIN     2    // Rename into a R.S.
#define CO_LOCATION_MOVEIN2    3    // Rename into a R.S. from a prev MOVEOUT

#define CO_LOCATION_MOVEOUT    4    // Rename out of any R.S.
#define CO_LOCATION_MOVERS     5    // Rename from one R.S. to another R.S.
#define CO_LOCATION_MOVEDIR    6    // Rename from one dir to another (Same R.S.)
#define CO_LOCATION_NUM_CMD    7

#define CO_LOCATION_CREATE_FILENAME_MASK    0x0000006D   // 0110 1101
#define CO_LOCATION_REMOVE_FILENAME_MASK    0x00000072   // 0111 0010
#define CO_LOCATION_NEW_FILE_IN_REPLICA     0x0000000D   // 0000 1101
#define CO_LOCATION_MOVEIN_FILE_IN_REPLICA  0x0000000C   // 0000 1100
#define CO_LOCATION_DELETE_FILENAME_MASK    0x00000012   // 0001 0010
#define CO_LOCATION_MOVE_RS_OR_DIR_MASK     0x00000060   // 0110 0000
#define CO_LOCATION_MOVE_OUT_RS_OR_DIR_MASK 0x00000070   // 0111 0000



#define CO_LOCATION_NO_CMD CO_LOCATION_NUM_CMD

//
//  Note: Any of the following bits being set can cause us to replicate the file.
//  Some of the causes such as USN_REASON_BASIC_INFO_CHANGE may not replicate if
//  all that has changed is the archive flag or the last access time.
//
#define CO_CONTENT_MASK                   \
    (USN_REASON_DATA_OVERWRITE          | \
     USN_REASON_DATA_EXTEND             | \
     USN_REASON_DATA_TRUNCATION         | \
     USN_REASON_NAMED_DATA_OVERWRITE    | \
     USN_REASON_NAMED_DATA_EXTEND       | \
     USN_REASON_NAMED_DATA_TRUNCATION   | \
     USN_REASON_EA_CHANGE               | \
     USN_REASON_SECURITY_CHANGE         | \
     USN_REASON_RENAME_OLD_NAME         | \
     USN_REASON_RENAME_NEW_NAME         | \
     USN_REASON_BASIC_INFO_CHANGE       | \
     USN_REASON_COMPRESSION_CHANGE      | \
     USN_REASON_ENCRYPTION_CHANGE       | \
     USN_REASON_OBJECT_ID_CHANGE        | \
     USN_REASON_REPARSE_POINT_CHANGE    | \
     USN_REASON_STREAM_CHANGE             \
    )

#define CO_CONTENT_NEED_STAGE           (CO_CONTENT_MASK & ~(0))



#define CO_LOCATION_MASK                  \
    (USN_REASON_FILE_DELETE             | \
     USN_REASON_FILE_CREATE             | \
     USN_REASON_RENAME_NEW_NAME           \
    )



//
// The following is true if this CO creates a new filename in a directory.
//
#define DOES_CO_CREATE_FILE_NAME(_cocmd_)                   \
    ((( 1 << (ULONG)((_cocmd_)->Lcmd.Field.Command)) &      \
      CO_LOCATION_CREATE_FILENAME_MASK) != 0)

//
// The following is true if this CO removes a filename from a directory.
//
#define DOES_CO_REMOVE_FILE_NAME(_cocmd_)                   \
    ((( 1 << (ULONG)((_cocmd_)->Lcmd.Field.Command)) &      \
      CO_LOCATION_REMOVE_FILENAME_MASK) != 0)

//
// The following is true if this CO deletes a filename from a directory.
//
#define DOES_CO_DELETE_FILE_NAME(_cocmd_)                   \
    ((( 1 << (ULONG)((_cocmd_)->Lcmd.Field.Command)) &      \
      CO_LOCATION_DELETE_FILENAME_MASK) != 0)

//
// The following checks for a simple name change.  No parent location change.
//
#define DOES_CO_DO_SIMPLE_RENAME(_cocmd_) (                               \
    ((ULONG)((_cocmd_)->Lcmd.Field.Command) == CO_LOCATION_NO_CMD) &&     \
    BooleanFlagOn((_cocmd_)->ContentCmd, USN_REASON_RENAME_OLD_NAME |     \
                                         USN_REASON_RENAME_NEW_NAME)      \
)

//
// The following are various predicates for testing the type of CO location cmd.
//
#define CO_NEW_FILE(_loc_)                                        \
    ((( 1 << (_loc_)) & CO_LOCATION_NEW_FILE_IN_REPLICA) != 0)

#define CO_MOVEIN_FILE(_loc_)                                     \
    ((( 1 << (_loc_)) & CO_LOCATION_MOVEIN_FILE_IN_REPLICA) != 0)

#define CO_DELETE_FILE(_loc_)                                     \
    ((( 1 << (_loc_)) & CO_LOCATION_DELETE_FILENAME_MASK) != 0)

#define CO_LOCN_CMD_IS(_co_, _Loc_)                               \
    (GET_CO_LOCATION_CMD((_co_)->Cmd, Command) == (_Loc_))

#define CO_MOVE_RS_OR_DIR(_loc_)                                  \
    ((( 1 << (_loc_)) & CO_LOCATION_MOVE_RS_OR_DIR_MASK) != 0)

#define CO_MOVE_OUT_RS_OR_DIR(_loc_)                              \
    ((( 1 << (_loc_)) & CO_LOCATION_MOVE_OUT_RS_OR_DIR_MASK) != 0)


#define CoIsDirectory(_co_) \
    (BooleanFlagOn((_co_)->Cmd.FileAttributes, FILE_ATTRIBUTE_DIRECTORY) || \
     GET_CO_LOCATION_CMD((_co_)->Cmd, DirOrFile))

#define CoCmdIsDirectory(_coc_) \
    (BooleanFlagOn((_coc_)->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ||  \
     GET_CO_LOCATION_CMD(*(_coc_), DirOrFile))


//
// Change order Flags
//
//  ** WARNING ** WARNING ** WARNING **
// Code in the Inlog process retire path may overwrite these
// flags after the CO is transferred into the Outlog.  It may need to clear
// INSTALL_INCOMPLETE or set the ABORT_CO flag.  The Outlog process
// currently has no need to modify these bits so this is OK.  Change orders
// generated during VVJoin set these flags but these change orders are never
// processed by the inlog process so it will not write to their flags field.
// If the Outlog process needs to write these bits code in chgorder.c must
// be updated so state is not lost.
//
#define CO_FLAG_ABORT_CO           0x00000001 // Set when CO is being aborted
#define CO_FLAG_VV_ACTIVATED       0x00000002 // Set when VV activate req is made.
#define CO_FLAG_CONTENT_CMD        0x00000004 // Valid content command
#define CO_FLAG_LOCATION_CMD       0x00000008 // valid location command

#define CO_FLAG_ONLIST             0x00000010 // On a change order process list.
#define CO_FLAG_LOCALCO            0x00000020 // CO is a locally generated.
#define CO_FLAG_RETRY              0x00000040 // CO needs to retry.
#define CO_FLAG_INSTALL_INCOMPLETE 0x00000080 // Local install not completed.

#define CO_FLAG_REFRESH            0x00000100 // CO is an upstream originated file refresh request.
#define CO_FLAG_OUT_OF_ORDER       0x00000200 // Don't check/update version vector
#define CO_FLAG_NEW_FILE           0x00000400 // If CO fails, delete IDTable entry.
#define CO_FLAG_FILE_USN_VALID     0x00000800 // CO FileUsn is valid.

#define CO_FLAG_CONTROL            0x00001000 // This is a Control CO (see below)
#define CO_FLAG_DIRECTED_CO        0x00002000 // This CO is directed to a single connection.
#define CO_FLAG_UNUSED4000         0x00004000 // This CO is a reanimation request.
#define CO_FLAG_UNUSED8000         0x00008000 // This CO is for a reanimated parent.

#define CO_FLAG_UNUSED10000        0x00010000 // This CO has previously requested
                                              // reanimation of its parent.
#define CO_FLAG_DEMAND_REFRESH     0x00020000 // CO is a downstream demand for refresh.
#define CO_FLAG_VVJOIN_TO_ORIG     0x00040000 // CO is from vvjoin to originator
#define CO_FLAG_MORPH_GEN          0x00080000 // CO generated as part of name morph resolution

#define CO_FLAG_SKIP_ORIG_REC_CHK  0x00100000 // Skip originator reconcile check
#define CO_FLAG_MOVEIN_GEN         0x00200000 // This CO was gened as part of a sub-dir MOVEIN.
#define CO_FLAG_MORPH_GEN_LEADER   0x00400000 // This is a MorphGenLeader and it needs to
                                              // refabricate the MorphGenFollower if it's retried.
#define CO_FLAG_JUST_OID_RESET     0x00800000 // All CO did was reset OID back to FRS defined value.
#define CO_FLAG_COMPRESSED_STAGE   0x01000000 // The stage file for this CO is compressed.
#define CO_FLAG_SKIP_VV_UPDATE     0x02000000 // This CO should not update the VV.



//
// Control Change Order Function Codes (passed in the ContentCmd field)
//
#define FCN_CORETRY_LOCAL_ONLY          0x1
#define FCN_CORETRY_ONE_CXTION          0x2
#define FCN_CORETRY_ALL_CXTIONS         0x3
#define FCN_CO_NORMAL_VVJOIN_TERM       0x4
#define FCN_CO_ABNORMAL_VVJOIN_TERM     0x5
#define FCN_CO_END_OF_JOIN              0x6
#define FCN_CO_END_OF_OPTIMIZED_VVJOIN  0x7


//
// Flag group for testing any type of refresh request.
//
#define CO_FLAG_GROUP_ANY_REFRESH   (CO_FLAG_DEMAND_REFRESH | CO_FLAG_REFRESH)

//
// Flags that are only valid locally; they should be cleared by the
// machine that receives the remote change order before inserting
// the remote change order into the change order stream.
//
#define CO_FLAG_NOT_REMOTELY_VALID  (CO_FLAG_ABORT_CO           | \
                                     CO_FLAG_VV_ACTIVATED       | \
                                     CO_FLAG_ONLIST             | \
                                     CO_FLAG_MORPH_GEN          | \
                                     CO_FLAG_MORPH_GEN_LEADER   | \
                                     CO_FLAG_MOVEIN_GEN         | \
                                     CO_FLAG_RETRY              | \
                                     CO_FLAG_LOCALCO            | \
                                     CO_FLAG_INSTALL_INCOMPLETE)
//
// The following group of flags are cleared before the Change Order is inserted
// in the Outbound Log.  When the CO is propagated they would confuse the
// outbound partner.
//
// We now send demand refresh change orders to downstream partners so
// we need to turn that flag off as well.
//
#define CO_FLAG_GROUP_OL_CLEAR  (CO_FLAG_ABORT_CO               | \
                                 CO_FLAG_VV_ACTIVATED           | \
                                 CO_FLAG_ONLIST                 | \
                                 CO_FLAG_MORPH_GEN              | \
                                 CO_FLAG_MORPH_GEN_LEADER       | \
                                 CO_FLAG_MOVEIN_GEN             | \
                                 CO_FLAG_RETRY                  | \
                                 CO_FLAG_DEMAND_REFRESH         | \
                                 CO_FLAG_NEW_FILE)

//
// The following group of flags are used to create a reanimation change order
// to fetch a deleted parent dir for our inbound partner.
//  - It is a create CO,
//  - demand refresh keeps it from propagating to outlog and keeps us
//    from reserving a VV retire slot since no ACK or VV update is needed,
//  - directed means inbound partner sends it only to us (not really
//    needed but makes it coinsistent),
//  - out-of-order lets it pass VV checks,
//  - onlist means it is on the change order process queue (or will be soon),
//  - this is a reanimation CO (in COE_FLAGS...),
//  - and this is a parent reanimation CO so it does not go into the inlog
//    since it will be regenerated as needed if the base CO fails and has to
//    be retried (in COE_FLAGS...).
//
#define CO_FLAG_GROUP_RAISE_DEAD_PARENT (CO_FLAG_LOCATION_CMD        | \
                                         CO_FLAG_DEMAND_REFRESH      | \
                                         CO_FLAG_OUT_OF_ORDER        | \
                                         CO_FLAG_ONLIST)
//
// We now send the reanimation COs forward so we don't want them to be
// directed COs.
//
/*                                         CO_FLAG_DIRECTED_CO         | \*/

#define COC_FLAG_ON(_COC_, _F_)     (BooleanFlagOn((_COC_)->Flags, (_F_)))
#define CO_FLAG_ON(_COE_, _F_)      (BooleanFlagOn((_COE_)->Cmd.Flags, (_F_)))

#define SET_CO_FLAG(_COE_, _F_)     SetFlag((_COE_)->Cmd.Flags, (_F_))
#define SET_COC_FLAG(_COC_, _F_)    SetFlag((_COC_)->Flags, (_F_))

#define CLEAR_CO_FLAG(_COE_, _F_)   ClearFlag((_COE_)->Cmd.Flags, (_F_))
#define CLEAR_COC_FLAG(_COC_, _F_)  ClearFlag((_COC_)->Flags, (_F_))

//
//  The interlocked flags word is used to hold change order flags that could
//  be accessed by multiple threads.  They must be set and cleared using
//  the interlock macros SET_FLAG_INTERLOCKED and CLEAR_FLAG_INTERLOCKED.
//  A crit sec may still be needed if the bits must remain stable during
//  some period of time.  But using the interlock macros by all threads
//  ensures that no bit changes are lost even without a critsec.
//
#define CO_IFLAG_VVRETIRE_EXEC    0x00000001  // VV retire has been executed.
#define CO_IFLAG_CO_ABORT         0x00000002  // CO has been aborted
#define CO_IFLAG_DIR_ENUM_PENDING 0x00000004  // This CO needs to enumerate it's
                                              // children as part of a sub-dir MOVEIN.

//
// The following IFlags are cleared before the CO is sent to an outbound
// partner.  See Outlog.c
//
#define CO_IFLAG_GROUP_OL_CLEAR  (CO_IFLAG_VVRETIRE_EXEC         | \
                                  CO_IFLAG_DIR_ENUM_PENDING)


#define CO_IFLAG_ON(_COE_, _F_)  (BooleanFlagOn((_COE_)->Cmd.IFlags, (_F_)))

#define SET_CO_IFLAG(_COE_, _F_)   \
    SET_FLAG_INTERLOCKED(&(_COE_)->Cmd.IFlags, (_F_))

#define CLEAR_CO_IFLAG(_COE_, _F_) \
    CLEAR_FLAG_INTERLOCKED(&(_COE_)->Cmd.IFlags, (_F_))



//  As the change order progresses we update the current state in the
//  change order entry in Jet at points where we need to preserve persistence.

//  Inbound Change Order Stages:
//      ** WARNING ** The order matters for compares.
//          E.g., RcsCmdPktCompletionRoutine in replica.c
//      *** update name list in Chgorder.c if any changes here.
//      ** WARNING ** If you change these values be sure that the new code
//          will work on a pre-existing database with the OLD VALUES.
//       If the number of states goes past 32 then some of the macros which
//       build a mask of state bits won't work.  See below.

#define IBCO_INITIALIZING        (0)    // Initial state when CO is first put in log.
#define IBCO_STAGING_REQUESTED   (1)    // Alloc staging file space for local CO
#define IBCO_STAGING_INITIATED   (2)    // LocalCO Staging file copy has started
#define IBCO_STAGING_COMPLETE    (3)    // LocalCO Staging file complete
                                        // At this point prelim accept rechecked and
                                        // becomes either final accept of abort.
                                        // Abort is caused by more recent local change.
#define IBCO_STAGING_RETRY       (4)    // Waiting to retry local CO stage file generation.

#define IBCO_FETCH_REQUESTED     (5)    // Alloc staging file space for remote co
#define IBCO_FETCH_INITIATED     (6)    // RemoteCO staging file fetch has started
#define IBCO_FETCH_COMPLETE      (7)    // RemoteCO Staging file fetch complete
#define IBCO_FETCH_RETRY         (8)    // Waiting to retry remote CO stage file fetch

#define IBCO_INSTALL_REQUESTED   (9)    // File install requested
#define IBCO_INSTALL_INITIATED   (10)   // File install has started
#define IBCO_INSTALL_COMPLETE    (11)   // File install is complete
#define IBCO_INSTALL_WAIT        (12)   // File install is waiting to try again.
#define IBCO_INSTALL_RETRY       (13)   // File install is retrying.
#define IBCO_INSTALL_REN_RETRY   (14)   // File install rename is retrying.
#define IBCO_INSTALL_DEL_RETRY   (15)   // File install delete is retrying.

#define IBCO_UNUSED_16           (16)   // Unused state
#define IBCO_UNUSED_17           (17)   // Unused state
#define IBCO_UNUSED_18           (18)   // Unused state

#define IBCO_ENUM_REQUESTED      (19)   // CO is being recycled to do a dir enum.

#define IBCO_OUTBOUND_REQUEST    (20)   // Request outbound propagaion
#define IBCO_OUTBOUND_ACCEPTED   (21)   // Request accepted and now in Outbound log

#define IBCO_COMMIT_STARTED      (22)   // DB state update started.
#define IBCO_RETIRE_STARTED      (23)   // DB state update done, freeing change order.

#define IBCO_ABORTING            (24)   // CO is being aborted.
#define IBCO_MAX_STATE           (24)


extern PCHAR IbcoStateNames[IBCO_MAX_STATE+1];


#define CO_STATE(_Entry_)        ((_Entry_)->Cmd.State)
#define CO_STATE_IS(_Entry_, _State_) ((_Entry_)->Cmd.State == (_State_))
#define CO_STATE_IS_LE(_Entry_, _State_) ((_Entry_)->Cmd.State <= (_State_))

#define PRINT_CO_STATE(_Entry_)  IbcoStateNames[CO_STATE(_Entry_)]
#define PRINT_COCMD_STATE(_Entry_)  IbcoStateNames[(_Entry_)->State]

#define SAVE_CHANGE_ORDER_STATE(_Entry_, _Save_, _Flags_)  \
    _Save_  = ((_Entry_)->Cmd.State);                      \
    _Flags_ = ((_Entry_)->Cmd.Flags);

#define RESTORE_CHANGE_ORDER_STATE(_Entry_, _Save_, _Flags_) \
    (_Entry_)->Cmd.State = (_Save_);                         \
    (_Entry_)->Cmd.Flags = (_Flags_);


#define CO_STATE_IS_INSTALL_RETRY(_co_)                                     \
    (0 != ((1 << CO_STATE(_co_)) & ((1 << IBCO_INSTALL_RETRY)     |         \
                                    (1 << IBCO_INSTALL_REN_RETRY) |         \
                                    (1 << IBCO_INSTALL_DEL_RETRY))))

#define CO_STATE_IS_REMOTE_RETRY(_co_)                                      \
    (CO_STATE_IS(_co_, IBCO_FETCH_RETRY) ||                                 \
     CO_STATE_IS_INSTALL_RETRY(_co_))


#define CO_STATE_IS_LOCAL_RETRY(_co_)                                       \
    (0 != ((1 << CO_STATE(_co_)) & (1 << IBCO_STAGING_RETRY)))

//
// Macro to update state field of change order and log the event.
//

#define SET_CHANGE_ORDER_STATE_CMD(_cmd_, _state_)                          \
{                                                                           \
    (_cmd_)->State = (_state_);                                             \
    CHANGE_ORDER_COMMAND_TRACE(3, (_cmd_), PRINT_COCMD_STATE(_cmd_));       \
                                                                            \
}

#define SET_CHANGE_ORDER_STATE(_coe_, _state_)                              \
    (_coe_)->Cmd.State = (_state_);                                         \
    CHANGE_ORDER_TRACE(3, (_coe_), PRINT_CO_STATE(_coe_));



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                         D i r T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The DirTable column descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// The DirTable is a per-replica table.  It is used by the USN Journal process
// to determine if a file on a given volume is in a replica set.  When the
// Journal process is initialized the table is loaded into the inmemory
// volume filter table so we can quickly determine if the file is in a
// replica tree and if so, which one.
//

typedef enum _DIRTABLE_COL_LIST {
    DFileGuidx = 0,         // The guid assigned to the Dir
    DFileIDx,               // The local NTFS volume file ID.
    DParentFileIDx,         // The file ID of the parent directory
    DReplicaNumberx,        // The replica set number (integer, for suffix on table names).
    DFileNamex,             // The file name part, no dir prefix. (UNICODE)
    DIRTABLE_MAX_COL
} DIRTABLE_COL_LIST;


extern JET_COLUMNCREATE DIRTableColDesc[];

//
// DIRTable record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
// WARNING:  If anything changes here make the corresponding change to
//           FILTER_TABLE_ENTRY in journal.c
//
typedef struct _DIRTABLE_RECORD {
    GUID         DFileGuid;
    LONGLONG     DFileID;
    LONGLONG     DParentFileID;
    ULONG        DReplicaNumber;
    WCHAR        DFileName[MAX_PATH+1];
} DIRTABLE_RECORD, *PDIRTABLE_RECORD;

//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS DIRTableRecordFields[];

extern JET_SETCOLUMN DIRTableJetSetCol[DIRTABLE_MAX_COL];



//
// The DIRTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
typedef enum _DIRTABLE_INDEX_LIST {
    DFileGuidIndexx = 0,    // The index on the file GUID.
    DFileIDIndexx,          // The index on the file ID.
    DIRTABLE_MAX_INDEX
} DIRTABLE_INDEX_LIST;


extern JET_INDEXCREATE DIRTableIndexDesc[];




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                           I D T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The IDTable column descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// Perf: Consider breaking out the data that changes less frequently from the
// rest of the data.  For example, fileguid, fileid, parentguid, parentid,
// file name, fileobjid, Flags, replenabled and fileisdir
// probably don't change often.  These could
// be in a different table with an autoinc column whose value is used to index
// a second table with the more volatile data.
//
// Perf: Also think about breaking up the tables based on the data accessed or
// modified by the different threads so as to minimize lock contention.

typedef enum _IDTABLE_COL_LIST {
    FileGuidx = 0,     // The guid assigned to the file.
    FileIDx,           // The local NTFS volume file ID.
    ParentGuidx,       // The guid of the parent directory
    ParentFileIDx,     // The file ID of the parent directory
    VersionNumberx,    // The version number of the file, bumped on close.
    EventTimex,        // The event time from the USN Journal entry.
    OriginatorGuidx,   // The GUID of the member that originated the last file update.
    OriginatorVSNx,    // The USN number of the originating member.
    CurrentFileUsnx,   // The close USN of the last modify to the file.
    FileCreateTimex,   // The file create time.
    FileWriteTimex,    // The file last write time.
    FileSizex,         // The file size.
    FileObjIDx,        // The file object ID (guid part matches our FileGuid).
    FileNamex,         // The file name part, no dir prefix. (UNICODE)
    FileIsDirx,        // True if the file is a directory.
    FileAttributesx,   // The file attributes.
    Flagsx,            // File is deleted, create deleted, etc. This is a tombstone.
    ReplEnabledx,      // True if replication is enabled for this file/dir.
    TombStoneGCx,      // Tombstone expiration / Garbage Collection time.
    OutLogSeqNumx,     // The sequence number of most recent CO inserted into OutLog.
    IdtVVFlagsx,       // Flags for version vector management.  (was IdtSpare1Ullx)
    IdtSpare2Ullx,     // Spare Ulonglong
    IdtSpare1Guidx,    // Spare Guid
    IdtSpare2Guidx,    // Spare Guid
    IdtSpare1Wcsx,     // Spare wide char
    IdtSpare2Wcsx,     // Spare wide char
    IdtExtensionx,     // IDTable Extension Field
    IdtSpare2Binx,     // Spare binary blob
    IDTABLE_MAX_COL
} IDTABLE_COL_LIST;


extern JET_COLUMNCREATE IDTableColDesc[];

//
// IDTable record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
#if 0
//    Note: Consider using tagged data in jet so the external world just picks up
//          the version element specific to the given type of change order
// Each file component that can be independently updated needs its own version
// info to drive reconcilliation.  Currently there are only two such components,
// (1) The data and (2) the non-data.
//
typedef struct _IDTABLE_OBJECT_VERSION_ {
    ULONG        VersionNumber;
    LONGLONG     EventTime;
    GUID         OriginatorGuid;
    ULONGLONG    OriginatorVSN;
} IDTABLE_OBJECT_VERSION, *PIDTABLE_OBJECT_VERSION

#define IDT_OBJECT_DATA     0
#define IDT_OBJECT_NONDATA  1
#define MAX_IDTABLE_OBJECTS 2

#define IdtDataVersionNumber(_rec_)  ((_rec_)->OV[IDT_OBJECT_DATA].VersionNumber)
#define IdtDataEventTime(_rec_)      ((_rec_)->OV[IDT_OBJECT_DATA].EventTime)
#define IdtDataOriginatorGuid(_rec_) ((_rec_)->OV[IDT_OBJECT_DATA].OriginatorGuid)
#define IdtDataOriginatorVSN(_rec_)  ((_rec_)->OV[IDT_OBJECT_DATA].OriginatorVSN)

#define IdtNonDataVersionNumber(_rec_)  ((_rec_)->OV[IDT_OBJECT_NONDATA].VersionNumber)
#define IdtNonDataEventTime(_rec_)      ((_rec_)->OV[IDT_OBJECT_NONDATA].EventTime)
#define IdtNonDataOriginatorGuid(_rec_) ((_rec_)->OV[IDT_OBJECT_NONDATA].OriginatorGuid)
#define IdtNonDataOriginatorVSN(_rec_)  ((_rec_)->OV[IDT_OBJECT_NONDATA].OriginatorVSN)

#define IdtVersionNumber(_rec_, _x_)  ((_rec_)->OV[(_x_)].VersionNumber)
#define IdtEventTime(_rec_, _x_)      ((_rec_)->OV[(_x_)].EventTime)
#define IdtOriginatorGuid(_rec_, _x_) ((_rec_)->OV[(_x_)].OriginatorGuid)
#define IdtOriginatorVSN(_rec_, _x_)  ((_rec_)->OV[(_x_)].OriginatorVSN)
#endif


//
// The Data Extension Field for the IDTable Record.
//
// This field has a fixed Size buffer with var len data.  For backward compat
// with older databases NEVER shrink the size of this struct.
// DbsFieldDataSize in createdb.c for details.
//
typedef struct _IDTABLE_RECORD_EXTENSION_ {
    ULONG FieldSize;
    USHORT Major;
    USHORT OffsetCount;

    //
    // use offsets from the base of the struct to each component so we avoid
    // problems with alignement packing.
    //
    ULONG Offset[2];    // Offsets to data components.
    ULONG OffsetLast;   // The last offset is always zero.

    DATA_EXTENSION_CHECKSUM      DataChecksum;
    DATA_EXTENSION_RETRY_TIMEOUT DataRetryTimeout;

    // Add new components in here.

} IDTABLE_RECORD_EXTENSION, *PIDTABLE_RECORD_EXTENSION;


typedef struct _IDTABLE_RECORD {
    GUID         FileGuid;
    LONGLONG     FileID;
    GUID         ParentGuid;
    LONGLONG     ParentFileID;

    // IDTABLE_OBJECT_VERSION OV[MAX_IDTABLE_OBJECTS];
    ULONG        VersionNumber;
    LONGLONG     EventTime;
    GUID         OriginatorGuid;
    ULONGLONG    OriginatorVSN;

    USN          CurrentFileUsn;

    LARGE_INTEGER FileCreateTime;
    LARGE_INTEGER FileWriteTime;
    ULONGLONG    FileSize;
    FILE_OBJECTID_BUFFER FileObjID;
    WCHAR        FileName[MAX_PATH+1];
    BOOL         FileIsDir;
    ULONG        FileAttributes;
    ULONG        Flags;
    BOOL         ReplEnabled;
    FILETIME     TombStoneGC;

    ULONGLONG    OutLogSeqNum;
    ULONGLONG    IdtVVFlags;     // The spare field Spare1Ull is now IdtVVFlags
    ULONGLONG    Spare2Ull;
    GUID         Spare1Guid;
    GUID         Spare2Guid;
    PWCHAR       Spare1Wcs;
    PWCHAR       Spare2Wcs;
    IDTABLE_RECORD_EXTENSION Extension; // See above
    PVOID        Spare2Bin;

} IDTABLE_RECORD, *PIDTABLE_RECORD;


//
// IDTable Record Flags -
//
// IDREC_FLAGS_DELETE_DEFERRED:
//
// Deferred delete deals with the resolution of a delete dir on one member while
// a second member simultaneously creates a child file or dir.  With the
// previous solution (see below) the delete dir gets stuck in a retry loop (AND
// the unjoin prevents us from sending the ACK so the partner resends the CO at
// rejoin anyway).  To resolve this the delete dir must be able to determine if
// there are currently any valid children when we get a dir_not_empty return
// status while executing the delete dir.  If there are valid children then the
// delete dir loses and gets aborted.  If there are no valid children the dir
// gets marked as deleted with deferred delete set and is sent to retry so it
// can finally get a shot at deleting the dir.
//
// We can get into this situation in one of two ways:
//   (1) A sharing violation prevented the prior deletion of a child under the
//   dir in question.  The child delete was sent to retry.  Then the parent
//   dir delete arrived and failed with dir_not_empty.
//
//   (2) A new child file was created just before the delete for the parent
//   arrived.  There is no delete pending for the second case so the parent
//   delete dir should be aborted.  (The parent dir is reanimated on other
//   members where parent delete dir arrived first.  The arrival of the child
//   create triggers the parent reanimation.)
//
// For the first case, the sharing violation on the child sent the delete
// change order to retry but delete deferred is set for the file so when the
// parent delete dir arrives it will find no valid children and it, in turn,
// sets delete deferred on the parent.
//
// The previous solution was to unjoin the connection when the delete dir
// failed.  This forced the change order stream arriving from that connection
// through retry which is later resubmitted in order.  But this doesn't work for
// case (2) above because no delete for the child will be forthcoming.  Using
// deferred delete solves this and in addition it eliminates the problem of
// spurious name morph conflicts if a conflicting dir create were to arrive from
// another connection.  This would occur in case (1) above where the parent
// delete dir is in retry because of the sharing violation on the child.  Since
// the dir name is still in use, the arrival of a new dir create with the same
// name would cause an unintended name morph collision.
//
//

#define IDREC_FLAGS_DELETED               0x00000001
#define IDREC_FLAGS_CREATE_DEFERRED       0x00000002
#define IDREC_FLAGS_DELETE_DEFERRED       0x00000004
#define IDREC_FLAGS_RENAME_DEFERRED       0x00000008

#define IDREC_FLAGS_NEW_FILE_IN_PROGRESS  0x00000010
#define IDREC_FLAGS_ENUM_PENDING          0x00000020

#define IDREC_FLAGS_ALL              0xFFFFFFFF

#define IsIdRecFlagSet(_p_, _f_) BooleanFlagOn((_p_)->Flags, (_f_))
#define SetIdRecFlag(_p_, _f_)   SetFlag(      (_p_)->Flags, (_f_))
#define ClearIdRecFlag(_p_, _f_) ClearFlag(    (_p_)->Flags, (_f_))

#define IDTRecIsDirectory(_idrec_) \
    (BooleanFlagOn((_idrec_)->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) || \
     (_idrec_)->FileIsDir)


//
// Need separate VV flags since they are updated asynchronously from the Flags.
// (this is a ULONGLONG but currently only the lower LONG is used.)
//
#define IDREC_VVFLAGS_SKIP_VV_UPDATE        0x00000001

#define IsIdRecVVFlagSet(_p_, _f_)                      ((BOOLEAN)(((ULONG) (_p_)->IdtVVFlags & (_f_)) != 0))
#define SetIdRecVVFlag(_p_, _f_)   (_p_)->IdtVVFlags = (ULONGLONG) ((ULONG) (_p_)->IdtVVFlags | (_f_))
#define ClearIdRecVVFlag(_p_, _f_) (_p_)->IdtVVFlags = (ULONGLONG) ((ULONG) (_p_)->IdtVVFlags & ~(_f_))

//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS IDTableRecordFields[];

extern JET_SETCOLUMN IDTableJetSetCol[IDTABLE_MAX_COL];



//
// The IDTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
typedef enum _IDTABLE_INDEX_LIST {
    GuidIndexx = 0,         // The index on the file GUID.
    FileIDIndexx,           // The index on the file ID.
    ParGuidFileNameIndexx,  // The index on the parent Guid and the file name.

    IDTABLE_MAX_INDEX
} IDTABLE_INDEX_LIST;


extern JET_INDEXCREATE IDTableIndexDesc[];





 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                           V V T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The VVTable column descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// The Version Vector Table (VVTable) is a per-Replica table.
// It is used by the replication service to dampen propagation of updates
// to replicas that already are up to date.  There is one entry per member of
// the replica set.  Each entry has the GUID of the originating member and
// the Volume Sequence Number (VSN) of the most recent change this member has
// seen from that member.
//

typedef enum _VVTABLE_COL_LIST {
    VVOriginatorGuidx = 0,    // The replica set member Guid.
    VVOriginatorVsnx,         // The VSN of the most recent change from this member.
    VVOutlogOriginatorVsnx,   // The VSN of the last entry deleted from outlog. Used to be VVSpare1Ullx
    VVSpare2Ullx,
    VVTABLE_MAX_COL
} VVTABLE_COL_LIST;


extern JET_COLUMNCREATE VVTableColDesc[];

//
// VVTable record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
//
typedef struct _VVTABLE_RECORD {
    GUID         VVOriginatorGuid;
    ULONGLONG    VVOriginatorVsn;
    ULONGLONG    VVOutlogOriginatorVsn; // The spare field Spare1Ull is now VVOutlogOriginatorVsn
    ULONGLONG    Spare2Ull;
} VVTABLE_RECORD, *PVVTABLE_RECORD;


//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS VVTableRecordFields[];

extern JET_SETCOLUMN VVTableJetSetCol[VVTABLE_MAX_COL];



//
// The VVTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
typedef enum _VVTABLE_INDEX_LIST {
    VVOriginatorGuidIndexx,        // The index on the originator Guid.
    VVTABLE_MAX_INDEX
} VVTABLE_INDEX_LIST;


extern JET_INDEXCREATE VVTableIndexDesc[];




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **            R E P L I C A   S E T   C O N F I G   T A B L E                **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
//
//
// There is only one config table in the database.  Each row in the table
// describes the configuration info for a single replica set.
//
//   Jet is limited in the number if databases that can be open at one time to
//   about 5.  The limit on open tables is much larger and is configurable.
//   As a result instead of having a single database per replica set all replica
//   sets must use the same database.  We use a replica set table indexed by the
//   replica set GUID to tell us which group of tables is used to manage that
//   replica set.
//   What should go in registry and what should go in jet Table?
//     The registry must have the path to the jet database area.
//     Time DB was created.
//     Time DB was last verified.
//     Time DB was last compacted.
//     Time DB was last backed up.
//     DS Polling interval
//     Local machine name and guid
//     Jet parameters like max number of open tables.
//
//   Maybe just put stuff in registry that we need if Jet Table is corrupted.
//   Need to be able to tell if JDB is a diff version from the one that we
//   used when we last ran by comparing state in a reg key.  This way we know
//   to go thru VERIFICATION.  (content and FID checking)  If the replica tree
//   was just copied or restored from backup all the FIDs can be different.
//   We need a way to check this.  Perhaps if we save the Volume USN at last
//   shutdown (or periodically in case of dirty shutdown) we can use this as
//   a hint to do a VERIFICATION.  The saved vol USN also tells us if we missed
//   volume activity while FRS was not running.
//
//   If any of the following consistency checks fail then we do a full
//   VERIFICATION between the files and the DB entries for the replication set.
//
//     NTFS Vol ID - to check for a restore that makes the fids wrong.
//     NTFS Volume Guid
//     NTFS Volume USN Checkpoint -- to see if we missed USN records.
//
//typedef struct _FILE_FS_VOLUME_INFORMATION {
//    LARGE_INTEGER VolumeCreationTime;
//    ULONG VolumeSerialNumber;
//    ULONG VolumeLabelLength;
//    BOOLEAN SupportsObjects;
//    WCHAR VolumeLabel[1];
//} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;
//
//     Registry Sequence Number -- to sanity check DB
//     RootPath of replica tree -- If this changes we need to check fids.

//   Inbound partner state (name, guid, connect info & status of last connect, last time repl occurred, stats, comm protocol)

//   Resource stats (disk space used/free, disk I/Os, DB space used/free, memory, error counts, #times update was blocked);

//   ********************************************************
//   On all binary structs include a rev level and a size.
//   Also include a rev level on the table defs.
//   (**) config params that are service wide are only present in the
//   system init '<init>' record.
//   ********************************************************
//

//
// Definition of the Jet System Parameters.  Each entry consists of a Jet
// defined parameter code and either a long or a string argument.  The ParamType
// tells which.  If a long the value is in ParamValue.  If a string the value
// is an offset from the base of the struct to the start of the string.
// The strings are stored at the end of the struct.
//
#define MAX_JET_SYSTEM_PARAMS 38


#define JPARAM_TYPE_LAST   0xf0f0f0f0
#define JPARAM_TYPE_LONG   1
#define JPARAM_TYPE_STRING 2
#define JPARAM_TYPE_SKIP   3

typedef struct _JET_PARAM_ENTRY {
    CHAR  ParamName[24];
    ULONG ParamId;
    ULONG ParamType;
    ULONG ParamValue;
} JET_PARAM_ENTRY, *PJET_PARAM_ENTRY;

typedef struct _JET_SYSTEM_PARAMS {
    ULONG Size;

    JET_PARAM_ENTRY ParamEntry[MAX_JET_SYSTEM_PARAMS];

    CHAR ChkPointFilePath[MAX_PATH];
    CHAR TempFilePath[MAX_PATH];
    CHAR LogFilePath[MAX_PATH];
    CHAR EventSource[20];
} JET_SYSTEM_PARAMS, *PJET_SYSTEM_PARAMS;


typedef struct _CHANGE_ORDER_STATS {
    ULONGLONG  NumCoIssued;
    ULONGLONG  NumCoRetired;
    ULONGLONG  NumCoAborts;

    ULONGLONG  NumCoStageGenReq;
    ULONGLONG  NumCoStageGenBytes;
    ULONGLONG  NumCoStageRetries;

    ULONGLONG  NumCoFetchReq;
    ULONGLONG  NumCoFetchBytes;
    ULONGLONG  NumCoFetchRetries;

    ULONGLONG  NumCoInstallRetries;
    ULONGLONG  NumFilesUpdated;

    ULONGLONG  NumInCoDampened;
    ULONGLONG  NumOutCoDampened;
    ULONGLONG  NumCoPropagated;
} CHANGE_ORDER_STATS, *PCHANGE_ORDER_STATS;


typedef struct _COMM_STATS {
    ULONGLONG  NumCoCmdPktsSent;
    ULONGLONG  NumCoCmdBytesSent;

    ULONGLONG  NumCoCmdPktsRcvd;
    ULONGLONG  NumCoCmdBytesRcvd;

    ULONGLONG  NumCoDataPktsSent;
    ULONGLONG  NumCoDataBytesSent;

    ULONGLONG  NumCoDataPktsRcvd;
    ULONGLONG  NumCoDataBytesRcvd;

    ULONGLONG  NumJoinReq;
    ULONGLONG  NumJoinReqDenied;
    ULONGLONG  NumJoinError;

} COMM_STATS, *PCOMM_STATS;

typedef struct _REPLICA_STATS {
    ULONG              Size;
    ULONG              Version;
    FILETIME           UpdateTime;

    CHANGE_ORDER_STATS Local;
    CHANGE_ORDER_STATS Remote;

    COMM_STATS         InBound;
    COMM_STATS         OutBound;

} REPLICA_STATS, *PREPLICA_STATS;

#define TALLY_STATS(_cr_, _category_, _field_, _data_)           \
    FRS_ASSERT((_cr_) != NULL);                                  \
    (_cr_)->PerfStats->_category_._field_ += (ULONGLONG)(_data_)

#define TALLY_LOCALCO_STATS(_cr_, _field_, _data_) \
    TALLY_STATS(_cr_, Local, _field_, _data_)

#define TALLY_REMOTECO_STATS(_cr_, _field_, _data_) \
    TALLY_STATS(_cr_, Remote, _field_, _data_)

#define TALLY_INBOUND_COMM_STATS(_cr_, _field_, _data_) \
    TALLY_STATS(_cr_, InBound, _field_, _data_)

#define TALLY_OUTBOUND_COMM_STATS(_cr_, _field_, _data_) \
    TALLY_STATS(_cr_, OutBound, _field_, _data_)

#define READ_STATS(_cr_, _category_, _field_)                    \
    (((_cr_) != NULL) ? (_cr_)->PerfStats->_category_._field     \
                       : (FRS_ASSERT((_cr_) != NULL), (ULONGLONG) 0))


typedef enum _CONFIG_TABLE_COL_LIST {
    ReplicaSetGuidx = 0,    // The guid assigned to the tree root dir and the replica set.
    ReplicaMemberGuidx,     // The guid assigned to this member of the replica set. (INDEXED)
    ReplicaSetNamex,        // The replica set name.
    ReplicaNumberx,         // The replica set number (integer, for suffix on table names).
    ReplicaMemberUSNx,      // The Replica member USN.  Saved in the registry for consistency check.

    ReplicaMemberNamex,     // Common-Name from NTFRS-Member
    ReplicaMemberDnx,       // Distinguished name from NTFRS-Member
    ReplicaServerDnx,       // Distinguished name from Server
    ReplicaSubscriberDnx,   // Distinguished name from Subscriber
    ReplicaRootGuidx,       // GUID assigned to the root directory.
    MembershipExpiresx,     // Membership Tombstone expiration time
    ReplicaVersionGuidx,    // originator guid for version vector
    ReplicaSetExtx,         // Frs-Extensions from NTFRS-Replica-Set
    ReplicaMemberExtx,      // Frs-Extensions from NTFRS-Member
    ReplicaSubscriberExtx,  // Frs-Extensions from NTFRS-Subscriber
    ReplicaSubscriptionsExtx, // Frs-Extensions from NTFRS-Subscriptions
    ReplicaSetTypex,        // Frs-Replica-Set-Type from NTFRS-Replica-Set
    ReplicaSetFlagsx,       // Frs-Flags from NTFRS-Replica-Set
    ReplicaMemberFlagsx,    // Frs-Flags from NTFRS-Member
    ReplicaSubscriberFlagsx,// Frs-Flags from NTFRS-Subscriber
    ReplicaDsPollx,         // Frs-DS-Poll
    ReplicaAuthLevelx,      // Frs-Partner-Auth-Level
    ReplicaCtlDataCreationx, // Frs-Control-Data-Creation
    ReplicaCtlInboundBacklogx, // Frs-Control-Inbound-Backlog
    ReplicaCtlOutboundBacklogx, // Frs-Control-Outbound-Backlog
    ReplicaFaultConditionx, // Frs-Fault-Condition
    TimeLastCommandx,       // Frs-Time-Last-Command

    DSConfigVersionNumberx, // The version number of the DS config info.
    FSVolInfox,             // The NTFS volume info of the replica tree.
    FSVolGuidx,             // The NTFS volume Guid.
    FSVolLastUSNx,          // The last volume USN we saw from the journal when service stopped or paused.
    FrsVsnx,                // The Frs defined Volume sequence number exported by all R.S. on volume.

    LastShutdownx,          // The UTC time service on this replica set was last shutdown.
    LastPausex,             // The UTC time updates to this replica set were last paused.
    LastDSCheckx,           // The UTC time we last checked the DS for config info.
    LastDSChangeAcceptedx,  // The UTC time we last accepted a DS config change for this replica set.
    LastReplCycleStartx,    // The UTC time the last replication cycle started.
    DirLastReplCycleEndedx, // The UTC time the last replication cycle ended.
    ReplicaDeleteTimex,     // The UTC time the replica set was deleted.
    LastReplCycleStatusx,   // The termination status of the last replication cycle.

    FSRootPathx,            // The path of the root of the replica tree.
    FSRootSDx,              // The security descriptor on the root.  Used in the single-master case.  Not replicated.
    FSStagingAreaPathx,     // The path to the file system staging area.
    SnapFileSizeLimitx,     // The maximum size of a file (KB units) that we will snapshot. (0 if no limit)
    ActiveServCntlCommandx, // The currently active service control command.
    ServiceStatex,          // The current service state (see below)

    ReplDirLevelLimitx,     // The max number of dir levels files are replicated. 0x7FFFFFFF means no limit.
    InboundPartnerStatex,   // A binary struct of the inbound partner config info.
    DsInfox,                // A binary struct of the Dir Service Information.

    CnfFlagsx,              // Misc config flags.  See below.

    AdminAlertListx,        // A string of Admin IDs to alert on exceptional conditions.

    ThrottleSchedx,         // The schedule of bandwidth throttling.
    ReplSchedx,             // The schedule of replication activity.
    FileTypePrioListx,      // A list of file types and repl priority levels.

    ResourceStatsx,         // A binary struct of resource stats like disk & DB space used/free.
    PerfStatsx,             // A binary struct of perf stats like number of I/Os done, # Files repl, ...
    ErrorStatsx,            // A binary struct of error stats like number of share viol blocking update, ...

    FileFilterListx,        // A list of file types that are not replicated.
    DirFilterListx,         // A list of dir paths (relative to the root) of dirs that are not replicated.
    TombstoneLifex,         // Tombstone life time for deleted files in days.
    GarbageCollPeriodx,     // The time between garbage collection in seconds.
    MaxOutBoundLogSizex,    // The maximum number of entries to be kept in the outbound log.
    MaxInBoundLogSizex,     // The maximum number of entries to be kept in the inbound log.
    UpdateBlockedTimex,     // The max time an update can be blocked before an alert is gen. (sec).
    EventTimeDiffThresholdx,// Two event times are the same if their diff is less than this. (ms)
    FileCopyWarningLevelx,  // The maximum tries to copy a file before a warning alert is generated. (kb)
    FileSizeWarningLevelx,  // New files greater than this size generate a warning alert. (kb)
    FileSizeNoRepLevelx,    // New files greater than this size generate an alert and are not replicated. (kb)

    CnfUsnJournalIDx,       // Journal Instance ID to detect journal recreation.
    CnfSpare2Ullx,
    CnfSpare1Guidx,
    CnfSpare2Guidx,
    CnfSpare1Wcsx,
    CnfSpare2Wcsx,
    CnfSpare1Binx,
    CnfSpare2Binx,
                            // --------------------------------------------------------------------------------
                            // The above is per-replica data.  Below this is data in the FRS init record '<init>'.
                            // --------------------------------------------------------------------------------
//
// Note: Consider adding Version number of the USN Journal Records the service
//       can work with.
//
    MachineNamex,           // The local machine name. (**)
    MachineGuidx,           // The local machine GUID. (**)
    MachineDnsNamex,        // The local machine DNS name. (**)
    TableVersionNumbersx,   // An array of version numbers, one per table type. (**)
    FSDatabasePathx,        // The path to the jet database.  (**)
    FSBackupDatabasePathx,  // The path to the backup jet database.  (**)

    ReplicaNetBiosNamex,    // SAM-Account-Name from Computer (minus the $)
    ReplicaPrincNamex,      // NT4 account name cracked from Computer
    ReplicaCoDnx,           // Distinguished name from Computer
    ReplicaCoGuidx,         // Object-GUID from Computer
    ReplicaWorkingPathx,    // Frs-Working-Path
    ReplicaVersionx,        // Frs-Version  "NTFRS Major.Minor.Patch  (build date)"
    FrsDbMajorx,            // Binary major version number of DB
    FrsDbMinorx,            // Binary minor version number of DB

    JetParametersx,         // The list of jet parameters in affect.  Only present in the first record.
                            // Used to set up config on a restore or new machine build.

    CONFIG_TABLE_MAX_COL
} CONFIG_TABLE_COL_LIST;

//
// Define the boundary between per-replica fields and the additional fields in
// the <init> record.  This makes the DB access a little quicker since the
// <init> record is only read once at startup.
//
#define REPLICA_CONFIG_RECORD_MAX_COL (MachineNamex)

#define  CONTROL_STRING_MAX 32

extern JET_COLUMNCREATE ConfigTableColDesc[];


//
// ConfigTable record definition.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
typedef struct _CONFIG_TABLE_RECORD {
    GUID     ReplicaSetGuid;
    GUID     ReplicaMemberGuid;
    WCHAR    ReplicaSetName[DNS_MAX_NAME_LENGTH+1];
    ULONG    ReplicaNumber;
    LONGLONG ReplicaMemberUSN;

    PWCHAR   ReplicaMemberName;      // Common-Name from NTFRS-Member
    PWCHAR   ReplicaMemberDn;        // Distinguished name from NTFRS-Member
    PWCHAR   ReplicaServerDn;        // Distinguished name from Server
    PWCHAR   ReplicaSubscriberDn;    // Distinguished name from Subscriber
    GUID     ReplicaRootGuid;        // GUID assigned to the root directory.
    FILETIME MembershipExpires;      // Membership Tombstone expiration time
    GUID     ReplicaVersionGuid;     // Frs-Version-GUID
    PVOID    ReplicaSetExt;          // Frs-Extensions from NTFRS-Replica-Set
    PVOID    ReplicaMemberExt;       // Frs-Extensions from NTFRS-Member
    PVOID    ReplicaSubscriberExt;   // Frs-Extensions from NTFRS-Subscriber
    PVOID    ReplicaSubscriptionsExt;// Frs-Extensions from NTFRS-Subscriptions
    ULONG    ReplicaSetType;         // Frs-Replica-Set-Type from NTFRS-Replica-Set
    ULONG    ReplicaSetFlags;        // Frs-Flags from NTFRS-Replica-Set, see below.
    ULONG    ReplicaMemberFlags;     // Frs-Flags from NTFRS-Member, see below.
    ULONG    ReplicaSubscriberFlags; // Frs-Flags from NTFRS-Subscriber, see below.
    ULONG    ReplicaDsPoll;          // Frs-DS-Poll
    ULONG    ReplicaAuthLevel;       // Frs-Partner-Auth-Level
    WCHAR    ReplicaCtlDataCreation[CONTROL_STRING_MAX]; // Frs-Control-Data-Creation
    WCHAR    ReplicaCtlInboundBacklog[CONTROL_STRING_MAX]; // Frs-Control-Inbound-Backlog
    WCHAR    ReplicaCtlOutboundBacklog[CONTROL_STRING_MAX]; // Frs-Control-Outbound-Backlog
    ULONG    ReplicaFaultCondition;  // Frs-Fault-Condition, see below.
    FILETIME TimeLastCommand;        // Frs-Time-Last-Command

    ULONG    DSConfigVersionNumber;
    PFILE_FS_VOLUME_INFORMATION   FSVolInfo;
    GUID     FSVolGuid;
    LONGLONG FSVolLastUSN;           // Keep this here so the file
    ULONGLONG FrsVsn;                // times are quadword aligned.

    ULONGLONG LastShutdown;          // A FILETIME.
    FILETIME LastPause;
    FILETIME LastDSCheck;
    FILETIME LastDSChangeAccepted;
    FILETIME LastReplCycleStart;
    FILETIME DirLastReplCycleEnded;
    FILETIME ReplicaDeleteTime;      // Time replica set was deleted.
    ULONG    LastReplCycleStatus;

    WCHAR    FSRootPath[MAX_PATH+1];
    SECURITY_DESCRIPTOR *FSRootSD;   // var len (or use ACLID table)
    WCHAR    FSStagingAreaPath[MAX_PATH+1];
    ULONG    SnapFileSizeLimit;
    PVOID    ActiveServCntlCommand;  // struct needed for pars?
    ULONG    ServiceState;

    ULONG    ReplDirLevelLimit;

    PVOID    InboundPartnerState;    // need struct  // delete
    PVOID    DsInfo;

    ULONG    CnfFlags;

    PWCHAR   AdminAlertList;         // var len

    PVOID    ThrottleSched;          // need array or struct
    PVOID    ReplSched;              // need array or struct
    PVOID    FileTypePrioList;       // need array or struct

    PVOID    ResourceStats;          // need array or struct
    PREPLICA_STATS  PerfStats;
    PVOID    ErrorStats;             // need array or struct

    PWCHAR   FileFilterList;         // var len
    PWCHAR   DirFilterList;          // var len
    ULONG    TombstoneLife;
    ULONG    GarbageCollPeriod;
    ULONG    MaxOutBoundLogSize;
    ULONG    MaxInBoundLogSize;
    ULONG    UpdateBlockedTime;
    ULONG    EventTimeDiffThreshold;
    ULONG    FileCopyWarningLevel;
    ULONG    FileSizeWarningLevel;
    ULONG    FileSizeNoRepLevel;

    ULONGLONG CnfUsnJournalID;        // Used for UsnJournalID.
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;
    GUID      Spare2Guid;
    PWCHAR    Spare1Wcs;
    PWCHAR    Spare2Wcs;
    PVOID     Spare1Bin;
    PVOID     Spare2Bin;

    //
    // Everything below this line is present only in the FRS <init> record.
    // Everything above is per-replica state.
    //
    WCHAR    MachineName[MAX_RDN_VALUE_SIZE+1];
    GUID     MachineGuid;
    WCHAR    MachineDnsName[DNS_MAX_NAME_LENGTH+1];
    ULONG    TableVersionNumbers[FRS_MAX_TABLE_TYPES];
    WCHAR    FSDatabasePath[MAX_PATH+1];
    WCHAR    FSBackupDatabasePath[MAX_PATH+1];

    PWCHAR   ReplicaNetBiosName;     // SAM-Account-Name from Computer (minus the $)
    PWCHAR   ReplicaPrincName;       // NT4 account name cracked from Computer
    PWCHAR   ReplicaCoDn;            // Distinguished name from Computer
    GUID     ReplicaCoGuid;          // Object-GUID from Computer
    PWCHAR   ReplicaWorkingPath;     // Frs-Working-Path
    PWCHAR   ReplicaVersion;         // Frs-Version  "NTFRS Major.Minor.Patch  (build date)"
    ULONG    FrsDbMajor;             // Binary major version number of DB
    ULONG    FrsDbMinor;             // Binary minor version number of DB

    PJET_SYSTEM_PARAMS JetParameters;

} CONFIG_TABLE_RECORD, *PCONFIG_TABLE_RECORD;

//
// Definitions of the CnfFlags ULONG.
//
// Note that Primary is specified by a field in the Replica Set Object in the DS.
// This field refs a member object so it is not possible to have more than
// one member be primary.
//
#define CONFIG_FLAG_MULTIMASTER   0x00000001  // This is a multi-master replica set.
#define CONFIG_FLAG_MASTER        0x00000002  // This machine is a master and will propagate Local COs.
#define CONFIG_FLAG_PRIMARY       0x00000004  // This is the first replica.
#define CONFIG_FLAG_SEEDING       0x00000008  // replica set has not been seeded.
#define CONFIG_FLAG_ONLINE        0x00000010  // replica set is ready to join with outbound.
                                              // This flag is set when the init sync
                                              // command server completes one pass.
#define CONFIG_FLAG_PRIMARY_UNDEFINED 0x00000020 // No primary is set in the DS.
//
// ReplicaMemberFlags -- (From Frs-Flags in NTFRS-Member Object)
//
#define FRS_MEMBER_FLAG_LEAF_NODE 0x00000001  // Don't propagate or originate files
                                              // or respond to fetch requests.
#define FRS_MEMBER_FLAG_CANT_ORIGINATE  0x00000002   // Don't originate local file changes

//
// ReplicaSetFlags -- (From Frs-Flags in NTFRS-Replica-Set Object)
//
//     See bit defs for FrsRsoFlags in Replica object in frsalloc.h
//

//
//  ReplicaSetType -- (From Frs-Replica-Set-Type in NTFRS-Replica-Set Object)
//
#define FRS_RSTYPE_ENTERPRISE_SYSVOL    1     // This replica set is enterprise system volume
#define FRS_RSTYPE_ENTERPRISE_SYSVOLW   L"1"  //    for ldap
#define FRS_RSTYPE_DOMAIN_SYSVOL        2     // This replica set is domain system volume
#define FRS_RSTYPE_DOMAIN_SYSVOLW       L"2"  //    for ldap
#define FRS_RSTYPE_DFS                  3     // A DFS alternate set
#define FRS_RSTYPE_DFSW                 L"3"  //    for ldap
#define FRS_RSTYPE_OTHER                4     // None of the above.
#define FRS_RSTYPE_OTHERW               L"4"  //    for ldap
//
// Is this replica set a sysvol?
//
#define FRS_RSTYPE_IS_SYSVOL(_T_) \
        ((_T_) == FRS_RSTYPE_ENTERPRISE_SYSVOL || \
         (_T_) == FRS_RSTYPE_DOMAIN_SYSVOL)
#define FRS_RSTYPE_IS_SYSVOLW(_TW_) \
        (_TW_ && \
         (WSTR_EQ(_TW_, FRS_RSTYPE_ENTERPRISE_SYSVOLW) || \
          WSTR_EQ(_TW_, FRS_RSTYPE_DOMAIN_SYSVOLW)))

//
// ReplicaSubscriberFlags -- (From Frs-Flags in NTFRS-Subscriber Object)
//
#define FRS_SUBSCRIBE_FLAG_DELFILE_ON_REMOVE  0x00000001   // Delete files when member is removed.

//
// ReplicaFaultCondition -- (From Frs-Fault-Condition in NTFRS-Subscriber Object)
//
#define FRS_SUBSCRIBE_FAULT_CONDITION_NORMAL    0  // Operating normally on this R/S
#define FRS_SUBSCRIBE_FAULT_CONDITION_STOPPED   1  // Replication stopped by request.
#define FRS_SUBSCRIBE_FAULT_CONDITION_WARNING   2  // Replication running but attention is needed.
#define FRS_SUBSCRIBE_FAULT_CONDITION_ERROR     3  // Replication stopped by error condition.


extern JET_SETCOLUMN ConfigTableJetSetCol[CONFIG_TABLE_MAX_COL];


//
// The ConfigTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
//
typedef enum _CONFIG_TABLE_INDEX_LIST {
    ReplicaNumberIndexx = 0,       // The index on the Replica set number.
    ReplicaMemberGuidIndexx,       // The index on the Replica Set member GUID.
    ReplicaSetNameIndexx,          // The index on the Replica Set name
    CONFIG_TABLE_MAX_INDEX
} CONFIG_TABLE_INDEX_LIST;

extern JET_INDEXCREATE ConfigTableIndexDesc[];


//
// Service State of this replica set.  Update DbsDBInitialize if states change.
//
typedef enum _SERVICE_STATE_LIST {
    CNF_SERVICE_STATE_CREATING = 0,     // Creating a new replica set
    CNF_SERVICE_STATE_INIT,             // Initializing an exisiting replica set
    CNF_SERVICE_STATE_RECOVERY,         // Recovering exisitng replica set
    CNF_SERVICE_STATE_RUNNING,          // Replica set up and running (modulo sched, cxtions, etc)
    CNF_SERVICE_STATE_CLEAN_SHUTDOWN,   // Replica set did a clean shutdown
    CNF_SERVICE_STATE_ERROR,            // Replica set is in an Error state.
    CNF_SERVICE_STATE_TOMBSTONE,        // Replica set has been marked for deletion.
    CNF_SERVICE_STATE_MAX
} SERVICE_STATE_LIST;

//
// Macro to update service state on this replica.
//
#define CNF_RECORD(_Replica_) \
    ((PCONFIG_TABLE_RECORD) ((_Replica_)->ConfigTable.pDataRecord))

#define SET_SERVICE_STATE(_Replica_, _state_)                                 \
{                                                                             \
    DPRINT3(4, ":S: Service State change from %s to %s for %ws\n",            \
            (CNF_RECORD(_Replica_)->ServiceState < CNF_SERVICE_STATE_MAX ) ?  \
                ServiceStateNames[CNF_RECORD(_Replica_)->ServiceState]     :  \
                ServiceStateNames[CNF_SERVICE_STATE_CREATING],                \
            ServiceStateNames[(_state_)],                                     \
                                                                              \
            ((_Replica_)->ReplicaName != NULL) ?                              \
                (_Replica_)->ReplicaName->Name : L"<null>");                  \
                                                                              \
    CNF_RECORD(_Replica_)->ServiceState = (_state_);                          \
}

#define SET_SERVICE_STATE2(_Cr_, _state_)                                  \
{                                                                          \
    DPRINT3(4, ":S: Service State change from %s to %s for %ws\n",         \
            ((_Cr_)->ServiceState < CNF_SERVICE_STATE_MAX ) ?              \
                ServiceStateNames[(_Cr_)->ServiceState]     :              \
                ServiceStateNames[CNF_SERVICE_STATE_CREATING],             \
                                                                           \
            ServiceStateNames[(_state_)],                                  \
            ((_Cr_)->ReplicaSetName != NULL) ?                             \
                (_Cr_)->ReplicaSetName : L"<null>");                       \
                                                                           \
    (_Cr_)->ServiceState = (_state_);                                      \
}

#define SERVICE_STATE(_Replica_) (CNF_RECORD(_Replica_)->ServiceState)


extern PCHAR ServiceStateNames[CNF_SERVICE_STATE_MAX];



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                      S e r v i c e   T a b l e                            **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The ServiceTable column descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// The service table contains service wide init/config params.
// There is only one Service Table.
//

typedef enum _SERVICE_TABLE_COL_LIST {
    SvcFrsDbMajorx = 0,        // Binary major version number of DB
    SvcFrsDbMinorx,            // Binary minor version number of DB
    SvcMachineNamex,           // The local machine name.
    SvcMachineGuidx,           // The local machine GUID.
    SvcMachineDnsNamex,        // The local machine DNS name.
    SvcTableVersionNumbersx,   // An array of version numbers, one per table type.
    SvcFSDatabasePathx,        // The path to the jet database.
    SvcFSBackupDatabasePathx,  // The path to the backup jet database.

    SvcReplicaNetBiosNamex,    // SAM-Account-Name from Computer (minus the $)
    SvcReplicaPrincNamex,      // NT4 account name cracked from Computer
    SvcReplicaCoDnx,           // Distinguished name from Computer
    SvcReplicaCoGuidx,         // Object-GUID from Computer
    SvcReplicaWorkingPathx,    // Frs-Working-Path
    SvcReplicaVersionx,        // Frs-Version  "NTFRS Major.Minor.Patch  (build date)"

    SvcSpare1Ullx,
    SvcSpare2Ullx,
    SvcSpare1Guidx,
    SvcSpare2Guidx,
    SvcSpare1Wcsx,
    SvcSpare2Wcsx,
    SvcSpare1Binx,
    SvcSpare2Binx,

    SvcJetParametersx,         // The list of jet parameters in affect.  Only present in the first record.
                               // Used to set up config on a restore or new machine build.
    SERVICE_TABLE_MAX_COL
} SERVICE_TABLE_COL_LIST;


extern JET_COLUMNCREATE ServiceTableColDesc[];

//
// Service Table record definition.
//
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than sizeof(PVOID) where the field def in the corresponding
// record struct is sizeof(PVOID) (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
//
typedef struct _SERVICE_TABLE_RECORD {

    ULONG     FrsDbMajor;             // Binary major version number of DB
    ULONG     FrsDbMinor;             // Binary minor version number of DB

    WCHAR     MachineName[MAX_RDN_VALUE_SIZE+1];
    GUID      MachineGuid;
    WCHAR     MachineDnsName[DNS_MAX_NAME_LENGTH+1];
    ULONG     TableVersionNumbers[FRS_MAX_TABLE_TYPES];
    WCHAR     FSDatabasePath[MAX_PATH+1];
    WCHAR     FSBackupDatabasePath[MAX_PATH+1];

    PWCHAR    ReplicaNetBiosName;     // SAM-Account-Name from Computer (minus the $)
    PWCHAR    ReplicaPrincName;       // NT4 account name cracked from Computer
    PWCHAR    ReplicaCoDn;            // Distinguished name from Computer
    GUID      ReplicaCoGuid;          // Object-GUID from Computer
    PWCHAR    ReplicaWorkingPath;     // Frs-Working-Path
    PWCHAR    ReplicaVersion;         // Frs-Version  "NTFRS Major.Minor.Patch  (build date)"

    ULONGLONG Spare1Ull;
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;
    GUID      Spare2Guid;
    PWCHAR    Spare1Wcs;
    PWCHAR    Spare2Wcs;
    PVOID     Spare1Bin;
    PVOID     Spare2Bin;

    PJET_SYSTEM_PARAMS JetParameters;

} SERVICE_TABLE_RECORD, *PSERVICE_TABLE_RECORD;


//
// The RECORD_FIELDS struct is used to build the Jet Set Column struct.
//
extern RECORD_FIELDS ServiceTableRecordFields[];

extern JET_SETCOLUMN ServiceTableJetSetCol[SERVICE_TABLE_MAX_COL];

//
// The Service Table index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
typedef enum _SERVICE_TABLE_INDEX_LIST {
    FrsDbMajorIndexx,        // The index on the major version number.
    SERVICE_TABLE_MAX_INDEX
} SERVICE_TABLE_INDEX_LIST;


extern JET_INDEXCREATE ServiceTableIndexDesc[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\test.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    test.h

Abstract:

    Header file for test routines

Author:

    Billy J. Fuller (billyf)  19-Sep-1997 Created

Environment:

    User Mode Service

Revision History:

--*/
#ifndef _TEST_INCLUDED_
#define _TEST_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
// Test morphing during co retire
//
#if     DBG
#define TEST_DBSRENAMEFID_TOP(_Coe) \
            TestDbsRenameFidTop(_Coe)
#define TEST_DBSRENAMEFID_BOTTOM(_Coe, _Ret) \
            TestDbsRenameFidBottom(_Coe, _Ret)

VOID
TestDbsRenameFidTop(
    IN PCHANGE_ORDER_ENTRY Coe
    );

VOID
TestDbsRenameFidBottom(
    IN PCHANGE_ORDER_ENTRY Coe,
    IN ULONG               Ret
    );
#else   DBG
#define TEST_DBSRENAMEFID_TOP(_Coe)
#define TEST_DBSRENAMEFID_BOTTOM(_Coe, _Ret)
#endif  DBG

#ifdef __cplusplus
  }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\writer.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:
    writer.h

Abstract:
    Header file for FRS writer

Author:
    Reuven Lax 	17-Sep-2002
    
--*/

#ifndef _WRITER_H_
#define _WRITER_H_
extern "C" {
#include <ntreppch.h>
#include <frs.h>
#include <ntfrsapi.h>
}
#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>

// {D76F5A28-3092-4589-BA48-2958FB88CE29}
static const VSS_ID WriterId = 
{ 0xd76f5a28, 0x3092, 0x4589, { 0xba, 0x48, 0x29, 0x58, 0xfb, 0x88, 0xce, 0x29 } };

static const WCHAR* WriterName = L"FRS Writer";

// auto pointer that uses the FRS deallocation method
template <class T>
class CAutoFrsPointer	{
private:
    T* m_pointer;
    CAutoFrsPointer(const CAutoFrsPointer&);    // disable copy constructor
    CAutoFrsPointer& operator=(const CAutoFrsPointer&); // disable operator=
public:
    CAutoFrsPointer(T* pointer = NULL) : m_pointer(pointer)
        {}

    CAutoFrsPointer& operator=(T* pointer)  {
        FrsFree(m_pointer);
        m_pointer = pointer;
        return *this;
    }

    operator T*()   {
        return m_pointer;
    }

    T** GetAddress()    {
        return &m_pointer;
    }

    T* Detach() {
        T* old = m_pointer;
        m_pointer = NULL;
        return old;
    }

    ~CAutoFrsPointer()  {
        FrsFree(m_pointer);
    }
};

// FRS Writer class
class CFrsWriter : public CVssWriter    {
private:
    // auto object that ensures that the backup/restore context is always destroyed
    struct CAutoFrsBackupRestore    {
        CAutoFrsBackupRestore(void* context) : m_context(context)
            {}
        
        ~CAutoFrsBackupRestore()    {
            #undef DEBSUB
            #define  DEBSUB  "CFrsWriter::CAutoFrsBackupRestore::~CAutoFrsBackupRestore:"
            if (m_context && !WIN_SUCCESS(::NtFrsApiDestroyBackupRestore(&m_context, NTFRSAPI_BUR_FLAGS_NONE, NULL, NULL, NULL)))
                DPRINT(3, "failed to successfully call NtFrsApiDestroyBackupRestore\n");
            }         

        void* m_context;
    };

    static CFrsWriter* m_pWriterInstance;   // global instance of the writer
    CFrsWriter()
        {}

    virtual ~CFrsWriter()   {
        Uninitialize();
    }

    
    HRESULT STDMETHODCALLTYPE Initialize();
    void Uninitialize();

    bool AddExcludes(IVssCreateWriterMetadata* pMetadata, WCHAR* filters);
    bool ParseExclude(WCHAR* exclude, WCHAR** path, WCHAR** filespec, bool* recursive);
    bool ProcessReplicaSet(void* context, void* replicaSet, IVssCreateWriterMetadata* pMetadata, WCHAR** retFilters);
public:
    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

    virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

    virtual bool STDMETHODCALLTYPE OnFreeze();

    virtual bool STDMETHODCALLTYPE OnThaw();

    virtual bool STDMETHODCALLTYPE OnAbort();

    static HRESULT CreateWriter();

    static void DestroyWriter();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\tablefcn.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    tablefcn.h

Abstract:

    Defines the function prototypes for the functions used to access the
    Jet database tables.

    Include after frsalloc.h

Author:

    David Orbits (davidor) - 10-Apr-1997

Revision History:

*/

JET_ERR
DbsCreateJetSession(
    IN OUT PTHREAD_CTX    ThreadCtx
    );

JET_ERR
DbsCloseJetSession(
    IN PTHREAD_CTX  ThreadCtx
    );

JET_ERR
DbsInsertTable2(
    IN PTABLE_CTX    TableCtx
    );

JET_ERR
DbsTableMoveFirst(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         ReplicaNumber,
    IN ULONG         RecordIndex
    );

JET_ERR
DbsOpenTable0(
    IN  PTHREAD_CTX   ThreadCtx,
    IN  PTABLE_CTX    TableCtx,
    IN  ULONG         ReplicaNumber,
    OUT PCHAR         TableName,
    OUT JET_TABLEID  *Tid
    );

JET_ERR
DbsOpenReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PREPLICA_THREAD_CTX RtCtx
    );

FRS_ERROR_CODE
DbsCloseSessionReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    );

JET_ERR
DbsCloseReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA Replica,
    IN PREPLICA_THREAD_CTX RtCtx,
    IN BOOL SessionErrorCheck
    );

VOID
DbsSetJetColAddr (
    IN PTABLE_CTX TableCtx
    );

VOID
DbsSetJetColSize(
    IN PTABLE_CTX TableCtx
    );

NTSTATUS
DbsAllocRecordStorage(
    IN OUT PTABLE_CTX TableCtx
    );

JET_ERR
DbsCheckSetRetrieveErrors(
    IN OUT PTABLE_CTX TableCtx
    );

#if DBG
VOID
DbsDisplayRecord(
    IN ULONG       Severity,
    IN PTABLE_CTX  TableCtx,
    IN BOOL        Read,
    IN PCHAR       Debsub,
    IN ULONG       uLineNo,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    );
#endif DBG

JET_ERR
DbsRecordOperation(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         KeyValue,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    );

ULONG
DbsRecordOperationMKey(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         *KeyValueArray,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    );

JET_ERR
DbsWriteReplicaTableRecord(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx
    );

ULONG
DbsWriteTableField(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordFieldx
    );

ULONG
DbsWriteTableFieldMult(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN PULONG        RecordFieldx,
    IN ULONG         FieldCount
    );

PVOID
DbsDataExtensionFind(
    IN PVOID ExtBuf,
    IN DATA_EXTENSION_TYPE_CODES TypeCode
    );

VOID
DbsDataInitCocExtension(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    );

VOID
DbsDataInitIDTableExtension(
    IN PIDTABLE_RECORD_EXTENSION IdtExt
    );

DWORD
FrsGetOrSetFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName,
    IN  BOOL CallerSupplied,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

ULONG
ChgOrdInboundRetired(
    IN PCHANGE_ORDER_ENTRY ChangeOrder
    );

ULONG
ChgOrdInboundRetry(
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN ULONG                NewState
    );

//
// DB Service access functions.
//

VOID
DbsInitialize(
    VOID
    );

VOID
DbsShutDown(
    VOID
    );


PTABLE_CTX
DbsCreateTableContext(
    IN ULONG TableType
);

ULONG
DbsOpenTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       ReplicaNumber,
    IN ULONG       TableType,
    IN PVOID       DataRecord
    );

BOOL
DbsFreeTableContext(
    IN PTABLE_CTX TableCtx,
    IN JET_SESID  Sesid
);

PCOMMAND_PACKET
DbsPrepareCmdPkt (
    PCOMMAND_PACKET CmdPkt,
    PREPLICA        Replica,
    ULONG           CmdRequest,
    PTABLE_CTX      TableCtx,
    PVOID           CallContext,
    ULONG           TableType,
    ULONG           AccessRequest,
    ULONG           IndexType,
    PVOID           KeyValue,
    ULONG           KeyValueLength,
    BOOL            Submit
    );


PCOMMAND_PACKET
DbsPrepFieldUpdateCmdPkt (
    PCOMMAND_PACKET CmdPkt,
    PREPLICA        Replica,
    PTABLE_CTX      TableCtx,
    PVOID           CallContext,
    ULONG           TableType,
    ULONG           IndexType,
    PVOID           KeyValue,
    ULONG           KeyValueLength,
    ULONG           FieldCount,
    PULONG          FieldIDList
    );

ULONG
DbsInitializeIDTableRecord(
    IN OUT PTABLE_CTX            TableCtx,
    IN     HANDLE                FileHandle,
    IN     PREPLICA              Replica,
    IN     PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN     PWCHAR                FileName,
    IN OUT BOOL                  *ExistingOid
    );

VOID
DbsDBInitConfigRecord(
    IN PTABLE_CTX   TableCtx,
    IN GUID  *ReplicaSetGuid,
    IN PWCHAR ReplicaSetName,
    IN ULONG  ReplicaNumber,
    IN PWCHAR ReplicaRootPath,
    IN PWCHAR ReplicaStagingPath,
    IN PWCHAR ReplicaVolume
    );

ULONG
DbsFidToGuid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN PULONGLONG    Fid,
    OUT GUID         *Guid
    );

ULONG
DbsGuidToFid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN GUID          *Guid,
    OUT PULONGLONG   Fid
    );

ULONG
DbsInitOneReplicaSet(
    PREPLICA Replica
    );

ULONG
DbsFreeRtCtx(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PREPLICA_THREAD_CTX   RtCtx,
    IN BOOL SessionErrorCheck
    );

JET_ERR
DbsDeleteTableRecord(
    IN PTABLE_CTX    TableCtx
    );

ULONG
DbsDeleteTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    );

#define  DbsDeleteIDTableRecord(_ThreadCtx_, _Replica_, _TableCtx_, _pIndex_) \
    DbsDeleteTableRecordByIndex(_ThreadCtx_,  \
                                _Replica_,    \
                                _TableCtx_,   \
                                _pIndex_,     \
                                 GuidIndexx,  \
                                 IDTablex)

#define  DbsDeleteDIRTableRecord(_ThreadCtx_, _Replica_, _TableCtx_, _pIndex_) \
    DbsDeleteTableRecordByIndex(_ThreadCtx_,  \
                                _Replica_,    \
                                _TableCtx_,   \
                                _pIndex_,     \
                                 DFileGuidIndexx,  \
                                 DIRTablex)

ULONG
DbsReadTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    );

ULONG
DbsUpdateTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    );

ULONG
DbsInsertTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       TableType,
    IN PVOID       DataRecord
    );

ULONG
DbsTableMoveToRecord(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN ULONG         MoveArg
    );

#define FrsMoveFirst     JET_MoveFirst
#define FrsMovePrevious  JET_MovePrevious
#define FrsMoveNext      JET_MoveNext
#define FrsMoveLast      JET_MoveLast

ULONG
DbsTableRead(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx
    );

ULONG
DbsUpdateRecordField(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx,
    IN ULONG        IndexField,
    IN PVOID        IndexValue,
    IN ULONG        UpdateField
    );

ULONG
DbsRequestSaveMark(
    PVOLUME_MONITOR_ENTRY pVme,
    BOOL                  Wait
    );

ULONG
DbsRequestReplicaServiceStateSave(
    IN PREPLICA Replica,
    IN BOOL     Wait
    );

ULONG
DbsUpdateVV(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PREPLICA_THREAD_CTX  RtCtx,
    IN ULONGLONG            OriginatorVsn,
    IN GUID                 *OriginatorGuid
    );

//
// An enumerate table function is passed as a parameter to FrsEnumerateTable().
// It gets a PTHREAD_CTX, PTABLE_CTX and a pointer to a data record from the
// table.  It does its processing of the record data and returns a JET_ERR
// status.  If the status is JET_errSuccess it will be called with the next
// record in the table.  IF the status is NOT JET_errSuccess, that status is
// returned as the status result of the FrsEnumerateTable() function.  If
// the status is JET_errInvalidObject then re-read the record and call the table
// function again.
//
//
typedef
JET_ERR
(NTAPI *PENUMERATE_TABLE_ROUTINE) (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );


typedef
JET_ERR
(NTAPI *PENUMERATE_TABLE_PREREAD) (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Context
    );


typedef
JET_ERR
(NTAPI *PENUMERATE_OUTLOGTABLE_ROUTINE) (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    IN PVOID         Context,
    IN ULONG         OutLogSeqNumber
    );


JET_ERR
DbsEnumerateTable2(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN PENUMERATE_TABLE_ROUTINE RecordFunction,
    IN PVOID         Context,
    IN PENUMERATE_TABLE_PREREAD PreReadFunction
    );

JET_ERR
DbsEnumerateTableFrom(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN PVOID         KeyValue,
    IN INT           ScanDirection,
    IN PENUMERATE_TABLE_ROUTINE RecordFunction,
    IN PVOID         Context,
    IN PENUMERATE_TABLE_PREREAD PreReadFunction
    );

#define FrsEnumerateTable(_TH, _TC, _RI, _RF, _CTX)    \
    DbsEnumerateTable2(_TH, _TC, _RI, _RF, _CTX, NULL)

#define FrsEnumerateTableFrom(_TH, _TC, _RI, _KV, _SD,  _RF, _CTX)    \
    DbsEnumerateTableFrom(_TH, _TC, _RI, _KV, _SD, _RF, _CTX, NULL)

//
// An enumerate directory function is passed as a parameter to
// FrsEnumerateDirectory().
//
// The function gets a the directory handle and a pointer to a directory
// record from the directory.  It does its processing of the directory
// data and returns a WIN32 STATUS.  If the status is ERROR_SUCCESS it
// will be called with the next record in the directory.  IF the status
// is NOT ERROR_SUCCESS, that status is returned as the status result of
// the FrsEnumerateDirectory() function and enumeration stops.
//
// The function is responsible for recursing into the next level of
// directory by calling FrsEnumerateDirectoryRecurse() as needed.
//
// FrsEnumerateDirectory() will continue an enumeration even if
// errors occur if ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE is set.
//
// FrsEnumerateDirectory() will skip non-directory entries if
// if ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY is set.
//

#define ENUMERATE_DIRECTORY_FLAGS_NONE              (0x00000000)
#define ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE    (0x00000001)
#define ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY  (0x00000002)

typedef
DWORD
(NTAPI *PENUMERATE_DIRECTORY_ROUTINE) (
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PVOID                       Context
    );

DWORD
FrsEnumerateDirectoryDeleteWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PVOID                       Ignored
    );

DWORD
FrsEnumerateDirectoryRecurse(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  HANDLE                      FileHandle,
    IN  PVOID                       Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    );

DWORD
FrsEnumerateDirectory(
    IN HANDLE   DirectoryHandle,
    IN PWCHAR   DirectoryName,
    IN DWORD    DirectoryLevel,
    IN DWORD    DirectoryFlags,
    IN PVOID    Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\resource.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    resource.h

Abstract:

    Constants for FRS Resources.

Author:
    David A. Orbits  7-4-1999

Environment
    User mode winnt

--*/


//
// The service long name (aka Display Name) is used in several places:
//
//      setting up the event log registry keys,  (english only)
//      in eventlog messages,
//      in DCPromo error messages,
//      Trace Log DPRINTs,                       (english only)
//      and as a parameter to the service controller.
//
// As noted above, some uses must only use the English translation.
// All other uses must use the ServiceLongName global fetched from
// the string resource with the keyword IDS_SERVICE_LONG_NAME since that
// gets translated to other languages.
//

#define SERVICE_LONG_NAME       L"File Replication Service"

//
// Strings
//
#define    IDS_TABLE_START                  100

#define    IDS_SERVICE_LONG_NAME            101
#define    IDS_RANGE_DWORD                  102
#define    IDS_RANGE_STRING                 103
#define    IDS_MISSING_STRING               104

//
// Warning: Don't change the order of these UNITS codes without a making
//          a matching change in the order of FRS_DATA_UNITS enum in config.h
//
#define    IDS_UNITS_NONE                   105
#define    IDS_UNITS_SECONDS                106
#define    IDS_UNITS_MINUTES                107
#define    IDS_UNITS_HOURS                  108
#define    IDS_UNITS_DAYS                   109
#define    IDS_UNITS_MILLISEC               110
#define    IDS_UNITS_KBYTES                 111
#define    IDS_UNITS_BYTES                  112
#define    IDS_UNITS_MBYTES                 113


#define    IDS_REG_KEY_NOT_FOUND            114
#define    IDS_REG_VALUE_NOT_FOUND          115
#define    IDS_REG_VALUE_RANGE_ERROR        116
#define    IDS_REG_VALUE_WRONG_TYPE         117

#define    IDS_NO_DEFAULT                   118

#define    IDS_INBOUND                      119
#define    IDS_OUTBOUND                     120

#define    IDS_POLL_SUM_SEARCH_ERROR        121
#define    IDS_POLL_SUM_DSBIND_FAIL         122
#define    IDS_POLL_SUM_NO_COMPUTER         123
#define    IDS_POLL_SUM_NO_REPLICASETS      124
#define    IDS_POLL_SUM_INVALID_ATTRIBUTE   125
#define    IDS_POLL_SUM_SUBSCRIBER_CONFLICT 126
#define    IDS_POLL_SUM_CXTION_CONFLICT     127
#define    IDS_EVENT_LOG_MSG_SIZE_EXCEEDED  128
#define    IDS_POLL_SUM_PRIMARY_UNDEFINED   129

#define    IDS_TABLE_END                    129


//
// Give an FRS units code, translate it to the IDS code number above.
//

#define    XLATE_IDS_UNITS(_u_) (((_u_)-UNITS_NONE) + IDS_UNITS_NONE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\main\main.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    main.c

Abstract:
    This is the main thread for the File Replication Service.

Author:
    Billy J. Fuller 20-Mar-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>
#include <objbase.h>

#define INITGUID
#include "frstrace.h"

PCHAR LatestChanges[] = {

    "Latest changes:",
    "Server 2003 01-07-2003",
#ifdef DS_FREE
    "DS_FREE mode",
#endif DS_FREE
    NULL
};


HANDLE  ShutDownEvent;
HANDLE  ShutDownComplete;
HANDLE  DataBaseEvent;
HANDLE  JournalEvent;
HANDLE  ChgOrdEvent;
HANDLE  ReplicaEvent;
HANDLE  CommEvent;
HANDLE  DsPollEvent;
HANDLE  DsShutDownComplete;
//
// Event to signal the end of freeze operation.
//
HANDLE  FrsThawEvent;
BOOL    FrsFrozenForBackup  = FALSE;

//
// Event to signal that there are no installs in
// progress.
//
HANDLE  FrsNoInstallsInProgressEvent;

PWCHAR  ServerPrincName;
BOOL    IsAMember               = FALSE;
BOOL    IsADc                   = FALSE;
BOOL    IsAPrimaryDc            = FALSE;
BOOL    EventLogIsRunning       = FALSE;
BOOL    RpcssIsRunning          = FALSE;
BOOL    RunningAsAService       = TRUE;
BOOL    NoDs                    = FALSE;
BOOL    FrsIsShuttingDown       = FALSE;
BOOL    FrsScmRequestedShutdown = FALSE;
BOOL    FrsIsAsserting          = FALSE;

//
// Require mutual authentication
//
BOOL    MutualAuthenticationIsEnabled;
BOOL    MutualAuthenticationIsEnabledAndRequired;

//
// Directory and file filter lists from registry.
//
PWCHAR  RegistryFileExclFilterList;
PWCHAR  RegistryFileInclFilterList;

PWCHAR  RegistryDirExclFilterList;
PWCHAR  RegistryDirInclFilterList;


extern CRITICAL_SECTION CritSec_pValidPartnerTableStruct;
extern CRITICAL_SECTION OldValidPartnerTableStructListHeadLock;

//
// Synchronize the shutdown thread with the service controller
//
CRITICAL_SECTION    ServiceLock;

//
// Synchronize initialization
//
CRITICAL_SECTION    MainInitLock;

//
// Convert the ANSI ArgV into a UNICODE ArgV
//
PWCHAR  *WideArgV;

//
// Process Handle
//
HANDLE  ProcessHandle;

//
// Working path / DB Log path
//
PWCHAR  WorkingPath;
PWCHAR  DbLogPath;

//
// Database directories (UNICODE and ASCII)
//
PWCHAR  JetPath;
PWCHAR  JetFile;
PWCHAR  JetFileCompact;
PWCHAR  JetSys;
PWCHAR  JetTemp;
PWCHAR  JetLog;

PCHAR   JetPathA;
PCHAR   JetFileA;
PCHAR   JetFileCompactA;
PCHAR   JetSysA;
PCHAR   JetTempA;
PCHAR   JetLogA;

//
// Limit the amount of staging area used (in kilobytes). This is
// a soft limit, the actual usage may be higher.
//
DWORD StagingLimitInKb;

//
// Default staging limit in kb to be assigned to a new staging area.
//
DWORD DefaultStagingLimitInKb;

//
// Max number replica sets and Jet Sessions allowed.
//
ULONG MaxNumberReplicaSets;
ULONG MaxNumberJetSessions;

//
// Maximum number of outbound changeorders allowed outstanding per connection.
//
ULONG MaxOutLogCoQuota;
//
// If TRUE then try to preserve existing file OIDs whenever possible.
//  -- See Bug 352250 for why this is a risky thing to do.
//
BOOL  PreserveFileOID;

//
// Limits on how many time and for how long we will continue to retry a
// change order when the parent is missing.
//
ULONG MaxCoRetryTimeoutMinutes;
ULONG MaxCoRetryTimeoutCount;

//
// Major/minor  (see frs.h)
//
ULONG   NtFrsMajor      = NTFRS_MAJOR;
ULONG   NtFrsMinor      = NTFRS_MINOR;

ULONG   NtFrsStageMajor = NTFRS_STAGE_MAJOR;
ULONG   NtFrsStageMinor = NTFRS_STAGE_MINOR_3;

ULONG   NtFrsCommMinor  = NTFRS_COMM_MINOR_8;

ULONG   NtFrsPerfCounterVer  = NTFRS_PERF_COUNTER_VER_1;

PCHAR   NtFrsModule     = __FILE__;
PCHAR   NtFrsDate       = __DATE__;
PCHAR   NtFrsTime       = __TIME__;

//
// Shutdown timeout
//

ULONG   ShutDownTimeOut = DEFAULT_SHUTDOWN_TIMEOUT;

//
// A useful thing to have around
//
WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 2];
PWCHAR  ComputerDnsName;
PWCHAR  ServiceLongName;

//
// The rpc server may reference this table as soon as the rpc interface
// is registered. Make sure it is setup.
//
extern PGEN_TABLE ReplicasByGuid;

extern BOOL LockedOutlogCleanup;

//
// The staging area table is references early in the startup process
//
extern PGEN_TABLE   StagingAreaTable;
extern CRITICAL_SECTION StagingAreaCleanupLock;

//
// This table is used to keep contexts across multiple calls from ntfrsutl.exe
//
extern PGEN_TABLE   FrsInfoContextTable;

PGEN_TABLE   CompressionTable;

extern PGEN_TABLE ReparseTagTable;

//
// Size of buffer to use when enumerating directories. Actual memory
// usage will be #levels * SizeOfBuffer.
//
LONG    EnumerateDirectorySizeInBytes;




BOOL    MainInitHasRun;

//
// Do not accept stop control unless the service is in SERVICE_RUNNING state.
// This prevents the service from getting confused when a stop is called
// while the service is starting.
//
SERVICE_STATUS  ServiceStatus = {
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_START_PENDING,
//        SERVICE_ACCEPT_STOP |
            // SERVICE_ACCEPT_PAUSE_CONTINUE |
        SERVICE_ACCEPT_SHUTDOWN,
        0,
        0,
        0,
        60*1000
};

//
// Supported compression formats.
//

//
// This is the compression format for uncompressed data.
//
DEFINE_GUID ( /* 00000000-0000-0000-0000-000000000000 */
    FrsGuidCompressionFormatNone,
    0x00000000,
    0x0000,
    0x0000,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  );

//
// This is the compression format for data compressed using NTFS's LZNT1 compression
// routines.
//
DEFINE_GUID ( /* 64d2f7d2-2695-436d-8830-8d3c58701e15 */
    FrsGuidCompressionFormatLZNT1,
    0x64d2f7d2,
    0x2695,
    0x436d,
    0x88, 0x30, 0x8d, 0x3c, 0x58, 0x70, 0x1e, 0x15
  );

//
// Fixed guid for the dummy cxtion (aka GhostCxtion) assigned to orphan remote
// change orders whose inbound cxtion has been deleted from the DS but they
// have already past the fetching state and can finish without the real cxtion
// coming back. No authentication checks are made for this dummy cxtion.
//
DEFINE_GUID ( /* b9d307a7-a140-4405-991e-281033f03309 */
    FrsGuidGhostCxtion,
    0xb9d307a7,
    0xa140,
    0x4405,
    0x99, 0x1e, 0x28, 0x10, 0x33, 0xf0, 0x33, 0x09
  );

DEFINE_GUID ( /* 3fe2820f-3045-4932-97fe-00d10b746dbf */
    FrsGhostJoinGuid,
    0x3fe2820f,
    0x3045,
    0x4932,
    0x97, 0xfe, 0x00, 0xd1, 0x0b, 0x74, 0x6d, 0xbf
  );

//
// Static Ghost cxtion structure. This cxtion is assigned to orphan remote change
// orders in the inbound log whose cxtion is deleted from the DS but who have already
// past the fetching state and do not need the cxtion to complete processing. No
// authentication checks are made for this dummy cxtion.
//
PCXTION  FrsGhostCxtion;

SERVICE_STATUS_HANDLE   ServiceStatusHandle = NULL;

VOID
InitializeEventLog(
    VOID
    );

DWORD
FrsSetServiceFailureAction(
    VOID
    );

VOID
FrsRpcInitializeAccessChecks(
    VOID
    );

BOOL
FrsSetupPrivileges (
    VOID
    );

VOID
CfgRegAdjustTuningDefaults(
    VOID
    );

VOID
CommInitializeCommSubsystem(
    VOID
    );

VOID
SndCsInitialize(
    VOID
    );

VOID
SndCsUnInitialize(
    VOID
    );

VOID
SndCsShutDown(
    VOID
    );

VOID
DbgPrintAllStats(
    VOID
    );

// FRS Capacity Planning
//
#define RESOURCE_NAME       L"MofResourceName"
#define IMAGE_PATH          L"ntfrs.exe"

DWORD       FrsWmiEventTraceFlag          = FALSE;
TRACEHANDLE FrsWmiTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE FrsWmiTraceLoggerHandle       = (TRACEHANDLE) 0;

// This is the FRS control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 78a8f0b1-290e-4c4c-9720-c7f1ef68ce21 */
    FrsControlGuid,
    0x78a8f0b1,
    0x290e,
    0x4c4c,
    0x97, 0x20, 0xc7, 0xf1, 0xef, 0x68, 0xce, 0x21
  );

// Traceable Guids start here
//
DEFINE_GUID ( /* 2eee6bbf-6665-44cf-8ed7-ceea1d306085 */
    FrsTransGuid,
    0x2eee6bbf,
    0x6665,
    0x44cf,
    0x8e, 0xd7, 0xce, 0xea, 0x1d, 0x30, 0x60, 0x85
  );

TRACE_GUID_REGISTRATION FrsTraceGuids[] =
{
    { & FrsTransGuid, NULL }
};

#define FrsGuidCount (sizeof(FrsTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

//
// Trace initialization / shutdown routines
//

ULONG
FrsWmiTraceControlCallback(
    IN     WMIDPREQUESTCODE RequestCode,
    IN     PVOID            RequestContext,
    IN OUT ULONG          * InOutBufferSize,
    IN OUT PVOID            Buffer
    )
/*++
Routine Description:


Arguments:


Return Value:

--*/
{
#undef DEBSUB
#define DEBSUB "FrsWmiTraceControlCallback:"

    PWNODE_HEADER Wnode = (PWNODE_HEADER) Buffer;
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode) {

    case WMI_ENABLE_EVENTS:
        FrsWmiTraceLoggerHandle = GetTraceLoggerHandle(Buffer);
        FrsWmiEventTraceFlag    = TRUE;
        RetSize              = 0;
        DPRINT1(0, "FrsTraceContextCallback(WMI_ENABLE_EVENTS,0x%08X)\n",
                FrsWmiTraceLoggerHandle);
        break;

    case WMI_DISABLE_EVENTS:
        FrsWmiTraceLoggerHandle = (TRACEHANDLE) 0;
        FrsWmiEventTraceFlag    = FALSE;
        RetSize              = 0;
        DPRINT(0, "FrsWmiTraceContextCallback(WMI_DISABLE_EVENTS)\n");
        break;

    default:
        RetSize = 0;
        Status  = ERROR_INVALID_PARAMETER;
        break;
    }

    *InOutBufferSize = RetSize;

    return Status;
}



ULONG
FrsWmiInitializeTrace(
    VOID
    )
/*++
Routine Description:


Arguments:


Return Value:

--*/
{
#undef DEBSUB
#define DEBSUB "FrsWmiInitializeTrace:"

    ULONG   WStatus;
    HMODULE hModule;
    WCHAR   FileName[MAX_PATH + 1];
    DWORD   nLen = 0;

    hModule = GetModuleHandleW(IMAGE_PATH);

    if (hModule != NULL) {
        nLen = GetModuleFileNameW(hModule, FileName, MAX_PATH);
    }

    if (nLen == 0) {
        wcscpy(FileName, IMAGE_PATH);
    }

    WStatus = RegisterTraceGuidsW(
                FrsWmiTraceControlCallback,
                NULL,
                & FrsControlGuid,
                FrsGuidCount,
                FrsTraceGuids,
                FileName,
                RESOURCE_NAME,
                & FrsWmiTraceRegistrationHandle);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT4(0, "NTFRS: FrsWmiInitializeTrace(%ws,%ws,%d) returns 0x%08X\n",
                 FileName, RESOURCE_NAME, FrsGuidCount, WStatus);
    }

    return WStatus;
}



ULONG
FrsWmiShutdownTrace(
    void
    )
/*++
Routine Description:


Arguments:


Return Value:

--*/
{
#undef DEBSUB
#define DEBSUB "FrsWmiShutdownTrace:"


    ULONG WStatus = ERROR_SUCCESS;

    UnregisterTraceGuids(FrsWmiTraceRegistrationHandle);
    return WStatus;
}



VOID
FrsWmiTraceEvent(
    IN DWORD WmiEventType,
    IN DWORD TraceGuid,
    IN DWORD rtnStatus
    )
/*++
Routine Description:


Arguments:


Return Value:

--*/
{
#undef DEBSUB
#define DEBSUB "FrsWmiTraceEvent:"

    struct {
        EVENT_TRACE_HEADER  TraceHeader;
        DWORD               Data;
        } Wnode;

    DWORD               WStatus;


    if (FrsWmiEventTraceFlag) {

        ZeroMemory(&Wnode, sizeof(Wnode));

        //
        // Set WMI event type
        //
        Wnode.TraceHeader.Class.Type = (UCHAR) WmiEventType;
        Wnode.TraceHeader.GuidPtr    = (ULONGLONG) FrsTraceGuids[TraceGuid].Guid;
        Wnode.TraceHeader.Size       = sizeof(Wnode);
        Wnode.TraceHeader.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_GUID_PTR;

        WStatus = TraceEvent(FrsWmiTraceLoggerHandle, (PEVENT_TRACE_HEADER) &Wnode);

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT5(0, "FreWmiTraceEvent(%d,%d,%d) = %d,0x%08X\n",
                     WmiEventType, TraceGuid, rtnStatus, WStatus, WStatus);
        }
    }
}


BOOL
WINAPI
MainSigHandler(
    IN DWORD Signal
    )
/*++
Routine Description:
    Handle CTRL_BREAK_EVENT and CTRL_C_EVENT by setting the shutdown event.

Arguments:
    Signal - signal received.

Return Value:
    Set the ShutDownEvent and return TRUE.
--*/
{
#undef DEBSUB
#define DEBSUB "MainSigHandler:"

    //
    // ShutDown on signal CTRL_C_EVENT or CTRL_BREAK_EVENT
    //
    if ((Signal == CTRL_C_EVENT) || (Signal == CTRL_BREAK_EVENT)) {
        DPRINT1(0,":S: Signal %s received, shutting down now...\n",
                (Signal == CTRL_C_EVENT) ? "CTRL_C_EVENT" : "CTRL_BREAK_EVENT");

        FrsScmRequestedShutdown = TRUE;
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);

        return TRUE;
    }

    DPRINT1(0,":S: Signal %d received, not handled\n", Signal);
    return FALSE;
}


ULONG
MainSCCheckPointUpdate(
    IN PVOID pCurrentState
    )
/*++
Routine Description:
    This thread repeatedly calls the Service Controller to update
    the checkpoint and reset the timeout value so that the
    service controller does not time out waiting for a response.
    When called in shutdown path the thread exits after a waiting
    a max "ShutDownTimeOut" # of seconds. All the subsystems might
    not have shutdown cleanly by this time but we don't want to take
    for ever to shutdown. This value is picked up from the registry.

Arguments:
    pCurrentState - Pointer to the value of the current state of
                    the service. Depending on this value the
                    function either waits to shutdown or startup.

Return Value:
    Exits with STATUS_UNSUCCESSFUL
--*/
{
#undef DEBSUB
#define DEBSUB "MainSCCheckPointUpdate:"

    ULONG   Timeout    = ShutDownTimeOut;
    DWORD   CheckPoint = 1;
    DWORD   WStatus    = ERROR_SUCCESS;
    DWORD   Ret        = 0;

    if (pCurrentState && *(DWORD *)pCurrentState == SERVICE_STOP_PENDING) {
        //
        // Thread is called in the shutdown path to make sure that FRS exits
        //
        while (Timeout) {
            DPRINT2(0, ":S: EXIT COUNTDOWN AT T-%d CheckPoint = %x\n", Timeout, CheckPoint);
            DEBUG_FLUSH();

            if (Timeout < 5) {
                Sleep(Timeout * 1000);
                Timeout = 0;
            } else {
                Sleep(5 * 1000);
                //
                // Update the status every 5 seconds to get the new checkpoint.
                //
                WStatus = FrsSetServiceStatus(SERVICE_STOP_PENDING, CheckPoint, (ShutDownTimeOut + 5) *1000, NO_ERROR);
                if (!WIN_SUCCESS(WStatus)) {
                    //
                    // Unable to set the service status. Exit process anyways.
                    //
                    break;
                }
                CheckPoint++;
                Timeout -= 5;
            }
        }

        DPRINT(0, ":S: EXIT COUNTDOWN EXPIRED\n");
        DEBUG_FLUSH();

        EPRINT0(EVENT_FRS_STOPPED_FORCE);

        //
        // EXIT FOR RESTART
        //
        // If we are shutting down after taking an assert then don't set the
        // service state to stopped. This will cause the service controller to
        // restart us if the recorvery option is set. In case of a service controller
        // initiated shutwon we want to set the state to stopped so that it does not
        // restart us.
        //
        if (!FrsIsAsserting && FrsScmRequestedShutdown) {
            FrsSetServiceStatus(SERVICE_STOPPED, CheckPoint, ShutDownTimeOut*1000, NO_ERROR);
        }

        ExitProcess(ERROR_NO_SYSTEM_RESOURCES);
        FrsFree(pCurrentState);
        return ERROR_NO_SYSTEM_RESOURCES;
    } else if (pCurrentState && *(DWORD *)pCurrentState == SERVICE_START_PENDING){
        //
        // Thread is called in the startup path to make sure that
        // service controller does not timeout waiting for the
        // service to start up.
        //
        while (TRUE) {
            DPRINT1(0, ":S: STARTUP CheckPoint = %x\n",CheckPoint);
             Sleep(5 * 1000);
             EnterCriticalSection(&ServiceLock);
             if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING
                 && !FrsIsShuttingDown) {

                 ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
                 ServiceStatus.dwCheckPoint = CheckPoint;
                 ServiceStatus.dwWaitHint = DEFAULT_STARTUP_TIMEOUT * 1000;
                 ServiceStatus.dwWin32ExitCode = NO_ERROR;
                 //
                 // Update the status every 5 seconds to get the new checkpoint.
                 //
                 Ret = SetServiceStatus(ServiceStatusHandle, &ServiceStatus);

                 CheckPoint++;
                 if (!Ret) {
                     //
                     // Can not set service status. Let the service try to start up
                     // in the given time. If it does not then the service controller
                     // time out and stop it.
                     //
                     LeaveCriticalSection(&ServiceLock);
                     break;
                 }
             } else {
                 //
                 // Service has either already started or it has moved to another state.
                 //
                 LeaveCriticalSection(&ServiceLock);
                 break;
             }
             LeaveCriticalSection(&ServiceLock);
        }
    }
    FrsFree(pCurrentState);
    return ERROR_SUCCESS;
}


VOID
MainStartShutDown(
    VOID
    )
/*++
Routine Description:
    Shutdown what we can.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainStartShutDown:"

    ULONGLONG   SecondsRunning;

    DPRINT(0, ":S: SHUTDOWN IN PROGRESS...\n");
    DEBUG_FLUSH();

    //
    // Do not restart if it was a service control manager requested shutdown.
    //
    DebugInfo.Restart = FALSE;
    if (!FrsScmRequestedShutdown) {

        GetSystemTimeAsFileTime((FILETIME *)&SecondsRunning);
        SecondsRunning /= (10 * 1000 * 1000);
        SecondsRunning -= DebugInfo.StartSeconds;

        //
        // Restart the service if it was an FRS triggered shutdown, e.g. malloc
        // failed or thread create failed, etc.
        // Also restart the service after an assertion failure iff the
        // service was able to run for some minutes.
        //
        // Assertion failures during shutdown won't trigger a restart since this
        // test is made before shutdown starts.
        //
        DebugInfo.Restart = !FrsIsAsserting ||
                                (FrsIsAsserting &&
                                (DebugInfo.RestartSeconds != 0) &&
                                (SecondsRunning >= DebugInfo.RestartSeconds));
    }

    if (DebugInfo.Restart) {
        DPRINT(0, ":S: Restart enabled\n");
    } else {
        DPRINT(0, ":S: Restart disabled\n");
    }
}


VOID
MainShutDownComplete(
    VOID
    )
/*++
Routine Description:
    Kick off the exe that will restart the service after a bit

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainShutDownComplete:"

    STARTUPINFO         StartUpInfo;
    PROCESS_INFORMATION ProcessInformation;

    //
    // Done with this service
    //
    DbgPrintAllStats();

    //
    // Spawn a new exe if needed
    //
    if (!RunningAsAService && DebugInfo.Restart) {
        GetStartupInfo(&StartUpInfo);
        if (!CreateProcess(NULL,
                           DebugInfo.CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           0, // CREATE_NEW_CONSOLE,
                           NULL,
                           NULL,
                           &StartUpInfo,
                           &ProcessInformation)) {
            DPRINT1_WS(0, ":S: ERROR - Spawning %ws :",
                       DebugInfo.CommandLine, GetLastError());
        } else {
            DPRINT1(0, ":S: Spawned %ws\n", DebugInfo.CommandLine);
        }
    }
    DPRINT(0,":S: SHUTDOWN COMPLETE\n");
    DEBUG_FLUSH();

    //
    // EXIT FOR RESTART
    //
    // If restart is desired then simply exit without setting our
    // status to SERVICE_STOPPED. The service controller will execute
    // our recovery settings which are defaulted to "restart after a
    // minute." The exe was restarted above.
    //
    if (DebugInfo.Restart) {
        ExitProcess(ERROR_NO_SYSTEM_RESOURCES);
    }
}


ULONG
MainFrsShutDown(
    IN PVOID Ignored
    )
/*++
Routine Description:
    Shutdown the service

Arguments:
    Ignored

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define DEBSUB "MainFrsShutDown:"

    DWORD       WStatus;
    DWORD       WaitStatus;
    HANDLE      ExitThreadHandle;
    DWORD       ExitThreadId;
    PVOID       ReplicaKey;
    PVOID       CxtionKey;
    PREPLICA    Replica;
    PCXTION     Cxtion;
    DWORD       CheckUnjoin;
    DWORD       LastCheckUnjoin;
    DWORD       ActiveCoCount, LastCheckActiveCoCount;
    PDWORD      ServiceWaitState     = NULL;

    //
    // How long is shutdown allowed to take?
    //
    CfgRegReadDWord(FKC_SHUTDOWN_TIMEOUT, NULL, 0, &ShutDownTimeOut);
    DPRINT1(1,":S: Using %d as ShutDownTimeOut\n",  ShutDownTimeOut);

    //
    // Wait for a shutdown event
    //
    do {
        //
        // If present, flush the log file every 30 seconds
        //
        if (DebugInfo.LogFILE) {
            WaitStatus = WaitForSingleObject(ShutDownEvent, (30 * 1000));
        } else {
            WaitStatus = WaitForSingleObject(ShutDownEvent, INFINITE);
        }
        DEBUG_FLUSH();
    } while (WaitStatus == WAIT_TIMEOUT);

    FrsIsShuttingDown = TRUE;

    EPRINT0(EVENT_FRS_STOPPING);

    //
    // How long is shutdown allowed to take?  Re-read so longer time can
    // be used for debug dumping when necc.
    //
    CfgRegReadDWord(FKC_SHUTDOWN_TIMEOUT, NULL, 0, &ShutDownTimeOut);
    DPRINT1(1,":S: Using %d as ShutDownTimeOut\n",  ShutDownTimeOut);

    //
    // SHUTDOWN
    //
    MainStartShutDown();

    //
    // Inform the service controller that we are stopping.
    //
    // Unless we aren't running as a service, or are
    // are running to restart the service, or simply running
    // as an exe.
    //
    if (!FrsIsAsserting) {
        FrsSetServiceStatus(SERVICE_STOP_PENDING, 0, ShutDownTimeOut*1000, NO_ERROR);
    }

    //
    // Kick off a thread that exits in a bit
    // Allocate memory for data to be passed to another thread.
    //

    ServiceWaitState = FrsAlloc(sizeof(DWORD));
    *ServiceWaitState = SERVICE_STOP_PENDING;
    ExitThreadHandle = (HANDLE)CreateThread(NULL,
                                            10000,
                                            MainSCCheckPointUpdate,
                                            ServiceWaitState,
                                            0,
                                            &ExitThreadId);

    if (!HANDLE_IS_VALID(ExitThreadHandle)) {
        ExitProcess(ERROR_NO_SYSTEM_RESOURCES);
    }

    //
    // Minimal shutdown - only the ds polling thread
    //
    if (!MainInitHasRun) {
        DPRINT(1,":S: \tFast shutdown in progress...\n");
        //
        // ShutDown rpc
        //
        DPRINT(1,":S: \tShutting down RPC Server...\n");
        ShutDownRpc();
        DEBUG_FLUSH();

        //
        // Ask all the threads to exit
        //
        DPRINT(1,":S: \tShutting down all the threads...\n");
        WStatus = ThSupExitThreadGroup(NULL);
        DEBUG_FLUSH();

        //
        // Free the rpc table and princname
        //
        DPRINT(1,":S: \tFreeing rpc memory...\n");
        FrsRpcUnInitialize();
        DEBUG_FLUSH();

        goto SHUTDOWN_COMPLETE;
    }

    //
    // Shutdown the FRS writer COM object.
    //
    DPRINT(1,":S: \tShutting down FRS writer component...\n");
    ShutDownFrsWriter();

    //
    // ShutDown the delayed command server; don't let change orders
    // sit on the various retry queues.
    //
    DPRINT(1,":S: \tShutting down Delayed Server...\n");
    ShutDownDelCs();
    DEBUG_FLUSH();

    //
    // ShutDown the staging file generator
    //
    DPRINT(1,":S: \tShutting down Staging File Generator...\n");
    ShutDownStageCs();
    DEBUG_FLUSH();

    //
    // ShutDown the staging file fetcher
    //
    DPRINT(1,":S: \tShutting down Staging File Fetch...\n");
    ShutDownFetchCs();
    DEBUG_FLUSH();

    //
    // ShutDown the initial sync controller
    //
    DPRINT(1,":S: \tShutting down Initial Sync Controller...\n");
    ShutDownInitSyncCs();
    DEBUG_FLUSH();

    //
    // ShutDown the staging file installer
    //
    DPRINT(1,":S: \tShutting down Staging File Install...\n");
    ShutDownInstallCs();
    DEBUG_FLUSH();

    //
    // Stop local change orders.
    //
    // Shutdown can be delayed indefinitely if the journal cs continues
    // to add local change orders to the change order accept queue.
    //
    // The remote change orders were stopped by setting FrsIsShuttingDown
    // to TRUE above.
    //
    ReplicaKey = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &ReplicaKey)) {
        DPRINT1(4, ":S: Pause journaling on replica %ws\n", Replica->ReplicaName->Name);
        if (Replica->pVme) {
            JrnlPauseVolume(Replica->pVme, 5000);
        }
    }

    //
    // Shutdown the replicas cleanly.
    //
    // WARN: all of the change orders have to be taken through the retry
    // path before shutting down the rest of the system. Otherwise,
    // access violations occur in ChgOrdIssueCleanup(). Perhaps we
    // should fix ChgOrdIssueCleanup() to handle the case when
    // change order accept has exited and cleaned up its tables?
    //
    CheckUnjoin = 0;
    ReplicaKey = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &ReplicaKey)) {
        LOCK_CXTION_TABLE(Replica);
        CxtionKey = NULL;

        while (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey)) {

            if (CxtionStateIs(Cxtion, CxtionStateUnjoined) ||
                CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                DPRINT3(0, ":S: %ws\\%ws %s: Unjoin not needed.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        (Cxtion->Inbound) ? "<-" : "->");
            } else {
                DPRINT4(0, ":S: %ws\\%ws %s: Unjoin    (%d cos).\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        (Cxtion->Inbound) ? "<-" : "->", Cxtion->ChangeOrderCount);
                RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_UNJOIN);
                CheckUnjoin += Cxtion->ChangeOrderCount + 1;
            }
        }
        UNLOCK_CXTION_TABLE(Replica);
    }
    LastCheckUnjoin = 0;

    while (CheckUnjoin && CheckUnjoin != LastCheckUnjoin) {
        //
        // Wait a bit and check again
        //
        Sleep(5 * 1000);
        LastCheckUnjoin = CheckUnjoin;
        CheckUnjoin = 0;
        ReplicaKey = NULL;

        while (Replica = GTabNextDatum(ReplicasByGuid, &ReplicaKey)) {
            LOCK_CXTION_TABLE(Replica);
            CxtionKey = NULL;

            while (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey)) {
                if (CxtionStateIs(Cxtion, CxtionStateUnjoined) ||
                    CxtionStateIs(Cxtion, CxtionStateDeleted)) {

                    DPRINT3(0, ":S: %ws\\%ws %s: Unjoin successful.\n",
                            Replica->MemberName->Name, Cxtion->Name->Name,
                            (Cxtion->Inbound) ? "<-" : "->");

                } else if (Cxtion->ChangeOrderCount) {

                    DPRINT4(0, ":S: %ws\\%ws %s: Unjoining (%d cos).\n",
                            Replica->MemberName->Name, Cxtion->Name->Name,
                            (Cxtion->Inbound) ? "<-" : "->",
                            Cxtion->ChangeOrderCount);
                    CheckUnjoin += Cxtion->ChangeOrderCount + 1;

                } else {

                    DPRINT4(0, ":S: %ws\\%ws %s: Ignoring  (state %s).\n",
                            Replica->MemberName->Name, Cxtion->Name->Name,
                           (Cxtion->Inbound) ? "<-" : "->", GetCxtionStateName(Cxtion));
                }
            }
            UNLOCK_CXTION_TABLE(Replica);
        }
    }
    if (CheckUnjoin) {
        DPRINT(0, "ERROR - Could not unjoin all cxtions.\n");
    }

    //
    // Now wait until any remaining local Change Orders wind through
    // retire or retry for each replica set.
    //

    ReplicaKey = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &ReplicaKey)) {

        ActiveCoCount = 0;
        LastCheckActiveCoCount = 1;

        while (ActiveCoCount != LastCheckActiveCoCount) {
            LastCheckActiveCoCount = ActiveCoCount;

            if ((Replica->pVme != NULL) &&
                (Replica->pVme->ActiveInboundChangeOrderTable != NULL)) {
                ActiveCoCount = GhtCountEntries(Replica->pVme->ActiveInboundChangeOrderTable);
                if (ActiveCoCount == 0) {
                    break;
                }
                DPRINT2(0, ":S: Waiting for %d active inbound change orders to finish up for %ws.\n",
                        ActiveCoCount, Replica->MemberName->Name);

                Sleep(5*1000);
            }
        }

        if (ActiveCoCount != 0) {
            DPRINT2(0, ":S: ERROR - %d active inbound change orders were not cleaned up for %ws.\n",
                    ActiveCoCount, Replica->MemberName->Name);
        } else {
            DPRINT1(0, ":S: All active inbound change orders finished for %ws.\n",
                   Replica->MemberName->Name);
        }
    }

    //
    // ShutDown the replica control command server
    //
    DPRINT(1,":S: \tShutting down Replica Server...\n");
    RcsShutDownReplicaCmdServer();
    DEBUG_FLUSH();

    //
    // ShutDown the send command server
    //
    DPRINT(1,":S: \tShutting down Comm Server...\n");
    SndCsShutDown();
    DEBUG_FLUSH();

    //
    // ShutDown rpc
    //
    DPRINT(1,":S: \tShutting down RPC Server...\n");
    ShutDownRpc();
    DEBUG_FLUSH();

    //
    // ShutDown the waitable timer server
    //
    DPRINT(1,":S: \tShutting down Waitable Timer Server...\n");
    ShutDownWait();
    DEBUG_FLUSH();
    //
    // ShutDown the outbound log processor
    //
    //
    // NOPE; the database server requires the outbound log
    // processor when shutting down. The database server will
    // shutdown the outbound log processor when its done.
    //
    // DPRINT(1,"\tShutting down Outbound Log Processor...\n");
    // DEBUG_FLUSH();
    // ShutDownOutLog();

    //
    // ShutDown the database server
    //
    DPRINT(1,":S: \tShutting down the Database Server...\n");
    DEBUG_FLUSH();
    DbsShutDown();

    //
    // Wakeup any command server waiting on another command server to start
    //
    if (HANDLE_IS_VALID(DataBaseEvent)) {
        SetEvent(DataBaseEvent);
    }
    if (HANDLE_IS_VALID(JournalEvent)) {
        SetEvent(JournalEvent);
    }
    if (HANDLE_IS_VALID(ChgOrdEvent)) {
        SetEvent(ChgOrdEvent);
    }
    if (HANDLE_IS_VALID(CommEvent)) {
        SetEvent(CommEvent);
    }
    if (HANDLE_IS_VALID(ReplicaEvent)) {
        SetEvent(ReplicaEvent);
    }

    //
    // Wakeup the thread that polls the ds
    //
    if (HANDLE_IS_VALID(DsPollEvent)) {
        SetEvent(DsPollEvent);
    }

    //
    // Wakeup any thread waiting on the thread that polls the ds
    //
    if (HANDLE_IS_VALID(DsShutDownComplete)) {
        SetEvent(DsShutDownComplete);
    }

    //
    // Ask all the threads to exit
    //
    DPRINT(1,":S: \tShutting down all the threads...\n");
    WStatus = ThSupExitThreadGroup(NULL);
    DEBUG_FLUSH();

    //
    // We can't uninitialize the subsystems because some thread
    // may still be active and referencing the data structs.
    //
    if (WIN_SUCCESS(WStatus)) {
        //
        // Free the active replica set stuff
        //
        DPRINT(1,":S: \tFreeing replica sets...\n");
        RcsFrsUnInitializeReplicaCmdServer();
        DEBUG_FLUSH();

        //
        // Free the rpc handle cache
        //
        DPRINT(1,":S: \tFreeing rpc handles...\n");
        SndCsUnInitialize();
        DEBUG_FLUSH();

        //
        // Free the stage table
        //
        DPRINT(1,":S: \tFreeing stage table...\n");
        FrsStageCsUnInitialize();
        DEBUG_FLUSH();

        //
        // Free the rpc table and princname
        //
        DPRINT(1,":S: \tFreeing rpc memory...\n");
        FrsRpcUnInitialize();
        DEBUG_FLUSH();
    }

    #if DBG
        //
        // DEBUG PRINTS
        //
        DPRINT(1,":S: \tDumping Vme Filter Table...\n");
        JrnlDumpVmeFilterTable();
        DEBUG_FLUSH();
    #endif  DBG

SHUTDOWN_COMPLETE:
    //
    // We can't free resources because some thread may still be
    // active and referencing them.
    //
    if (WIN_SUCCESS(WStatus)) {
        //
        //
        // Free resources in main
        //
        DPRINT(1,":S: \tFreeing main resources...\n");
        DEBUG_FLUSH();
        FrsFree(WorkingPath);
        FrsFree(DbLogPath);
        FrsFree(JetPath);
        FrsFree(JetFile);
        FrsFree(JetFileCompact);
        FrsFree(JetSys);
        FrsFree(JetTemp);
        FrsFree(JetLog);
        FrsFree(JetPathA);
        FrsFree(JetFileA);
        FrsFree(JetFileCompactA);
        FrsFree(JetSysA);
        FrsFree(JetTempA);
        FrsFree(JetLogA);
        GTabFreeTable(StagingAreaTable, FrsFree);
        GTabFreeTable(ReparseTagTable, FrsFreeType);

        //
        // Uninitialize the memory allocation subsystem
        //
        DPRINT(1,":S: \tShutting down the memory allocation subsystem...\n");
        DEBUG_FLUSH();
        FrsUnInitializeMemAlloc();
    }

    //
    // Report an event
    //
    if (FrsIsAsserting) {
        EPRINT0(EVENT_FRS_STOPPED_ASSERT);
    } else {
        EPRINT0(EVENT_FRS_STOPPED);
    }

    //
    // Check the restart action.
    //
    MainShutDownComplete();

    //
    // DONE
    //
    if (!FrsIsAsserting && FrsScmRequestedShutdown) {
        SetEvent(ShutDownComplete);
        FrsSetServiceStatus(SERVICE_STOPPED, 0, ShutDownTimeOut*1000, NO_ERROR);
    }

    ExitProcess(STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


DWORD
MainMustInit(
    IN INT      ArgC,
    IN PWCHAR   *ArgV
    )
/*++
Routine Description:
    Initialize anything necessary for shutdown and logging errors.

Arguments:
    ArgC    - From main
    ArgV    - From main

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB "MainMustInit:"

    DWORD   WStatus;
    ULONG   Len;
    PWCHAR  Severity;
    HANDLE  ShutDownThreadHandle;
    DWORD   ShutDownThreadId;

    //
    // Several lower level functions aren't prepared to dynamically allocate
    // the needed storage so to help mitigate this we use the BigPath crock.
    //
    WCHAR   BigPath[8*MAX_PATH + 1];

    //
    // FIRST, SETUP THE "MUST HAVE" VARIABLES, EVENTS, SERVICES...
    //

    //
    // Synchronizes access to pValidPartnerTableStruct.
    // see definition of pValidPartnerTableStruct for more info.
    //
    INITIALIZE_CRITICAL_SECTION(&CritSec_pValidPartnerTableStruct);

    //
    // Synchronizes access to the Old ValidPartnerTableStruct List.
    // OldValidPartnerTableStructListHead
    //
    INITIALIZE_CRITICAL_SECTION(&OldValidPartnerTableStructListHeadLock);

    //
    // Synchronizes access between DsCs and SysVol Promotion when
    // initializing other the rest of the service (MainInit()).
    //
    INITIALIZE_CRITICAL_SECTION(&MainInitLock);

    //
    // Enable event logging
    //
    //InitializeEventLog();
    //EPRINT0(EVENT_FRS_STARTING);

    //
    // Backup/Restore privileges
    //
    if (!FrsSetupPrivileges()) {
        WStatus = GetLastError();
        DPRINT_WS(0, ":S: ERROR - FrsSetupPrivileges()", WStatus);
        return WStatus;
    }
    DEBUG_FLUSH();

    //
    // Get this Machine's name.
    //
    DPRINT1(0, ":S: Computer name is %ws\n", ComputerName);

    //
    // Get this Machine's DNS name.
    //
    Len = ARRAY_SZ(BigPath);
    BigPath[0] = L'\0';
    if (!GetComputerNameEx(ComputerNameDnsFullyQualified, BigPath, &Len)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "ERROR - Cannot get the computer's DNS name; using %ws\n",
                ComputerName, WStatus);
        ComputerDnsName = FrsWcsDup(ComputerName);
    } else {
        ComputerDnsName = FrsWcsDup(BigPath);
    }

    DPRINT1(0, "Computer's DNS name is %ws\n", ComputerDnsName);

    DEBUG_FLUSH();

    if (!RunningAsAService) {
        //
        // We need the event log service to log errors, warnings, notes, ...
        //
        EventLogIsRunning = FrsWaitService(ComputerName, L"EventLog", 1000, 10000);
        if (!EventLogIsRunning) {
            return ERROR_SERVICE_NOT_ACTIVE;
        }

        //
        // We need the rpc endpoint mapper
        //
        RpcssIsRunning = FrsWaitService(ComputerName, L"rpcss", 1000, 10000);
        if (!RpcssIsRunning) {
            return ERROR_SERVICE_NOT_ACTIVE;
        }
    }

    //
    // Signaled when shutdown is desired
    //
    ShutDownEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when shutdown has completed
    //
    ShutDownComplete = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when database has started
    //
    DataBaseEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when journal has started
    //
    JournalEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when change order accept has started
    //
    ChgOrdEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when replica has started
    //
    ReplicaEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Signaled when comm has started
    //
    CommEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Used to poll the ds
    //
    DsPollEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Set when the thread that polls the Ds has shut down
    //
    DsShutDownComplete = FrsCreateEvent(TRUE, FALSE);

    //
    // Used to signal the completion of backup operation.
    //
    FrsThawEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Event to signal that there are no installs in
    // progress.
    //
    FrsNoInstallsInProgressEvent = FrsCreateEvent(TRUE, FALSE);
    

    //
    // register signal handlers after creating events and initializing
    // the critical sections!
    //
    if (!RunningAsAService) {
        DPRINT(0, "Setting CTRL_C_EVENT and CTRL_BREAK_EVENT handlers.\n");
        if(!SetConsoleCtrlHandler(MainSigHandler, TRUE)) {
            DPRINT_WS(0, "SetConsoleCtrlHandler() failed:", GetLastError());
        }
    }

    //
    // Get the path to the DB file and the DB Logs.
    //

    CfgRegReadString(FKC_WORKING_DIRECTORY, NULL, 0, &WorkingPath);
    if (WorkingPath == NULL) {
        DPRINT(0, ":S: Must have the working directory in the registry. Aborting\n");
        return ERROR_INVALID_PARAMETER;
    }

    CfgRegReadString(FKC_DBLOG_DIRECTORY, NULL, 0, &DbLogPath);

    //
    // Create the working directory and the DB log dir (optional)
    //
    FRS_WCSLWR(WorkingPath);
    DPRINT1(0, ":S: Working Directory is %ws\n", WorkingPath);
    WStatus = FrsCreateDirectory(WorkingPath);
    CLEANUP_WS(0, ":S: Can't create working dir:", WStatus, CLEAN_UP);

    if (DbLogPath != NULL) {
        FRS_WCSLWR(DbLogPath);
        DPRINT1(0, ":S: DB Log Path provided is %ws\n", DbLogPath);
        WStatus = FrsCreateDirectory(DbLogPath);
        CLEANUP_WS(0, ":S: Can't create debug log dir:", WStatus, CLEAN_UP);
    }

    //
    // Restrict access to the database working directory
    //
    WStatus = FrsRestrictAccessToFileOrDirectory(WorkingPath, NULL,
                                                 FALSE, // do not inherit acls from parent.
                                                 TRUE); // push acls to children.
    DPRINT1_WS(0, ":S: WARN - Failed to restrict access to %ws (IGNORED);",
               WorkingPath, WStatus);
    WStatus = ERROR_SUCCESS;

    //
    // Restrict access to the database log directory (optional)
    //
    if (DbLogPath != NULL) {
        WStatus = FrsRestrictAccessToFileOrDirectory(DbLogPath, NULL,
                                                     FALSE, // do not inherit acls from parent.
                                                     TRUE);// push acls to children.

        DPRINT1_WS(0, ":S: WARN - Failed to restrict access to %ws (IGNORED);",
                   DbLogPath, WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Create the database path
    // WARN: FrsDsInitializeHardWired() may alter JetPath
    //
    JetPath = FrsWcsPath(WorkingPath, JET_DIR);

    //
    // Initialize the path to the inifile.
    //
#ifdef DS_FREE

    IniFileName = FrsWcsPath(WorkingPath, L"frsconfig.txt");

#endif DS_FREE

    //
    // Initialize the hardwired config stuff
    // WARN: FrsDsInitializeHardWired() may alter JetPath
    //
    INITIALIZE_HARD_WIRED();

    //
    // Create the database paths and file (UNICODE and ASCII)
    //      Jet uses the ASCII versions
    //
    FRS_WCSLWR(JetPath);   // for wcsstr()
    JetFile        = FrsWcsPath(JetPath, JET_FILE);
    JetFileCompact = FrsWcsPath(JetPath, JET_FILE_COMPACT);
    JetSys         = FrsWcsPath(JetPath, JET_SYS);
    JetTemp        = FrsWcsPath(JetPath, JET_TEMP);

    if (DbLogPath != NULL) {
        JetLog     = FrsWcsDup(DbLogPath);
    } else {
        JetLog     = FrsWcsPath(JetPath, JET_LOG);
    }

    //
    // Jet can't handle wide char strings
    //
    JetPathA        = FrsWtoA(JetPath);
    JetFileA        = FrsWtoA(JetFile);
    JetFileCompactA = FrsWtoA(JetFileCompact);
    JetSysA         = FrsWtoA(JetSys);
    JetTempA        = FrsWtoA(JetTemp);
    JetLogA         = FrsWtoA(JetLog);

    DPRINT2(4, ":S: JetPath       : %ws (%s in ASCII)\n", JetPath, JetPathA);
    DPRINT2(4, ":S: JetFile       : %ws (%s in ASCII)\n", JetFile, JetFileA);
    DPRINT2(4, ":S: JetFileCompact: %ws (%s in ASCII)\n", JetFileCompact, JetFileCompactA);
    DPRINT2(4, ":S: JetSys        : %ws (%s in ASCII)\n", JetSys, JetSysA);
    DPRINT2(4, ":S: JetTemp       : %ws (%s in ASCII)\n", JetTemp, JetTempA);
    DPRINT2(4, ":S: JetLog        : %ws (%s in ASCII)\n", JetLog, JetLogA);

    //
    // Create the database directories under workingpath\JET_DIR
    //
    WStatus = FrsCreateDirectory(JetPath);
    CLEANUP_WS(0, ":S: Can't create JetPath dir:", WStatus, CLEAN_UP);

    WStatus = FrsCreateDirectory(JetSys);
    CLEANUP_WS(0, ":S: Can't create JetSys dir:", WStatus, CLEAN_UP);

    WStatus = FrsCreateDirectory(JetTemp);
    CLEANUP_WS(0, ":S: Can't create JetTemp dir:", WStatus, CLEAN_UP);

    WStatus = FrsCreateDirectory(JetLog);
    CLEANUP_WS(0, ":S: Can't create JetLog dir:", WStatus, CLEAN_UP);

    //
    // Initialize the subsystem used for managing threads
    //      (needed for an orderly shutdown)
    //
    ThSupInitialize();

    //
    // This thread responds to the ShutDownEvent and insures
    // an orderly shutdown when run as either a service or an exe.
    //
    ShutDownThreadHandle = (HANDLE)CreateThread(NULL,
                                                0,
                                                MainFrsShutDown,
                                                NULL,
                                                0,
                                                &ShutDownThreadId);

    if (!HANDLE_IS_VALID(ShutDownThreadHandle)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, ":S: Can't create shutdown thread:", WStatus, CLEAN_UP);
    }

    DbgCaptureThreadInfo2(L"Shutdown", MainFrsShutDown, ShutDownThreadId);

    //
    // The rpc server may reference this table as soon as the rpc
    // interfaces are registered. Make sure it exists early in the
    // startup.
    //
    ReplicasByGuid = GTabAllocTable();

    //
    // The staging area table is referenced early in the startup threads
    //
    StagingAreaTable = GTabAllocTable();
    INITIALIZE_CRITICAL_SECTION(&StagingAreaCleanupLock);

    //
    // Initialize necessary tables.
    //
    ReparseTagTable = GTabAllocNumberTable();

    CompressionTable = GTabAllocTable();

    //
    // This table is used to keep contexts across multiple calls from by
    // info APIs. Table is only initialized once.
    //
    FrsInfoContextTable = GTabAllocNumberTable();


    if (!DebugInfo.DisableCompression) {
        DPRINT(0, "Staging file COMPRESSION support is enabled.\n");
        //
        // The Compression table is inited from the registry. Add the guids for the
        // compression formats that we support.
        //
        GTabInsertEntryNoLock(CompressionTable, (PVOID)&FrsGuidCompressionFormatLZNT1, (GUID*)&FrsGuidCompressionFormatLZNT1, NULL);
    } else {
        DPRINT(0, "Staging file COMPRESSION support is disabled.\n");
    }

    //
    // Size of buffer used during directory enumeration
    //
    CfgRegReadDWord(FKC_ENUMERATE_DIRECTORY_SIZE, NULL, 0, &EnumerateDirectorySizeInBytes);
    DPRINT1(4, ":S: Registry Param - Enumerate Directory Buffer Size in Bytes: %d\n",
            EnumerateDirectorySizeInBytes);

    //
    // Default File and Directory filter lists.
    //
    //    The compiled in default is only used if no value is supplied in
    //    EITHER the DS or the Registry.
    //    The table below shows how the final filter is formed.
    //
    //    value      Value
    //    supplied  supplied        Resulting filter string Used
    //    in DS     in Registry
    //      No        No             DEFAULT_xxx_FILTER_LIST
    //      No        Yes            Value from registry
    //      Yes       No             Value from DS
    //      Yes       Yes            Value from DS + Value from registry
    //
    RegistryFileExclFilterList = NULL;
    CfgRegReadString(FKC_FILE_EXCL_FILTER_LIST, NULL, 0, &RegistryFileExclFilterList);

    RegistryDirExclFilterList = NULL;
    CfgRegReadString(FKC_DIR_EXCL_FILTER_LIST, NULL, 0, &RegistryDirExclFilterList);

    DPRINT1(4, ":S: Registry Param - File Filter List: %ws\n",
            (RegistryFileExclFilterList) ? RegistryFileExclFilterList : L"Null");

    DPRINT1(4, ":S: Registry Param - Directory Filter Exclusion List: %ws\n",
            (RegistryDirExclFilterList) ? RegistryDirExclFilterList : L"Null");

    //
    // Inclusion filters were added very late (7/13/99) so a single file
    // ~clbcatq.*  could be made to replicate.  This is a reg only key.
    //
    // Add the File Inclusion Filter List Value to the Reg key
    //     "HKLM\System\CurrentControlSet\Services\NtFrs\Parameters"
    //
    // If the value already exists then preserve it.
    //
    CfgRegWriteString(FKC_FILE_INCL_FILTER_LIST,
                     NULL,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    RegistryFileInclFilterList = NULL;
    CfgRegReadString(FKC_FILE_INCL_FILTER_LIST, NULL, 0, &RegistryFileInclFilterList);

    RegistryDirInclFilterList = NULL;
    CfgRegReadString(FKC_DIR_INCL_FILTER_LIST, NULL, 0, &RegistryDirInclFilterList);


    DPRINT1(4, ":S: Registry Param - File Filter Inclusion List: %ws\n",
            (RegistryFileInclFilterList) ? RegistryFileInclFilterList : L"Null");

    DPRINT1(4, ":S: Registry Param - Directory Filter Inclusion List: %ws\n",
            (RegistryDirInclFilterList) ? RegistryDirInclFilterList : L"Null");


    //
    // Mutual Authentication. Update registry value as needed.
    //
    CfgRegCheckEnable(FKC_FRS_MUTUAL_AUTHENTICATION_IS,
                      NULL,
                      0,
                      &MutualAuthenticationIsEnabled,
                      &MutualAuthenticationIsEnabledAndRequired);


//  WStatus = ConfigCheckEnabledWithUpdate(FRS_CONFIG_SECTION,
//                                         FRS_MUTUAL_AUTHENTICATION_IS,
//                                         FRS_IS_DEFAULT_ENABLED,
//                                         &MutualAuthenticationIsEnabled);
//
//  if (!MutualAuthenticationIsEnabled) {
//      DPRINT_WS(0, "WARN - Mutual authentication is not enabled", WStatus);
//  } else {
//      DPRINT(4, "Mutual authentication is enabled\n");
//  }

    //
    // Initialize the FRS backup writer COM interface.
    //
    DPRINT(4, "About to initialize the Frs Writer component\n");
    WStatus = InitializeFrsWriter();
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1(1,"WARN - Can not initialize the Frs Writer component, WStatus = %d\n", WStatus); 
    }

    //
    // Initialize the Perfmon server
    //
    InitializePerfmonServer();

    //
    // Create registry keys for checking access to RPC calls
    //
    FrsRpcInitializeAccessChecks();

    //
    // Register the RPC interfaces
    //
    if (!FrsRpcInitialize()) {
        return RPC_S_CANT_CREATE_ENDPOINT;
    }

    return ERROR_SUCCESS;


CLEAN_UP:
        return WStatus;
}


VOID
MainInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to run the service

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainInit:"

    EnterCriticalSection(&MainInitLock);
    //
    // No need to initialize twice
    //
    if (MainInitHasRun) {
        LeaveCriticalSection(&MainInitLock);
        return;
    }

    //
    // SETUP THE INFRASTRUCTURE
    //

    //
    // Reset our start time (in minutes).  The service is not restarted
    // unless this invocation ran long enough before taking an assert.
    //
    // 100-nsecs / (10 (microsecs) * 1000 (msecs) * 1000 (secs) * 60 (min)
    //
    GetSystemTimeAsFileTime((FILETIME *)&DebugInfo.StartSeconds);
    DebugInfo.StartSeconds /= (10 * 1000 * 1000);

    //
    // Fetch the staging file limit
    //
    CfgRegReadDWord(FKC_STAGING_LIMIT, NULL, 0, &StagingLimitInKb);
    DPRINT1(4, ":S: Staging limit is: %d KB\n", StagingLimitInKb);

    //
    // Put the default value in registry if there is no key present.
    //
    CfgRegWriteDWord(FKC_STAGING_LIMIT,
                     NULL,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // Get Max number of replica sets allowed.
    //
    CfgRegReadDWord(FKC_MAX_NUMBER_REPLICA_SETS, NULL, 0, &MaxNumberReplicaSets);

    //
    // Get Max number of Jet database sessions allowed.
    //
    CfgRegReadDWord(FKC_MAX_NUMBER_JET_SESSIONS, NULL, 0, &MaxNumberJetSessions);

    //
    // Get outstanding CO qutoa limit on outbound connections.
    //
    CfgRegReadDWord(FKC_OUT_LOG_CO_QUOTA, NULL, 0, &MaxOutLogCoQuota);

    //
    // Get boolean to tell us to preserve file object IDs
    //  -- See Bug 352250 for why this is a risky thing to do.
    CfgRegReadDWord(FKC_PRESERVE_FILE_OID, NULL, 0, &PreserveFileOID);

    //
    // Get number of days for retry timeouts
    //
    CfgRegReadDWord(FKC_MAX_CO_RETRY_TIMEOUT_MINUTES, NULL, 0, &MaxCoRetryTimeoutMinutes);

    //
    // Get maximum count for retry timeouts
    //
    CfgRegReadDWord(FKC_MAX_CO_RETRY_TIMEOUT_COUNT, NULL, 0, &MaxCoRetryTimeoutCount);

    //
    // Get state of outlog cleanup lock.
    //
    CfgRegReadDWord(FKC_LOCKED_OUTLOG_CLEANUP, NULL, 0, &LockedOutlogCleanup);

    //
    // Get the service long name for use in error messages.
    //
    ServiceLongName = FrsGetResourceStr(IDS_SERVICE_LONG_NAME);

    //
    // Initialize the Delayed command server. This command server
    // is really a timeout queue that the other command servers use
    // to retry or check the state of previously issued commands that
    // have an indeterminate completion time.
    //
    // WARN: MUST BE FIRST -- Some command servers may use this
    // command server during their initialization.
    //
    WaitInitialize();
    FrsDelCsInitialize();

    //
    // SETUP THE COMM LAYER
    //

    //
    // Initialize the low level comm subsystem
    //
    CommInitializeCommSubsystem();

    //
    // Initialize the Send command server. The receive command server
    // starts when we register our RPC interface.
    //
    SndCsInitialize();

    //
    // SETUP THE SUPPORT COMMAND SERVERS
    //

    //
    // Staging file fetcher
    //
    FrsFetchCsInitialize();

    //
    // Initial Sync Controller
    //
    InitSyncCsInitialize();

    //
    // Staging file installer
    //
    FrsInstallCsInitialize();

    //
    // Staging file generator
    //
    FrsStageCsInitialize();

    //
    // outbound log processor
    //
    OutLogInitialize();

    //
    // LAST, KICK OFF REPLICATION
    //

    //
    // MUST PRECEED DATABASE AND DS INITIALIZATION
    //
    // The DS command server and the Database command server depend on
    // the replica control initialization.
    //
    // Initialize the replica control command server
    //
    RcsInitializeReplicaCmdServer();

    //
    // Actually, we can start the database at any time after the delayed
    // command server and the replica control command server. But its
    // a good idea to fail sooner than later to make cleanup more predictable.
    //
    DbsInitialize();

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);

    MainInitHasRun = TRUE;
    LeaveCriticalSection(&MainInitLock);
}


VOID
MainMinimumInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to run the service

Arguments:
    None.

Return Value:
    TRUE    - No problems
    FALSE   - Can't start service
--*/
{
#undef DEBSUB
#define DEBSUB "MainMinimumInit:"

    //
    // Setup the infrastructure
    //
    DbgMinimumInit();

    //
    // Check some NT to WIN error translations
    //
    FRS_ASSERT(WIN_NOT_IMPLEMENTED(FrsSetLastNTError(STATUS_NOT_IMPLEMENTED)));

    FRS_ASSERT(WIN_SUCCESS(FrsSetLastNTError(STATUS_SUCCESS)));

    FRS_ASSERT(WIN_ACCESS_DENIED(FrsSetLastNTError(STATUS_ACCESS_DENIED)));

    FRS_ASSERT(WIN_INVALID_PARAMETER(FrsSetLastNTError(STATUS_INVALID_PARAMETER)));

    FRS_ASSERT(WIN_NOT_FOUND(FrsSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND)));

    //
    // Initialize the DS command server
    //
    FrsDsInitialize();

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
}


PWCHAR *
MainConvertArgV(
    DWORD ArgC,
    PCHAR *ArgV
    )
/*++
Routine Description:
    Convert short char ArgV into wide char ArgV

Arguments:
    ArgC    - From main
    ArgV    - From main

Return Value:
    Address of the new ArgV
--*/
{
#undef DEBSUB
#define DEBSUB "MainConvertArgV:"

    PWCHAR  *wideArgV;

    wideArgV = FrsAlloc((ArgC + 1) * sizeof(PWCHAR));
    wideArgV[ArgC] = NULL;

    while (ArgC-- >= 1) {
        wideArgV[ArgC] = FrsAlloc((strlen(ArgV[ArgC]) + 1) * sizeof(WCHAR));
        wsprintf(wideArgV[ArgC], L"%hs", ArgV[ArgC]);
        FRS_WCSLWR(wideArgV[ArgC]);
    }
    return wideArgV;
}


VOID
MainServiceHandler(
    IN DWORD    ControlCode
    )
/*++
Routine Description:
    Service handler. Called by the service controller runtime

Arguments:
    ControlCode

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainServiceHandler:"

    DPRINT1(0, ":S: Received control code %d from Service Controller\n",ControlCode);

    switch (ControlCode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:

            DPRINT1(0, ":S: Service controller requests shutdown in %d seconds...\n",
                    ShutDownTimeOut);

            FrsSetServiceStatus(SERVICE_STOP_PENDING, 0, ShutDownTimeOut * 1000, NO_ERROR);

            FrsScmRequestedShutdown = TRUE;
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
            return;


        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:

            DPRINT(0, ":S: SERVICE PAUSE/CONTINUE IS NOT IMPLEMENTED\n");
            return;

        case SERVICE_CONTROL_INTERROGATE:

            return;

        default:

            DPRINT2(0, ":S: Handler for service %ws does not understand 0x%x\n",
                    SERVICE_NAME, ControlCode);
    }
    return;
}


VOID
WINAPI
MainRunningAsAService(
    IN DWORD    ArgC,
    IN PWCHAR   *ArgV
    )
/*++
Routine Description:
    Main routine when running as a service

Arguments:
    ArgC    - Ignored
    ArgV    - Ignored

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainRunningAsAService:"

    HANDLE      StartupThreadHandle;
    DWORD       StartupThreadId;
    DWORD       WStatus;
    PDWORD      ServiceWaitState     = NULL;

    DPRINT(0, "Running as a service\n");

    //
    // Register our handlers
    //
    ServiceStatusHandle = RegisterServiceCtrlHandler(SERVICE_NAME, MainServiceHandler);
    if (!ServiceStatusHandle) {
        DPRINT1_WS(0, ":S: ERROR - No ServiceStatusHandle for %ws;",
                   SERVICE_NAME, GetLastError());
        ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        ServiceStatus.dwWin32ExitCode = ERROR_PROCESS_ABORTED;
        ServiceStatus.dwWaitHint = DEFAULT_SHUTDOWN_TIMEOUT * 1000;
        return;
    }


    if (!FrsIsShuttingDown) {
        FrsSetServiceStatus(SERVICE_START_PENDING,
                            0,
                            DEFAULT_STARTUP_TIMEOUT * 1000,
                            NO_ERROR);
    }

    //
    // Kick off a thread that updates the checkpoint and
    // keeps the service controller from timing out.
    // Allocate memory for data to be passed to another thread.
    //
    ServiceWaitState = FrsAlloc(sizeof(DWORD));
    *ServiceWaitState = SERVICE_START_PENDING;
    StartupThreadHandle = (HANDLE)CreateThread(NULL,
                                            0,
                                            MainSCCheckPointUpdate,
                                            ServiceWaitState,
                                            0,
                                            &StartupThreadId);

    if (!HANDLE_IS_VALID(StartupThreadHandle)) {
        //
        // Not a fatal error. It is OK to not update the checkpoint.
        //
        DPRINT_WS(4,":S: ERROR - Could not start thread to update startup checkpoint.", GetLastError());
    }

    //
    // Finish rest of debug input
    //
    DbgMustInit(ArgC, WideArgV);

    //
    // Critical initialization
    //
    DPRINT1(4, "ArgC = %d\n", ArgC);
    WStatus = MainMustInit(ArgC, WideArgV);
    if (FRS_SUCCESS(WStatus)) {
        //
        // Necessary initialization
        //
        MainMinimumInit();

        if (!FrsIsShuttingDown) {
            //
            // The core service has started.
            //
            FrsSetServiceStatus(SERVICE_RUNNING,
                                0,
                                DEFAULT_STARTUP_TIMEOUT * 1000,
                                NO_ERROR);
            //
            // Init the service restart action if service fails.
            //
            FrsSetServiceFailureAction();
        }
    } else {
        //
        // Initialization failed; service can't start
        //
        DPRINT_WS(0, ":S: MainMustInit failed;", WStatus);
        FrsSetServiceStatus(SERVICE_STOPPED,
                            0,
                            DEFAULT_SHUTDOWN_TIMEOUT * 1000,
                            ERROR_PROCESS_ABORTED);
    }
    return;
}


ULONG
MainNotRunningAsAService(
    IN DWORD    ArgC,
    IN PWCHAR   *ArgV
    )
/*++
Routine Description:
    Main routine when not running as a service

Arguments:
    ArgC    - Ignored
    ArgV    - Ignored

Return Value:
    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "MainNotRunningAsAService:"

    ULONG WStatus;

    DPRINT(0, "Not running as a service\n");

    //
    // Finish rest of debug input
    //
    DbgMustInit(ArgC, WideArgV);

    //
    // Critical initialization
    //
    DPRINT1(4, "ArgC = %d\n", ArgC);
    WStatus = MainMustInit(ArgC, WideArgV);
    if (!FRS_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":S: MainMustInit failed;", WStatus);
        ExitProcess(ERROR_NO_SYSTEM_RESOURCES);
    }

    //
    // Necessary initialization
    //
    MainMinimumInit();

#if 0
    //
    // Kick off the test thread and forget about it
    //
    if (!ThSupCreateThread(L"TestThread", NULL, FrsTest, NULL)) {
        DPRINT(0, ":S: Could not create FrsTest\n");
    }
#endif

    //
    // Wait for shutdown
    //

    DPRINT(0, ":S: Waiting for shutdown event.\n");
    WStatus = WaitForSingleObject(ShutDownEvent, INFINITE);

    CHECK_WAIT_ERRORS(0, WStatus, 1, ACTION_CONTINUE);


    DPRINT(0, ":S: Waiting for shutdown complete event.\n");
    WStatus = WaitForSingleObject(ShutDownComplete, INFINITE);

    CHECK_WAIT_ERRORS(0, WStatus, 1, ACTION_CONTINUE);

    if (WIN_SUCCESS(WStatus)) {
        DPRINT(0, ":S: ShutDownComplete event signalled.\n");
    }

    return WStatus;
}


ULONG
_cdecl
main(
    IN INT      ArgC,
    IN PCHAR    ArgV[]
    )
/*++
Routine Description:
    Main runs as either a service or an exe.

Arguments:
    ArgC
    ArgV

Return Value:
    ERROR_SUCCESS   - No problems
    Otherwise       - Something went wrong
--*/
{
#undef DEBSUB
#define DEBSUB "main:"
    DWORD Len;
    ULONG WStatus;
    HRESULT hr;
    
    SERVICE_TABLE_ENTRY ServiceTableEntry[] = {
        { SERVICE_NAME, MainRunningAsAService },
        { NULL,         NULL }
    };

    //
    // Process Handle
    //
    ProcessHandle = GetCurrentProcess();

    //
    // Disable any DPRINTs until we can init the debug component.
    //
    DebugInfo.Disabled = TRUE;

    //
    // Adjust the defaults for some tunable params.
    //
    CfgRegAdjustTuningDefaults();

    //
    // Get this Machine's name.
    //
    Len = MAX_COMPUTERNAME_LENGTH + 2;
    ComputerName[0] = UNICODE_NULL;
    GetComputerNameW(ComputerName, &Len);
    ComputerName[Len] = UNICODE_NULL;

    //
    // Initialize the memory allocation subsystem
    //
    FrsInitializeMemAlloc();

    //
    // Perform as much work as possible in WCHAR
    //
    WideArgV = MainConvertArgV(ArgC, ArgV);

    //
    // Find out if we are running as a service or as an .exe
    //
    RunningAsAService = !FrsSearchArgv(ArgC, WideArgV, L"notservice", NULL);

    //
    // Synchronizes access between the shutdown thread and the
    // service controller.
    //
    INITIALIZE_CRITICAL_SECTION(&ServiceLock);

    //
    // Initialize the debug lock
    //

    INITIALIZE_CRITICAL_SECTION(&DebugInfo.Lock);
    INITIALIZE_CRITICAL_SECTION(&DebugInfo.DbsOutOfSpaceLock);



    //
    // Enable event logging
    //
    InitializeEventLog();

    //
    // This event log will not show up in the debug
    // logs since it is written before debug logs are
    // initialized. We do this because DbgInitLogTraceFile
    // can produce a event log and we want to see the
    // FRS starting event log before any other event
    // logs.
    //
    EPRINT0(EVENT_FRS_STARTING);

    //
    // Init the debug trace log.
    //
    DbgInitLogTraceFile(ArgC, WideArgV);

    WStatus = ERROR_SUCCESS;

    try {
        try {

            if (RunningAsAService) {
                hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
                if (FAILED(hr)) {
                    DPRINT1(1,L"CoInitializeEx failed with hresult 0x%08lx\n", hr);
                }

                // initialize COM security
                if (SUCCEEDED(hr))  {
                    hr = CoInitializeSecurity(
                                  NULL,                                                      // sd
                                  -1,                                                        // cAuthSvc
                                  NULL,                                                     // asAuthSvc
                                  NULL,                                                    // pReserved1
                                  RPC_C_AUTHN_LEVEL_PKT_PRIVACY,     // dwAuthnLevel
                                  RPC_C_IMP_LEVEL_IDENTIFY,                // dwImpLevel
                                  NULL,                                                   // pAuthList
                                  EOAC_NONE,                                        // dwCapabilities
                                  NULL                                                   // pReserved3 
                                  );
                    if (FAILED(hr)) {
                        DPRINT1(1,L"CoInitializeSecurity failed with hresult 0x%08lx\n", hr);
                        CoUninitialize();
                    }
                }

                //
                // RUNNING AS A SERVICE
                //
                if (!StartServiceCtrlDispatcher(ServiceTableEntry)) {
                    WStatus = GetLastError();
                    DPRINT1_WS(0, "Could not start dispatcher for service %ws;",
                               SERVICE_NAME, WStatus);
                }
                
                if (SUCCEEDED(hr))  {
                    CoUninitialize();
                }
            } else {

                //
                // NOT A SERVICE
                //
                MainNotRunningAsAService(ArgC, WideArgV);
            }
        } except (FrsException(GetExceptionInformation())) {
        }
    } finally {
        if (AbnormalTermination()) {
            WStatus = ERROR_INVALID_ACCESS;
        }
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\mkdso\mkdsoe.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>
#include <ntldap.h>
#include <schedule.h>
#include <mkdso.h>
#include <frsrpc.h>
#include <ntdsapi.h>
#include <winber.h>


#define  ArgMatch(_a, _b) (wcsstr(_a, _b) == (_a))


#define WCS_CAT7(_dest, _a1, _a2, _a3, _a4, _a5, _a6, _a7 )     \
    wcscpy(_dest, _a1);                                         \
    wcscat(_dest, _a2);                                         \
    wcscat(_dest, _a3);                                         \
    wcscat(_dest, _a4);                                         \
    wcscat(_dest, _a5);                                         \
    wcscat(_dest, _a6);                                         \
    wcscat(_dest, _a7);


//
// Some useful ldap macroes
//
#define LDAP_FREE_MSG(x)        {if (x) {ldap_msgfree(x); (x) = NULL;}}
#define LDAP_FREE_VALUES(x)     {if (x) {ldap_value_free(x); (x) = NULL;}}
#define LDAP_FREE_BER_VALUES(x) {if (x) {ldap_value_free_len(x); (x) = NULL;}}


//Global data
BOOL           bVerboseMode       = FALSE;
BOOL           bVerboseModeSearch = FALSE;
PWCHAR         DcName             = NULL;
PLDAP          pLdap              = NULL;
BOOL           bDebugMode         = FALSE;
BOOL           bAffectAll         = FALSE;
PBYTE          SchedMask          = NULL;
PBYTE          SchedOverride      = NULL;
BOOL           bCreateSet         = FALSE;
BOOL           bUpdateSet         = FALSE;
BOOL           bDelSet            = FALSE;
BOOL           bCreateMember      = FALSE;
BOOL           bMakeMePrimary     = FALSE;
BOOL           bUpdateMember      = FALSE;
BOOL           bDelMember         = FALSE;
BOOL           bCreateSubscriber  = FALSE;
BOOL           bUpdateSubscriber  = FALSE;
BOOL           bDelSubscriber     = FALSE;
BOOL           bDump              = FALSE;
BOOL           bSchedule          = FALSE;
BOOL           bDFSNaming         = FALSE;

WCHAR          ComputerObjectGuidStr[50];
PWCHAR         DomainGuidStr = NULL;                 // [50];
PWCHAR         DFSName = NULL;

//
// Static array to print the replica set type.
//

WCHAR ReplicaSetTypeStr[][MAX_PATH] = {L"Invalid type",
                                       L"Invalid type",
                                       L"Sysvol",
                                       L"Dfs",
                                       L"Other"};


DWORD
UpdateReplicaSet(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      ReplicaSetType,
    PWCHAR      FileFilter,
    PWCHAR      DirectoryFilter,
    PWCHAR      PrimaryMember,
    PBYTE       pSchedule
    );

VOID
PrintScheduleGrid(
    PUCHAR    ScheduleData,
    DWORD     Mask
    );

VOID
PrintSchedule(
    PSCHEDULE Schedule,
    DWORD     Mask
    );


DWORD
BindToDC (
    IN  PWCHAR    pszDC,
    OUT PLDAP     *ppLDAP
    )
/*++

Routine Description:

    Sets up an LDAP connection to the specified server

Arguments:

    pwszDC - DS DC to bind to
    ppLDAP - The LDAP connection information is returned here

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG   ulOptions;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName
    // passing the server name as the domainname parm...bad, because
    // DsGetDcName will make a load of DNS queries based on the server name,
    // it is designed to construct these queries from a domain name...so all
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up
    // as referrals/forwarders are contacted to attempt to resolve the bogus
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
    // after the ldap_init but before any other operation using the ldap
    // handle from ldap_init, the delayed connection setup will not call
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
    // will detect that and use the address directly.
    //
//    *ppLDAP = ldap_open(pszDC, LDAP_PORT);
    *ppLDAP = ldap_init(pszDC, LDAP_PORT);

    if(*ppLDAP == NULL) {
        dwErr = ERROR_PATH_NOT_FOUND;
    } else {
        //
        // set the options.
        //
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        ldap_set_option(*ppLDAP, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

        //
        // Do a bind...
        //
        dwErr = ldap_bind_s(*ppLDAP, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    }

    return(dwErr);
}

PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL)
            return NULL;

    NewStr = (PWCHAR)malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}




VOID
AddMod(
    PWCHAR AttrType,
    PWCHAR AttrValue,
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR *)malloc(sizeof (PWCHAR) * 2);
    Values[0] = _wcsdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
//    Attr->mod_op = LDAP_MOD_ADD;
    Attr->mod_op = LDAP_MOD_REPLACE;
    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
AddBerMod(
    PWCHAR AttrType,
    PCHAR AttrValue,
    DWORD AttrValueLen,
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    AttrValueLen    - length of the attribute
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PLDAP_BERVAL    Berval;
    PLDAP_BERVAL    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL) {
        return;
    }

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PLDAP_BERVAL)malloc(sizeof(LDAP_BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PLDAP_BERVAL *)malloc(sizeof (PLDAP_BERVAL) * 2);
    Values[0] = Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_bvalues = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
FreeMod(
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    //
    // For each attibute
    //
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            //
            // Free the value
            //
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

BOOL
LdapSearch(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    LDAPMessage  **Res,
    BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
    DWORD LStatus;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_s(ldap, Base, Scope, Filter, Attrs, AttrsOnly, Res);

    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {
        if (!Quiet) {
            DPRINT4("WARN - Error searching %ws for %ws; LStatus %d: %ws\n",
                    Base, Filter, LStatus, ldap_err2string(LStatus));
        }
        return FALSE;
    }
    //
    // Return TRUE if not shutting down
    //
    return TRUE;
}

PWCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PWCHAR Dn,
    IN PWCHAR DesiredAttr,
    IN BOOL   Quiet
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.
    Quiet

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES(). NULL if unsuccessful.
--*/
{
    PWCHAR          Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PWCHAR          Attrs[2];
    PWCHAR          *Values = NULL;

    //
    // Search Base for all of its attributes + values
    //
    MK_ATTRS_1(Attrs, DesiredAttr);

    //
    // Issue the ldap search
    //
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, CLASS_ANY, Attrs, 0, &LdapMsg, Quiet)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    LDAP_FREE_MSG(LdapMsg);
    return Values;
}



PLDAP_BERVAL *
GetBerValues(
    IN PLDAP  Ldap,
    IN PWCHAR Dn,
    IN PWCHAR DesiredAttr,
    IN BOOL   Quiet
    )
/*++
Routine Description:
    Return the DS Ber values for one binary attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.
    Quiet

Return Value:
    An array of BerVal struct pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_BER_VALUES(). NULL if unsuccessful.
--*/
{
    PWCHAR          Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PWCHAR          Attrs[2];
    PLDAP_BERVAL   *Values = NULL;

    //
    // Search Base for all of its attributes + values
    //
    MK_ATTRS_1(Attrs, DesiredAttr);

    //
    // Issue the ldap search
    //
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, CLASS_ANY, Attrs, 0, &LdapMsg, Quiet)) {
        return NULL;
    }

    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values_len(Ldap, LdapEntry, Attr);
        }
    }
    LDAP_FREE_MSG(LdapMsg);
    return Values;
}



BOOL
LdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext,
    BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
    DWORD           LStatus = LDAP_SUCCESS;
    PLDAPControl    ServerControls[2];
    berval          cookie1 = { 0, NULL };

    FrsSearchContext->bOpen = FALSE;
    FrsSearchContext->LdapMsg = NULL;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;
    FrsSearchContext->TotalEntries = 0;

    FrsSearchContext->Filter = FrsWcsDup(Filter);
    FrsSearchContext->BaseDn = FrsWcsDup(Base);
    FrsSearchContext->Scope = Scope;
    FrsSearchContext->PageSize = FRS_LDAP_SEARCH_PAGESIZE;
    FrsSearchContext->Attrs = Attrs;


    LStatus = ldap_create_page_control(ldap,
                                      FrsSearchContext->PageSize,
                                      &cookie1,
                                      FALSE, // is critical
                                      &ServerControls[0]
                                     );

    ServerControls[1] = NULL;

    if (LStatus != LDAP_SUCCESS) {
        DPRINT1("ldap_create_page_control returned error. LStatus = 0x%x\n", LStatus);
    }

    LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      NULL,
                      0,
                      &FrsSearchContext->LdapMsg);

    if  (LStatus  == LDAP_SUCCESS) {
       FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
       FrsSearchContext->CurrentEntry = 0;
       FrsSearchContext->bOpen = TRUE;
    }


    return (LStatus == LDAP_SUCCESS);
}

PLDAPMessage
LdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{

    FrsSearchContext->CurrentEntry += 1;
    if ( FrsSearchContext->CurrentEntry == 1 ) {
        FrsSearchContext->CurrentLdapMsg = ldap_first_entry(ldap ,FrsSearchContext->LdapMsg);
    } else {
        FrsSearchContext->CurrentLdapMsg = ldap_next_entry(ldap ,FrsSearchContext->CurrentLdapMsg);
    }

    return FrsSearchContext->CurrentLdapMsg;
}

DWORD
LdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
    DWORD                     LStatus = LDAP_SUCCESS;
    berval                  * CurrCookie = NULL;
    PLDAPControl            * CurrControls = NULL;
    ULONG                     retcode = 0;
    PLDAPControl              ServerControls[2];



    // Get the server control from the message, and make a new control with the cookie from the server
    LStatus = ldap_parse_result(ldap, FrsSearchContext->LdapMsg, &retcode,NULL,NULL,NULL,&CurrControls,FALSE);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);
    FrsSearchContext->LdapMsg = NULL;

    if (LStatus == LDAP_SUCCESS) {
       LStatus = ldap_parse_page_control(ldap, CurrControls, &FrsSearchContext->TotalEntries, &CurrCookie);
       // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are
       // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will
       // cause us to start over at the beginning of the search results.

    }
    if (LStatus == LDAP_SUCCESS) {
       if ( CurrCookie->bv_len == 0 && CurrCookie->bv_val == 0 ) {
          // under Exchange 5.5, SP 2, this means we're at the end of the results.
          // if we pass in this cookie again, we will start over at the beginning of the search results.
          LStatus = LDAP_CONTROL_NOT_FOUND;
       }

       ServerControls[0] = NULL;
       ServerControls[1] = NULL;
       if (LStatus == LDAP_SUCCESS) {
          LStatus = ldap_create_page_control(ldap,
                                  FrsSearchContext->PageSize,
                                  CurrCookie,
                                  FALSE,
                                  ServerControls);
       }
       ldap_controls_free(CurrControls);
       CurrControls = NULL;
       ber_bvfree(CurrCookie);
       CurrCookie = NULL;
    }

    // continue the search with the new cookie
    if (LStatus == LDAP_SUCCESS) {
       LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      NULL,
                      0,
                      &FrsSearchContext->LdapMsg);

       if ( (LStatus != LDAP_SUCCESS) && (LStatus != LDAP_CONTROL_NOT_FOUND) )
       {
          // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results
          // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there
          // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page
          // control from the search results).

       }
    }

    if (LStatus == LDAP_SUCCESS) {
        FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
        FrsSearchContext->CurrentEntry = 0;

    }

    return LdapMapErrorToWin32(LStatus);
}

PLDAPMessage
LdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
    DWORD         WStatus = ERROR_SUCCESS;
    PLDAPMessage  NextEntry = NULL;

    if (FrsSearchContext->bOpen != TRUE) {
       NextEntry = NULL;
    } else {
       if (FrsSearchContext->EntriesInPage > FrsSearchContext->CurrentEntry ) {
          // return the next entry from the current page
          return LdapSearchGetNextEntry(ldap, FrsSearchContext);
       } else {
          // see if there are more pages of results to get
          WStatus = LdapSearchGetNextPage(ldap, FrsSearchContext);
          if (WStatus == ERROR_SUCCESS) {
             return LdapSearchGetNextEntry(ldap, FrsSearchContext);
          }
       }
    }

    return NextEntry;
}




VOID
LdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
    FrsSearchContext->bOpen = FALSE;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;
    FrsSearchContext->TotalEntries = 0;

    FREE(FrsSearchContext->Filter);
    FREE(FrsSearchContext->BaseDn);

    if (FrsSearchContext->LdapMsg != NULL) {
        LDAP_FREE_MSG(FrsSearchContext->LdapMsg);
    }
}

PWCHAR
GetRootDn(
    PLDAP    Ldap,
    PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, ATTR_ROOT, ATTR_NAMING_CONTEXTS, FALSE);
    if (Values == NULL) {
        return NULL;
    }

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsWcsDup(Root);
            LDAP_FREE_VALUES(Values);
            return Root;
        }
    }
    DPRINT1("ERROR - COULD NOT FIND %ws\n", NamingContext);
    LDAP_FREE_VALUES(Values);
    return NULL;
}



PWCHAR
ExtendDn(
    PWCHAR Dn,
    PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PWCHAR NewDn;

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"CN=");
    wcscat(NewDn, Cn);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}


PVOID *
FindValues(
    PLDAPMessage LdapEntry,
    PWCHAR       DesiredAttr,
    BOOL         DoBerValues
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoVerValues - Return the bervals

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES(). NULL if unsuccessful.
--*/
{
    PWCHAR      LdapAttr;       // Retrieved from an ldap entry
    BerElement  *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (LdapAttr = ldap_first_attribute(pLdap, LdapEntry, &Ber);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(pLdap, LdapEntry, Ber)) {
        if (_wcsicmp(DesiredAttr, LdapAttr) == 0) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerValues) {
                return (PVOID *)ldap_get_values_len(pLdap, LdapEntry, LdapAttr);
            } else {
                return (PVOID *)ldap_get_values(pLdap, LdapEntry, LdapAttr);
            }
        }
    }
    return NULL;
}

PWCHAR
FindValue(
    PLDAPMessage LdapEntry,
    PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE().
--*/
{
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FindValues(LdapEntry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    if (Values) {
        Val = new WCHAR[wcslen(Values[0]) + 1];
        wcscpy(Val, Values[0]);
    } else {
        Val = NULL;
    }

    // Free ldap's array of values
    LDAP_FREE_VALUES(Values);

    return Val;
}

BOOL
FindBerValue(
    PLDAPMessage Entry,
    PWCHAR       DesiredAttr,
    ULONG        *Len,
    VOID         **Value
    )
/*++
Routine Description:
    Return a copy of the attributes object's schedule

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - desired attribute
    Len         - length of Value
    Value       - binary value

Return Value:
    The address of a schedule or NULL. Free with FrsFree().
--*/
{
    PLDAP_BERVAL    *Values;

    *Len = 0;
    *Value = NULL;

    //
    // Get ldap's array of values
    //
    Values = (PLDAP_BERVAL *)FindValues(Entry, DesiredAttr, TRUE);
    if (!Values) {
        return FALSE;
    }

    //
    // Return a copy of the schedule
    //
    *Len = Values[0]->bv_len;
    if (*Len) {
        *Value = new WCHAR[*Len];
        CopyMemory(*Value, Values[0]->bv_val, *Len);
    }
    LDAP_FREE_BER_VALUES(Values);
    return TRUE;
}


PBYTE
ReadScheduleFile(
    PWCHAR  FileName
    )
/*++
Routine Description:
    Read a Hex formated byte array for a 7x24 schedule from a file.
    Convert to a 7x24 binary schedule.

Arguments:
    FileName - Name of schedule file.

Return Value:
    ptr to schedule data array or NULL if invalid param.
--*/
{
    HANDLE FileHandle;
    PBYTE  SchedData;
    DWORD  WStatus;
    DWORD  BytesRead;
    DWORD  DataByte, i, Day, Hour;
    ULONG  Remaining;
    PCHAR  pTC;
    CHAR   SchedText[FRST_SIZE_OF_SCHEDULE_GRID*3 + 50];

    SchedData = new BYTE[FRST_SIZE_OF_SCHEDULE_GRID];
    if (SchedData == NULL) {
        printf("Error allocating memory.\n");
        return NULL;
    }

    FileHandle = CreateFileW(
        FileName,                                   //  lpszName
        GENERIC_READ | GENERIC_WRITE,               //  fdwAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,         //  fdwShareMode
        NULL,                                       //  lpsa
        OPEN_EXISTING,                              //  fdwCreate
        FILE_ATTRIBUTE_NORMAL,                      //  fdwAttrAndFlags
        NULL);                                      //  hTemplateFile

    if (!HANDLE_IS_VALID(FileHandle)) {
        WStatus = GetLastError();
        printf("Error opening %ws   WStatus: %d\n", FileName, WStatus);
        FREE(SchedData);
        return NULL;
    }

    if (!ReadFile(FileHandle, SchedText, sizeof(SchedText), &BytesRead, NULL)) {
        WStatus = GetLastError();
        printf("Error reading %ws   WStatus: %d\n", FileName, WStatus);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // remove any white-space chars, including CR-LF, used for formatting.
    //
    Remaining = BytesRead;
    pTC = SchedText;

    while (Remaining > 0) {
        if (isspace((LONG) *pTC)) {
            memcpy(pTC, pTC+1, Remaining-1);
        } else {
            pTC++;
        }
        Remaining -= 1;
    }
    BytesRead = pTC - SchedText;

    if (BytesRead < FRST_SIZE_OF_SCHEDULE_GRID*2) {
        printf("Error reading %ws   Expecting %d bytes,  Actual was %d bytes.  Could be too much whitespace.\n",
           FileName, FRST_SIZE_OF_SCHEDULE_GRID*2, BytesRead);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // Result should be exactly the right size.
    //
    if (BytesRead != FRST_SIZE_OF_SCHEDULE_GRID*2) {
        printf("Error reading %ws   Expecting %d bytes,  Actual was %d bytes\n",
               FileName, FRST_SIZE_OF_SCHEDULE_GRID*2, BytesRead);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // Convert to binary.
    //
    for (i=0; i<FRST_SIZE_OF_SCHEDULE_GRID; i++) {
        if (sscanf(&SchedText[i*2], "%2x", &DataByte) != 1) {
            SchedText[i*2+2] = '\0';
            printf("Error reading %ws   Invalid hex data (%s) for schedule byte %d.\n",
                   FileName, &SchedText[i*2], i);
            FREE(SchedData);
            FRS_CLOSE(FileHandle);
            return NULL;
        }
        SchedData[i] = (BYTE) DataByte;
    }


    FRS_CLOSE(FileHandle);
    return SchedData;
}

DWORD
BuildSchedule(
    PBYTE       *ppSchedule,
    DWORD       Interval,
    DWORD       Stagger,
    DWORD       Offset
    )
/*++
Routine Description:
     Build the schedule structure.
Arguments:
      ppSchedule         - pointer to return the schedule in.

Return Value:
    winerror.
--*/
{
    BYTE    ScheduleData[FRST_SIZE_OF_SCHEDULE_GRID];
    UINT    i, Day, Hour;
    DWORD   Status = ERROR_SUCCESS;

    *ppSchedule = new BYTE[FRST_SIZE_OF_SCHEDULE];
    if (*ppSchedule == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Set the values for the elements of the SCHEDULE structure.
    //

    ((PSCHEDULE)*ppSchedule)->Size = FRST_SIZE_OF_SCHEDULE;
    ((PSCHEDULE)*ppSchedule)->Bandwidth = 0;
    ((PSCHEDULE)*ppSchedule)->NumberOfSchedules = 1;
    ((PSCHEDULE)*ppSchedule)->Schedules->Type = SCHEDULE_INTERVAL;
    ((PSCHEDULE)*ppSchedule)->Schedules->Offset = sizeof(SCHEDULE);

    //
    // Building the ScheduleData array depending on the requested schedule.
    //

    for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
        if (Interval == 0) {
            ScheduleData[i] = 0x00;
        } else if (i < (Offset*Interval)) {
            ScheduleData[i] = 0x00;
        } else if ((i-(Offset*Interval))%(Interval * Stagger) == 0) {
            ScheduleData[i] = 0x01;
        } else {
            ScheduleData[i] = 0x00;
        }
    }

    //
    // Use the supplied schedule mask to turn off regions of the above schedule.
    //
    if (SchedMask != NULL) {
        for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
            ScheduleData[i] &= ~SchedMask[i];
        }
    }

    //
    // Apply the supplied override schedule to regions of the above schedule.
    //
    if (SchedOverride != NULL) {
        for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
            ScheduleData[i] |= SchedOverride[i];
        }
    }

    memcpy((*ppSchedule)+sizeof(SCHEDULE),ScheduleData, FRST_SIZE_OF_SCHEDULE_GRID);
    return Status;
}


#if 0
DWORD
DeleteSubscription(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn
    )
/*++
Routine Description:
     Delete a Subscription.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          SubscriptionDn        = NULL;
    PWCHAR          MemberAttrs[3];
    PWCHAR          SubscriptionAttrs[3];
    PWCHAR          SearchFilter        = NULL;
    DWORD           NoOfMembers;
    DWORD           NoOfSubscriptions;
    PWCHAR          LocalComputerDn     = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_2(MemberAttrs,     ATTR_DN, ATTR_COMPUTER_REF);
    MK_ATTRS_2(SubscriptionAttrs, ATTR_DN, ************ ATTR_MEMBER_REF);

    //
    // We need to get to the member object and the computer object.
    //   To get to the member object we need the member name or the computer dn.
    //   To get to the computer object we need a member with valid computerref
    //   or the computerdn parameter.
    //
    if ((MemberName == NULL) && (ComputerDn == NULL)) {
        printf("ERROR: MemberName and ComputerDn are NULL in DeleteSubscription.\n");
        Status = MKDSOE_BAD_ARG;
        return Status;
    }

    SearchFilter = (PWCHAR) malloc((max((ComputerDn != NULL)?wcslen(ComputerDn):0,
                                        (MemberDn != NULL)?wcslen(MemberDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        MemberDn = ExtendDn(ReplicaSetDn, MemberName);
    } else {
        //
        // Use computerdn to get the memberdn.
        //
        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");

        if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                        MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIPTION_DELETE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error deleting Subscription; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_NOT_FOUND_DELETE;
            goto CLEANUP;
        }

        if (NoOfMembers > 1) {
            printf("Error deleting Subscription; duplicate members found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_DUPS_FOUND_DELETE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            MemberDn = FindValue(LdapEntry, ATTR_DN);
        }

        LdapSearchClose(&FrsSearchContext);
    }

    DPRINT1("MemberDn:%ws\n", MemberDn);

    if (ComputerDn == NULL) {
        //
        // Use MemberDn to find the computerDn. We will come here
        // only if MemberName is supplied but computerdn is not.
        //
        if (!LdapSearchInit(pLdap, MemberDn, LDAP_SCOPE_BASE, NULL,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIPTION_DELETE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error deleting Subscription; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_NOT_FOUND_DELETE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           LocalComputerDn = FindValue(LdapEntry, ATTR_COMPUTER_REF);
           if (LocalComputerDn == NULL) {
               printf("Error deleting Subscription; computerdn not found.\n");
               LdapSearchClose(&FrsSearchContext);
               Status = MKDSOE_SUBSCRIPTION_NOT_FOUND_DELETE;
               goto CLEANUP;
           }
        }

        LdapSearchClose(&FrsSearchContext);
    } else {
        LocalComputerDn = FrsWcsDup(ComputerDn);
    }


    //
    // We have the computerdn and the memberdn. Now check if a Subscription
    // already exists.
    //

    WCS_CAT7(SearchFilter, L"(&(", ATTR_MEMBER_REF, L"=", MemberDn, L")" , CLASS_SUBSCRIPTION, L")");

    if (!LdapSearchInit(pLdap, LocalComputerDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        SubscriptionAttrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIPTION_DELETE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscriptions = FrsSearchContext.EntriesInPage;

    if ((NoOfSubscriptions > 1) && (bAffectAll != TRUE)) {
        printf("Duplicate Subscriptions found. Deleting all.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIPTION_DUPS_FOUND_DELETE;
        goto CLEANUP;
    }

    if (NoOfSubscriptions != 0) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           SubscriptionDn = FindValue(LdapEntry, ATTR_DN);
           DPRINT1("Deleting Dn:%ws\n", SubscriptionDn);
           if (bDebugMode) {
               DPRINT1("LStatus = ldap_delete_s(pLdap, %ws);\n", SubscriptionDn);
           } else {
               LStatus = ldap_delete_s(pLdap, SubscriptionDn);
               if (LStatus != LDAP_SUCCESS) {
                   printf("ERROR - Can't delete %ws: %ws\n",
                           SubscriptionDn, ldap_err2string(LStatus));
                   Status = MKDSOE_SUBSCRIPTION_DELETE_FAILED;
               }
           }
           FREE(SubscriptionDn);
        }
    } else {
        printf("Warning deleting; Subscription not found.\n");
        Status = MKDSOE_SUBSCRIPTION_NOT_FOUND_DELETE;
    }

    LdapSearchClose(&FrsSearchContext);


CLEANUP:

    FREE(SearchFilter);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(LocalComputerDn);
    FREE(SubscriptionDn);
    FreeMod(&Mod);
    return Status;
}

DWORD
UpdateSubscription(
    PWCHAR      SubscriptionDn,
    PWCHAR      MemberRef,
    PWCHAR      RootPath,
    PWCHAR      StagePath
    )
/*++
Routine Description:
     Update the Subscription.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          Attrs[5];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          CurMemberRef        = NULL;
    PWCHAR          CurRootPath         = NULL;
    PWCHAR          CurStagePath        = NULL;
    DWORD           NoOfSubscriptions;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    MK_ATTRS_4(Attrs, ATTR_DN, ATTR_MEMBER_REF, ATTR_REPLICA_ROOT, ATTR_REPLICA_STAGE);

    if (!LdapSearchInit(pLdap, SubscriptionDn, LDAP_SCOPE_BASE, NULL,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIPTION_OBJ_UPDATE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscriptions = FrsSearchContext.EntriesInPage;

    if (NoOfSubscriptions == 0) {
        printf("Error updating; Subscription not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIPTION_NOT_FOUND_UPDATE;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        CurMemberRef = FindValue(LdapEntry, ATTR_MEMBER_REF);
        CurRootPath = FindValue(LdapEntry, ATTR_REPLICA_ROOT);
        CurStagePath = FindValue(LdapEntry, ATTR_REPLICA_STAGE);
    }

    LdapSearchClose(&FrsSearchContext);

    DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);

    // Check ATTR_MEMBER_REF
    // if a ref is supplied then make sure it is same as the current ref.
    // if a ref is not supplied then leave it as it is.
    if (MemberRef != NULL) {
        if ((CurMemberRef == NULL) ||
            ((CurMemberRef != NULL) && wcscmp(MemberRef, CurMemberRef))) {
            AddMod(ATTR_MEMBER_REF, MemberRef, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsMemberReference:%ws\n", MemberRef);
        }
    }

    // Check ATTR_REPLICA_ROOT
    // if a path is supplied then make sure it is same as the current path.
    // if a path is not supplied then leave it as it is.
    if (RootPath != NULL) {
        if ((CurRootPath == NULL) ||
            ((CurRootPath != NULL) && wcscmp(RootPath, CurRootPath))) {
            AddMod(ATTR_REPLICA_ROOT, RootPath, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsRootPath:%ws\n", RootPath);
        }
    }

    // Check ATTR_REPLICA_STAGE
    // if a path is supplied then make sure it is same as the current path.
    // if a path is not supplied then leave it as it is.
    if (StagePath != NULL) {
        if ((CurStagePath == NULL) ||
            ((CurStagePath != NULL) && wcscmp(StagePath, CurStagePath))) {
            AddMod(ATTR_REPLICA_STAGE, StagePath, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsRootPath:%ws\n", StagePath);
        }
    }


    if (bNeedsUpdate) {
        if (bDebugMode) {
          DPRINT1("LStatus = ldap_modify_s(pLdap, %ws, Mod);\n", SubscriptionDn);
        } else {
            LStatus = ldap_modify_s(pLdap, SubscriptionDn, Mod);
            if (LStatus != LDAP_SUCCESS) {
                printf("ERROR - Can't update %ws: %ws\n",
                        SubscriptionDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIPTION_OBJ_UPDATE_FAILED;
            }
        }

    } else {
        printf("No update required\n");
    }

CLEANUP:

    FREE(CurMemberRef);
    FREE(CurRootPath);
    FREE(CurStagePath);
    FreeMod(&Mod);
    return Status;
}

DWORD
CreateNewSubscription(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn,
    PWCHAR      RootPath,
    PWCHAR      StagePath,
    PWCHAR      RefDCName
    )
/*++
Routine Description:
     Create a new Subscription.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          SubscriptionDn      = NULL;
    PWCHAR          MemberAttrs[3];
    PWCHAR          SubscriptionAttrs[3];
    PWCHAR          SearchFilter        = NULL;
    DWORD           NoOfMembers;
    DWORD           NoOfSubscriptions;
    PWCHAR          LocalComputerDn     = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_2(MemberAttrs,     ATTR_DN, ATTR_COMPUTER_REF);
    MK_ATTRS_2(SubscriptionAttrs, ************* ATTR_DN, ATTR_MEMBER_REF);

    //
    // We need to get to the member object and the computer object.
    //   To get to the member object we need the member name or the computer dn.
    //
    //   To get to the computer object we need a member with valid computerref
    //   or the computerdn parameter.
    //
    if ((MemberName == NULL) && (ComputerDn == NULL)) {
        Status = MKDSOE_BAD_ARG;
        return Status;
    }

    SearchFilter = (PWCHAR) malloc((max((ComputerDn != NULL)?wcslen(ComputerDn):0,
                                        (MemberDn != NULL)?wcslen(MemberDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        MemberDn = ExtendDn(ReplicaSetDn, MemberName);
    } else {
        //
        // Use computerdn to get the memberdn.
        //
        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");

        if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error creating Subscription; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        if (NoOfMembers > 1) {
            printf("Error creating Subscription; duplicate members found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_DUPS_FOUND_UPDATE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           MemberDn = FindValue(LdapEntry, ATTR_DN);

        }

        LdapSearchClose(&FrsSearchContext);
    }

    DPRINT1("MemberDn:%ws\n", MemberDn);

    if (ComputerDn == NULL) {
        //
        // Use MemberDn to find the computerDn. We will come here
        // only if MemberName is supplied but computerdn is not.
        //
        if (!LdapSearchInit(pLdap, MemberDn, LDAP_SCOPE_BASE, NULL,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error creating Subscription; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            LocalComputerDn = FindValue(LdapEntry, ATTR_COMPUTER_REF);
            if (LocalComputerDn == NULL) {
                printf("Error creating Subscription; computerdn not found.\n");
                LdapSearchClose(&FrsSearchContext);
                Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
        }

        LdapSearchClose(&FrsSearchContext);
    } else {
        LocalComputerDn = FrsWcsDup(ComputerDn);
    }


    //
    // We have the computerdn and the memberdn. Now check if a Subscription
    // already exists.
    //

    WCS_CAT7(SearchFilter, L"(&(", ATTR_MEMBER_REF, L"=", MemberDn, L")" , CLASS_SUBSCRIPTION, L")");

    if (!LdapSearchInit(pLdap, LocalComputerDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        SubscriptionAttrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscriptions = FrsSearchContext.EntriesInPage;

    if (NoOfSubscriptions > 1) {
        printf("Error creating Subscription; duplicate found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIPTION_DUPS_FOUND_UPDATE;
        goto CLEANUP;
    }

    if (NoOfSubscriptions == 1) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            SubscriptionDn = FindValue(LdapEntry, ATTR_DN);
        }
        Status = UpdateSubscription(SubscriptionDn, MemberDn, RootPath, StagePath);
    } else {
        SubscriptionDn = ExtendDn(LocalComputerDn, MKDSOE_SUBSCRIPTION);

        // ATTR_DN
        DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
        AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

        if (bDebugMode) {
            DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
        } else {
            LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

            if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {

                printf("ERROR - Can't create %ws: %ws\n",
                        SubscriptionDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
        }

        FreeMod(&Mod);
                       ************ check
        SubscriptionDn = ExtendDn(SubscriptionDn, ReplicaSetName);

        // ATTR_DN
        DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
        AddMod(ATTR_CLASS, ATTR_SUBSCRIPTION, &Mod);

        // ATTR_MEMBER_REF
        AddMod(ATTR_MEMBER_REF, MemberDn, &Mod);
        DPRINT1("    FrsMemberReference:%ws\n", MemberDn);

        // ATTR_REPLICA_ROOT
        AddMod(ATTR_REPLICA_ROOT, RootPath, &Mod);
        DPRINT1("    FrsRootPath:%ws\n", RootPath);

        // ATTR_REPLICA_STAGE
        AddMod(ATTR_REPLICA_STAGE, StagePath, &Mod);
        DPRINT1("    FrsStagePath:%ws\n", StagePath);

        if (bDebugMode) {
            DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
        } else {
            LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

            if ((LStatus == LDAP_CONSTRAINT_VIOLATION) && RefDCName != NULL) {
                //
                // prepare the server hint. Needed in case the member object
                // is just created on another DC than the one on which the
                // Subscription is being created.
                //
                LDAPControl   simpleControl;
                PLDAPControl  controlArray[2];
                INT           rc;
                BERVAL*       pBerVal = NULL;
                BerElement*   pBer;

                pBer = ber_alloc_t(LBER_USE_DER);
                if (!pBer)
                {
                    Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                DPRINT1("Sending binding DC Name %ws\n",RefDCName);
                rc = ber_printf(pBer,"{io}", 0, RefDCName, wcslen(RefDCName) * sizeof(WCHAR));
                if ( rc == -1 ) {
                    Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                rc = ber_flatten(pBer, &pBerVal);
                if (rc == -1)
                {
                    Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                ber_free(pBer,1);

                controlArray[0] = &simpleControl;
                controlArray[1] = NULL;

            //    simpleControl.ldctl_oid = LDAP_SERVER_GC_VERIFY_NAME_OID_W;
                simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
                simpleControl.ldctl_iscritical = TRUE;
                simpleControl.ldctl_value = *pBerVal;

                LStatus = ldap_add_ext_s(pLdap,
                                         SubscriptionDn,
                                         Mod,
                                         (PLDAPControl *)&controlArray, //ServerControls,
                                         NULL                           //ClientControls,
                                         );
            }

            if (LStatus == LDAP_ALREADY_EXISTS) {
                //
                // If the object already exists then convert the create to an update.
                // This is to allow the user to run the data file with creates twice without
                // generating errors but only fixing the objects that have changed.
                //
                Status = UpdateSubscription(SubscriptionDn, MemberDn, RootPath, StagePath);

            } else if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't create %ws: %ws\n",
                        SubscriptionDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIPTION_OBJ_CRE_FAILED;
            }
        }
    }

    LdapSearchClose(&FrsSearchContext);


CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(SubscriptionDn);
    FREE(SearchFilter);
    FREE(LocalComputerDn);
    return Status;
}
#endif 0

DWORD
DeleteSubscriber(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn
    )
/*++
Routine Description:
     Delete a subscriber.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          SubscriberDn        = NULL;
    PWCHAR          MemberAttrs[3];
    PWCHAR          SubscriberAttrs[3];
    PWCHAR          SearchFilter        = NULL;
    DWORD           NoOfMembers;
    DWORD           NoOfSubscribers;
    PWCHAR          LocalComputerDn     = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_2(MemberAttrs,     ATTR_DN, ATTR_COMPUTER_REF);
    MK_ATTRS_2(SubscriberAttrs, ATTR_DN, ATTR_MEMBER_REF);

    //
    // We need to get to the member object and the computer object.
    //   To get to the member object we need the member name or the computer dn.
    //   To get to the computer object we need a member with valid computerref
    //   or the computerdn parameter.
    //
    if ((MemberName == NULL) && (ComputerDn == NULL)) {
        printf("ERROR: MemberName and ComputerDn are NULL in DeleteSubscriber.\n");
        Status = MKDSOE_BAD_ARG;
        return Status;
    }

    SearchFilter = (PWCHAR) malloc((max((ComputerDn != NULL)?wcslen(ComputerDn):0,
                                        (MemberDn != NULL)?wcslen(MemberDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        MemberDn = ExtendDn(ReplicaSetDn, MemberName);
    } else {
        //
        // Use computerdn to get the memberdn.
        //
        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");

        if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                        MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIBER_DELETE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error deleting subscriber; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE;
            goto CLEANUP;
        }

        if (NoOfMembers > 1) {
            printf("Error deleting subscriber; duplicate members found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_DUPS_FOUND_DELETE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            MemberDn = FindValue(LdapEntry, ATTR_DN);
        }

        LdapSearchClose(&FrsSearchContext);
    }

    DPRINT1("MemberDn:%ws\n", MemberDn);

    if (ComputerDn == NULL) {
        //
        // Use MemberDn to find the computerDn. We will come here
        // only if MemberName is supplied but computerdn is not.
        //
        if (!LdapSearchInit(pLdap, MemberDn, LDAP_SCOPE_BASE, NULL,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIBER_DELETE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error deleting subscriber; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           LocalComputerDn = FindValue(LdapEntry, ATTR_COMPUTER_REF);
           if (LocalComputerDn == NULL) {
               printf("Error deleting subscriber; computerdn not found.\n");
               LdapSearchClose(&FrsSearchContext);
               Status = MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE;
               goto CLEANUP;
           }
        }

        LdapSearchClose(&FrsSearchContext);
    } else {
        LocalComputerDn = FrsWcsDup(ComputerDn);
    }


    //
    // We have the computerdn and the memberdn. Now check if a subscriber
    // already exists.
    //

    WCS_CAT7(SearchFilter, L"(&(", ATTR_MEMBER_REF, L"=", MemberDn, L")" , CLASS_SUBSCRIBER, L")");

    if (!LdapSearchInit(pLdap, LocalComputerDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        SubscriberAttrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIBER_DELETE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscribers = FrsSearchContext.EntriesInPage;

    if ((NoOfSubscribers > 1) && (bAffectAll != TRUE)) {
        printf("Duplicate subscribers found. Deleting all.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIBER_DUPS_FOUND_DELETE;
        goto CLEANUP;
    }

    if (NoOfSubscribers != 0) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           SubscriberDn = FindValue(LdapEntry, ATTR_DN);
           DPRINT1("Deleting Dn:%ws\n", SubscriberDn);
           if (bDebugMode) {
               DPRINT1("LStatus = ldap_delete_s(pLdap, %ws);\n", SubscriberDn);
           } else {
               LStatus = ldap_delete_s(pLdap, SubscriberDn);
               if (LStatus != LDAP_SUCCESS) {
                   printf("ERROR - Can't delete %ws: %ws\n",
                           SubscriberDn, ldap_err2string(LStatus));
                   Status = MKDSOE_SUBSCRIBER_DELETE_FAILED;
               }
           }
           FREE(SubscriberDn);
        }
    } else {
        printf("Warning deleting; subscriber not found.\n");
        Status = MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE;
    }

    LdapSearchClose(&FrsSearchContext);


CLEANUP:

    FREE(SearchFilter);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(LocalComputerDn);
    FREE(SubscriberDn);
    FreeMod(&Mod);
    return Status;
}

DWORD
UpdateSubscriber(
    PWCHAR      SubscriberDn,
    PWCHAR      MemberRef,
    PWCHAR      RootPath,
    PWCHAR      StagePath
    )
/*++
Routine Description:
     Update the subscriber.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          Attrs[5];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          CurMemberRef        = NULL;
    PWCHAR          CurRootPath         = NULL;
    PWCHAR          CurStagePath        = NULL;
    DWORD           NoOfSubscribers;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    MK_ATTRS_4(Attrs, ATTR_DN, ATTR_MEMBER_REF, ATTR_REPLICA_ROOT, ATTR_REPLICA_STAGE);

    if (!LdapSearchInit(pLdap, SubscriberDn, LDAP_SCOPE_BASE, NULL,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIBER_OBJ_UPDATE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscribers = FrsSearchContext.EntriesInPage;

    if (NoOfSubscribers == 0) {
        printf("Error updating; subscriber not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIBER_NOT_FOUND_UPDATE;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        CurMemberRef = FindValue(LdapEntry, ATTR_MEMBER_REF);
        CurRootPath = FindValue(LdapEntry, ATTR_REPLICA_ROOT);
        CurStagePath = FindValue(LdapEntry, ATTR_REPLICA_STAGE);
    }

    LdapSearchClose(&FrsSearchContext);

    DPRINT1("SubscriberDn:%ws\n", SubscriberDn);

    // Check ATTR_MEMBER_REF
    // if a ref is supplied then make sure it is same as the current ref.
    // if a ref is not supplied then leave it as it is.
    if (MemberRef != NULL) {
        if ((CurMemberRef == NULL) ||
            ((CurMemberRef != NULL) && wcscmp(MemberRef, CurMemberRef))) {
            AddMod(ATTR_MEMBER_REF, MemberRef, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsMemberReference:%ws\n", MemberRef);
        }
    }

    // Check ATTR_REPLICA_ROOT
    // if a path is supplied then make sure it is same as the current path.
    // if a path is not supplied then leave it as it is.
    if (RootPath != NULL) {
        if ((CurRootPath == NULL) ||
            ((CurRootPath != NULL) && wcscmp(RootPath, CurRootPath))) {
            AddMod(ATTR_REPLICA_ROOT, RootPath, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsRootPath:%ws\n", RootPath);
        }
    }

    // Check ATTR_REPLICA_STAGE
    // if a path is supplied then make sure it is same as the current path.
    // if a path is not supplied then leave it as it is.
    if (StagePath != NULL) {
        if ((CurStagePath == NULL) ||
            ((CurStagePath != NULL) && wcscmp(StagePath, CurStagePath))) {
            AddMod(ATTR_REPLICA_STAGE, StagePath, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsStagePath:%ws\n", StagePath);
        }
    }


    if (bNeedsUpdate) {
        if (bDebugMode) {
          DPRINT1("LStatus = ldap_modify_s(pLdap, %ws, Mod);\n", SubscriberDn);
        } else {
            LStatus = ldap_modify_s(pLdap, SubscriberDn, Mod);
            if (LStatus != LDAP_SUCCESS) {
                printf("ERROR - Can't update %ws: %ws\n",
                        SubscriberDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIBER_OBJ_UPDATE_FAILED;
            }
        }

    } else {
        printf("No update required\n");
    }

CLEANUP:

    FREE(CurMemberRef);
    FREE(CurRootPath);
    FREE(CurStagePath);
    FreeMod(&Mod);
    return Status;
}

DWORD
CreateNewSubscriber(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn,
    PWCHAR      RootPath,
    PWCHAR      StagePath,
    PWCHAR      WorkingPath,
    PWCHAR      RefDCName
    )
/*++
Routine Description:
     Create a new subscriber.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          SubscriberDn        = NULL;
    PWCHAR          SubscriptionDn      = NULL;
    PWCHAR          MemberAttrs[3];
    PWCHAR          SubscriberAttrs[3];
    PWCHAR          SearchFilter        = NULL;
    DWORD           NoOfMembers;
    DWORD           NoOfSubscribers;
    PWCHAR          LocalComputerDn     = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PWCHAR          SaveDn;
    PWCHAR          DFSRoot, DFSJunction;
    DWORD           Vbar;

    if (bDFSNaming) {
        Vbar = wcscspn(DFSName, L'|');
        if ((Vbar == wcslen(DFSName) || (Vbar == 0)) {
            //
            // No vertical bar found.
            //
            Status = MKDSOE_BAD_ARG;
            return Status;
        }
        //
        // Extract the name components.
        //
        DFSRoot = FrsWcsDup(DFSName);
        DFSRoot[Vbar] = L'\0';
        DFSJunction = &DFSName[Vbar+1];
    }

    MK_ATTRS_2(MemberAttrs,     ATTR_DN, ATTR_COMPUTER_REF);
    MK_ATTRS_2(SubscriberAttrs, ATTR_DN, ATTR_MEMBER_REF);

    //
    // We need to get to the member object and the computer object.
    //   To get to the member object we need the member name or the computer dn.
    //
    //   To get to the computer object we need a member with valid computerref
    //   or the computerdn parameter.
    //
    if ((MemberName == NULL) && (ComputerDn == NULL)) {
        Status = MKDSOE_BAD_ARG;
        return Status;
    }

    SearchFilter = (PWCHAR) malloc((max((ComputerDn != NULL)?wcslen(ComputerDn):0,
                                        (MemberDn != NULL)?wcslen(MemberDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        MemberDn = ExtendDn(ReplicaSetDn, MemberName);
    } else {
        //
        // Use computerdn to get the memberdn.
        //
        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");

        if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error creating subscriber; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        if (NoOfMembers > 1) {
            printf("Error creating subscriber; duplicate members found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_DUPS_FOUND_UPDATE;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

           MemberDn = FindValue(LdapEntry, ATTR_DN);

        }

        LdapSearchClose(&FrsSearchContext);
    }

    DPRINT1("MemberDn:%ws\n", MemberDn);

    if (ComputerDn == NULL) {
        //
        // Use MemberDn to find the computerDn. We will come here
        // only if MemberName is supplied but computerdn is not.
        //
        if (!LdapSearchInit(pLdap, MemberDn, LDAP_SCOPE_BASE, NULL,
                            MemberAttrs, 0, &FrsSearchContext, FALSE)) {
            Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        NoOfMembers = FrsSearchContext.EntriesInPage;

        if (NoOfMembers == 0) {
            printf("Error creating subscriber; member not found.\n");
            LdapSearchClose(&FrsSearchContext);
            Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            LocalComputerDn = FindValue(LdapEntry, ATTR_COMPUTER_REF);
            if (LocalComputerDn == NULL) {
                printf("Error creating subscriber; computerdn not found.\n");
                LdapSearchClose(&FrsSearchContext);
                Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
        }

        LdapSearchClose(&FrsSearchContext);
    } else {
        LocalComputerDn = FrsWcsDup(ComputerDn);
    }


    //
    // We have the computerdn and the memberdn. Now check if a subscriber
    // already exists.
    //

    WCS_CAT7(SearchFilter, L"(&(", ATTR_MEMBER_REF, L"=", MemberDn, L")" , CLASS_SUBSCRIBER, L")");

    if (!LdapSearchInit(pLdap, LocalComputerDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        SubscriberAttrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
        goto CLEANUP;
    }

    NoOfSubscribers = FrsSearchContext.EntriesInPage;

    if (NoOfSubscribers > 1) {
        printf("Error creating subscriber; duplicate found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SUBSCRIBER_DUPS_FOUND_UPDATE;
        goto CLEANUP;
    }

    if (NoOfSubscribers == 1) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            SubscriberDn = FindValue(LdapEntry, ATTR_DN);
        }
        Status = UpdateSubscriber(SubscriberDn, MemberDn, RootPath, StagePath);
    } else {
        //
        // Create the new subscriber.
        //

        SubscriptionDn = ExtendDn(LocalComputerDn, MKDSOE_SUBSCRIPTION);

        // ATTR_DN
        DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
        AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

        if (WorkingPath != NULL) {
            // ATTR_WORKING_PATH
            AddMod(ATTR_REPLICA_STAGE, WorkingPath, &Mod);
            DPRINT1("    FrsWorkingPath:%ws\n", WorkingPath);
        } else {
            fprintf(stderr, "WARNING: Creating subscription '%ws' with no working path\n", MKDSOE_SUBSCRIPTION);
        }

        if (bDebugMode) {
            DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
        } else {
            LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

            if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {

                printf("ERROR - Can't create %ws: %ws\n",
                        SubscriptionDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
        }

        FreeMod(&Mod);

        //
        // If this member is to be added using the Win2K DFS naming convention
        // then we need to create a few more subscription containers.  E.G.
        //
        // (cn=software$|packages,                              frs subscriber    (DFS junction)
        //    cn=software$,                                     frs subscription  (DFS Root)
        //      cn=56421f6a-9edd-4098-a101-bf2e161e4572,        frs subscription  (domain guid for DFS Guid)
        //        cn=dfs volumes,                               frs subscription
        //          cn=ntfrs subscriptions,                     frs subscription
        //            cn=dfs-srv-01,                            computer object
        //              ou=multifunction terminal servers,
        //                ou=domain controllers,
        //                  dc=cps,
        //                    dc=gov,
        //                      dc=uk)
        //
        //
        if (bDFSNaming) {

            SaveDn = SubscriptionDn;
            SubscriptionDn = ExtendDn(SubscriptionDn, L"DFS VOLUMES");
            FREE(SaveDn);

            // ATTR_DN
            DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
            AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

            if (bDebugMode) {
                DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
            } else {
                LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

                if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {
                    printf("ERROR - Can't create %ws: %ws\n", SubscriptionDn, ldap_err2string(LStatus));
                    Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
            }

            FreeMod(&Mod);

            //
            // Add subscription container with name of Domain Guid.
            //
            SaveDn = SubscriptionDn;
            SubscriptionDn = ExtendDn(SubscriptionDn, DomainGuidStr);
            FREE(SaveDn);

            // ATTR_DN
            DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
            AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

            if (bDebugMode) {
                DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
            } else {
                LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

                if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {
                    printf("ERROR - Can't create %ws: %ws\n", SubscriptionDn, ldap_err2string(LStatus));
                    Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
            }

            FreeMod(&Mod);

            if (wcslen(DFSRoot) > 0) {
                //
                // Add subscription container with name of DFS Root.
                //
                SaveDn = SubscriptionDn;
                SubscriptionDn = ExtendDn(SubscriptionDn, DFSRoot);
                FREE(SaveDn);

                // ATTR_DN
                DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
                AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

                if (bDebugMode) {
                    DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
                } else {
                    LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

                    if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {
                        printf("ERROR - Can't create %ws: %ws\n", SubscriptionDn, ldap_err2string(LStatus));
                        Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                        goto CLEANUP;
                    }
                }

                FreeMod(&Mod);

                if (wcslen(DFSJunction) > 0) {
                    //
                    // Add subscription container with name of DFS Junction.
                    //
                    SaveDn = SubscriptionDn;
                    SubscriptionDn = ExtendDn(SubscriptionDn, DFSJunction);
                    FREE(SaveDn);

                    // ATTR_DN
                    DPRINT1("SubscriptionDn:%ws\n", SubscriptionDn);
                    AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);

                    if (bDebugMode) {
                        DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriptionDn);
                    } else {
                        LStatus = ldap_add_s(pLdap, SubscriptionDn, Mod);

                        if ((LStatus != LDAP_ALREADY_EXISTS) && (LStatus != LDAP_SUCCESS)) {
                            printf("ERROR - Can't create %ws: %ws\n", SubscriptionDn, ldap_err2string(LStatus));
                            Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                            goto CLEANUP;
                        }
                    }

                    FreeMod(&Mod);
                }
            }
        }

        //
        // Now construct the subscriber object.
        //
        SubscriberDn = ExtendDn(SubscriptionDn, ReplicaSetName);

        // ATTR_DN
        DPRINT1("SubscriberDn:%ws\n", SubscriberDn);
        AddMod(ATTR_CLASS, ATTR_SUBSCRIBER, &Mod);

        // ATTR_MEMBER_REF
        AddMod(ATTR_MEMBER_REF, MemberDn, &Mod);
        DPRINT1("    FrsMemberReference:%ws\n", MemberDn);

        // ATTR_REPLICA_ROOT
        AddMod(ATTR_REPLICA_ROOT, RootPath, &Mod);
        DPRINT1("    FrsRootPath:%ws\n", RootPath);

        // ATTR_REPLICA_STAGE
        AddMod(ATTR_REPLICA_STAGE, StagePath, &Mod);
        DPRINT1("    FrsStagePath:%ws\n", StagePath);

        if (bDebugMode) {
            DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", SubscriberDn);
        } else {
            LStatus = ldap_add_s(pLdap, SubscriberDn, Mod);

            if ((LStatus == LDAP_CONSTRAINT_VIOLATION) && RefDCName != NULL) {
                //
                // prepare the server hint. Needed in case the member object
                // is just created on another DC than the one on which the
                // subscriber is being created.
                //
                LDAPControl   simpleControl;
                PLDAPControl  controlArray[2];
                INT           rc;
                BERVAL*       pBerVal = NULL;
                BerElement*   pBer;

                pBer = ber_alloc_t(LBER_USE_DER);
                if (!pBer)
                {
                    Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                DPRINT1("Sending binding DC Name %ws\n",RefDCName);
                rc = ber_printf(pBer,"{io}", 0, RefDCName, wcslen(RefDCName) * sizeof(WCHAR));
                if ( rc == -1 ) {
                    Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                rc = ber_flatten(pBer, &pBerVal);
                if (rc == -1)
                {
                    Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
                    goto CLEANUP;
                }
                ber_free(pBer,1);

                controlArray[0] = &simpleControl;
                controlArray[1] = NULL;

            //    simpleControl.ldctl_oid = LDAP_SERVER_GC_VERIFY_NAME_OID_W;
                simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
                simpleControl.ldctl_iscritical = TRUE;
                simpleControl.ldctl_value = *pBerVal;

                LStatus = ldap_add_ext_s(pLdap,
                                         SubscriberDn,
                                         Mod,
                                         (PLDAPControl *)&controlArray, //ServerControls,
                                         NULL                           //ClientControls,
                                         );
            }

            if (LStatus == LDAP_ALREADY_EXISTS) {
                //
                // If the object already exists then convert the create to an update.
                // This is to allow the user to run the data file with creates twice without
                // generating errors but only fixing the objects that have changed.
                //
                Status = UpdateSubscriber(SubscriberDn, MemberDn, RootPath, StagePath);

            } else if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't create %ws: %ws\n",
                        SubscriberDn, ldap_err2string(LStatus));
                Status = MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED;
            }
        }
    }

    LdapSearchClose(&FrsSearchContext);


CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(SubscriberDn);
    FREE(SubscriptionDn);
    FREE(SearchFilter);
    FREE(LocalComputerDn);
    FREE(DFSRoot);
    return Status;
}

DWORD
DeleteReplicaMember(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn
    )
/*++
Routine Description:
     Delete the replica member.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          MemberCn            = NULL;
    PWCHAR          ComputerRef         = NULL;
    PWCHAR          Attrs[5];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          SearchFilter        = NULL;
    DWORD           NoOfMembers;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    MK_ATTRS_4(Attrs, ATTR_DN, ATTR_CN, ATTR_COMPUTER_REF, ATTR_SERVER_REF);

    SearchFilter = (PWCHAR) malloc((((ComputerDn != NULL)?wcslen(ComputerDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", MemberName, L")" , CLASS_MEMBER, L")");
    } else if (ComputerDn != NULL){

        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");
    } else {
        wcscpy(SearchFilter, CLASS_MEMBER);
    }

    if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_MEMBER_DELETE_FAILED;
        goto CLEANUP;
    }

    NoOfMembers = FrsSearchContext.EntriesInPage;

    if ((NoOfMembers > 1) && (bAffectAll != TRUE)) {
        DPRINT0("Duplicate members found. Deleting all.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_MEMBER_DUPS_FOUND_DELETE;
        goto CLEANUP;
    }

    if (NoOfMembers != 0) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
             LdapEntry != NULL;
             LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

            MemberDn = FindValue(LdapEntry, ATTR_DN);
            MemberCn = FindValue(LdapEntry, ATTR_CN);
            ComputerRef = FindValue(LdapEntry, ATTR_COMPUTER_REF);

            //
            // If asked to delete the corresponding subscriber then do that first.
            //
            if (bDelSubscriber && ((ComputerRef != NULL) || (ComputerDn != NULL))) {
                Status = DeleteSubscriber(NTFRSSettingsDn, ReplicaSetName,
                                          MemberCn,
                                          (ComputerRef != NULL)?ComputerRef:ComputerDn);
                if (Status != MKDSOE_SUCCESS) {
                    LdapSearchClose(&FrsSearchContext);
                    goto CLEANUP;
                }
            }

            DPRINT1("Deleting Dn:%ws\n", MemberDn);
            if (bDebugMode) {
                DPRINT1("LStatus = ldap_delete_s(pLdap, %ws);\n", MemberDn);
            } else {
                LStatus = ldap_delete_s(pLdap, MemberDn);
                if (LStatus != LDAP_SUCCESS) {
                    DPRINT2("ERROR - Can't delete %ws: %ws\n",
                            MemberDn, ldap_err2string(LStatus));
                    Status = MKDSOE_MEMBER_DELETE_FAILED;
                }
            }
            FREE(MemberDn);
            FREE(MemberCn);
            FREE(ComputerRef);
        }
    } else {
        DPRINT0("Warning deleting; member not found.\n");
        Status = MKDSOE_MEMBER_NOT_FOUND_DELETE;
    }

    LdapSearchClose(&FrsSearchContext);

CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(MemberCn);
    FREE(ComputerRef);
    FREE(SearchFilter);
    return Status;
}

DWORD
UpdateReplicaMember(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn,
    PWCHAR      ServerRef,
    PWCHAR      RefDCName
    )
/*++
Routine Description:
     Update the replica member parameters.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;
    PWCHAR          Attrs[4];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          SearchFilter        = NULL;
    PWCHAR          CurComputerRef      = NULL;
    PWCHAR          CurServerRef        = NULL;
    DWORD           NoOfMembers;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_3(Attrs, ATTR_DN, ATTR_COMPUTER_REF, ATTR_SERVER_REF);

    SearchFilter = (PWCHAR) malloc((((ComputerDn != NULL)?wcslen(ComputerDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    if (MemberName != NULL) {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", MemberName, L")" , CLASS_MEMBER, L")");
    } else {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_COMPUTER_REF, L"=", ComputerDn, L")" , CLASS_MEMBER, L")");
    }

    if (!LdapSearchInit(pLdap, ReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_MEMBER_OBJ_UPDATE_FAILED;
        goto CLEANUP;
    }

    NoOfMembers = FrsSearchContext.EntriesInPage;

    if (NoOfMembers == 0) {
        DPRINT0("Error updating; member not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_MEMBER_NOT_FOUND_UPDATE;
        goto CLEANUP;
    }

    if (NoOfMembers > 1) {
        DPRINT0("Error updating; duplicate members found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_MEMBER_DUPS_FOUND_UPDATE;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        MemberDn = FindValue(LdapEntry, ATTR_DN);
        CurComputerRef = FindValue(LdapEntry, ATTR_COMPUTER_REF);
        CurServerRef = FindValue(LdapEntry, ATTR_SERVER_REF);

    }

    LdapSearchClose(&FrsSearchContext);

    DPRINT1("MemberDn:%ws\n", MemberDn);

    // Check ATTR_COMPUTER_REF
    // if a ref is supplied then make sure it is same as the current ref.
    // if a ref is not supplied then leave it as it is.
    if (ComputerDn != NULL) {
        if ((CurComputerRef == NULL) ||
            ((CurComputerRef != NULL) && wcscmp(ComputerDn, CurComputerRef))) {
            AddMod(ATTR_COMPUTER_REF, ComputerDn, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsComputerReference:%ws\n", ComputerDn);
        }
    }

    // Check ATTR_SERVER_REF
    // if a ref is supplied then make sure it is same as the current ref.
    // if a ref is not supplied then leave it as it is.
    if (ServerRef != NULL) {
        if ((CurServerRef == NULL) ||
            ((CurServerRef != NULL) && wcscmp(ServerRef, CurServerRef))) {
            AddMod(ATTR_SERVER_REF, ServerRef, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New ServerReference:%ws\n", ServerRef);
        }
    }


    if (bNeedsUpdate) {
        if (bDebugMode) {
            DPRINT1("LStatus = ldap_modify_s(pLdap, %ws, Mod);\n", MemberDn);
        } else {
            LStatus = ldap_modify_s(pLdap, MemberDn, Mod);

            if ((LStatus == LDAP_CONSTRAINT_VIOLATION) && RefDCName != NULL) {
                //
                // prepare the server hint. Needed in case the member object
                // is just created on another DC than the one on which the
                // subscriber is being created.
                //
                LDAPControl   simpleControl;
                PLDAPControl  controlArray[2];
                INT           rc;
                BERVAL*       pBerVal = NULL;
                BerElement*   pBer;

                pBer = ber_alloc_t(LBER_USE_DER);
                if (!pBer)
                {
                    Status = MKDSOE_MEMBER_OBJ_UPDATE_FAILED;
                    goto CLEANUP;
                }
                DPRINT1("Sending binding DC Name %ws\n",RefDCName);
                rc = ber_printf(pBer,"{io}", 0, RefDCName, wcslen(RefDCName) * sizeof(WCHAR));
                if ( rc == -1 ) {
                    Status = MKDSOE_MEMBER_OBJ_UPDATE_FAILED;
                    goto CLEANUP;
                }
                rc = ber_flatten(pBer, &pBerVal);
                if (rc == -1)
                {
                    Status = MKDSOE_MEMBER_OBJ_UPDATE_FAILED;
                    goto CLEANUP;
                }
                ber_free(pBer,1);

                controlArray[0] = &simpleControl;
                controlArray[1] = NULL;

            //    simpleControl.ldctl_oid = LDAP_SERVER_GC_VERIFY_NAME_OID_W;
                simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
                simpleControl.ldctl_iscritical = TRUE;
                simpleControl.ldctl_value = *pBerVal;

                LStatus = ldap_modify_ext_s(pLdap,
                                            MemberDn,
                                            Mod,
                                            (PLDAPControl *)&controlArray, //ServerControls,
                                            NULL                           //ClientControls,
                                            );
            }

            if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't update %ws: %ws\n",
                        MemberDn, ldap_err2string(LStatus));
                Status = MKDSOE_MEMBER_OBJ_UPDATE_FAILED;
            }
        }

    } else {
        DPRINT0("No update required\n");
    }


    if (bMakeMePrimary && (Status == MKDSOE_SUCCESS)) {
        //
        // Update the primary member attribute on the replica set object to
        // reference this member if /makemeprimary is set.
        //
            Status = UpdateReplicaSet(NTFRSSettingsDn, ReplicaSetName,
                                      NULL, NULL, NULL, MemberName, NULL);
    }

CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    FREE(SearchFilter);
    FREE(CurComputerRef);
    FREE(CurServerRef);
    return Status;
}

DWORD
CreateNewReplicaMember(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      MemberName,
    PWCHAR      ComputerDn,
    PWCHAR      ServerRef,
    PWCHAR      RefDCName
    )
/*++
Routine Description:
     Create a new replica member.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          MemberDn            = NULL;

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    MemberDn = ExtendDn(ReplicaSetDn, MemberName);

    // ATTR_DN
    DPRINT1("MemberDn:%ws\n", MemberDn);
    AddMod(ATTR_CLASS, ATTR_MEMBER, &Mod);

    // ATTR_COMPUTER_REF
    if (ComputerDn != NULL) {
        AddMod(ATTR_COMPUTER_REF, ComputerDn, &Mod);
        DPRINT1("    FrsComputerReference:%ws\n", ComputerDn);
    }

    // ATTR_SERVER_REF
    if (ServerRef != NULL) {
        AddMod(ATTR_SERVER_REF, ServerRef, &Mod);
        DPRINT1("    ServerReference:%ws\n", ServerRef);
    }

    if (bDebugMode) {
        DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", MemberDn);
    } else {
        LStatus = ldap_add_s(pLdap, MemberDn, Mod);

        if ((LStatus == LDAP_CONSTRAINT_VIOLATION) && RefDCName != NULL) {
            //
            // prepare the server hint. Needed in case the member object
            // is just created on another DC than the one on which the
            // subscriber is being created.
            //
            LDAPControl   simpleControl;
            PLDAPControl  controlArray[2];
            INT           rc;
            BERVAL*       pBerVal = NULL;
            BerElement*   pBer;

            pBer = ber_alloc_t(LBER_USE_DER);
            if (!pBer) {
                Status = MKDSOE_MEMBER_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
            DPRINT1("Sending binding DC Name %ws\n",RefDCName);
            rc = ber_printf(pBer,"{io}", 0, RefDCName, wcslen(RefDCName) * sizeof(WCHAR));
            if ( rc == -1 ) {
                Status = MKDSOE_MEMBER_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
            rc = ber_flatten(pBer, &pBerVal);
            if (rc == -1) {
                Status = MKDSOE_MEMBER_OBJ_CRE_FAILED;
                goto CLEANUP;
            }
            ber_free(pBer,1);

            controlArray[0] = &simpleControl;
            controlArray[1] = NULL;

        //    simpleControl.ldctl_oid = LDAP_SERVER_GC_VERIFY_NAME_OID_W;
            simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
            simpleControl.ldctl_iscritical = TRUE;
            simpleControl.ldctl_value = *pBerVal;

            LStatus = ldap_add_ext_s(pLdap,
                                     MemberDn,
                                     Mod,
                                     (PLDAPControl *)&controlArray, //ServerControls,
                                     NULL                           //ClientControls,
                                     );
        }

        if (LStatus == LDAP_ALREADY_EXISTS) {
            //
            // If the object already exists then convert the create to an update.
            // This is to allow the user to run the data file with creates twice without
            // generating errors but only fixing the objects that have changed.
            //
            Status = UpdateReplicaMember(NTFRSSettingsDn,
                                         ReplicaSetName,
                                         MemberName,
                                         ComputerDn,
                                         ServerRef,
                                         RefDCName);

        } else if (LStatus != LDAP_SUCCESS) {
            DPRINT2("ERROR - Can't create %ws: %ws\n", MemberDn, ldap_err2string(LStatus));
            Status = MKDSOE_MEMBER_OBJ_CRE_FAILED;

        } else if (bMakeMePrimary) {
            //
            // Update the primary member attribute on the replica set object to
            // reference this member if /makemeprimary is set.
            //
                Status = UpdateReplicaSet(NTFRSSettingsDn, ReplicaSetName,
                                          NULL, NULL, NULL, MemberName, NULL);
            }
    }



CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(MemberDn);
    return Status;
}

DWORD
DeleteReplicaSet(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName
    )
/*++
Routine Description:
     delete replica set.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          Attrs[2];
    PLDAPMessage    LdapEntry           = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    DWORD           NoOfSets;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_1(Attrs, ATTR_DN);

    WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", ReplicaSetName, L")" , CLASS_NTFRS_REPLICA_SET, L")");

    if (!LdapSearchInit(pLdap, NTFRSSettingsDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SET_DELETE_FAILED;
        goto CLEANUP;
    }

    NoOfSets = FrsSearchContext.EntriesInPage;

    if (NoOfSets == 0) {
        DPRINT0("Error deleting; connection not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SET_NOT_FOUND_DELETE;
        goto CLEANUP;
    }

    if (NoOfSets > 1) {
        DPRINT0("Error deleting; duplicate sets found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SET_DUPS_FOUND_DELETE;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        ReplicaSetDn = FindValue(LdapEntry, ATTR_DN);

        DPRINT1("Deleting Dn:%ws\n", ReplicaSetDn);
        if (bDebugMode) {
            DPRINT1("LStatus = ldap_delete_s(pLdap, %ws);\n", ReplicaSetDn);
        } else {
            LStatus = ldap_delete_s(pLdap, ReplicaSetDn);
            if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't delete %ws: %ws\n",
                        ReplicaSetDn, ldap_err2string(LStatus));
                Status = MKDSOE_SET_DELETE_FAILED;
            }
        }
    }

    LdapSearchClose(&FrsSearchContext);

CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    return Status;
}

DWORD
UpdateReplicaSet(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      ReplicaSetType,
    PWCHAR      FileFilter,
    PWCHAR      DirectoryFilter,
    PWCHAR      PrimaryMember,
    PBYTE       pSchedule
    )
/*++
Routine Description:
     Update the replica set parameters.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          Attrs[7];
    PLDAPMessage    LdapEntry           = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    PWCHAR          CurSetType          = NULL;
    PWCHAR          CurFileFilter       = NULL;
    PWCHAR          CurDirectoryFilter  = NULL;
    PWCHAR          CurPrimaryMember    = NULL;
    PWCHAR          PrimaryMemberDn     = NULL;
    DWORD           NoOfSets;
    PSCHEDULE       Schedule            = NULL;
    DWORD           ScheduleLen;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    MK_ATTRS_6(Attrs, ATTR_DN, ATTR_SET_TYPE, ATTR_FILE_FILTER, ATTR_DIRECTORY_FILTER, ATTR_SCHEDULE, ATTR_PRIMARY_MEMBER);

    WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", ReplicaSetName, L")" , CLASS_NTFRS_REPLICA_SET, L")");

    if (!LdapSearchInit(pLdap, NTFRSSettingsDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SET_OBJ_UPDATE_FAILED;
        goto CLEANUP;
    }

    NoOfSets = FrsSearchContext.EntriesInPage;

    if (NoOfSets == 0) {
        DPRINT0("Error updating; connection not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SET_NOT_FOUND_UPDATE;
        goto CLEANUP;
    }

    if (NoOfSets > 1) {
        DPRINT0("Error updating; duplicate connections found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SET_DUPS_FOUND_UPDATE;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        ReplicaSetDn       = FindValue(LdapEntry, ATTR_DN);
        CurSetType         = FindValue(LdapEntry, ATTR_SET_TYPE);
        CurFileFilter      = FindValue(LdapEntry, ATTR_FILE_FILTER);
        CurDirectoryFilter = FindValue(LdapEntry, ATTR_DIRECTORY_FILTER);
        CurPrimaryMember   = FindValue(LdapEntry, ATTR_PRIMARY_MEMBER);
        FindBerValue(LdapEntry, ATTR_SCHEDULE, &ScheduleLen, (VOID **)&Schedule);
    }

    LdapSearchClose(&FrsSearchContext);

    DPRINT1("ReplicaSetDn:%ws\n", ReplicaSetDn);

    // Check ATTR_SET_TYPE
    // if a type is supplied then make sure it is same as the current type.
    // if a type is not supplied then leave it as it is.
    if (ReplicaSetType != NULL) {
        if ((CurSetType == NULL) ||
            ((CurSetType != NULL) && wcscmp(ReplicaSetType, CurSetType))) {
            AddMod(ATTR_SET_TYPE, ReplicaSetType, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsReplicaSetType:%ws\n", ReplicaSetType);
        }
    }

    // Check ATTR_FILE_FILTER
    // if a filter is supplied then make sure it is same as the current filter.
    // if a filter is not supplied then leave it as it is.
    if (FileFilter != NULL) {
        if ((CurFileFilter == NULL) ||
            ((CurFileFilter != NULL) && wcscmp(FileFilter, CurFileFilter))) {
            AddMod(ATTR_FILE_FILTER, FileFilter, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsFileFilter:%ws\n", FileFilter);
        }
    }

    // Check ATTR_DIRECTORY_FILTER
    // if a filter is supplied then make sure it is same as the current filter.
    // if a filter is not supplied then leave it as it is.
    if (DirectoryFilter != NULL) {
        if ((CurDirectoryFilter == NULL) ||
            ((CurDirectoryFilter != NULL) && wcscmp(DirectoryFilter, CurDirectoryFilter))) {
            AddMod(ATTR_DIRECTORY_FILTER, DirectoryFilter, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsDirectoryFilter:%ws\n", DirectoryFilter);
        }
    }

    // Check ATTR_PRIMARY_MEMBER
    // if a PrimaryMember is supplied then make sure it is same as the current PrimaryMember.
    // if a PrimaryMember is not supplied then leave it as it is.
    if (PrimaryMember != NULL) {
        PrimaryMemberDn = ExtendDn(ReplicaSetDn, PrimaryMember);
        if ((CurPrimaryMember == NULL) ||
            ((CurPrimaryMember != NULL) && wcscmp(PrimaryMemberDn, CurPrimaryMember))) {
            AddMod(ATTR_PRIMARY_MEMBER, PrimaryMemberDn, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT1("    New FrsPrimaryMember:%ws\n", PrimaryMemberDn);
        }
    }

    // Check ATTR_SCHEDULE
    if (pSchedule != NULL) {
        if ((Schedule == NULL) ||
            (FRST_SIZE_OF_SCHEDULE != ScheduleLen) ||
            (memcmp(Schedule, pSchedule, FRST_SIZE_OF_SCHEDULE))) {
            bNeedsUpdate = TRUE;
            AddBerMod(ATTR_SCHEDULE,(PCHAR)pSchedule,FRST_SIZE_OF_SCHEDULE,&Mod);

            DPRINT0("    New schedule:\n");
            PrintSchedule((PSCHEDULE)pSchedule, 0x0F);
        }
    }

    if (bNeedsUpdate) {
        if (bDebugMode) {
            DPRINT1("LStatus = ldap_modify_s(pLdap, %ws, Mod);\n", ReplicaSetDn);
        } else {
            LStatus = ldap_modify_s(pLdap, ReplicaSetDn, Mod);
            if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't update %ws: %ws\n",
                        ReplicaSetDn, ldap_err2string(LStatus));
                Status = MKDSOE_SET_OBJ_UPDATE_FAILED;
            }
        }

    } else {
        DPRINT0("No update required\n");
    }

CLEANUP:

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(PrimaryMemberDn);
    FREE(CurSetType);
    FREE(CurFileFilter);
    FREE(CurDirectoryFilter);
    FREE(CurPrimaryMember);
    FREE(Schedule);
    return Status;
}

DWORD
CreateNewReplicaSet(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName,
    PWCHAR      ReplicaSetType,
    PWCHAR      FileFilter,
    PWCHAR      DirectoryFilter,
    PWCHAR      PrimaryMember,
    PBYTE       pSchedule
    )
/*++
Routine Description:
     Create a new replica Set.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          ReplicaSetDn        = NULL;
    PWCHAR          PrimaryMemberDn     = NULL;
    UINT            i;

    ReplicaSetDn = ExtendDn(NTFRSSettingsDn, ReplicaSetName);

    // ATTR_DN
    DPRINT1("ReplicaSetDn:%ws\n", ReplicaSetDn);
    AddMod(ATTR_CLASS, ATTR_REPLICA_SET, &Mod);

    // ATTR_SET_TYPE
    AddMod(ATTR_SET_TYPE, ReplicaSetType, &Mod);
    DPRINT1("    FrsReplicaSetType:%ws\n", ReplicaSetType);

    // ATTR_FILE_FILTER
    if (FileFilter != NULL) {
        AddMod(ATTR_FILE_FILTER, FileFilter, &Mod);
        DPRINT1("    FrsFileFilter:%ws\n", FileFilter);
    }

    // ATTR_DIRECTORY_FILTER
    if (DirectoryFilter != NULL) {
        AddMod(ATTR_DIRECTORY_FILTER, DirectoryFilter, &Mod);
        DPRINT1("    FrsDirectoryFilter:%ws\n", DirectoryFilter);
    }

    // ATTR_PRIMARY_MEMBER
    if (PrimaryMember != NULL) {
        PrimaryMemberDn = ExtendDn(ReplicaSetDn, PrimaryMember);
        AddMod(ATTR_PRIMARY_MEMBER, PrimaryMemberDn, &Mod);
        DPRINT1("    FrsPrimaryMemberr:%ws\n", PrimaryMemberDn);
    }

    if (pSchedule != NULL) {
        AddBerMod(ATTR_SCHEDULE,(PCHAR)pSchedule,FRST_SIZE_OF_SCHEDULE,&Mod);

        PrintSchedule((PSCHEDULE)pSchedule, 0x0F);
    }

    if (bDebugMode) {
        DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", ReplicaSetDn);
    } else {
        LStatus = ldap_add_s(pLdap, ReplicaSetDn, Mod);

        if (LStatus == LDAP_ALREADY_EXISTS) {
            //
            // If the object already exists then convert the create to an update.
            // This is to allow the user to run the data file with creates twice without
            // generating errors but only fixing the objects that have changed.
            //
            Status = UpdateReplicaSet(NTFRSSettingsDn,
                                      ReplicaSetName,
                                      ReplicaSetType,
                                      FileFilter,
                                      DirectoryFilter,
                                      PrimaryMember,
                                      pSchedule);

        } else if (LStatus != LDAP_SUCCESS) {
            DPRINT2("ERROR - Can't create %ws: %ws\n",
                    ReplicaSetDn, ldap_err2string(LStatus));
            Status = MKDSOE_SET_OBJ_CRE_FAILED;
        }
    }

    FreeMod(&Mod);
    FREE(ReplicaSetDn);
    FREE(PrimaryMemberDn);
    return Status;
}

VOID
PrintScheduleGrid(
    PUCHAR    ScheduleData,
    DWORD     Mask
    )
/*++
Routine Description:
    Print the schedule grid.

Arguments:
    Schedule
    Mask for each byte.
Return Value:
    NONE
--*/
{
    DWORD  Day, Hour;

    for (Day = 0; Day < 7; ++Day) {
        printf("        Day %1d: ",Day + 1);
        for (Hour = 0; Hour < 24; ++Hour) {
            printf("%1x", *(ScheduleData + (Day * 24) + Hour) & Mask);
        }
        printf("\n");
    }
}



VOID
PrintSchedule(
    PSCHEDULE Schedule,
    DWORD     Mask
    )
/*++
Routine Description:
    Print the schedule.

Arguments:
    Schedule
    Mask for each byte.
Return Value:
    NONE
--*/
{
    PUCHAR          ScheduleData;
    DWORD           i;

    if (bVerboseMode) {
        printf("    schedule:\n");
        for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
            ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
            if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
                continue;
            }
            PrintScheduleGrid(ScheduleData, Mask);
        }
    }
}

DWORD
DumpSubscribers(
    PWCHAR      ComputerDn,
    PWCHAR      MemberDn
    )
/*++
Routine Description:
     Dump the frs member object.
Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          Attrs[5];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          Val                 = NULL;
    PWCHAR          SearchFilter        = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           NoOfSubscribers;

    MK_ATTRS_4(Attrs, ATTR_DN, ATTR_MEMBER_REF, ATTR_REPLICA_ROOT, ATTR_REPLICA_STAGE);

    SearchFilter = (PWCHAR) malloc((((MemberDn != NULL)?wcslen(MemberDn):0)
                                    + MAX_PATH)
                                   * sizeof(WCHAR));

    if (MemberDn != NULL) {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_MEMBER_REF, L"=", MemberDn, L")" , CLASS_SUBSCRIBER, L")");
    } else {
        wcscpy(SearchFilter, CLASS_SUBSCRIBER);
    }

    if (!LdapSearchInit(pLdap, ComputerDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SUBSCRIBER_DUMP_FAILED;
        goto CLEANUP;
    }

    NoOfSubscribers = FrsSearchContext.EntriesInPage;

    if (NoOfSubscribers == 0) {
        LdapSearchClose(&FrsSearchContext);
        if (MemberDn != NULL) {
            //
            // This error return only makes sense when we were asked to dump
            // a specific subscriber.
            //
            DPRINT0("Error dumping; subscriber not found.\n");
            Status = MKDSOE_SUBSCRIBER_NOT_FOUND_DUMP;
        }
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        // ATTR_DN
        Val = FindValue(LdapEntry, ATTR_DN);
        printf("\n    SubscriberDn:%ws\n", Val);
        FREE(Val);

        //
        // ATTR_CLASS
        // We know the class
        printf("        ObjectClass:nTFRSSubscriber\n");

        // ATTR_MEMBER_REF
        Val = FindValue(LdapEntry, ATTR_MEMBER_REF);
        printf("        FrsMemberReference:%ws\n", Val);
        FREE(Val);

        // ATTR_REPLICA_ROOT
        Val = FindValue(LdapEntry, ATTR_REPLICA_ROOT);
        printf("        FrsRootPath:%ws\n", Val);
        FREE(Val);

        // ATTR_REPLICA_STAGE
        Val = FindValue(LdapEntry, ATTR_REPLICA_STAGE);
        printf("        FrsStagingPath:%ws\n", Val);
        FREE(Val);

    }

    LdapSearchClose(&FrsSearchContext);

CLEANUP:

    FREE(SearchFilter);
    return Status;
}

DWORD
DumpReplicaMembers(
    PWCHAR      NTFRSReplicaSetDn,
    PWCHAR      MemberName
    )
/*++
Routine Description:
     Dump the frs member object.
Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          Attrs[4];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          Val                 = NULL;
    PWCHAR          ComputerRef         = NULL;
    PWCHAR          MemberDn            = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           NoOfMembers;

    MK_ATTRS_3(Attrs, ATTR_DN, ATTR_COMPUTER_REF, ATTR_SERVER_REF);

    if (MemberName != NULL) {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", MemberName, L")" , CLASS_MEMBER, L")");
    } else {
        wcscpy(SearchFilter, CLASS_MEMBER);
    }

    if (!LdapSearchInit(pLdap, NTFRSReplicaSetDn, LDAP_SCOPE_ONELEVEL, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_MEMBER_DUMP_FAILED;
        goto CLEANUP;
    }

    NoOfMembers = FrsSearchContext.EntriesInPage;

    if (NoOfMembers == 0) {
        LdapSearchClose(&FrsSearchContext);

        if (MemberName != NULL) {
            //
            // This error return only makes sense when we were asked to dump
            // a specific member object.
            //
            DPRINT0("Error dumping; member not found.\n");
            Status = MKDSOE_MEMBER_NOT_FOUND_DUMP;
        }
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        // ATTR_DN
        MemberDn = FindValue(LdapEntry, ATTR_DN);
        printf("\n    MemberDn:%ws\n", MemberDn);

        //
        // ATTR_CLASS
        // We know the class
        printf("        ObjectClass:nTFRSMember\n");

        // ATTR_COMPUTER_REF
        ComputerRef = FindValue(LdapEntry, ATTR_COMPUTER_REF);
        printf("        FrsComputerReference:%ws\n", ComputerRef);

        // ATTR_SERVER_REF
        Val = FindValue(LdapEntry, ATTR_SERVER_REF);
        printf("        ServerReference:%ws\n", Val);
        FREE(Val);

        if (bAffectAll && ComputerRef != NULL) {
            DumpSubscribers(ComputerRef, MemberDn);
        }

        FREE(ComputerRef);
        FREE(MemberDn);
    }

    LdapSearchClose(&FrsSearchContext);

CLEANUP:

    return Status;
}

DWORD
DumpReplicaSet(
    PWCHAR      NTFRSSettingsDn,
    PWCHAR      ReplicaSetName
    )
/*++
Routine Description:
     Dump the replica set object.
Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    DWORD           Status              = MKDSOE_SUCCESS;
    PWCHAR          Attrs[7];
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          Val                 = NULL;
    PWCHAR          ReplicaSetDn        = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           ReplicaSetType;
    DWORD           NoOfSets;
    DWORD           ScheduleLen;
    PSCHEDULE       Schedule            = NULL;
    BOOL            SaveVerbose;


    MK_ATTRS_6(Attrs, ATTR_DN, ATTR_SET_TYPE, ATTR_FILE_FILTER, ATTR_DIRECTORY_FILTER, ATTR_SCHEDULE, ATTR_PRIMARY_MEMBER);

    if (ReplicaSetName != NULL) {
        WCS_CAT7(SearchFilter, L"(&(", ATTR_CN, L"=", ReplicaSetName, L")" , CLASS_NTFRS_REPLICA_SET, L")");
    } else {
        wcscpy(SearchFilter, CLASS_NTFRS_REPLICA_SET);
    }

    if (!LdapSearchInit(pLdap, NTFRSSettingsDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                        Attrs, 0, &FrsSearchContext, FALSE)) {
        Status = MKDSOE_SET_DUMP_FAILED;
        goto CLEANUP;
    }

    NoOfSets = FrsSearchContext.EntriesInPage;

    if (NoOfSets == 0) {
        DPRINT0("Error dumping; replica set not found.\n");
        LdapSearchClose(&FrsSearchContext);
        Status = MKDSOE_SET_NOT_FOUND_DUMP;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

        // ATTR_DN
        ReplicaSetDn = FindValue(LdapEntry, ATTR_DN);
        printf("\nReplicaSetDn:%ws\n", ReplicaSetDn);

        //
        // ATTR_CLASS
        // We know the class
        printf("    ObjectClass:nTFRSReplicaSet\n");

        // ATTR_SET_TYPE
        Val = FindValue(LdapEntry, ATTR_SET_TYPE);
        ReplicaSetType = _wtoi(Val);
        printf("    FrsReplicaSetType:%ws ", Val);

        if (ReplicaSetType > MKDSOE_RSTYPE_MAX) {
            printf("[ Invalid Type ");
        } else {
            printf("[ %ws ", ReplicaSetTypeStr[ReplicaSetType]);
        }
        printf("]\n");
        FREE(Val);

        // ATTR_FILE_FILTER
        Val = FindValue(LdapEntry, ATTR_FILE_FILTER);
        printf("    FrsFileFilter:%ws\n", Val);
        FREE(Val);

        // ATTR_DIRECTORY_FILTER
        Val = FindValue(LdapEntry, ATTR_DIRECTORY_FILTER);
        printf("    FrsDirectoryFilter:%ws\n", Val);
        FREE(Val);

        // ATTR_PRIMARY_MEMBER
        Val = FindValue(LdapEntry, ATTR_PRIMARY_MEMBER);
        printf("    FrsPrimaryMember:%ws\n", Val);
        FREE(Val);

        // ATTR_SCHEDULE
        FindBerValue(LdapEntry, ATTR_SCHEDULE, &ScheduleLen, (VOID **)&Schedule);

        if (Schedule) {
            SaveVerbose = bVerboseMode;
            bVerboseMode = TRUE;
            PrintSchedule(Schedule, 0x0F);
            bVerboseMode = SaveVerbose;
            delete(Schedule);
        }

        //
        // Dump the members if asked.
        //
        if (bAffectAll) {
            DumpReplicaMembers(ReplicaSetDn, NULL);
        }
        FREE(ReplicaSetDn);
    }

    LdapSearchClose(&FrsSearchContext);

CLEANUP:

    return Status;
}

PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv =  new PWCHAR[argc + 1];
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = new WCHAR[strlen(argv[argc]) + 1];
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
    }
    return wideargv;
}



VOID
FreeArgv(
    DWORD Argc,
    PWCHAR *Argv
    )
/*++
Routine Description:
    Free the converted arguments.

Arguments:
    Argc    - No of arguments.
    Argv    - Converted arguments returned from ConvertArgv.

Return Value:
    None.
--*/
{

    while (Argc-- >= 1) {
        FREE(Argv[Argc]);
    }
    FREE(Argv);
}

VOID
Usage(
    PWCHAR *Argv
    )
/*++
Routine Description:
    Tell the user how to use the program.

Arguments:
    Argv Argument array.

Return Value:
    None
--*/
{
    printf("\n");
    printf("%-60s\n", "This tool creates, adds, updates, dumps, and deletes replica set, member, and subscriber objects.\n");
    printf("%-60s%ws /?\n", "Help", Argv[0]);
    printf("%-60s%ws /v\n", "Verbose mode.", Argv[0]);
    printf("%-60s%ws /debug\n", "Debug mode. No Writes to the DC.", Argv[0]);
    printf("%-60s%ws /dc\n", "Name of the DC to connect to.", Argv[0]);
    printf("%-60s%ws /ntfrssettingsdn\n", "Dn for the FRS settings container.", Argv[0]);
    printf("%-60s%ws /setname\n", "Name of the replica set.", Argv[0]);
    printf("%-60s%ws /settype\n", "Type of the replica set.", Argv[0]);
    printf("%-60s\n", "Sysvol         = 2");
    printf("%-60s\n", "Dfs            = 3");
    printf("%-60s\n\n", "Other          = 4");
    printf("%-60s%ws /filefilter\n", "Filter to use against files.e.g. *.bak,*.tmp", Argv[0]);
    printf("%-60s%ws /directoryfilter\n", "Filter to use against directories.", Argv[0]);
    printf("%-60s%ws /primarymember\n", "Name of primary member for initial replica set contents.", Argv[0]);
    printf("%-60s%ws /membername\n", "Name of the member.", Argv[0]);
    printf("%-60s\n", "If DFS naming conventions are desired, specify 'ComputerObjectGuid' for membername.");
    printf("%-60s%ws /dfsname\n", "Name of the dfs in the format <root name>|<junction name>.", Argv[0]);
    printf("%-60s\n", "Required if membername is 'ComputerObjectGuid'.");
    printf("%-60s%ws /computerdn\n", "Dn for the computer object.", Argv[0]);
    printf("%-60s%ws /computername\n", "NT4 style computer name. e.g. NTDEV\\SUDARCTEST$.", Argv[0]);
    printf("%-60s%ws /serverref\n", "Dn of NTDSSettings object for DCs.", Argv[0]);
    printf("%-60s%ws /rootpath\n", "Replica root path. Has to be absolute.", Argv[0]);
    printf("%-60s%ws /stagepath\n", "Replica staging path. Has to be absolute.", Argv[0]);
    printf("%-60s%ws /workingpath\n", "Replica working path. Has to be absolute. Only used if subscriptions obj created.", Argv[0]);
    printf("%-60s%ws /refdcname <dnsname>\n", "Reference DC to use while creating subscriber.", Argv[0]);
    printf("%-60s%ws /[create<object> update<object> del<object> dump]\n", "Operation to be performed.", Argv[0]);
    printf("%-60s%ws \n\n", "<object> can be one of [set member subscriber].", Argv[0]);
    printf("%-60s%ws /all\n", "Perform the operation on all the objects.", Argv[0]);
    printf("%-60s%ws \n\n", "/all only works with /dump and /del.", Argv[0]);
    printf("%-60s%ws /makemeprimary\n", "Make this member object the primary replica set member.", Argv[0]);
    printf("%-60s%ws \n\n", "Applies to member operations only.", Argv[0]);
    printf("%-60s%ws /schedule <Interval> <Stagger> <Offset>\n", "Schedule to create for the replica set.", Argv[0]);
    printf("%-60s%ws           <Interval>\n", "The desired interval between each sync with one source.", Argv[0]);
    printf("%-60s%ws                      <Stagger>\n", "Typically number of source DCs.", Argv[0]);
    printf("%-60s%ws                                <Offset>\n\n", "Typically the number of the source DC.", Argv[0]);
    printf("%-60s%ws /schedoverride\n", "File with 7x24 vector of schedule override data.", Argv[0]);
    printf("%-60s%ws /schedmask\n", "File with 7x24 vector of schedule mask off data.", Argv[0]);
    printf("%-60s\n", "SchedOverride and SchedMask data are formatted");
    printf("%-60s\n\n", "as 2 ascii hex digits for each schedule byte.");
    DPRINT0("\n");

    DPRINT0("mkdso.exe error return codes\n");
    DPRINT0("100 = Success\n");
    DPRINT0("101 = Invalid Arguments\n");
    DPRINT0("102 = Could not bind to the DC\n");
    DPRINT0("103 = Could not find 'NTFRS Settings' object.  Check the /settingsdn parameter\n");
    DPRINT0("104 = Error creating replica set\n");
    DPRINT0("105 = Error updating replica set\n");
    DPRINT0("106 = Error updating replica set; set not found\n");
    DPRINT0("107 = Error updating replica set; duplicate sets found\n");
    DPRINT0("108 = Error deleting replica set; duplicate sets found.\n");
    DPRINT0("109 = Error deleting replica set\n");
    DPRINT0("110 = Error deleting replica set; set not found\n");
    DPRINT0("111 = Deleting multiple sets\n");
    DPRINT0("112 = Error dumping replica set\n");
    DPRINT0("113 = Error dumping replica set; set not found\n");
    DPRINT0("114 = Dumping duplicate sets\n");
    DPRINT0("115 = Error creating replica member\n");
    DPRINT0("116 = Error updating replica member\n");
    DPRINT0("117 = Error updating replica member; member not found\n");
    DPRINT0("118 = Error updating replica member; duplicate members found\n");
    DPRINT0("119 = Error deleting member; duplicate subscribers found.\n");
    DPRINT0("120 = Error deleting replica member\n");
    DPRINT0("121 = Error deleting replica member; member not found\n");
    DPRINT0("122 = Deleting multiple members\n");
    DPRINT0("123 = Error dumping replica member\n");
    DPRINT0("124 = Error dumping replica member; member not found\n");
    DPRINT0("125 = Dumping duplicate members\n");
    DPRINT0("126 = Error creating subscriber\n");
    DPRINT0("127 = Error updating subscriber\n");
    DPRINT0("128 = Error updating subscriber; subscriber not found\n");
    DPRINT0("129 = Error updating subscriber; duplicate subscribers found\n");
    DPRINT0("130 = Error deleting subscriber\n");
    DPRINT0("131 = Error deleting subscriber; subscriber not found\n");
    DPRINT0("132 = Deleting multiple subscribers\n");
    DPRINT0("133 = Error deleting subscriber; duplicate subscribers found.\n");
    DPRINT0("134 = Error dumping subscriber\n");
    DPRINT0("135 = Error dumping subscriber; subscriber not found\n");
    DPRINT0("136 = Dumping duplicate subscribers\n");
    DPRINT0("\n");
    fflush(stdout);
}

DWORD __cdecl
main(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    Exits with 0 if everything went okay. Otherwise returns a error code.

    MKDSOE_SUCCESS                      "Success."
    MKDSOE_BAD_ARG                      "Invalid Arguments."
    MKDSOE_CANT_BIND                    "Could not bind to the DC."
    MKDSOE_NO_NTFRS_SETTINGS            "Could not find 'NTFRS Settings' object.  Check the /settingsdn parameter."
    MKDSOE_SET_OBJ_CRE_FAILED           "Error creating replica set."
    MKDSOE_SET_OBJ_UPDATE_FAILED        "Error updating replica set."
    MKDSOE_SET_NOT_FOUND_UPDATE         "Error updating replica set; set not found."
    MKDSOE_SET_DUPS_FOUND_UPDATE        "Error updating replica set; duplicate sets found."
    MKDSOE_SET_DUPS_FOUND_DELETE        "Error deleting replica set; duplicate sets found."
    MKDSOE_SET_DELETE_FAILED            "Error deleting replica set."
    MKDSOE_SET_NOT_FOUND_DELETE         "Error deleting replica set; set not found."
    MKDSOE_MULTIPLE_SETS_DELETED        "Deleting multiple sets."
    MKDSOE_SET_DUMP_FAILED              "Error dumping replica set."
    MKDSOE_SET_NOT_FOUND_DUMP           "Error dumping replica set; set not found."
    MKDSOE_MULTIPLE_SETS_DUMPED         "Dumping duplicate sets."
    MKDSOE_MEMBER_OBJ_CRE_FAILED        "Error creating replica member."
    MKDSOE_MEMBER_OBJ_UPDATE_FAILED     "Error updating replica member."
    MKDSOE_MEMBER_NOT_FOUND_UPDATE      "Error updating replica member; member not found."
    MKDSOE_MEMBER_DUPS_FOUND_UPDATE     "Error updating replica member; duplicate members found."
    MKDSOE_MEMBER_DUPS_FOUND_DELETE     "Error deleting member; duplicate subscribers found."
    MKDSOE_MEMBER_DELETE_FAILED         "Error deleting replica member."
    MKDSOE_MEMBER_NOT_FOUND_DELETE      "Error deleting replica member; member not found."
    MKDSOE_MULTIPLE_MEMBERS_DELETED     "Deleting multiple members."
    MKDSOE_MEMBER_DUMP_FAILED           "Error dumping replica member."
    MKDSOE_MEMBER_NOT_FOUND_DUMP        "Error dumping replica member; member not found."
    MKDSOE_MULTIPLE_MEMBERS_DUMPED      "Dumping duplicate members."
    MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED    "Error creating subscriber."
    MKDSOE_SUBSCRIBER_OBJ_UPDATE_FAILED "Error updating subscriber."
    MKDSOE_SUBSCRIBER_NOT_FOUND_UPDATE  "Error updating subscriber; subscriber not found."
    MKDSOE_SUBSCRIBER_DUPS_FOUND_UPDATE "Error updating subscriber; duplicate subscribers found."
    MKDSOE_SUBSCRIBER_DELETE_FAILED     "Error deleting subscriber."
    MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE  "Error deleting subscriber; subscriber not found."
    MKDSOE_MULTIPLE_SUBSCRIBERS_DELETED "Deleting multiple subscribers."
    MKDSOE_SUBSCRIBER_DUPS_FOUND_DELETE "Error deleting subscriber; duplicate subscribers found."
    MKDSOE_SUBSCRIBER_DUMP_FAILED       "Error dumping subscriber."
    MKDSOE_SUBSCRIBER_NOT_FOUND_DUMP    "Error dumping subscriber; subscriber not found."
    MKDSOE_MULTIPLE_SUBSCRIBERS_DUMPED  "Dumping duplicate subscribers."
--*/
{
    PWCHAR     *Argv;
    ULONG      i, j;
    ULONG      OptLen;
    DWORD      Status             = MKDSOE_SUCCESS;
    DWORD      WStatus            = ERROR_SUCCESS;
    PWCHAR     NTFRSSettingsDn    = NULL;
    PWCHAR     ReplicaSetName     = NULL;
    PWCHAR     ReplicaSetType     = NULL;
    PWCHAR     FileFilter         = NULL;
    PWCHAR     DirectoryFilter    = NULL;
    PWCHAR     PrimaryMember      = NULL;
    PBYTE      pSchedule          = NULL;
    DWORD      Interval           = 1;
    DWORD      Stagger            = 1;
    DWORD      Offset             = 0;
    DWORD      Vbar;
    PWCHAR     NT4ComputerName    = NULL;
    PWCHAR     ComputerDn         = NULL;
    PWCHAR     DomainName         = NULL;
    PWCHAR     MemberName         = NULL;
    PWCHAR     ServerRef          = NULL;
    PWCHAR     RootPath           = NULL;
    PWCHAR     StagePath          = NULL;
    PWCHAR     WorkingPath        = NULL;
    PWCHAR     RefDCName          = NULL;
    PWCHAR     *Values            = NULL;
    PWCHAR     Switch             = NULL;
    PWCHAR     pw;
    BOOL       ClassFound         = FALSE;

    DWORD      Commands           = 0;
    DS_NAME_RESULT  *Cracked      = NULL;
    HANDLE     hDs                = INVALID_HANDLE_VALUE;

    PLDAP_BERVAL   *BerValues     = NULL;
    GUID           *Guid          = NULL;

    PDOMAIN_CONTROLLER_INFO           pDCInfo = NULL;
    BOOL                              bRetry = FALSE;
    DWORD                             DcFlags;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer = NULL;


    Argv = ConvertArgv(argc, argv);

    if (argc <= 1) {
        Usage(Argv);
        Status = MKDSOE_SUCCESS;
        goto ARG_CLEANUP;
    }

    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        _wcslwr(Argv[i]);
        Switch = Argv[i];
        DPRINT1("   %20ws ", Switch);

        if ((*Switch != L'/') && (*Switch != L'-')) {
            Usage(Argv);
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
        ++Switch;   // jump over -

        if (OptLen == 2 && ArgMatch(Switch, L"v")) {
            bVerboseMode=TRUE;
            DPRINT1("   %20ws ", Switch);

        } else if (OptLen == 3 && ArgMatch(Switch, L"vs")) {
                bVerboseModeSearch=TRUE;
                DPRINT1("   %20ws ", Switch);

        } else if (OptLen == 2 && ArgMatch(Switch, L"?")) {
            Usage(Argv);
            Status = MKDSOE_SUCCESS;
            goto ARG_CLEANUP;

        } else if (OptLen == 6 && ArgMatch(Switch, L"debug")) {
            bDebugMode = TRUE;
            bVerboseMode=TRUE;

        } else if (OptLen == 3 && (i+1 < argc) && ArgMatch(Switch, L"dc")) {
            i += 1;
            DcName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(DcName, Argv[i]);
            DPRINT1("%ws", DcName);

        } else if (OptLen == 16 && (i+1 < argc) && ArgMatch(Switch, L"ntfrssettingsdn")) {
            i += 1;
            NTFRSSettingsDn = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(NTFRSSettingsDn, Argv[i]);
            DPRINT1("%ws", NTFRSSettingsDn);

        } else if (OptLen == 8 && (i+1 < argc) && ArgMatch(Switch, L"setname")) {
            i += 1;
            ReplicaSetName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ReplicaSetName, Argv[i]);
            DPRINT1("%ws", ReplicaSetName);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"computerdn")) {
            i += 1;
            ComputerDn = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ComputerDn, Argv[i]);
            DPRINT1("%ws", ComputerDn);

        } else if (OptLen == 13 && (i+1 < argc) && ArgMatch(Switch, L"computername")) {
            i += 1;
            NT4ComputerName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(NT4ComputerName, Argv[i]);
            DPRINT1("%ws", NT4ComputerName);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"membername")) {
            i += 1;
            MemberName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(MemberName, Argv[i]);
            DPRINT1("%ws", MemberName);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"membername")) {
            i += 1;
            MemberName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(MemberName, Argv[i]);
            DPRINT1("%ws", MemberName);

        } else if (OptLen == 8 && (i+1 < argc) && ArgMatch(Switch, L"dfsname")) {
            i += 1;
            DFSName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(DFSName, Argv[i]);
            DPRINT1("%ws", DFSName);
            bDFSNaming = TRUE;

        } else if (OptLen == 9 && (i+1 < argc) && ArgMatch(Switch, L"rootpath")) {
            i += 1;
            RootPath = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(RootPath, Argv[i]);
            DPRINT1("%ws", RootPath);

        } else if (OptLen == 10 && (i+1 < argc) && ArgMatch(Switch, L"stagepath")) {
            i += 1;
            StagePath = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(StagePath, Argv[i]);
            DPRINT1("%ws", StagePath);

        } else if (OptLen == 12 && (i+1 < argc) && ArgMatch(Switch, L"workingpath")) {
            i += 1;
            WorkingPath = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(WorkingPath, Argv[i]);
            DPRINT1("%ws", WorkingPath);

        } else if (OptLen == 10 && (i+1 < argc) && ArgMatch(Switch, L"refdcname")) {
            i += 1;
            RefDCName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(RefDCName, Argv[i]);
            DPRINT1("%ws", RefDCName);

        } else if (OptLen == 10 && ArgMatch(Switch, L"createset")) {
            bCreateSet = TRUE;
            ++Commands;

        } else if (OptLen == 10 && ArgMatch(Switch, L"updateset")) {
            bUpdateSet = TRUE;
            ++Commands;

        } else if (OptLen == 7 && ArgMatch(Switch, L"delset")) {
            bDelSet = TRUE;
            ++Commands;

        } else if (OptLen == 13 && ArgMatch(Switch, L"createmember")) {
            bCreateMember = TRUE;
            ++Commands;

        } else if (OptLen == 13 && ArgMatch(Switch, L"updatemember")) {
            bUpdateMember = TRUE;
            ++Commands;

        } else if (OptLen == 10 && ArgMatch(Switch, L"delmember")) {
            bDelMember = TRUE;
            ++Commands;

        } else if (OptLen == 17 && ArgMatch(Switch, L"createsubscriber")) {
            bCreateSubscriber = TRUE;
            ++Commands;

        } else if (OptLen == 17 && ArgMatch(Switch, L"updatesubscriber")) {
            bUpdateSubscriber = TRUE;
            ++Commands;

        } else if (OptLen == 14 && ArgMatch(Switch, L"delsubscriber")) {
            bDelSubscriber = TRUE;
            ++Commands;

        } else if (OptLen == 5 && ArgMatch(Switch, L"dump")) {
            bDump = TRUE;
            ++Commands;

        } else if (OptLen == 4 && ArgMatch(Switch, L"all")) {
            bAffectAll = TRUE;

        } else if (OptLen == 8 && (i+1 < argc) && ArgMatch(Switch, L"settype")) {
            i += 1;
            ReplicaSetType = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ReplicaSetType, Argv[i]);
            DPRINT1("%ws", ReplicaSetType);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"filefilter")) {
            i += 1;
            FileFilter = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(FileFilter, Argv[i]);
            DPRINT1("%ws", FileFilter);

        } else if (OptLen == 16 && (i+1 < argc) && ArgMatch(Switch, L"directoryfilter")) {
            i += 1;
            DirectoryFilter = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(DirectoryFilter, Argv[i]);
            DPRINT1("%ws", DirectoryFilter);

        } else if (OptLen == 14 && (i+1 < argc) && ArgMatch(Switch, L"primarymember")) {
            i += 1;
            PrimaryMember = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(PrimaryMember, Argv[i]);
            DPRINT1("%ws", PrimaryMember);

        } else if (OptLen == 14 && ArgMatch(Switch, L"makemeprimary")) {
            bMakeMePrimary = TRUE;

        } else if (OptLen == 9 && (i+3 < argc) && ArgMatch(Switch, L"schedule")) {

            bSchedule = TRUE;
            Interval = _wtoi(Argv[i+1]);
            Stagger = _wtoi(Argv[i+2]);
            Offset = _wtoi(Argv[i+3]);
            i+=3;

        } else if ((OptLen == 10) && (i+1 < argc) && ArgMatch(Switch, L"schedmask")) {

            SchedMask = ReadScheduleFile(Argv[i+1]);
            if (SchedMask == NULL) {
                FreeArgv(argc,Argv);
                return MKDSOE_BAD_ARG;
            } else {
                if (bVerboseMode) {
                    printf("    schedmask:\n");
                    PrintScheduleGrid(SchedMask, 0x0F);
                }
            }
            i+=1;

        } else if ((OptLen == 14) && (i+1 < argc) && ArgMatch(Switch, L"schedoverride")) {

            SchedOverride = ReadScheduleFile(Argv[i+1]);
            if (SchedOverride == NULL) {
                FreeArgv(argc,Argv);
                return MKDSOE_BAD_ARG;
            } else {
                if (bVerboseMode) {
                    printf("    schedoverride:\n");
                    PrintScheduleGrid(SchedOverride, 0x0F);
                }
            }
            i+=1;

        } else {
            Usage(Argv);
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }

        DPRINT0("\n");
    }

    //
    // Begin of verify command line parameters.
    //

    if (Commands != 1) {
        if ((Commands == 2) && bDelSubscriber  &&bDelMember) {
            //
            // The only time two commands are allowed is when /delsubscriber
            // is used with /delmember
            //
        } else {
            DPRINT0("INVALID ARG: Specify one and only one command except /delmember /delsubscriber.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
    }

    if (NTFRSSettingsDn == NULL) {
        DPRINT0("INVALID ARG: Missing parameter /ntfrssettingsdn.\n");
        Status = MKDSOE_BAD_ARG;
        goto ARG_CLEANUP;
    }

    if ((ReplicaSetName == NULL) && !(bDump && bAffectAll)) {
        DPRINT0("INVALID ARG: Missing parameter /setname.\n");
        Status = MKDSOE_BAD_ARG;
        goto ARG_CLEANUP;
    }

    if (bCreateSet && ReplicaSetType == NULL) {
        DPRINT0("INVALID ARG: Missing parameter /settype.\n");
        Status = MKDSOE_BAD_ARG;
        goto ARG_CLEANUP;
    }

    if (bCreateMember) {
        if (MemberName == NULL) {
            DPRINT0("INVALID ARG: Missing parameter /membername.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
        if (bDFSNaming) {
            if (DFSName == NULL) {
                DPRINT0("INVALID ARG: Missing parameter /dfsname.\n");
                Status = MKDSOE_BAD_ARG;
                goto ARG_CLEANUP;
            }
            Vbar = wcscspn(DFSName, L"|");
            if ((Vbar == wcslen(DFSName)) ||
                (Vbar == 0) ||
                ((wcslen(DFSName) - Vbar) < 2)) {
                //
                // No vertical bar found or root or junction parts are zero len.
                //
                DPRINT0("INVALID ARG: Member name must have v-bar with root and junction parts for DFS naming. /dfsname.\n");
                Status = MKDSOE_BAD_ARG;
                goto ARG_CLEANUP;
            }
        }
    }

    if (bMakeMePrimary && (bCreateSet || bUpdateSet || bDelSet || bDelMember)) {
        DPRINT0("INVALID ARG: /makemeprimary not allowed with /createset, /updateset, /delset, or /delmember.\n");
        Status = MKDSOE_BAD_ARG;
        goto ARG_CLEANUP;
    }

    if (bUpdateMember) {
        if ((MemberName == NULL) &&
            (ComputerDn == NULL) &&
            (NT4ComputerName == NULL)) {
            DPRINT0("INVALID ARG: Missing parameter /membername or /computerdn or /computername.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
    }

    if (bCreateSubscriber) {
        if ((MemberName == NULL) &&
            (ComputerDn == NULL) &&
            (NT4ComputerName == NULL)) {
            DPRINT0("INVALID ARG: Missing parameter /membername or /computerdn or /computername.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }

        if (RootPath == NULL) {
            DPRINT0("INVALID ARG: Missing parameter /rootpath.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }

        if (StagePath == NULL) {
            DPRINT0("INVALID ARG: Missing parameter /stagepath.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }

        if (bDFSNaming) {
            if (DFSName == NULL) {
                DPRINT0("INVALID ARG: Missing parameter /dfsname.\n");
                Status = MKDSOE_BAD_ARG;
                goto ARG_CLEANUP;
            }
            Vbar = wcscspn(DFSName, L"|");
            if ((Vbar == wcslen(DFSName)) ||
                (Vbar == 0) ||
                ((wcslen(DFSName) - Vbar) < 2)) {
                //
                // No vertical bar found or root or junction parts are zero len.
                //
                DPRINT0("INVALID ARG: Member name must have v-bar with root and junction parts for DFS naming. /dfsname.\n");
                Status = MKDSOE_BAD_ARG;
                goto ARG_CLEANUP;
            }
        }
    }

    if (bUpdateSubscriber) {
        if ((MemberName == NULL) &&
            (ComputerDn == NULL) &&
            (NT4ComputerName == NULL)) {
            DPRINT0("INVALID ARG: Missing parameter /membername or /computerdn or /computername.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
    }

    if (bDelMember) {
        if (!bAffectAll &&
            (MemberName == NULL) &&
            (ComputerDn == NULL) &&
            (NT4ComputerName == NULL)) {
            DPRINT0("INVALID ARG: Missing parameter /membername or /computerdn or /computername or /all.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
    }

    if (bDelSubscriber) {
        if (!bDelMember &&
            (MemberName == NULL) &&
            (ComputerDn == NULL) &&
            (NT4ComputerName == NULL)) {
            DPRINT0("INVALID ARG: Missing parameter /membername or /computerdn or /computername.\n");
            Status = MKDSOE_BAD_ARG;
            goto ARG_CLEANUP;
        }
    }

    //
    // End of verify command line parameters.
    //

    Status = BindToDC(DcName, &pLdap);

    //
    // Verify that the ntfrs settings DN exists and is actually a NTFRSSettings object.
    //
    i=0;
    ClassFound = FALSE;
    Values = GetValues(pLdap, NTFRSSettingsDn, ATTR_CLASS, TRUE);

    while (Values && Values[i]) {
        if (_wcsicmp(Values[i],ATTR_NTFRS_SETTINGS) == 0) {
            ClassFound = TRUE;
            break;
        }
        ++i;
    }
    LDAP_FREE_VALUES(Values);

    if (!ClassFound) {
        DPRINT0("INVALID ARG: Check parameter /ntfrssettingsdn.\n");
        Status = MKDSOE_NO_NTFRS_SETTINGS;
        goto CLEANUP;
    }

    //
    // Verify that the computer DN exists and is actually a computer object.
    //
    if (ComputerDn != NULL) {
        i=0;
        ClassFound = FALSE;
        Values = GetValues(pLdap, ComputerDn, ATTR_CLASS, TRUE);

        while (Values && Values[i]) {
            if ((_wcsicmp(Values[i],ATTR_COMPUTER)== 0)  ||
                (_wcsicmp(Values[i],ATTR_USER) == 0)) {

                ClassFound = TRUE;
                break;
            }
            ++i;
        }
        LDAP_FREE_VALUES(Values);

        if (!ClassFound) {
            DPRINT0("INVALID ARG: Check parameter /computerdn.\n");
            Status = MKDSOE_BAD_ARG;
            goto CLEANUP;
        }

    }

    if (bCreateSet) {
        if (bSchedule) {
            BuildSchedule(&pSchedule, Interval, Stagger, Offset);
            Status = CreateNewReplicaSet(NTFRSSettingsDn,ReplicaSetName,
                                         ReplicaSetType, FileFilter,
                                         DirectoryFilter, PrimaryMember, pSchedule);
        } else {
            Status = CreateNewReplicaSet(NTFRSSettingsDn,ReplicaSetName,
                                         ReplicaSetType, FileFilter,
                                         DirectoryFilter, PrimaryMember, NULL);
        }
    }

    if (bUpdateSet) {
        if (bSchedule) {
            BuildSchedule(&pSchedule, Interval, Stagger, Offset);
            Status = UpdateReplicaSet(NTFRSSettingsDn,ReplicaSetName,
                                         ReplicaSetType, FileFilter,
                                         DirectoryFilter, PrimaryMember, pSchedule);
        } else {
            Status = UpdateReplicaSet(NTFRSSettingsDn,ReplicaSetName,
                                         ReplicaSetType, FileFilter,
                                         DirectoryFilter, PrimaryMember, NULL);
        }
    }

    if (bCreateMember || bUpdateMember || bCreateSubscriber || bUpdateSubscriber ||
        bDelSubscriber || bDelMember) {

        //
        // Get the Coumputer Dn using the NT4 account name.
        //
        if ((ComputerDn == NULL) && (NT4ComputerName != NULL)) {

            if (hDs == INVALID_HANDLE_VALUE) {
                WStatus = DsBind(DcName, NULL, &hDs);
                if (WStatus != ERROR_SUCCESS) {
                    DPRINT2("ERROR: Can not bind to DC (%ws) %d\n", DcName, WStatus);
                    Status = MKDSOE_BAD_ARG;
                    goto CLEANUP;
                }
            }

            WStatus = DsCrackNames(hDs,                  // in   hDS,
                                   DS_NAME_NO_FLAGS,     // in   flags,
                                   DS_NT4_ACCOUNT_NAME,  // in   formatOffered,
                                   DS_FQDN_1779_NAME,    // in   formatDesired,
                                   1,                    // in   cNames,
                                   &NT4ComputerName,     // in   *rpNames,
                                   &Cracked);            // out  *ppResult

            if ((WStatus == ERROR_SUCCESS) &&
                Cracked && Cracked->cItems && Cracked->rItems &&
                (Cracked->rItems->status == DS_NAME_NO_ERROR)) {

                ComputerDn = FrsWcsDup(Cracked->rItems->pName);
                DsFreeNameResult(Cracked);
            } else {
                DPRINT1("ERROR: Can not crack computerDn %d\n", WStatus);
                Status = MKDSOE_BAD_ARG;
                goto CLEANUP;
            }
        }


        //

        bugbug ("we need the domain guid for the DFSRoot's Domain NC which may not be the same as the member")

        // Get the domain GUID for the domain containing the member.
        //
        if ((ComputerDn != NULL) && bCreateSubscriber) {
            if (hDs == INVALID_HANDLE_VALUE) {
                WStatus = DsBind(DcName, NULL, &hDs);
                if (WStatus != ERROR_SUCCESS) {
                    DPRINT2("ERROR: Can not bind to DC (%ws) %d\n", DcName, WStatus);
                    Status = MKDSOE_BAD_ARG;
                    goto CLEANUP;
                }
            }

            //
            // First get the DS_CANONICAL_NAME.
            // eg: engineering.widget.com/software/spencer katt
            // Domain-only version includes trailing '/'.
            //
            WStatus = DsCrackNames(hDs,                  // in   hDS,
                                   DS_NAME_NO_FLAGS,     // in   flags,
                                   DS_FQDN_1779_NAME,    // in   formatOffered,
                                   DS_CANONICAL_NAME,    // in   formatDesired,
                                   1,                    // in   cNames,
                                   &ComputerDn,          // in   *rpNames,
                                   &Cracked);            // out  *ppResult

            if ((WStatus == ERROR_SUCCESS) &&
                Cracked && Cracked->cItems && Cracked->rItems &&
                (Cracked->rItems->status == DS_NAME_NO_ERROR)) {

                //
                // Get the Canonical name and terminate the string after the domain name.
                //
                DomainName = FrsWcsDup(Cracked->rItems->pName);
                DPRINT1("Canonical name: %ws\n", DomainName);
                pw = DomainName;
                while (*pw && (*pw != L'\\')) {
                    pw++;
                }
                if (pw != DomainName) {
                    *pw = L'\0';
                }
                DPRINT1("Domain name: %ws\n", DomainName);
                DsFreeNameResult(Cracked);
            } else {
                DPRINT2("ERROR: Can not crack canonical name (%ws) %d\n", ComputerDn, WStatus);
                Status = MKDSOE_BAD_ARG;
                goto CLEANUP;
            }


            //
            // Take the domain name and get the domain GUID.
            //
            WStatus = DsCrackNames(hDs,                  // in   hDS,
                                   DS_NAME_NO_FLAGS,     // in   flags,
                                   DS_CANONICAL_NAME,    // in   formatOffered,
                                   DS_UNIQUE_ID_NAME,    // in   formatDesired,
                                   1,                    // in   cNames,
                                   &DomainName,          // in   *rpNames,
                                   &Cracked);            // out  *ppResult

            if ((WStatus == ERROR_SUCCESS) &&
                Cracked && Cracked->cItems && Cracked->rItems &&
                (Cracked->rItems->status == DS_NAME_NO_ERROR)) {

                DomainGuidStr = FrsWcsDup(Cracked->rItems->pName);
                DPRINT1("Canonical name: %ws\n", DomainGuidStr);
                DsFreeNameResult(Cracked);
            } else {
                DPRINT2("ERROR: Can not crack canonical DomainName (%ws) %d\n", DomainName, WStatus);
                Status = MKDSOE_BAD_ARG;
                goto CLEANUP;
            }



#if 0

            // Alternate sequence if above fails.



            DcFlags = DS_DIRECTORY_SERVICE_PREFERRED;

            do {
                //
                // Get a DC name for a DC in the domain containing this member.
                //
                WStatus = DsGetDcName(NULL, DomainName, NULL, NULL, DcFlags, &pDCInfo);
                if (WStatus != ERROR_SUCCESS) {
                    DPRINT1("ERROR: Can not get computer name of DC in member's domain. (%ws)\n", DomainName);
                    Status = MKDSOE_BAD_ARG;
                    NetApiBufferFree(pDCInfo);
                    goto CLEANUP;
                }

                if ( !(pDCInfo->Flags & DS_DS_FLAG) ) {
                    // down level domain
                    DPRINT1("ERROR: ComputerDn in down level domains not supported. (%ws)\n", DomainName);
                    Status = MKDSOE_BAD_ARG;
                    NetApiBufferFree(pDCInfo);
                    goto CLEANUP;
                }

                //
                // Get the domain guid.
                //
                WStatus = DsRoleGetPrimaryDomainInformation(pDCInfo->DomainControllerName,
                                                            DsRolePrimaryDomainInfoBasic,
                                                            (PBYTE *)&pBuffer);
                if ((WStatus == RPC_S_SERVER_UNAVAILABLE) && !bRetry) {
                    bRetry = TRUE; // only retry once
                    NetApiBufferFree(pDCInfo);
                    DcFlags |= DS_FORCE_REDISCOVERY;
                } else {
                    break;
                }

              } while (1);

              if (WStatus == ERROR_SUCCESS) {

                  Guid = &pBuffer->DomainGuid;
                  //
                  // Build stringized Guid in the format returned by the DS.
                  // It has an extra dash.
                  // e.g.  DsCrackNames(hDs,DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME,
                  //                    DS_UNIQUE_ID_NAME, 1, &NT4ComputerName, &Cracked);
                  //
                  swprintf(DomainGuidStr,
                          L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                          Guid->Data1, Guid->Data2, Guid->Data3,
                          Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
                          Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
                  Guid = NULL;

                  DsRoleFreeMemory(pBuffer);

                  NetApiBufferFree(pDCInfo);

              } else {
                  DPRINT1("ERROR: Failed to get domain GUID for computer (%ws)\n", ComputerDn);
                  Status = MKDSOE_BAD_ARG;
                  NetApiBufferFree(pDCInfo);
                  goto CLEANUP;
              }
        }

#endif

        if (hDs != INVALID_HANDLE_VALUE) {
            DsUnBind(&hDs);
        }

        //
        // Go get the Guid of the computer object and convert to stringized form
        // that the FRS GUI Snapin will recognize.
        //
        BerValues = GetBerValues(pLdap, ComputerDn, ATTR_OBJECT_GUID, TRUE);

        if (BerValues && BerValues[0]) {
            // Copy the first value (if any)
            Guid = (GUID *)BerValues[0]->bv_val;
        }
        if (Guid != NULL) {
            //
            // Build stringized Guid in the format returned by the DS.
            // It has an extra dash.
            // e.g.  DsCrackNames(hDs,DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME,
            //                    DS_UNIQUE_ID_NAME, 1, &NT4ComputerName, &Cracked);
            //
            swprintf(ComputerObjectGuidStr,
                    L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                    Guid->Data1, Guid->Data2, Guid->Data3,
                    Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
                    Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
            Guid = NULL;
        } else {
            DPRINT1("INVALID ARG: Cannot get Object Guid for computerdn (%ws).\n", ComputerDn);
            Status = MKDSOE_MEMBER_OBJ_CRE_FAILED;
            goto CLEANUP;
        }

        // Free ldap's array of BerValues
        LDAP_FREE_BER_VALUES(BerValues);

        //
        // Check if MemberName is "ComputerObjectGuid".  If so then use the
        // stringized Guid to make the FRS UI (in the DFS UI) happy.
        // Else use the MemberName itself.
        //
        if (ArgMatch(MemberName, L"ComputerObjectGuid")) {
            FREE(MemberName);
            MemberName = new WCHAR[wcslen(ComputerObjectGuidStr)+1];
            wcscpy(MemberName, ComputerObjectGuidStr);
            DPRINT1("Member name conversion to GUID: %ws\n", MemberName);
            bDFSNaming = TRUE;
        }

        if (bCreateMember) {
            Status = CreateNewReplicaMember(NTFRSSettingsDn, ReplicaSetName,
                                            MemberName, ComputerDn, ServerRef,
                                            RefDCName);
        }

        if (bUpdateMember) {
            Status = UpdateReplicaMember(NTFRSSettingsDn, ReplicaSetName,
                                         MemberName, ComputerDn, ServerRef,
                                         RefDCName);
        }

        if (bDelMember) {
            Status = DeleteReplicaMember(NTFRSSettingsDn, ReplicaSetName,
                                         MemberName,ComputerDn);
        }

        if (bCreateSubscriber || bUpdateSubscriber) {
            Status = CreateNewSubscriber(NTFRSSettingsDn, ReplicaSetName,
                                         MemberName, ComputerDn,
                                         RootPath, StagePath, WorkingPath, RefDCName);
        }

        if (bDelSubscriber && !bDelMember) {
            Status = DeleteSubscriber(NTFRSSettingsDn, ReplicaSetName,
                                      MemberName, ComputerDn);
        }
    }

    if (bDelSet) {
        Status = DeleteReplicaSet(NTFRSSettingsDn, ReplicaSetName);
    }


    if (bDump ) {
        DumpReplicaSet(NTFRSSettingsDn, ReplicaSetName);
    }

    goto CLEANUP;

CLEANUP:
    ldap_unbind(pLdap);

ARG_CLEANUP:

    FreeArgv(argc,Argv);
    FREE(MemberName);
    FREE(ReplicaSetName);
    FREE(ComputerDn);
    FREE(NT4ComputerName);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\mkdso\mkdso.h ===
//mkdso.h

//
// Exit status codes. Exit codes start with 100 to keep them
// distinct from the MKDSXE_ error codes in mkdsx.h
//
#define  MKDSOE_SUCCESS                      100   // "Success."
#define  MKDSOE_BAD_ARG                      101   // "Invalid Arguments."
#define  MKDSOE_CANT_BIND                    102   // "Could not bind to the DC."
#define  MKDSOE_NO_NTFRS_SETTINGS            103   // "Could not find 'NTFRS Settings' object.  Check the /settingsdn parameter."
#define  MKDSOE_SET_OBJ_CRE_FAILED           104   // "Error creating replica set."
#define  MKDSOE_SET_OBJ_UPDATE_FAILED        105   // "Error updating replica set."
#define  MKDSOE_SET_NOT_FOUND_UPDATE         106   // "Error updating replica set; set not found."
#define  MKDSOE_SET_DUPS_FOUND_UPDATE        107   // "Error updating replica set; duplicate sets found."
#define  MKDSOE_SET_DUPS_FOUND_DELETE        108   // "Error deleting replica set; duplicate sets found."
#define  MKDSOE_SET_DELETE_FAILED            109   // "Error deleting replica set."
#define  MKDSOE_SET_NOT_FOUND_DELETE         110   // "Error deleting replica set; set not found."
#define  MKDSOE_MULTIPLE_SETS_DELETED        111   // "Deleting multiple sets."
#define  MKDSOE_SET_DUMP_FAILED              112   // "Error dumping replica set."
#define  MKDSOE_SET_NOT_FOUND_DUMP           113   // "Error dumping replica set; set not found."
#define  MKDSOE_MULTIPLE_SETS_DUMPED         114   // "Dumping duplicate sets."
#define  MKDSOE_MEMBER_OBJ_CRE_FAILED        115   // "Error creating replica member."
#define  MKDSOE_MEMBER_OBJ_UPDATE_FAILED     116   // "Error updating replica member."
#define  MKDSOE_MEMBER_NOT_FOUND_UPDATE      117   // "Error updating replica member; member not found."
#define  MKDSOE_MEMBER_DUPS_FOUND_UPDATE     118   // "Error updating replica member; duplicate members found."
#define  MKDSOE_MEMBER_DUPS_FOUND_DELETE     119   // "Error deleting member; duplicate subscribers found."
#define  MKDSOE_MEMBER_DELETE_FAILED         120   // "Error deleting replica member."
#define  MKDSOE_MEMBER_NOT_FOUND_DELETE      121   // "Error deleting replica member; member not found."
#define  MKDSOE_MULTIPLE_MEMBERS_DELETED     122   // "Deleting multiple members."
#define  MKDSOE_MEMBER_DUMP_FAILED           123   // "Error dumping replica member."
#define  MKDSOE_MEMBER_NOT_FOUND_DUMP        124   // "Error dumping replica member; member not found."
#define  MKDSOE_MULTIPLE_MEMBERS_DUMPED      125   // "Dumping duplicate members."
#define  MKDSOE_SUBSCRIBER_OBJ_CRE_FAILED    126   // "Error creating subscriber."
#define  MKDSOE_SUBSCRIBER_OBJ_UPDATE_FAILED 127   // "Error updating subscriber."
#define  MKDSOE_SUBSCRIBER_NOT_FOUND_UPDATE  128   // "Error updating subscriber; subscriber not found."
#define  MKDSOE_SUBSCRIBER_DUPS_FOUND_UPDATE 129   // "Error updating subscriber; duplicate subscribers found."
#define  MKDSOE_SUBSCRIBER_DELETE_FAILED     130   // "Error deleting subscriber."
#define  MKDSOE_SUBSCRIBER_NOT_FOUND_DELETE  131   // "Error deleting subscriber; subscriber not found."
#define  MKDSOE_MULTIPLE_SUBSCRIBERS_DELETE  132   // "Deleting multiple subscribers."
#define  MKDSOE_SUBSCRIBER_DUPS_FOUND_DELETE 133   // "Error deleting subscriber; duplicate subscribers found."
#define  MKDSOE_SUBSCRIBER_DUMP_FAILED       134   // "Error dumping subscriber."
#define  MKDSOE_SUBSCRIBER_NOT_FOUND_DUMP    135   // "Error dumping subscriber; subscriber not found."
#define  MKDSOE_MULTIPLE_SUBSCRIBERS_DUMPED  136   // "Dumping duplicate subscribers."


#define MKDSOE_RSTYPE_MAX  4
#define MKDSOE_SUBSCRIPTION L"NTFRS Subscriptions"

#define  FRST_SIZE_OF_SCHEDULE_GRID 168     // 168 bytes for the schedule (7days*24hours).
#define  FRST_SIZE_OF_SCHEDULE      188     // 20 bytes for the SCHEDULE and SCHEDULE_HEADER structure and

#define WIN_SUCCESS(_Status)            (_Status == ERROR_SUCCESS)
#define FREE(_x_)   { if (_x_) free(_x_); _x_ = NULL; }


//
// Is a handle valid?
//      Some functions set the handle to NULL and some to
//      INVALID_HANDLE_VALUE (-1). This define handles both
//      cases.
//
#define HANDLE_IS_VALID(_Handle)  ((_Handle) && ((_Handle) != INVALID_HANDLE_VALUE))

//
// Only close valid handles and then set the handle invalid.
//   FRS_CLOSE(handle);
//
#define FRS_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        CloseHandle(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }


VOID
PrintSchedule(
    PSCHEDULE Schedule
    );

#define FRS_LDAP_SEARCH_PAGESIZE 1000

typedef struct _FRS_LDAP_SEARCH_CONTEXT {

    BOOL                      bOpen;
    ULONG                     EntriesInPage;
    ULONG                     CurrentEntry;
    ULONG                     TotalEntries;
    LDAPMessage             * LdapMsg;
    LDAPMessage             * CurrentLdapMsg;
    PWCHAR                    Filter;
    PWCHAR                    BaseDn;
    DWORD                     Scope;
    DWORD                     PageSize;
    PWCHAR                  * Attrs;

} FRS_LDAP_SEARCH_CONTEXT, *PFRS_LDAP_SEARCH_CONTEXT;

//Macros for prints.
#define DPRINT0(str) (bVerboseMode) ? printf(str):printf("")
#define DPRINT1(str,p1) (bVerboseMode) ? printf(str,p1):printf("")
#define DPRINT2(str,p1,p2) (bVerboseMode) ? printf(str,p1,p2):printf("")
#define DPRINT3(str,p1,p2,p3) (bVerboseMode) ? printf(str,p1,p2,p3):printf("")
#define DPRINT4(str,p1,p2,p3,p4) (bVerboseMode) ? printf(str,p1,p2,p3,p4):printf("")

#define NDPRINT0(str) (!bVerboseMode) ? printf(str):printf("")
#define NDPRINT1(str,p1) (!bVerboseMode) ? printf(str,p1):printf("")
#define NDPRINT2(str,p1,p2) (!bVerboseMode) ? printf(str,p1,p2):printf("")


//
// Some useful DS object classes and object attributes
//
#define SCHEMA_NAMING_CONTEXT       L"CN=Schema"
#define CONFIG_NAMING_CONTEXT       L"CN=Configuration"
#define DOMAIN_NAMING_CONTEXT       L"DC="

#define ATTR_ATTRIBUTE_ID           L"attributeID"
#define ATTR_AUTH_LEVEL             L"frsPartnerAuthLevel"
#define ATTR_CLASS                  L"objectClass"
#define ATTR_CLASS_SCHEMA           L"classSchema"
#define ATTR_CN                     L"cn"
#define ATTR_COMPUTER               L"computer"
#define ATTR_COMPUTER_REF           L"frsComputerReference"
#define ATTR_COMPUTER_REF_BL        L"frsComputerReferenceBL"
#define ATTR_CONTAINER              L"container"
#define ATTR_CONTROL_CREATION       L"frsControlDataCreation"
#define ATTR_CXTION                 L"nTDSConnection"
#define ATTR_DEFAULT_NAMING_CONTEXT L"defaultNamingContext"
#define ATTR_DESCRIPTION            L"description"
#define ATTR_DIRECTORY_FILTER       L"frsDirectoryFilter"
#define ATTR_DN                     L"distinguishedName"
#define ATTR_DNS                    L"machineDNSName"
#define ATTR_DNS_HOST_NAME          L"dNSHostName"
#define ATTR_DS_POLL                L"frsDSPoll"
#define ATTR_ENABLED_CXTION         L"enabledConnection"
#define ATTR_EXTENSIONS             L"frsExtensions"
#define ATTR_FALSE                  L"FALSE"
#define ATTR_FAULT_CONDITION        L"frsFaultCondition"
#define ATTR_FILE_FILTER            L"frsFileFilter"
#define ATTR_FLAGS                  L"frsFlags"
#define ATTR_FROM_SERVER            L"fromServer"
#define ATTR_GOVERNS_ID             L"governsID"
#define ATTR_INBOUND_BACKLOG        L"frsControlInboundBacklog"
#define ATTR_LDAP_DISPLAY           L"lDAPDisplayName"
#define ATTR_LEVEL_LIMIT            L"frsLevelLimit"
#define ATTR_MEMBER                 L"nTFRSMember"
#define ATTR_MEMBER_REF             L"frsMemberReference"
#define ATTR_MEMBER_REF_BL          L"frsMemberReferenceBL"
#define ATTR_NAMING_CONTEXTS        L"namingContexts"
#define ATTR_NEW_SET_GUID           L"frsReplicaSetGUID"
#define ATTR_NEW_VERSION_GUID       L"frsVersionGuid"
#define ATTR_NTDS_SITE_SETTINGS     L"nTDSSiteSettings"
#define ATTR_NTFRS_SETTINGS         L"nTFRSSettings"
#define ATTR_NTFRS_SITE_SETTINGS    L"nTFRSSiteSettings"
#define ATTR_OBJECT_GUID            L"objectGUID"
#define ATTR_OLD_SET_GUID           L"replicaSetGUID"
#define ATTR_OLD_VERSION_GUID       L"replicaVersionGuid"
#define ATTR_OPTIONS                L"options"
#define ATTR_OPTIONS_0              L"0"
#define ATTR_OUTBOUND_BACKLOG       L"frsControlOutboundBacklog"
#define ATTR_PRIMARY_MEMBER         L"frsPrimaryMember"
#define ATTR_REPLICA_ROOT           L"frsRootPath"
#define ATTR_REPLICA_SET            L"nTFRSReplicaSet"
#define ATTR_REPLICA_STAGE          L"frsStagingPath"
#define ATTR_ROOT                   L""
#define ATTR_SAM                    L"sAMAccountName"
#define ATTR_SCHEDULE               L"schedule"
#define ATTR_SERVER                 L"server"
#define ATTR_SERVER_REF             L"serverReference"
#define ATTR_SERVER_REF_BL          L"serverReferenceBL"
#define ATTR_SERVICE_COMMAND        L"frsServiceCommand"
#define ATTR_SERVICE_COMMAND_STATUS L"frsServiceCommandStatus"
#define ATTR_SET_TYPE               L"frsReplicaSetType"
#define ATTR_SUBSCRIBER             L"nTFRSSubscriber"
#define ATTR_SUBSCRIPTIONS          L"nTFRSSubscriptions"
#define ATTR_SUPERIORS              L"possSuperiors"
#define ATTR_SYSTEM_FLAGS           L"systemFlags"
#define ATTR_SYSTEM_MAY_CONTAIN     L"systemMayContain"
#define ATTR_SYSTEM_MUST_CONTAIN    L"systemMustContain"
#define ATTR_SYSTEM_POSS_SUPERIORS  L"systemPossSuperiors"
#define ATTR_TRUE                   L"TRUE"
#define ATTR_UPDATE_TIMEOUT         L"frsUpdateTimeout"
#define ATTR_USER                   L"user"
#define ATTR_VERSION                L"frsVersion"
#define ATTR_WORKING_PATH           L"frsWorkingPath"

#define CN_NTDS_SITE_SETTINGS       L"NTDS Site Settings"
#define CN_SERVERS                  L"Servers"
#define CN_TEST_SETTINGS            L"NTFRS Test Settings"
#define CN_SUBSCRIPTIONS            L"NTFRS Subscriptions"
#define CN_SITES                    L"Sites"
#define CN_SERVICES                 L"Services"
#define CN_SYSTEM                   L"System"
#define CN_SYSVOLS                  L"Microsoft System Volumes"
#define CN_NTDS_SETTINGS            L"NTDS Settings"
#define CN_NTFRS_SETTINGS           L"File Replication Service"
#define CN_DOMAIN_SYSVOL            L"Domain System Volume (SYSVOL share)"

#define CLASS_ANY                   L"(objectClass=*)"
#define CLASS_SUBSCRIPTIONS         L"(objectClass=nTFRSSubscriptions)"
#define CLASS_COMPUTER              L"(objectClass=computer)"
#define CLASS_SUBSCRIBER            L"(objectClass=nTFRSSubscriber)"
#define CLASS_NTFRS_SETTINGS        L"(objectClass=nTFRSSettings)"
#define CLASS_NTDS_SETTINGS         L"(objectClass=nTDSSettings)"
#define CLASS_CXTION                L"(objectClass=nTDSConnection)"
#define CLASS_NTFRS_REPLICA_SET     L"(objectClass=nTFRSReplicaSet)"
#define CLASS_SCHEMA                L"(objectClass=classSchema)"
#define CLASS_SERVER                L"(objectClass=server)"
#define CLASS_MEMBER                L"(objectClass=nTFRSMember)"
#define CLASS_NTDS_DSA              L"(objectClass=nTDSDSA)"

#define CLASS_SITE_SETTINGS         L"(|(objectClass=nTDSSiteSettings)"\
                                    L"(objectClass=nTFRSSiteSettings))"

#define CLASS_TOPOLOGY              L"(|(objectClass=nTDSSettings)"  \
                                    L"(objectClass=nTFRSSettings)"   \
                                    L"(objectClass=nTFRSReplicaSet)" \
                                    L"(objectClass=nTDSConnection))"

#define CLASS_DELETABLE             L"(|(objectClass=nTFRSSiteSettings)"  \
                                    L"(objectClass=nTFRSSettings)"        \
                                    L"(objectClass=nTFRSReplicaSet)"      \
                                    L"(objectClass=nTDSConnection))"


#define MK_ATTRS_1(_attr_, _a1)                                                \
    _attr_[0] = _a1;   _attr_[1] = NULL;

#define MK_ATTRS_2(_attr_, _a1, _a2)                                           \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = NULL;

#define MK_ATTRS_3(_attr_, _a1, _a2, _a3)                                      \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = NULL;

#define MK_ATTRS_4(_attr_, _a1, _a2, _a3, _a4)                                 \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = NULL;

#define MK_ATTRS_5(_attr_, _a1, _a2, _a3, _a4, _a5)                            \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = NULL;

#define MK_ATTRS_6(_attr_, _a1, _a2, _a3, _a4, _a5, _a6)                       \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = NULL;

#define MK_ATTRS_7(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7)                  \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = NULL;

#define MK_ATTRS_8(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)             \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = _a8;  \
    _attr_[8] = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\mkdsx\mkdsx.h ===
//mkdsx.h.h

//
// Exit status codes.
//
#define  MKDSXE_SUCCESS                    0   // "Success."
#define  MKDSXE_BAD_ARG                    1   // "Invalid Arguments."
#define  MKDSXE_CANT_BIND                  2   // "Could not bind to the DC."
#define  MKDSXE_NO_T0_NTDS_SETTINGS        3   // "Could not find 'NTDS Settings' object.  Check the host site\\server parameter."
#define  MKDSXE_NO_FROM_NTDS_SETTINGS      4   // "Could not find 'NTDS Settings' object.  Check the from site\\server parameter."
#define  MKDSXE_CXTION_OBJ_CRE_FAILED      5   // "Error creating connection."
// #define  MKDSXE_CXTION_EXISTS              6   // "Connection already exists."
#define  MKDSXE_CXTION_OBJ_UPDATE_FAILED   7   // "Error updating connection."
#define  MKDSXE_CXTION_NOT_FOUND_UPDATE    8   // "Error updating connection; connection not found."
#define  MKDSXE_CXTION_DUPS_FOUND_UPDATE   9   // "Error updating connection; duplicate connections found."
#define  MKDSXE_CXTION_DELETE_FAILED      10   // "Error deleting connection."
#define  MKDSXE_CXTION_NOT_FOUND_DELETE   11   // "Error deleting connection; connection not found."
#define  MKDSXE_MULTIPLE_CXTIONS_DELETED  12   // "Deleting multiple connection."
#define  MKDSXE_CXTION_DUMP_FAILED        13   // "Error dumping connection."
#define  MKDSXE_CXTION_NOT_FOUND_DUMP     14   // "Error dumping; connection not found."
#define  MKDSXE_MULTIPLE_CXTIONS_DUMPED   15   // "Dumping duplicate connections."



#define  FRST_SIZE_OF_SCHEDULE_GRID 168     // 168 bytes for the schedule (7days*24hours).
#define  FRST_SIZE_OF_SCHEDULE      188     // 20 bytes for the SCHEDULE and SCHEDULE_HEADER structure and

#define WIN_SUCCESS(_Status)            (_Status == ERROR_SUCCESS)
#define FREE(_x_)   { if (_x_) free(_x_); _x_ = NULL; }


//
// Is a handle valid?
//      Some functions set the handle to NULL and some to
//      INVALID_HANDLE_VALUE (-1). This define handles both
//      cases.
//
#define HANDLE_IS_VALID(_Handle)  ((_Handle) && ((_Handle) != INVALID_HANDLE_VALUE))

//
// Only close valid handles and then set the handle invalid.
//   FRS_CLOSE(handle);
//
#define FRS_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        CloseHandle(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }


VOID
PrintSchedule(
    PSCHEDULE Schedule
    );

#define FRS_LDAP_SEARCH_PAGESIZE 1000

typedef struct _FRS_LDAP_SEARCH_CONTEXT {

    BOOL                      bOpen;
    ULONG                     EntriesInPage;
    ULONG                     CurrentEntry;
    ULONG                     TotalEntries;
    LDAPMessage             * LdapMsg;
    LDAPMessage             * CurrentLdapMsg;
    PWCHAR                    Filter;
    PWCHAR                    BaseDn;
    DWORD                     Scope;
    DWORD                     PageSize;
    PWCHAR                  * Attrs;

} FRS_LDAP_SEARCH_CONTEXT, *PFRS_LDAP_SEARCH_CONTEXT;

//Macros for prints.
#define DPRINT0(str) (bVerboseMode) ? printf(str):printf("")
#define DPRINT1(str,p1) (bVerboseMode) ? printf(str,p1):printf("")
#define DPRINT2(str,p1,p2) (bVerboseMode) ? printf(str,p1,p2):printf("")
#define DPRINT3(str,p1,p2,p3) (bVerboseMode) ? printf(str,p1,p2,p3):printf("")
#define DPRINT4(str,p1,p2,p3,p4) (bVerboseMode) ? printf(str,p1,p2,p3,p4):printf("")

#define NDPRINT0(str) (!bVerboseMode) ? printf(str):printf("")
#define NDPRINT1(str,p1) (!bVerboseMode) ? printf(str,p1):printf("")
#define NDPRINT2(str,p1,p2) (!bVerboseMode) ? printf(str,p1,p2):printf("")


//
// Some useful DS object classes and object attributes
//
#define SCHEMA_NAMING_CONTEXT       L"CN=Schema"
#define CONFIG_NAMING_CONTEXT       L"CN=Configuration"
#define DOMAIN_NAMING_CONTEXT       L"DC="

#define ATTR_ATTRIBUTE_ID           L"attributeID"
#define ATTR_AUTH_LEVEL             L"frsPartnerAuthLevel"
#define ATTR_CLASS                  L"objectClass"
#define ATTR_CLASS_SCHEMA           L"classSchema"
#define ATTR_CN                     L"cn"
#define ATTR_COMPUTER_REF           L"frsComputerReference"
#define ATTR_COMPUTER_REF_BL        L"frsComputerReferenceBL"
#define ATTR_CONTAINER              L"container"
#define ATTR_CONTROL_CREATION       L"frsControlDataCreation"
#define ATTR_CXTION                 L"nTDSConnection"
#define ATTR_DEFAULT_NAMING_CONTEXT L"defaultNamingContext"
#define ATTR_DESCRIPTION            L"description"
#define ATTR_DIRECTORY_FILTER       L"frsDirectoryFilter"
#define ATTR_DN                     L"distinguishedName"
#define ATTR_DNS                    L"machineDNSName"
#define ATTR_DNS_HOST_NAME          L"dNSHostName"
#define ATTR_DS_POLL                L"frsDSPoll"
#define ATTR_ENABLED_CXTION         L"enabledConnection"
#define ATTR_EXTENSIONS             L"frsExtensions"
#define ATTR_FALSE                  L"FALSE"
#define ATTR_FAULT_CONDITION        L"frsFaultCondition"
#define ATTR_FILE_FILTER            L"frsFileFilter"
#define ATTR_FLAGS                  L"frsFlags"
#define ATTR_FROM_SERVER            L"fromServer"
#define ATTR_GOVERNS_ID             L"governsID"
#define ATTR_INBOUND_BACKLOG        L"frsControlInboundBacklog"
#define ATTR_LDAP_DISPLAY           L"lDAPDisplayName"
#define ATTR_LEVEL_LIMIT            L"frsLevelLimit"
#define ATTR_MEMBER                 L"nTFRSMember"
#define ATTR_MEMBER_REF             L"frsMemberReference"
#define ATTR_MEMBER_REF_BL          L"frsMemberReferenceBL"
#define ATTR_NAMING_CONTEXTS        L"namingContexts"
#define ATTR_NEW_SET_GUID           L"frsReplicaSetGUID"
#define ATTR_NEW_VERSION_GUID       L"frsVersionGuid"
#define ATTR_NTDS_SITE_SETTINGS     L"nTDSSiteSettings"
#define ATTR_NTFRS_SETTINGS         L"nTFRSSettings"
#define ATTR_NTFRS_SITE_SETTINGS    L"nTFRSSiteSettings"
#define ATTR_OBJECT_GUID            L"objectGUID"
#define ATTR_OLD_SET_GUID           L"replicaSetGUID"
#define ATTR_OLD_VERSION_GUID       L"replicaVersionGuid"
#define ATTR_OPTIONS                L"options"
#define ATTR_OPTIONS_0              L"0"
#define ATTR_OUTBOUND_BACKLOG       L"frsControlOutboundBacklog"
#define ATTR_PRIMARY_MEMBER         L"frsPrimaryMember"
#define ATTR_REPLICA_ROOT           L"frsRootPath"
#define ATTR_REPLICA_SET            L"nTFRSReplicaSet"
#define ATTR_REPLICA_STAGE          L"frsStagingPath"
#define ATTR_ROOT                   L""
#define ATTR_SAM                    L"sAMAccountName"
#define ATTR_SCHEDULE               L"schedule"
#define ATTR_SERVER                 L"server"
#define ATTR_SERVER_REF             L"serverReference"
#define ATTR_SERVER_REF_BL          L"serverReferenceBL"
#define ATTR_SERVICE_COMMAND        L"frsServiceCommand"
#define ATTR_SERVICE_COMMAND_STATUS L"frsServiceCommandStatus"
#define ATTR_SET_TYPE               L"frsReplicaSetType"
#define ATTR_SUBSCRIBER             L"nTFRSSubscriber"
#define ATTR_SUBSCRIPTIONS          L"nTFRSSubscriptions"
#define ATTR_SUPERIORS              L"possSuperiors"
#define ATTR_SYSTEM_FLAGS           L"systemFlags"
#define ATTR_SYSTEM_MAY_CONTAIN     L"systemMayContain"
#define ATTR_SYSTEM_MUST_CONTAIN    L"systemMustContain"
#define ATTR_SYSTEM_POSS_SUPERIORS  L"systemPossSuperiors"
#define ATTR_TRUE                   L"TRUE"
#define ATTR_UPDATE_TIMEOUT         L"frsUpdateTimeout"
#define ATTR_VERSION                L"frsVersion"
#define ATTR_WORKING_PATH           L"frsWorkingPath"

#define CN_NTDS_SITE_SETTINGS       L"NTDS Site Settings"
#define CN_SERVERS                  L"Servers"
#define CN_TEST_SETTINGS            L"NTFRS Test Settings"
#define CN_SUBSCRIPTIONS            L"NTFRS Subscriptions"
#define CN_SITES                    L"Sites"
#define CN_SERVICES                 L"Services"
#define CN_SYSTEM                   L"System"
#define CN_SYSVOLS                  L"Microsoft System Volumes"
#define CN_NTDS_SETTINGS            L"NTDS Settings"
#define CN_NTFRS_SETTINGS           L"File Replication Service"
#define CN_DOMAIN_SYSVOL            L"Domain System Volume (SYSVOL share)"

#define CLASS_ANY                   L"(objectClass=*)"
#define CLASS_SUBSCRIPTIONS         L"(objectClass=nTFRSSubscriptions)"
#define CLASS_COMPUTER              L"(objectClass=computer)"
#define CLASS_SUBSCRIBER            L"(objectClass=nTFRSSubscriber)"
#define CLASS_NTFRS_SETTINGS        L"(objectClass=nTFRSSettings)"
#define CLASS_NTDS_SETTINGS         L"(objectClass=nTDSSettings)"
#define CLASS_CXTION                L"(objectClass=nTDSConnection)"
#define CLASS_NTFRS_REPLICA_SET     L"(objectClass=nTFRSReplicaSet)"
#define CLASS_SCHEMA                L"(objectClass=classSchema)"
#define CLASS_SERVER                L"(objectClass=server)"
#define CLASS_MEMBER                L"(objectClass=nTFRSMember)"
#define CLASS_NTDS_DSA              L"(objectClass=nTDSDSA)"

#define CLASS_SITE_SETTINGS         L"(|(objectClass=nTDSSiteSettings)"\
                                    L"(objectClass=nTFRSSiteSettings))"

#define CLASS_TOPOLOGY              L"(|(objectClass=nTDSSettings)"  \
                                    L"(objectClass=nTFRSSettings)"   \
                                    L"(objectClass=nTFRSReplicaSet)" \
                                    L"(objectClass=nTDSConnection))"

#define CLASS_DELETABLE             L"(|(objectClass=nTFRSSiteSettings)"  \
                                    L"(objectClass=nTFRSSettings)"        \
                                    L"(objectClass=nTFRSReplicaSet)"      \
                                    L"(objectClass=nTDSConnection))"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\mkdsx\mkdsxe.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>
#include <schedule.h>
#include <mkdsx.h>
#include <frsrpc.h>
#include <ntdsapi.h>

//Global data
BOOL           bVerboseMode     = FALSE;
BOOL           bVerboseModeSearch = FALSE;
PWCHAR         DcName           = NULL;
PLDAP          pLdap            = NULL;
BOOL           bDebugMode       = FALSE;
BOOL           bAffectAll       = FALSE;
PBYTE          SchedMask        = NULL;
PBYTE          SchedOverride    = NULL;

//
// The following come from ntdsapi.h but were not defined in win2K so for
// the SP versions we define them here.
//
#ifndef NTDSCONN_OPT_IS_GENERATED
#define NTDSCONN_OPT_IS_GENERATED ( 1 << 0 )  /* object generated by DS, not admin */
#endif
#ifndef NTDSCONN_OPT_TWOWAY_SYNC
#define NTDSCONN_OPT_TWOWAY_SYNC  ( 1 << 1 )  /* force sync in opposite direction at end of sync */
#endif
#ifndef NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT
#define NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT (1 << 2 )  // Do not use defaults to determine notification
#endif
#ifndef NTDSCONN_OPT_USE_NOTIFY
#define NTDSCONN_OPT_USE_NOTIFY   (1 << 3) // Does source notify destination
#endif



//
// Static arrays to conver the value of the options attribute to
// string for display.
//
#define NTDSCONN_OPT_NUM 6

DWORD NtdsConnOptions[NTDSCONN_OPT_NUM] = {0,
                                           NTDSCONN_OPT_IS_GENERATED,
                                           NTDSCONN_OPT_TWOWAY_SYNC,
                                           NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT,
                                           NTDSCONN_OPT_USE_NOTIFY,
                                           NTDSCONN_OPT_IGNORE_SCHEDULE_MASK};

WCHAR NtdsConnOptionsStr[][MAX_PATH] = {L"Not Used",
                                        L"IsGenerated",
                                        L"TwoWaySync",
                                        L"OverrideNotifyDefault",
                                        L"UseNotify",
                                        L"IgnoreSchedule"};

//
// Mask of allowed connection options.
//

#define MKDSXE_VALID_CONN_OPTIONS_MASK (NTDSCONN_OPT_IS_GENERATED |             \
                                       NTDSCONN_OPT_TWOWAY_SYNC  |              \
                                       NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT |   \
                                       NTDSCONN_OPT_USE_NOTIFY |                \
                                       NTDSCONN_OPT_IGNORE_SCHEDULE_MASK |      \
                                       FRSCONN_PRIORITY_MASK)

//
// Only priority 0-7 is supported.
//
#define MKDSXE_MAX_CONN_PRIORITY 7

VOID
PrintScheduleGrid(
    PUCHAR    ScheduleData,
    DWORD     Mask
    );

VOID
PrintSchedule(
    PSCHEDULE Schedule,
    DWORD     Mask
    );


DWORD
BindToDC (
    IN  PWCHAR    pszDC,
    OUT PLDAP     *ppLDAP
    )
/*++

Routine Description:

    Sets up an LDAP connection to the specified server

Arguments:

    pwszDC - DS DC to bind to
    ppLDAP - The LDAP connection information is returned here

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG   ulOptions;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName
    // passing the server name as the domainname parm...bad, because
    // DsGetDcName will make a load of DNS queries based on the server name,
    // it is designed to construct these queries from a domain name...so all
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up
    // as referrals/forwarders are contacted to attempt to resolve the bogus
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
    // after the ldap_init but before any other operation using the ldap
    // handle from ldap_init, the delayed connection setup will not call
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
    // will detect that and use the address directly.
    //
//    *ppLDAP = ldap_open(pszDC, LDAP_PORT);
    *ppLDAP = ldap_init(pszDC, LDAP_PORT);

    if(*ppLDAP == NULL)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // set the options.
        //
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        ldap_set_option(*ppLDAP, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

        //
        // Do a bind...
        //
        dwErr = ldap_bind_s(*ppLDAP,
                            NULL,
                            NULL,
                            LDAP_AUTH_NEGOTIATE);
    }

    return(dwErr);
}

PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL)
            return NULL;

    NewStr = (PWCHAR)malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}




VOID
AddMod(
    PWCHAR AttrType,
    PWCHAR AttrValue,
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR *)malloc(sizeof (PWCHAR) * 2);
    Values[0] = _wcsdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
//    Attr->mod_op = LDAP_MOD_ADD;
    Attr->mod_op = LDAP_MOD_REPLACE;
    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
AddBerMod(
    PWCHAR AttrType,
    PCHAR AttrValue,
    DWORD AttrValueLen,
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    AttrValueLen    - length of the attribute
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PLDAP_BERVAL    Berval;
    PLDAP_BERVAL    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PLDAP_BERVAL)malloc(sizeof(LDAP_BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PLDAP_BERVAL *)malloc(sizeof (PLDAP_BERVAL) * 2);
    Values[0] = Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_bvalues = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
FreeMod(
    LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    //
    // For each attibute
    //
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            //
            // Free the value
            //
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

BOOL
LdapSearch(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    LDAPMessage  **Res,
    BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD LStatus;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_s(ldap,
                            Base,
                            Scope,
                            Filter,
                            Attrs,
                            AttrsOnly,
                            Res);
    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {
        if (!Quiet) {
            DPRINT4("WARN - Error searching %ws for %ws; LStatus %d: %ws\n",
                    Base, Filter, LStatus, ldap_err2string(LStatus));
        }
        return FALSE;
    }
    //
    // Return TRUE if not shutting down
    //
    return TRUE;
}

PWCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PWCHAR Dn,
    IN PWCHAR DesiredAttr,
    IN BOOL   Quiet
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.
    Quiet

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR          Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PWCHAR          Attrs[2];
    PWCHAR          *Values = NULL;

    //
    // Search Base for all of its attributes + values
    //
    Attrs[0] = DesiredAttr;
    Attrs[1] = NULL;

    //
    // Issue the ldap search
    //
    if (!LdapSearch(Ldap,
                    Dn,
                    LDAP_SCOPE_BASE,
                    CLASS_ANY,
                    Attrs,
                    0,
                    &LdapMsg,
                    Quiet)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    ldap_msgfree(LdapMsg);
    return Values;
}

BOOL
LdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext,
    BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD           LStatus = LDAP_SUCCESS;
    PLDAPControl    ServerControls[2];
    berval          cookie1 = { 0, NULL };

    FrsSearchContext->bOpen = FALSE;
    FrsSearchContext->LdapMsg = NULL;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;
    FrsSearchContext->TotalEntries = 0;

    FrsSearchContext->Filter = FrsWcsDup(Filter);
    FrsSearchContext->BaseDn = FrsWcsDup(Base);
    FrsSearchContext->Scope = Scope;
    FrsSearchContext->PageSize = FRS_LDAP_SEARCH_PAGESIZE;
    FrsSearchContext->Attrs = Attrs;


    LStatus = ldap_create_page_control(ldap,
                                      FrsSearchContext->PageSize,
                                      &cookie1,
                                      FALSE, // is critical
                                      &ServerControls[0]
                                     );

    ServerControls[1] = NULL;

    if (LStatus != LDAP_SUCCESS) {
        DPRINT1("ldap_create_page_control returned error. LStatus = 0x%x\n", LStatus);
    }

    LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      NULL,
                      0,
                      &FrsSearchContext->LdapMsg);

    if  (LStatus  == LDAP_SUCCESS) {
       FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
       FrsSearchContext->CurrentEntry = 0;
       FrsSearchContext->bOpen = TRUE;
    }


    return (LStatus == LDAP_SUCCESS);
}

PLDAPMessage
LdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{

    FrsSearchContext->CurrentEntry += 1;
    if ( FrsSearchContext->CurrentEntry == 1 ) {
        FrsSearchContext->CurrentLdapMsg = ldap_first_entry(ldap ,FrsSearchContext->LdapMsg);
    } else {
        FrsSearchContext->CurrentLdapMsg = ldap_next_entry(ldap ,FrsSearchContext->CurrentLdapMsg);
    }

    return FrsSearchContext->CurrentLdapMsg;
}

DWORD
LdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD                     LStatus = LDAP_SUCCESS;
    berval                  * CurrCookie = NULL;
    PLDAPControl            * CurrControls = NULL;
    ULONG                     retcode = 0;
    PLDAPControl              ServerControls[2];



    // Get the server control from the message, and make a new control with the cookie from the server
    LStatus = ldap_parse_result(ldap, FrsSearchContext->LdapMsg, &retcode,NULL,NULL,NULL,&CurrControls,FALSE);
    ldap_msgfree(FrsSearchContext->LdapMsg);
    FrsSearchContext->LdapMsg = NULL;

    if (LStatus == LDAP_SUCCESS) {
       LStatus = ldap_parse_page_control(ldap, CurrControls, &FrsSearchContext->TotalEntries, &CurrCookie);
       // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are
       // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will
       // cause us to start over at the beginning of the search results.

    }
    if (LStatus == LDAP_SUCCESS) {
       if ( CurrCookie->bv_len == 0 && CurrCookie->bv_val == 0 ) {
          // under Exchange 5.5, SP 2, this means we're at the end of the results.
          // if we pass in this cookie again, we will start over at the beginning of the search results.
          LStatus = LDAP_CONTROL_NOT_FOUND;
       }

       ServerControls[0] = NULL;
       ServerControls[1] = NULL;
       if (LStatus == LDAP_SUCCESS) {
          LStatus = ldap_create_page_control(ldap,
                                  FrsSearchContext->PageSize,
                                  CurrCookie,
                                  FALSE,
                                  ServerControls);
       }
       ldap_controls_free(CurrControls);
       CurrControls = NULL;
       ber_bvfree(CurrCookie);
       CurrCookie = NULL;
    }

    // continue the search with the new cookie
    if (LStatus == LDAP_SUCCESS) {
       LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      NULL,
                      0,
                      &FrsSearchContext->LdapMsg);

       if ( (LStatus != LDAP_SUCCESS) && (LStatus != LDAP_CONTROL_NOT_FOUND) )
       {
          // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results
          // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there
          // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page
          // control from the search results).

       }
    }

    if (LStatus == LDAP_SUCCESS) {
        FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
        FrsSearchContext->CurrentEntry = 0;

    }

    return LdapMapErrorToWin32(LStatus);
}

PLDAPMessage
LdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD         WStatus = ERROR_SUCCESS;
    PLDAPMessage  NextEntry = NULL;

    if (FrsSearchContext->bOpen != TRUE)
    {
       NextEntry = NULL;
    }
    else
    {
       if (FrsSearchContext->EntriesInPage > FrsSearchContext->CurrentEntry )
       {
          // return the next entry from the current page
          return LdapSearchGetNextEntry(ldap, FrsSearchContext);
       }
       else
       {
          // see if there are more pages of results to get
          WStatus = LdapSearchGetNextPage(ldap, FrsSearchContext);
          if (WStatus == ERROR_SUCCESS)
          {
             return LdapSearchGetNextEntry(ldap, FrsSearchContext);
          }
       }


    }

    return NextEntry;
}

VOID
LdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    FrsSearchContext

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    FrsSearchContext->bOpen = FALSE;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;
    FrsSearchContext->TotalEntries = 0;

    FREE(FrsSearchContext->Filter);
    FREE(FrsSearchContext->BaseDn);

    if (FrsSearchContext->LdapMsg != NULL) {
        ldap_msgfree(FrsSearchContext->LdapMsg);
    }
}

PWCHAR
GetRootDn(
    PLDAP    Ldap,
    PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, ATTR_ROOT, ATTR_NAMING_CONTEXTS, FALSE);
    if (Values == NULL)
        return NULL;

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsWcsDup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    DPRINT1("ERROR - COULD NOT FIND %ws\n", NamingContext);
    ldap_value_free(Values);
    return NULL;
}

PWCHAR
ExtendDn(
    PWCHAR Dn,
    PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PWCHAR NewDn;

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"CN=");
    wcscat(NewDn, Cn);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}

PVOID *
FindValues(
    PLDAPMessage LdapEntry,
    PWCHAR       DesiredAttr,
    BOOL         DoBerValues
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoVerValues - Return the bervals

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR      LdapAttr;       // Retrieved from an ldap entry
    BerElement  *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (LdapAttr = ldap_first_attribute(pLdap, LdapEntry, &Ber);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(pLdap, LdapEntry, Ber)) {
        if (_wcsicmp(DesiredAttr, LdapAttr) == 0) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerValues) {
                return (PVOID *)ldap_get_values_len(pLdap, LdapEntry, LdapAttr);
            } else {
                return (PVOID *)ldap_get_values(pLdap, LdapEntry, LdapAttr);
            }
        }
    }
    return NULL;
}

PWCHAR
FindValue(
    PLDAPMessage LdapEntry,
    PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE().
--*/
{
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FindValues(LdapEntry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    if (Values) {
       Val = new WCHAR[wcslen(Values[0]) + 1];
       wcscpy(Val, Values[0]);
    } else {
       Val = NULL;
    }

    // Free ldap's array of values
    ldap_value_free(Values);

    return Val;
}

BOOL
FindBerValue(
    PLDAPMessage Entry,
    PWCHAR       DesiredAttr,
    ULONG        *Len,
    VOID         **Value
    )
/*++
Routine Description:
    Return a copy of the attributes object's schedule

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - desired attribute
    Len         - length of Value
    Value       - binary value

Return Value:
    The address of a schedule or NULL. Free with FrsFree().
--*/
{
    PLDAP_BERVAL    *Values;

    *Len = 0;
    *Value = NULL;

    //
    // Get ldap's array of values
    //
    Values = (PLDAP_BERVAL *)FindValues(Entry, DesiredAttr, TRUE);
    if (!Values) {
        return FALSE;
    }

    //
    // Return a copy of the schedule
    //
    *Len = Values[0]->bv_len;
    if (*Len) {
        *Value = new WCHAR[*Len];
        CopyMemory(*Value, Values[0]->bv_val, *Len);
    }
    ldap_value_free_len(Values);
    return TRUE;
}

DWORD
FormMemberDn(
    IN  PWCHAR    ReplicaSetName,
    IN  PWCHAR    ComputerDnsName,
    OUT PWCHAR    *pMemberDn
    )
/*++

Routine Description:

    Form the member Dn given the computername and the replica set name.

Arguments:


Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD  Status      = ERROR_SUCCESS;
    WCHAR  SearchFilter[MAX_PATH];
    ULONG  NoOfSets    = 0;
    PLDAPMessage LdapEntry  = NULL;
    PWCHAR ConfigDn    = NULL;
    PWCHAR ServicesDn  = NULL;
    PWCHAR FrsTestDn   = NULL;
    PWCHAR DomainDn    = NULL;
    PWCHAR SystemDn    = NULL;
    PWCHAR FrsDn       = NULL;
    PWCHAR SetDn       = NULL;
    PWCHAR MemberDn    = NULL;
    PWCHAR ComputerDn  = NULL;
    PWCHAR *Values     = NULL;
    PWCHAR Attrs[3];
    PWCHAR Attrs2[4];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_CN;
    Attrs[2] = NULL;



    DomainDn = GetRootDn(pLdap, DOMAIN_NAMING_CONTEXT);
    if (DomainDn == NULL) {
        if (bVerboseModeSearch) printf("GetRootDn-1 returned NULL\n");
        return MKDSXE_NO_T0_NTDS_SETTINGS;
    }

    SystemDn = ExtendDn(DomainDn, CN_SYSTEM);
    FrsDn = ExtendDn(SystemDn, CN_NTFRS_SETTINGS);

    wcscpy(SearchFilter, L"(&(");
    wcscat(SearchFilter, ATTR_CN);
    wcscat(SearchFilter, L"=");
    wcscat(SearchFilter, ReplicaSetName);
    wcscat(SearchFilter, L")");
    wcscat(SearchFilter, CLASS_NTFRS_REPLICA_SET);
    wcscat(SearchFilter, L")");

    if (bVerboseModeSearch) printf("\nSubtree search at: %ws\n", FrsDn);
    if (bVerboseModeSearch) printf("Filter           : %ws\n", SearchFilter);

    if (!LdapSearchInit(pLdap,
                    FrsDn,
                    LDAP_SCOPE_SUBTREE,
                    SearchFilter,
                    Attrs,
                    0,
                    &FrsSearchContext,
                    FALSE)) {
        Status = MKDSXE_NO_T0_NTDS_SETTINGS ;
        if (bVerboseModeSearch) printf("Subtree-1 search failed\n");
        goto RETURN;
    }

    NoOfSets = FrsSearchContext.EntriesInPage;

    if (NoOfSets == 0) {

        LdapSearchClose(&FrsSearchContext);

        //
        // Replica set was not found under system. Look under
        // CN=NTFRS Test Settings,CN=Services,CN=Configuration,DC=...
        //
        ConfigDn = GetRootDn(pLdap, CONFIG_NAMING_CONTEXT);
        if (ConfigDn == NULL) {
            if (bVerboseModeSearch) printf("GetRootDn-2 returned NULL\n");
            Status = MKDSXE_NO_T0_NTDS_SETTINGS;
            goto RETURN;
        }
        ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
        FrsTestDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);

        if (bVerboseModeSearch) printf("\nSubtree search at: %ws\n", FrsTestDn);
        if (bVerboseModeSearch) printf("Filter           : %ws\n", SearchFilter);

        if (!LdapSearchInit(pLdap,
                        FrsTestDn,
                        LDAP_SCOPE_SUBTREE,
                        SearchFilter,
                        Attrs,
                        0,
                        &FrsSearchContext,
                        FALSE)) {
            Status = MKDSXE_NO_T0_NTDS_SETTINGS ;
            if (bVerboseModeSearch) printf("Subtree-2 search failed\n");
            goto RETURN;
        }

        NoOfSets = FrsSearchContext.EntriesInPage;
    }


    if (NoOfSets != 1) {
        DPRINT0("Error finding replica set.\n");
        return MKDSXE_NO_T0_NTDS_SETTINGS;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

       SetDn = FindValue(LdapEntry, ATTR_DN);
    }

    DPRINT1("Replica Set Dn:%ws\n", SetDn);

    LdapSearchClose(&FrsSearchContext);

    Attrs2[0] = ATTR_DN;
    Attrs2[1] = ATTR_CN;
    Attrs2[2] = ATTR_COMPUTER_REF;
    Attrs2[3] = NULL;

    if (bVerboseModeSearch) printf("\nSubtree search at: %ws\n", SetDn);
    if (bVerboseModeSearch) printf("Filter           : %ws\n", CLASS_MEMBER);

    if (!LdapSearchInit(pLdap,
                    SetDn,
                    LDAP_SCOPE_ONELEVEL,
                    CLASS_MEMBER,
                    Attrs2,
                    0,
                    &FrsSearchContext,
                    FALSE)) {
        Status = MKDSXE_NO_T0_NTDS_SETTINGS;
        if (bVerboseModeSearch) printf("Error finding member.\n");
        goto RETURN;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

       MemberDn = FindValue(LdapEntry, ATTR_DN);
       ComputerDn = FindValue(LdapEntry, ATTR_COMPUTER_REF);

       if (bVerboseModeSearch) printf("\n    MemberDN scan : %ws\n", MemberDn);
       if (bVerboseModeSearch) printf("    ComputerDn is : %ws\n", (ComputerDn == NULL) ? L"null" : ComputerDn);
       if (ComputerDn != NULL) {
           Values = GetValues(pLdap, ComputerDn, ATTR_DNS_HOST_NAME, TRUE);
           FREE(ComputerDn);
           if (bVerboseModeSearch) printf("    Computer DNS is : %ws\n", (Values != NULL) && (Values[0] != NULL) ? Values[0] : L"null");
           if ((Values != NULL) && (Values[0] != NULL) && !_wcsicmp(Values[0], ComputerDnsName)) {
               ldap_value_free(Values);
               *pMemberDn = FrsWcsDup(MemberDn);
               FREE(MemberDn);
               break;
           }
       }
       FREE(MemberDn);
    }

    if (*pMemberDn == NULL) {
        if (bVerboseModeSearch) printf("No member found in scan.\n");
        Status = MKDSXE_NO_T0_NTDS_SETTINGS;
    }
    LdapSearchClose(&FrsSearchContext);

RETURN:

    FREE(SetDn);
    FREE(FrsDn);
    FREE(SystemDn);
    FREE(DomainDn);
    FREE(FrsTestDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
    return Status;
}

DWORD
FormNTDSSettingsDn(
    IN  PWCHAR    ToSite,
    IN  PWCHAR    ToServer,
    OUT PWCHAR    *pNTDSSettingsDn
    )
/*++

Routine Description:

    Form the settings dn for the to server.

Arguments:


Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD  Status   = ERROR_SUCCESS;
    PWCHAR ConfigDn = NULL;
    PWCHAR SitesDn  = NULL;
    PWCHAR ToSiteDn = NULL;
    PWCHAR ServersDn = NULL;
    PWCHAR ToServerDn = NULL;
    PWCHAR Attrs[2];
    PLDAPMessage    LdapMsg;

    Attrs[0] = ATTR_DN;
    Attrs[1] = NULL;


    ConfigDn = GetRootDn(pLdap, CONFIG_NAMING_CONTEXT);
    if (ConfigDn == NULL) {
        return MKDSXE_NO_T0_NTDS_SETTINGS;
    }

    SitesDn = ExtendDn(ConfigDn, CN_SITES);
    ToSiteDn = ExtendDn(SitesDn, ToSite);
    ServersDn = ExtendDn(ToSiteDn, L"Servers");
    ToServerDn = ExtendDn(ServersDn, ToServer);
    *pNTDSSettingsDn = ExtendDn(ToServerDn, L"NTDS Settings");

    if (!LdapSearch(pLdap,
                    *pNTDSSettingsDn,
                    LDAP_SCOPE_BASE,
                    CLASS_NTDS_SETTINGS,
                    Attrs,
                    0,
                    &LdapMsg,
                    TRUE)){
        Status = MKDSXE_NO_T0_NTDS_SETTINGS;
    }


    FREE(ConfigDn);
    FREE(SitesDn);
    FREE(ToSiteDn);
    FREE(ServersDn);
    FREE(ToServerDn);
    ldap_msgfree(LdapMsg);

    return Status;
}


PBYTE
ReadScheduleFile(
    PWCHAR  FileName
    )
/*++
Routine Description:
    Read a Hex formated byte array for a 7x24 schedule from a file.
    Convert to a 7x24 binary schedule.

Arguments:
    FileName - Name of schedule file.

Return Value:
    ptr to schedule data array or NULL if invalid param.
--*/
{
    HANDLE FileHandle;
    PBYTE  SchedData;
    DWORD  WStatus;
    DWORD  BytesRead;
    DWORD  DataByte, i, Day, Hour;
    ULONG  Remaining;
    PCHAR  pTC;
    CHAR   SchedText[FRST_SIZE_OF_SCHEDULE_GRID*3 + 50];

    SchedData = new BYTE[FRST_SIZE_OF_SCHEDULE_GRID];
    if (SchedData == NULL) {
        printf("Error allocating memory.\n");
        return NULL;
    }

    FileHandle = CreateFileW(
        FileName,                                   //  lpszName
        GENERIC_READ | GENERIC_WRITE,               //  fdwAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,         //  fdwShareMode
        NULL,                                       //  lpsa
        OPEN_EXISTING,                              //  fdwCreate
        FILE_ATTRIBUTE_NORMAL,                      //  fdwAttrAndFlags
        NULL);                                      //  hTemplateFile

    if (!HANDLE_IS_VALID(FileHandle)) {
        WStatus = GetLastError();
        printf("Error opening %ws   WStatus: %d\n", FileName, WStatus);
        FREE(SchedData);
        return NULL;
    }

    if (!ReadFile(FileHandle, SchedText, sizeof(SchedText), &BytesRead, NULL)) {
        WStatus = GetLastError();
        printf("Error reading %ws   WStatus: %d\n", FileName, WStatus);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // remove any white-space chars, including CR-LF, used for formatting.
    //
    Remaining = BytesRead;
    pTC = SchedText;

    while (Remaining > 0) {
        if (isspace((LONG) *pTC)) {
            memcpy(pTC, pTC+1, Remaining-1);
        } else {
            pTC++;
        }
        Remaining -= 1;
    }
    BytesRead = pTC - SchedText;

    if (BytesRead < FRST_SIZE_OF_SCHEDULE_GRID*2) {
        printf("Error reading %ws   Expecting %d bytes,  Actual was %d bytes.  Could be too much whitespace.\n",
           FileName, FRST_SIZE_OF_SCHEDULE_GRID*2, BytesRead);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // Result should be exactly the right size.
    //
    if (BytesRead != FRST_SIZE_OF_SCHEDULE_GRID*2) {
        printf("Error reading %ws   Expecting %d bytes,  Actual was %d bytes\n",
               FileName, FRST_SIZE_OF_SCHEDULE_GRID*2, BytesRead);
        FREE(SchedData);
        FRS_CLOSE(FileHandle);
        return NULL;
    }

    //
    // Convert to binary.
    //
    for (i=0; i<FRST_SIZE_OF_SCHEDULE_GRID; i++) {
        if (sscanf(&SchedText[i*2], "%2x", &DataByte) != 1) {
            SchedText[i*2+2] = '\0';
            printf("Error reading %ws   Invalid hex data (%s) for schedule byte %d.\n",
                   FileName, &SchedText[i*2], i);
            FREE(SchedData);
            FRS_CLOSE(FileHandle);
            return NULL;
        }
        SchedData[i] = (BYTE) DataByte;
    }


    FRS_CLOSE(FileHandle);
    return SchedData;
}

DWORD
BuildSchedule(
    PBYTE       *ppSchedule,
    DWORD       Interval,
    DWORD       Stagger,
    DWORD       Offset,
    PBYTE       CustSchedData
    )
/*++
Routine Description:
     Build the schedule structure.  Using interval, stagger and offset.
     Then apply mask and override.
     If CustSchedData is non-null then just use that.
Arguments:
      ppSchedule         - pointer to return the schedule in.

Return Value:
    winerror.
--*/
{
    BYTE    ScheduleData[FRST_SIZE_OF_SCHEDULE_GRID];
    UINT    i, Day, Hour;
    DWORD   Status = ERROR_SUCCESS;

    *ppSchedule = new BYTE[FRST_SIZE_OF_SCHEDULE];
    if (*ppSchedule == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Set the values for the elements of the SCHEDULE structure.
    //

    ((PSCHEDULE)*ppSchedule)->Size = FRST_SIZE_OF_SCHEDULE;
    ((PSCHEDULE)*ppSchedule)->Bandwidth = 0;
    ((PSCHEDULE)*ppSchedule)->NumberOfSchedules = 1;
    ((PSCHEDULE)*ppSchedule)->Schedules->Type = SCHEDULE_INTERVAL;
    ((PSCHEDULE)*ppSchedule)->Schedules->Offset = sizeof(SCHEDULE);

    if (CustSchedData != NULL) {
        //
        // For custom schedules, we're done.
        //
        memcpy((*ppSchedule)+sizeof(SCHEDULE), CustSchedData, FRST_SIZE_OF_SCHEDULE_GRID);
        return ERROR_SUCCESS;
    }

    //
    // Building the ScheduleData array depending on the requested schedule.
    //
    for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
        if (Interval == 0) {
            ScheduleData[i] = 0x00;
        } else if (i < Offset) {
            ScheduleData[i] = 0x00;
        } else if ( (i-Offset) % (Interval * Stagger) == 0) {
            ScheduleData[i] = 0x01;
        } else {
            ScheduleData[i] = 0x00;
        }
    }

    //
    // Use the supplied schedule mask to turn off regions of the above schedule.
    //
    if (SchedMask != NULL) {
        for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
            ScheduleData[i] &= ~SchedMask[i];
        }
    }

    //
    // Apply the supplied override schedule to regions of the above schedule.
    //
    if (SchedOverride != NULL) {
        for (i=0 ; i<FRST_SIZE_OF_SCHEDULE_GRID ; ++i) {
            ScheduleData[i] |= SchedOverride[i];
        }
    }

    memcpy((*ppSchedule)+sizeof(SCHEDULE),ScheduleData, FRST_SIZE_OF_SCHEDULE_GRID);
    return Status;
}

DWORD
UpdateConnection(
    PWCHAR      FromNTDSSettingsDn,
    PWCHAR      ToNTDSSettingsDn,
    BOOL        bEnabled,
    DWORD       Options,
    PBYTE       pSchedule
    )
/*++
Routine Description:
     Update the connection parameters.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = ERROR_SUCCESS;
    PWCHAR          CxtionDn            = NULL;
    PWCHAR          Attrs[6];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    PWCHAR          CurEnabled          = NULL;
    DWORD           NoOfCxtions;
    PSCHEDULE       Schedule            = NULL;
    DWORD           ScheduleLen;
    BOOL            bNeedsUpdate        = FALSE;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    WCHAR           OptionsStr[10];
    PWCHAR          OptionsVal          = NULL;
    UINT            i;


    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_FROM_SERVER;
    Attrs[2] = ATTR_ENABLED_CXTION;
    Attrs[3] = ATTR_SCHEDULE;
    Attrs[4] = ATTR_OPTIONS;
    Attrs[5] = NULL;

    wcscpy(SearchFilter, L"(&(");
    wcscat(SearchFilter, ATTR_FROM_SERVER);
    wcscat(SearchFilter, L"=");
    wcscat(SearchFilter, FromNTDSSettingsDn);
    wcscat(SearchFilter, L")");
    wcscat(SearchFilter, CLASS_CXTION);
    wcscat(SearchFilter, L")");

    if (!LdapSearchInit(pLdap,
                    ToNTDSSettingsDn,
                    LDAP_SCOPE_ONELEVEL,
                    SearchFilter,
                    Attrs,
                    0,
                    &FrsSearchContext,
                    FALSE)) {
        return MKDSXE_CXTION_OBJ_UPDATE_FAILED;
    }

    NoOfCxtions = FrsSearchContext.EntriesInPage;

    if (NoOfCxtions == 0) {
        DPRINT0("Error updating; connection not found.\n");
        return MKDSXE_CXTION_NOT_FOUND_UPDATE;
    }

    if (NoOfCxtions > 1) {
        DPRINT0("Error updating; duplicate connections found.\n");
        return MKDSXE_CXTION_DUPS_FOUND_UPDATE;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

       CxtionDn = FindValue(LdapEntry, ATTR_DN);
       CurEnabled = FindValue(LdapEntry, ATTR_ENABLED_CXTION);
       OptionsVal = FindValue(LdapEntry, ATTR_OPTIONS);
       FindBerValue(LdapEntry, ATTR_SCHEDULE, &ScheduleLen, (VOID **)&Schedule);

    }

    LdapSearchClose(&FrsSearchContext);

    DPRINT1("Connection Dn:%ws\n", CxtionDn);
    // Check ATTR_ENABLED_CXTION
    if (bEnabled) {
        if ((CurEnabled == NULL) || wcscmp(CurEnabled, ATTR_TRUE)) {
            AddMod(ATTR_ENABLED_CXTION, ATTR_TRUE, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT0("    New enabledCxtion:TRUE\n");
        }
    } else {
        if ((CurEnabled == NULL) || wcscmp(CurEnabled, ATTR_FALSE)) {
            AddMod(ATTR_ENABLED_CXTION, ATTR_FALSE, &Mod);
            bNeedsUpdate = TRUE;
            DPRINT0("    New enabledCxtion:FALSE\n");
        }
    }

    // Check ATTR_OPTIONS
    if (wcstoul(OptionsVal, NULL, 10) != Options) {

        _itow(Options, OptionsStr, 10);

        AddMod(ATTR_OPTIONS, OptionsStr, &Mod);
        DPRINT1("    options:0x%08x [ ", Options);
        for (i = 1 ; i<NTDSCONN_OPT_NUM;++i) {
            if (NtdsConnOptions[i] & Options) {
                DPRINT1("%ws ", NtdsConnOptionsStr[i]);
            }
        }
        if (Options & FRSCONN_PRIORITY_MASK) {
            DPRINT1("Priority%d ", (Options & FRSCONN_PRIORITY_MASK) >> 28);
        }
        DPRINT0("]\n");
        bNeedsUpdate = TRUE;
    }

    FREE(OptionsVal);

    // Check ATTR_SCHEDULE
    if (pSchedule != NULL) {
        if ((Schedule == NULL) ||
            (FRST_SIZE_OF_SCHEDULE != ScheduleLen) ||
            (memcmp(Schedule, pSchedule, FRST_SIZE_OF_SCHEDULE))) {
            bNeedsUpdate = TRUE;
            AddBerMod(ATTR_SCHEDULE,(PCHAR)pSchedule,FRST_SIZE_OF_SCHEDULE,&Mod);

            DPRINT0("    New schedule:\n");
            PrintSchedule((PSCHEDULE)pSchedule, 0x0F);
        }
    }

    if (bNeedsUpdate) {
        if (bDebugMode) {
          DPRINT1("LStatus = ldap_modify_s(pLdap, %ws, Mod);\n", CxtionDn);
        } else {
            LStatus = ldap_modify_s(pLdap, CxtionDn, Mod);
            if (LStatus != LDAP_SUCCESS) {
                DPRINT2("ERROR - Can't update %ws: %ws\n",
                        CxtionDn, ldap_err2string(LStatus));
                Status = MKDSXE_CXTION_OBJ_UPDATE_FAILED;
            }
        }

    } else {
        DPRINT0("No update required\n");
    }

    FREE(CxtionDn);
    FREE(CurEnabled);
    FREE(Schedule);
    FreeMod(&Mod);
    return Status;
}

DWORD
CreateNewConnection(
    PWCHAR      CxtionName,
    PWCHAR      FromNTDSSettingsDn,
    PWCHAR      ToNTDSSettingsDn,
    BOOL        bEnabled,
    DWORD       Options,
    PBYTE       pSchedule
    )
/*++
Routine Description:
     Create a new connection.
Arguments:

Return Value:
--*/
{
    LDAPMod         **Mod               = NULL;
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = ERROR_SUCCESS;
    PWCHAR          CxtionDn            = NULL;
    WCHAR           OptionsStr[10];
    UINT            i;

    CxtionDn = ExtendDn(ToNTDSSettingsDn, CxtionName);

    DPRINT1("Connection Dn:%ws\n", CxtionDn);
    AddMod(ATTR_CLASS, ATTR_CXTION, &Mod);
    AddMod(ATTR_FROM_SERVER, FromNTDSSettingsDn, &Mod);
    DPRINT1("    fromServer:%ws\n", FromNTDSSettingsDn);

    if (bEnabled) {
        AddMod(ATTR_ENABLED_CXTION, ATTR_TRUE, &Mod);
        DPRINT0("    enabledCxtion:TRUE\n");
    } else {
        AddMod(ATTR_ENABLED_CXTION, ATTR_FALSE, &Mod);
        DPRINT0("    enabledCxtion:FALSE\n");
    }

    //
    // If options are specified then use that options otherwise
    // set options to 0.
    //
    if (Options == 0xffffffff) {
        Options = 0;
    }

    _itow(Options, OptionsStr, 10);

    AddMod(ATTR_OPTIONS, OptionsStr, &Mod);
    DPRINT1("    options:0x%08x [ ", Options);
    for (i = 1 ; i<NTDSCONN_OPT_NUM;++i) {
        if (NtdsConnOptions[i] & Options) {
            DPRINT1("%ws ", NtdsConnOptionsStr[i]);
        }
    }
    if (Options & FRSCONN_PRIORITY_MASK) {
        DPRINT1("Priority%d ", (Options & FRSCONN_PRIORITY_MASK) >> 28);
    }
    DPRINT0("]\n");

    if (pSchedule != NULL) {
        AddBerMod(ATTR_SCHEDULE,(PCHAR)pSchedule,FRST_SIZE_OF_SCHEDULE,&Mod);

        PrintSchedule((PSCHEDULE)pSchedule, 0x0F);
    }

    if (bDebugMode) {
        DPRINT1("LStatus = ldap_add_s(pLdap, %ws, Mod);\n", CxtionDn);
    } else {
        LStatus = ldap_add_s(pLdap, CxtionDn, Mod);

        if (LStatus == LDAP_ALREADY_EXISTS) {
            //
            // If the object already exists then convert the create to an update.
            // This is to allow the user to run the data file with creates twice without
            // generating errors but only fixing the cxtions that have changed.
            //
            Status = UpdateConnection(FromNTDSSettingsDn, ToNTDSSettingsDn,
                                      bEnabled, Options, pSchedule);
        } else if (LStatus != LDAP_SUCCESS) {
            DPRINT2("ERROR - Can't create %ws: %ws\n",
                    CxtionDn, ldap_err2string(LStatus));
            Status = MKDSXE_CXTION_OBJ_CRE_FAILED;
        }
    }


    FREE(CxtionDn);
    FreeMod(&Mod);
    return Status;
}

DWORD
DelConnection(
    PWCHAR      FromNTDSSettingsDn,
    PWCHAR      ToNTDSSettingsDn
    )
/*++
Routine Description:
     Create a new connection.
Arguments:

Return Value:
--*/
{
    DWORD           LStatus             = LDAP_SUCCESS;
    DWORD           Status              = ERROR_SUCCESS;
    PWCHAR          CxtionDn            = NULL;
    PWCHAR          Attrs[3];
    PLDAPMessage    LdapMsg              = NULL;
    PLDAPMessage    LdapEntry            = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           NoOfCxtions;

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_FROM_SERVER;
    Attrs[2] = NULL;

    if (bAffectAll) {
        wcscpy(SearchFilter, CLASS_CXTION);
    } else {
        wcscpy(SearchFilter, L"(&(");
        wcscat(SearchFilter, ATTR_FROM_SERVER);
        wcscat(SearchFilter, L"=");
        wcscat(SearchFilter, FromNTDSSettingsDn);
        wcscat(SearchFilter, L")");
        wcscat(SearchFilter, CLASS_CXTION);
        wcscat(SearchFilter, L")");
    }

    if (!LdapSearchInit(pLdap,
                    ToNTDSSettingsDn,
                    LDAP_SCOPE_ONELEVEL,
                    SearchFilter,
                    Attrs,
                    0,
                    &FrsSearchContext,
                    FALSE)) {
        return MKDSXE_CXTION_DELETE_FAILED;
    }

    NoOfCxtions = FrsSearchContext.EntriesInPage;

    if (NoOfCxtions == 0) {
        DPRINT0("Warning deleting; connection not found.\n");
        return MKDSXE_CXTION_NOT_FOUND_DELETE;
    }

    if (bAffectAll != TRUE) {
        if (NoOfCxtions > 1) {
            DPRINT0("Duplicate connections found. Deleting all.\n");
            Status = MKDSXE_MULTIPLE_CXTIONS_DELETED;
        }
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

       CxtionDn = FindValue(LdapEntry, ATTR_DN);
       DPRINT1("Deleting Dn:%ws\n", CxtionDn);
       if (bDebugMode) {
           DPRINT1("LStatus = ldap_delete_s(pLdap, %ws);\n", CxtionDn);
       } else {
           LStatus = ldap_delete_s(pLdap, CxtionDn);
           if (LStatus != LDAP_SUCCESS) {
               DPRINT2("ERROR - Can't delete %ws: %ws\n",
                       CxtionDn, ldap_err2string(LStatus));
               Status = MKDSXE_CXTION_DELETE_FAILED;
           }
       }
       FREE(CxtionDn);
    }

    LdapSearchClose(&FrsSearchContext);
    return Status;
}

DWORD
DumpConnection(
    PWCHAR      FromNTDSSettingsDn,
    PWCHAR      ToNTDSSettingsDn
    )
/*++
Routine Description:
     Create a new connection.
Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    DWORD           Status              = ERROR_SUCCESS;
    PWCHAR          CxtionDn            = NULL;
    PWCHAR          Attrs[6];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          Val                 = NULL;
    WCHAR           SearchFilter[MAX_PATH];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           NoOfCxtions;
    DWORD           ScheduleLen;
    PSCHEDULE       Schedule            = NULL;
    BOOL            SaveVerbose;
    DWORD           options             = 0;
    UINT            i;

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_FROM_SERVER;
    Attrs[2] = ATTR_ENABLED_CXTION;
    Attrs[3] = ATTR_SCHEDULE;
    Attrs[4] = ATTR_OPTIONS;
    Attrs[5] = NULL;

    if (bAffectAll) {
        wcscpy(SearchFilter, CLASS_CXTION);
    } else {
        wcscpy(SearchFilter, L"(&(");
        wcscat(SearchFilter, ATTR_FROM_SERVER);
        wcscat(SearchFilter, L"=");
        wcscat(SearchFilter, FromNTDSSettingsDn);
        wcscat(SearchFilter, L")");
        wcscat(SearchFilter, CLASS_CXTION);
        wcscat(SearchFilter, L")");
    }

    if (!LdapSearchInit(pLdap,
                    ToNTDSSettingsDn,
                    LDAP_SCOPE_ONELEVEL,
                    SearchFilter,
                    Attrs,
                    0,
                    &FrsSearchContext,
                    FALSE)) {
        return MKDSXE_CXTION_DUMP_FAILED;
    }

    NoOfCxtions = FrsSearchContext.EntriesInPage;

    if (NoOfCxtions == 0) {
        DPRINT0("Error dumping; connection not found.\n");
        return MKDSXE_CXTION_NOT_FOUND_DUMP;
    }

    if (bAffectAll != TRUE) {
        if (NoOfCxtions > 1) {
            printf("Duplicate connections found. Dumping all.\n");
            Status = MKDSXE_MULTIPLE_CXTIONS_DUMPED;
        }
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = LdapSearchNext(pLdap, &FrsSearchContext)) {

       // ATTR_DN
       Val = FindValue(LdapEntry, ATTR_DN);
       printf("Dn:%ws\n", Val);
       FREE(Val);

       // ATTR_FROM_SERVER
       Val = FindValue(LdapEntry, ATTR_FROM_SERVER);
       printf("    fromServer:%ws\n", Val);
       FREE(Val);

       // ATTR_ENABLED_CXTION
       Val = FindValue(LdapEntry, ATTR_ENABLED_CXTION);
       printf("    enabledCxtion:%ws\n", Val);
       FREE(Val);

       // ATTR_OPTIONS
       Val = FindValue(LdapEntry, ATTR_OPTIONS);
       if (Val) {
           options = _wtoi(Val);
           printf("    options:0x%08x [ ", options);
           for (i = 1 ; i<NTDSCONN_OPT_NUM;++i) {
               if (NtdsConnOptions[i] & options) {
                   printf("%ws ", NtdsConnOptionsStr[i]);
               }
           }
           if (options & FRSCONN_PRIORITY_MASK) {
               printf("Priority%d ", (options & FRSCONN_PRIORITY_MASK) >> 28);
           }
           printf("]\n");
       }
       FREE(Val);

       // ATTR_SCHEDULE
       FindBerValue(LdapEntry, ATTR_SCHEDULE, &ScheduleLen, (VOID **)&Schedule);

       if (Schedule) {
           SaveVerbose = bVerboseMode;
           bVerboseMode = TRUE;
           PrintSchedule(Schedule, 0x0F);
           bVerboseMode = SaveVerbose;
           delete(Schedule);
       }
    }

    LdapSearchClose(&FrsSearchContext);
    return Status;
}

VOID
PrintScheduleGrid(
    PUCHAR    ScheduleData,
    DWORD     Mask
    )
/*++
Routine Description:
    Print the schedule grid.

Arguments:
    Schedule
    Mask for each byte.
Return Value:
    NONE
--*/
{
    DWORD  Day, Hour;

    for (Day = 0; Day < 7; ++Day) {
        printf("        Day %1d: ",Day + 1);
        for (Hour = 0; Hour < 24; ++Hour) {
            printf("%1x", *(ScheduleData + (Day * 24) + Hour) & Mask);
        }
        printf("\n");
    }
}


VOID
PrintSchedule(
    PSCHEDULE Schedule,
    DWORD     Mask
    )
/*++
Routine Description:
    Print the schedule.

Arguments:
    Schedule
    Mask for each byte.
Return Value:
    NONE
--*/
{
    PUCHAR          ScheduleData;
    DWORD           i;

    if (bVerboseMode) {
        printf("    schedule:\n");
        for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
            ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
            if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
                continue;
            }
            PrintScheduleGrid(ScheduleData, Mask);
        }
    }
}

PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv =  new PWCHAR[argc + 1];
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = new WCHAR[strlen(argv[argc]) + 1];
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
    }
    return wideargv;
}

VOID
FreeArgv(
    DWORD Argc,
    PWCHAR *Argv
    )
/*++
Routine Description:
    Free the converted arguments.

Arguments:
    Argc    - No of arguments.
    Argv    - Converted arguments returned from ConvertArgv.

Return Value:
    None.
--*/
{

    while (Argc-- >= 1) {
        FREE(Argv[Argc]);
    }
    FREE(Argv);
}

VOID
Usage(
    PWCHAR *Argv
    )
/*++
Routine Description:
    Tell the user how to use the program.

Arguments:
    Argv Argument array.

Return Value:
    None
--*/
{
    printf("%-60s\n", "This tool creates, adds, updates, dumps, and deletes connections between DCs.\n");
    printf("%-60s%ws /?\n", "Help", Argv[0]);
    printf("%-60s%ws /v\n", "Verbose mode.", Argv[0]);
    printf("%-60s%ws /debug\n", "Debug mode. No Writes to the DC.", Argv[0]);
    printf("%-60s%ws /dc\n", "Name of the DC to connect to.", Argv[0]);
    printf("%-60s%ws /name\n", "Name of the connection to be created.", Argv[0]);
    printf("%-60s%ws /[create update del dump]\n", "Operation to be performed.", Argv[0]);
    printf("%-60s%ws /all\n", "Perform the operation on all the connections to the", Argv[0]);
    printf("%-60s%ws \n", "toserver. /all only works with /dump and /del.", Argv[0]);
    printf("%-60s%ws /enable\n", "Connection is enabled.", Argv[0]);
    printf("%-60s%ws /disable\n", "Connection is disabled.", Argv[0]);
    printf("%-60s%ws /options <integer>\n", "Sum of the following options for connection.", Argv[0]);
    printf("%-60s\n", "IsGenerated           = 1");
    printf("%-60s\n", "TwoWaySync            = 2");
    printf("%-60s\n", "OverrideNotifyDefault = 4");
    printf("%-60s\n\n", "UseNotify             = 8");
    printf("%-60s%ws /ignoreschedule\n", "Schedule is ignored during initial sync.", Argv[0]);
    printf("%-60s%ws /priority <0-7>\n", "Sets the priority to be used during intial sync.", Argv[0]);
    printf("%-60s%ws /schedule <Interval> <Stagger> <Offset>\n", "Schedule to create for the connection.", Argv[0]);
    printf("%-60s%ws           <Interval>\n", "The desired interval between each sync with one source.", Argv[0]);
    printf("%-60s%ws                      <Stagger>\n", "Typically number of source DCs.", Argv[0]);
    printf("%-60s%ws                                <Offset>\n", "Typically the number of the source DC.", Argv[0]);
    printf("%-60s%ws /fromsite\n", "Name of the site the 'from' server is in.", Argv[0]);
    printf("%-60s%ws /tosite\n", "Name of the site the 'to' server is in.", Argv[0]);
    printf("%-60s%ws /fromserver\n", "Name of the 'from' server.", Argv[0]);
    printf("%-60s%ws /toserver\n", "Name of the 'to' server.", Argv[0]);
    printf("%-60s%ws /schedoverride\n", "File with 7x24 vector of schedule override data.", Argv[0]);
    printf("%-60s%ws /schedmask\n", "File with 7x24 vector of schedule mask off data.", Argv[0]);
    printf("%-60s\n\n", "  SchedOverride and SchedMask data are formatted as 2 ascii hex digits for each schedule byte");
    printf("%-60s%ws /customschedule\n", "A string of length 7x24 of schedule data. Override and Mask are not applied.", Argv[0]);
    printf("%-60s%ws /replicasetname\n", "Name of the non-sysvol replica set.", Argv[0]);
    printf("%-60s%ws /fromcomputer\n", "Name of the 'from' computer. /replicasetname needed.", Argv[0]);
    printf("%-60s%ws /tocomputer\n", "Name of the 'to' computer. /replicasetname needed.", Argv[0]);
    DPRINT0("\n");
    DPRINT0("mkdsx.exe error return codes\n");
    DPRINT0("0 = Success;\n");
    DPRINT0("1 = Invalid Arguments.\n");
    DPRINT0("2 = Could not bind to the DC.\n");
    DPRINT0("3 = Could not find 'NTDS Settings' object for the to Server.\n");
    DPRINT0("4 = Could not find 'NTDS Settings' object for the from Server.\n");
    DPRINT0("5 = Error creating connection.\n");
    DPRINT0("6 = Connection already exists.\n");
    DPRINT0("7 = Error updating connection.\n");
    DPRINT0("8 = Error updating connection; connection not found.\n");
    DPRINT0("9 = Error updating connection; duplicate connections found.\n");
    DPRINT0("10= Error deleting connection.\n");
    DPRINT0("11= Error deleting connection; connection not found.\n");
    DPRINT0("12= Deleting multiple connection.\n");
    DPRINT0("13= Error dumping connection.\n");
    DPRINT0("14= Error dumping; connection not found.\n");
    DPRINT0("15= Dumping duplicate connections.\n");
    DPRINT0("\n");
    fflush(stdout);
}

DWORD __cdecl
main(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    Exits with 0 if everything went okay. Otherwise returns a error code.

    MKDSXE_SUCCESS                  = Success;
    MKDSXE_BAD_ARG                  = Invalid Arguments.
    MKDSXE_CANT_BIND                = Could not bind to the DC.
    MKDSXE_NO_T0_NTDS_SETTINGS      = Could not find "NTDS Settings" object for the to Server.
    MKDSXE_NO_FROM_NTDS_SETTINGS    = Could not find "NTDS Settings" object for the from Server.
    MKDSXE_CXTION_OBJ_CRE_FAILED    = Error creating connection.
    MKDSXE_CXTION_EXISTS            = Connection already exists.  (unused)
    MKDSXE_CXTION_OBJ_UPDATE_FAILED = Error updating connection.
    MKDSXE_CXTION_NOT_FOUND_UPDATE  = Error updating connection; connection not found.
    MKDSXE_CXTION_DUPS_FOUND_UPDATE = Error updating connection; duplicate connections found.
    MKDSXE_CXTION_DELETE_FAILED     = Error deleting connection.
    MKDSXE_CXTION_NOT_FOUND_DELETE  = Error deleting connection; connection not found.
    MKDSXE_MULTIPLE_CXTIONS_DELETED = Deleting multiple connection.
    MKDSXE_CXTION_DUMP_FAILED       = Error dumping connection.
    MKDSXE_CXTION_NOT_FOUND_DUMP    = Error dumping; connection not found.
    MKDSXE_MULTIPLE_CXTIONS_DUMPED  = Dumping duplicate connections.

--*/
{
    PWCHAR     *Argv;
    ULONG      i, j;
    ULONG      OptLen;
    DWORD      Status             = ERROR_SUCCESS;
    PWCHAR     FromSite           = NULL;
    PWCHAR     FromServer         = NULL;
    PWCHAR     ToSite             = NULL;
    PWCHAR     ToServer           = NULL;
    PWCHAR     ReplicaSetName     = NULL;
    PWCHAR     FromComputer       = NULL;
    PWCHAR     ToComputer         = NULL;
    PWCHAR     ToNTDSSettingsDn   = NULL; // These parameters are settingsDn in sysvol replica sets
    PWCHAR     FromNTDSSettingsDn = NULL; // and memberDn in non sysvol replica sets.
    PWCHAR     CxtionName         = NULL;
    PBYTE      pSchedule          = NULL;
    PBYTE      CustSchedData      = NULL;
    DWORD      Interval           = 1;
    DWORD      Stagger            = 1;
    DWORD      Offset             = 0;
    DWORD      Options            = 0xffffffff;
    DWORD      Priority           = 0xffffffff;
    BOOL       bEnabled           = TRUE;
    BOOL       bIgnoreSchedule    = FALSE;
    BOOL       bCreateConnection  = FALSE;
    BOOL       bUpdateConnection  = FALSE;
    BOOL       bDelConnection     = FALSE;
    BOOL       bDumpConnection    = FALSE;
    BOOL       bSchedule          = FALSE;
    PWCHAR     Switch             = NULL;
    PWCHAR     CustomSchedule     = NULL;
    DWORD      DataByte;

#define  ArgMatch(_a, _b) (wcsstr(_a, _b) == (_a))

    Argv = ConvertArgv(argc, argv);

    if (argc <= 1) {
        Usage(Argv);
        FreeArgv(argc,Argv);
        return MKDSXE_BAD_ARG;
    }

    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        _wcslwr(Argv[i]);
        Switch = Argv[i];

        if ((*Switch != L'/') && (*Switch != L'-')) {
            Usage(Argv);
            return MKDSXE_BAD_ARG;
        }
        ++Switch;   // jump over -


        if (OptLen == 2 && ArgMatch(Switch, L"v")) {
            bVerboseMode=TRUE;

        } else if (OptLen == 3 && ArgMatch(Switch, L"vs")) {
                bVerboseModeSearch=TRUE;

        } else if (OptLen == 2 && ArgMatch(Switch, L"?")) {
            Usage(Argv);
            FreeArgv(argc,Argv);
            return MKDSXE_SUCCESS;

        } else if (OptLen == 6 && ArgMatch(Switch, L"debug")) {
            bDebugMode = TRUE;
            bVerboseMode=TRUE;

        } else if (OptLen == 3 && (i+1 < argc) &&  ArgMatch(Switch, L"dc")) {
            i+=1;
            DcName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(DcName, Argv[i]);

        } else if (OptLen == 9 && (i+1 < argc) && ArgMatch(Switch, L"fromsite")) {
            i+=1;
            FromSite = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(FromSite, Argv[i]);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"fromserver")) {
            i+=1;
            FromServer = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(FromServer, Argv[i]);

        } else if (OptLen == 7 && (i+1 < argc) && ArgMatch(Switch, L"tosite")) {
            i+=1;
            ToSite = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ToSite, Argv[i]);

        } else if (OptLen == 9 && (i+1 < argc) && ArgMatch(Switch, L"toserver")) {
            i+=1;
            ToServer = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ToServer, Argv[i]);

        } else if (OptLen == 15 && (i+1 < argc) && ArgMatch(Switch, L"replicasetname")) {
            i+=1;
            ReplicaSetName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ReplicaSetName, Argv[i]);

        } else if (OptLen == 13 && (i+1 < argc) && ArgMatch(Switch, L"fromcomputer")) {
            i+=1;
            FromComputer = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(FromComputer, Argv[i]);

        } else if (OptLen == 11 && (i+1 < argc) && ArgMatch(Switch, L"tocomputer")) {
            i+=1;
            ToComputer = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(ToComputer, Argv[i]);

        } else if (OptLen == 5 && (i+1 < argc) && ArgMatch(Switch, L"name")) {
            i+=1;
            CxtionName = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(CxtionName, Argv[i]);

        } else if (OptLen == 15 && (i+1 < argc) && ArgMatch(Switch, L"customschedule")) {
            i+=1;
            if (wcslen(Argv[i]) != FRST_SIZE_OF_SCHEDULE_GRID) {
                printf("Invalid custom schedule - Expecting %d bytes,  Actual was %d bytes\n",
                       FRST_SIZE_OF_SCHEDULE_GRID, wcslen(Argv[i]));
                return MKDSXE_BAD_ARG;
            }

            bSchedule = TRUE;
            CustomSchedule = new WCHAR[wcslen(Argv[i])+1];
            wcscpy(CustomSchedule, Argv[i]);

            //
            // Convert to binary.
            //
            CustSchedData = new BYTE[FRST_SIZE_OF_SCHEDULE_GRID];
            if (CustSchedData == NULL) {
                printf("Error allocating memory.\n");
                return MKDSXE_BAD_ARG;
            }

            for (j=0; j<FRST_SIZE_OF_SCHEDULE_GRID; j++) {
                if (swscanf(&CustomSchedule[j], L"%1x", &DataByte) != 1) {
                    CustomSchedule[j+1] = L'\0';
                    printf("Invalid custom schedule - Invalid hex data (%ws) for schedule byte %d.\n",
                           &CustomSchedule[j], i);
                    return MKDSXE_BAD_ARG;
                }
                CustSchedData[j] = (BYTE) DataByte;
            }
            //PrintScheduleGrid(CustSchedData, 0x0F);


        } else if (OptLen == 9 && (i+3 < argc) && ArgMatch(Switch, L"schedule")) {

            bSchedule = TRUE;
            Interval = _wtoi(Argv[i+1]);
            Stagger = _wtoi(Argv[i+2]);
            Offset = _wtoi(Argv[i+3]);
            i+=3;

        } else if ((OptLen == 10) && (i+1 < argc) && ArgMatch(Switch, L"schedmask")) {

            SchedMask = ReadScheduleFile(Argv[i+1]);
            if (SchedMask == NULL) {
                FreeArgv(argc,Argv);
                return MKDSXE_BAD_ARG;
            } else {
                if (bVerboseMode) {
                    printf("    schedmask:\n");
                    PrintScheduleGrid(SchedMask, 0x0F);
                }
            }
            i+=1;

        } else if ((OptLen == 14) && (i+1 < argc) && ArgMatch(Switch, L"schedoverride")) {

            SchedOverride = ReadScheduleFile(Argv[i+1]);
            if (SchedOverride == NULL) {
                FreeArgv(argc,Argv);
                return MKDSXE_BAD_ARG;
            } else {
                if (bVerboseMode) {
                    printf("    schedoverride:\n");
                    PrintScheduleGrid(SchedOverride, 0x0F);
                }
            }
            bSchedule = TRUE;
            i+=1;

        } else if (OptLen == 8 && (i+1 < argc) && ArgMatch(Switch, L"options")) {
            i+=1;
            Options = _wtoi(Argv[i]);
            //
            // Mask off all the bits of option that are not supported.
            //
            Options = Options & MKDSXE_VALID_CONN_OPTIONS_MASK;

        } else if (OptLen == 9 && (i+1 < argc) && ArgMatch(Switch, L"priority")) {
            i+=1;
            Priority = _wtoi(Argv[i]);
            if (Priority > MKDSXE_MAX_CONN_PRIORITY) {
                Usage(Argv);
                FreeArgv(argc,Argv);
                return MKDSXE_BAD_ARG;
            }

        } else if (OptLen == 15 && ArgMatch(Switch, L"ignoreschedule")) {
            bIgnoreSchedule = TRUE;

        } else if (OptLen == 7 && ArgMatch(Switch, L"enable")) {
            bEnabled = TRUE;

        } else if (OptLen == 8 && ArgMatch(Switch, L"disable")) {
            bEnabled = FALSE;

        } else if (OptLen == 7 && ArgMatch(Switch, L"create")) {
            bCreateConnection = TRUE;

        } else if (OptLen == 7 && ArgMatch(Switch, L"update")) {
            bUpdateConnection = TRUE;

        } else if (OptLen == 4 && ArgMatch(Switch, L"del")) {
            bDelConnection = TRUE;

        } else if (OptLen == 5 && ArgMatch(Switch, L"dump")) {
            bDumpConnection = TRUE;

        } else if (OptLen == 4 && ArgMatch(Switch, L"all")) {
            bAffectAll = TRUE;

        } else {
            Usage(Argv);
            FreeArgv(argc,Argv);
            return MKDSXE_BAD_ARG;
        }
    }

    FreeArgv(argc,Argv);

    if (ReplicaSetName != NULL) {
        if (bAffectAll) {
            if (  //DcName == NULL ||
                ToComputer == NULL) {
                Usage(Argv);
                return MKDSXE_BAD_ARG;
            }
        } else if (  //DcName == NULL ||
                   FromComputer == NULL ||
                   ToComputer == NULL) {
                Usage(Argv);
                return MKDSXE_BAD_ARG;
        }

    } else {
        if (bAffectAll) {
            if (  // DcName == NULL ||
                ToSite == NULL || ToServer == NULL ) {
                Usage(Argv);
                return MKDSXE_BAD_ARG;
            }
        } else if (  // DcName == NULL ||
                FromSite == NULL || FromServer == NULL ||
                ToSite == NULL || ToServer == NULL ) {
                Usage(Argv);
                return MKDSXE_BAD_ARG;
        }

    }
    Status = BindToDC(DcName, &pLdap);
    if (Status != ERROR_SUCCESS) {
        return MKDSXE_CANT_BIND;
    }

    if (ReplicaSetName != NULL) {
        Status = FormMemberDn(ReplicaSetName, ToComputer, &ToNTDSSettingsDn);
    } else {
        Status = FormNTDSSettingsDn(ToSite, ToServer, &ToNTDSSettingsDn);
    }

    if (Status != ERROR_SUCCESS) {
        return MKDSXE_NO_T0_NTDS_SETTINGS;
    }

    //
    // We need the from server only if Affectall is not set.
    //
    if (!bAffectAll) {
        if (ReplicaSetName != NULL) {
            Status = FormMemberDn(ReplicaSetName, FromComputer, &FromNTDSSettingsDn);
        } else {
            Status = FormNTDSSettingsDn(FromSite, FromServer, &FromNTDSSettingsDn);
        }

        if (Status != ERROR_SUCCESS) {
            return MKDSXE_NO_FROM_NTDS_SETTINGS;
        }
    }

    //
    // /all does not make sense with create.
    //
    if ((bAffectAll) && (bCreateConnection || bUpdateConnection) ) {
        Usage(Argv);
        DPRINT0("Error - /all can not be used with  /create or /update.\n");
        return MKDSXE_BAD_ARG;
    }

    //
    // Merge the priority with options attribute if supplied.
    //

    if (Priority != 0xffffffff) {
        if (Options == 0xffffffff) {
            Options = (Priority << 28);
        } else {
            Options = Options | (Priority << 28);
        }
    }

    //
    // Merge the ignore schedule bit with options attribute if supplied.
    //

    if (bIgnoreSchedule == TRUE) {
        if (Options == 0xffffffff) {
            Options = NTDSCONN_OPT_IGNORE_SCHEDULE_MASK;
        } else {
            Options = Options | NTDSCONN_OPT_IGNORE_SCHEDULE_MASK;
        }
    }

    if (bCreateConnection) {
        if (CxtionName == NULL) {
            DPRINT0("Need a cxtion name to create a new connection\n");
            Status = MKDSXE_BAD_ARG;
        } else {
            if (bSchedule) {
                BuildSchedule(&pSchedule, Interval, Stagger, Offset, CustSchedData);
                Status = CreateNewConnection(CxtionName, FromNTDSSettingsDn,
                                             ToNTDSSettingsDn, bEnabled, Options, pSchedule);
            } else {
                Status = CreateNewConnection(CxtionName, FromNTDSSettingsDn,
                                             ToNTDSSettingsDn, bEnabled, Options, NULL);
            }
        }
    } else if (bUpdateConnection) {
        if (bSchedule) {
            BuildSchedule(&pSchedule, Interval, Stagger, Offset, CustSchedData);
            Status = UpdateConnection(FromNTDSSettingsDn, ToNTDSSettingsDn,
                                      bEnabled, Options, pSchedule);
        } else {
            Status = UpdateConnection(FromNTDSSettingsDn, ToNTDSSettingsDn,
                                      bEnabled, Options, NULL);
        }
    } else if (bDelConnection) {
        Status = DelConnection(FromNTDSSettingsDn, ToNTDSSettingsDn);
    } else if (bDumpConnection) {
        Status = DumpConnection(FromNTDSSettingsDn, ToNTDSSettingsDn);
    }

    ldap_unbind(pLdap);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\ntfrsapi\frsapi_c_stub.c ===
#include "frsapi_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\ntfrsupg\ntfrsupg.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    ntfrsupg.c

Abstract:
    Upgrade ntfrs.

    Supports upgrading previous IDS (1717) to current IDS (~1770)

    Basically, it builds the sysvol hierarchy, adjusts the netlogon
    share, and sets up the registry so the service can create the
    sysvols. There is no seeding.

Author:
    Isaac Heizer and Billy J. Fuller 9-Mar-1998

Environment
    User mode winnt

--*/

extern "C" {
#include <ntreppch.h>
#pragma  hdrstop
#include    <lm.h>
#include    <netcan.h>
#include    <icanon.h>
#include    <dsgetdc.h>
#include    <dsrole.h>
#include    <frs.h>
#include    <tablefcn.h>
}

/*
 * This program performs the steps necessary to configure NTFRS on a DC, prepared
 * to support the system volumes.
 *
 * It was created as an interim tool to support the initialization of NTFRS on a DC
 *  which was running NT5 generation software before NTFRS was available.  After upgrading
 *  that DC with the latest NT5 version, this tool must be manually run to complete the
 *  initialization of NTFRS and system volumes.
 */


WCHAR SysVolShare[] = L"SYSVOL";
WCHAR SysVolRemark[] = L"System Volume Share (Migrated)";
WCHAR FRSSysvol[] = L"System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Sysvol";
WCHAR FRSParameters[] = L"System\\CurrentControlSet\\Services\\NtFrs\\Parameters";

#define DSROLEP_FRS_COMMAND     L"Replica Set Command"
#define DSROLEP_FRS_NAME        L"Replica Set Name"
#define DSROLEP_FRS_TYPE        L"Replica Set Type"
#define DSROLEP_FRS_PRIMARY     L"Replica Set Primary"
#define DSROLEP_FRS_STAGE       L"Replica Set Stage"
#define DSROLEP_FRS_ROOT        L"Replica Set Root"
#define DSROLEP_FRS_CREATE      L"Create"
#define DSROLEP_FRS_DELETE      L"Delete"
#define DSROLEP_FRS_COMMITTED   L"SysVol Information is Committed"
#define DSROLEP_FRS_LONG_NAME   L"File Replication Service"
#define DSROLEP_FRS_SHORT_NAME  L"NtFrs"
#define DSROLEP_FRS_RECOVERY    L"Catastrophic Restore at Startup"

#define FREE(_x_) { if (_x_) { free(_x_); (_x_) = NULL; } }

//
// These are the static directories created within a system volume share
//
LPWSTR StaticSysvolDirs[] = {
    L"sysvol",
    L"domain",
    L"staging",
    L"staging areas",

    L"staging\\domain",
    0
};

//
// Print out the usage message
//
void
Usage( int argc, char *argv[] )
{
    fprintf( stderr, "Usage: %s [-D] sysvol\n\n", argv[0] );
    fprintf( stderr, "       -D  this is the first upgraded DC in this domain\n\n" );
    fprintf( stderr, "       sysvol is the path for the system volume share.\n" );
    fprintf( stderr, "       The system volume must reside on NTFS version 5.\n" );
    fprintf( stderr, "       \n");
    fprintf( stderr, "       After running this program with the -D option, copy\n");
    fprintf( stderr, "       the files in the scripts directory from the old\n");
    fprintf( stderr, "       system volume into the scripts directory in the new\n");
    fprintf( stderr, "       domain system volume. Otherwise, wait for replication to\n");
    fprintf( stderr, "       populate the scripts directory in the new domain\n");
    fprintf( stderr, "       system volume.\n");
    fprintf( stderr, "       \n");
    fprintf( stderr, "Usage: %s [-Y] -RESTORE\n\n", argv[0] );
    fprintf( stderr, "       -RESTORE Delete replicated directories.\n");
    fprintf( stderr, "       -Y Delete directories without prompting.\n");
    fprintf( stderr, "       \n");
    fprintf( stderr, "       WARNING: FILE REPLICATION SERVICE STATE WILL BE DELETED!\n");
    fprintf( stderr, "       WARNING: ALL REPLICATED DIRECTORIES WILL BE DELETED!\n");
    fprintf( stderr, "       When run with the -RESTORE option, the contents of\n");
    fprintf( stderr, "       the replicated directories and the service's state \n");
    fprintf( stderr, "       are deleted with the expectation that the data will \n");
    fprintf( stderr, "       be supplied by a replication partner at a later time. \n");
    fprintf( stderr, "       The user is prompted for each replicated directory.\n");
    fprintf( stderr, "       The contents of the replicated directory are not deleted\n");
    fprintf( stderr, "       if you type n. The contents are deleted if you type y.\n");
    fprintf( stderr, "       Type n if there are no replication partners.\n");
}

//
// Print 'text' and render 'code' into an error message
//
void
errmsg( char *text, ULONG code )
{
    int i;
    char msg[ 100 ];

    i = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );

    if( i )
        fprintf( stderr, "%s: %s\n", text ? text : "", msg );
    else
        fprintf( stderr, "%s: error %d\n", text ? text : "", code );
}

//
// Print unicode 'text' and render 'code' into an error message
//
void
errmsg( LPWSTR text, ULONG code )
{
    int i;
    WCHAR msg[ 100 ];

    i = FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg) / sizeof(WCHAR),
               NULL );

    if( i )
        fprintf( stderr, "%ws: %ws\n", text ? text : L"", msg );
    else
        fprintf( stderr, "%ws: error %d\n", text ? text : L"", code );
}

//
// Write a string value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, LPWSTR Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if (!WIN_SUCCESS(retval)) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_SZ,
                    (BYTE *)Value,
                    (wcslen( Value ) + 1) * sizeof( WCHAR )
                 );

        if (!WIN_SUCCESS(retval)) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Write a DWORD value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, DWORD Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if (!WIN_SUCCESS(retval)) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_DWORD,
                    (BYTE *)&Value,
                    sizeof( Value )
                 );

        if (!WIN_SUCCESS(retval)) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Make sure that 'DirName' exists.  Create it if it doesn't
//
BOOLEAN
EnsureDirectoryExists( LPWSTR DirName )
{
    DWORD retval;

    retval = GetFileAttributes( DirName );

    if( retval == 0xFFFFFFFF ) {
        printf( "    Create directory: %ws\n", DirName );
        if( !CreateDirectory( DirName, NULL ) ) {
            retval = GetLastError();
            errmsg( DirName, GetLastError() );
            return FALSE;
        }
    } else if( !(retval & FILE_ATTRIBUTE_DIRECTORY) ) {
        fprintf( stderr, "Not a directory: %ws\n", DirName );
        return FALSE;
    }

    return TRUE;
}




BOOLEAN
LinkAToB( LPWSTR DirA, LPWSTR DirB )
{
    NTSTATUS Status;
    BOOLEAN RetValue = FALSE;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING UnicodeNameB;
    UNICODE_STRING DosNameB;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer;
    USHORT ReparseDataLength;
    PWSTR  FreeBuffer = NULL;

    if( !EnsureDirectoryExists( DirA ) ||
        !EnsureDirectoryExists( DirB ) ) {

        goto CLEANUP;
    }

    Handle = CreateFile( DirA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                        NULL
                        );

    if (!HANDLE_IS_VALID(Handle)) {
        fprintf( stderr, "Unable to open %ws", DirA );
        errmsg( (LPWSTR)NULL, GetLastError() );
        goto CLEANUP;
    }

    //
    // Get the NT path name of the directory to which we want to link
    //
    if( !RtlDosPathNameToNtPathName_U(
                            DirB,
                            &UnicodeNameB,
                            NULL,
                            NULL
                            )) {
        errmsg( DirB, GetLastError() );
        goto CLEANUP;
    }

    //
    // Remember the unicode buffer to free.
    //
    FreeBuffer = UnicodeNameB.Buffer;

    RtlInitUnicodeString( &DosNameB, DirB);

    //
    //  Set the reparse point with mount point or symbolic link tag and determine
    //  the appropriate length of the buffer.
    //

    ReparseDataLength = (USHORT) ((FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) -
                        REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        UnicodeNameB.Length + sizeof(UNICODE_NULL) +
                        DosNameB.Length + sizeof(UNICODE_NULL));

    //
    //  Allocate a buffer to set the reparse point.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)LocalAlloc(  LPTR,
                                                    REPARSE_DATA_BUFFER_HEADER_SIZE +
                                                    ReparseDataLength
                                                    );

    if (ReparseBufferHeader == NULL) {
        errmsg( "Unable to allocate reparse buffer", GetLastError() );
        goto CLEANUP;
    }

    ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;

    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = UnicodeNameB.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = UnicodeNameB.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = DosNameB.Length;
    RtlCopyMemory(
        ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
        UnicodeNameB.Buffer,
        UnicodeNameB.Length
        );
    RtlCopyMemory(
        (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
        UnicodeNameB.Length + sizeof(UNICODE_NULL),
        DosNameB.Buffer,
        DosNameB.Length
        );

    Status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SET_REPARSE_POINT,
                 ReparseBufferHeader,
                 REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseBufferHeader->ReparseDataLength,
                 NULL,                // no output buffer
                 0                    // output buffer length
                 );

    if (!NT_SUCCESS(Status)) {

        switch( Status ) {
        case STATUS_VOLUME_NOT_UPGRADED:
        case STATUS_INVALID_DEVICE_REQUEST:
            printf( "%ws must be on an NT5 NTFS volume.\n", DirA );
            break;

        default:
            printf( "Unable to set reparse point data, status %X", Status );
            break;
        }
        goto CLEANUP;
    }

    //
    // SUCCESS
    //
    RetValue = TRUE;

CLEANUP:
    if ((HLOCAL)ReparseBufferHeader) {
        LocalFree((HLOCAL)ReparseBufferHeader);
    }

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    FRS_CLOSE(Handle);

    return RetValue;
}

//
// Create the system volume subtree
//
BOOLEAN
CreateSysVolTree( LPWSTR SysVolPath, BOOLEAN IsFirstDCInDomain , PWCHAR domainName)
{
    DWORD i;
    WCHAR bufA[ MAX_PATH ];
    WCHAR bufB[ MAX_PATH ];

    printf( "Checking %ws subtree at %ws\n", SysVolShare, SysVolPath );

    if( !EnsureDirectoryExists( SysVolPath) ) {
        return FALSE;
    }

    //
    // First create the static system volume directories
    //
    for( i = 0; StaticSysvolDirs[i]; i++ ) {
        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\" );
        wcscat( bufA, StaticSysvolDirs[i]  );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    //
    // Create the DNS domain link for the sysvol share
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\sysvol\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the DNS domain link in the staging area
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\staging areas\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\staging\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Finally, if we are the first DC initialized in this domain,
    //  we need to create the scripts directory
    //
    if( IsFirstDCInDomain ) {

        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\domain\\scripts" );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Create the system volume share.
//
BOOLEAN
CreateSysVolShare( LPWSTR SysVolPath )
{
    DWORD dwType, retval;
    SHARE_INFO_2 si2, *psi2;
    WCHAR SysVol[ MAX_PATH ];

    printf( "Creating system volume share:\n" );

    //
    // Blow away the current sysvol share if it exists
    //
    retval = NetShareGetInfo( NULL, SysVolShare, 2, (LPBYTE *)&psi2 );

    if( retval == NO_ERROR ) {
        if( psi2->shi2_type != STYPE_DISKTREE ) {
            fprintf( stderr, "%ws is shared, but is not a disk share!\n", SysVolShare );
            return FALSE;
        }

        printf( "    Delete current share: %ws=%ws\n", psi2->shi2_netname, psi2->shi2_path );

        NetApiBufferFree( psi2 );

        //
        // Try to delete this share
        //
        retval = NetShareDel( NULL, SysVolShare, 0 );
        if( retval != NO_ERROR ) {
            errmsg( "Unable to delete sysvol share", retval );
            return FALSE;
        }
    }
    //
    // sysvol share
    //
    wcscpy( SysVol, SysVolPath );
    wcscat( SysVol, L"\\sysvol" );

    //
    // Add the new sysvol share
    //
    si2.shi2_netname = SysVolShare;
    si2.shi2_type = STYPE_DISKTREE;
    si2.shi2_remark = SysVolRemark;
    si2.shi2_permissions = 0;
    si2.shi2_max_uses = (DWORD)-1;
    si2.shi2_current_uses = 0;
    si2.shi2_path = SysVol;
    si2.shi2_passwd = 0;

    printf( "    Add share: %ws=%ws\n", SysVolShare, SysVol );
    retval = NetShareAdd( NULL, 2, (LPBYTE)&si2, &dwType );

    if( retval != NO_ERROR ) {
        errmsg( "Unable to share new sysvol share", retval );
        return FALSE;
    }

    //
    // Add the registry key telling netlogon to share this out as the system volume share
    //
    printf( "    Add netlogon sysvol registry key\n" );

    return WriteRegistry( L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                          L"SysVol",
                          SysVol
                        );
}

//
// Add the registry keys needed for NTFRS.  Do what DcPromo would have done
//
BOOLEAN
AddRegKeys(
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot )
{
    WCHAR   KeyName[512];

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Sysvol key + values
    //
    wcscpy( KeyName, L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol\\" );
    wcscat( KeyName, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_COMMAND, DSROLEP_FRS_CREATE );
    WriteRegistry( KeyName, DSROLEP_FRS_NAME, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_TYPE, ReplicaSetType );
    WriteRegistry( KeyName, DSROLEP_FRS_PRIMARY, (DWORD)ReplicaSetPrimary );
    WriteRegistry( KeyName, DSROLEP_FRS_ROOT, ReplicaSetRoot );
    WriteRegistry( KeyName, DSROLEP_FRS_STAGE, ReplicaSetStage );

    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
CommitRegKeys(
    VOID )
{
    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Commit both sysvols
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                  DSROLEP_FRS_COMMITTED, (DWORD)1 );
    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
DeleteRegKeys(
    VOID )
{
    DWORD WStatus;
    HKEY  HKey = 0;
    WCHAR KeyBuf[MAX_PATH + 1];
    BOOLEAN RetValue = FALSE;

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        errmsg("Cannot open registry", WStatus);
        goto CLEANUP;
    }
    WStatus = RegDeleteValue(HKey, DSROLEP_FRS_COMMITTED);
    if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_FILE_NOT_FOUND) {
        errmsg("Cannot delete registry value", WStatus);
        goto CLEANUP;
    }
    //
    // Delete the subkeys
    //
    do {
        WStatus = RegEnumKey(HKey, 0, KeyBuf, MAX_PATH + 1);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = RegDeleteKey(HKey, KeyBuf);
        }
    } while (WIN_SUCCESS(WStatus));
    if (WStatus != ERROR_NO_MORE_ITEMS) {
        errmsg("Cannot delete registry key", WStatus);
        goto CLEANUP;
    }
    //
    // SUCCESS
    //
    RetValue = TRUE;

CLEANUP:
    if (HKey) {
        RegCloseKey(HKey);
    }
    return RetValue;
}

//
// Set FRS to auto start
//
BOOLEAN
SetFRSAutoStart( void )
{
    SC_HANDLE   ServiceHandle = NULL;
    SC_HANDLE   SCMHandle = NULL;
    BOOLEAN     RetValue = FALSE;

    printf( "Set NTFRS to Auto Start\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        goto CLEANUP;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        goto CLEANUP;
    }

    //
    // Service starts automatically at startup
    //
    if (!ChangeServiceConfig(ServiceHandle,
                             SERVICE_NO_CHANGE,
                             SERVICE_AUTO_START,
                             SERVICE_NO_CHANGE,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             DSROLEP_FRS_LONG_NAME)) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        goto CLEANUP;
    }

    //
    // SUCCESS
    //
    RetValue = TRUE;

CLEANUP:
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }
    return RetValue;
}

//
// Start FRS
//
BOOLEAN
StartFRS( void )
{
    DWORD           WStatus;
    SC_HANDLE       ServiceHandle = NULL;
    SC_HANDLE       SCMHandle = NULL;
    SERVICE_STATUS  ServiceStatus;
    BOOLEAN RetValue = FALSE;

    printf( "Start NTFRS\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        goto CLEANUP;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        goto CLEANUP;
    }

    //
    // stop the service
    //
    ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        //
        // May be shutting down; retry in a bit
        //
        Sleep(3 * 1000);
        if (!StartService(ServiceHandle, 0, NULL)) {
            WStatus = GetLastError();
            if (WStatus != ERROR_SERVICE_ALREADY_RUNNING) {
                errmsg("Can't start NtFrs", WStatus);
                goto CLEANUP;
            }
        }
    }

    //
    // SUCCESS
    //
    RetValue = TRUE;

CLEANUP:
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }
    return RetValue;
}

//
// Stop FRS
//
BOOLEAN
StopFRS( void )
{
    DWORD           WStatus;
    SC_HANDLE       ServiceHandle;
    SC_HANDLE       SCMHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't stop NtFrs", GetLastError());
        return FALSE;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't Stop NtFrs", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(SCMHandle);

    //
    // stop the service
    //
STOP_AGAIN:
    if (!ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus)) {
        WStatus = GetLastError();
        if (WStatus != ERROR_SERVICE_REQUEST_TIMEOUT &&
            WStatus != ERROR_SERVICE_NOT_ACTIVE) {
            errmsg("Can't Stop NtFrs", WStatus);
            CloseServiceHandle(ServiceHandle);
            return FALSE;
        }
    }
    if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
        errmsg("Can't Stop NtFrs", GetLastError());
        CloseServiceHandle(ServiceHandle);
        return FALSE;
    }
    if (ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) {
        Sleep(5 * 1000);
        goto STOP_AGAIN;
    }
    if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
        fprintf(stderr,
                "Can't stop NtFrs; NtFrs is in state %d\n",
                ServiceStatus.dwCurrentState);
        CloseServiceHandle(ServiceHandle);
        return FALSE;
    }

    //
    // SUCCESS
    //
    CloseServiceHandle(ServiceHandle);
    return TRUE;
}


////////
//
// BEGIN code that processes -restore option
//
///////


ULONG
UpgSetLastNTError(
    NTSTATUS Status
    )
/*++

Routine Description:

    Translate NT status codes to WIN32 status codes for those functions that
    make NT calls.  Map a few status values differently.

Arguments:

    Status - the NTstatus to map.

Return Value:

    The WIN32 status.  Also puts this into LastError.

--*/
{
    ULONG WStatus;

    //
    // Do the standard system mapping first.
    //
    WStatus = RtlNtStatusToDosError( Status );
    SetLastError( WStatus );
    return WStatus;
}




BOOL
UpgGetFileInfoByHandle(
    IN PWCHAR Name,
    IN HANDLE Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo
    )
/*++

Routine Description:

    Return the network file info for the specified handle.

Arguments:

    Name - File's name for printing error messages

    Handle - Open file handle

    FileOpenInfo - Returns the file FILE_NETWORK_OPEN_INFORMATION data.

Return Value:

    TRUE  - FileOpenInfo contains the file's info
    FALSE - Contents of FileOpenInfo is undefined

--*/
{
    DWORD           WStatus;
    NTSTATUS        NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Return some file info
    //
    NtStatus = NtQueryInformationFile(Handle,
                                      &IoStatusBlock,
                                      FileOpenInfo,
                                      sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                      FileNetworkOpenInformation);
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = UpgSetLastNTError(NtStatus);
        return FALSE;
    }
    return TRUE;
}


BOOL
UpgSetFileAttributes(
    PWCHAR  Name,
    HANDLE  Handle,
    ULONG   FileAttributes
    )
/*++
Routine Description:
    This routine sets the file's attributes

Arguments:
    Name        - for error messages
    Handle      - Supplies a handle to the file that is to be marked for delete.
    Attributes  - Attributes for the file
Return Value:
    TRUE - attributes have been set
    FALSE
--*/
{
    IO_STATUS_BLOCK         IoStatus;
    FILE_BASIC_INFORMATION  BasicInformation;
    DWORD                   WStatus;
    NTSTATUS                NtStatus;

    //
    // Set the attributes
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = FileAttributes | FILE_ATTRIBUTE_NORMAL;
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    &BasicInformation,
                                    sizeof(BasicInformation),
                                    FileBasicInformation);
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = UpgSetLastNTError(NtStatus);
        return FALSE;
    }
    return TRUE;
}




BOOL
UpgResetAttributesForDelete(
    PWCHAR  Name,
    HANDLE  Handle
    )
/*++
Routine Description:
    This routine turns off the attributes that prevent deletion

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    None.
--*/
{
    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    //
    // Get the file's attributes
    //
    if (!UpgGetFileInfoByHandle(Name, Handle, &FileInfo)) {
        return FALSE;
    }

    //
    // Turn off the access attributes that prevent deletion and write
    //
    if (FileInfo.FileAttributes & NOREPL_ATTRIBUTES) {
        if (!UpgSetFileAttributes(Name, Handle,
                                  FileInfo.FileAttributes & ~NOREPL_ATTRIBUTES)) {
            return FALSE;
        }
    }
    return TRUE;
}


DWORD
UpgEnumerateDirectory(
    IN HANDLE   DirectoryHandle,
    IN PWCHAR   DirectoryName,
    IN DWORD    DirectoryLevel,
    IN DWORD    DirectoryFlags,
    IN PVOID    Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Enumerate the directory identified by DirectoryHandle, passing each
    directory record to Function. If the record is for a directory,
    call Function before recursing if ProcessBeforeCallingFunction
    is TRUE.

    Function controls the enumeration of the CURRENT directory
    by setting ContinueEnumeration to TRUE (continue) or
    FALSE (terminate).

    Function controls the enumeration of the entire directory
    tree by returning a WIN32 STATUS that is not ERROR_SUCCESS.

    UpgEnumerateDirectory() will terminate the entire directory
    enumeration by returning a WIN32 STATUS other than ERROR_SUCCESS
    when encountering an error.

    Context passes global info from the caller to Function.

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
    DWORD                       WStatus;
    NTSTATUS                    NtStatus;
    BOOL                        Recurse;
    PFILE_DIRECTORY_INFORMATION DirectoryRecord;
    PFILE_DIRECTORY_INFORMATION DirectoryBuffer = NULL;
    BOOLEAN                     RestartScan     = TRUE;
    PWCHAR                      FileName        = NULL;
    DWORD                       FileNameLength  = 0;
    DWORD                       NumBuffers      = 0;
    DWORD                       NumRecords      = 0;
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;

    //
    // The buffer size is configurable with registry value
    // ENUMERATE_DIRECTORY_SIZE
    //
    DirectoryBuffer = (PFILE_DIRECTORY_INFORMATION)malloc(DEFAULT_ENUMERATE_DIRECTORY_SIZE);

    if (DirectoryBuffer == NULL) {
        WStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUP;
    }

    ZeroMemory(DirectoryBuffer, DEFAULT_ENUMERATE_DIRECTORY_SIZE);

NEXT_BUFFER:
    //
    // READ A BUFFER FULL OF DIRECTORY INFORMATION
    //

    NtStatus = NtQueryDirectoryFile(DirectoryHandle,   // Directory Handle
                                    NULL,              // Event
                                    NULL,              // ApcRoutine
                                    NULL,              // ApcContext
                                    &IoStatusBlock,
                                    DirectoryBuffer,
                                    DEFAULT_ENUMERATE_DIRECTORY_SIZE,
                                    FileDirectoryInformation,
                                    FALSE,             // return single entry
                                    NULL,              // FileName
                                    RestartScan        // restart scan
                                    );
    //
    // Enumeration Complete
    //
    if (NtStatus == STATUS_NO_MORE_FILES) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Error enumerating directory; return to caller
    //
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = UpgSetLastNTError(NtStatus);
        errmsg(DirectoryName, WStatus);
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this directory
            //
            WStatus = ERROR_SUCCESS;
        }
        goto CLEANUP;
    }
    ++NumBuffers;

    //
    // PROCESS DIRECTORY RECORDS
    //
    DirectoryRecord = DirectoryBuffer;
NEXT_RECORD:

    ++NumRecords;

    //
    // Filter . and ..
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        //
        // Skip .
        //
        if (DirectoryRecord->FileNameLength == 2 &&
            DirectoryRecord->FileName[0] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }

        //
        // Skip ..
        //
        if (DirectoryRecord->FileNameLength == 4 &&
            DirectoryRecord->FileName[0] == L'.' &&
            DirectoryRecord->FileName[1] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }
    }

    //
    // Add a terminating NULL to the FileName (painful)
    //
    if (FileNameLength < DirectoryRecord->FileNameLength + sizeof(WCHAR)) {
        FREE(FileName);
        FileNameLength = DirectoryRecord->FileNameLength + sizeof(WCHAR);
        FileName = (PWCHAR)malloc(FileNameLength);
        if (FileName == NULL) {
            WStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto CLEANUP;
        }
    }
    CopyMemory(FileName, DirectoryRecord->FileName, DirectoryRecord->FileNameLength);

    FileName[DirectoryRecord->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Process the record
    //
    WStatus = (*Function)(DirectoryHandle,
                          DirectoryName,
                          DirectoryLevel,
                          DirectoryRecord,
                          DirectoryFlags,
                          FileName,
                          Context);
    if (!WIN_SUCCESS(WStatus)) {
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this entry
            //
            WStatus = ERROR_SUCCESS;
        } else {
            //
            // Abort the entire enumeration
            //
            goto CLEANUP;
        }
    }

ADVANCE_TO_NEXT_RECORD:
    //
    // Next record
    //
    if (DirectoryRecord->NextEntryOffset) {
        DirectoryRecord = (PFILE_DIRECTORY_INFORMATION)(((PCHAR)DirectoryRecord) + DirectoryRecord->NextEntryOffset);
        goto NEXT_RECORD;
    }

    //
    // Done with this buffer; go get another one
    // But don't restart the scan for every loop!
    //
    RestartScan = FALSE;
    goto NEXT_BUFFER;

CLEANUP:
    FREE(FileName);
    FREE(DirectoryBuffer);

    return WStatus;
}


DWORD
UpgEnumerateDirectoryRecurse(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  HANDLE                      FileHandle,
    IN  PVOID                       Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Open the directory identified by FileName in the directory
    identified by DirectoryHandle and call UpgEnumerateDirectory().

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryRecord     - From UpgEnumerateRecord()
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    FileName            - Open this directory and recurse
    FileHandle          - Use for FileName if not INVALID_HANDLE_VALUE
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
    DWORD               WStatus;
    NTSTATUS            NtStatus;
    HANDLE              LocalHandle   = INVALID_HANDLE_VALUE;
    UNICODE_STRING      ObjectName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;


    //
    // Relative open
    //
    if (!HANDLE_IS_VALID(FileHandle)) {
        ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
        ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.Buffer = DirectoryRecord->FileName;
        ObjectAttributes.ObjectName = &ObjectName;
        ObjectAttributes.RootDirectory = DirectoryHandle;
        NtStatus = NtCreateFile(&LocalHandle,
                                READ_ACCESS,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN,
                                    FILE_OPEN_REPARSE_POINT |
                                    FILE_SEQUENTIAL_ONLY |
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,                  // EA buffer
                                0                      // EA buffer size
                                );

        //
        // Error opening directory
        //
        if (!NT_SUCCESS(NtStatus)) {
            WStatus = UpgSetLastNTError(NtStatus);
            errmsg(FileName, WStatus);
            if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
                //
                // Skip this directory tree
                //
                WStatus = ERROR_SUCCESS;
            }
            goto CLEANUP;
        }
        FileHandle = LocalHandle;
    }
    //
    // RECURSE
    //
    WStatus = UpgEnumerateDirectory(FileHandle,
                                    FileName,
                                    DirectoryLevel + 1,
                                    DirectoryFlags,
                                    Context,
                                    Function);
CLEANUP:
    FRS_CLOSE(LocalHandle);

    return WStatus;

}


DWORD
UpgDeleteByHandle(
    IN PWCHAR  Name,
    IN HANDLE  Handle
    )
/*++
Routine Description:
    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    Win Status
--*/
{
    FILE_DISPOSITION_INFORMATION    DispositionInformation;
    IO_STATUS_BLOCK                 IoStatus;
    NTSTATUS                        NtStatus;
    DWORD                           WStatus;

    if (!HANDLE_IS_VALID(Handle)) {
        return ERROR_SUCCESS;
    }

    //
    // Mark the file for delete. The delete happens when the handle is closed.
    //
#undef DeleteFile
    DispositionInformation.DeleteFile = TRUE;
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    &DispositionInformation,
                                    sizeof(DispositionInformation),
                                    FileDispositionInformation);
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = UpgSetLastNTError(NtStatus);
        return WStatus;
    }
    return ERROR_SUCCESS;
}


DWORD
UpgEnumerateDirectoryDeleteWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PVOID                       Ignored
    )
/*++
Routine Description:
    Empty a directory of non-replicating files and dirs if this is
    an ERROR_DIR_NOT_EMPTY and this is a retry change order for a
    directory delete.

Arguments:
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    Ignored             - Context is ignored

Return Value:
    Win32 Status
--*/
{
    DWORD                   WStatus;
    NTSTATUS                NtStatus;
    HANDLE                  Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Depth first
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        WStatus = UpgEnumerateDirectoryRecurse(DirectoryHandle,
                                               DirectoryName,
                                               DirectoryLevel,
                                               DirectoryRecord,
                                               DirectoryFlags,
                                               FileName,
                                               INVALID_HANDLE_VALUE,
                                               Ignored,
                                               UpgEnumerateDirectoryDeleteWorker);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
    }

    //
    // Relative open
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(&Handle,
                            GENERIC_READ |
                                SYNCHRONIZE |
                                DELETE |
                                FILE_WRITE_ATTRIBUTES,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                            FILE_OPEN,
                               FILE_OPEN_REPARSE_POINT |
                               FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = UpgSetLastNTError(NtStatus);
        errmsg(FileName, WStatus);
        goto CLEANUP;
    }
    //
    // Turn off readonly, system, and hidden
    //
    UpgResetAttributesForDelete(FileName, Handle);

    //
    // Delete the file
    //
    WStatus = UpgDeleteByHandle(FileName, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        errmsg(FileName, WStatus);
    }

CLEANUP:
    FRS_CLOSE(Handle);

    return WStatus;
}


DWORD
UpgOpenDirectoryPath(
    OUT PHANDLE     Handle,
    IN  PWCHAR      lpFileName
    )
/*++

Routine Description:

    This function opens the specified directory

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the directory to be opened.

Return Value:

    Win32 Status

--*/
{
    DWORD               WStatus;
    NTSTATUS            NtStatus;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      FileName;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID               FreeBuffer;


    //
    // Convert the Dos name to an NT name.
    //
    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
        lpFileName,
        &FileName,
        NULL,
        &RelativeName
        );

    if ( !TranslationStatus ) {
        return ERROR_BAD_PATHNAME;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    NtStatus = NtCreateFile(Handle,
                            READ_ACCESS,
                            &Obja,
                            &IoStatusBlock,
                            NULL,              // Initial allocation size
                            FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                            FILE_OPEN,
                                  FILE_SEQUENTIAL_ONLY |
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0);

    if ( !NT_SUCCESS(NtStatus) ) {
        *Handle = INVALID_HANDLE_VALUE;
        WStatus = UpgSetLastNTError(NtStatus);
    } else {
        WStatus = ERROR_SUCCESS;
    }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    return WStatus;
}


DWORD
DeleteTree(
    IN  PWCHAR  Path
    )
/*++

Routine Description:

    Delete the contents of Path

Arguments:

    Path    - directory path

Return Value:

    WIN32 STATUS

--*/
{
    DWORD               WStatus;
    HANDLE              FileHandle   = INVALID_HANDLE_VALUE;

    //
    // Done deleting nothing
    //
    if (Path == NULL) {
        return ERROR_SUCCESS;
    }

    //
    // Open directory
    //
    WStatus = UpgOpenDirectoryPath(&FileHandle, Path);
    if (!WIN_SUCCESS(WStatus)) {
        if (WStatus == ERROR_FILE_NOT_FOUND) {
            WStatus = ERROR_SUCCESS;
            goto CLEANUP;
        }
        errmsg(Path, WStatus);
        goto CLEANUP;
    }

    //
    // RECURSE
    //
    WStatus = UpgEnumerateDirectory(FileHandle,
                                    Path,
                                    1,
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                    NULL,
                                    UpgEnumerateDirectoryDeleteWorker);
CLEANUP:
    FRS_CLOSE(FileHandle);

    return WStatus;
}


PWCHAR
GetConfigString(
    IN HKEY     HKey,
    IN PWCHAR   Param
    )
/*++

Routine Description:

    This function reads a keyword value from the registry.

Arguments:

    HKey    - Key to be read

    Param   - item for which we want the value

Return Value:

    String or NULL. Free with free().

--*/
{
    DWORD   WStatus;
    DWORD   Type;
    DWORD   Len;
    DWORD   Bytes;
    PWCHAR  RetValue;
    WCHAR   Value[MAX_PATH + 1];

    //
    // Read the value
    //
    Len = sizeof(Value);
    WStatus = RegQueryValueEx(HKey, Param, NULL, &Type, (PUCHAR)&Value[0], &Len);
    if (!WIN_SUCCESS(WStatus)) {
        return NULL;
    }

    //
    // Duplicate the string
    //
    if (Type == REG_SZ) {
        Bytes = (wcslen(Value) + 1) * sizeof(WCHAR);
        RetValue = (PWCHAR)malloc(Bytes);
        if (RetValue != NULL) {
            CopyMemory(RetValue, Value, Bytes);
        }
        return RetValue;
    }

    return NULL;
}



//
// RestoreFRS
//
DWORD
RestoreFRS( IN BOOLEAN IsYes )
{
    DWORD   WStatus = ERROR_SUCCESS;
    DWORD   KeyIdx;
    DWORD   SysvolReady;
    HKEY    HKey = 0;
    HKEY    HSetsKey = 0;
    HKEY    HSetKey = 0;
    HKEY    HNetKey = 0;
    PWCHAR  Value = NULL;
    BOOLEAN DeleteIt = FALSE;
    WCHAR   KeyBuf[MAX_PATH + 1];
    CHAR    InStr[512];
    PCHAR   pInStr;

    if (!StopFRS()) {
        return 1;
    }

    //
    // Open the NtFrs parameters key
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_CONFIG_SECTION,
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        errmsg(FRS_CONFIG_SECTION, WStatus);
        goto CLEANUP;
    }

    //
    // Open (or create) the Replica Sets key
    //
    WStatus = RegCreateKey(HKey,
                           FRS_SETS_KEY,
                           &HSetsKey);
    if (!WIN_SUCCESS(WStatus)) {
        errmsg(FRS_SETS_KEY, WStatus);
        goto CLEANUP;
    }
    Value = GetConfigString(HSetsKey, JET_PATH);
    if (!Value) {
        goto CLEANUP;
    }
    //
    // We have a jet path; see if the user wants to
    // delete it.
    //
ASK_STATE_AGAIN:
    if (Value) {
        //
        // The user did not specify yes to all so query
        //
        if (!IsYes) {

            //
            // Describe the situation
            //
            printf("\nDelete File Replication Service state? [yn] ");
            //
            // Query the user
            //
            pInStr = gets(InStr);
            printf("\n");
            //
            // Query resulted in NULL?
            //
            if (!pInStr) {
                //
                // Eof; query again
                //
                if (feof(stdin)) {
                    goto ASK_STATE_AGAIN;
                }
                //
                // Error; exit
                //
                if (ferror(stdin)) {
                    fprintf(stderr, "Error reading stdin.\n");
                    WStatus = ERROR_OPERATION_ABORTED;
                    goto CLEANUP;
                }
            }
            //
            // Accept only y or n
            //
            if (*pInStr != 'y' &&
                *pInStr != 'Y' &&
                *pInStr != 'n' &&
                *pInStr != 'N') {
                goto ASK_STATE_AGAIN;
            }
        }

        //
        // If yes to all or a query resulted in yes; delete root
        //
        if (IsYes || *pInStr == 'y' || *pInStr == 'Y') {
            WStatus = DeleteTree(Value);
            if (!WIN_SUCCESS(WStatus)) {
                goto CLEANUP;
            }
            //
            // Access the netlogon\parameters key
            //
            WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   NETLOGON_SECTION,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &HNetKey);
            if (WIN_SUCCESS(WStatus)) {
                //
                // Tell NetLogon to stop sharing the sysvol
                //
                SysvolReady = 0;
                WStatus = RegSetValueEx(HNetKey,
                                        SYSVOL_READY,
                                        0,
                                        REG_DWORD,
                                        (PUCHAR)&SysvolReady,
                                        sizeof(DWORD));
            }
            WStatus = ERROR_SUCCESS;
        } else {
            WStatus = ERROR_OPERATION_ABORTED;
            goto CLEANUP;
        }
        FREE(Value);
    }

    //
    // Delete the subkeys
    //
    KeyIdx = 0;
    do {
        WStatus = RegEnumKey(HSetsKey, KeyIdx, KeyBuf, MAX_PATH + 1);
        if (WIN_SUCCESS(WStatus)) {
            //
            // Open (or create) a replica set key
            //
            WStatus = RegCreateKey(HSetsKey,
                                   KeyBuf,
                                   &HSetKey);
            if (!WIN_SUCCESS(WStatus)) {
                errmsg(KeyBuf, WStatus);
                goto CLEANUP;
            } else {
                Value = GetConfigString(HSetKey, REPLICA_SET_ROOT);
                //
                // We have a root path; see if the user wants to
                // delete it.
                //
ASK_AGAIN:
                if (Value) {
                    //
                    // The user did not specify yes to all so query
                    //
                    if (!IsYes) {
                        //
                        // Describe the situation
                        //
                        printf(
"\nThe contents of the replicated directory %ws \n"
"will be deleted with the expectation that the data \n"
"can be retrieved from a replication partner at a later \n"
"time. The contents of %ws should not be deleted \n"
"if there are no replication partners. \n\n"
"Are there replication partners that can supply the \n"
"data for %ws at a later time? [yn] ",
                               Value,
                               Value,
                               Value);
                        //
                        // Query the user
                        //
                        pInStr = gets(InStr);
                        printf("\n");
                        //
                        // Query resulted in NULL?
                        //
                        if (!pInStr) {
                            //
                            // Eof; query again
                            //
                            if (feof(stdin)) {
                                goto ASK_AGAIN;
                            }
                            //
                            // Error; exit
                            //
                            if (ferror(stdin)) {
                                fprintf(stderr, "Error reading stdin.\n");
                                WStatus = ERROR_OPERATION_ABORTED;
                                goto CLEANUP;
                            }
                        }
                        //
                        // Accept only y or n
                        //
                        if (*pInStr != 'y' &&
                            *pInStr != 'Y' &&
                            *pInStr != 'n' &&
                            *pInStr != 'N') {
                            goto ASK_AGAIN;
                        }
                    }

                    //
                    // If yes to all or a query resulted in yes; delete root
                    //
                    if (IsYes || *pInStr == 'y' || *pInStr == 'Y') {
                        WStatus = DeleteTree(Value);
                        if (!WIN_SUCCESS(WStatus)) {
                            goto CLEANUP;
                        }
                    }
                    FREE(Value);
                }
            }
            if (HSetKey) {
                RegCloseKey(HSetKey);
                HSetKey = 0;
            }
        }
        ++KeyIdx;
    } while (WIN_SUCCESS(WStatus));

    if (WStatus != ERROR_NO_MORE_ITEMS) {
        errmsg(FRS_SETS_KEY, WStatus);
        goto CLEANUP;
    }

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    if (HKey) {
        RegCloseKey(HKey);
    }
    if (HSetsKey) {
        RegCloseKey(HSetsKey);
    }
    if (HSetKey) {
        RegCloseKey(HSetKey);
    }
    if (HNetKey) {
        RegCloseKey(HNetKey);
    }
    if (Value) {
        free(Value);
    }
    if (WIN_SUCCESS(WStatus)) {
        return 0;
    }
    return 1;
}

////////
//
// END code that processes -restore option
//
///////


BOOLEAN
IsThisADC(
    IN PWCHAR domainName )
{
    DWORD   WStatus;
    PWCHAR  p;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *DsRole;

    //
    // Is this a domain controller?
    //
    WStatus = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&DsRole);
    if (!WIN_SUCCESS(WStatus)) {
        errmsg("Can't get primary domain information", WStatus);
        return FALSE;
    }

    //
    // Domain Controller (DC)
    //
    if (DsRole->MachineRole == DsRole_RoleBackupDomainController ||
        DsRole->MachineRole == DsRole_RolePrimaryDomainController) {
        if (!DsRole->DomainNameDns) {
            errmsg( "Unable to get domain name", ERROR_PATH_NOT_FOUND );
            return FALSE;
        }
        wcscpy(domainName, DsRole->DomainNameDns);
        DsRoleFreeMemory(DsRole);
        for( p = domainName; *p != L'\0'; p++ );
        if( *(p-1) == L'.' ) {
            *(p-1) = L'\0';
        }
        return TRUE;
    }
    DsRoleFreeMemory(DsRole);
    return FALSE;
}

/*
 * Make it so NTFRS will run on this DC
 */
__cdecl
main( int argc, char *argv[] )
{
    DWORD i;
    LONG retval;
    BOOLEAN IsFirstDCInDomain = FALSE;
    BOOLEAN FixSysvols = FALSE;
    WCHAR SysVolPath[ MAX_PATH ], stage[ MAX_PATH ], root[ MAX_PATH ];
    DWORD pathType;
    BOOLEAN IsRestore = FALSE;
    BOOLEAN IsYes = FALSE;
    WCHAR domainName[512];

    SysVolPath[0] = 0;

    for( i = 1; i < (DWORD)argc; i++ ) {
        switch( argv[i][0] ) {
        case '/':
        case '-':
                switch( argv[i][1] ) {
                case 'D':
                case 'd':
                    IsFirstDCInDomain = TRUE;
                    break;
                case 'F':
                case 'f':
                    FixSysvols = TRUE;
                    break;
                case 'R':
                case 'r':
                    //
                    // Prepare for restore by stopping the service and
                    // setting a registry value. The registry value
                    // will force the service to DELETE ALL FILES
                    // AND DIRECTORIES in the known replica sets and
                    // then delete the database the very next time the
                    // service starts.
                    //
                    if (!_stricmp(&argv[i][1], "restore")) {
                        IsRestore = TRUE;
                    } else {
                        fprintf( stderr, "Unrecognized option: %s\n\n", argv[i] );
                        Usage( argc, argv );
                        return 1;
                    }
                    break;
                case 'Y':
                case 'y':
                    IsYes = TRUE;
                    break;
                default:
                    fprintf( stderr, "Unrecognized option: %c\n\n", argv[i][1] );
                    Usage( argc, argv );
                    return 1;
                }
                break;
        default:

            if( SysVolPath[0] != 0 ) {
                fprintf( stderr, "Too many 'sysvol' paths!  Need quotes?\n\n" );
                Usage( argc, argv );
                return 1;
            }

            mbstowcs( SysVolPath, argv[i], sizeof( SysVolPath ) / sizeof(WCHAR) );

            //
            // Make sure the system volume path is reasonable
            //
            retval = NetpPathType( NULL, SysVolPath, &pathType, 0 );

            if( retval != NO_ERROR || pathType != ITYPE_PATH_ABSD ) {
                fprintf( stderr, "Invalid system volume path.  Must be an absolute path.\n" );
                return 1;
            }

            break;
        }
    }

    //
    // Restore in progress; delete state
    //
    if (IsRestore) {
        return (RestoreFRS(IsYes));
    }

    if( IsThisADC( domainName ) == FALSE ) {
        fprintf( stderr, "This program can only be run on a DC!\n" );
        return 1;
    }

    if( SysVolPath[0] == 0 ) {
        Usage( argc, argv );
        return 1;
    }

    printf( "Initializing the NT MultiMaster File Replication Service:\n" );
    printf( "    Domain: %ws\n", domainName );

    if( IsFirstDCInDomain ) {
        printf( "    First DC in the domain\n" );
    }
    printf( "    System Volume: %ws\n", SysVolPath );

    //
    // Create the sysvol tree and share it out, if needed
    //
    if (!FixSysvols) {
        if( !CreateSysVolTree( SysVolPath, IsFirstDCInDomain, domainName ) ||
            !CreateSysVolShare( SysVolPath ) ) {

            return 1;
        }
    }
    //
    // Uncommit and delete old keys
    //
    if (!DeleteRegKeys()) {
        goto errout;
    }

    //
    // Add the registry keys for the NTFRS domain volume
    //
    wcscpy( stage, SysVolPath );
    wcscat( stage, L"\\staging areas\\" );
    wcscat( stage, domainName );

    wcscpy( root, SysVolPath );
    wcscat( root, L"\\sysvol\\" );
    wcscat( root, domainName );

    if( !AddRegKeys( domainName,
                     L"domain",
                     IsFirstDCInDomain,
                     stage,
                     root ) ) {
        goto errout;
    }

    //
    // Commit the keys only after all of the values are set without error.
    // Otherwise, a running NtFrs might pick up the keys while they are in
    // an incomplete state.
    //
    if( !CommitRegKeys()) {
        goto errout;
    }

    //
    // Now ensure that the replication service is running, and will run at each boot
    //
    if( !SetFRSAutoStart() || !StartFRS() ) {
        goto errout;
    }

    printf( "Success!\n" );

    return 0;

errout:
    if (!FixSysvols) {
        fprintf( stderr, "Warning: SYSVOL share path may have been changed.\n" );
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\ntfrsapi\ntfrsapi.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    api.c

Abstract:
    Application Programmer's Interface

    The dcpromo APIs are used when promoting or demoting a machine. The
    APIs seed the sysvols after promotion. The sysvols are deleted
    during demotion.

    The poke API forces the service on the indicated machine to
    immediately poll the DS.

Author:
    Billy J. Fuller 31-Dec-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <ntfrsapi.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <frssup.h>

#include <overflow.h>


CRITICAL_SECTION    NtFrsApi_GlobalLock;
BOOLEAN             NtFrsApi_GlobalLock_Initialized = FALSE;
CRITICAL_SECTION    NtFrsApi_ThreadLock;
BOOLEAN             NtFrsApi_ThreadLock_Initialized = FALSE;
DWORD               NtFrsApi_State;
DWORD               NtFrsApi_ServiceState;
DWORD               NtFrsApi_ServiceWaitHint;
HANDLE              NtFrsApi_ShutDownEvent;

PWCHAR              NtFrsApi_ServiceLongName = NULL;

//
// API Version Information
//
PCHAR               NtFrsApi_Module = __FILE__;
PCHAR               NtFrsApi_Date   = __DATE__;
PCHAR               NtFrsApi_Time   = __TIME__;


//  Seed the sysvol after dcpromo
//     Update the registry, delete existing sysvols (w/o error),
//     set service to auto-start
//

//
// NTFRSAPI States
//
#define NTFRSAPI_LOADED             (00)
#define NTFRSAPI_PREPARING          (10)
#define NTFRSAPI_PREPARED_SERVICE   (15)
#define NTFRSAPI_PREPARED           (20)
#define NTFRSAPI_COMMITTING         (30)
#define NTFRSAPI_COMMITTED          (40)
#define NTFRSAPI_ABORTING           (50)
#define NTFRSAPI_ABORTED            (60)

//
// Useful macros
//
#undef GET_EXCEPTION_CODE
#define GET_EXCEPTION_CODE(_x_)                                               \
{                                                                             \
    (_x_) = GetExceptionCode();                                               \
    if (((LONG)(_x_)) < 0) {                                                  \
        (_x_) = FRS_ERR_INTERNAL_API;                                         \
    }                                                                         \
    NTFRSAPI_DBG_PRINT2("Exception caught: %d, 0x%08x\n", (_x_), (_x_));      \
}

#define FREE(_x_) { if (_x_) { LocalFree(_x_); (_x_) = NULL; } }

//
// Only close valid registry key handles and then set the handle invalid.
//   FRS_REG_CLOSE(handle);
//
#define FRS_REG_CLOSE(_Handle)                                                   \
    if (HANDLE_IS_VALID(_Handle)) {                                          \
        RegCloseKey(_Handle);                                                \
        (_Handle) = INVALID_HANDLE_VALUE;                                    \
    }

//
// Status Polling Interval
//
#define STATUS_POLLING_INTERVAL (1 * 1000)  // 1 second

//
// Ldap timeout
//
#define NTFRSAPI_LDAP_CONNECT_TIMEOUT 30    // 30 seconds.


//
// DEBUG LOGGING
//
#define NTFRSAPI_DBG_LOG_DIR    L"%SystemRoot%\\debug"
#define NTFRSAPI_DBG_LOG_FILE   L"\\NtFrsApi.log"
WCHAR   NtFrsApi_Dbg_LogFile[MAX_PATH + 1];
FILE    *NtFrsApi_Dbg_LogFILE;
CRITICAL_SECTION NtFrsApi_Dbg_Lock;
BOOLEAN          NtFrsApi_Dbg_Lock_Initialized = FALSE;

//
// Semaphore name used to serialize backup restore operations.
//
#define NTFRS_BACKUP_RESTORE_SEMAPHORE L"NtFrs Backup Restore Semaphore"


#define CLEANUP_CB(_cb_func, _str, _wstatus, _branch)                  \
         if (!WIN_SUCCESS(_wstatus)) {                                 \
             NtFrsApi_CallBackOnWStatus((_cb_func), (_str), _wstatus); \
             goto _branch;                                             \
         }


#define MAX_DN  (8 * MAX_PATH)

WCHAR   DsDeleteDefaultDn[MAX_PATH + 1];
WCHAR   DsDeleteConfigDn[MAX_PATH + 1];
WCHAR   DsDeleteComputerName[MAX_COMPUTERNAME_LENGTH + 2];
WCHAR   DsDeleteDomainDnsName[MAX_PATH + 2];
PLDAP   DsDeleteLdap;

//
// Name components for FQDN substitution.  Used to build a string substitution
// array that is driven by a table to build the desired FQDN.
//
typedef enum  _FQDN_ARG_STRING {
    FQDN_END = 0,           // Null
    FQDN_ComputerName,      // DsDeleteComputerName,
    FQDN_ConfigName,        // DsDeleteConfigDn,
    FQDN_RepSetName,        // Thread->ReplicaSetName,
    FQDN_DefaultDn,         // DsDeleteDefaultDn,
    FQDN_CN_SYSVOLS,        // CN_SYSVOLS,
    FQDN_CN_SERVICES,       // CN_SERVICES
    FQDN_CN_DOMAIN_SYSVOL,  // CN_DOMAIN_SYSVOL,
    FQDN_CN_NTFRS_SETTINGS, // CN_NTFRS_SETTINGS,
    FQDN_CN_SYSTEM,         // CN_SYSTEM,
    FQDN_CN_SUBSCRIPTIONS,  // CN_SUBSCRIPTIONS,
    FQDN_CN_COMPUTERS,      // CN_COMPUTERS
    FQDN_MAX_COUNT
} FQDN_ARG_STRING;

PWCHAR FQDN_StdArgTable[FQDN_MAX_COUNT] = {
    L"InvalidFqdnArgument",
    DsDeleteComputerName,
    DsDeleteConfigDn,
    L"InvalidFqdnArgument",      // Thread->ReplicaSetName,
    DsDeleteDefaultDn,
    CN_SYSVOLS,
    CN_SERVICES,
    CN_DOMAIN_SYSVOL,
    CN_NTFRS_SETTINGS,
    CN_SYSTEM,
    CN_SUBSCRIPTIONS,
    CN_COMPUTERS
};

typedef struct _FQDN_CONSTRUCTION_TABLE {

    PCHAR   Description;   // For error messages.
    PWCHAR  Format;        // Format string used to construct the FQDN
    BYTE    Arg[8];        // Array of offsets into the arg table ordered by the FQDN

} FQDN_CONSTRUCTION_TABLE, *PFQDN_CONSTRUCTION_TABLE;

//
// This table describes the FQDNs for FRS objects that need to be deleted.
// The entries contain the object names for both the Beta 2 and Beta 3 versions.
// The objects are deleted in the order specified by the table entries.
//
FQDN_CONSTRUCTION_TABLE FrsDsObjectDeleteTable[] = {

    {"MemberDn(B2)", L"cn=%ws,cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_ComputerName, FQDN_RepSetName, FQDN_CN_SYSVOLS,
        FQDN_CN_SERVICES, FQDN_ConfigName, FQDN_END},

    {"MemberDn(B3)", L"cn=%ws,cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_ComputerName, FQDN_CN_DOMAIN_SYSVOL, FQDN_CN_NTFRS_SETTINGS,
        FQDN_CN_SYSTEM, FQDN_DefaultDn, FQDN_END},

    {"SetDn for(B2)", L"cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_RepSetName, FQDN_CN_SYSVOLS, FQDN_CN_SERVICES,
        FQDN_ConfigName, FQDN_END},

    {"SetDn for(B3)", L"cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_CN_DOMAIN_SYSVOL, FQDN_CN_NTFRS_SETTINGS, FQDN_CN_SYSTEM,
        FQDN_DefaultDn, FQDN_END},

    {"SettingsDn(B2)", L"cn=%ws,cn=%ws,%ws",
        FQDN_CN_SYSVOLS, FQDN_CN_SERVICES, FQDN_ConfigName, FQDN_END},

    {"SubscriberDn(B2)", L"cn=%ws,cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_RepSetName, FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName,
        FQDN_CN_COMPUTERS, FQDN_DefaultDn, FQDN_END},

    {"SubscriberDn(B3)", L"cn=%ws,cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_CN_DOMAIN_SYSVOL, FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName,
        FQDN_CN_COMPUTERS, FQDN_DefaultDn, FQDN_END},

    {"SubscriberDn$(B2)", L"cn=%ws,cn=%ws,cn=%ws$,cn=%ws,%ws",
        FQDN_RepSetName, FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName,
        FQDN_CN_COMPUTERS, FQDN_DefaultDn, FQDN_END},

    {"SubscriberDn$(B3)", L"cn=%ws,cn=%ws,cn=%ws$,cn=%ws,%ws",
        FQDN_CN_DOMAIN_SYSVOL, FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName,
        FQDN_CN_COMPUTERS, FQDN_DefaultDn, FQDN_END},

    {"SubscriptionsDn", L"cn=%ws,cn=%ws,cn=%ws,%ws",
        FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName, FQDN_CN_COMPUTERS,
        FQDN_DefaultDn, FQDN_END},

    {"SubscriptionsDn$", L"cn=%ws,cn=%ws$,cn=%ws,%ws",
        FQDN_CN_SUBSCRIPTIONS, FQDN_ComputerName, FQDN_CN_COMPUTERS,
        FQDN_DefaultDn, FQDN_END},

    {NULL, NULL, FQDN_END}
};




//
// return flags from DsGetDCInfo() & DsGetDcName() too?
//
FLAG_NAME_TABLE NtFrsApi_DsGetDcInfoFlagNameTable[] = {
    {DS_PDC_FLAG               , "DCisPDCofDomain "             },
    {DS_GC_FLAG                , "DCIsGCofForest "              },
    {DS_LDAP_FLAG              , "ServerSupportsLDAP_Server "   },
    {DS_DS_FLAG                , "DCSupportsDSAndIsA_DC "       },
    {DS_KDC_FLAG               , "DCIsRunningKDCSvc "           },
    {DS_TIMESERV_FLAG          , "DCIsRunningTimeSvc "          },
    {DS_CLOSEST_FLAG           , "DCIsInClosestSiteToClient "   },
    {DS_WRITABLE_FLAG          , "DCHasWritableDS "             },
    {DS_GOOD_TIMESERV_FLAG     , "DCRunningTimeSvcWithClockHW " },
    {DS_DNS_CONTROLLER_FLAG    , "DCNameIsDNSName "             },
    {DS_DNS_DOMAIN_FLAG        , "DomainNameIsDNSName "         },
    {DS_DNS_FOREST_FLAG        , "DnsForestNameIsDNSName "      },

    {0, NULL}
};


//
// Note: More replicated friggen code because the build environment for this
//       api file is all messed up.
//
VOID
FrsFlagsToStr(
    IN DWORD            Flags,
    IN PFLAG_NAME_TABLE NameTable,
    IN ULONG            Length,
    OUT PSTR            Buffer
    )
/*++

Routine Description:

    Routine to convert a Flags word to a descriptor string using the
    supplied NameTable.

Arguments:

    Flags - flags to convert.

    NameTable - An array of FLAG_NAME_TABLE structs.

    Length - Size of buffer in bytes.

    Buffer - buffer with returned string.

Return Value:

    Buffer containing printable string.

--*/
{
#undef NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "FrsFlagsToStr:"

    PFLAG_NAME_TABLE pNT = NameTable;
    LONG Remaining = Length-1;


    //FRS_ASSERT((Length > 4) && (Buffer != NULL));

    *Buffer = '\0';
    if (Flags == 0) {
        strncpy(Buffer, "<Flags Clear>", Length);
        return;
    }


    //
    // Build a string for each bit set in the Flag name table.
    //
    while ((Flags != 0) && (pNT->Flag != 0)) {

        if ((pNT->Flag & Flags) != 0) {
            Remaining -= strlen(pNT->Name);

            if (Remaining < 0) {
                //
                // Out of string buffer.  Tack a "..." at the end.
                //
                Remaining += strlen(pNT->Name);
                if (Remaining > 3) {
                    strcat(Buffer, "..." );
                } else {
                    strcpy(&Buffer[Length-4], "...");
                }
                return;
            }

            //
            // Tack the name onto the buffer and clear the flag bit so we
            // know what is left set when we run out of table.
            //
            strcat(Buffer, pNT->Name);
            ClearFlag(Flags, pNT->Flag);
        }

        pNT += 1;
    }

    if (Flags != 0) {
        //
        // If any flags are still set give them back in hex if there is
        // enough room in the buffer. "0xFFFFFFFF " needs 12 characters
        // including the null.
        //
        if ((Length - strlen(Buffer)) >= 12) {
            sprintf( &Buffer[strlen(Buffer)], "0x%08x ", Flags );
        }
    }

    return;
}


#define NTFRSAPI_DBG_INITIALIZE()   NtFrsApi_Dbg_Initialize()
VOID
NtFrsApi_Dbg_Initialize(
    VOID
    )
/*++
Routine Description:
    Initialize the debug subsystem at load.

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    if(InitializeCriticalSectionAndSpinCount(&NtFrsApi_Dbg_Lock,
						    NTFRS_CRITSEC_SPIN_COUNT)) {
	NtFrsApi_Dbg_Lock_Initialized = TRUE;
    }

}

#define NTFRSAPI_DBG_UNINITIALIZE()   NtFrsApi_Dbg_UnInitialize()
VOID
NtFrsApi_Dbg_UnInitialize(
    VOID
    )
/*++
Routine Description:
    Shutdown the debug sunsystem when dll is detached.

Arguments:
    None.

Return Value:
    None.
--*/
{
    if(NtFrsApi_Dbg_Lock_Initialized) {
	DeleteCriticalSection(&NtFrsApi_Dbg_Lock);
    }
}

#define NTFRSAPI_DBG_UNPREPARE()   NtFrsApi_Dbg_UnPrepare()
VOID
NtFrsApi_Dbg_UnPrepare(
    VOID
    )
/*++
Routine Description:
    All done; close the debug subsystem.

Arguments:
    None.

Return Value:
    None.
--*/
{
    if (!NtFrsApi_Dbg_LogFILE) {
        return;
    }
    fflush(NtFrsApi_Dbg_LogFILE);
    fclose(NtFrsApi_Dbg_LogFILE);
    NtFrsApi_Dbg_LogFILE = NULL;
}

#define NTFRSAPI_DBG_FLUSH()   NtFrsApi_Dbg_Flush()
VOID
NtFrsApi_Dbg_Flush(
    VOID
    )
/*++
Routine Description:
    Flush the log file.

Arguments:
    None.

Return Value:
    None.
--*/
{
    if (!NtFrsApi_Dbg_LogFILE) {
        return;
    }
    fflush(NtFrsApi_Dbg_LogFILE);
}


BOOL
NtFrsApi_Dbg_FormatLine(
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Format,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of debug output.

Arguments:
    Not documented.

Return Value:
    None.
--*/
{
    ULONG       LineUsed;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    try {
        //
        // Increment the line count here to prevent counting
        // the several DPRINTs that don't have a newline.
        //
        GetLocalTime(&SystemTime);
        if (_snprintf(Line, LineSize, "<%-31s%4u: %5u: %02d:%02d:%02d> ",
                  (DebSub) ? DebSub : "NoName",
                  GetCurrentThreadId(),
                  LineNo,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond) < 0) {
            Line[LineSize-1] = '\0';
            Ret = FALSE;
        } else {
            LineUsed = strlen(Line);
            if (((LineUsed + 1) >= LineSize) ||
                (_vsnprintf(Line + LineUsed,
                           LineSize - LineUsed,
                           Format,
                           argptr) < 0)) {
                Ret = FALSE;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Ret = FALSE;
    }
    return Ret;
}


#define NTFRSAPI_DBG_PRINT0(_Format)   \
    NtFrsApi_Dbg_Print((PUCHAR)_Format, NTFRSAPI_MODULE, __LINE__)

#define NTFRSAPI_DBG_PRINT1(_Format, _p1)   \
    NtFrsApi_Dbg_Print((PUCHAR)_Format, NTFRSAPI_MODULE, __LINE__,  \
                       _p1)

#define NTFRSAPI_DBG_PRINT2(_Format, _p1, _p2)   \
    NtFrsApi_Dbg_Print((PUCHAR)_Format, NTFRSAPI_MODULE, __LINE__,  \
                       _p1, _p2)

#define NTFRSAPI_DBG_PRINT3(_Format, _p1, _p2, _p3)   \
    NtFrsApi_Dbg_Print((PUCHAR)_Format, NTFRSAPI_MODULE, __LINE__,  \
                       _p1, _p2, _p3)

#define NTFRSAPI_DBG_PRINT4(_Format, _p1, _p2, _p3, _p4)   \
    NtFrsApi_Dbg_Print((PUCHAR)_Format, NTFRSAPI_MODULE, __LINE__,  \
                       _p1, _p2, _p3, _p4)

VOID
NtFrsApi_Dbg_Print(
    IN PUCHAR  Format,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ... )
/*++
Routine Description:
    Format and print a line of debug output to the log file.

Arguments:
    Format  - printf format
    DebSub  - module name
    LineNo  - file's line number

Return Value:
    None.
--*/
{
    CHAR    Line[512];

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, LineNo);

    //
    // Print the line to the log file
    //
    try {
        EnterCriticalSection(&NtFrsApi_Dbg_Lock);
        if (NtFrsApi_Dbg_LogFILE) {
            if (NtFrsApi_Dbg_FormatLine(DebSub, LineNo, Line, sizeof(Line),
                                        Format, argptr)) {
                fprintf(NtFrsApi_Dbg_LogFILE, "%s", Line);
                fflush(NtFrsApi_Dbg_LogFILE);
            }
        }
    } finally {
        LeaveCriticalSection(&NtFrsApi_Dbg_Lock);
    }
    va_end(argptr);
}


#define NTFRSAPI_DBG_PREPARE()   NtFrsApi_Dbg_Prepare()
VOID
NtFrsApi_Dbg_Prepare(
    VOID
    )
/*++
Routine Description:
    Prepare the debug subsystem at NtFrsApi_Prepare().

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Dbg_Prepare:"
    DWORD   WStatus;
    DWORD   Len;

    Len = ExpandEnvironmentStrings(NTFRSAPI_DBG_LOG_DIR,
                                   NtFrsApi_Dbg_LogFile,
                                   MAX_PATH + 1);
    if (Len == 0) {
        return;
    }
    //
    // Create the debug directory
    //
    if (!CreateDirectory(NtFrsApi_Dbg_LogFile, NULL)) {
        WStatus = GetLastError();
        if (!WIN_ALREADY_EXISTS(WStatus)) {
            return;
        }
    }

    if ((wcslen(NtFrsApi_Dbg_LogFile) + wcslen(NTFRSAPI_DBG_LOG_FILE) + 1) <= (MAX_PATH + 1)) {
        wcscat(NtFrsApi_Dbg_LogFile, NTFRSAPI_DBG_LOG_FILE);
    }else {
        return;
    }

    NtFrsApi_Dbg_LogFILE = _wfopen(NtFrsApi_Dbg_LogFile, L"ac");
    if (!NtFrsApi_Dbg_LogFILE) {
        return;
    }
}


#define NTFRSAPI_IPRINT0(_Info, _Format)   \
    NtFrsApi_Iprint(_Info, _Format)

#define NTFRSAPI_IPRINT1(_Info, _Format, _p1)   \
    NtFrsApi_Iprint(_Info, _Format, _p1)

#define NTFRSAPI_IPRINT2(_Info, _Format, _p1, _p2)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2)

#define NTFRSAPI_IPRINT3(_Info, _Format, _p1, _p2, _p3)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2, _p3)

#define NTFRSAPI_IPRINT4(_Info, _Format, _p1, _p2, _p3, _p4)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2, _p3, _p4)

#define NTFRSAPI_IPRINT5(_Info, _Format, _p1, _p2, _p3, _p4, _p5)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2, _p3, _p4, _p5)

#define NTFRSAPI_IPRINT6(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6)

#define NTFRSAPI_IPRINT7(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)   \
    NtFrsApi_Iprint(_Info, _Format, _p1, _p2, _p3, _p4, _p5, _p6, _p7)

VOID
NtFrsApi_Iprint(
    IN PNTFRSAPI_INFO   Info,
    IN PCHAR            Format,
    IN ... )
/*++
Routine Description:
    Format and print a line of information output into the info buffer.

Arguments:
    Info    - Info buffer
    Format  - printf format

Return Value:
    None.
--*/
{
    PCHAR   Line;
    ULONG   LineLen;
    LONG    LineSize;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, Format);

    //
    // Print the line into the info buffer
    //
    try {
        if (!FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
            //
            // Calc offset to start of free buffer space.
            // And calc max space left in buffer.
            //
            Line = ((PCHAR)Info) + Info->OffsetToFree;
            LineSize = (Info->SizeInChars - (ULONG)(Line - (PCHAR)Info));

            if (LineSize <= 0 || _vsnprintf(Line, LineSize, Format, argptr) < 0) {
                //
                // Buffer is filled.
                //
                SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
            } else {

                LineLen = strlen(Line) + 1;
                if (Info->CharsToSkip > 0) {
                    //
                    // Still skipping chars that we previously returned.  Barf.
                    //
                    Info->CharsToSkip = (LineLen > Info->CharsToSkip) ?
                                           0 : Info->CharsToSkip - LineLen;
                } else {
                    //
                    // The line fits.  Bump freespace offset and TotalChars returned.
                    //
                    Info->OffsetToFree += LineLen;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    va_end(argptr);
}


BOOL
NtFrsApiCheckRpcError(
    RPC_STATUS RStatus,
    PCHAR  Msg
)
/*++
Routine Description:

    Print rpc error message

Arguments:
    RStatus - Status return from RPC call.
    Msg - message string. Optional.

Return Value:
    True if there is an error else False.

--*/
{
#undef NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiCheckRpcError:"

    if (RStatus != RPC_S_OK) {
        if (Msg != NULL) {
            NTFRSAPI_DBG_PRINT2("RpcError (%d) - %s\n", RStatus, Msg);
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
NtFrsApi_Fix_Comm_WStatus(
    IN DWORD    WStatus
    )
/*++
Routine Description:
    If WStatus is an FRS error code, return it unaltered. Otherwise,
    map the rpc status into the generic FRS_ERR_SERVICE_COMM.

Arguments:
    WStatus - status from the rpc call.

Return Value:
    Fixed WStatus
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Fix_Comm_WStatus:"
    // TODO: replace these constants with symbollic values from winerror.h
    if ( (WStatus < 8000) || (WStatus >= 8200) ) {
        NTFRSAPI_DBG_PRINT1("Comm WStatus: not FRS (%d)\n", WStatus);
        WStatus = FRS_ERR_SERVICE_COMM;
    }
    return WStatus;
}


PVOID
NtFrsApi_Alloc(
    IN DWORD    Size
    )
/*++
Routine Description:
    Allocate fixed, zeroed memory. Raise an exception if memory
    cannot be allocated.

Arguments:
    Size - size of memory request

Return Value:
    Raise an exception if memory cannot be allocated.
--*/
{
    PVOID   Va;

    Va = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);
    if (!Va) {
        RaiseException(GetLastError(), 0, 0, NULL);
    }
    return Va;
}


HANDLE
NtFrsApi_CreateEvent(
    IN BOOL ManualReset,
    IN BOOL InitialState
    )
/*++
Routine Description:
    Support routine to create an event.

Arguments:
    ManualReset     - TRUE if ResetEvent is required
    InitialState    - TRUE if signaled

Return Value:
    Address of the created event handle.
--*/
{
    HANDLE  Handle;

    Handle = CreateEvent(NULL, ManualReset, InitialState, NULL);
    if (!HANDLE_IS_VALID(Handle)) {
        RaiseException(GetLastError(), 0, 0, NULL);
    }
    return Handle;
}


PWCHAR
NtFrsApi_Dup(
    IN PWCHAR   Src
    )
/*++
Routine Description:
    Duplicate the string. Raise an exception if memory cannot be allocated.

Arguments:
    Size - size of memory request

Return Value:
    Raise an exception if memory cannot be allocated.
--*/
{
    PWCHAR  Dst;
    DWORD   Size;

    if (!Src) {
        return NULL;
    }

    Size = (wcslen(Src) + 1) * sizeof(WCHAR);
    Dst = NtFrsApi_Alloc(Size);
    CopyMemory(Dst, Src, Size);
    return Dst;
}


#define NTFRSAPI_ERROR_MESSAGE_DELIMITER    L": "
VOID
WINAPI
NtFrsApi_CallBackOnWStatus(
    IN  DWORD   (*ErrorCallBack)(IN PWCHAR, IN ULONG), OPTIONAL
    IN  PWCHAR  ObjectName, OPTIONAL
    IN  DWORD   WStatus
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_CallBackOnWStatus:"
    DWORD   MsgBufSize;
    DWORD   FinalSize;
    PWCHAR  FinalMsg = NULL;
    WCHAR   MsgBuf[MAX_PATH + 1];

    //
    // Nothing to report
    //
    if (!ObjectName || !ErrorCallBack) {
        return;
    }

    //
    // Format the error code
    //
    MsgBufSize = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                               NULL,
                               WStatus,
                               0,
                               MsgBuf,
                               MAX_PATH + 1,
                               NULL);
    if (!MsgBufSize) {
        // If format message fails then call the call back with
        // empty string.
        (ErrorCallBack)(L"", WStatus);
        return;
    }

    //
    // Produce message: "ObjectName: Error Code Message"
    //
    FinalSize = (wcslen(ObjectName) +
                 wcslen(MsgBuf) +
                 wcslen(NTFRSAPI_ERROR_MESSAGE_DELIMITER) +
                 1) * sizeof(WCHAR);
    try {
        FinalMsg = NtFrsApi_Alloc(FinalSize);
    } except (EXCEPTION_EXECUTE_HANDLER) {
	  GET_EXCEPTION_CODE(WStatus);
	  return;
    }
    FinalMsg[0] = L'\0';
    wcscat(FinalMsg, ObjectName);
    wcscat(FinalMsg, NTFRSAPI_ERROR_MESSAGE_DELIMITER);
    wcscat(FinalMsg, MsgBuf);
    //
    // Record message with caller
    //
    (ErrorCallBack)(FinalMsg, WStatus);
    FREE(FinalMsg);
}


//
// NTFRSAPI Thread Struct
//
typedef struct _NTFRSAPI_THREAD NTFRSAPI_THREAD, *PNTFRSAPI_THREAD;
struct _NTFRSAPI_THREAD {
    //
    // Thread state
    //
    PNTFRSAPI_THREAD    Next;           // Singly linked list
    HANDLE              ThreadHandle;   // returned by CreateThread()
    DWORD               ThreadId;       // returned by CreateThread()
    HANDLE              DoneEvent;      // Set when thread is done
    DWORD               ThreadWStatus;  // Win32 Status of this thread

    //
    // From NtFrs Service
    //
    ULONG               ServiceState;   // State of promotion/demotion
    ULONG               ServiceWStatus; // Win32 Status of promotion/demotion
    PWCHAR              ServiceDisplay; // Display string

    //
    // From NtFrsApi_StartPromotion/Demotion
    //
    PWCHAR              ParentComputer;
    PWCHAR              ParentAccount;
    PWCHAR              ParentPassword;
    DWORD               (*DisplayCallBack)(IN PWCHAR Display);
    DWORD               (*ErrorCallBack)(IN PWCHAR, IN ULONG);
    PWCHAR              ReplicaSetName;
    PWCHAR              ReplicaSetType;
    DWORD               ReplicaSetPrimary;
    PWCHAR              ReplicaSetStage;
    PWCHAR              ReplicaSetRoot;
} *NtFrsApi_Threads;
DWORD NtFrsApi_NumberOfThreads;


PVOID
NtFrsApi_FreeThread(
    IN PNTFRSAPI_THREAD Thread
    )
/*++
Routine Description:
    Abort a thread and free its thread struct.
    Caller must hold the NtFrsApi_ThreadLock.

Arguments:
    Thread  - represents the thread

Return Value:
    NULL
--*/
{

    //
    // Clean up the handles
    //      Cancel the RPC requests.
    //      Give the thread a little time to clean up.
    //      Terminate the thread.
    //      Set and close the thread's done event.
    //
    if (HANDLE_IS_VALID(Thread->ThreadHandle)) {
        RpcCancelThread(Thread->ThreadHandle);
        WaitForSingleObject(Thread->ThreadHandle, 5 * 1000);
        TerminateThread(Thread->ThreadHandle, ERROR_OPERATION_ABORTED);
        CloseHandle(Thread->ThreadHandle);
        //
        // Decrement count only if the thread was correctly
        // initialized.
        //
        --NtFrsApi_NumberOfThreads;
    }

    if (HANDLE_IS_VALID(Thread->DoneEvent)) {
        SetEvent(Thread->DoneEvent);
        CloseHandle(Thread->DoneEvent);
    }

    //
    // Clean up memory
    //
    FREE(Thread->ParentComputer);
    FREE(Thread->ParentAccount);
    FREE(Thread->ParentPassword);
    FREE(Thread->ReplicaSetName);
    FREE(Thread->ReplicaSetType);
    FREE(Thread->ReplicaSetStage);
    FREE(Thread->ReplicaSetRoot);
    FREE(Thread);
    return NULL;
}


DWORD
NtFrsApi_CreateThread(
    IN DWORD    Entry(IN PVOID Arg),
    IN PWCHAR   ParentComputer,
    IN PWCHAR   ParentAccount,
    IN PWCHAR   ParentPassword,
    IN DWORD    DisplayCallBack(IN PWCHAR Display),
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    )
/*++
Routine Description:
    Create a thread for promotion/demotion.

Arguments:
    Entry               - Entry function
    ParentComputer      - An RPC-bindable name of the computer that is
                          supplying the Directory Service (DS) with its
                          initial state. The files and directories for
                          the system volume are replicated from this
                          parent computer.
    ParentAccount       - A logon account on ParentComputer.
    ParentPassword      - The logon account's password on ParentComputer.
    DisplayCallBack     - Called peridically with a progress display.
    ErrorCallBack       - Called with additional error info
    ReplicaSetName      - Name of the replica set.
    ReplicaSetType      - Type of replica set (enterprise or domain)
    ReplicaSetPrimary   - Is this the primary member of the replica set?
    ReplicaSetStage     - Staging path.
    ReplicaSetRoot      - Root path.

Return Value:
    Win32 Status
--*/
{
    DWORD               WStatus;
    PNTFRSAPI_THREAD    Thread;

    try {
        //
        // Allocate a local thread structure
        //
        Thread = NtFrsApi_Alloc(sizeof(NTFRSAPI_THREAD));
        //
        // Thread sets this event when it is done.
        //
        Thread->DoneEvent          = NtFrsApi_CreateEvent(TRUE, FALSE);
        Thread->ParentComputer     = NtFrsApi_Dup(ParentComputer);
        Thread->ParentAccount      = NtFrsApi_Dup(ParentAccount);
        Thread->ParentPassword     = NtFrsApi_Dup(ParentPassword);
        Thread->DisplayCallBack    = DisplayCallBack;
        Thread->ErrorCallBack      = ErrorCallBack;
        Thread->ReplicaSetName     = NtFrsApi_Dup(ReplicaSetName);
        Thread->ReplicaSetType     = NtFrsApi_Dup(ReplicaSetType);
        Thread->ReplicaSetPrimary  = ReplicaSetPrimary;
        Thread->ReplicaSetStage    = NtFrsApi_Dup(ReplicaSetStage);
        Thread->ReplicaSetRoot     = NtFrsApi_Dup(ReplicaSetRoot);
        Thread->ThreadWStatus      = ERROR_SUCCESS;
        Thread->ServiceWStatus     = ERROR_SUCCESS;
        Thread->ServiceState       = NTFRSAPI_SERVICE_STATE_IS_UNKNOWN;

        //
        // Kick off the thread
        //
        Thread->ThreadHandle = (HANDLE) CreateThread(NULL,
                                                     0,
                                                     Entry,
                                                     (PVOID)Thread,
                                                     0,
                                                     &Thread->ThreadId);
        //
        // FAILED
        //
        if (!HANDLE_IS_VALID(Thread->ThreadHandle)) {
            WStatus = GetLastError();
            NTFRSAPI_DBG_PRINT1("CreateThread(); %d\n", WStatus);
            CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
        }

        //
        // SUCCEEDED
        //
        EnterCriticalSection(&NtFrsApi_ThreadLock);
        ++NtFrsApi_NumberOfThreads;
        Thread->Next = NtFrsApi_Threads;
        NtFrsApi_Threads = Thread;
        Thread = NULL;
        LeaveCriticalSection(&NtFrsApi_ThreadLock);
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    if (Thread) {
        try {
            try {
                EnterCriticalSection(&NtFrsApi_ThreadLock);
                Thread = NtFrsApi_FreeThread(Thread);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);

            }
        } finally {
            //
            // Release lock
            //
            LeaveCriticalSection(&NtFrsApi_ThreadLock);
        }
    }

    return WStatus;
}


PWCHAR
NtFrsApi_FrsGetResourceStr(
    IN HINSTANCE hInstance,
    IN LONG  Id
)
/*++

Routine Description:

    This routine Loads the specified resource string.
    It allocates a buffer and returns the ptr.

Arguments:

    Id - An FRS_IDS_xxx identifier.

Return Value:

    Ptr to allocated string.
    The caller must free the buffer with a call to FrsFree().

--*/
#undef NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_FrsGetResourceStr:"
{

    LONG  N;
    WCHAR WStr[200];

    //
    // ID Must be Valid.
    //
    if ((Id <= IDS_TABLE_START) || (Id >= IDS_TABLE_END)) {
      NTFRSAPI_DBG_PRINT1("Resource string ID is out of range - %d\n", Id);
      Id = IDS_MISSING_STRING;
    }

    WStr[0] = UNICODE_NULL;

    N = LoadString(hInstance, Id, WStr, sizeof(WStr)/sizeof(WCHAR));

    if (N == 0) {
      NTFRSAPI_DBG_PRINT1("ERROR - Failed to get resource string. WStatus = %d\n",
                           GetLastError());
    }

    return NtFrsApi_Dup(WStr);
}


BOOL
WINAPI
NtFrsApi_Initialize(
    HINSTANCE  hinstDLL,
    DWORD      fdwReason,
    LPVOID     lpvReserved
   )
/*++
Routine Description:
    Called when this DLL is attached and detached.

Arguments:
    hinstDLL      handle to DLL module
    fdwReason     reason for calling function
    lpvReserved   reserved

Return Value:
    TRUE    - no problems
    FALSE   - DLL is not attached
--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH :
        //
        // No initialization needed per thread
        //
        DisableThreadLibraryCalls(hinstDLL);

        //
        // Get the translated long service name for error messages.
        //
        NtFrsApi_ServiceLongName =
            NtFrsApi_FrsGetResourceStr(hinstDLL, IDS_SERVICE_LONG_NAME);

        //
        // Shutdown event
        //
        NtFrsApi_ShutDownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!HANDLE_IS_VALID(NtFrsApi_ShutDownEvent)) {
            return FALSE;
        }

        //
        // General purpose critical section
        //
        if(!InitializeCriticalSectionAndSpinCount(&NtFrsApi_GlobalLock,
                                              NTFRS_CRITSEC_SPIN_COUNT)) {
	    return FALSE;
	}

	NtFrsApi_GlobalLock_Initialized = TRUE;

        //
        // Thread subsystem
        //
        if(!InitializeCriticalSectionAndSpinCount(&NtFrsApi_ThreadLock,
                                              NTFRS_CRITSEC_SPIN_COUNT)) {
	    return FALSE;
	}
	
	NtFrsApi_ThreadLock_Initialized = TRUE;

        //
        // Debug subsystem
        //
        NTFRSAPI_DBG_INITIALIZE();

        //
        // Not prepared for promotion or demotion, yet
        //
        NtFrsApi_State = NTFRSAPI_LOADED;

        break;
    case DLL_THREAD_ATTACH  :
        break;
    case DLL_THREAD_DETACH  :
        break;
    case DLL_PROCESS_DETACH :

        FREE(NtFrsApi_ServiceLongName);
	
	if(NtFrsApi_GlobalLock_Initialized) {
	    DeleteCriticalSection(&NtFrsApi_GlobalLock);
	}
        
	if(NtFrsApi_ThreadLock_Initialized) {
	    DeleteCriticalSection(&NtFrsApi_ThreadLock);
	}
        
	if (NtFrsApi_ShutDownEvent) {
            CloseHandle(NtFrsApi_ShutDownEvent);
        }
        
	NTFRSAPI_DBG_UNINITIALIZE();
        break;
    default:
        return FALSE;
    }
    return TRUE;
}


PVOID
MIDL_user_allocate(
    IN size_t Bytes
    )
/*++
Routine Description:
    Allocate memory for RPC.

Arguments:
    Bytes   - Number of bytes to allocate.

Return Value:
    NULL    - memory could not be allocated.
    !NULL   - address of allocated memory.
--*/
{
    return LocalAlloc(LMEM_FIXED, Bytes);
}


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
/*++
Routine Description:
    Free memory for RPC.

Arguments:
    Buffer  - Address of memory allocated with MIDL_user_allocate().

Return Value:
    None.
--*/
{
    FREE(Buffer);
}


DWORD
WINAPI
NtFrsApi_Bind(
    IN  PWCHAR      ComputerName,       OPTIONAL
    IN  DWORD       ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on ComputerName (this machine if NULL).

Arguments:
    ComputerName     - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.
    ErrorCallBack    - Ignored if NULL. Otherwise called with extra info
                       about an error.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Bind:"
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      LocalName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        NTFRSAPI_DBG_PRINT1("Bind: %ws\n", ComputerName);
        //
        // Return value
        //
        if (OutHandle == NULL) {
            return ERROR_INVALID_PARAMETER;
        }
        *OutHandle = NULL;

        //
        // If needed, get computer name
        //
        if (ComputerName == NULL) {
            ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
            LocalName = NtFrsApi_Alloc(ComputerLen * sizeof(WCHAR));
            if (!GetComputerName(LocalName, &ComputerLen)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Bind: GetComputerName(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }
            ComputerName = LocalName;
        }

        //
        // Create a binding string to NtFrs on some machine.  Trim leading \\
        //
        FRS_TRIM_LEADING_2SLASH(ComputerName);

        NTFRSAPI_DBG_PRINT1("Bind: compose to %ws\n", ComputerName);

        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, ComputerName,
                                          NULL, NULL, &BindingString);

        NTFRSAPI_DBG_PRINT2("Bind: compose done to %ws; %d\n", ComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);

        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
            NTFRSAPI_DBG_PRINT2("Bind: RpcBindingFromStringBinding(%ws); %d\n",
                                ComputerName, WStatus);
            CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        NTFRSAPI_DBG_PRINT1("Bind: resolve to %ws\n", ComputerName);
        WStatus = RpcEpResolveBinding(Handle, NtFrsApi_ClientIfHandle);

        NTFRSAPI_DBG_PRINT2("Bind: resolve done to %ws; %d\n", ComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);

        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

cleanup:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalName) {
            FREE(LocalName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
            NtFrsApiCheckRpcError(WStatus1, "RpcStringFreeW");
        }
        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    NTFRSAPI_DBG_PRINT1("Bind done: %d\n", WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_BindWithAuth(
    IN  PWCHAR      ComputerName,       OPTIONAL
    IN  DWORD       ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on ComputerName (this machine if NULL)
    with authenticated, encrypted packets.

Arguments:
    ComputerName     - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.
    ErrorCallBack    - Ignored if NULL. Otherwise called with extra info
                       about an error.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_BindWithAuth:"
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      LocalName       = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        NTFRSAPI_DBG_PRINT1("Bind With Auth: %ws\n", ComputerName);
        //
        // Return value
        //
        if (OutHandle == NULL) {
            return ERROR_INVALID_PARAMETER;
        }
        *OutHandle = NULL;

        //
        // If needed, get computer name
        //
        if (ComputerName == NULL) {
            ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
            LocalName = NtFrsApi_Alloc(ComputerLen * sizeof(WCHAR));

            if (!GetComputerName(LocalName, &ComputerLen)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Bind With Auth: GetComputerName(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
            }
            ComputerName = LocalName;
        }

        //
        // Create a binding string to NtFrs on some machine.  Trim leading \\
        //
        FRS_TRIM_LEADING_2SLASH(ComputerName);

        NTFRSAPI_DBG_PRINT1("Bind With Auth: compose to %ws\n", ComputerName);

        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, ComputerName,
                                          NULL, NULL, &BindingString);

        NTFRSAPI_DBG_PRINT2("Bind With Auth: compose done to %ws; %d\n", ComputerName, WStatus);

        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
            NTFRSAPI_DBG_PRINT2("Bind With Auth: RpcBindingFromStringBinding(%ws); %d\n",
                                ComputerName, WStatus);
            CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        NTFRSAPI_DBG_PRINT1("Bind With Auth: resolve to %ws\n", ComputerName);
        WStatus = RpcEpResolveBinding(Handle, NtFrsApi_ClientIfHandle);

        NTFRSAPI_DBG_PRINT2("Bind With Auth: resolve done to %ws; %d\n", ComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // Find the principle name
        //
        NTFRSAPI_DBG_PRINT1("Bind With Auth: princname to %ws\n", ComputerName);
        WStatus = RpcMgmtInqServerPrincName(Handle, RPC_C_AUTHN_GSS_NEGOTIATE, &PrincName);

        NTFRSAPI_DBG_PRINT2("Bind With Auth: princname done to %ws; %d\n", ComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
        //
        // Set authentication info
        //
        NTFRSAPI_DBG_PRINT2("Bind With Auth: auth to %ws (princname %ws)\n",
                            ComputerName, PrincName);
        WStatus = RpcBindingSetAuthInfo(Handle,
                                        PrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        NULL,
                                        RPC_C_AUTHZ_NONE);
        NTFRSAPI_DBG_PRINT2("Bind With Auth: set auth done to %ws; %d\n", ComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalName) {
            FREE(LocalName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
            NtFrsApiCheckRpcError(WStatus1, "RpcStringFreeW");
        }
        if (PrincName) {
            RpcStringFree(&PrincName);
        }
        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    NTFRSAPI_DBG_PRINT1("Bind With Auth done: %d\n", WStatus);
    return WStatus;
}

DWORD
WINAPI
NtFrsApi_BindLocal(
    IN  DWORD       ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT handle_t    *OutHandle
    )
/*++
Routine Description:
    Bind to the NtFrs service on this machine
    with authenticated, encrypted packets.

Arguments:
    ErrorCallBack    - Ignored if NULL. Otherwise called with extra info
                       about an error.
    OutHandle        - Bound, resolved, authenticated handle

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_BindLocal:"
    DWORD       WStatus, WStatus1;
    DWORD       ComputerLen;
    handle_t    Handle          = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;
    PWCHAR      LocalComputerName    = NULL;

    try {
        NTFRSAPI_DBG_PRINT1("Bind Local: %ws\n", LocalComputerName);
        //
        // Return value
        //
        if (OutHandle == NULL) {
            return ERROR_INVALID_PARAMETER;
        }
        *OutHandle = NULL;

        //
        // Get computer name
        //
	ComputerLen = MAX_COMPUTERNAME_LENGTH + 2;
	LocalComputerName = NtFrsApi_Alloc(ComputerLen * sizeof(WCHAR));

	if (!GetComputerName(LocalComputerName, &ComputerLen)) {
	    WStatus = GetLastError();
	    NTFRSAPI_DBG_PRINT1("Bind Local: GetComputerName(); %d\n", WStatus);
	    CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
	}

        //
        // Create a binding string to NtFrs on some machine.  Trim leading \\
        //
        FRS_TRIM_LEADING_2SLASH(LocalComputerName);

        NTFRSAPI_DBG_PRINT1("Bind Local: compose to %ws\n", LocalComputerName);

        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_LRPC, LocalComputerName,
                                          NULL, NULL, &BindingString);

        NTFRSAPI_DBG_PRINT2("Bind Local: compose done to %ws; %d\n", LocalComputerName, WStatus);

        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
            NTFRSAPI_DBG_PRINT2("Bind Local: RpcBindingFromStringBinding(%ws); %d\n",
                                LocalComputerName, WStatus);
            CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
        }
        //
        // Resolve the binding to the dynamic endpoint
        //
        NTFRSAPI_DBG_PRINT1("Bind Local: resolve to %ws\n", LocalComputerName);
        WStatus = RpcEpResolveBinding(Handle, NtFrsApi_ClientIfHandle);

        NTFRSAPI_DBG_PRINT2("Bind Local: resolve done to %ws; %d\n", LocalComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // Find the principle name
        //
        NTFRSAPI_DBG_PRINT1("Bind Local: princname to %ws\n", LocalComputerName);
        WStatus = RpcMgmtInqServerPrincName(Handle, RPC_C_AUTHN_WINNT, &PrincName);

        NTFRSAPI_DBG_PRINT2("Bind Local: princname done to %ws; %d\n", LocalComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);
        //
        // Set authentication info
        //
        NTFRSAPI_DBG_PRINT2("Bind Local: auth to %ws (princname %ws)\n",
                            LocalComputerName, PrincName);
        WStatus = RpcBindingSetAuthInfo(Handle,
                                        PrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        RPC_C_AUTHZ_NONE);
        NTFRSAPI_DBG_PRINT2("Bind Local: set auth done to %ws; %d\n", LocalComputerName, WStatus);
        CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, CLEANUP);

        //
        // SUCCESS
        //
        *OutHandle = Handle;
        Handle = NULL;
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (LocalComputerName) {
            FREE(LocalComputerName);
        }
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
            NtFrsApiCheckRpcError(WStatus1, "RpcStringFreeW");
        }
        if (PrincName) {
            RpcStringFree(&PrincName);
        }
        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    NTFRSAPI_DBG_PRINT1("Bind Local done: %d\n", WStatus);
    return WStatus;
}



DWORD
NtFrsApi_GetServiceHandle(
    IN  DWORD       ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT SC_HANDLE   *ServiceHandle
    )
/*++
Routine Description:
    Open a service on a machine.

Arguments:
    ServiceHandle   - Openned handle to ServiceName

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_GetServiceHandle:"
    DWORD       WStatus;
    SC_HANDLE   SCMHandle;

    if (ServiceHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!HANDLE_IS_VALID(SCMHandle)) {
        WStatus = GetLastError();
        NtFrsApi_CallBackOnWStatus(ErrorCallBack, L"Service Controller", WStatus);
        return WStatus;
    }

    //
    // Contact the NtFrs service.
    //
    *ServiceHandle = OpenService(SCMHandle,
                                 SERVICE_NAME,
                                    SERVICE_INTERROGATE |
                                    SERVICE_PAUSE_CONTINUE |
                                    SERVICE_QUERY_STATUS |
                                    SERVICE_QUERY_CONFIG |
                                    SERVICE_START |
                                    SERVICE_STOP |
                                    SERVICE_CHANGE_CONFIG);
    if (!HANDLE_IS_VALID(*ServiceHandle)) {
        WStatus = GetLastError();
        NtFrsApi_CallBackOnWStatus(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus);
    } else {
        WStatus = ERROR_SUCCESS;
    }
    CloseServiceHandle(SCMHandle);
    return WStatus;
}


#define MAX_WAIT_HINT   (120 * 1000)    // 120 seconds
DWORD
NtFrsApi_WaitForService(
    IN SC_HANDLE    ServiceHandle,
    IN DWORD        WaitHint,
    IN DWORD        PendingState,
    IN DWORD        FinalState
    )
/*++
Routine Description:
    Wait for the indicated service to transition from PendingState
    to State. The service is polled once a second for up to WaitHint
    seconds (WaitHint is in milliseconds). The maximum WaitHint is
    120 seconds.

Arguments:
    ServiceHandle   - indicates the service.
    WaitHint        - From the service status (in milliseconds)
    PendingState    - Expected pending state (E.g., SERVICE_START_PENDING)
    FinalState      - Expected final state (E.g., SERVICE_RUNNING)

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_WaitForService:"
    DWORD           WStatus;
    SERVICE_STATUS  ServiceStatus;

    //
    // Don't wait too long; dcpromo is an interactive app
    //
    if (WaitHint > MAX_WAIT_HINT || !WaitHint) {
        WaitHint = MAX_WAIT_HINT;
    }

    //
    // Get the service's status
    //
again:
    if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
        return GetLastError();
    }
    //
    // Done
    //
    if (ServiceStatus.dwCurrentState == FinalState) {
        return ERROR_SUCCESS;
    }
    //
    // Not in pending state; error
    //
    if (ServiceStatus.dwCurrentState != PendingState) {
        return ERROR_OPERATION_ABORTED;
    }
    //
    // Can't wait any longer
    //
    if (WaitHint < 1000) {
        return ERROR_OPERATION_ABORTED;
    }
    //
    // Wait a second
    //
    NTFRSAPI_DBG_PRINT0("Waiting for service.\n");
    Sleep(1000);
    WaitHint -= 1000;
    //
    // Try again
    //
    goto again;
}



DWORD
NtFrsApi_StopService(
    IN  SC_HANDLE         ServiceHandle,
    OUT LPSERVICE_STATUS  ServiceStatus
    )
/*++
Routine Description:

    Stop the FRS service.

Arguments:

    ServiceHandle - An open handle to the service controller.

    ServiceStatus - ptr to struct for returned service status.

Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_StopService:"

    DWORD           WStatus;

    //
    // Stop the FRS service.
    // Double stop used to deal with shutdown hang.
    //
    if (!ControlService(ServiceHandle, SERVICE_CONTROL_STOP, ServiceStatus)) {
        WStatus = GetLastError();
        if (WStatus == ERROR_SERVICE_REQUEST_TIMEOUT) {
            WStatus = ERROR_SUCCESS;
            if (!ControlService(ServiceHandle, SERVICE_CONTROL_STOP, ServiceStatus)) {
                WStatus = GetLastError();
                if (WStatus == ERROR_SERVICE_NOT_ACTIVE) {
                    WStatus = ERROR_SUCCESS;
                }
            }
        }
    }

    //
    // Wait for the stop to finish.
    //
    WStatus = NtFrsApi_WaitForService(ServiceHandle,
                                      NtFrsApi_ServiceWaitHint,
                                      SERVICE_STOP_PENDING,
                                      SERVICE_STOPPED);
    if (!WIN_SUCCESS(WStatus)) {
        WStatus = FRS_ERR_STOPPING_SERVICE;
    }

    return WStatus;
}

PWCHAR
WINAPI
NtFrsApi_Cats(
    IN  PWCHAR  Name1, OPTIONAL
    IN  PWCHAR  Name2, OPTIONAL
    IN  PWCHAR  Name3  OPTIONAL
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Cats:"
    DWORD   FinalSize;
    PWCHAR  FinalMsg;

    //
    // sizeof(Names) + sizeof(terminating NULL)
    //
    FinalSize = (((Name1) ? wcslen(Name1) : 0) +
                 ((Name2) ? wcslen(Name2) : 0) +
                 ((Name3) ? wcslen(Name3) : 0) +
                 1) * sizeof(WCHAR);
    //
    // Nothing but the terminating UNICODE NULL; ignore
    //
    if (FinalSize <= sizeof(WCHAR)) {
        return NULL;
    }
    //
    // Allocate string and concatenate
    //
    FinalMsg = NtFrsApi_Alloc(FinalSize);
    FinalMsg[0] = L'\0';
    if (Name1) {
        wcscat(FinalMsg, Name1);
    }
    if (Name2) {
        wcscat(FinalMsg, Name2);
    }
    if (Name3) {
        wcscat(FinalMsg, Name3);
    }
    return (FinalMsg);
}


DWORD
WINAPI
NtFrsApiOpenKeyEx(
    IN PCHAR    NtFrsApiModule,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   KeyPath,
    IN DWORD    KeyAccess,
    OUT HKEY    *OutHKey
    )
/*++
Routine Description:
    Open KeyPath.

Arguments:
    NtFrsApiModule  - String to identify caller
    ErrorCallBack   - Ignored if NULL
    KeyPath         - Path of registry key (HKEY_LOCAL_MACHINE)
    KeyAccess       - for RegOpenKeyEx()
    OutHKey         - From RegOpenKeyEx()

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiOpenKeyEx:"
    DWORD WStatus;

    if (OutHKey == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Open KeyPath
    //
    *OutHKey = 0;
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KeyPath, 0, KeyAccess, OutHKey);
    //
    // Report error
    //
    if (!WIN_SUCCESS(WStatus)) {
        NtFrsApi_CallBackOnWStatus(ErrorCallBack, KeyPath, WStatus);
        NTFRSAPI_DBG_PRINT3("%s RegOpenKeyEx(%ws); %d\n",
                            NtFrsApiModule, KeyPath, WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiCreateKey(
    IN PCHAR    NtFrsApiModule,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   KeyPath,
    IN HKEY     HKey,
    IN PWCHAR   KeyName,
    OUT HKEY    *OutHKey
    )
/*++
Routine Description:
    Create KeyPath.

Arguments:
    NtFrsApiModule  - String to identify caller
    ErrorCallBack   - Ignored if NULL
    KeyPath         - Path of registry key (HKEY_LOCAL_MACHINE)
    KeyAccess       - for RegCreateKey()
    OutHKey         - From RegCreateKey()

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiCreateKey:"
    DWORD   WStatus;
    PWCHAR  ObjectName;

    //
    // Open KeyPath
    //
    *OutHKey = 0;
    WStatus = RegCreateKey(HKey, KeyName, OutHKey);
    //
    // Report error
    //
    if (!WIN_SUCCESS(WStatus)) {
        if (KeyPath) {
            ObjectName = NtFrsApi_Cats(KeyPath, L"\\", KeyName);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegCreateKey(%ws); %d\n",
                                NtFrsApiModule, ObjectName, WStatus);
            FREE(ObjectName);
        } else {
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, KeyName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegCreateKey(%ws); %d\n",
                                NtFrsApiModule, KeyName, WStatus);
        }
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiSetValueEx(
    IN PCHAR    NtFrsApiModule,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   KeyPath,
    IN HKEY     HKey,
    IN PWCHAR   ValueName,
    IN DWORD    RegType,
    IN PCHAR    RegValue,
    IN DWORD    RegSize
    )
/*++
Routine Description:
    Set value

Arguments:
    NtFrsApiModule  - String to identify caller
    ErrorCallBack   - Ignored if NULL
    KeyPath         - Path of registry key (HKEY_LOCAL_MACHINE)
    HKey            - For call to RegSetValueEx()
    ValueName       - For Call to RegSetValueEx()
    RegType         - For Call to RegSetValueEx()
    RegValue        - For Call to RegSetValueEx()
    RegSize         - For Call to RegSetValueEx()

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiSetValueEx:"
    DWORD   WStatus;
    PWCHAR  ObjectName;

    //
    // Set the value
    //
    WStatus = RegSetValueEx(HKey, ValueName, 0, RegType, RegValue, RegSize);
    //
    // Report error
    //
    if (!WIN_SUCCESS(WStatus)) {
        if (KeyPath) {
            ObjectName = NtFrsApi_Cats(KeyPath, L"->", ValueName);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegSetValueEx(%ws); %d\n",
                                NtFrsApiModule, ObjectName, WStatus);
            FREE(ObjectName);
        } else {
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ValueName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegSetValueEx(%ws); %d\n",
                                NtFrsApiModule, ValueName, WStatus);
        }
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiDeleteValue(
    IN PCHAR    NtFrsApiModule,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   KeyPath,
    IN HKEY     HKey,
    IN PWCHAR   ValueName
    )
/*++
Routine Description:
    Delete value.

Arguments:
    NtFrsApiModule  - String to identify caller
    ErrorCallBack   - Ignored if NULL
    KeyPath         - Path of registry key (HKEY_LOCAL_MACHINE)
    HKey            - For call to RegDeleteValue()
    ValueName       - For Call to RegDeleteValue()

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiDeleteValue:"
    DWORD   WStatus;
    PWCHAR  ObjectName;

    //
    // Set the value
    //
    WStatus = RegDeleteValue(HKey, ValueName);
    //
    // Report error
    //
    if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_FILE_NOT_FOUND) {
        if (KeyPath) {
            ObjectName = NtFrsApi_Cats(KeyPath, L"->", ValueName);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegDeleteValue(%ws); %d\n",
                                NtFrsApiModule, ObjectName, WStatus);
            FREE(ObjectName);
        } else {
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ValueName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegDeleteValue(%ws); %d\n",
                                NtFrsApiModule, ValueName, WStatus);
        }
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiDeleteKey(
    IN PCHAR    NtFrsApiModule,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   KeyPath,
    IN HKEY     HKey,
    IN PWCHAR   KeyName
    )
/*++
Routine Description:
    Delete key.

Arguments:
    NtFrsApiModule  - String to identify caller
    ErrorCallBack   - Ignored if NULL
    KeyPath         - Path of registry key (HKEY_LOCAL_MACHINE)
    HKey            - For call to RegDeleteKey()
    KeyName         - For Call to RegDeleteKey()

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiDeleteKey:"
    DWORD   WStatus;
    PWCHAR  ObjectName;

    //
    // Set the value
    //
    WStatus = RegDeleteKey(HKey, KeyName);
    //
    // Report error
    //
    if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_FILE_NOT_FOUND) {
        if (KeyPath) {
            ObjectName = NtFrsApi_Cats(KeyPath, L"\\", KeyName);

            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);

            NTFRSAPI_DBG_PRINT3("%s RegDeleteKey(%ws); %d\n",
                                NtFrsApiModule, ObjectName, WStatus);
            FREE(ObjectName);
        } else {
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, KeyName, WStatus);
            NTFRSAPI_DBG_PRINT3("%s RegDeleteKey(%ws); %d\n",
                                NtFrsApiModule, KeyName, WStatus);
        }
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_Prepare(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN BOOL     IsDemote
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC) and stops replicating
    the system volumes when a DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's
    replica set.

    This function prepares the NtFrs service on this machine by
    stopping the service, deleting old state in the registry,
    and restarting the service. The service's current state is
    retained and restored if the promotion or demotion are
    aborted.

Arguments:
    IsDemote    - TRUE: prepare for demotion
                  FALSE: prepare for promotion
Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Prepare:"
    DWORD           WStatus;
    SERVICE_STATUS  ServiceStatus;
    DWORD           ValueLen;
    DWORD           ValueType;
    DWORD           SysvolReady;
    HKEY            HKey = INVALID_HANDLE_VALUE;
    HKEY            HNetKey = INVALID_HANDLE_VALUE;
    SC_HANDLE       ServiceHandle = NULL;
    WCHAR           KeyBuf[MAX_PATH + 1];


    try {
        //
        // Acquire global lock within a try-finally
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);

        NTFRSAPI_DBG_PRINT0("Prepare:\n");

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_LOADED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }
        NtFrsApi_State = NTFRSAPI_PREPARING;

        //
        // Stop the service, delete old state from the registry,
        // and restart the service
        //
        try {
            //
            // Set the RPC cancel timeout to "now"
            //
            WStatus = RpcMgmtSetCancelTimeout(0);
            if (!WIN_SUCCESS(WStatus)) {
                NTFRSAPI_DBG_PRINT1("Prepare: RpcMgmtSetCancelTimeout(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }

            //
            // Insure access to the ntfrs parameters\sysvol section in the registry
            //
            NTFRSAPI_DBG_PRINT0("Prepare: FRS Registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Insure access to the netlogon\parameters key
            //
            NTFRSAPI_DBG_PRINT0("Prepare: Netlogon registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        ErrorCallBack,
                                        NETLOGON_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HNetKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Tell NetLogon to stop sharing the sysvol
            // NtFrs will reset the value if a seeded sysvol is
            // detected at startup.
            //
            SysvolReady = 0;
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         ErrorCallBack,
                                         NETLOGON_SECTION,
                                         HNetKey,
                                         SYSVOL_READY,
                                         REG_DWORD,
                                         (PCHAR)&SysvolReady,
                                         sizeof(DWORD));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Open the service
            //
            NTFRSAPI_DBG_PRINT0("Prepare: Service\n");
            WStatus = NtFrsApi_GetServiceHandle(ErrorCallBack, &ServiceHandle);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Get the service's status
            //
            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Prepare: QueryServiceStatus(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }
            //
            // Remember the current state
            //
            NtFrsApi_ServiceState = ServiceStatus.dwCurrentState;
            NtFrsApi_ServiceWaitHint = ServiceStatus.dwWaitHint;
            NtFrsApi_State = NTFRSAPI_PREPARED_SERVICE;

            //
            // Stop the service
            //
            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                WStatus = NtFrsApi_StopService(ServiceHandle, &ServiceStatus);
                if (!WIN_SUCCESS(WStatus)) {
                    goto cleanup;
                }
            }

            //
            // Delete old state from the registry
            // Delete the value that indicates the sysvol subkeys are valid
            //
            WStatus = NtFrsApiDeleteValue(NTFRSAPI_MODULE,
                                          ErrorCallBack,
                                          FRS_SYSVOL_SECTION,
                                          HKey,
                                          SYSVOL_INFO_IS_COMMITTED);
            if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_FILE_NOT_FOUND) {
                goto cleanup;
            }

            //
            // Delete the subkeys
            //
            do {
                WStatus = RegEnumKey(HKey, 0, KeyBuf, MAX_PATH + 1);
                if (WIN_SUCCESS(WStatus)) {
                    WStatus = NtFrsApiDeleteKey(NTFRSAPI_MODULE,
                                                ErrorCallBack,
                                                FRS_SYSVOL_SECTION,
                                                HKey,
                                                KeyBuf);
                    if (!WIN_SUCCESS(WStatus)) {
                        goto cleanup;
                    }
                }
            } while (WIN_SUCCESS(WStatus));

            if (WStatus != ERROR_NO_MORE_ITEMS) {
                NTFRSAPI_DBG_PRINT2("Prepare: RegEnumKey(%ws); %d\n",
                                    FRS_SYSVOL_SECTION, WStatus);
                CLEANUP_CB(ErrorCallBack, FRS_SYSVOL_SECTION, WStatus, cleanup);
            }

            //
            // Restart the service
            //
            NTFRSAPI_DBG_PRINT0("Prepare: Restart service\n");
            if (!StartService(ServiceHandle, 0, NULL)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT2("Prepare: StartService(%ws); %d\n",
                                    NtFrsApi_ServiceLongName, WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }
            //
            // Wait for the service to start
            //
            WStatus = NtFrsApi_WaitForService(ServiceHandle,
                                              NtFrsApi_ServiceWaitHint,
                                              SERVICE_START_PENDING,
                                              SERVICE_RUNNING);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = FRS_ERR_STARTING_SERVICE;
                goto cleanup;
            }

            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
            NtFrsApi_State = NTFRSAPI_PREPARED;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            if (ServiceHandle) {
                CloseServiceHandle(ServiceHandle);
            }
            FRS_REG_CLOSE(HKey);
            FRS_REG_CLOSE(HNetKey);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }
done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT1("Prepare done: %d\n", WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_PrepareForPromotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function prepares the NtFrs service on this machine for
    promotion by stopping the service, deleting old promotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define  NTFRSAPI_MODULE "NtFrsApi_PrepareForPromotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PREPARE();

    NTFRSAPI_DBG_PRINT0("\n");
    NTFRSAPI_DBG_PRINT0("=============== Promotion Start:\n");
    NTFRSAPI_DBG_PRINT0("\n");

    NTFRSAPI_DBG_PRINT0("Prepare promotion:\n");
    WStatus = NtFrsApi_Prepare(ErrorCallBack, FALSE);
    NTFRSAPI_DBG_PRINT1("Prepare promotion done: %d\n", WStatus);
    return WStatus;
}


PVOID *
DsDeleteFindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
#undef NTFRSAPI_MODULE
#define  NTFRSAPI_MODULE  "DsDeleteFindValues:"
    PWCHAR          Attr;       // Retrieved from an ldap entry
    BerElement      *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
         Attr != NULL;
         Attr = ldap_next_attribute(Ldap, LdapEntry, Ber)) {
        if (WSTR_EQ(DesiredAttr, Attr)) {
            //
            // Return the values for DesiredAttr
            //
            return ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    return NULL;
}


VOID
WINAPI
DsDeletePrepare(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials   OPTIONAL
    )
/*++
Routine Description:
    Called from NtFrsApi_PrepareForDemotionW().

    Squirrel away an ldap binding to another DS. After the
    demotion is committed, the settings, set, member, subscriptions,
    and subscriber objects will be deleted.

Arguments:

    Credentials -- Credentionals to use in ldap binding call, if supplied.

Return Value:
    None.
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "DsDeletePrepare:"
    DWORD                   WStatus;
    DWORD                   Idx;
    DWORD                   LStatus = LDAP_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PLDAPMessage            LdapEntry;
    PLDAPMessage            LdapMsg = NULL;
    PWCHAR                  *LdapValues = NULL;
    PWCHAR                  LdapValue;
    PWCHAR                  Attrs[3];
    PWCHAR                  DomainName;
    PWCHAR                  DomainControllerName = NULL;
    PWCHAR                  DomainControllerAddress = NULL;
    struct l_timeval        Timeout;

    DWORD                   InfoFlags;
    CHAR                    FlagBuffer[220];
    ULONG                   ulOptions;

    DsDeleteLdap = NULL;

    //
    // computer name
    //
    Idx = MAX_COMPUTERNAME_LENGTH + 2;
    if (!GetComputerNameEx(ComputerNameNetBIOS, DsDeleteComputerName, &Idx)) {
        NTFRSAPI_DBG_PRINT1("ERROR - Can't get computer name; %d\n", GetLastError());
        goto CLEANUP;
    }
    NTFRSAPI_DBG_PRINT1("Computer name is %ws\n", DsDeleteComputerName);
    //
    // domain name
    //
    Idx = MAX_PATH + 2;
    if (!GetComputerNameEx(ComputerNameDnsDomain, DsDeleteDomainDnsName, &Idx)) {
        NTFRSAPI_DBG_PRINT1("ERROR - Can't get domain name; %d\n", GetLastError());
        goto CLEANUP;
    }
    NTFRSAPI_DBG_PRINT1("Domain name is %ws\n", DsDeleteDomainDnsName);

    //
    // Find any DC in our hierarchy of DCs
    //
    DomainName = DsDeleteDomainDnsName;
FIND_DC:
    NTFRSAPI_DBG_PRINT1("Trying domain name is %ws\n", DomainName);
    WStatus = DsGetDcName(NULL,    // Computer to remote to
                          DomainName,
                          NULL,    // Domain Guid
                          NULL,    // Site Guid
                          DS_DIRECTORY_SERVICE_REQUIRED |
                          DS_WRITABLE_REQUIRED          |
                          DS_BACKGROUND_ONLY            |
                          DS_AVOID_SELF,
                          &DcInfo); // Return info
    //
    // Report the error and retry for any DC
    //
    if (!WIN_SUCCESS(WStatus)) {
        DcInfo = NULL;
        NTFRSAPI_DBG_PRINT2("WARN - Could not get DC Info for %ws; WStatus %d\n",
                            DomainName, WStatus);
        //
        // Try the parent domain
        //
        while (*DomainName && *DomainName != L'.') {
            ++DomainName;
        }
        if (*DomainName) {
            ++DomainName;
            goto FIND_DC;
        }
        goto CLEANUP;
    }
    NTFRSAPI_DBG_PRINT1("DomainControllerName   : %ws\n", DcInfo->DomainControllerName);
    NTFRSAPI_DBG_PRINT1("DomainControllerAddress: %ws\n", DcInfo->DomainControllerAddress);
    NTFRSAPI_DBG_PRINT1("DomainControllerType   : %08x\n",DcInfo->DomainControllerAddressType);
    NTFRSAPI_DBG_PRINT1("DomainName             : %ws\n", DcInfo->DomainName);
    NTFRSAPI_DBG_PRINT1("DcSiteName             : %ws\n", DcInfo->DcSiteName);
    NTFRSAPI_DBG_PRINT1("ClientSiteName         : %ws\n", DcInfo->ClientSiteName);

    InfoFlags = DcInfo->Flags;
    FrsFlagsToStr(InfoFlags, NtFrsApi_DsGetDcInfoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    NTFRSAPI_DBG_PRINT2("Flags                  : %08x Flags [%s]\n",InfoFlags, FlagBuffer);

    //
    // Open and bind to the DS
    //
    //
    // if ldap_open is called with a server name the api will call DsGetDcName
    // passing the server name as the domainname parm...bad, because
    // DsGetDcName will make a load of DNS queries based on the server name,
    // it is designed to construct these queries from a domain name...so all
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up
    // as referrals/forwarders are contacted to attempt to resolve the bogus
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
    // after the ldap_init but before any other operation using the ldap
    // handle from ldap_init, the delayed connection setup will not call
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
    // will detect that and use the address directly.
    //
    // The presence of the LDAP_OPT_DNSDOMAIN_NAME flag tells the ldap client
    // to ensure that the server is really a DC (By constructing the three 
    // part SPN when performing the LDAP bind.) This enables mutual 
    // authentication.
    //

    //
    // Trim the leadinf \\ because ldap does not like it.
    //

//    DsDeleteLdap = ldap_open(DcInfo->DomainControllerName, LDAP_PORT);

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    Timeout.tv_sec = NTFRSAPI_LDAP_CONNECT_TIMEOUT;
    Timeout.tv_usec = 0;

    //
    // Try using DomainControllerName first.
    //

    if (DcInfo->DomainControllerName != NULL) {
        DomainControllerName = DcInfo->DomainControllerName;
        FRS_TRIM_LEADING_2SLASH(DomainControllerName);

        DsDeleteLdap = ldap_init(DomainControllerName, LDAP_PORT);
        if (DsDeleteLdap != NULL) {
            ldap_set_option(DsDeleteLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            //
            // Request mutual auth.
            //
            LStatus = ldap_set_option(DsDeleteLdap, LDAP_OPT_DNSDOMAIN_NAME, &DomainName);
            if (LStatus != LDAP_SUCCESS) {
                NTFRSAPI_DBG_PRINT2("ERROR - Can not set option LDAP_OPT_DNSDOMAIN_NAME while connecting to the DS on %ws; %ws)\n",
                                    DomainControllerName, ldap_err2string(LStatus));
                ldap_unbind_s(DsDeleteLdap);
                DsDeleteLdap = NULL;
            } else {
                LStatus = ldap_connect(DsDeleteLdap, &Timeout);
                if (LStatus != LDAP_SUCCESS) {
                    NTFRSAPI_DBG_PRINT2("ERROR - Connecting to the DS on %ws; %ws)\n",
                                        DomainControllerName, ldap_err2string(LStatus));
                    ldap_unbind_s(DsDeleteLdap);
                    DsDeleteLdap = NULL;
                }
            }
        }
    }


    //
    // Try using DomainControllerAddress next.
    //
    if ((DsDeleteLdap == NULL) && (DcInfo->DomainControllerAddress != NULL)) {

        DomainControllerAddress = DcInfo->DomainControllerAddress;
        FRS_TRIM_LEADING_2SLASH(DomainControllerAddress);

        DsDeleteLdap = ldap_init(DomainControllerAddress, LDAP_PORT);
        if (DsDeleteLdap != NULL) {
            ldap_set_option(DsDeleteLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            //
            // Request mutual auth.
            //
            LStatus = ldap_set_option(DsDeleteLdap, LDAP_OPT_DNSDOMAIN_NAME, &DomainName);
            if (LStatus != LDAP_SUCCESS) {
                NTFRSAPI_DBG_PRINT2("ERROR - Can not set option LDAP_OPT_DNSDOMAIN_NAME while connecting to the DS on %ws; %ws)\n",
                                    DomainControllerName, ldap_err2string(LStatus));
                ldap_unbind_s(DsDeleteLdap);
                DsDeleteLdap = NULL;
            } else {
                LStatus = ldap_connect(DsDeleteLdap, &Timeout);
                if (LStatus != LDAP_SUCCESS) {
                    NTFRSAPI_DBG_PRINT2("ERROR - Connecting to the DS on %ws; %ws)\n",
                                        DomainControllerAddress, ldap_err2string(LStatus));
                    ldap_unbind_s(DsDeleteLdap);
                    DsDeleteLdap = NULL;
                }
            }
        }
    }

    //
    // Can not connect to DC. Give up.
    //
    if (DsDeleteLdap == NULL) {
        goto CLEANUP;
    }

    LStatus = ldap_bind_s(DsDeleteLdap, NULL, (PWCHAR) Credentials, LDAP_AUTH_NEGOTIATE);
    if (LStatus != LDAP_SUCCESS) {
        NTFRSAPI_DBG_PRINT2("ERROR - Binding to the DS on %ws; %ws)\n",
                            DcInfo->DomainControllerName, ldap_err2string(LStatus));
        ldap_unbind_s(DsDeleteLdap);
        DsDeleteLdap = NULL;
        goto CLEANUP;
    }
    //
    // Fetch the naming contexts
    //
    Attrs[0] = ATTR_NAMING_CONTEXTS;
    Attrs[1] = ATTR_DEFAULT_NAMING_CONTEXT;
    Attrs[2] = NULL;
    LStatus = ldap_search_s(DsDeleteLdap,
                            CN_ROOT,
                            LDAP_SCOPE_BASE,
                            CATEGORY_ANY,
                            Attrs,
                            0,
                            &LdapMsg);
    if (LStatus != LDAP_SUCCESS) {
        NTFRSAPI_DBG_PRINT2("ERROR - Getting naming contexts from %ws; %ws\n",
                            DcInfo->DomainControllerName, ldap_err2string(LStatus));
        goto CLEANUP;
    }

    LdapEntry = ldap_first_entry(DsDeleteLdap, LdapMsg);
    if (!LdapEntry) {
        NTFRSAPI_DBG_PRINT1("ERROR - No naming contexts for %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }

    //
    // ATTR_NAMING_CONTEXTS
    //      Configuration, Schema, and ???
    //
    LdapValues = (PWCHAR *)DsDeleteFindValues(DsDeleteLdap,
                                              LdapEntry,
                                              ATTR_NAMING_CONTEXTS);
    if (!LdapValues) {
        NTFRSAPI_DBG_PRINT1("ERROR - no values for naming contexts for %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }

    //
    // Now, find the naming context that begins with "cn=configuration"
    //
    Idx = ldap_count_values(LdapValues);
    while (Idx--) {
        if (!LdapValues[Idx]) {
            continue;
        }
        _wcslwr(LdapValues[Idx]);
        LdapValue = wcsstr(LdapValues[Idx], CONFIG_NAMING_CONTEXT);
        if (LdapValue && LdapValue == LdapValues[Idx]) {
            break;
        } else {
            LdapValue = NULL;
        }
    }
    if (!LdapValue) {
        NTFRSAPI_DBG_PRINT1("ERROR - No configuration naming context from %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }
    if (wcslen(LdapValue) >= sizeof(DsDeleteConfigDn)) {
        NTFRSAPI_DBG_PRINT1("ERROR - Buffer too small for configuration naming context from %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }
    wcscpy(DsDeleteConfigDn, LdapValue);
    NTFRSAPI_DBG_PRINT1("Configuration naming context is %ws\n", DsDeleteConfigDn);
    ldap_value_free(LdapValues);
    LdapValues = NULL;


    //
    // ATTR_DEFAULT_NAMING_CONTEXT
    //
    LdapValues = (PWCHAR *)DsDeleteFindValues(DsDeleteLdap,
                                              LdapEntry,
                                              ATTR_DEFAULT_NAMING_CONTEXT);
    if (!LdapValues || !LdapValues[0]) {
        NTFRSAPI_DBG_PRINT1("ERROR - No values for default naming context from %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }

    if (wcslen(LdapValues[0]) >= sizeof(DsDeleteDefaultDn)) {
        NTFRSAPI_DBG_PRINT1("ERROR - Buffer too small for Domain naming context from %ws\n",
                            DcInfo->DomainControllerName);
        goto CLEANUP;
    }

    wcscpy(DsDeleteDefaultDn, LdapValues[0]);
    NTFRSAPI_DBG_PRINT1("Default naming context is %ws\n", DsDeleteDefaultDn);
    ldap_value_free(LdapValues);
    LdapValues = NULL;

CLEANUP:
    if (LdapMsg) {
        ldap_msgfree(LdapMsg);
    }
    if (LdapValues) {
        ldap_value_free(LdapValues);
    }
    if (DcInfo) {
        NetApiBufferFree(DcInfo);
        DcInfo = NULL;
    }
}


VOID
WINAPI
DsDeleteCommit(
    VOID
    )
/*++
Routine Description:
    Called from NtFrsApi_CommitDemotionW().

    Use the binding squirreled away by DsDeletePrepare() to attempt
    the deletion of the settings, set, member, subscriptions, and
    subscriber objects.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "DsDeleteCommit:"
    DWORD                   Idx;
    DWORD                   LStatus;
    LONG                    Count;
    PNTFRSAPI_THREAD        Thread;
    PFQDN_CONSTRUCTION_TABLE Entry;
    PWCHAR                  ArgTable[FQDN_MAX_COUNT];
    WCHAR                   Dn[MAX_DN+1];

    //
    // No binding; done
    //
    if (!DsDeleteLdap) {
        goto CLEANUP;
    }

    //
    // For each sysvol
    //
    for (Thread = NtFrsApi_Threads, Idx = 0;
         Thread && Idx < NtFrsApi_NumberOfThreads;
         Thread = Thread->Next, ++Idx) {

        //
        // First make a copy of the standard argument table and then update the
        // entries to point to variable arguments.  Most of the standard argument
        // entries point to contstant name strings or to Global Strings.
        //
        CopyMemory(ArgTable,  FQDN_StdArgTable, sizeof(ArgTable));

        if (Thread->ReplicaSetName != NULL) {
            ArgTable[FQDN_RepSetName] = Thread->ReplicaSetName;;
        }

        //
        // Loop thru the entries in the FrsDsObjectDeleteTable, build each
        // FQDN string and make the call to delete the object.
        //
        Entry = FrsDsObjectDeleteTable;

        while (Entry->Description != NULL) {

            //
            // Construct the FQDN string for the object.
            //
            Count = _snwprintf(Dn, MAX_DN, Entry->Format,
                               ArgTable[Entry->Arg[0]], ArgTable[Entry->Arg[1]],
                               ArgTable[Entry->Arg[2]], ArgTable[Entry->Arg[3]],
                               ArgTable[Entry->Arg[4]], ArgTable[Entry->Arg[5]],
                               ArgTable[Entry->Arg[6]], ArgTable[Entry->Arg[7]]);
            //
            // Delete the object.
            //
            if (Count > 0) {
		Dn[Count] = UNICODE_NULL;
                NTFRSAPI_DBG_PRINT2("%s: %ws\n", Entry->Description, Dn);

                LStatus = ldap_delete_s(DsDeleteLdap, Dn);

                if (LStatus != LDAP_SUCCESS && LStatus != LDAP_NO_SUCH_OBJECT) {
                    NTFRSAPI_DBG_PRINT4("ERROR - Can't delete %s (%ws) for %ws; %ws\n",
                                        Entry->Description, Dn, ArgTable[FQDN_RepSetName],
                                        ldap_err2string(LStatus));
                }
            } else {
                NTFRSAPI_DBG_PRINT2("ERROR - Can't construct %s for %ws\n",
                                    Entry->Description, ArgTable[FQDN_RepSetName]);
            }

            Entry++;
        }

    }

CLEANUP:
    if (DsDeleteLdap) {
        ldap_unbind_s(DsDeleteLdap);
        DsDeleteLdap = NULL;
    }
}


DWORD
WINAPI
NtFrsApi_PrepareForDemotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_PrepareForDemotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PREPARE();

    NTFRSAPI_DBG_PRINT0("\n");
    NTFRSAPI_DBG_PRINT0("=============== Demotion Starting: \n");
    NTFRSAPI_DBG_PRINT0("\n");

    NTFRSAPI_DBG_PRINT0("Prepare demotion:\n");
    WStatus = NtFrsApi_Prepare(ErrorCallBack, TRUE);
    NTFRSAPI_DBG_PRINT1("Prepare demotion done: %d\n", WStatus);

    NTFRSAPI_DBG_PRINT0("Prepare delete:\n");
    DsDeletePrepare(NULL);
    NTFRSAPI_DBG_PRINT1("Prepare delete done: %d\n", WStatus);

    return WStatus;
}




DWORD
WINAPI
NtFrsApi_PrepareForDemotionUsingCredW(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN HANDLE ClientToken,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    Credentials -- Credentionals to use in ldap binding call, if supplied.

    ClientToken -- Impersonation token to use if no Credentials supplied.


Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_PrepareForDemotionUsingCredW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PREPARE();

    NTFRSAPI_DBG_PRINT0("\n");
    NTFRSAPI_DBG_PRINT0("=============== Demotion Starting: \n");
    NTFRSAPI_DBG_PRINT0("\n");

    NTFRSAPI_DBG_PRINT0("Prepare demotion:\n");
    WStatus = NtFrsApi_Prepare(ErrorCallBack, TRUE);
    NTFRSAPI_DBG_PRINT1("Prepare demotion done: %d\n", WStatus);

    NTFRSAPI_DBG_PRINT0("Prepare delete:\n");

    if ((Credentials == NULL) && HANDLE_IS_VALID(ClientToken)) {
        if (ImpersonateLoggedOnUser( ClientToken )) {
            DsDeletePrepare(Credentials);
            NTFRSAPI_DBG_PRINT0("Prepare delete done.\n");
            RevertToSelf();
        } else {
            WStatus = GetLastError();
            NTFRSAPI_DBG_PRINT1("Prepare delete: ImpersonateLoggedOnUser failed: %d\n", WStatus);
        }
    } else {
        DsDeletePrepare(Credentials);
        NTFRSAPI_DBG_PRINT0("Prepare delete done.\n");
    }


    return WStatus;
}


DWORD
WINAPI
NtFrsApi_Abort(
    VOID
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC) and stops replication
    when a server is demoted from a DC by tombstoning the system
    volume's replica set.

    This function aborts the seeding or tombstoning process by
    stopping the service, deleting the state from the registry,
    cleaning up the active threads and the active RPC calls,
    and finally resetting the service to its pre-seeding/tombstoning
    state.

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Abort:"
    DWORD               WStatus;
    SERVICE_STATUS      ServiceStatus;
    PNTFRSAPI_THREAD    Thread;
    HKEY                HKey = INVALID_HANDLE_VALUE;
    SC_HANDLE           ServiceHandle = NULL;
    WCHAR               KeyBuf[MAX_PATH + 1];

    try {
        //
        // Acquire all locks
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);
        EnterCriticalSection(&NtFrsApi_ThreadLock);

        NTFRSAPI_DBG_PRINT0("Abort: \n");

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED &&
            NtFrsApi_State != NTFRSAPI_PREPARED_SERVICE) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }
        NtFrsApi_State = NTFRSAPI_ABORTING;

        //
        // Stop the service, kill off the active threads,
        // delete old state from the registry, and restart
        // the service if it was running prior to the call
        // to NtFrsApi_PrepareForPromotionW.
        //
        try {
            //
            // Set the shutdown event
            //
            SetEvent(NtFrsApi_ShutDownEvent);

            //
            // Abort the threads
            //
            NTFRSAPI_DBG_PRINT0("Abort: threads\n");
            while (Thread = NtFrsApi_Threads) {
                NtFrsApi_Threads = Thread->Next;
                NtFrsApi_FreeThread(Thread);
            }

            //
            // Open the service
            //
            WStatus = NtFrsApi_GetServiceHandle(NULL, &ServiceHandle);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Get the service's state
            //
            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Abort: QueryServiceStatus(); %d\n", WStatus);
                goto cleanup;
            }

            //
            // Stop the service
            //
            NTFRSAPI_DBG_PRINT0("Abort: service\n");

            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                WStatus = NtFrsApi_StopService(ServiceHandle, &ServiceStatus);
                if (!WIN_SUCCESS(WStatus)) {
                    goto cleanup;
                }
            }

            //
            // Delete old state from the registry
            //
            //
            // Open the ntfrs parameters\sysvol section in the registry
            //
            NTFRSAPI_DBG_PRINT0("Abort: registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        NULL,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Delete the value that indicates the sysvol subkeys are valid
            //
            WStatus = NtFrsApiDeleteValue(NTFRSAPI_MODULE,
                                          NULL,
                                          FRS_SYSVOL_SECTION,
                                          HKey,
                                          SYSVOL_INFO_IS_COMMITTED);
            if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_FILE_NOT_FOUND) {
                goto cleanup;
            }

            //
            // Delete the subkeys
            //
            do {
                WStatus = RegEnumKey(HKey, 0, KeyBuf, MAX_PATH + 1);
                if (WIN_SUCCESS(WStatus)) {
                    WStatus = NtFrsApiDeleteKey(NTFRSAPI_MODULE,
                                                NULL,
                                                FRS_SYSVOL_SECTION,
                                                HKey,
                                                KeyBuf);
                    if (!WIN_SUCCESS(WStatus)) {
                        goto cleanup;
                    }
                }
            } while (WIN_SUCCESS(WStatus));

            if (WStatus != ERROR_NO_MORE_ITEMS) {
                NTFRSAPI_DBG_PRINT2("Abort: RegEnumKey(%ws); %d\n",
                                    FRS_SYSVOL_SECTION, WStatus);
                CLEANUP_CB(NULL, FRS_SYSVOL_SECTION, WStatus, cleanup);
            }

            //
            // Restart the service if needed
            //
            if (NtFrsApi_ServiceState == SERVICE_RUNNING) {
                NTFRSAPI_DBG_PRINT0("Abort: restarting\n");
                if (!StartService(ServiceHandle, 0, NULL)) {

                    WStatus = GetLastError();
                    NTFRSAPI_DBG_PRINT2("Abort: StartService(%ws); %d\n",
                                        NtFrsApi_ServiceLongName, WStatus);
                    CLEANUP_CB(NULL, NtFrsApi_ServiceLongName, WStatus, cleanup);
                }

                //
                // Wait for the service to start
                //
                WStatus = NtFrsApi_WaitForService(ServiceHandle,
                                                  NtFrsApi_ServiceWaitHint,
                                                  SERVICE_START_PENDING,
                                                  SERVICE_RUNNING);
                if (!WIN_SUCCESS(WStatus)) {
                    WStatus = FRS_ERR_STARTING_SERVICE;
                    goto cleanup;
                }
            }

            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
            NtFrsApi_State = NTFRSAPI_ABORTED;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            if (ServiceHandle) {
                CloseServiceHandle(ServiceHandle);
            }
            FRS_REG_CLOSE(HKey);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }
done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        LeaveCriticalSection(&NtFrsApi_ThreadLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT1("Abort done: %d\n", WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_AbortPromotionW(
    VOID
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function aborts the seeding process by stopping the service,
    deleting the promotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-seeding state.

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_AbortPromotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PRINT0("Abort promotion: \n");
    WStatus = NtFrsApi_Abort();
    NTFRSAPI_DBG_PRINT1("Abort promotion done: %d\n", WStatus);
    NTFRSAPI_DBG_UNPREPARE();
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_AbortDemotionW(
    VOID
    )
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function aborts the tombstoning process by stopping the service,
    deleting the demotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-tombstoning state.

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_AbortDemotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PRINT0("Abort demotion:\n");
    WStatus = NtFrsApi_Abort();
    NTFRSAPI_DBG_PRINT1("Abort demotion done: %d\n", WStatus);
    NTFRSAPI_DBG_UNPREPARE();
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_StartPromotion_Thread(
    IN PNTFRSAPI_THREAD Thread
    )
/*++
Routine Description:

    THIS FUNCTION IS A THREAD ENTRY!

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This thread that updates the sysvol information in the registry
    and initiates the seeding process. The thread tracks the progress
    of the seeding and periodically informs the caller.

    The threads started by NtFrsApi_StartPromotionW can be forcefully
    terminated with NtFrsApi_AbortPromotionW.

    The threads started by NtFrsApi_StartPromotionW can be waited on
    with NtFrsApi_WaitForPromotionW.

Arguments:
    Thread  - thread context

Return Value:
    Win32 Status and updates to the thread context.
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_StartPromotion_Thread:"
    DWORD       WStatus, WStatus1;
    DWORD       WaitStatus;
    HKEY        HKey = INVALID_HANDLE_VALUE;
    HKEY        HSubKey = INVALID_HANDLE_VALUE;
    handle_t    Handle = NULL;

    try {
        try {
            //
            // Abort client RPC calls on demand
            //
            WStatus = RpcMgmtSetCancelTimeout(0);
            if (!WIN_SUCCESS(WStatus)) {
                NTFRSAPI_DBG_PRINT1("Promotion thread start: RpcMgmtSetCancelTimeout(); %d\n",
                                    WStatus);
                CLEANUP_CB(Thread->ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }

            NTFRSAPI_DBG_PRINT1("Promotion thread start: Parent %ws\n", Thread->ParentComputer);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Account %ws\n", Thread->ParentAccount);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Set %ws\n", Thread->ReplicaSetName);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Type %ws\n", Thread->ReplicaSetType);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Primary %d\n", Thread->ReplicaSetPrimary);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Stage %ws\n", Thread->ReplicaSetStage);
            NTFRSAPI_DBG_PRINT1("Promotion thread start: Root %ws\n", Thread->ReplicaSetRoot);

            //
            // Update the registry and initiate the seeding process
            //

            //
            // Set new state in the registry
            //
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        Thread->ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Create the subkey for this set
            //
            WStatus = NtFrsApiCreateKey(NTFRSAPI_MODULE,
                                        Thread->ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        HKey,
                                        Thread->ReplicaSetName,
                                        &HSubKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Set the subkey's values
            //
            //
            // Replica set parent
            //
            if (Thread->ParentComputer) {
                WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                             Thread->ErrorCallBack,
                                             FRS_SYSVOL_SECTION,
                                             HSubKey,
                                             REPLICA_SET_PARENT,
                                             REG_SZ,
                                             (PCHAR)Thread->ParentComputer,
                                             (wcslen(Thread->ParentComputer) + 1) * sizeof(WCHAR));
                if (!WIN_SUCCESS(WStatus)) {
                    goto cleanup;
                }
            }
            //
            // Replica set command
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_COMMAND,
                                         REG_SZ,
                                         (PCHAR)L"Create",
                                         (wcslen(L"Create") + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set name
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_NAME,
                                         REG_SZ,
                                         (PCHAR)Thread->ReplicaSetName,
                                         (wcslen(Thread->ReplicaSetName) + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set type
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_TYPE,
                                         REG_SZ,
                                         (PCHAR)Thread->ReplicaSetType,
                                         (wcslen(Thread->ReplicaSetType) + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set primary
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_PRIMARY,
                                         REG_DWORD,
                                         (PCHAR)&Thread->ReplicaSetPrimary,
                                         sizeof(DWORD));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set root
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_ROOT,
                                         REG_SZ,
                                         (PCHAR)Thread->ReplicaSetRoot,
                                         (wcslen(Thread->ReplicaSetRoot) + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set stage
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_STAGE,
                                         REG_SZ,
                                         (PCHAR)Thread->ReplicaSetStage,
                                         (wcslen(Thread->ReplicaSetStage) + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Bind to the service
            //
            WStatus = NtFrsApi_BindWithAuth(NULL, NULL, &Handle);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                //
                // Ignore errors until reboot
                //
                Thread->ServiceState = NTFRSAPI_SERVICE_DONE;
                Thread->ServiceWStatus = ERROR_SUCCESS;
                WStatus = ERROR_SUCCESS;
                goto cleanup;
            }

            //
            // Tell the service to start the promotion by demoting
            // existing sysvols.
            //
            NTFRSAPI_DBG_PRINT1("Promotion thread rpc demote: Set %ws\n",
                                Thread->ReplicaSetName);
            try {
                WStatus = NtFrsApi_Rpc_StartDemotionW(Handle, L"");
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
            NTFRSAPI_DBG_PRINT2("Promotion thread rpc demote done: %d (%08x)\n",
                                WStatus, WStatus);
            //
            // Ignore errors; sysvol will be seeded after promotion
            //
            // if (!WIN_SUCCESS(WStatus)) {
                // WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                // goto cleanup;
            // }
            //
            //
            Thread->ServiceState = NTFRSAPI_SERVICE_DONE;
            Thread->ServiceWStatus = ERROR_SUCCESS;
            WStatus = ERROR_SUCCESS;

            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            FRS_REG_CLOSE(HKey);
            FRS_REG_CLOSE(HSubKey);

            if (Handle) {
                WStatus1 = RpcBindingFree(&Handle);
                NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }
    } finally {
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    Thread->ThreadWStatus = WStatus;
    NTFRSAPI_DBG_PRINT1("Promotion thread complete: Set %ws\n", Thread->ReplicaSetName);
    NTFRSAPI_DBG_PRINT2("Promotion thread complete: Thread %d, Service %d\n",
                        Thread->ThreadWStatus, Thread->ServiceWStatus);
    SetEvent(Thread->DoneEvent);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_StartPromotionW(
    IN PWCHAR   ParentComputer,                         OPTIONAL
    IN PWCHAR   ParentAccount,                          OPTIONAL
    IN PWCHAR   ParentPassword,                         OPTIONAL
    IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function kicks off a thread that updates the sysvol information
    in the registry and initiates the seeding process. The thread tracks
    the progress of the seeding and periodically informs the caller.

    The threads started by NtFrsApi_StartPromotionW can be forcefully
    terminated with NtFrsApi_AbortPromotionW.

    The threads started by NtFrsApi_StartPromotionW can be waited on
    with NtFrsApi_WaitForPromotionW.

Arguments:
    ParentComputer      - An RPC-bindable name of the computer that is
                          supplying the Directory Service (DS) with its
                          initial state. The files and directories for
                          the system volume are replicated from this
                          parent computer.
    ParentAccount       - A logon account on ParentComputer.
                          NULL == use the caller's credentials
    ParentPassword      - The logon account's password on ParentComputer.
    DisplayCallBack     - Called periodically with a progress display.
    ReplicaSetName      - Name of the replica set.
    ReplicaSetType      - Type of replica set (enterprise or domain)
    ReplicaSetPrimary   - Is this the primary member of the replica set?
    ReplicaSetStage     - Staging path.
    ReplicaSetRoot      - Root path.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_StartPromotionW:"
    DWORD       WStatus;

    try {
        //
        // Acquire global lock within a try-finally
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);

        NTFRSAPI_DBG_PRINT1("Promotion start: Parent %ws\n", ParentComputer);
        NTFRSAPI_DBG_PRINT1("Promotion start: Account %ws\n", ParentAccount);
        NTFRSAPI_DBG_PRINT1("Promotion start: Set %ws\n", ReplicaSetName);
        NTFRSAPI_DBG_PRINT1("Promotion start: Type %ws\n", ReplicaSetType);
        NTFRSAPI_DBG_PRINT1("Promotion start: Primary %d\n", ReplicaSetPrimary);
        NTFRSAPI_DBG_PRINT1("Promotion start: Stage %ws\n", ReplicaSetStage);
        NTFRSAPI_DBG_PRINT1("Promotion start: Root %ws\n", ReplicaSetRoot);

        ParentAccount = NULL;
        ParentPassword = NULL;

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }

        //
        // Update the registry and initiate the seeding process
        //
        try {
            //
            // Check parameters
            //
            // What about kerberos,delegation,impersonation,no account?
            //
            if (!ReplicaSetName  ||
                !ReplicaSetType  ||
                !ReplicaSetStage ||
                !ReplicaSetRoot  ||
                (!ParentComputer  && ReplicaSetPrimary != 1)) {
                WStatus = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            if (WSTR_NE(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
                WSTR_NE(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
                WStatus = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            if (ReplicaSetPrimary != 0 && ReplicaSetPrimary != 1) {
                WStatus = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            WStatus = NtFrsApi_CreateThread(NtFrsApi_StartPromotion_Thread,
                                            ParentComputer,
                                            ParentAccount,
                                            ParentPassword,
                                            DisplayCallBack,
                                            ErrorCallBack,
                                            ReplicaSetName,
                                            ReplicaSetType,
                                            ReplicaSetPrimary,
                                            ReplicaSetStage,
                                            ReplicaSetRoot);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT2("Promotion start done: Set %ws, %d\n",
                        ReplicaSetName, WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_StartDemotion_Thread(
    IN PNTFRSAPI_THREAD Thread
    )
/*++
Routine Description:

    THIS FUNCTION IS A THREAD ENTRY!

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This thread stops replicating the system volume by telling
    the NtFrs service on this machine to tombstone the system
    volume's replica set.

    The threads started by NtFrsApi_StartDemotionW can be forcefully
    terminated with NtFrsApi_AbortDemotionW.

    The threads started by NtFrsApi_StartDemotionW can be waited on
    with NtFrsApi_WaitForDemotionW.

Arguments:
    Thread  - thread context

Return Value:
    Win32 Status and updated thread context
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_StartDemotion_Thread:"
    DWORD       WStatus, WStatus1;
    HKEY        HKey = INVALID_HANDLE_VALUE;
    HKEY        HSubKey = INVALID_HANDLE_VALUE;
    handle_t    Handle = NULL;


    try {
        try {
            //
            // Abort client RPC calls on demand
            //
            WStatus = RpcMgmtSetCancelTimeout(0);
            if (!WIN_SUCCESS(WStatus)) {
                NTFRSAPI_DBG_PRINT1("Demotion thread start: RpcMgmtSetCancelTimeout(); %d\n", WStatus);
                CLEANUP_CB(Thread->ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }
            NTFRSAPI_DBG_PRINT1("Demotion thread start: Set %ws\n", Thread->ReplicaSetName);

            //
            // Update the registry and initiate the seeding process
            //

            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        Thread->ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Create the subkey for this set
            //
            WStatus = NtFrsApiCreateKey(NTFRSAPI_MODULE,
                                        Thread->ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        HKey,
                                        Thread->ReplicaSetName,
                                        &HSubKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Set the subkey's values
            //

            //
            // Replica set command
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_COMMAND,
                                         REG_SZ,
                                         (PCHAR)L"Delete",
                                         (wcslen(L"Delete") + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
            //
            // Replica set name
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         Thread->ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HSubKey,
                                         REPLICA_SET_NAME,
                                         REG_SZ,
                                         (PCHAR)Thread->ReplicaSetName,
                                         (wcslen(Thread->ReplicaSetName) + 1) * sizeof(WCHAR));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Bind to the service
            //
            WStatus = NtFrsApi_BindWithAuth(NULL,
                        Thread->ErrorCallBack,
                        &Handle);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                goto cleanup;
            }

            //
            // Tell the service to demote the sysvol
            //
            NTFRSAPI_DBG_PRINT1("Demotion thread rpc start: Set %ws\n",
                                Thread->ReplicaSetName);
            try {
                WStatus = NtFrsApi_Rpc_StartDemotionW(Handle,
                                                      Thread->ReplicaSetName);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
            NTFRSAPI_DBG_PRINT3("Demotion thread rpc start done: Set %ws, %d (%08x)\n",
                                Thread->ReplicaSetName, WStatus, WStatus);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                goto cleanup;
            }

            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            FRS_REG_CLOSE(HKey);
            FRS_REG_CLOSE(HSubKey);
            if (Handle) {
                WStatus1 = RpcBindingFree(&Handle);
                NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }
    } finally {
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    Thread->ThreadWStatus = WStatus;
    Thread->ServiceState = NTFRSAPI_SERVICE_DONE;
    Thread->ServiceWStatus = ERROR_SUCCESS;
    NTFRSAPI_DBG_PRINT1("Demotion thread done: Set %ws\n", Thread->ReplicaSetName);
    NTFRSAPI_DBG_PRINT2("Demotion thread done: Thread %d, Service %d\n",
                        Thread->ThreadWStatus, Thread->ServiceWStatus);
    SetEvent(Thread->DoneEvent);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_StartDemotionW(
    IN PWCHAR   ReplicaSetName,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function kicks off a thread that stops replicating the
    system volume by telling the NtFrs service on this machine
    to tombstone the system volume's replica set.

    The threads started by NtFrsApi_StartDemotionW can be forcefully
    terminated with NtFrsApi_AbortDemotionW.

    The threads started by NtFrsApi_StartDemotionW can be waited on
    with NtFrsApi_WaitForDemotionW.

Arguments:
    ReplicaSetName      - Name of the replica set.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_StartDemotionW:"
    DWORD   WStatus;

    try {
        //
        // Acquire global lock within a try-finally
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);
        NTFRSAPI_DBG_PRINT1("Demotion start: Set %ws\n", ReplicaSetName);

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }

        //
        // Update the registry and initiate the seeding process
        //
        try {
            //
            // Check parameters
            //
            if (!ReplicaSetName) {
                WStatus = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            //
            // Create the demotion thread
            //
            WStatus = NtFrsApi_CreateThread(NtFrsApi_StartDemotion_Thread,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            ErrorCallBack,
                                            ReplicaSetName,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Success
            //
            WStatus = ERROR_SUCCESS;
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT2("Demotion start done: Set %ws %d\n",
                        ReplicaSetName, WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_Wait(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN DWORD    TimeoutInMilliSeconds
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC) and stops replicating
    the system volumes when a DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the seeding or tombstoning to finish
    or to stop w/error.

    NOT MT-SAFE.

Arguments:
    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding/tombstoning to finish.
    ErrorCallBack            - Ignored if NULL. Called with additional
                               info about an error.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Wait:"
    DWORD               WStatus;
    DWORD               WaitStatus;
    DWORD               i;
    PNTFRSAPI_THREAD    Thread;
    HANDLE              *Handles = NULL;

    WStatus = ERROR_SUCCESS;

    try {
        //
        // Acquire all locks
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);
        EnterCriticalSection(&NtFrsApi_ThreadLock);

        NTFRSAPI_DBG_PRINT0("Wait: \n");

        //
        // Nothing to wait on
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }
        try {

            //
            // Collect the done events
            //
            NTFRSAPI_DBG_PRINT0("Wait: Threads\n");
            Handles = NtFrsApi_Alloc(NtFrsApi_NumberOfThreads * sizeof(HANDLE));
            for (Thread = NtFrsApi_Threads, i = 0;
                 Thread && i < NtFrsApi_NumberOfThreads;
                 Thread = Thread->Next, ++i) {
                Handles[i] = Thread->DoneEvent;
            }

            //
            // Wait on the threads' done events
            //
            WaitStatus = WaitForMultipleObjects(NtFrsApi_NumberOfThreads,
                                                Handles,
                                                TRUE,
                                                TimeoutInMilliSeconds);
            //
            // Timeout
            //
            if (WaitStatus == WAIT_TIMEOUT) {
                WStatus = ERROR_TIMEOUT;
                goto cleanup;
            }

            //
            // Wait failed
            //
            if (WaitStatus == WAIT_FAILED) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("%s WaitForMultipleObjects(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }

            //
            // Return the threads' status
            //
            NTFRSAPI_DBG_PRINT0("Wait: Status\n");
            for (Thread = NtFrsApi_Threads; Thread; Thread = Thread->Next) {
                //
                // Thread error
                //
                WStatus = Thread->ThreadWStatus;
                if (!WIN_SUCCESS(WStatus)) {
                    goto cleanup;
                }
                //
                // Service error
                //
                WStatus = Thread->ServiceWStatus;
                if (!WIN_SUCCESS(WStatus)) {
                    goto cleanup;
                }
            }
cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            FREE(Handles);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }
done:;

    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        LeaveCriticalSection(&NtFrsApi_ThreadLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT1("Wait done: %d\n", WStatus);
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_WaitForPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish or to stop w/error.

Arguments:
    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_WaitForPromotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PRINT0("Wait promotion: \n");
    WStatus = NtFrsApi_Wait(ErrorCallBack, TimeoutInMilliSeconds);
    NTFRSAPI_DBG_PRINT1("Wait promotion done: %d\n", WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        NtFrsApi_AbortPromotionW();
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_WaitForDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:
    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish or to stop w/error.

Arguments:
    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               tombstoning to finish.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_WaitForDemotionW:"
    DWORD   WStatus;

    NTFRSAPI_DBG_PRINT0("Wait demotion: \n");
    WStatus = NtFrsApi_Wait(ErrorCallBack, TimeoutInMilliSeconds);
    NTFRSAPI_DBG_PRINT1("Wait demotion done: %d\n", WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        NtFrsApi_AbortDemotionW();
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_CommitPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:
    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_CommitPromotionW:"
    DWORD           WStatus;
    SERVICE_STATUS  ServiceStatus;
    DWORD           SysVolInfoIsCommitted = 1;
    DWORD           SysvolReady = 0;
    HKEY            HKey = INVALID_HANDLE_VALUE;
    SC_HANDLE       ServiceHandle = NULL;

    //
    // Wait for the seeding to finish.
    //
    WStatus = NtFrsApi_WaitForPromotionW(TimeoutInMilliSeconds, ErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        NTFRSAPI_DBG_PRINT1("Commit promotion aborted: %d\n", WStatus);
        NTFRSAPI_DBG_FLUSH();
        return WStatus;
    }

    try {
        //
        // Acquire global lock within a try-finally
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);

        NTFRSAPI_DBG_PRINT0("Commit promotion:\n");

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }
        NtFrsApi_State = NTFRSAPI_COMMITTING;

        //
        // Stop the service and commit the new state in the registry
        //
        try {
            //
            // Open the service
            //
            NTFRSAPI_DBG_PRINT0("Commit promotion: service\n");
            WStatus = NtFrsApi_GetServiceHandle(ErrorCallBack, &ServiceHandle);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Stop the service
            //
            WStatus = NtFrsApi_StopService(ServiceHandle, &ServiceStatus);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Commit the new state in the registry
            //
            //
            // Open the ntfrs parameters\sysvol section in the registry
            //
            NTFRSAPI_DBG_PRINT0("Commit promotion: registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Set the value that indicates the sysvol subkeys are valid
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HKey,
                                         SYSVOL_INFO_IS_COMMITTED,
                                         REG_DWORD,
                                         (PCHAR)&SysVolInfoIsCommitted,
                                         sizeof(SysVolInfoIsCommitted));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Service starts automatically at startup
            //
            if (!ChangeServiceConfig(ServiceHandle,
                                     SERVICE_NO_CHANGE,
                                     SERVICE_AUTO_START,
                                     SERVICE_NO_CHANGE,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NtFrsApi_ServiceLongName)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Commit promotion: no auto %d\n", WStatus);
            }

            //
            // Success
            //
            NtFrsApi_State = NTFRSAPI_COMMITTED;
            WStatus = ERROR_SUCCESS;

cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            if (ServiceHandle) {
                CloseServiceHandle(ServiceHandle);
            }
            FRS_REG_CLOSE(HKey);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }
done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT1("Commit promotion done: %d\n", WStatus);
    NTFRSAPI_DBG_UNPREPARE();
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_CommitDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    )
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server
    by tombstoning the system volume's replica set.

    This function waits for the tombstoning to finish, tells the service
    to forcibly delete the system volumes' replica sets, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:
    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               tombstoning to finish.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_CommitDemotionW:"
    DWORD           WStatus, WStatus1;
    SERVICE_STATUS  ServiceStatus;
    DWORD           SysVolInfoIsCommitted = 1;
    DWORD           SysvolReady = 0;
    HKEY            HKey = INVALID_HANDLE_VALUE;
    HKEY            HNetKey = INVALID_HANDLE_VALUE;
    SC_HANDLE       ServiceHandle = NULL;
    handle_t        RpcHandle = NULL;


    //
    // Wait for the demotion to finish.
    //
    WStatus = NtFrsApi_WaitForDemotionW(TimeoutInMilliSeconds, ErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        NTFRSAPI_DBG_PRINT1("Commit demotion aborted: %d\n", WStatus);
        NTFRSAPI_DBG_FLUSH();
        return WStatus;
    }

    try {
        //
        // Acquire global lock within a try-finally
        //
        EnterCriticalSection(&NtFrsApi_GlobalLock);

        NTFRSAPI_DBG_PRINT0("Commit demotion:\n");

        //
        // This function is designed to be called once!
        //
        if (NtFrsApi_State != NTFRSAPI_PREPARED) {
            WStatus = FRS_ERR_INVALID_API_SEQUENCE;
            goto done;
        }
        NtFrsApi_State = NTFRSAPI_COMMITTING;

        //
        // Stop the service and commit the new state in the registry
        //
        try {
            //
            // Set the RPC cancel timeout to "now"
            //
            WStatus = RpcMgmtSetCancelTimeout(0);
            if (!WIN_SUCCESS(WStatus)) {
                NTFRSAPI_DBG_PRINT1("Commit demotion: RpcMgmtSetCancelTimeout(); %d\n", WStatus);
                CLEANUP_CB(ErrorCallBack, NtFrsApi_ServiceLongName, WStatus, cleanup);
            }

            //
            // Bind to the service
            //
            NTFRSAPI_DBG_PRINT0("Commit demotion: service\n");
            //
            // Need to bind with NTLM over LRPC because
            // Kerberos is not available at this point.
            // Actually NTLM authentication would also fail, but the loopback
            // optimization gets around that.
            //
            WStatus = NtFrsApi_BindLocal(ErrorCallBack, &RpcHandle);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                goto cleanup;
            }

            //
            // Tell the service to commit the demotion
            //
            NTFRSAPI_DBG_PRINT0("Commit demotion rpc start:\n");
            try {
                WStatus = NtFrsApi_Rpc_CommitDemotionW(RpcHandle);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
            NTFRSAPI_DBG_PRINT2("Commit demotion rpc done: %d (%08x)\n",
                                WStatus, WStatus);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
                goto cleanup;
            }

            //
            // Open the service
            //
            WStatus = NtFrsApi_GetServiceHandle(ErrorCallBack, &ServiceHandle);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Stop the service
            //
            NTFRSAPI_DBG_PRINT0("Commit demotion: stop service\n");

            WStatus = NtFrsApi_StopService(ServiceHandle, &ServiceStatus);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

            //
            // Commit the new state in the registry
            //
#if 0
            //
            // Open the ntfrs parameters\sysvol section in the registry
            //
            NTFRSAPI_DBG_PRINT0("Commit demotion: registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        ErrorCallBack,
                                        FRS_SYSVOL_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HKey);
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }

// Don't bother committing the "Delete sysvol" registry values because,
// after the reboot, the computer will not have sufficient rights to
// delete the sysvol from the Ds. Hence the call to DsDeleteCommit()
// below. Leave the code as a place holder for now.
            //
            // Set the value that indicates the sysvol subkeys are valid
            //
            WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                         ErrorCallBack,
                                         FRS_SYSVOL_SECTION,
                                         HKey,
                                         SYSVOL_INFO_IS_COMMITTED,
                                         REG_DWORD,
                                         (PCHAR)&SysVolInfoIsCommitted,
                                         sizeof(SysVolInfoIsCommitted));
            if (!WIN_SUCCESS(WStatus)) {
                goto cleanup;
            }
#endif 0

            //
            // Service starts automatically at startup
            //
            if (!ChangeServiceConfig(ServiceHandle,
                                     SERVICE_NO_CHANGE,
                                     SERVICE_AUTO_START,
                                     SERVICE_NO_CHANGE,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NtFrsApi_ServiceLongName)) {
                WStatus = GetLastError();
                NTFRSAPI_DBG_PRINT1("Commit demotion: no auto %d\n", WStatus);
            }

            //
            // Insure access to the netlogon\parameters key
            //
            NTFRSAPI_DBG_PRINT0("Commit Demotion: Netlogon registry\n");
            WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                        NULL,
                                        NETLOGON_SECTION,
                                        KEY_ALL_ACCESS,
                                        &HNetKey);
            if (WIN_SUCCESS(WStatus)) {
                //
                // Tell NetLogon to stop sharing the sysvol
                //
                SysvolReady = 0;
                WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                             NULL,
                                             NETLOGON_SECTION,
                                             HNetKey,
                                             SYSVOL_READY,
                                             REG_DWORD,
                                             (PCHAR)&SysvolReady,
                                             sizeof(DWORD));
            }
            WStatus = ERROR_SUCCESS;

            //
            // Delete our DS objects in some other DS. We cannot delete
            // the objects from the DS on this DC because this DS is
            // going away. We cannot delete the objects in another DS
            // after rebooting because, as a member server, we no longer
            // have permissions to delete our objects.
            //
            // The service will, however, continue to retry the deletes
            // just in case this computer comes up as a DC after the
            // demotion completed. BSTS.
            //
            DsDeleteCommit();

            //
            // Success
            //
            NtFrsApi_State = NTFRSAPI_COMMITTED;
            WStatus = ERROR_SUCCESS;

cleanup:;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }

        //
        // Clean up any handles, events, memory, ...
        //
        try {
            if (ServiceHandle) {
                CloseServiceHandle(ServiceHandle);
            }
            FRS_REG_CLOSE(HKey);
            FRS_REG_CLOSE(HNetKey);
            if (RpcHandle) {
                WStatus1 = RpcBindingFree(&RpcHandle);
                NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Exception (may be RPC)
            //
            GET_EXCEPTION_CODE(WStatus);
        }
done:;
    } finally {
        //
        // Release locks
        //
        LeaveCriticalSection(&NtFrsApi_GlobalLock);
        if (AbnormalTermination()) {
            WStatus = FRS_ERR_INTERNAL_API;
        }
    }
    NTFRSAPI_DBG_PRINT1("Commit demotion done: %d\n", WStatus);
    NTFRSAPI_DBG_UNPREPARE();
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_Set_DsPollingIntervalW(
    IN PWCHAR   ComputerName,       OPTIONAL
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    )
/*++
Routine Description:
    The NtFrs service polls the DS occasionally for configuration changes.
    This API alters the polling interval and, if the service is not
    in the middle of a polling cycle, forces the service to begin a
    polling cycle.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. This API can be used to force the service to use
    the short interval until a stable configuration has been retrieved.
    After which, the service reverts back to the long interval.

    The default values for ShortInterval and LongInterval can be
    changed by setting the parameters to a non-zero value. If zero,
    the current values remain unchanged and a polling cycle is initiated.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    UseShortInterval - If non-zero, the service switches to the short
                       interval until a stable configuration is retrieved
                       from the DS or another call to this API is made.
                       Otherwise, the service uses the long interval.

    LongInterval     - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

    ShortInterval    - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

Return Value:
    Win32 Status
--*/
{
    DWORD       WStatus, WStatus1;
    DWORD       AuthWStatus;
    DWORD       NoAuthWStatus;
    handle_t    AuthHandle    = NULL;
    handle_t    NoAuthHandle  = NULL;

    try {
        //
        // Check LongInterval
        //
        if (LongInterval &&
            (LongInterval < NTFRSAPI_MIN_INTERVAL ||
             LongInterval > NTFRSAPI_MAX_INTERVAL)) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        //
        // Check ShortInterval
        //
        if (ShortInterval &&
            (ShortInterval < NTFRSAPI_MIN_INTERVAL ||
             ShortInterval > NTFRSAPI_MAX_INTERVAL)) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        //
        // Bind to the service with and without authentication
        //
        AuthWStatus = NtFrsApi_BindWithAuth(ComputerName, NULL, &AuthHandle);
        NoAuthWStatus = NtFrsApi_Bind(ComputerName, NULL, &NoAuthHandle);

        //
        // Send Authenticated RPC request to service
        //
        if (HANDLE_IS_VALID(AuthHandle)) {
            try {
                WStatus = NtFrsApi_Rpc_Set_DsPollingIntervalW(AuthHandle,
                                                              UseShortInterval,
                                                              LongInterval,
                                                              ShortInterval);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
        } else {
            WStatus = ERROR_ACCESS_DENIED;
        }
        if (WStatus == ERROR_ACCESS_DENIED) {
            //
            // Send Unauthenticated RPC request to service
            //
            if (HANDLE_IS_VALID(NoAuthHandle)) {
                try {
                    WStatus = NtFrsApi_Rpc_Set_DsPollingIntervalW(NoAuthHandle,
                                                                  UseShortInterval,
                                                                  LongInterval,
                                                                  ShortInterval);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    GET_EXCEPTION_CODE(WStatus);
                }
            } else {
                WStatus = NoAuthWStatus;
            }
        }
        if (!WIN_SUCCESS(WStatus)) {
            WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
            goto CLEANUP;
        }
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Unbind
        //
        if (AuthHandle) {
            WStatus1 = RpcBindingFree(&AuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
        if (NoAuthHandle) {
            WStatus1 = RpcBindingFree(&NoAuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_Get_DsPollingIntervalW(
    IN  PWCHAR  ComputerName,       OPTIONAL
    OUT ULONG   *Interval,
    OUT ULONG   *LongInterval,
    OUT ULONG   *ShortInterval
    )
/*++
Routine Description:
    The NtFrs service polls the DS occasionally for configuration changes.
    This API returns the values the service uses for polling intervals.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. The short interval is also used if the
    NtFrsApi_Set_DsPollingIntervalW() is used to force usage of the short
    interval until a stable configuration has been retrieved. After which,
    the service reverts back to the long interval.

    The value returned in Interval is the polling interval currently in
    use.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    Interval         - The current polling interval in minutes.

    LongInterval     - The long interval in minutes.

    ShortInterval    - The short interval in minutes.

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_Get_DsPollingIntervalW:"
    DWORD       WStatus, WStatus1;
    DWORD       NoAuthWStatus;
    DWORD       AuthWStatus;
    handle_t    AuthHandle    = NULL;
    handle_t    NoAuthHandle  = NULL;

    try {
        //
        // Bind to the service with and without authentication
        //
        AuthWStatus = NtFrsApi_BindWithAuth(ComputerName, NULL, &AuthHandle);
        NoAuthWStatus = NtFrsApi_Bind(ComputerName, NULL, &NoAuthHandle);

        //
        // Send Authenticated RPC request to service
        //
        if (HANDLE_IS_VALID(AuthHandle)) {
            try {
                WStatus = NtFrsApi_Rpc_Get_DsPollingIntervalW(AuthHandle,
                                                              Interval,
                                                              LongInterval,
                                                              ShortInterval);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
        } else {
            WStatus = ERROR_ACCESS_DENIED;
        }
        if (WStatus == ERROR_ACCESS_DENIED || WStatus == RPC_S_CALL_FAILED_DNE) {
            //
            // Send Unauthenticated RPC request to service
            //
            if (HANDLE_IS_VALID(NoAuthHandle)) {
                try {
                    WStatus = NtFrsApi_Rpc_Get_DsPollingIntervalW(NoAuthHandle,
                                                                  Interval,
                                                                  LongInterval,
                                                                  ShortInterval);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    GET_EXCEPTION_CODE(WStatus);
                }
            } else {
                WStatus = NoAuthWStatus;
            }
        }
        if (!WIN_SUCCESS(WStatus)) {
            WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
            goto CLEANUP;
        }
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Unbind
        //
        if (AuthHandle) {
            WStatus1 = RpcBindingFree(&AuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
        if (NoAuthHandle) {
            WStatus1 = RpcBindingFree(&NoAuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_InfoW(
    IN     PWCHAR  ComputerName,       OPTIONAL
    IN     ULONG   TypeOfInfo,
    IN     ULONG   SizeInChars,
    IN OUT PVOID   *NtFrsApiInfo
    )
/*++
Routine Description:
    Return a buffer full of the requested information. The information
    can be extracted from the buffer with NtFrsApi_InfoLineW().

    *NtFrsApiInfo should be NULL on the first call. On subsequent calls,
    *NtFrsApiInfo will be filled in with more data if any is present.
    Otherwise, *NtFrsApiInfo is set to NULL and the memory is freed.

    The SizeInChars is a suggested size; the actual memory usage
    may be different. The function chooses the memory usage if
    SizeInChars is 0.

    The format of the returned information can change without notice.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    TypeOfInfo      - See the constants beginning with NTFRSAPI_INFO_
                      in ntfrsapi.h.

    SizeInChars     - Suggested memory usage; actual may be different.
                      0 == Function chooses memory usage

    NtFrsApiInfo    - Opaque. Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW();

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_InfoW:"
    DWORD           WStatus, WStatus1;
    DWORD           NoAuthWStatus;
    DWORD           AuthWStatus;
    PNTFRSAPI_INFO  Info            = NULL;
    handle_t        AuthHandle      = NULL;
    handle_t        NoAuthHandle    = NULL;

    try {
        //
        // Adjust memory usage
        //
        if (SizeInChars == 0) {
            SizeInChars = NTFRSAPI_DEFAULT_INFO_SIZE;
        } else
        if (SizeInChars < NTFRSAPI_MINIMUM_INFO_SIZE) {
            SizeInChars = NTFRSAPI_MINIMUM_INFO_SIZE;
        }

    if(SizeInChars > NTFRSAPI_DEFAULT_INFO_SIZE) {
        SizeInChars = NTFRSAPI_DEFAULT_INFO_SIZE;
    }

        //
        // Check params
        //
        Info = *NtFrsApiInfo;
        if (Info != NULL) {
            TypeOfInfo = Info->TypeOfInfo;
        }

        //
        // Allocate a large text buffer
        //
        if (Info != NULL) {
            if (!NtFrsApi_InfoMoreW(Info)) {
                NtFrsApi_InfoFreeW(NtFrsApiInfo);
                WStatus = ERROR_SUCCESS;
                goto CLEANUP;
            }
            //
            // Set charstoskip to the value of cumulative count of chars
            // returned.  Note:  In SP3 and XP TotalChars is now a context
            // handle so this is a no-op.  TotalChars is saved in the caller's
            // server side context block.
            //
            Info->CharsToSkip = Info->TotalChars;
        } else {
            //
            // Allocate a buffer and insert the DLL major/minor rev,
            // and the structure size and the type of info request.
            //
            Info = NtFrsApi_Alloc(SizeInChars);
            Info->Major = NTFRS_MAJOR;
            Info->Minor = NTFRS_MINOR;
            Info->SizeInChars = SizeInChars;
            Info->TypeOfInfo = TypeOfInfo;
            //
            // Return the buffer address to the caller.
            //
            *NtFrsApiInfo = Info;
        }
        //
        // Clear the flags and reset the buffer to empty.
        //
        Info->Flags = 0;
        Info->OffsetToFree = (ULONG)(Info->Lines - (PCHAR)Info);
        Info->OffsetToLines = Info->OffsetToFree;

        //
        // Caller only wants info on the api; deliver it
        //
        if (TypeOfInfo == NTFRSAPI_INFO_TYPE_VERSION) {
            NTFRSAPI_IPRINT0(Info, "NtFrsApi Version Information\n");
            NTFRSAPI_IPRINT1(Info, "   NtFrsApi Major      : %d\n", NTFRS_MAJOR);
            NTFRSAPI_IPRINT1(Info, "   NtFrsApi Minor      : %d\n", NTFRS_MINOR);
            NTFRSAPI_IPRINT2(Info, "   NtFrsApi Compiled on: %s %s\n",
                             NtFrsApi_Date, NtFrsApi_Time);
#if    NTFRS_TEST
            NTFRSAPI_IPRINT0(Info, "   NTFRS_TEST Enabled\n");
#endif NTFRS_TEST

        }

        //
        // Bind to the service with and without authentication
        //
        AuthWStatus = NtFrsApi_BindWithAuth(ComputerName, NULL, &AuthHandle);
        if (!WIN_SUCCESS(AuthWStatus)) {
            NTFRSAPI_IPRINT3(Info, "ERROR - Cannot bind w/authentication to computer, %ws; %08x (%d)\n",
                             ComputerName, AuthWStatus, AuthWStatus);
        }

        NoAuthWStatus = NtFrsApi_Bind(ComputerName, NULL, &NoAuthHandle);
        if (!WIN_SUCCESS(NoAuthWStatus)) {
            NTFRSAPI_IPRINT3(Info, "ERROR - Cannot bind w/o authentication to computer, %ws; %08x (%d)\n",
                             ComputerName, NoAuthWStatus, NoAuthWStatus);
        }

        //
        // Send Authenticated RPC request to service
        //
        if (HANDLE_IS_VALID(AuthHandle)) {
            try {
                //
                // Are we sending the entire info buffer over the wire to the
                // service v.s. just the header?????
                //
                WStatus = NtFrsApi_Rpc_InfoW(AuthHandle, Info->SizeInChars, (PBYTE)Info);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
        } else {
            WStatus = ERROR_ACCESS_DENIED;
        }

        if (WStatus == ERROR_ACCESS_DENIED ||
            WStatus == RPC_S_CALL_FAILED_DNE) {
            //
            // Send Unauthenticated RPC request to service
            //
            if (HANDLE_IS_VALID(NoAuthHandle)) {
                try {
                    //
                    // Are we sending the entire info buffer over the wire to the
                    // service v.s. just the header?????
                    //
                    WStatus = NtFrsApi_Rpc_InfoW(NoAuthHandle, Info->SizeInChars, (PBYTE)Info);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    GET_EXCEPTION_CODE(WStatus);
                }
            } else {
                WStatus = NoAuthWStatus;
            }
        }

        if (!WIN_SUCCESS(WStatus)) {
            NTFRSAPI_IPRINT3(Info, "ERROR - Cannot RPC to computer, %ws; %08x (%d)\n",
                             ComputerName, WStatus, WStatus);
            WStatus = ERROR_SUCCESS;
            goto CLEANUP;
        }

        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Unbind
        //
        if (AuthHandle) {
            WStatus1 = RpcBindingFree(&AuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
        if (NoAuthHandle) {
            WStatus1 = RpcBindingFree(&NoAuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
        if (!WIN_SUCCESS(WStatus)) {
            FREE(*NtFrsApiInfo);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApi_InfoLineW(
    IN      PNTFRSAPI_INFO  NtFrsApiInfo,
    IN OUT  PVOID           *InOutLine
    )
/*++
Routine Description:
    Extract the wchar lines of information from NtFrsApiInformation.

    Returns the address of the next L'\0' terminated line of information.
    NULL if none.

Arguments:
    NtFrsApiInfo    - Opaque. Returned by NtFrsApi_InfoW().
                      Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_InfoLineW:"
    DWORD   WStatus;
    PCHAR   NextLine;
    PCHAR   FirstLine;
    PCHAR   FreeLine;

    try {
        //
        // Check input params
        //
        if (InOutLine == NULL) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        if (NtFrsApiInfo == NULL) {
            *InOutLine = NULL;
            WStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        NextLine = *InOutLine;
        //
        // Offset to first line in the returned buffer.
        //
        FirstLine = ((PCHAR)NtFrsApiInfo) + NtFrsApiInfo->OffsetToLines;
        //
        // Offset to first unused byte in the return buffer.
        //
        FreeLine = ((PCHAR)NtFrsApiInfo) + NtFrsApiInfo->OffsetToFree;

        //
        // Get start of next line to return.
        //
        if (NextLine == NULL) {
            NextLine = FirstLine;
        } else {
            if (NextLine < FirstLine) {
                *InOutLine = NULL;
                WStatus = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            if (NextLine < FreeLine) {
                NextLine += strlen(NextLine) + 1;
            }
        }

        if (NextLine >= FreeLine) {
            *InOutLine = NULL;
        } else {
            *InOutLine = NextLine;
        }

        WStatus = ERROR_SUCCESS;

cleanup:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApi_InfoFreeW(
    IN  PVOID   *NtFrsApiInfo
    )
/*++
Routine Description:
    Free the information buffer allocated by NtFrsApi_InfoW();

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_InfoFreeW:"
    DWORD   WStatus;

    try {
        FREE(*NtFrsApiInfo);
        WStatus = ERROR_SUCCESS;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


BOOL
WINAPI
NtFrsApi_InfoMoreW(
    IN  PNTFRSAPI_INFO  NtFrsApiInfo
    )
/*++
Routine Description:
    All of the information may not have fit in the buffer. The additional
    information can be fetched by calling NtFrsApi_InfoW() again with the
    same NtFrsApiInfo struct. NtFrsApi_InfoW() will return NULL in
    NtFrsApiInfo if there is no more information.

    However, the information returned in subsequent calls to _InfoW() may be
    out of sync with the previous information. If the user requires a
    coherent information set, then the information buffer should be freed
    with NtFrsApi_InfoFreeW() and another call made to NtFrsApi_InfoW()
    with an increased SizeInChars. Repeat the procedure until
    NtFrsApi_InfoMoreW() returns FALSE.

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    TRUE    - The information buffer does *NOT* contain all of the info.
    FALSE   - The information buffer does contain all of the info.
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_InfoMoreW:"
    DWORD   WStatus;
    BOOL    BStatus = FALSE;

    try {
        //
        // If we have an info buffer
        // and the info buffer is full
        // and there was at least one line in the info buffer
        // then there is more info.
        //
        if (NtFrsApiInfo &&
            FlagOn(NtFrsApiInfo->Flags, NTFRSAPI_INFO_FLAGS_FULL) &&
            NtFrsApiInfo->OffsetToLines != NtFrsApiInfo->OffsetToFree) {
            BStatus = TRUE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return BStatus;
}


DWORD
WINAPI
NtFrsApiStopServiceForRestore(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    IN DWORD    BurFlags
    )
/*++
Routine Description:

    Old code left over from Version 1.0 of the Backup/restore api.
    Used as subroutine for Version 3.0.

    Stop the service and update the registry.

Arguments:

    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.

    BurFlags         - Callers Backup/Restore flags
Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiStopServiceForRestore:"
    DWORD                   WStatus;
    DWORD                   SizeInChars;
    DWORD                   CharsNeeded;
    DWORD                   Hint;
    BOOL                    IsAutoStart;
    BOOL                    IsRunning;
    DWORD                   BurStopDisposition;
    HKEY                    HBurMvKey = INVALID_HANDLE_VALUE;
    HKEY                    HBurStopKey = INVALID_HANDLE_VALUE;
    SERVICE_STATUS          ServiceStatus;
    SC_HANDLE               ServiceHandle   = NULL;
    QUERY_SERVICE_CONFIG    *ServiceConfig  = NULL;

    try {
        //
        // STOP THE SERVICE
        //
        //
        // Open the service
        //
        WStatus = NtFrsApi_GetServiceHandle(ErrorCallBack, &ServiceHandle);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        //
        // Get Service config
        //
        SizeInChars = 1024;
QUERY_SERVICE_AGAIN:
        ServiceConfig = NtFrsApi_Alloc(SizeInChars);
        if (!QueryServiceConfig(ServiceHandle, ServiceConfig, SizeInChars, &CharsNeeded)) {
            WStatus = GetLastError();

            if (WIN_BUF_TOO_SMALL(WStatus) && CharsNeeded > SizeInChars) {
                SizeInChars = CharsNeeded;
                FREE(ServiceConfig);
                goto QUERY_SERVICE_AGAIN;
            }
            CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
        }
        IsAutoStart = (ServiceConfig->dwStartType == SERVICE_AUTO_START);

        //
        // Get Service status
        //
        if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
            WStatus = GetLastError();
            CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
        }
        IsRunning = (ServiceStatus.dwCurrentState == SERVICE_RUNNING);
        Hint = ServiceStatus.dwWaitHint;

        //
        // Stop the service
        //
        if (IsRunning) {
            if (!ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus)) {

                WStatus = GetLastError();

                if (WStatus == ERROR_SERVICE_REQUEST_TIMEOUT) {
                    WStatus = ERROR_SUCCESS;
                    if (!ControlService(ServiceHandle,
                                        SERVICE_CONTROL_STOP,
                                        &ServiceStatus)) {
                        WStatus = GetLastError();
                        if (WStatus == ERROR_SERVICE_NOT_ACTIVE) {
                            WStatus = ERROR_SUCCESS;
                        }
                    }
                }
            }
            WStatus = NtFrsApi_WaitForService(ServiceHandle,
                                              Hint,
                                              SERVICE_STOP_PENDING,
                                              SERVICE_STOPPED);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = FRS_ERR_STOPPING_SERVICE;
                CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
            }
        }

        //
        // Update the registry
        //

        //
        // Open the ntfrs parameters\backup/restore\Startup section
        //
        WStatus = RegCreateKey(HKEY_LOCAL_MACHINE,
                               FRS_BACKUP_RESTORE_MV_SECTION,
                               &HBurMvKey);
        FRS_REG_CLOSE(HBurMvKey);

        //
        // Re-open using reduced access
        //
        WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                    ErrorCallBack,
                                    FRS_BACKUP_RESTORE_MV_SECTION,
                                    KEY_SET_VALUE,
                                    &HBurMvKey);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                     ErrorCallBack,
                                     FRS_BACKUP_RESTORE_MV_SECTION,
                                     HBurMvKey,
                                     FRS_VALUE_BURFLAGS,
                                     REG_DWORD,
                                     (PCHAR)&BurFlags,
                                     sizeof(DWORD));
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // Create the volatile key to prevent the service from starting
        //
        WStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                 FRS_BACKUP_RESTORE_STOP_SECTION,
                                 0,
                                 NULL,
                                 REG_OPTION_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &HBurStopKey,
                                 &BurStopDisposition);
        if (!WIN_SUCCESS(WStatus)) {
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, FRS_BACKUP_RESTORE_STOP_SECTION, WStatus);
            //
            // Ignore errors
            //
            WStatus = ERROR_SUCCESS;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (ServiceHandle) {
            CloseServiceHandle(ServiceHandle);
        }
        FRS_REG_CLOSE(HBurMvKey);
        FRS_REG_CLOSE(HBurStopKey);
        FREE(ServiceConfig);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiStartServiceAfterRestore(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG) OPTIONAL
    )
/*++
Routine Description:

    Old code from Version 1.0 of the Backup/Restore API. Used
    as subroutine in Version 3.0.

    Restart the service after a restore has completed.

Arguments:

    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.
Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiStartServiceAfterRestore:"
    DWORD                   WStatus;
    DWORD                   SizeInChars;
    DWORD                   CharsNeeded;
    DWORD                   Hint;
    BOOL                    IsAutoStart;
    SERVICE_STATUS          ServiceStatus;
    SC_HANDLE               ServiceHandle   = NULL;
    QUERY_SERVICE_CONFIG    *ServiceConfig  = NULL;

    try {
        //
        // Delete the volatile key that prevents the service from starting
        //
        WStatus = NtFrsApiDeleteKey(NTFRSAPI_MODULE,
                                    NULL,
                                    NULL,
                                    HKEY_LOCAL_MACHINE,
                                    FRS_BACKUP_RESTORE_STOP_SECTION);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Ignore errors
            //
            WStatus = ERROR_SUCCESS;
        }

        //
        // START THE SERVICE
        //
        //
        // Open the service
        //
        WStatus = NtFrsApi_GetServiceHandle(ErrorCallBack, &ServiceHandle);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        //
        // Get Service config
        //
        SizeInChars = 1024;
QUERY_SERVICE_AGAIN:
        ServiceConfig = NtFrsApi_Alloc(SizeInChars);
        if (!QueryServiceConfig(ServiceHandle, ServiceConfig, SizeInChars, &CharsNeeded)) {
            WStatus = GetLastError();
            if (WIN_BUF_TOO_SMALL(WStatus) && CharsNeeded > SizeInChars) {
                SizeInChars = CharsNeeded;
                FREE(ServiceConfig);
                goto QUERY_SERVICE_AGAIN;
            }
            CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
        }
        IsAutoStart = (ServiceConfig->dwStartType == SERVICE_AUTO_START);

        //
        // Get Service status
        //
        if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
            WStatus = GetLastError();
            CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
        }
        Hint = ServiceStatus.dwWaitHint;

        //
        // Restart the service
        //
        if (IsAutoStart) {
            if (!StartService(ServiceHandle, 0, NULL)) {
                WStatus = GetLastError();
                CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
            }

            WStatus = NtFrsApi_WaitForService(ServiceHandle,
                                              Hint,
                                              SERVICE_START_PENDING,
                                              SERVICE_RUNNING);
            if (!WIN_SUCCESS(WStatus)) {
                WStatus = FRS_ERR_STARTING_SERVICE;
                CLEANUP_CB(ErrorCallBack, SERVICE_NAME, WStatus, CLEANUP);
            }
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (ServiceHandle) {
            CloseServiceHandle(ServiceHandle);
        }
        FREE(ServiceConfig);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiMoveCumulativeSets(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG) OPTIONAL
    )
/*++
Routine Description:
    Move the cumulative replica sets currently in the registry into the
    backup/restore key that will (might) be moved into the restored
    registry at the end of restore. This is to maintain as much state
    as possible about un-deleted replica sets. An old registry may
    lack info about new sets that will appear once the current restored
    DS is updated from its partners.

Arguments:
    ErrorCallBack   - Ignored if NULL. Otherwise, call on error.

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiMoveCumulativeSets:"
    DWORD                   WStatus;
    DWORD                   KeyIdx;
    DWORD                   RegType;
    DWORD                   RegBytes;
    PWCHAR                  CumuPath        = NULL;
    PWCHAR                  BurCumuPath     = NULL;
    HKEY                    HCumusKey       = INVALID_HANDLE_VALUE;
    HKEY                    HCumuKey        = INVALID_HANDLE_VALUE;
    HKEY                    HBurCumusKey    = INVALID_HANDLE_VALUE;
    HKEY                    HBurCumuKey     = INVALID_HANDLE_VALUE;
    WCHAR                   RegBuf[MAX_PATH + 1];

    //
    // Open CUMULATIVE REPLICA SETS
    //
    WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                ErrorCallBack,
                                FRS_CUMULATIVE_SETS_SECTION,
                                KEY_ENUMERATE_SUB_KEYS,
                                &HCumusKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Open BACKUP RESTORE CUMULATIVE REPLICA SETS
    //
    WStatus = RegCreateKey(HKEY_LOCAL_MACHINE,
                           FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION,
                           &HBurCumusKey);
    if (WIN_SUCCESS(WStatus)) {
        FRS_REG_CLOSE(HBurCumusKey);
    }
    WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                ErrorCallBack,
                                FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION,
                                KEY_CREATE_SUB_KEY,
                                &HBurCumusKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    // Enumerate the Cumulative Replica Sets
    //
    KeyIdx = 0;
    do {
        WStatus = RegEnumKey(HCumusKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (WStatus == ERROR_NO_MORE_ITEMS) {
            break;
        }
        CLEANUP_CB(ErrorCallBack, FRS_CUMULATIVE_SETS_SECTION, WStatus, CLEANUP);

        //
        // Full path of both the source and target key
        //
        CumuPath = NtFrsApi_Cats(FRS_CUMULATIVE_SETS_SECTION, L"\\", RegBuf);
        BurCumuPath = NtFrsApi_Cats(FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION,
                                    L"\\",
                                    RegBuf);
        //
        // Open the cumulative replica set
        //
        WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                    ErrorCallBack,
                                    CumuPath,
                                    KEY_READ,
                                    &HCumuKey);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP_DURING_LOOP;
        }
        //
        // Create the backup restore cumulative replica set
        //
        WStatus = RegCreateKey(HKEY_LOCAL_MACHINE, BurCumuPath, &HBurCumuKey);
        CLEANUP_CB(ErrorCallBack, BurCumuPath, WStatus, CLEANUP_DURING_LOOP);

CLEANUP_DURING_LOOP:
        FRS_REG_CLOSE(HCumuKey);

        FRS_REG_CLOSE(HBurCumuKey);
        FREE(CumuPath);
        FREE(BurCumuPath);
        ++KeyIdx;
    } while (TRUE);

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    //
    // Clean up any handles, events, memory, ...
    //
    FRS_REG_CLOSE(HCumuKey);
    FRS_REG_CLOSE(HBurCumuKey);
    FRS_REG_CLOSE(HCumusKey);
    FRS_REG_CLOSE(HBurCumusKey);
    FREE(CumuPath);
    FREE(BurCumuPath);
    return WStatus;
}


typedef struct _NTFRSAPI_BUR_SET    NTFRSAPI_BUR_SET, *PNTFRSAPI_BUR_SET;
struct _NTFRSAPI_BUR_SET {
    PNTFRSAPI_BUR_SET   BurSetNext;  // next in list of sets
    PWCHAR              BurSetGuid;  // member guid is also name of registry key
    PWCHAR              BurSetRoot;  // root path
    PWCHAR              BurSetStage; // stage path
    PWCHAR              BurSetType;  // type of set (domain, enterprise, ...)
};

//
// Context generated by NtFrsApiInitializeBackupRestore() and freed by
// NtFrsApiDestroyBackupRestore(). Used for all other function calls.
//
typedef struct _NTFRSAPI_BUR_CONTEXT {
    DWORD               BurFlags;           // from caller
    PNTFRSAPI_BUR_SET   BurSets;            // See NtFrsApiGetBackupRestoreSets
    DWORD               BurFiltersSizeInBytes; // Size of BurFilters
    PWCHAR              BurFilters;            // From registry
    BOOL                HaveBurSemaphore;   // Holding the semaphore
    HANDLE              BurSemaphore;       // This is a single thread API
    DWORD               (*ErrorCallBack)(IN PWCHAR, IN ULONG); // from caller
} NTFRSAPI_BUR_CONTEXT, *PNTFRSAPI_BUR_CONTEXT;


VOID
WINAPI
NtFrsApiFreeBurSets(
    IN PNTFRSAPI_BUR_SET *BurSets
    )
/*++
Routine Description:
    Free the linked list of BurSets and set *BurSets to NULL.

Arguments:
    BurSets - Linked list of BurSets

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiFreeBurSets:"
    PNTFRSAPI_BUR_SET LocalBurSet;

    while (LocalBurSet = *BurSets) {
        *BurSets = LocalBurSet->BurSetNext;
        FREE(LocalBurSet->BurSetGuid);
        FREE(LocalBurSet->BurSetRoot);
        FREE(LocalBurSet->BurSetStage);
        FREE(LocalBurSet->BurSetType);
        FREE(LocalBurSet);
    }
}


DWORD
WINAPI
NtFrsApiInitializeBackupRestore(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    IN  DWORD   BurFlags,
    OUT PVOID   *BurContext
    )
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a subsequent call to NtFrsApiDestroyBackupRestore().

    Prepare the system for the backup or restore specified by BurFlags.
    Currently, the following combinations are supported:
    ASR - Automated System Recovery
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (all sets)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (just the sysvol)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
        (may be followed by subsequent calls to NtFrsApiRestoringDirectory())

    Normal Restore - System is up and running; just restoring files
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_NORMAL |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_AUTHORITATIVE

    Normal Backup
        NTFRSAPI_BUR_FLAGS_BACKUP |
        NTFRSAPI_BUR_FLAGS_NORMAL

Arguments:
    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.
    BurFlags        - See above for the supported combinations
    BurContext      - Opaque context for this process

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiInitializeBackupRestore:"
    DWORD                   WStatus;
    DWORD                   WaitStatus;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = NULL;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Must be one of backup or restore
        //
        if (!(BurFlags & (NTFRSAPI_BUR_FLAGS_BACKUP |
                          NTFRSAPI_BUR_FLAGS_RESTORE))) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(ErrorCallBack, L"BurFlags ~(BACKUP|RESTORE)", WStatus, CLEANUP);
        }
        //
        // RESTORE
        //
        if (BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) {
            //
            // Can't be both backup and restore
            //
            if (BurFlags & NTFRSAPI_BUR_FLAGS_BACKUP) {
                WStatus = ERROR_INVALID_PARAMETER;
                CLEANUP_CB(ErrorCallBack, L"BurFlags (RESTORE|BACKUP)", WStatus, CLEANUP);
            }
            //
            // Restore supports a few flags
            //
            if (BurFlags & ~NTFRSAPI_BUR_FLAGS_SUPPORTED_RESTORE) {
                WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                CLEANUP_CB(ErrorCallBack, L"BurFlags ONE OR MORE FLAGS", WStatus, CLEANUP);
            }
            //
            // Select only one type of restore
            //
            switch (BurFlags & NTFRSAPI_BUR_FLAGS_TYPES_OF_RESTORE) {
                //
                // Authoritative
                //
                case NTFRSAPI_BUR_FLAGS_AUTHORITATIVE:
                    if (BurFlags & (NTFRSAPI_BUR_FLAGS_SYSTEM |
                                    NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags (SYSTEM | ACTIVE | AUTHORITATIVE)", WStatus, CLEANUP);
                    }
                    break;
                //
                // Non-Authoritative
                //
                case NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE:
                    //
                    // NORMAL
                    //
                    if (BurFlags & NTFRSAPI_BUR_FLAGS_NORMAL) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags (NORMAL | NON-AUTHORITATIVE)", WStatus, CLEANUP);
                    }
                    //
                    // _ACTIVE_DIRECTORY and not ALL
                    //
                    if ((BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY) &&
                         (!(BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES))) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags (ACTIVE DIRECTORY | NON-AUTHORITATIVE w/o ALL)", WStatus, CLEANUP);
                    }
                    break;
                //
                // Primary
                //
                case NTFRSAPI_BUR_FLAGS_PRIMARY:
                    if (BurFlags & NTFRSAPI_BUR_FLAGS_NORMAL) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags (NORMAL | PRIMARY)", WStatus, CLEANUP);
                    }
                    //
                    // _ACTIVE_DIRECTORY and not ALL
                    //
                    if ((BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY) &&
                         (!(BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES))) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags (ACTIVE DIRECTORY | PRIMARY w/o ALL)", WStatus, CLEANUP);
                    }
                    break;
                //
                // None
                //
                case NTFRSAPI_BUR_FLAGS_NONE:
                    if ((BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES) ||
                        !(BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags TOO FEW TYPES", WStatus, CLEANUP);
                    }
                    break;
                //
                // More than one or none
                //
                default:
                    WStatus = ERROR_INVALID_PARAMETER;
                    CLEANUP_CB(ErrorCallBack, L"BurFlags TOO MANY TYPES", WStatus, CLEANUP);
            }
            //
            // Select only one mode of restore
            //
            switch (BurFlags & NTFRSAPI_BUR_FLAGS_MODES_OF_RESTORE) {
                //
                // System
                //
                case NTFRSAPI_BUR_FLAGS_SYSTEM:
                    if (!(BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags SYSTEM without ALL", WStatus, CLEANUP);
                    }
                    break;
                //
                // Active Directory
                //
                case NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY:
#if 0
                    if (!(BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags ACTIVE DIRECTORY without ALL", WStatus, CLEANUP);
                    }
#endif 0
                    break;
                //
                // Normal
                //
                case NTFRSAPI_BUR_FLAGS_NORMAL:
                    if (!(BurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)) {
                        WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                        CLEANUP_CB(ErrorCallBack, L"BurFlags NORMAL without ALL", WStatus, CLEANUP);
                    }
                    break;
                //
                // More than one
                //
                default:
                    WStatus = ERROR_INVALID_PARAMETER;
                    CLEANUP_CB(ErrorCallBack, L"BurFlags TOO MANY/FEW MODES", WStatus, CLEANUP);
            }
        //
        // BACKUP
        //
        } else {
            //
            // Backup supports a subset of BurFlags
            //
            if (BurFlags & ~NTFRSAPI_BUR_FLAGS_SUPPORTED_BACKUP) {
                WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                CLEANUP_CB(ErrorCallBack, L"BurFlags unsupported BACKUP Flag(s)", WStatus, CLEANUP);
            }
            //
            // Normal must be set
            //
            if (!(BurFlags & NTFRSAPI_BUR_FLAGS_NORMAL)) {
                WStatus = ERROR_CALL_NOT_IMPLEMENTED;
                CLEANUP_CB(ErrorCallBack, L"BurFlags BACKUP without NORMAL", WStatus, CLEANUP);
            }
        }
        //
        // Must have someplace to return the context
        //
        if (!BurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(ErrorCallBack, L"BurContext", WStatus, CLEANUP);
        }
        //
        // No context, yet
        //
        *BurContext = NULL;


        //
        // Allocate a context
        //
        LocalBurContext = NtFrsApi_Alloc(sizeof(NTFRSAPI_BUR_CONTEXT));
        LocalBurContext->ErrorCallBack = ErrorCallBack,
        LocalBurContext->BurFlags = BurFlags;

        //
        // Only one backup/restore is allowed at a time
        //
        LocalBurContext->BurSemaphore = CreateSemaphore(NULL,
                                                        1,
                                                        1,
                                                        NTFRS_BACKUP_RESTORE_SEMAPHORE);
        if (!HANDLE_IS_VALID(LocalBurContext->BurSemaphore)) {
            LocalBurContext->BurSemaphore = OpenSemaphore(SEMAPHORE_ALL_ACCESS,
                                                          FALSE,
                                                          NTFRS_BACKUP_RESTORE_SEMAPHORE);
        }
        if (!HANDLE_IS_VALID(LocalBurContext->BurSemaphore)) {
            WStatus = GetLastError();
            CLEANUP_CB(ErrorCallBack, NTFRS_BACKUP_RESTORE_SEMAPHORE, WStatus, CLEANUP);
        }
        WaitStatus = WaitForSingleObject(LocalBurContext->BurSemaphore, 1 * 1000);
        if (WaitStatus != WAIT_OBJECT_0) {
            if (WaitStatus == WAIT_TIMEOUT) {
                WStatus = ERROR_BUSY;
            } else if (WaitStatus == WAIT_ABANDONED){
                WStatus = ERROR_SEM_OWNER_DIED;
            } else {
                WStatus = GetLastError();
            }
            CLEANUP_CB(ErrorCallBack, NTFRS_BACKUP_RESTORE_SEMAPHORE, WStatus, CLEANUP);
        }
        LocalBurContext->HaveBurSemaphore = TRUE;

        //
        // Stop the service and set the appropriate registry value
        //
        // THE RESTORE IS EFFECTIVELY COMMITTED AT THIS TIME!
        //
        if (BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE &&
            !(BurFlags & NTFRSAPI_BUR_FLAGS_NORMAL)) {
            WStatus = NtFrsApiStopServiceForRestore(ErrorCallBack, BurFlags);
            if (!WIN_SUCCESS(WStatus)) {
                goto CLEANUP;
            }
            //
            // Save the current set of replica sets
            //
            WStatus = NtFrsApiMoveCumulativeSets(NULL);
            if (!WIN_SUCCESS(WStatus)) {
                // Ignore error; caller may not care
                WStatus = ERROR_SUCCESS;
            }
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;
        *BurContext = LocalBurContext;
        LocalBurContext = NULL;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Release semaphore
        //
        if (LocalBurContext && HANDLE_IS_VALID(LocalBurContext->BurSemaphore)) {
            if (LocalBurContext->HaveBurSemaphore) {
                ReleaseSemaphore(LocalBurContext->BurSemaphore, 1, NULL);
            }
            CloseHandle(LocalBurContext->BurSemaphore);
        }
        //
        // Context
        //
        if (LocalBurContext) {
            NtFrsApiFreeBurSets(&LocalBurContext->BurSets);
            LocalBurContext->BurFiltersSizeInBytes = 0;
            FREE(LocalBurContext->BurFilters);
            FREE(LocalBurContext);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    )
/*++
Routine Description:
    The backup/restore application is about to restore the directory
    specified by BurSet (See NtFrsApiEnumBackupRestoreSets()). Matched
    with a later call to NtFrsApiFinishedRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags can be NTFRSAPI_BUR_FLAGS_PRIMARY or
    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE and overrides any value
    specified in the call to NtFrsApiInitializeBackupRestore().

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiRestoringDirectory:"
    DWORD                   WStatus;
    DWORD                   WaitStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;
    HKEY                    HBurSetKey = INVALID_HANDLE_VALUE;
    PWCHAR                  BurSetPath = NULL;

    try {
        //
        // VERIFY THE PARAMETERS
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Must be one of primary or nonauth
        //
        if (!(BurFlags & (NTFRSAPI_BUR_FLAGS_PRIMARY |
                          NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE))) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurFlags not (PRIMARY|NON-AUTH)", WStatus, CLEANUP);
        }
        //
        // Can only be one of primary or nonauth
        //
        if (BurFlags & ~(NTFRSAPI_BUR_FLAGS_PRIMARY |
                         NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE)) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurFlags not just (PRIMARY|NON-AUTH)", WStatus, CLEANUP);
        }
        //
        // Must be a restore context
        //
        if (!(LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE)) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurContext not RESTORE", WStatus, CLEANUP);
        }
        //
        // Must be an active directory context
        //
        if (!(LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurContext not ACTIVE_DIRECTORY", WStatus, CLEANUP);
        }

        //
        // Re-locate the correct BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NOT_FOUND;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurSet", WStatus, CLEANUP);
        }
        //
        // Corrupted BurSet
        //
        if (!LocalBurSet->BurSetGuid) {
            WStatus = ERROR_NOT_FOUND;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurSet Id", WStatus, CLEANUP);
        }
        //
        // Full path to registry key
        //
        BurSetPath = NtFrsApi_Cats(FRS_BACKUP_RESTORE_MV_SETS_SECTION,
                                   L"\\",
                                   LocalBurSet->BurSetGuid);
        WStatus = RegCreateKey(HKEY_LOCAL_MACHINE, BurSetPath, &HBurSetKey);
        if (!WIN_SUCCESS(WStatus)) {
            CLEANUP_CB(LocalBurContext->ErrorCallBack, BurSetPath, WStatus, CLEANUP);
        }
        //
        // Retain _RESTORE and _ACTIVE_DIRECTORY in the registry value
        //
        BurFlags |= LocalBurContext->BurFlags &
                        (NTFRSAPI_BUR_FLAGS_RESTORE |
                         NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY);
        WStatus = NtFrsApiSetValueEx(NTFRSAPI_MODULE,
                                     LocalBurContext->ErrorCallBack,
                                     BurSetPath,
                                     HBurSetKey,
                                     FRS_VALUE_BURFLAGS,
                                     REG_DWORD,
                                     (PCHAR)&BurFlags,
                                     sizeof(DWORD));
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        FRS_REG_CLOSE(HBurSetKey);
        FREE(BurSetPath);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}


DWORD
WINAPI
NtFrsApiFinishedRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    )
/*++
Routine Description:
    Finished restoring directory for BurSet. Matched by a previous call
    to NtFrsApiRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags must be NTFRSAPI_BUR_FLAGS_NONE.

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiRestoringDirectory:"
    DWORD                   WStatus;
    DWORD                   WaitStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Must be one of primary or nonauth
        //
        if (BurFlags != NTFRSAPI_BUR_FLAGS_NONE) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurFlags not NONE", WStatus, CLEANUP);
        }
        //
        // Must be restore context
        //
        if (!(LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE)) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurContext not RESTORE", WStatus, CLEANUP);
        }
        //
        // Must be active directory context
        //
        if (!(LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
            WStatus = ERROR_INVALID_PARAMETER;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurContext not ACTIVE_DIRECTORY", WStatus, CLEANUP);
        }

        //
        // Re-locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NOT_FOUND;
            CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurSet", WStatus, CLEANUP);
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiDestroyBackupRestore(
    IN     PVOID    *BurContext,
    IN     DWORD    BurFlags,
    OUT    HKEY     *HKey,
    IN OUT DWORD    *KeyPathSizeInBytes,
    OUT    PWCHAR   KeyPath
    )
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a previous call to NtFrsApiInitializeBackupRestore().

    If NtFrsApiInitializeBackupRestore() was called with:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM or NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
    then BurFlags may be set to one of:
        NTFRSAPI_BUR_FLAGS_NONE - Do not restart the service. The key
            specified by (HKey, KeyPath) must be moved into the final
            registry.
        NTFRSAPI_BUR_FLAGS_RESTART - Restart the service. HKey,
            KeyPathSizeInBytes, and KeyPath must be NULL.

    If NtFrsApiInitializeBackupRestore() was not called the above flags,
    then BurFlags must be NTFRSAPI_BUR_FLAGS_NONE and HKey, KeyPathSizeInBytes,
    and KeyPath must be NULL.

Arguments:
    BurContext          - Returned by previous call to
                          NtFrsApiInitializeBackupRestore().

    BurFlags            - Backup/Restore Flags. See Routine Description.

    HKey                - Address of a HKEY for that will be set to
                          HKEY_LOCAL_MACHINE, ...
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPathSizeInBytes  - Address of of a DWORD specifying the size of
                          KeyPath. Set to the actual number of bytes
                          needed by KeyPath. ERROR_INSUFFICIENT_BUFFER
                          is returned if the size of KeyPath is too small.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPath             - Buffer to receive the path of the registry key.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiDestroyBackupRestore:"
    DWORD                   WStatus;
    DWORD                   KeyLen;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!BurContext || !*BurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        LocalBurContext = *BurContext;

        //
        // Restart is the only supported flag
        //
        if (LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) {
            //
            // RESTORE
            //
            if (BurFlags & ~NTFRSAPI_BUR_FLAGS_RESTART) {
                WStatus = ERROR_INVALID_PARAMETER;
                CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurFlags TOO MANY FLAGS", WStatus, CLEANUP);
            }
            if (LocalBurContext->BurFlags & (NTFRSAPI_BUR_FLAGS_SYSTEM |
                                             NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
                if (BurFlags & NTFRSAPI_BUR_FLAGS_RESTART) {
                    if (HKey || KeyPathSizeInBytes || KeyPath) {
                        WStatus = ERROR_INVALID_PARAMETER;
                        CLEANUP_CB(LocalBurContext->ErrorCallBack, L"HKey, KeyPathSizeInBytes, KeyPath", WStatus, CLEANUP);
                    }
                } else {
                    if (!HKey || !KeyPathSizeInBytes || !KeyPath) {
                        WStatus = ERROR_INVALID_PARAMETER;
                        CLEANUP_CB(LocalBurContext->ErrorCallBack, L"No HKey, KeyPathSizeInBytes, KeyPath", WStatus, CLEANUP);
                    }
                    KeyLen = sizeof(WCHAR) *
                             (wcslen(FRS_BACKUP_RESTORE_MV_SECTION) + 1);
                    if (KeyLen > *KeyPathSizeInBytes) {
                        *KeyPathSizeInBytes = KeyLen;
                        WStatus = ERROR_INSUFFICIENT_BUFFER;
                        goto CLEANUP;
                    }
                }
            } else if (HKey || KeyPathSizeInBytes || KeyPath) {
                WStatus = ERROR_INVALID_PARAMETER;
                CLEANUP_CB(LocalBurContext->ErrorCallBack, L"HKey, KeyPathSizeInBytes, KeyPath", WStatus, CLEANUP);
            }
        //
        // BACKUP
        //
        } else {
            if (BurFlags) {
                WStatus = ERROR_INVALID_PARAMETER;
                CLEANUP_CB(LocalBurContext->ErrorCallBack, L"BurFlags TOO MANY FLAGS", WStatus, CLEANUP);
            }
            if (HKey || KeyPathSizeInBytes || KeyPath) {
                WStatus = ERROR_INVALID_PARAMETER;
                CLEANUP_CB(LocalBurContext->ErrorCallBack, L"HKey, KeyPathSizeInBytes, KeyPath",
                           WStatus, CLEANUP);
            }
        }

        //
        // Restart service or return the key
        //
        if (LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) {
            if (LocalBurContext->BurFlags & (NTFRSAPI_BUR_FLAGS_SYSTEM |
                                             NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY)) {
                if (BurFlags & NTFRSAPI_BUR_FLAGS_RESTART) {
                    //
                    // Restart service; no key to move over
                    //
                    WStatus = NtFrsApiStartServiceAfterRestore(LocalBurContext->ErrorCallBack);
                    if (!WIN_SUCCESS(WStatus)) {
                        goto CLEANUP;
                    }
                } else {
                    //
                    // Key hierarchy to move into final registry
                    //
                    *HKey = HKEY_LOCAL_MACHINE;
                    KeyLen = sizeof(WCHAR) *
                                         (wcslen(FRS_BACKUP_RESTORE_MV_SECTION) + 1);
                    if (KeyLen > *KeyPathSizeInBytes) {
                        WStatus = ERROR_INSUFFICIENT_BUFFER;
                        goto CLEANUP;
                    } else {
                        *KeyPathSizeInBytes = KeyLen;
                        CopyMemory(KeyPath, FRS_BACKUP_RESTORE_MV_SECTION, *KeyPathSizeInBytes);
                    }
                }
            }
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;
        if (HANDLE_IS_VALID(LocalBurContext->BurSemaphore)) {
            if (LocalBurContext->HaveBurSemaphore) {
                ReleaseSemaphore(LocalBurContext->BurSemaphore, 1, NULL);
            }
            CloseHandle(LocalBurContext->BurSemaphore);
        }
        NtFrsApiFreeBurSets(&LocalBurContext->BurSets);
        LocalBurContext->BurFiltersSizeInBytes = 0;
        FREE(LocalBurContext->BurFilters);
        FREE(LocalBurContext);
        *BurContext = LocalBurContext;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiGetBurSets(
    IN  DWORD               ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT PNTFRSAPI_BUR_SET   *OutBurSets
    )
/*++
Routine Description:
    Retrieve the replica sets from the registry. Ignore tombstoned
    sets.

Arguments:
    ErrorCallBack   - Ignored if NULL. Otherwise, call on error.
    OutBurSets      - Linked list of BurSets

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBurSets:"
    DWORD                   WStatus;
    DWORD                   KeyIdx;
    DWORD                   RegType;
    DWORD                   RegBytes;
    DWORD                   ReplicaSetTombstoned;
    PWCHAR                  SetPath         = NULL;
    PWCHAR                  ObjectName      = NULL;
    HKEY                    HSetsKey        = INVALID_HANDLE_VALUE;
    HKEY                    HSetKey         = INVALID_HANDLE_VALUE;
    PNTFRSAPI_BUR_SET       LocalBurSet     = NULL;
    WCHAR                   RegBuf[MAX_PATH + 1];
    PWCHAR                  RegBufPtr = NULL;

    *OutBurSets = NULL;

    //
    // Open the ntfrs parameters\replica sets section in the registry
    //
    WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                ErrorCallBack,
                                FRS_SETS_SECTION,
                                KEY_ENUMERATE_SUB_KEYS,
                                &HSetsKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Enumerate the Replica Sets
    //
    KeyIdx = 0;
    do {
        WStatus = RegEnumKey(HSetsKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (WStatus == ERROR_NO_MORE_ITEMS) {
            break;
        }
        CLEANUP_CB(ErrorCallBack, FRS_SETS_SECTION, WStatus, CLEANUP);

        //
        // LocalBurSet->BurSetGuid (name of registry key)
        //
        LocalBurSet = NtFrsApi_Alloc(sizeof(NTFRSAPI_BUR_SET));
        LocalBurSet->BurSetGuid = NtFrsApi_Dup(RegBuf);
        SetPath = NtFrsApi_Cats(FRS_SETS_SECTION, L"\\", RegBuf);
        //
        // Open registry key for the Replica Set
        //
        WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                    ErrorCallBack,
                                    SetPath,
                                    KEY_READ,
                                    &HSetKey);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP_DURING_LOOP;
        }

        //
        // ReplicaSetTombstoned
        // Ignore tombstoned replica sets
        //
        RegBytes = sizeof(DWORD);
        WStatus = RegQueryValueEx(HSetKey,
                                  REPLICA_SET_TOMBSTONED,
                                  NULL,
                                  &RegType,
                                  (PUCHAR)&ReplicaSetTombstoned,
                                  &RegBytes);
        if (WIN_SUCCESS(WStatus) && RegType != REG_DWORD) {
            ReplicaSetTombstoned = 0;
        }
        if (WIN_SUCCESS(WStatus) && ReplicaSetTombstoned) {
            goto CLEANUP_DURING_LOOP;
        }

        //
        // LocalBurSet->BurSetType
        //
        RegBytes = sizeof(RegBuf);
        WStatus = RegQueryValueEx(HSetKey,
                                  REPLICA_SET_TYPE,
                                  NULL,
                                  &RegType,
                                  (PUCHAR)RegBuf,
                                  &RegBytes);
        if (WIN_SUCCESS(WStatus) && RegType != REG_SZ) {
            WStatus = ERROR_INVALID_PARAMETER;
        }
        if (!WIN_SUCCESS(WStatus)) {
            ObjectName = NtFrsApi_Cats(SetPath, L"->", REPLICA_SET_TYPE);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            FREE(ObjectName);
            goto CLEANUP_DURING_LOOP;
        }
        LocalBurSet->BurSetType = NtFrsApi_Dup(RegBuf);

        //
        // LocalBurSet->BurSetRoot
        //
        RegBytes = (MAX_PATH + 1)*sizeof(WCHAR);
        RegBufPtr = NtFrsApi_Alloc(RegBytes);
        WStatus = RegQueryValueEx(HSetKey,
                                  REPLICA_SET_ROOT,
                                  NULL,
                                  &RegType,
                                  (PUCHAR)RegBufPtr,
                                  &RegBytes);

        if (WStatus == ERROR_MORE_DATA) {
            // If the buffer is not big enough then the required size
            // is returned in the RegBytes parameter.
            FREE(RegBufPtr);
            RegBufPtr = NtFrsApi_Alloc(RegBytes);
            WStatus = RegQueryValueEx(HSetKey,
                                      REPLICA_SET_ROOT,
                                      NULL,
                                      &RegType,
                                      (PUCHAR)RegBufPtr,
                                      &RegBytes);
        }

        if (WIN_SUCCESS(WStatus) && RegType != REG_SZ) {
            WStatus = ERROR_INVALID_PARAMETER;
        }

        if (!WIN_SUCCESS(WStatus)) {
            ObjectName = NtFrsApi_Cats(SetPath, L"->", REPLICA_SET_ROOT);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            FREE(ObjectName);
            goto CLEANUP_DURING_LOOP;
        }
        LocalBurSet->BurSetRoot = NtFrsApi_Dup(RegBufPtr);
        FREE(RegBufPtr);

        //
        // LocalBurSet->BurSetStage
        //
        RegBytes = (MAX_PATH + 1)*sizeof(WCHAR);
        RegBufPtr = NtFrsApi_Alloc(RegBytes);
        WStatus = RegQueryValueEx(HSetKey,
                                  REPLICA_SET_STAGE,
                                  NULL,
                                  &RegType,
                                  (PUCHAR)RegBufPtr,
                                  &RegBytes);

        if (WStatus == ERROR_MORE_DATA) {
            // If the buffer is not big enough then the required size
            // is returned in the RegBytes parameter.
            FREE(RegBufPtr);
            RegBufPtr = NtFrsApi_Alloc(RegBytes);

            WStatus = RegQueryValueEx(HSetKey,
                                      REPLICA_SET_STAGE,
                                      NULL,
                                      &RegType,
                                      (PUCHAR)RegBufPtr,
                                      &RegBytes);

        }

        if (WIN_SUCCESS(WStatus) && RegType != REG_SZ) {
            WStatus = ERROR_INVALID_PARAMETER;
        }
        if (!WIN_SUCCESS(WStatus)) {
            ObjectName = NtFrsApi_Cats(SetPath, L"->", REPLICA_SET_STAGE);
            NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
            FREE(ObjectName);
            goto CLEANUP_DURING_LOOP;
        }
        LocalBurSet->BurSetStage = NtFrsApi_Dup(RegBufPtr);
        FREE(RegBufPtr);

        //
        // Link to list of BurSets
        //
        LocalBurSet->BurSetNext = *OutBurSets;
        *OutBurSets = LocalBurSet;
        LocalBurSet = NULL;

CLEANUP_DURING_LOOP:
        FRS_REG_CLOSE(HSetKey);
        FREE(SetPath);
        ++KeyIdx;
    } while (TRUE);

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:;
    //
    // Clean up any handles, events, memory, ...
    //
    FRS_REG_CLOSE(HSetsKey);
    FRS_REG_CLOSE(HSetKey);

    if (LocalBurSet) {
        FREE(LocalBurSet->BurSetGuid);
        FREE(LocalBurSet->BurSetRoot);
        FREE(LocalBurSet->BurSetStage);
        FREE(LocalBurSet->BurSetType);
        FREE(LocalBurSet);
    }
    FREE(SetPath);
    FREE(ObjectName);
    return WStatus;
}


DWORD
WINAPI
NtFrsApiGetBurFilters(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    OUT DWORD   *OutBurFiltersSizeInBytes,
    OUT PWCHAR  *OutBurFilters
    )
/*++
Routine Description:
    Retrieve the ntfrs filter from FilesNotToBackup

Arguments:
    ErrorCallBack   - Ignored if NULL. Otherwise, call on error.
    OutBurFiltersSizeInBytes - Size of *OutBurFiltes in bytes
    OutBurFilters - Multistring filters

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBurFilters:"
    DWORD   WStatus;
    DWORD   RegType;
    PWCHAR  ObjectName;
    HKEY    HFilesKey   = INVALID_HANDLE_VALUE;
    DWORD   RegBytes = 16;
    PWCHAR  RegBuf = NULL;

    *OutBurFiltersSizeInBytes = 0;
    *OutBurFilters = NULL;

    //
    // Open the ntfrs parameters\replica sets section in the registry
    //
    WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                ErrorCallBack,
                                FRS_NEW_FILES_NOT_TO_BACKUP,
                                KEY_READ,
                                &HFilesKey);
    if (!WIN_SUCCESS(WStatus)) {
        WStatus = NtFrsApiOpenKeyEx(NTFRSAPI_MODULE,
                                    ErrorCallBack,
                                    FRS_OLD_FILES_NOT_TO_BACKUP,
                                    KEY_QUERY_VALUE,
                                    &HFilesKey);
    }
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }


    //
    // NtFrs Filters from FilesNotToBackup
    //
    try{
	RegBuf = NtFrsApi_Alloc(RegBytes);
    } except (EXCEPTION_EXECUTE_HANDLER) {
	  GET_EXCEPTION_CODE(WStatus);
	  goto CLEANUP;
    }

    WStatus = RegQueryValueEx(HFilesKey,
                              SERVICE_NAME,
                              NULL,
                              &RegType,
                              (PUCHAR)RegBuf,
                              &RegBytes);
    if (WStatus == ERROR_MORE_DATA) {
        FREE(RegBuf);
	try{
	    RegBuf = NtFrsApi_Alloc(RegBytes);
	} except (EXCEPTION_EXECUTE_HANDLER) {
	  GET_EXCEPTION_CODE(WStatus);
	  goto CLEANUP;
	}
	WStatus = RegQueryValueEx(HFilesKey,
				  SERVICE_NAME,
				  NULL,
                                  &RegType,
                                  (PUCHAR)RegBuf,
                                  &RegBytes);
    }
    if (WIN_SUCCESS(WStatus) && RegType != REG_MULTI_SZ) {
        WStatus = ERROR_INVALID_PARAMETER;
    }
    if (!WIN_SUCCESS(WStatus)) {
        ObjectName = NtFrsApi_Cats(FRS_NEW_FILES_NOT_TO_BACKUP, L"->", SERVICE_NAME);
        NtFrsApi_CallBackOnWStatus(ErrorCallBack, ObjectName, WStatus);
        FREE(ObjectName);
        goto CLEANUP;
    }

    //
    // SUCCESS
    //
    *OutBurFiltersSizeInBytes = RegBytes;
    *OutBurFilters = RegBuf;
    RegBuf = NULL;
    WStatus = ERROR_SUCCESS;

CLEANUP:;
    //
    // Clean up any handles, events, memory, ...
    //
    FRS_REG_CLOSE(HFilesKey);
    FREE(RegBuf);
    return WStatus;
}


DWORD
WINAPI
NtFrsApiGetBackupRestoreSets(
    IN PVOID BurContext
    )
/*++
Routine Description:
    Cannot be called if BurContext is for a System restore.

    Retrieves information about the current replicated directories
    (AKA replica sets).

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()

Return Value:

    Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBackupRestoreSets:"
    DWORD                   WStatus;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        if (LocalBurContext->BurFlags & NTFRSAPI_BUR_FLAGS_SYSTEM) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Free the current filters, if any
        //
        LocalBurContext->BurFiltersSizeInBytes = 0;
        FREE(LocalBurContext->BurFilters);

        //
        // Free current BurSets, if any
        //
        NtFrsApiFreeBurSets(&LocalBurContext->BurSets);

        //
        // Fetch the backup restore sets
        //
        WStatus = NtFrsApiGetBurSets(LocalBurContext->ErrorCallBack,
                                     &LocalBurContext->BurSets);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // Fetch the backup restore filters
        //
        WStatus = NtFrsApiGetBurFilters(LocalBurContext->ErrorCallBack,
                                        &LocalBurContext->BurFiltersSizeInBytes,
                                        &LocalBurContext->BurFilters);
        if (!WIN_SUCCESS(WStatus)) {
            // Ignore errors
            WStatus = ERROR_SUCCESS;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiEnumBackupRestoreSets(
    IN  PVOID   BurContext,
    IN  DWORD   BurSetIndex,
    OUT PVOID   *BurSet
    )
/*++
Routine Description:
    Returns ERROR_NO_MORE_ITEMS if BurSetIndex exceeds the number of
    sets returned by NtFrsApiGetBackupRestoreSets().

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSetIndex - Index of set. Starts at 0.
    BurSet      - Opaque struct representing a replicating directory.

Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiEnumBackupRestoreSets:"
    DWORD                   WStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        *BurSet = NULL;

        //
        // Find the correct set
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && BurSetIndex;
             LocalBurSet = LocalBurSet->BurSetNext, --BurSetIndex) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NO_MORE_ITEMS;
            goto CLEANUP;
        }
        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;
        *BurSet = LocalBurSet;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiIsBackupRestoreSetASysvol(
    IN  PVOID    BurContext,
    IN  PVOID    BurSet,
    OUT BOOL     *IsSysvol
    )
/*++
Routine Description:
    Does the specified BurSet represent a replicating SYSVOL share?

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    IsSysvol    - TRUE : set is a system volume (AKA SYSVOL).
                  FALSE: set is a not a system volume (AKA SYSVOL).

Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiBackupRestoreSetIsSysvol:"
    DWORD                   WStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!IsSysvol) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }

        //
        // If a type were specified and it is Enterprise or Domain
        //
        if (LocalBurSet->BurSetType &&
            (WSTR_EQ(LocalBurSet->BurSetType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) ||
             WSTR_EQ(LocalBurSet->BurSetType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN))) {
            *IsSysvol = TRUE;
        } else {
            *IsSysvol = FALSE;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiGetBackupRestoreSetDirectory(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *DirectoryPathSizeInBytes,
    OUT    PWCHAR   DirectoryPath
    )
/*++
Routine Description:
    Return the path of the replicating directory represented by BurSet.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    DirectoryPathSizeInBytes    - Address of DWORD giving size of
                                  DirectoryPath. Cannot be NULL.
                                  Set to the number of bytes needed
                                  to return DirectoryPath.
                                  ERROR_INSUFFICIENT_BUFFER is returned if
                                  DirectoryPath is too small.
    DirectoryPath               - Buffer that is *DirectoryPathSizeInBytes
                                  bytes in length. Contains path of replicating
                                  directory.
Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBackupRestoreSetDirectory:"
    DWORD                   WStatus;
    DWORD                   DirectorySize;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!DirectoryPathSizeInBytes) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (*DirectoryPathSizeInBytes && !DirectoryPath) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Re-locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }
        DirectorySize = (wcslen(LocalBurSet->BurSetRoot) + 1) * sizeof(WCHAR);
        if (DirectorySize > *DirectoryPathSizeInBytes) {
            WStatus = ERROR_INSUFFICIENT_BUFFER;
            *DirectoryPathSizeInBytes = DirectorySize;
            goto CLEANUP;
        }
        *DirectoryPathSizeInBytes = DirectorySize;
        CopyMemory(DirectoryPath, LocalBurSet->BurSetRoot, DirectorySize);

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApiGetBackupRestoreSetPaths(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *PathsSizeInBytes,
    OUT    PWCHAR   Paths,
    IN OUT DWORD    *FiltersSizeInBytes,
    OUT    PWCHAR   Filters
    )
/*++
Routine Description:
    Return a multistring that contains the paths to other files
    and directories needed for proper operation of the replicated
    directory represented by BurSet. Return another multistring
    that details the backup filters to be applied to the paths
    returned by this function and the path returned by
    NtFrsApiGetBackupRestoreSetDirectory().

    The paths may overlap the replicated directory.

    The paths may contain nested entries.

    Filters is a multistring in the same format as the values for
    the registry key FilesNotToBackup.

    The replicated directory can be found with
    NtFrsApiGetBackupRestoreSetDirectory(). The replicated directory
    may overlap one or more entries in Paths.

    ERROR_PATH_NOT_FOUND is returned if the paths could not be
    determined.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().

    PathsSizeInBytes  - Address of DWORD giving size of Paths.
                        Cannot be NULL. Set to the number of bytes
                        needed to return Paths.
                        ERROR_INSUFFICIENT_BUFFER is returned if
                        Paths is too small.

    Paths             - Buffer that is *PathsSizeInBytes
                        bytes in length. Contains the paths of the
                        other files and directories needed for proper
                        operation of the replicated directory.

    FiltersSizeInBytes  - Address of DWORD giving size of Filters.
                          Cannot be NULL. Set to the number of bytes
                          needed to return Filters.
                          ERROR_INSUFFICIENT_BUFFER is returned if
                          Filters is too small.

    Filters             - Buffer that is *FiltersSizeInBytes bytes in
                          length. Contains the backup filters to be
                          applied to Paths, the contents of directories
                          in Paths, and the replicated directory.
Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBackupRestoreSetPaths:"
    DWORD                   WStatus;
    DWORD                   PathsSize;
    LONG                    NChars;
    PWCHAR                  Path;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!PathsSizeInBytes) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (*PathsSizeInBytes && !Paths) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Re-locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if (!LocalBurSet) {
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }
        //
        // Sysvol; return sysvol root
        //
        if (LocalBurSet->BurSetType &&
            (WSTR_EQ(LocalBurSet->BurSetType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) ||
             WSTR_EQ(LocalBurSet->BurSetType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN))) {
            Path = LocalBurSet->BurSetRoot;
            //
            // Skip trailing \'s
            //
            NChars = wcslen(Path) - 1;
            while (NChars >= 0) {
                if (Path[NChars] != L'\\') {
                    break;
                }
                --NChars;
            }
            //
            // Find the last \ that isn't a trailing \
            //
            while (NChars >= 0) {
                if (Path[NChars] == L'\\') {
                    break;
                }
                --NChars;
            }
            //
            // Skip dup \'s
            //
            while (NChars >= 0) {
                if (Path[NChars] != L'\\') {
                    break;
                }
                --NChars;
            }
            //
            // Convert index into number of chars
            //
            ++NChars;

            //
            // Sysvol path must contain at least 3 chars; <driver letter>:\
            //
            if (NChars < 4) {
                WStatus = ERROR_NOT_FOUND;
                goto CLEANUP;
            }
        } else {
            //
            // Not a Sysvol; return staging path
            //
            Path = LocalBurSet->BurSetStage;
            NChars = wcslen(Path);
        }

        //
        // Is the Paths and Filters buffers big enough?
        //
        PathsSize = (NChars + 1 + 1) * sizeof(WCHAR);
        if (PathsSize > *PathsSizeInBytes ||
            LocalBurContext->BurFiltersSizeInBytes > *FiltersSizeInBytes) {
            *PathsSizeInBytes = PathsSize;
            *FiltersSizeInBytes = LocalBurContext->BurFiltersSizeInBytes;
            WStatus = ERROR_INSUFFICIENT_BUFFER;
            goto CLEANUP;
        }
        //
        // Yep; buffers are big enough
        //
        *PathsSizeInBytes = PathsSize;
        *FiltersSizeInBytes = LocalBurContext->BurFiltersSizeInBytes;

        //
        // Copy the sysvol or staging path
        //
        CopyMemory(Paths, Path, NChars * sizeof(WCHAR));
        Paths[NChars + 0] = L'\0';
        Paths[NChars + 1] = L'\0';

        //
        // Filters
        //
        if (LocalBurContext->BurFiltersSizeInBytes) {
            CopyMemory(Filters, LocalBurContext->BurFilters, LocalBurContext->BurFiltersSizeInBytes);
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}


DWORD
WINAPI
NtFrsApi_DeleteSysvolMember(
    IN          PSEC_WINNT_AUTH_IDENTITY_W pCreds,
    IN          PWCHAR   BindingDC,
    IN          PWCHAR   NTDSSettingsDn,
    IN OPTIONAL PWCHAR   ComputerDn
    )
/*++
Routine Description:
    This API is written to be called from NTDSUTIL.EXE to remove
    FRS member and subscriber object for a server that is being
    removed (without dcpromo-demote) from the list of DCs.

Arguments:

    pCreds         p Credentials used to bind to the DS.
    BindingDC      - Name of a DC to perform the delete on.
    NTDSSettingsDn - Dn of the "NTDS Settings" object for the server
                     that is being removed from the sysvol replica set.
    ComputerDn     - Dn of the computer object for the server that is
                     being removed from the sysvol replica set.

Return Value:

    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_DeleteSysvolMember:"

    PLDAP           pLdap            = NULL;
    DWORD           LStatus          = LDAP_SUCCESS;
    DWORD           WStatus          = ERROR_SUCCESS;
    PWCHAR          DefaultNcDn      = NULL;
    PWCHAR          SystemDn         = NULL;
    PWCHAR          NtfrsSettingsDn  = NULL;
    PWCHAR          ReplicaSetDn     = NULL;
    PWCHAR          MemberDn         = NULL;
    PWCHAR          ComputerRef      = NULL;
    PWCHAR          SubscriberDn     = NULL;
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg          = NULL;
    PWCHAR          *Values          = NULL;
    PWCHAR          Attrs[2];
    PWCHAR          SearchFilter     = NULL;
    DWORD           NoOfMembers;
    DWORD           NoOfSubscribers;
    PWCHAR          MemberAttrs[4];
    PWCHAR          SubscriberAttrs[3];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;


    if ((BindingDC == NULL) || (NTDSSettingsDn == NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    WStatus = FrsSupBindToDC (BindingDC, pCreds, &pLdap);

    if (WStatus != ERROR_SUCCESS) {
        goto CLEANUP;
    }

    //
    // Find the naming contexts and the default naming context (objectCategory=*)
    //
    MK_ATTRS_1(Attrs, ATTR_DEFAULT_NAMING_CONTEXT);

    if (!FrsSupLdapSearch(pLdap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         Attrs, 0, &LdapMsg)) {
        goto CLEANUP;
    }

    LdapEntry = ldap_first_entry(pLdap, LdapMsg);
    if (LdapEntry == NULL) {
        goto CLEANUP;
    }

    //
    // Find the default naming context
    //
    Values = (PWCHAR *)FrsSupFindValues(pLdap, LdapEntry, ATTR_DEFAULT_NAMING_CONTEXT, FALSE);
    if (Values == NULL) {
        WStatus = ERROR_NOT_FOUND;
        goto CLEANUP;
    }
    DefaultNcDn = FrsSupWcsDup(Values[0]);
    SystemDn = FrsSupExtendDn(DefaultNcDn, CN_SYSTEM);
    NtfrsSettingsDn = FrsSupExtendDn(SystemDn, CN_NTFRS_SETTINGS);
    ReplicaSetDn = FrsSupExtendDn(NtfrsSettingsDn, CN_DOMAIN_SYSVOL);

    if (ReplicaSetDn == NULL) {
        WStatus = ERROR_OUTOFMEMORY;
    }

    //
    // Find member DN
    //
    if (ComputerDn != NULL) {
        SearchFilter = (PWCHAR)malloc(sizeof(WCHAR) * (1 + wcslen(ComputerDn) +
                                                       wcslen(NTDSSettingsDn) +
                                                       wcslen(CLASS_MEMBER) +
                                                       wcslen(ATTR_COMPUTER_REF) +
                                                       wcslen(ATTR_SERVER_REF) +
                                                       wcslen(L"(&(|(=)(=)))")));


        if (SearchFilter == NULL) {
            WStatus = ERROR_OUTOFMEMORY;
            goto CLEANUP;
        }

        //
        // e.g. (&(objectClass=nTFRSmember)
        // (|(frsComputerReference=<computerdn>)(serverReference=<ntdssettingsdn>)))
        //
        wcscpy(SearchFilter, L"(&");
        wcscat(SearchFilter, CLASS_MEMBER);
        wcscat(SearchFilter, L"(|(");
        wcscat(SearchFilter, ATTR_COMPUTER_REF);
        wcscat(SearchFilter, L"=");
        wcscat(SearchFilter, ComputerDn);
        wcscat(SearchFilter, L")(");
        wcscat(SearchFilter, ATTR_SERVER_REF);
        wcscat(SearchFilter, L"=");
        wcscat(SearchFilter, NTDSSettingsDn);
        wcscat(SearchFilter, L")))");
    } else {
        SearchFilter = (PWCHAR)malloc(sizeof(WCHAR) * (1 + wcslen(NTDSSettingsDn) +
                                                       wcslen(CLASS_MEMBER) +
                                                       wcslen(ATTR_SERVER_REF) +
                                                       wcslen(L"(&(=))")));

        if (SearchFilter == NULL) {
            WStatus = ERROR_OUTOFMEMORY;
            goto CLEANUP;
        }

        //
        // e.g. (&(objectClass=nTFRSmember)(serverReference=<ntdssettingsdn>))
        //
        wcscpy(SearchFilter, L"(&");
        wcscat(SearchFilter, CLASS_MEMBER);
        wcscat(SearchFilter, L"(");
        wcscat(SearchFilter, ATTR_SERVER_REF);
        wcscat(SearchFilter, L"=");
        wcscat(SearchFilter, NTDSSettingsDn);
        wcscat(SearchFilter, L"))");
    }

    MK_ATTRS_3(MemberAttrs, ATTR_DN, ATTR_COMPUTER_REF, ATTR_SERVER_REF);

    if (!FrsSupLdapSearchInit(pLdap,
                    ReplicaSetDn,
                    LDAP_SCOPE_SUBTREE,
                    SearchFilter,
                    MemberAttrs,
                    0,
                    &FrsSearchContext)) {

        WStatus = ERROR_NOT_FOUND;
        goto CLEANUP;
    }

    NoOfMembers = FrsSearchContext.EntriesInPage;

    if (NoOfMembers == 0) {

        FrsSupLdapSearchClose(&FrsSearchContext);
        WStatus = ERROR_NOT_FOUND;
        goto CLEANUP;
    }

    if (NoOfMembers > 1) {

        FrsSupLdapSearchClose(&FrsSearchContext);
        WStatus = ERROR_NOT_FOUND;
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = FrsSupLdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = FrsSupLdapSearchNext(pLdap, &FrsSearchContext)) {

       MemberDn = FrsSupFindValue(pLdap, LdapEntry, ATTR_DN);
       if (ComputerDn == NULL) {
           ComputerRef = FrsSupFindValue(pLdap, LdapEntry, ATTR_COMPUTER_REF);
       } else {
           ComputerRef = FrsSupWcsDup(ComputerDn);
       }

    }

    FrsSupLdapSearchClose(&FrsSearchContext);

    //
    // Find subscriber DN. Delete the member even if subscriber is not
    // found.
    //
    FRS_SUP_FREE(SearchFilter);

    if (ComputerRef == NULL) {
        goto DODELETE;
    }

    SearchFilter = (PWCHAR)malloc(sizeof(WCHAR) * (1 + wcslen(MemberDn) + MAX_PATH));
    if (SearchFilter == NULL) {
        WStatus = ERROR_OUTOFMEMORY;
        goto DODELETE;
    }

    wcscpy(SearchFilter, L"(&");
    wcscat(SearchFilter, CLASS_SUBSCRIBER);
    wcscat(SearchFilter, L"(");
    wcscat(SearchFilter, ATTR_MEMBER_REF);
    wcscat(SearchFilter, L"=");
    wcscat(SearchFilter, MemberDn);
    wcscat(SearchFilter, L"))");

    MK_ATTRS_2(SubscriberAttrs, ATTR_DN, ATTR_MEMBER_REF);

    if (!FrsSupLdapSearchInit(pLdap,
                    ComputerRef,
                    LDAP_SCOPE_SUBTREE,
                    SearchFilter,
                    SubscriberAttrs,
                    0,
                    &FrsSearchContext)) {

        WStatus = ERROR_NOT_FOUND;
        goto DODELETE;
    }

    NoOfSubscribers = FrsSearchContext.EntriesInPage;

    if (NoOfSubscribers != 1) {

        FrsSupLdapSearchClose(&FrsSearchContext);
        WStatus = ERROR_NOT_FOUND;
        goto DODELETE;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = FrsSupLdapSearchNext(pLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = FrsSupLdapSearchNext(pLdap, &FrsSearchContext)) {

       SubscriberDn = FrsSupFindValue(pLdap, LdapEntry, ATTR_DN);

    }

    FrsSupLdapSearchClose(&FrsSearchContext);


DODELETE:
    //
    // Now we have both the member dn and the subscriber dn.
    //

    if (SubscriberDn != NULL) {
        LStatus = ldap_delete_s(pLdap, SubscriberDn);
        if (LStatus != LDAP_SUCCESS) {
            WStatus = ERROR_INTERNAL_ERROR;
        }
    }

    if (MemberDn != NULL) {
        LStatus = ldap_delete_s(pLdap, MemberDn);
        if (LStatus != LDAP_SUCCESS) {
            WStatus = ERROR_INTERNAL_ERROR;
        }
    }

CLEANUP:

    if (pLdap != NULL) {
        ldap_unbind_s(pLdap);
    }

    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);

    FRS_SUP_FREE(SearchFilter);
    FRS_SUP_FREE(DefaultNcDn);
    FRS_SUP_FREE(SystemDn);
    FRS_SUP_FREE(NtfrsSettingsDn);
    FRS_SUP_FREE(ReplicaSetDn);
    FRS_SUP_FREE(MemberDn);
    FRS_SUP_FREE(ComputerRef);
    FRS_SUP_FREE(SubscriberDn);

    return WStatus;

}

DWORD
WINAPI
NtFrsApi_IsPathReplicated(
    IN OPTIONAL PWCHAR  ComputerName,
    IN          PWCHAR  Path,
    IN          ULONG   ReplicaSetTypeOfInterest,
    OUT         BOOL   *Replicated,
    OUT         ULONG   *Primary,
    OUT         BOOL   *Root,
    OUT         GUID    *ReplicaSetGuid
    )
/*++
Routine Description:

    Checks if the Path given is part of a replica set of type
    ReplicaSetTypeOfInterest. If ReplicaSetTypeOfInterest is 0, will match for
    any replica set type.On successful execution the OUT parameters are set as
    follows:

    Replicated == TRUE iff Path is part of a replica set of type
                   ReplicaSetTypeOfInterest

    Primary == 0 if this machine is not the primary for the replica set
           1 if this machine is the primary for the replica set
           2 if there is no primary for the replica set

    Root == TRUE iff Path is the root path for the replica

Arguments:

    ComputerName - Bind to the service on this computer. The computer
                   name can be any RPC-bindable name. Usually, the
                   NetBIOS or DNS name works just fine. The NetBIOS
                   name can be found with GetComputerName() or
                   hostname. The DNS name can be found with
                   gethostbyname() or ipconfig /all. If NULL, the
                   service on this computer is contacted.

    Path - the local path to check

    ReplicaSetTypeOfInterest - The type of replica set to match against. Set to
                   0 to match any replica set.

    Replicated - set TRUE iff Path is part of a replica set of type
         ReplicaSetTypeOfInterest.
         If Replicated is FALSE, the other OUT parameters are not set.

    Primary - set to 0 if this machine is not the primary for the replica set
             1 if this machine is the primary for the replica set
             2 if there is no primary for the replica set

    Root - set TRUE iff Path is the root path for the replica.

    ReplicaSetGuid - GUID of the matching replica set.

Return Value:

      Win32 Status

--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApi_IsPathReplicated:"

    DWORD           WStatus, WStatus1;
    DWORD           AuthWStatus;
    handle_t        AuthHandle      = NULL;
    ULONG ulReplicated, ulRoot;

    //
    // Bind to the service with authentication
    //
    AuthWStatus = NtFrsApi_BindWithAuth(ComputerName, NULL, &AuthHandle);
    if (!WIN_SUCCESS(AuthWStatus)) {
    NTFRSAPI_DBG_PRINT3("ERROR - Cannot bind w/authentication to computer, %ws; %08x (%d)\n",
                ComputerName, AuthWStatus, AuthWStatus);
    }

    //
    // Send Authenticated RPC request to service
    //
    if (HANDLE_IS_VALID(AuthHandle)) {
        try {
            WStatus = NtFrsApi_Rpc_IsPathReplicated(AuthHandle, Path, ReplicaSetTypeOfInterest, &ulReplicated, Primary, &ulRoot, ReplicaSetGuid);
            *Replicated = (ulReplicated==0)?FALSE:TRUE;
            *Root = (ulRoot==0)?FALSE:TRUE;
        } except (EXCEPTION_EXECUTE_HANDLER) {
              GET_EXCEPTION_CODE(WStatus);
        }
    } else {
    WStatus = ERROR_ACCESS_DENIED;
    }

    if (!WIN_SUCCESS(WStatus)) {
    NTFRSAPI_DBG_PRINT3("ERROR - Cannot RPC to computer, %ws; %08x (%d)\n",
                ComputerName, WStatus, WStatus);
    goto CLEANUP;
    }


    WStatus = ERROR_SUCCESS;

CLEANUP:
    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Unbind
        //
        if (AuthHandle) {
            WStatus1 = RpcBindingFree(&AuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;


}

DWORD
WINAPI
NtFrsApi_WriterCommand(
    IN PWCHAR   ComputerName,       OPTIONAL
    IN ULONG    Command
    )
/*++
Routine Description:

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    Command          - Command to send to the FRS service.
                       Only two commands are currently in use.
                       freeze and thaw.

Return Value:
    Win32 Status
--*/
{
    DWORD       WStatus, WStatus1;
    DWORD       AuthWStatus;
    DWORD       NoAuthWStatus;
    handle_t    AuthHandle    = NULL;
    handle_t    NoAuthHandle  = NULL;

    try {
        //
        // Bind to the service with and without authentication
        //
        AuthWStatus = NtFrsApi_BindWithAuth(ComputerName, NULL, &AuthHandle);
        NoAuthWStatus = NtFrsApi_Bind(ComputerName, NULL, &NoAuthHandle);

        //
        // Send Authenticated RPC request to service
        //
        if (HANDLE_IS_VALID(AuthHandle)) {
            try {
                WStatus = NtFrsApi_Rpc_WriterCommand(AuthHandle, Command);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                GET_EXCEPTION_CODE(WStatus);
            }
        } else {
            WStatus = ERROR_ACCESS_DENIED;
        }
        if (WStatus == ERROR_ACCESS_DENIED) {
            //
            // Send Unauthenticated RPC request to service
            //
            if (HANDLE_IS_VALID(NoAuthHandle)) {
                try {
                WStatus = NtFrsApi_Rpc_WriterCommand(AuthHandle, Command);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    GET_EXCEPTION_CODE(WStatus);
                }
            } else {
                WStatus = NoAuthWStatus;
            }
        }
        if (!WIN_SUCCESS(WStatus)) {
            WStatus = NtFrsApi_Fix_Comm_WStatus(WStatus);
            goto CLEANUP;
        }
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        //
        // Unbind
        //
        if (AuthHandle) {
            WStatus1 = RpcBindingFree(&AuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
        if (NoAuthHandle) {
            WStatus1 = RpcBindingFree(&NoAuthHandle);
            NtFrsApiCheckRpcError(WStatus1, "RpcBindingFree");
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}

DWORD
WINAPI
NtFrsApiGetBackupRestoreSetType(
    IN      PVOID    BurContext,
    IN      PVOID    BurSet,
    OUT     PWCHAR   SetType,
    IN OUT  DWORD    *SetTypeSizeInBytes
    )
/*++
Routine Description:
    Return the type of the replica set. The type is 
    returned as a string. The types are defined in the
    frsapip.h file.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    SetType     - type of the replica set in a string format.
    SetTypeSizeInBytes     - Length of the passed in buffer.

Return Value:

    ERROR_MORE_DATE - If the passed in buffer is not big enough
                      to hold the type. SetTypeSizeInBytes is set
                      to the size of buffer required.
    ERROR_INVALID_PARAMETER - Parameter validation.
    ERROR_NOT_FOUND - If passed in set is not found in the context
                      or if it does not have a type specified in
                      the registry.
    ERROR_SUCCESS   - When everything goes fine. SetTypeSizeInBytes
                      returns the number of bytes written to the
                      buffer.
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBackupRestoreSetType:"
    DWORD                   WStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;
    DWORD                   RequiredSizeInBytes;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if ((LocalBurSet == NULL) ||
            (LocalBurSet->BurSetType == NULL)) {
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }

        //
        // Check if the passed in buffer is large enough.
        //

        RequiredSizeInBytes = (wcslen(LocalBurSet->BurSetType)+1) *
                                sizeof(WCHAR);

        if ((SetType == NULL) ||
            (SetTypeSizeInBytes == NULL) ||
            (*SetTypeSizeInBytes < RequiredSizeInBytes) ){

            SetType = NULL;
            *SetTypeSizeInBytes = RequiredSizeInBytes;
            WStatus = ERROR_MORE_DATA;
            goto CLEANUP;
        }

        //
        // SUCCESS
        //

        *SetTypeSizeInBytes = RequiredSizeInBytes;
        wcscpy(SetType, LocalBurSet->BurSetType);
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}

DWORD
WINAPI
NtFrsApiGetBackupRestoreSetGuid(
    IN      PVOID    BurContext,
    IN      PVOID    BurSet,
    OUT     PWCHAR   SetGuid,
    IN OUT  DWORD    *SetGuidSizeInBytes
    )
/*++
Routine Description:
    Return the type of the replica set. The type is 
    returned as a string. The types are defined in the
    frsapip.h file.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    SetGuid     - Guid of the replica set in a string format.
    SetGuidSizeInBytes - Length of the passed in buffer.

Return Value:

    ERROR_MORE_DATE - If the passed in buffer is not big enough
                      to hold the guid. SetGuidSizeInBytes is set
                      to the size of buffer required.
    ERROR_INVALID_PARAMETER - Parameter validation.
    ERROR_NOT_FOUND - If passed in set is not found in the context.
    ERROR_SUCCESS   - When everything goes fine. SetGuidSizeInBytes
                      returns the number of bytes written to the
                      buffer.
    Win32 Status
--*/
{
#undef  NTFRSAPI_MODULE
#define NTFRSAPI_MODULE "NtFrsApiGetBackupRestoreSetGuid:"
    DWORD                   WStatus;
    PNTFRSAPI_BUR_SET       LocalBurSet;
    PNTFRSAPI_BUR_CONTEXT   LocalBurContext = BurContext;
    DWORD                   RequiredSizeInBytes;

    try {
        //
        // VERIFY THE PARAMETERS
        //

        //
        // Context
        //
        if (!LocalBurContext) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        if (!BurSet) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        //
        // Locate BurSet
        //
        for (LocalBurSet = LocalBurContext->BurSets;
             LocalBurSet && (LocalBurSet != BurSet);
             LocalBurSet = LocalBurSet->BurSetNext) {
        }
        if ((LocalBurSet == NULL) ||
            (LocalBurSet->BurSetGuid == NULL)) {
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }

        //
        // Check if the passed in buffer is large enough.
        //

        RequiredSizeInBytes = (wcslen(LocalBurSet->BurSetGuid)+1) *
                                sizeof(WCHAR);

        if ((SetGuid == NULL) ||
            (SetGuidSizeInBytes == NULL) ||
            (*SetGuidSizeInBytes < RequiredSizeInBytes) ){

            SetGuid = NULL;
            *SetGuidSizeInBytes = RequiredSizeInBytes;
            WStatus = ERROR_MORE_DATA;
            goto CLEANUP;
        }

        //
        // SUCCESS
        //

        *SetGuidSizeInBytes = RequiredSizeInBytes;
        wcscpy(SetGuid, LocalBurSet->BurSetGuid);
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\ntfrsutl\ntfrsutl.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ntfrsutl.c

Abstract:

    This is a utility program to help debug File Replication Service.
    It dumps the internal tables, thread and memory information. It runs
    on local as well as remote server. It uses RPC to communicate with the
    service.

Author:

    Sudarshan Chitre  12-Aug-1999

Environment

    User mode, winnt32

--*/

#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <ntfrsapi.h>


VOID
Win32ToMsg (
    IN PWCHAR Prefix,
    IN DWORD  WindowsErrorCode
    )

/*++
Routine Description:
    Translate a error code into a error message using FormatMessage()
    and print to stderr. If no message is available, the error code
    is printed in decimal and hex.

Arguments:
    Prefix   - prefix to error message
    WStatus  - Standard win32 error code.

Return Value:
    None.
--*/
{
    DWORD   NumChar;
    PWCHAR  Buffer;

    //
    // Use the system formatter for standard error codes
    //
    NumChar = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            WindowsErrorCode,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR) &Buffer,
                            0,
                            NULL
                            );

    if (NumChar) {
        fprintf(stderr, "%ws %ws\n", Prefix, Buffer);
    } else {
        fprintf(stderr, "%ws Status %d (0x%08x)\n", Prefix, WindowsErrorCode, WindowsErrorCode);
    }
    LocalFree( Buffer );
}


VOID
Usage(
    IN DWORD ExitStatus
    )
/*++
Routine Description:
    Print usage and exit

Arguments:
    ExitStatus  - exits with this status

Return Value:
    Exit(ExitStatus)
--*/
{
    printf("Ntfrsutl dumps the internal tables, thread and memory information\n");
    printf("for the ntfrs service.It runs against local as well as remote server.\n\n");
    printf("Note : To access the internal information, the logged in user should\n");
    printf("       have the required access on the following registry keys on the\n");
    printf("       target server.\n\n");
    printf("       HKLM\\System\\CCS\\Services\\Ntfrs\\Parameters\\Access Checks\\\n");
    printf("            Get Internal Information : Full control\n");
    printf("            Get Ds Polling Interval  : Read\n");
    printf("            Set Ds Polling Interval  : Full Control\n\n");
    printf("ntfrsutl [idtable | configtable | inlog | outlog] [computer]\n");
    printf("\t          = enumerate the service's idtable/configtable/inlog/outlog \n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("ntfrsutl [memory|threads|stage] [computer]\n");
    printf("\t          = list the service's memory usage\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("ntfrsutl ds [computer]\n");
    printf("\t          = list the service's view of the DS\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("ntfrsutl sets [computer]\n");
    printf("\t          = list the active replica sets\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("ntfrsutl version [computer]\n");
    printf("\t          = list the api and service versions\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("ntfrsutl poll [/quickly[=[N]]] [/slowly[=[N]]] [/now] [computer]\n");
    printf("\t          = list the current polling intervals.\n");
    printf("\tnow       = Poll now.\n");
    printf("\tquickly   = Poll quickly until stable configuration retrieved.\n");
    printf("\tquickly=  = Poll quickly every default minutes.\n");
    printf("\tquickly=N = Poll quickly every N minutes.\n");
    printf("\tslowly    = Poll slowly until stable configuration retrieved.\n");
    printf("\tslowly=   = Poll slowly every default minutes.\n");
    printf("\tslowly=N  = Poll slowly every N minutes.\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");

    exit(ExitStatus);
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv = LocalAlloc(LMEM_FIXED, (argc + 1) * sizeof(PWCHAR));
    if (wideargv == NULL) {
        fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                GetLastError());
        exit(1);
    }
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = LocalAlloc(LMEM_FIXED,
                                    (strlen(argv[argc]) + 1) * sizeof(WCHAR));
        if (wideargv[argc] == NULL) {
            fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                    GetLastError());
            exit(1);
        }
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
        FRS_WCSLWR(wideargv[argc]);
    }
    return wideargv;
}


VOID
ProcessPoll(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand poll.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   i;
    ULONG   LongInterval;
    ULONG   ShortInterval;
    ULONG   UseShortInterval;
    ULONG   Interval;
    DWORD   ComputerLen;
    PWCHAR  LocalComputerName;
    BOOL    SetInterval;

    //
    // Initialize the input parameters
    //
    LongInterval = 0;
    ShortInterval = 0;
    UseShortInterval = 0;
    LocalComputerName = NULL;
    SetInterval = FALSE;

    for (i = 2; i < argc; ++i) {
        //
        // Process options for poll
        //

        //
        // Not a parameter; must be the computer name
        //
        if (*Argv[i] != L'/' && *Argv[i] != L'-') {
            if (LocalComputerName) {
                fprintf(stderr, "Multiple computer names are not allowed\n");
                Usage(1);
            }
            LocalComputerName = Argv[i];
        //
        // /?
        //
        } else if (wcsstr(Argv[i] + 1, L"?") == Argv[i] + 1) {
            Usage(0);
        //
        // /quickly
        //
        } else if (!_wcsnicmp(Argv[i], L"/quickly", 8)) {
            SetInterval = TRUE;
            UseShortInterval = 1;
            if (*(Argv[i] + 8) != L'\0') {
                if (*(Argv[i] + 8) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 9) == L'\0') {
                    ShortInterval = NTFRSAPI_DEFAULT_SHORT_INTERVAL;
                } else {
                    ShortInterval = wcstoul(Argv[i] + 9, NULL, 10);
                }
                if (ShortInterval < NTFRSAPI_MIN_INTERVAL ||
                    ShortInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /slowly
        //
        } else if (!_wcsnicmp(Argv[i], L"/slowly", 7)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 7) != L'\0') {
                if (*(Argv[i] + 7) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 8) == L'\0') {
                    LongInterval = NTFRSAPI_DEFAULT_LONG_INTERVAL;
                } else {
                    LongInterval = wcstoul(Argv[i] + 8, NULL, 10);
                }
                if (LongInterval < NTFRSAPI_MIN_INTERVAL ||
                    LongInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /now
        //
        } else if (!_wcsnicmp(Argv[i], L"/now", 4)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 4) != L'\0') {
                fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                Usage(1);
            }
        //
        // Don't understand
        //
        } else {
            fprintf(stderr, "Don't understand %ws\n", Argv[i]);
            Usage(1);
        }
    }
    if (SetInterval) {
        //
        // Set the interval and initiate a new polling cycle
        //
        WStatus = NtFrsApi_Set_DsPollingIntervalW(LocalComputerName,
                                                  UseShortInterval,
                                                  LongInterval,
                                                  ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't set interval:", WStatus);
            exit(1);
        }
    } else {
        //
        // Get the current polling cycles
        //
        WStatus = NtFrsApi_Get_DsPollingIntervalW(LocalComputerName,
                                                  &Interval,
                                                  &LongInterval,
                                                  &ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't get intervals:", WStatus);
            exit(1);
        }
        printf("Current Interval: %6d minutes\n", Interval);
        printf("Short Interval  : %6d minutes\n", ShortInterval);
        printf("Long Interval   : %6d minutes\n", LongInterval);
    }
    exit(0);
}


VOID
ProcessWriterCommand(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN ULONG    Command
    )
/*++
Routine Description:
    Make calls to freeze and thaw.

Arguments:
    Command - command to send to the FRS service.

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  LocalComputerName = NULL;

    if (argc > 2) {
        LocalComputerName = Argv[2];
    }

    WStatus = NtFrsApi_WriterCommand(LocalComputerName,
                                          Command);
    if (!WIN_SUCCESS(WStatus)) {
        Win32ToMsg(L"Can't call writer APIs", WStatus);
        exit(1);
    }
    exit(0);
}

VOID
ProcessDump(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    TypeOfInformation
    )
/*++
Routine Description:
    Dump bunches of stuff

Arguments:
    argc
    Argv
    TypeOfInformation

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PCHAR   Line;
    BOOL    FirstTime = TRUE;
    PVOID   Info = NULL;
    PWCHAR  LocalComputerName = NULL;

    if (argc > 2) {
        LocalComputerName = Argv[2];
    }

    do {
        WStatus = NtFrsApi_InfoW(LocalComputerName,
                                 TypeOfInformation,
                                 0,
                                 &Info);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr, "ERROR NtFrsApi_InfoW() Error %d\n", WStatus);
            NtFrsApi_InfoFreeW(&Info);
            exit(1);
        }
        if (Info) {
            if (!FirstTime) {
                printf("===== THE FOLLOWING INFO MAY BE INCONSISTENT DUE TO REFETCH =====\n");
            }
            FirstTime = FALSE;

            Line = NULL;
            do {
                WStatus = NtFrsApi_InfoLineW(Info, &Line);
                if (!WIN_SUCCESS(WStatus)) {
                    fprintf(stderr, "ERROR NtFrsApi_InfoLineW() Error %d\n", WStatus);
                    NtFrsApi_InfoFreeW(&Info);
                    exit(1);
                }
                if (Line) {
                    printf("%s", Line);
                }
            } while (Line);
        }
    } while (Info);
    exit(0);
}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PWCHAR  *Argv;

    //
    // Print usage and exit
    //
    if (argc == 1) {
        Usage(0);
    }

    //
    // Use wide char parameters
    //
    Argv = ConvertArgv(argc, argv);

    //
    // Find the subcommand
    //
    if (!wcscmp(Argv[1], L"poll")) {
        ProcessPoll(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"version")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_VERSION);
    } else if (!_wcsicmp(Argv[1], L"sets")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_SETS);
    } else if (!_wcsicmp(Argv[1], L"ds")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_DS);
    } else if (!_wcsicmp(Argv[1], L"memory")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_MEMORY);
    } else if (!_wcsicmp(Argv[1], L"idtable")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_IDTABLE);
    } else if (!_wcsicmp(Argv[1], L"configtable")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_CONFIGTABLE);
    } else if (!_wcsicmp(Argv[1], L"inlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_INLOG);
    } else if (!_wcsicmp(Argv[1], L"outlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_OUTLOG);
    } else if (!_wcsicmp(Argv[1], L"threads")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_THREADS);
    } else if (!_wcsicmp(Argv[1], L"stage")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_STAGE);
    }
    
#if  0
    else if (!_wcsicmp(Argv[1], L"freeze")) {
        ProcessWriterCommand(argc, Argv, NTFRSAPI_WRITER_COMMAND_FREEZE);
    } else if (!_wcsicmp(Argv[1], L"thaw")) {
        ProcessWriterCommand(argc, Argv, NTFRSAPI_WRITER_COMMAND_THAW);
    }
#endif

    else if (!_wcsicmp(Argv[1], L"/?")) {
        Usage(0);
    } else {
        fprintf(stderr, "Don't understand %ws\n", Argv[1]);
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\ntfrscon.h ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSCON.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	NTFRSCON.h

Abstract

	This is the offset definition file for the REPLICACONN Object.

Environment:

	User Mode Service

Revision History:

--*/


#ifndef _NTFRSCON_H_
#define _NTFRSCON_H_

//
// The offset definitions follow
//
#define OBJREPLICACONN 0 // REPLICACONN Object

#define DEV_CTR_1 2  // Packets Sent in Bytes            
#define DEV_CTR_2 4  // Fetch Blocks Sent in Bytes       
#define DEV_CTR_3 6  // Fetch Blocks Received in Bytes   
#define DEV_CTR_4 8  // Local Change Orders Sent         
#define DEV_CTR_5 10  // Local Change Orders Sent At Join 
#define DEV_CTR_6 12  // Remote Change Orders Sent        
#define DEV_CTR_7 14  // Remote Change Orders Received    
#define DEV_CTR_8 16  // Inbound Change Orders Dampened   
#define DEV_CTR_9 18  // Outbound Change Orders Dampened  
#define DEV_CTR_10 20  // Packets Sent                     
#define DEV_CTR_11 22  // Packets Sent in Error            
#define DEV_CTR_12 24  // Communication Timeouts           
#define DEV_CTR_13 26  // Fetch Requests Sent              
#define DEV_CTR_14 28  // Fetch Requests Received          
#define DEV_CTR_15 30  // Fetch Blocks Sent                
#define DEV_CTR_16 32  // Fetch Blocks Received            
#define DEV_CTR_17 34  // Join Notifications Sent          
#define DEV_CTR_18 36  // Join Notifications Received      
#define DEV_CTR_19 38  // Joins                            
#define DEV_CTR_20 40  // Unjoins                          
#define DEV_CTR_21 42  // Bindings                         
#define DEV_CTR_22 44  // Bindings in Error                
#define DEV_CTR_23 46  // Authentications                  
#define DEV_CTR_24 48  // Authentications in Error         

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\ntfrsrep.h ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSREP.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	NTFRSREP.h

Abstract

	This is the offset definition file for the REPLICASET Object.

Environment:

	User Mode Service

Revision History:

--*/


#ifndef _NTFRSREP_H_
#define _NTFRSREP_H_

//
// The offset definitions follow
//
#define OBJREPLICASET 0 // REPLICASET Object

#define DEV_CTR_1 2  // Bytes of Staging Generated              
#define DEV_CTR_2 4  // Bytes of Staging Fetched                
#define DEV_CTR_3 6  // Bytes of Staging Regenerated            
#define DEV_CTR_4 8  // Bytes of Files Installed                
#define DEV_CTR_5 10  // KB of Staging Space In Use              
#define DEV_CTR_6 12  // KB of Staging Space Free                
#define DEV_CTR_7 14  // Packets Received in Bytes               
#define DEV_CTR_8 16  // Packets Sent in Bytes                   
#define DEV_CTR_9 18  // Fetch Blocks Sent in Bytes              
#define DEV_CTR_10 20  // Fetch Blocks Received in Bytes          
#define DEV_CTR_11 22  // Staging Files Generated                 
#define DEV_CTR_12 24  // Staging Files Generated with Error      
#define DEV_CTR_13 26  // Staging Files Fetched                   
#define DEV_CTR_14 28  // Staging Files Regenerated               
#define DEV_CTR_15 30  // Files Installed                         
#define DEV_CTR_16 32  // Files Installed with Error              
#define DEV_CTR_17 34  // Change Orders Issued                    
#define DEV_CTR_18 36  // Change Orders Retired                   
#define DEV_CTR_19 38  // Change Orders Aborted                   
#define DEV_CTR_20 40  // Change Orders Retried                   
#define DEV_CTR_21 42  // Change Orders Retried at Generate       
#define DEV_CTR_22 44  // Change Orders Retried at Fetch          
#define DEV_CTR_23 46  // Change Orders Retried at Install        
#define DEV_CTR_24 48  // Change Orders Retried at Rename         
#define DEV_CTR_25 50  // Change Orders Morphed                   
#define DEV_CTR_26 52  // Change Orders Propagated                
#define DEV_CTR_27 54  // Change Orders Received                  
#define DEV_CTR_28 56  // Change Orders Sent                      
#define DEV_CTR_29 58  // Change Orders Evaporated                
#define DEV_CTR_30 60  // Local Change Orders Issued              
#define DEV_CTR_31 62  // Local Change Orders Retired             
#define DEV_CTR_32 64  // Local Change Orders Aborted             
#define DEV_CTR_33 66  // Local Change Orders Retried             
#define DEV_CTR_34 68  // Local Change Orders Retried at Generate 
#define DEV_CTR_35 70  // Local Change Orders Retried at Fetch    
#define DEV_CTR_36 72  // Local Change Orders Retried at Install  
#define DEV_CTR_37 74  // Local Change Orders Retried at Rename   
#define DEV_CTR_38 76  // Local Change Orders Morphed             
#define DEV_CTR_39 78  // Local Change Orders Propagated          
#define DEV_CTR_40 80  // Local Change Orders Sent                
#define DEV_CTR_41 82  // Local Change Orders Sent At Join        
#define DEV_CTR_42 84  // Remote Change Orders Issued             
#define DEV_CTR_43 86  // Remote Change Orders Retired            
#define DEV_CTR_44 88  // Remote Change Orders Aborted            
#define DEV_CTR_45 90  // Remote Change Orders Retried            
#define DEV_CTR_46 92  // Remote Change Orders Retried at Generate
#define DEV_CTR_47 94  // Remote Change Orders Retried at Fetch   
#define DEV_CTR_48 96  // Remote Change Orders Retried at Install 
#define DEV_CTR_49 98  // Remote Change Orders Retried at Rename  
#define DEV_CTR_50 100  // Remote Change Orders Morphed            
#define DEV_CTR_51 102  // Remote Change Orders Propagated         
#define DEV_CTR_52 104  // Remote Change Orders Sent               
#define DEV_CTR_53 106  // Remote Change Orders Received           
#define DEV_CTR_54 108  // Inbound Change Orders Dampened          
#define DEV_CTR_55 110  // Outbound Change Orders Dampened         
#define DEV_CTR_56 112  // Usn Reads                               
#define DEV_CTR_57 114  // Usn Records Examined                    
#define DEV_CTR_58 116  // Usn Records Accepted                    
#define DEV_CTR_59 118  // Usn Records Rejected                    
#define DEV_CTR_60 120  // Packets Received                        
#define DEV_CTR_61 122  // Packets Received in Error               
#define DEV_CTR_62 124  // Packets Sent                            
#define DEV_CTR_63 126  // Packets Sent in Error                   
#define DEV_CTR_64 128  // Communication Timeouts                  
#define DEV_CTR_65 130  // Fetch Requests Sent                     
#define DEV_CTR_66 132  // Fetch Requests Received                 
#define DEV_CTR_67 134  // Fetch Blocks Sent                       
#define DEV_CTR_68 136  // Fetch Blocks Received                   
#define DEV_CTR_69 138  // Join Notifications Sent                 
#define DEV_CTR_70 140  // Join Notifications Received             
#define DEV_CTR_71 142  // Joins                                   
#define DEV_CTR_72 144  // Unjoins                                 
#define DEV_CTR_73 146  // Bindings                                
#define DEV_CTR_74 148  // Bindings in Error                       
#define DEV_CTR_75 150  // Authentications                         
#define DEV_CTR_76 152  // Authentications in Error                
#define DEV_CTR_77 154  // DS Polls                                
#define DEV_CTR_78 156  // DS Polls without Changes                
#define DEV_CTR_79 158  // DS Polls with Changes                   
#define DEV_CTR_80 160  // DS Searches                             
#define DEV_CTR_81 162  // DS Searches in Error                    
#define DEV_CTR_82 164  // DS Objects                              
#define DEV_CTR_83 166  // DS Objects in Error                     
#define DEV_CTR_84 168  // DS Bindings                             
#define DEV_CTR_85 170  // DS Bindings in Error                    
#define DEV_CTR_86 172  // Replica Sets Created                    
#define DEV_CTR_87 174  // Replica Sets Deleted                    
#define DEV_CTR_88 176  // Replica Sets Removed                    
#define DEV_CTR_89 178  // Replica Sets Started                    
#define DEV_CTR_90 180  // Threads started                         
#define DEV_CTR_91 182  // Threads exited                          

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perfconn.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    perfconn.c

Abstract:

    This file contains the (three) functions that implement the PerformanceDLL of the
    REPLICACONN Object.

Author:

    Rohan Kumar          [rohank]   13-Sept-1998

Environment:

    User Mode Service

Revision History:


--*/

#include "REPCONN.h"
#include "perfutil.h"
#include "NTFRSCON.h"

//
// Should Perfmon return Data ? This boolean is set in the DllMain function.
//
extern BOOLEAN ShouldPerfmonCollectData;

//
// Data Variable definition
//
REPLICACONN_DATA_DEFINITION ReplicaConnDataDefinition;

//
// Extern variable definition
//
extern ReplicaConnValues RepConnInitData[FRC_NUMOFCOUNTERS];

//
// Sum of counter sizes + SIZEOFDWORD
//
DWORD SizeOfReplicaConnPerformanceData = 0;

//
// Number of "Open" threads
//
DWORD FRC_dwOpenCount = 0;

//
// Data structure used by the Open RPC Call
//
OpenRpcData *FRC_datapackage = NULL;

//
// Data structure used by the Collect RPC Call
//
CollectRpcData *FRC_collectpakg = NULL;

//
// Used to filter duplicate eventlog messages.
//
BOOLEAN FRC_Op = TRUE, FRC_Cl = TRUE;

//
// Signatures of functions implemented in this file
//

PM_OPEN_PROC    OpenReplicaConnPerformanceData; // The Open function
PM_COLLECT_PROC CollectReplicaConnPerformanceData; // The Collect function
PM_CLOSE_PROC   CloseReplicaConnPerformanceData; // The Close function

DWORD FRC_BindTheRpcHandle(handle_t *); // Binds the RPC handle
VOID  FreeReplicaConnData();            // Free the allocated memory.
PVOID FRSPerfAlloc(IN DWORD Size);      // Allocates memory

#undef GET_EXCEPTION_CODE
#define GET_EXCEPTION_CODE(_x_)                                                \
{                                                                              \
    (_x_) = GetExceptionCode();                                                \
    if (((LONG)(_x_)) < 0) {                                                   \
        (_x_) = FRS_ERR_INTERNAL_API;                                          \
    }                                                                          \
    /* NTFRSAPI_DBG_PRINT2("Exception caught: %d, 0x%08x\n", (_x_), (_x_)); */ \
}


#if 0
VOID
InitializeTheRepConnObjectData(
    VOID
    )

/*++

Routine Description:

    This routine initializes the ReplicaConnDataDefinition data structure

Arguments:

    none

Return Value:

    none

--*/

{
    LONG i, j;
    PPERF_OBJECT_TYPE        PerfObject;
    PPERF_COUNTER_DEFINITION CounterDef;

    //
    // Initialization of ReplicaConnObjectType (PERF_OBJECT_TYPE) field.
    //
    PerfObject = &ReplicaConnDataDefinition.ReplicaConnObjectType;

    PerfObject->TotalByteLength  = sizeof(REPLICACONN_DATA_DEFINITION);
    PerfObject->DefinitionLength = sizeof(REPLICACONN_DATA_DEFINITION);
    PerfObject->HeaderLength     = sizeof(PERF_OBJECT_TYPE);
    PerfObject->ObjectNameTitleIndex = OBJREPLICACONN;
    PerfObject->ObjectNameTitle      = 0;
    PerfObject->ObjectHelpTitleIndex = OBJREPLICACONN;
    PerfObject->ObjectHelpTitle = 0;
    PerfObject->DetailLevel     = PERF_DETAIL_NOVICE;
    PerfObject->NumCounters     = FRC_NUMOFCOUNTERS;
    PerfObject->DefaultCounter  = 0;
    PerfObject->NumInstances    = PERF_NO_INSTANCES;
    PerfObject->CodePage        = 0;

    //
    // Initialization of NumStat (PERF_COUNTER_DEFINITION) structures.
    //
    for (i = 0, j = 2; i < FRC_NUMOFCOUNTERS; i++, j += 2) {
        CounterDef = &ReplicaConnDataDefinition.NumStat[i];

        CounterDef->ByteLength =  sizeof(PERF_COUNTER_DEFINITION);
        CounterDef->CounterNameTitleIndex = j;
        CounterDef->CounterNameTitle = 0;
        CounterDef->CounterHelpTitleIndex = j;
        CounterDef->CounterHelpTitle = 0;
        CounterDef->DefaultScale = 0;
        CounterDef->DetailLevel = PERF_DETAIL_NOVICE;
        CounterDef->CounterType = RepConnInitData[i].counterType;
        CounterDef->CounterSize = RepConnInitData[i].size;
        CounterDef->CounterOffset = RepConnInitData[i].offset + sizeof(DWORD);
    }

    //
    // Set the total size of the counter data types
    //
    SizeOfReplicaConnPerformanceData = SIZEOF_REPCONN_COUNTER_DATA +
                                       CSIZEOFDWORD;
}
#endif


DWORD APIENTRY
OpenReplicaConnPerformanceData (
    IN LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine does the following:

    1. Sets up the data structures (field values of structures used by PERFMON)
       used for collecting the counter data.

    2. Gets the numerical indices for Instance names from the server using RPC.

Arguments:

    lpDeviceNames - Pointer to the Instance list

Return Value:

    ERROR_SUCCESS - The Initialization was successful OR
    Appropriate DWORD value for the Error status

--*/

{
    LONG WStatus, WStatus1, i;
    HKEY hKeyDriverPerf = INVALID_HANDLE_VALUE;
    DWORD size, type;
    DWORD dwFirstCounter, dwFirstHelp;
    //
    // Additions for instances
    //
    size_t len, tot = 0;
    PWCHAR p, q;
    INT j, namelen = 0;
    handle_t Handle;
    PPERF_COUNTER_DEFINITION CounterDef;

    //
    // If InitializeCriticalSectionAndSpinCount returned error, no point
    // in continuing. Open always has to return success.
    //
    if (!ShouldPerfmonCollectData) {
        return ERROR_SUCCESS;
    }

    //
    // Keep track of the number of times open has been called. The Registry
    // routines will limit the access to the initialization routine to only
    // on thread at a time, so synchronization should not be a problem. The
    // FRC_ThrdCounter is used to synchronize between this (Open) and the Close
    // functions.
    //
    EnterCriticalSection(&FRC_ThrdCounter);
    if (FRC_dwOpenCount != 0) {
        //
        // Increment the FRC_dwOpenCount counter which counts the number of
        // times Open has been called.
        //
        FRC_dwOpenCount++;
        LeaveCriticalSection(&FRC_ThrdCounter);
        return ERROR_SUCCESS;
    }
    LeaveCriticalSection(&FRC_ThrdCounter);

    //
    // Perform some preliminary checks.
    //
    if (FRC_collectpakg != NULL || FRC_datapackage != NULL) {
        //
        // We seem to have failed (in the last call) in the middle of this
        // Open function. Also the open count is zero which means we
        // haven't yet succeeded a open.
        // Free up resources and return.
        //
        FreeReplicaConnData();
        return ERROR_SUCCESS;
    }

    //
    // Do the necessary initialization of the PERFMON data structures
    //
    SizeOfReplicaConnPerformanceData = InitializeObjectData(
                                           sizeof(REPLICACONN_DATA_DEFINITION),
                                           OBJREPLICACONN,
                                           FRC_NUMOFCOUNTERS,
                                           (PFRS_PERF_DATA_DEFINITION) &ReplicaConnDataDefinition,
                                           (PFRS_PERF_INIT_VALUES) RepConnInitData,
                                           SIZEOF_REPCONN_COUNTER_DATA);

    //
    // Get the counter and help index base values from the registry. Open key
    // to registry entry, read the First Counter and First Help values. Update
    // the static data structures by adding base to offset value in the structure
    //
    WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Performance",
                            0L,
                            KEY_READ,
                            &hKeyDriverPerf);
    if (WStatus != ERROR_SUCCESS) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        FilterAndPrintToEventLog(WINPERF_LOG_USER, FRC_Op, NTFRSPRF_REGISTRY_ERROR_CONN);
        // Open function always returns ERROR_SUCCESS.
        return ERROR_SUCCESS;
    }

    size = sizeof(DWORD);
    WStatus = RegQueryValueEx (hKeyDriverPerf,
                               L"First Counter",
                               0L,
                               &type,
                               (LPBYTE)&dwFirstCounter,
                               &size);
    if (WStatus != ERROR_SUCCESS || type != REG_DWORD) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        FRS_REG_CLOSE(hKeyDriverPerf); // Close the registry key
        FilterAndPrintToEventLog(WINPERF_LOG_USER, FRC_Op, NTFRSPRF_REGISTRY_ERROR_CONN);
        // Open function always returns ERROR_SUCCESS.
        return ERROR_SUCCESS;
    }

    size = sizeof(DWORD);
    WStatus = RegQueryValueEx (hKeyDriverPerf,
                               L"First Help",
                               0L,
                               &type,
                               (LPBYTE)&dwFirstHelp,
                               &size);
    if (WStatus != ERROR_SUCCESS || type != REG_DWORD) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        FRS_REG_CLOSE(hKeyDriverPerf); // Close the registry key
        FilterAndPrintToEventLog(WINPERF_LOG_USER, FRC_Op, NTFRSPRF_REGISTRY_ERROR_CONN);
        // Open function always returns ERROR_SUCCESS.
        return ERROR_SUCCESS;
    }

    //
    // Add offsets to the name and help fields
    //
    ReplicaConnDataDefinition.ReplicaConnObjectType.ObjectNameTitleIndex += dwFirstCounter;
    ReplicaConnDataDefinition.ReplicaConnObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    for (i = 0; i < FRC_NUMOFCOUNTERS; i++) {
        CounterDef = &ReplicaConnDataDefinition.NumStat[i];
        CounterDef->CounterNameTitleIndex += dwFirstCounter;
        CounterDef->CounterHelpTitleIndex += dwFirstHelp;
    }

    FRS_REG_CLOSE(hKeyDriverPerf); // Close the registry key

    //
    // Check if there are any instances. If there are, parse and set them in a structure
    // to be sent to the server to get the indices for the instance names. These indices
    // are used in the collect function to get the data
    //
    if (lpDeviceNames != NULL) {
        //
        // yes, there are
        //
        q = (PWCHAR) lpDeviceNames;
        //
        // Calculate the number of instances
        //
        while (TRUE) {
            tot++;
            p = wcschr(q, L'\0');
            if (*(p + 1) == L'\0') {
                break;
            }
            q = p + 1;
        }

        //
        // Bind the RPC handle
        //
        if ( (WStatus = FRC_BindTheRpcHandle(&Handle)) != ERROR_SUCCESS) {
            //
            // Service may be stopped.
            // return success.
            //
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRC_Op, NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN);
            return ERROR_SUCCESS;
        }

        //
        // Set the data structure to be sent to the server using RPC
        //
        FRC_datapackage = (OpenRpcData *) FRSPerfAlloc (sizeof(OpenRpcData));
        NTFRS_MALLOC_TEST(FRC_datapackage, FreeReplicaConnData(), FALSE);
        FRC_datapackage->majorver = MAJORVERSION;
        FRC_datapackage->minorver = MINORVERSION;
        FRC_datapackage->ObjectType = REPCONN;
        FRC_datapackage->numofinst = tot;
        FRC_datapackage->ver = (PLONG) FRSPerfAlloc (sizeof(LONG));
        NTFRS_MALLOC_TEST(FRC_datapackage->ver, FreeReplicaConnData(), FALSE);
        FRC_datapackage->indices = (inst_index *) FRSPerfAlloc (sizeof(inst_index));
        NTFRS_MALLOC_TEST(FRC_datapackage->indices, FreeReplicaConnData(), FALSE);
        FRC_datapackage->indices->size = tot;
        FRC_datapackage->indices->index = (PLONG) FRSPerfAlloc ( FRC_datapackage->numofinst * sizeof(LONG));
        NTFRS_MALLOC_TEST(FRC_datapackage->indices->index, FreeReplicaConnData(), FALSE);
        FRC_datapackage->instnames = (InstanceNames *) FRSPerfAlloc (sizeof(InstanceNames));
        NTFRS_MALLOC_TEST(FRC_datapackage->instnames, FreeReplicaConnData(), FALSE);
        FRC_datapackage->instnames->size = tot;
        FRC_datapackage->instnames->InstanceNames = (inst_name *) FRSPerfAlloc (tot * sizeof(inst_name));
        NTFRS_MALLOC_TEST(FRC_datapackage->instnames->InstanceNames, FreeReplicaConnData(), FALSE);
        //
        // Copy the instance names and set the corresponding size value used by RPC
        //
        q = (PWCHAR) lpDeviceNames;
        for (j = 0; j < FRC_datapackage->numofinst; j++) {
            p = wcschr(q, L'\0');
            len = wcslen (q);
            FRC_datapackage->instnames->InstanceNames[j].size = len + 1;
            FRC_datapackage->instnames->InstanceNames[j].name =
                                    (PWCHAR) FRSPerfAlloc ((len + 1) * sizeof(WCHAR));
            NTFRS_MALLOC_TEST(FRC_datapackage->instnames->InstanceNames[j].name, FreeReplicaConnData(), FALSE);
            wcscpy(FRC_datapackage->instnames->InstanceNames[j].name, q);
            //
            // Calculate the total length of all the instance names
            // The extra 1 is for the '\0' character. The namelen is
            // rounded upto the next 8 byte boundary.
            //
            namelen += (((((len + 1) * sizeof(WCHAR)) + 7) >> 3) << 3);
            q = p + 1;
        }

        //
        // Set the totalbytelength and NumInstances fields of the PERF_OBJECT_TYPE Data structure,
        // now that we know the number of instances and the length of their names
        //
        ReplicaConnDataDefinition.ReplicaConnObjectType.TotalByteLength +=
            namelen +
            (FRC_datapackage->numofinst *
             (SizeOfReplicaConnPerformanceData + CSIZEOFDWORD +
               sizeof(PERF_INSTANCE_DEFINITION)));

        ReplicaConnDataDefinition.ReplicaConnObjectType.NumInstances =
            FRC_datapackage->numofinst;

        //
        // Call the server to set the indices of the instance names
        //
        try {
            WStatus = GetIndicesOfInstancesFromServer(Handle, FRC_datapackage);
        } except (EXCEPTION_EXECUTE_HANDLER) {
              GET_EXCEPTION_CODE(WStatus);
        }
        if (!WIN_SUCCESS(WStatus)) {
            //
            // RPC error trying to contact service.
            // Free up the memory and return success.
            //
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRC_Op, NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN);
            WStatus1 = RpcBindingFree(&Handle);
            FreeReplicaConnData();
            return ERROR_SUCCESS;
        }

        //
        // Set the data structure used by the RPC call in the Collect function
        //
        FRC_collectpakg = (CollectRpcData *) FRSPerfAlloc (sizeof(CollectRpcData));
        NTFRS_MALLOC_TEST(FRC_collectpakg, FreeReplicaConnData(), TRUE);
        FRC_collectpakg->majorver = MAJORVERSION;
        FRC_collectpakg->minorver = MINORVERSION;
        FRC_collectpakg->ObjectType = REPCONN;
        FRC_collectpakg->ver = *(FRC_datapackage->ver);
        FRC_collectpakg->numofinst = FRC_datapackage->numofinst;
        FRC_collectpakg->numofcotrs = FRC_NUMOFCOUNTERS;
        FRC_collectpakg->indices = (inst_index *) FRSPerfAlloc (sizeof(inst_index));
        NTFRS_MALLOC_TEST(FRC_collectpakg->indices, FreeReplicaConnData(), TRUE);
        FRC_collectpakg->indices->size = FRC_datapackage->indices->size;
        FRC_collectpakg->indices->index = (PLONG) FRSPerfAlloc (FRC_collectpakg->indices->size * sizeof(LONG));
        NTFRS_MALLOC_TEST(FRC_collectpakg->indices->index, FreeReplicaConnData(), TRUE);
        //
        // Copy the indices got from the server
        //
        for (j = 0; j < FRC_collectpakg->numofinst; j++) {
            FRC_collectpakg->indices->index[j]= FRC_datapackage->indices->index[j];
        }
        //
        // Set the memory blob used to (mem)copy the counter dats from the server
        //
        FRC_collectpakg->databuff = (DataBuffer *) FRSPerfAlloc (sizeof(DataBuffer));
        NTFRS_MALLOC_TEST(FRC_collectpakg->databuff, FreeReplicaConnData(), TRUE);
        FRC_collectpakg->databuff->size = FRC_collectpakg->numofinst *
                                          SIZEOF_REPCONN_COUNTER_DATA;

        //
        // Allocate memory for the buffer in which the data gets copied.
        //
        FRC_collectpakg->databuff->data = (PBYTE) FRSPerfAlloc (FRC_collectpakg->databuff->size * sizeof(BYTE));
        NTFRS_MALLOC_TEST(FRC_collectpakg->databuff->data, FreeReplicaConnData(), TRUE);

        WStatus1 = RpcBindingFree(&Handle);

    } else {
        //
        // There are no instances at this time, so set the PERF_OBJECT_TYPE structure fields accordingly
        //
        ReplicaConnDataDefinition.ReplicaConnObjectType.TotalByteLength +=
                             SizeOfReplicaConnPerformanceData + CSIZEOFDWORD;
        ReplicaConnDataDefinition.ReplicaConnObjectType.NumInstances =
                                                            PERF_NO_INSTANCES;
    }

    EnterCriticalSection(&FRC_ThrdCounter);
    FRC_dwOpenCount++; // increment the open counter
    LeaveCriticalSection(&FRC_ThrdCounter);

    FRC_Op = TRUE;
    return ERROR_SUCCESS;
}



DWORD APIENTRY
CollectReplicaConnPerformanceData (
    IN     LPWSTR lpValueName,
    IN OUT LPVOID *lppData,
    IN OUT LPDWORD lpcbTotalBytes,
    IN OUT LPDWORD lpNumObjectTypes
    )

/*++

Routine Description:

    This routine collects the counter data from the server and copies it into
    the callers buffer.

Arguments:

    lpValueName - Wide character string passed by the registry.
    lppData - IN:  Pointer to the address of the buffer to receive the
                   completed PerfDataBlock and the subordinate structures.
                       This routine will append its data to the buffer starting
                           at the point referenced by *lppData.
              OUT: Points to the first byte after the data structure added
                       by this routine.
    lpcbTotalBytes - IN:  The address of the DWORD that tells the size in bytes
                          of the buffer referenced by the lppData argument
                             OUT: The number of bytes added by this routine is written
                                  to the DWORD pointed to by this argument.
    lpNumObjectTypes - IN:  The address of the DWORD to receive the number of
                            Objects added by this routine       .
                       OUT: The number of Objects added by this routine is written
                                    to the buffer pointed by this argument.
Return Value:

    ERROR_MORE_DATA - The buffer passed was too small.
    ERROR_SUCCESS - Success or any other error

--*/

{
    //
    // Variables for reformatting data
    //
    ULONG               SpaceNeeded;
    PBYTE               bte, vd;
    PDWORD              pdwCounter;
    DWORD               dwQueryType;
    LONG                j, k;
    PWCHAR              name;
    DWORD               WStatus;
    LPWSTR              lpDeviceNames = NULL;
    HKEY                hKeyDriverPerf = INVALID_HANDLE_VALUE;
    DWORD               size, type;
    PERF_COUNTER_BLOCK  *pPerfCounterBlock;

    PERF_INSTANCE_DEFINITION *p1;
    REPLICACONN_DATA_DEFINITION *pReplicaConnDataDefinition;

    //
    // RPC Additions
    //
    handle_t Handle;

    //
    // Check to see that all the pointers that are passed in are fine
    //
    if (lppData == NULL || *lppData == NULL || lpcbTotalBytes == NULL ||
        lpValueName == NULL || lpNumObjectTypes == NULL) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        return ERROR_SUCCESS;
    }

    //
    // Check to see if Open went OK.
    // If not then call then attempt to
    // make the open call here.
    //
    EnterCriticalSection(&FRC_ThrdCounter);
    if (FRC_dwOpenCount == 0) {
        LeaveCriticalSection(&FRC_ThrdCounter);

        try {
            //
            // Get the Export value from the Linkage key
            // SYSTEM\CurrentControlSet\Services\FileReplicaConn\Linkage
            //
            WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Linkage",
                                    0L,
                                    KEY_READ,
                                    &hKeyDriverPerf);
            if (WStatus != ERROR_SUCCESS) {
                __leave;
            }

            //
            // Start with string length MAX_PATH and increase
            // if required. If lpDeviceNames is NULL for the 
            // first call then the function succeeds without
            // returning a value.
            //
            size = MAX_PATH * sizeof(WCHAR);
            lpDeviceNames = FRSPerfAlloc(size);
            WStatus = RegQueryValueEx (hKeyDriverPerf,
                                       L"Export",
                                       0L,
                                       &type,
                                       (LPBYTE)lpDeviceNames,
                                       &size);

            if (WStatus == ERROR_MORE_DATA) {
                free(lpDeviceNames);
                lpDeviceNames = FRSPerfAlloc(size);
                if (lpDeviceNames == NULL) {
                    WStatus = ERROR_NO_SYSTEM_RESOURCES;
                    __leave;
                }
                WStatus = RegQueryValueEx (hKeyDriverPerf,
                                           L"Export",
                                           0L,
                                           &type,
                                           (LPBYTE)lpDeviceNames,
                                           &size);
            }

        }  except (EXCEPTION_EXECUTE_HANDLER) {
           //
           // Exception
           //
           WStatus = GetExceptionCode();
        }

        FRS_REG_CLOSE(hKeyDriverPerf);

        if (WStatus != ERROR_SUCCESS || type != REG_MULTI_SZ) {
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            if (lpDeviceNames != NULL) {
                free(lpDeviceNames);
            }
            return ERROR_SUCCESS;
        }

        if (lpDeviceNames != NULL) {
            WStatus = OpenReplicaConnPerformanceData(lpDeviceNames);
            free(lpDeviceNames);
        }
    } else {
        LeaveCriticalSection(&FRC_ThrdCounter);
    }

    //
    // Check to see if Open went OK
    //
    EnterCriticalSection(&FRC_ThrdCounter);
    if (FRC_dwOpenCount == 0) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        LeaveCriticalSection(&FRC_ThrdCounter);
        //
        // Fatal error. No point in continuing.
        //
        return ERROR_SUCCESS;
    }
    LeaveCriticalSection(&FRC_ThrdCounter);

    //
    // Check the query type
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS) {
        if ( !(IsNumberInUnicodeList(
                   ReplicaConnDataDefinition.ReplicaConnObjectType
                       .ObjectNameTitleIndex, lpValueName)) ) {
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            return ERROR_SUCCESS;
        }
    }

    //
    // The assumption here is that *lppData is aligned on a 8 byte boundary.
    // If its not, then some object in front of us messed up.
    //
    pReplicaConnDataDefinition = (REPLICACONN_DATA_DEFINITION *) *lppData;

    //
    // Check if the buffer space is sufficient
    //
    SpaceNeeded = (ULONG) ReplicaConnDataDefinition.ReplicaConnObjectType.TotalByteLength;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        //
        // Buffer space is insufficient
        //
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the Object Type and counter definitions to the callers buffer
    //
    memmove (pReplicaConnDataDefinition,
             &ReplicaConnDataDefinition,
             sizeof(REPLICACONN_DATA_DEFINITION));

    //
    // Check if the Object has any instances
    //
    if (FRC_datapackage != NULL) {

        //
        // Bind the RPC handle
        //
        if (FRC_BindTheRpcHandle(&Handle) != ERROR_SUCCESS) {
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRC_Cl, NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN);
            return ERROR_SUCCESS;
        }

        //
        // Zero the contents of the data buffer.
        //
        ZeroMemory(FRC_collectpakg->databuff->data, FRC_collectpakg->databuff->size);

        //
        // Get the counter data from the server
        //
        try {
            WStatus = GetCounterDataOfInstancesFromServer(Handle, FRC_collectpakg);
        } except (EXCEPTION_EXECUTE_HANDLER) {
              GET_EXCEPTION_CODE(WStatus);
        }
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            WStatus = RpcBindingFree(&Handle);
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRC_Cl, NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN);
            return ERROR_SUCCESS;
        }

        vd = FRC_collectpakg->databuff->data;
        p1 = (PERF_INSTANCE_DEFINITION *)&pReplicaConnDataDefinition[1];

        //
        // Format the data and copy it into the callers buffer
        //
        for (j = 0; j < FRC_collectpakg->numofinst; j++) {
            DWORD RoundedLen;
            //
            // Name length rounded to the next 8 byte boundary.
            //
            RoundedLen = (((((1 +
                     wcslen(FRC_datapackage->instnames->InstanceNames[j].name))
                     * sizeof(WCHAR)) + 7) >> 3) << 3) + CSIZEOFDWORD;
            //
            // Set the Instance definition structure
            //
            p1->ByteLength = sizeof (PERF_INSTANCE_DEFINITION) + RoundedLen;
            p1->ParentObjectTitleIndex = 0;
            p1->ParentObjectInstance = 0;
            p1->UniqueID = PERF_NO_UNIQUE_ID;
            p1->NameOffset = sizeof (PERF_INSTANCE_DEFINITION);
            p1->NameLength = (1 +
                     wcslen(FRC_datapackage->instnames->InstanceNames[j].name))
                     * sizeof(WCHAR);
            //
            // Set the instance name
            //
            name = (PWCHAR) (&p1[1]);
            wcscpy(name, FRC_datapackage->instnames->InstanceNames[j].name);
            //
            // Set the PERF_COUNTER_BLOCK structure
            //
            pPerfCounterBlock = (PERF_COUNTER_BLOCK *)
                                (name + (RoundedLen/sizeof(WCHAR)));
            pPerfCounterBlock->ByteLength = SizeOfReplicaConnPerformanceData;
            //
            // Finally set the counter data. Pad 8 bytes to have 8 byte
            // alignment.
            //
            bte = ((PBYTE) (&pPerfCounterBlock[1]));
            CopyMemory (bte, vd, SIZEOF_REPCONN_COUNTER_DATA);
            vd += SIZEOF_REPCONN_COUNTER_DATA;
            bte += SIZEOF_REPCONN_COUNTER_DATA;
            p1 = (PERF_INSTANCE_DEFINITION *) bte;
        }
        //
        // Update the arguments for return
        //
        *lpNumObjectTypes = REPLICACONN_NUM_PERF_OBJECT_TYPES;
        *lppData = (PVOID) p1;
        //
        // Set the totalbytes being returned.
        //
        *lpcbTotalBytes = (DWORD)((PBYTE) p1 - (PBYTE) pReplicaConnDataDefinition);
        WStatus = RpcBindingFree(&Handle);
        FRC_Cl = TRUE;
        return ERROR_SUCCESS;
    }

    else {
        //
        // No instances as of now, so fill zeros for the counter data
        //
        pPerfCounterBlock = (PERF_COUNTER_BLOCK *)
                            (((PBYTE)&pReplicaConnDataDefinition[1]) +
                             CSIZEOFDWORD);
        pPerfCounterBlock->ByteLength = SizeOfReplicaConnPerformanceData;
        bte = ((PBYTE) (&pPerfCounterBlock[1]));
        ZeroMemory (bte, SIZEOF_REPCONN_COUNTER_DATA);
        bte += SIZEOF_REPCONN_COUNTER_DATA;
        *lppData = (PVOID) bte;
        *lpNumObjectTypes = REPLICACONN_NUM_PERF_OBJECT_TYPES;
        *lpcbTotalBytes =
                     (DWORD)((PBYTE) bte - (PBYTE) pReplicaConnDataDefinition);
        FRC_Cl = TRUE;
        return ERROR_SUCCESS;
    }
}



DWORD APIENTRY
CloseReplicaConnPerformanceData (
    VOID
    )

/*++

Routine Description:

   This routine decrements the open count and frees up the memory allocated by
   the Open and Collect routines if needed.

Arguments:

   none.

Return Value:

   ERROR_SUCCESS - Success

--*/

{
    EnterCriticalSection(&FRC_ThrdCounter);
    //
    // Check to see if the open count is zero. This should never happen but
    // just in case.
    //
    if (FRC_dwOpenCount == 0) {
        LeaveCriticalSection(&FRC_ThrdCounter);
        return ERROR_SUCCESS;
    }
    //
    // Decrement the Open count.
    //
    FRC_dwOpenCount--;
    //
    // If the open count becomes zero, free up the memory since no more threads
    // are going to collect data.
    //
    if (FRC_dwOpenCount == 0) {
        //
        // Call the routine that frees up the memory.
        //
        FreeReplicaConnData();
        LeaveCriticalSection(&FRC_ThrdCounter);
    } else {
        LeaveCriticalSection(&FRC_ThrdCounter);
    }
    return ERROR_SUCCESS;
}

VOID
FreeReplicaConnData(
    VOID
    )
/*++

Routine Description:

    This routine frees up the memory allocated by the Open and Collect routines.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    LONG j;

    //
    // Free up the Datapackage strucutre.
    //
    if (FRC_datapackage != NULL) {
        if (FRC_datapackage->ver != NULL) {
            free(FRC_datapackage->ver);
        }
        if (FRC_datapackage->indices != NULL) {
            if (FRC_datapackage->indices->index != NULL) {
                free(FRC_datapackage->indices->index);
            }
            free(FRC_datapackage->indices);
        }
        if (FRC_datapackage->instnames != NULL) {
            if (FRC_datapackage->instnames->InstanceNames != NULL) {
                for (j = 0; j < FRC_datapackage->numofinst; j++) {
                    if (FRC_datapackage->instnames->InstanceNames[j].name != NULL) {
                        free(FRC_datapackage->instnames->InstanceNames[j].name);
                    }
                }
                free(FRC_datapackage->instnames->InstanceNames);
            }
            free(FRC_datapackage->instnames);
        }
        free(FRC_datapackage);
        FRC_datapackage = NULL;
    }

    //
    // Free up the collect package structure.
    //
    if (FRC_collectpakg != NULL) {
        if (FRC_collectpakg->indices != NULL) {
            if (FRC_collectpakg->indices->index != NULL) {
                free(FRC_collectpakg->indices->index);
            }
            free(FRC_collectpakg->indices);
        }
        if (FRC_collectpakg->databuff != NULL) {
            if (FRC_collectpakg->databuff->data != NULL) {
                free(FRC_collectpakg->databuff->data);
            }
            free(FRC_collectpakg->databuff);
        }
        free(FRC_collectpakg);
        FRC_collectpakg = NULL;
    }
}


DWORD
FRC_BindTheRpcHandle (
    OUT handle_t *OutHandle
    )

/*++

Routine Description:

    This routine binds the RPC handle to the local server

Arguments:

    OutHandle: Handle to be bound

Return Value:

    ERROR_SUCCESS - Success

--*/

{
    PWCHAR LocalComputerName, BindingString;
    DWORD NameLen, WStatus = ERROR_SUCCESS;
    handle_t Handle;
    PWCHAR PrincName = NULL;
    DWORD WStatus1;

    //
    // Get the name of the local computer
    //
    NameLen = MAX_COMPUTERNAME_LENGTH + 2;
    LocalComputerName = (PWCHAR) FRSPerfAlloc (NameLen * sizeof(WCHAR));
    if (LocalComputerName == NULL) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }
    if (!GetComputerNameW(LocalComputerName, &NameLen)) {
        WStatus = GetLastError();
        free(LocalComputerName);
        return WStatus;
    }

    //
    // Create the binding string. Since we are always
    // calling the local computer bind using local rpc.
    // Server side of perfmon denies all calls that do not
    // come over local rpc (ncalrpc).
    //
    WStatus = RpcStringBindingComposeW(NULL, L"ncalrpc", LocalComputerName,
                                      NULL, NULL, &BindingString);
    if (WStatus != RPC_S_OK) {
        goto CLEANUP;
    }

    //
    // Store the binding in the handle
    //
    WStatus = RpcBindingFromStringBindingW(BindingString, &Handle);
    if (WStatus != RPC_S_OK) {
        goto CLEANUP;
    }

    //
    // Resolve the handle to a dynamic end point
    //
    WStatus = RpcEpResolveBinding(Handle, PerfFrs_ClientIfHandle);
    if (WStatus != RPC_S_OK) {
        WStatus1 = RpcBindingFree(&Handle);
        goto CLEANUP;
    }

    //
    // Find the principle name
    //
    WStatus = RpcMgmtInqServerPrincName(Handle,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        &PrincName);
    if (WStatus != RPC_S_OK) {
        WStatus1 = RpcBindingFree(&Handle);
        goto CLEANUP;
    }
    //
    // Set authentication info. LocalRPC only works with
    // NTLM.
    //
    WStatus = RpcBindingSetAuthInfo(Handle,
                                    PrincName,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NONE);
    if (WStatus != RPC_S_OK) {
        WStatus1 = RpcBindingFree(&Handle);
        goto CLEANUP;
    }

    //
    // Success
    //
    *OutHandle = Handle;

CLEANUP:

    free(LocalComputerName);
    RpcStringFreeW(&BindingString);

    if (PrincName) {
        RpcStringFreeW(&PrincName);
    }

    return WStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perffrs_c_stub.c ===
#include "perffrs_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perfmain.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfmain.c

Abstract:

    This file contains the DllMain function for the NTFRSPRF.dll.

Author:

    Rohan Kumar          [rohank]   15-Feb-1999

Environment:

    User Mode Service

Revision History:


--*/

//
// The common header file which leads to the definition of the CRITICAL_SECTION
// data structure and declares the globals FRS_ThrdCounter and FRC_ThrdCounter.
//
#include <perrepsr.h>


//
// If InitializeCriticalSectionAndSpinCount returns an error, set the global boolean
// (below) to FALSE.
//
BOOLEAN ShouldPerfmonCollectData = TRUE;

BOOLEAN FRS_ThrdCounter_Initialized = FALSE;
BOOLEAN FRC_ThrdCounter_Initialized = FALSE;


HANDLE  hEventLog;
//BOOLEAN DoLogging = TRUE;
//
// Default to no Event Log reporting.
//
DWORD   PerfEventLogLevel = WINPERF_LOG_NONE;

#define NTFRSPERF   L"SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\NTFRSPerf"
#define EVENTLOGDLL L"%SystemRoot%\\System32\\ntfrsres.dll"
#define PERFLIB_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"



BOOL
WINAPI
DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID fImpLoad
    )
/*++

Routine Description:

    The DllMain routine for the NTFRSPRF.dll.

Arguments:

    hinstDLL - Instance handle of the DLL.
    fdwReason - The reason for this function to be called by the system.
    fImpLoad - Indicated whether the DLL was implicitly or explicitly loaded.

Return Value:

    TRUE.

--*/
{
    DWORD flag, WStatus;
    DWORD size, type;
    DWORD TypesSupported = 7; // Types of EventLog messages supported.
    HKEY  Key = INVALID_HANDLE_VALUE;

    switch(fdwReason) {
    case DLL_PROCESS_ATTACH:
        //
        // THe DLL is being mapped into the process's address space. When this
        // happens, initialize the CRITICAL_SECTION objects being used for
        // synchronization. InitializeCriticalSectionAndSpinCount returns
        // an error in low memory condition.
        //
        if(!InitializeCriticalSectionAndSpinCount(&FRS_ThrdCounter,
                                                        NTFRS_CRITSEC_SPIN_COUNT)) {
            ShouldPerfmonCollectData = FALSE;
            return(TRUE);
        }

	FRS_ThrdCounter_Initialized = TRUE;

        if(!InitializeCriticalSectionAndSpinCount(&FRC_ThrdCounter,
                                                        NTFRS_CRITSEC_SPIN_COUNT)) {
            ShouldPerfmonCollectData = FALSE;
            return(TRUE);
        }

	FRC_ThrdCounter_Initialized = TRUE;


        //
        // Create/Open a Key under the Application key for logging purposes.
        // Even if we fail, we return TRUE. EventLogging is not critically important.
        // Returning FALSE will cause the process loading this DLL to terminate.
        //
        WStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  NTFRSPERF,
                                  0L,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &Key,
                                  &flag);
        if (WStatus != ERROR_SUCCESS) {
            //DoLogging = FALSE;
            break;
        }

        //
        // Set the values EventMessageFile and TypesSupported. Return value is
        // intentionally not checked (see above).
        //
        WStatus = RegSetValueEx(Key,
                                L"EventMessageFile",
                                0L,
                                REG_EXPAND_SZ,
                                (BYTE *)EVENTLOGDLL,
                                (1 + wcslen(EVENTLOGDLL)) * sizeof(WCHAR));
        if (WStatus != ERROR_SUCCESS) {
            //DoLogging = FALSE;
            FRS_REG_CLOSE(Key);
            break;
        }
        WStatus = RegSetValueEx(Key,
                                L"TypesSupported",
                                0L,
                                REG_DWORD,
                                (BYTE *)&TypesSupported,
                                sizeof(DWORD));
        if (WStatus != ERROR_SUCCESS) {
            //DoLogging = FALSE;
            FRS_REG_CLOSE(Key);
            break;
        }
        //
        // Close the key
        //
        FRS_REG_CLOSE(Key);

        //
        // Get the handle used to report errors in the event log. Return value
        // is intentionally not checked (see above).
        //
        hEventLog = RegisterEventSource((LPCTSTR)NULL, (LPCTSTR)L"NTFRSPerf");
        if (hEventLog == NULL) {
            //DoLogging = FALSE;
            break;
        }


        //
        // Read the Perflib Event log level from the registry.
        //   "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\EventLogLevel"
        //
        WStatus = RegOpenKey(HKEY_LOCAL_MACHINE, PERFLIB_KEY, &Key);
        if (WStatus != ERROR_SUCCESS) {
            //DoLogging = FALSE;
            break;
        }

        size = sizeof(DWORD);
        WStatus = RegQueryValueEx (Key,
                                   L"EventLogLevel",
                                   0L,
                                   &type,
                                   (LPBYTE)&PerfEventLogLevel,
                                   &size);
        if (WStatus != ERROR_SUCCESS || type != REG_DWORD) {
            //DoLogging = FALSE;
            PerfEventLogLevel = WINPERF_LOG_NONE;
            FRS_REG_CLOSE(Key);
            break;
        }

        FRS_REG_CLOSE(Key);
        break;

    case DLL_THREAD_ATTACH:
        //
        // A thread is being created. Nothing to do.
        //
        break;

    case DLL_THREAD_DETACH:
        //
        // A thread is exiting cleanly. Nothing to do.
        //
        break;

    case DLL_PROCESS_DETACH:
        //
        // The DLL is being unmapped from the process's address space. Free up
        // the resources.
        //
        if (FRS_ThrdCounter_Initialized) {
            DeleteCriticalSection(&FRS_ThrdCounter);
        }
        
	if (FRC_ThrdCounter_Initialized) {
            DeleteCriticalSection(&FRC_ThrdCounter);
        }

        if (hEventLog) {
            DeregisterEventSource(hEventLog);
        }

        break;

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perfset.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    perfset.c

Abstract:

    This file contains the functions that implement the PerformanceDLL of the
    REPLICASET Object.

Author:

    Rohan Kumar          [rohank]   13-Sept-1998

Environment:

    User Mode Service


Revision History:


--*/

#include "REPSET.h"
#include "perfutil.h"
#include "NTFRSREP.h"

//
// Future Cleanup: Really need a struct to encapsulate this state so the same code
//                 can be used for both the replica set and connection perfmon objects

//
// Should Perfmon return Data ? This boolean is set in the DllMain function.
//
extern BOOLEAN ShouldPerfmonCollectData;

//
// Data Variable definition
//
REPLICASET_DATA_DEFINITION ReplicaSetDataDefinition;

//
// Extern variable definition
//
extern ReplicaSetValues RepSetInitData[FRS_NUMOFCOUNTERS];

//
// Sum of counter sizes + SIZEOFDWORD
//
DWORD SizeOfReplicaSetPerformanceData = 0;

//
// Number of "Open" threads
//
DWORD FRS_dwOpenCount = 0;

//
// Data structure used by the Open RPC Call
//
OpenRpcData *FRS_datapackage = NULL;

//
// Data structure used by the Collect RPC Call
//
CollectRpcData *FRS_collectpakg = NULL;

//
// Used to filter duplicate eventlog messages.
//
BOOLEAN FRS_Op = TRUE, FRS_Cl = TRUE;

//
// Signatures of functions implemented in this file
//

PM_OPEN_PROC OpenReplicaSetPerformanceData; // The Open function
PM_COLLECT_PROC CollectReplicaSetPerformanceData; // The Collect function
PM_CLOSE_PROC CloseReplicaSetPerformanceData; // The Close function
VOID FreeReplicaSetData(); // Frees the allocated memory
PVOID FRSPerfAlloc(IN DWORD Size); // Allocates memory

#undef GET_EXCEPTION_CODE
#define GET_EXCEPTION_CODE(_x_)                                                \
{                                                                              \
    (_x_) = GetExceptionCode();                                                \
    if (((LONG)(_x_)) < 0) {                                                   \
        (_x_) = FRS_ERR_INTERNAL_API;                                          \
    }                                                                          \
    /* NTFRSAPI_DBG_PRINT2("Exception caught: %d, 0x%08x\n", (_x_), (_x_)); */ \
}

DWORD
FRC_BindTheRpcHandle (
    OUT handle_t *OutHandle
    );




DWORD
InitializeObjectData (
    DWORD                       ObjectLength,
    DWORD                       ObjectNameTitleIndex,
    DWORD                       NumCounters,
    PFRS_PERF_DATA_DEFINITION   FrsPerfDataDef,
    PFRS_PERF_INIT_VALUES       FrsInitValueDef,
    DWORD                       SizeOfCounterData
    )

/*++

Routine Description:

    This routine initializes the ReplicaSetDataDefinition data structure.

Arguments:

    ObjectLength,         - size of Counter Structure returned by the perfmon Object
    ObjectNameTitleIndex, - Index for object Title and help strings.
    NumCounters,          - The number of perfmon data counters for the object.
    FrsPerfDataDef,       - Counter Structure returned by the perfmon Object
    FrsInitValueDef,      - Init structure used to provide counter type, size and offset.
    SizeOfCounterData     - The FRS internal struct used to hold the counter data for the object.


Return Value:

    Returns total size of the counter data types.

--*/

{
    DWORD i, j;
    PPERF_OBJECT_TYPE        PerfObject;
    PPERF_COUNTER_DEFINITION CounterDef;

    //
    // Initialization of ReplicaSetObjectType (PERF_OBJECT_TYPE) field. This structure
    // is defined in the file winperf.h
    //
    PerfObject = &FrsPerfDataDef->ObjectType;

    PerfObject->TotalByteLength      = ObjectLength;
    PerfObject->DefinitionLength     = ObjectLength;
    PerfObject->HeaderLength         = sizeof(PERF_OBJECT_TYPE);
    PerfObject->ObjectNameTitleIndex = ObjectNameTitleIndex;
    PerfObject->ObjectNameTitle      = 0;
    PerfObject->ObjectHelpTitleIndex = ObjectNameTitleIndex;
    PerfObject->ObjectHelpTitle      = 0;
    PerfObject->DetailLevel          = PERF_DETAIL_NOVICE;
    PerfObject->NumCounters          = NumCounters;
    PerfObject->DefaultCounter       = 0;
    PerfObject->NumInstances         = PERF_NO_INSTANCES;
    PerfObject->CodePage             = 0;

    //
    // Initialization of NumStat (PERF_COUNTER_DEFINITION) structures.
    //
    for (i = 0, j = 2; i < NumCounters; i++, j += 2) {
        CounterDef = &FrsPerfDataDef->NumStat[i];

        CounterDef->ByteLength            = sizeof(PERF_COUNTER_DEFINITION);
        CounterDef->CounterNameTitleIndex = j;
        CounterDef->CounterNameTitle      = 0;
        CounterDef->CounterHelpTitleIndex = j;
        CounterDef->CounterHelpTitle      = 0;
        CounterDef->DefaultScale          = 0;
        CounterDef->DetailLevel           = PERF_DETAIL_NOVICE;
        CounterDef->CounterType           = FrsInitValueDef[i].counterType;
        CounterDef->CounterSize           = FrsInitValueDef[i].size;
        CounterDef->CounterOffset         = FrsInitValueDef[i].offset + sizeof(DWORD);
    }

    //
    // Return the total size of the counter data types
    //
    return SizeOfCounterData + sizeof(DWORD);
}



DWORD APIENTRY
OpenReplicaSetPerformanceData (
    IN LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine does the following:

    1. Sets up the data structures (field values of structures used by PERFMON)
       used for collecting the counter data.

    2. Gets the numerical indices for Instance names from the server using RPC.

Arguments:

    lpDeviceNames - Pointer to the Instance list

Return Value:

    ERROR_SUCCESS - The Initialization was successful OR
    Appropriate DWORD value for the Error status

--*/

{
    LONG WStatus, tot = 0, i;
    HKEY hKeyDriverPerf = INVALID_HANDLE_VALUE;
    DWORD size, type;
    DWORD dwFirstCounter, dwFirstHelp; // To store the first counter and first help values

    //
    // Additions for instances
    //
    size_t len;
    PWCHAR p, q;
    INT j, namelen = 0;
    handle_t Handle;
    PPERF_COUNTER_DEFINITION CounterDef;

    //
    // If InitializeCriticalSectionAndSpinCount returned an error, no point
    // in continuing. Open always has to return success.
    //
    if (!ShouldPerfmonCollectData) {
        return ERROR_SUCCESS;
    }

    //
    // Keep track of the number of times open has been called. The Registry
    // routines will limit the access to the initialization routine to only
    // on thread at a time, so synchronization should not be a problem. The
    // FRS_ThrdCounter is used to synchronize between this (Open) and the Close
    // functions.
    //
    EnterCriticalSection(&FRS_ThrdCounter);
    if (FRS_dwOpenCount != 0) {
        //
        // Increment the FRS_dwOpenCount counter which counts the number of
        // times Open has been called.
        //
        FRS_dwOpenCount++;
        LeaveCriticalSection(&FRS_ThrdCounter);
        return ERROR_SUCCESS;
    }
    LeaveCriticalSection(&FRS_ThrdCounter);

    //
    // Perform some preliminary checks.
    //
    if (FRS_collectpakg != NULL || FRS_datapackage != NULL) {
        //
        // We seem to have failed (in the last call) in the middle of this
        // Open function. Also the open count is zero which means we
        // haven't yet succeeded a open.
        // Free up resources and return.
        //
        FreeReplicaSetData();
        return ERROR_SUCCESS;
    }

    //
    // Do the necessary initialization of the PERFMON data structures
    //
    SizeOfReplicaSetPerformanceData = InitializeObjectData(
                                           sizeof(REPLICASET_DATA_DEFINITION),
                                           OBJREPLICASET,
                                           FRS_NUMOFCOUNTERS,
                                           (PFRS_PERF_DATA_DEFINITION) &ReplicaSetDataDefinition,
                                           (PFRS_PERF_INIT_VALUES) RepSetInitData,
                                           SIZEOF_REPSET_COUNTER_DATA);

    WStatus = ERROR_SUCCESS;
    type = REG_DWORD;
    try {

        //
        // Get the counter and help index base values from the registry. Open key
        // to registry entry, read the First Counter and First Help values. Update
        // the static data structures by adding base to offset value in the structure
        //
        WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Performance",
                                0L,
                                KEY_READ,
                                &hKeyDriverPerf);
        if (WStatus != ERROR_SUCCESS) {
            __leave;
        }

        size = sizeof(DWORD);
        WStatus = RegQueryValueEx (hKeyDriverPerf,
                                   L"First Counter",
                                   0L,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size);
        if (WStatus != ERROR_SUCCESS || type != REG_DWORD) {
            __leave;
        }

        size = sizeof(DWORD);
        WStatus = RegQueryValueEx (hKeyDriverPerf,
                                   L"First Help",
                                   0L,
                                   &type,
                                   (LPBYTE)&dwFirstHelp,
                                   &size);
        if (WStatus != ERROR_SUCCESS || type != REG_DWORD) {
            __leave;
        }

    }  except (EXCEPTION_EXECUTE_HANDLER) {
       //
       // Exception
       //
       WStatus = GetExceptionCode();
    }


    if (WStatus == ERROR_SUCCESS && type != REG_DWORD) {
        WStatus = ERROR_INVALID_PARAMETER;
    }

    if (WStatus != ERROR_SUCCESS) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        FRS_REG_CLOSE(hKeyDriverPerf);
        FilterAndPrintToEventLog(WINPERF_LOG_USER, FRS_Op, NTFRSPRF_REGISTRY_ERROR_SET);
        // Open function always returns ERROR_SUCCESS.
        return ERROR_SUCCESS;
    }

    //
    // Add the offsets to the name and help fields
    //
    ReplicaSetDataDefinition.ReplicaSetObjectType.ObjectNameTitleIndex += dwFirstCounter;
    ReplicaSetDataDefinition.ReplicaSetObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    for (i = 0; i < FRS_NUMOFCOUNTERS; i++) {
        CounterDef = &ReplicaSetDataDefinition.NumStat[i];
        CounterDef->CounterNameTitleIndex += dwFirstCounter;
        CounterDef->CounterHelpTitleIndex += dwFirstHelp;
    }


    //
    // Check if there are any instances. If there are, parse and set them in a structure
    // to be sent to the server to get the indices for the instance names. These indices
    // are used in the collect function to get the data
    //
    if (lpDeviceNames != NULL) {
        //
        // yes, there are
        //
        q = (PWCHAR) lpDeviceNames;
        //
        // Calculate the number of instances
        //
        while (TRUE) {
            tot++;
            p = wcschr(q, L'\0');
            if (*(p + 1) == L'\0') {
                break;
            }
            q = p + 1;
        }

        //
        // Bind the RPC handle
        //
        if ( (WStatus = FRC_BindTheRpcHandle(&Handle)) != ERROR_SUCCESS) {
            //
            // Service may be stopped.
            // return success.
            //
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRS_Op, NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET);
            return ERROR_SUCCESS;
        }

        //
        // Set the data structure to be sent to the server using RPC
        //
        FRS_datapackage = (OpenRpcData *) FRSPerfAlloc (sizeof(OpenRpcData));
        NTFRS_MALLOC_TEST(FRS_datapackage, FreeReplicaSetData(), FALSE);
        FRS_datapackage->majorver = MAJORVERSION;
        FRS_datapackage->minorver = MINORVERSION;
        FRS_datapackage->ObjectType = REPSET;
        FRS_datapackage->numofinst = tot;
        FRS_datapackage->ver = (PLONG) FRSPerfAlloc (sizeof(LONG));
        NTFRS_MALLOC_TEST(FRS_datapackage->ver, FreeReplicaSetData(), FALSE);
        FRS_datapackage->indices = (inst_index *) FRSPerfAlloc (sizeof(inst_index));
        NTFRS_MALLOC_TEST(FRS_datapackage->indices, FreeReplicaSetData(), FALSE);
        FRS_datapackage->indices->size = tot;
        FRS_datapackage->indices->index = (PLONG) FRSPerfAlloc (FRS_datapackage->numofinst * sizeof(LONG));
        NTFRS_MALLOC_TEST(FRS_datapackage->indices->index, FreeReplicaSetData(), FALSE);
        FRS_datapackage->instnames = (InstanceNames *) FRSPerfAlloc (sizeof(InstanceNames));
        NTFRS_MALLOC_TEST(FRS_datapackage->instnames, FreeReplicaSetData(), FALSE);
        FRS_datapackage->instnames->size = tot;
        FRS_datapackage->instnames->InstanceNames = (inst_name *) FRSPerfAlloc (tot * sizeof(inst_name));
        NTFRS_MALLOC_TEST(FRS_datapackage->instnames->InstanceNames, FreeReplicaSetData(), FALSE);
        //
        // Copy the instance names and set the corresponding size value used by RPC
        //
        q = (PWCHAR) lpDeviceNames;
        for (j = 0; j < FRS_datapackage->numofinst; j++) {
            p = wcschr(q, L'\0');
            len = wcslen (q);
            FRS_datapackage->instnames->InstanceNames[j].size = len + 1;
            FRS_datapackage->instnames->InstanceNames[j].name =
                                    (PWCHAR) FRSPerfAlloc ((len + 1) * sizeof(WCHAR));
            NTFRS_MALLOC_TEST(FRS_datapackage->instnames->InstanceNames[j].name, FreeReplicaSetData(), FALSE);
            wcscpy(FRS_datapackage->instnames->InstanceNames[j].name, q);

            //
            // Calculte the total length of all the instance names
            // The extra 1 is for the '\0' character. The names are rounded
            // upto the next 8 byte boundary.
            //
            namelen += (((((len + 1) * sizeof(WCHAR)) + 7) >> 3) << 3);
            q = p + 1;
        }

        //
        // Set the totalbytelength and NumInstances fields of the PERF_OBJECT_TYPE Data structure,
        // now that we know the number of instances and the length of their names
        //
        ReplicaSetDataDefinition.ReplicaSetObjectType.TotalByteLength +=
            namelen +
            FRS_datapackage->numofinst *
                (SizeOfReplicaSetPerformanceData + SSIZEOFDWORD +
                 sizeof(PERF_INSTANCE_DEFINITION));

        ReplicaSetDataDefinition.ReplicaSetObjectType.NumInstances =
            FRS_datapackage->numofinst;

        //
        // (RP)Call the server to set the indices of the instance names
        //
        try {
            WStatus = GetIndicesOfInstancesFromServer(Handle, FRS_datapackage);
        } except (EXCEPTION_EXECUTE_HANDLER) {
              GET_EXCEPTION_CODE(WStatus);
        }

        if (!WIN_SUCCESS(WStatus)) {
            //
            // RPC error trying to contact service.
            // Free up the memory and return success.
            //
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRS_Op, NTFRSPRF_OPEN_RPC_CALL_ERROR_SET);
            RpcBindingFree(&Handle);
            FreeReplicaSetData();
            return ERROR_SUCCESS;
        }

        //
        // Set the data structure used by the RPC call in the Collect function
        //
        FRS_collectpakg = (CollectRpcData *) FRSPerfAlloc (sizeof(CollectRpcData));
        NTFRS_MALLOC_TEST(FRS_collectpakg, FreeReplicaSetData(), TRUE);
        FRS_collectpakg->majorver = MAJORVERSION;
        FRS_collectpakg->minorver = MINORVERSION;
        FRS_collectpakg->ObjectType = REPSET;
        FRS_collectpakg->ver = *(FRS_datapackage->ver);
        FRS_collectpakg->numofinst = FRS_datapackage->numofinst;
        FRS_collectpakg->numofcotrs = FRS_NUMOFCOUNTERS;
        FRS_collectpakg->indices = (inst_index *) FRSPerfAlloc (sizeof(inst_index));
        NTFRS_MALLOC_TEST(FRS_collectpakg->indices, FreeReplicaSetData(), TRUE);
        FRS_collectpakg->indices->size = FRS_datapackage->indices->size;
        FRS_collectpakg->indices->index = (PLONG) FRSPerfAlloc (FRS_collectpakg->indices->size * sizeof(LONG));
        NTFRS_MALLOC_TEST(FRS_collectpakg->indices->index, FreeReplicaSetData(), TRUE);
        //
        // Copy the indices got from the server
        //
        for (j = 0; j < FRS_collectpakg->numofinst; j++) {
            FRS_collectpakg->indices->index[j]= FRS_datapackage->indices->index[j];
        }
        //
        // Set the memory blob used to (mem)copy the counter dats from the server
        //
        FRS_collectpakg->databuff = (DataBuffer *) FRSPerfAlloc (sizeof(DataBuffer));
        NTFRS_MALLOC_TEST(FRS_collectpakg->databuff, FreeReplicaSetData(), TRUE);
        FRS_collectpakg->databuff->size = FRS_collectpakg->numofinst *
                                          SIZEOF_REPSET_COUNTER_DATA;

        //
        // Allocate memory for the buffer in which the data gets copied.
        //
        FRS_collectpakg->databuff->data = (PBYTE) FRSPerfAlloc (FRS_collectpakg->databuff->size * sizeof(BYTE));
        NTFRS_MALLOC_TEST(FRS_collectpakg->databuff->data, FreeReplicaSetData(), TRUE);

        RpcBindingFree(&Handle);

    } else {
        //
        // There are no instances at this time, so set the PERF_OBJECT_TYPE structure fields accordingly
        //
        ReplicaSetDataDefinition.ReplicaSetObjectType.TotalByteLength +=
                              SizeOfReplicaSetPerformanceData + SSIZEOFDWORD;
        ReplicaSetDataDefinition.ReplicaSetObjectType.NumInstances =
                                                            PERF_NO_INSTANCES;
    }

    EnterCriticalSection(&FRS_ThrdCounter);
    FRS_dwOpenCount++; // increment the open counter
    LeaveCriticalSection(&FRS_ThrdCounter);

    FRS_Op = TRUE;
    return ERROR_SUCCESS;

}



DWORD APIENTRY
CollectReplicaSetPerformanceData (
    IN     LPWSTR lpValueName,
    IN OUT LPVOID *lppData,
    IN OUT LPDWORD lpcbTotalBytes,
    IN OUT LPDWORD lpNumObjectTypes
    )

/*++

Routine Description:

    This routine collects the counter data from the server and copies it into
    the callers buffer.

Arguments:

    lpValueName - Wide character string passed by the registry.
    lppData - IN: pointer to the address of the buffer to receive the
                  completed PerfDataBlock and the subordinate structures.
                  This routine will append its data to the buffer starting
                  at the point referenced by *lppData.
              OUT: Points to the first byte after the data structure added
                   by this routine.
    lpcbTotalBytes - IN: The address of the DWORD that tells the size in bytes
                        of the buffer referenced by the lppData argument
                    OUT: The number of bytes added by this routine is written
                         to the DWORD pointed to by this argument.
    lpNumObjectTypes - IN: The address of the DWORD to receive the number of
                          Objects added by this routine       .
                      OUT: The number of Objects added by this routine is written
                           to the buffer pointed by this argument.
Return Value:

    ERROR_MORE_DATA - The buffer passed was too small.
    ERROR_SUCCESS - Success or any other error

--*/

{
    //
    // Variables for reformatting data to be sent to perfmon
    //
    ULONG               SpaceNeeded;
    PBYTE               bte, vd;
    PDWORD              pdwCounter;
    DWORD               dwQueryType;
    LONG                j, k;
    PWCHAR              name;
    DWORD               WStatus;
    LPWSTR              lpDeviceNames = NULL;
    HKEY                hKeyDriverPerf = INVALID_HANDLE_VALUE;
    DWORD               size, type;
    PERF_COUNTER_BLOCK  *pPerfCounterBlock;

    PERF_INSTANCE_DEFINITION   *p1;
    REPLICASET_DATA_DEFINITION *pReplicaSetDataDefinition;

    //
    // RPC Additions
    //
    handle_t Handle;

    //
    // Check to see that all the pointers that are passed in are fine
    //
    if (lppData == NULL || *lppData == NULL || lpcbTotalBytes == NULL ||
        lpValueName == NULL || lpNumObjectTypes == NULL) {
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        return ERROR_SUCCESS;
    }

    //
    // Check to see if Open went OK.
    // If not then call then attempt to
    // make the open call here.
    //
    EnterCriticalSection(&FRS_ThrdCounter);
    if (FRS_dwOpenCount == 0) {
        LeaveCriticalSection(&FRS_ThrdCounter);

        try {
            //
            // Get the Export value from the Linkage key
            // SYSTEM\CurrentControlSet\Services\FileReplicaSet\Linkage
            //
            WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Linkage",
                                    0L,
                                    KEY_READ,
                                    &hKeyDriverPerf);
            if (WStatus != ERROR_SUCCESS) {
                __leave;
            }

            size = 1;
            lpDeviceNames = FRSPerfAlloc(size);
            WStatus = RegQueryValueEx (hKeyDriverPerf,
                                       L"Export",
                                       0L,
                                       &type,
                                       (LPBYTE)lpDeviceNames,
                                       &size);

            if (WStatus == ERROR_MORE_DATA) {
                free(lpDeviceNames);
                lpDeviceNames = FRSPerfAlloc(size);
                if (lpDeviceNames == NULL) {
                    WStatus = ERROR_NO_SYSTEM_RESOURCES;
                    __leave;
                }
                WStatus = RegQueryValueEx (hKeyDriverPerf,
                                           L"Export",
                                           0L,
                                           &type,
                                           (LPBYTE)lpDeviceNames,
                                           &size);
            }

        }  except (EXCEPTION_EXECUTE_HANDLER) {
           //
           // Exception
           //
           WStatus = GetExceptionCode();
        }

        FRS_REG_CLOSE(hKeyDriverPerf);

        if (WStatus != ERROR_SUCCESS || type != REG_MULTI_SZ) {
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            if (lpDeviceNames != NULL) {
                free(lpDeviceNames);
            }
            return ERROR_SUCCESS;
        }

        if (lpDeviceNames != NULL) {
            WStatus = OpenReplicaSetPerformanceData(lpDeviceNames);
            free(lpDeviceNames);
        }
    } else {
        LeaveCriticalSection(&FRS_ThrdCounter);
    }

    //
    // Check to see if Open went OK.
    //
    EnterCriticalSection(&FRS_ThrdCounter);
    if (FRS_dwOpenCount == 0) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        LeaveCriticalSection(&FRS_ThrdCounter);
        //
        // Fatal error. No point in continuing.
        //
        return ERROR_SUCCESS;
    }
    LeaveCriticalSection(&FRS_ThrdCounter);

    //
    // Check the query type
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        //
        // Fatal error. No point in continuing.  Clean up and exit.
        //
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS) {
        if ( !(IsNumberInUnicodeList(ReplicaSetDataDefinition.ReplicaSetObjectType
                                   .ObjectNameTitleIndex, lpValueName)) ) {
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            return ERROR_SUCCESS;
        }
    }

    //
    // The assumption here is that *lppData is aligned on a 8 byte boundary.
    // If its not, then some object in front of us messed up.
    //
    pReplicaSetDataDefinition = (REPLICASET_DATA_DEFINITION *) *lppData;

    //
    // Check if the buffer space is sufficient
    //
    SpaceNeeded = (ULONG) ReplicaSetDataDefinition.ReplicaSetObjectType.TotalByteLength;

    //
    // Check if the buffer space is sufficient
    //
    if ( *lpcbTotalBytes < SpaceNeeded ) {
        //
        // Buffer space is insufficient
        //
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the Object Type and counter definitions to the callers buffer
    //
    memmove (pReplicaSetDataDefinition, &ReplicaSetDataDefinition, sizeof(REPLICASET_DATA_DEFINITION));

    //
    // Check if the Object has any instances
    //
    if (FRS_datapackage != NULL) {

        //
        // Bind the RPC handle
        //
        if (FRC_BindTheRpcHandle(&Handle) != ERROR_SUCCESS) {
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRS_Cl, NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET);
            return ERROR_SUCCESS;
        }

        //
        // Zero the contents of the data buffer.
        //
        ZeroMemory(FRS_collectpakg->databuff->data, FRS_collectpakg->databuff->size);

        //
        // (RP) Call to get the counter data from the server
        //
        try {
            WStatus = GetCounterDataOfInstancesFromServer(Handle, FRS_collectpakg);
        } except (EXCEPTION_EXECUTE_HANDLER) {
              GET_EXCEPTION_CODE(WStatus);
        }

        if (!WIN_SUCCESS(WStatus)) {
            //
            // Fatal error. No point in continuing.  Clean up and exit.
            //
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;
            RpcBindingFree(&Handle);
            FilterAndPrintToEventLog(WINPERF_LOG_DEBUG, FRS_Cl, NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET);
            return ERROR_SUCCESS;
        }

        vd = FRS_collectpakg->databuff->data;
        p1 = (PERF_INSTANCE_DEFINITION *)&pReplicaSetDataDefinition[1];

        //
        // Format the data and copy it into the callers buffer
        //
        for (j = 0; j < FRS_collectpakg->numofinst; j++) {
            DWORD RoundedLen;
            //
            // Name length rounded to the next 8 byte boundary.
            //
            RoundedLen = (((((1 +
                     wcslen(FRS_datapackage->instnames->InstanceNames[j].name))
                     * sizeof(WCHAR)) + 7) >> 3) << 3) + SSIZEOFDWORD;
            //
            // Set the Instance definition structure
            //
            p1->ByteLength = sizeof (PERF_INSTANCE_DEFINITION) + RoundedLen;
            p1->ParentObjectTitleIndex = 0;
            p1->ParentObjectInstance = 0;
            p1->UniqueID = PERF_NO_UNIQUE_ID;
            p1->NameOffset = sizeof (PERF_INSTANCE_DEFINITION);
            p1->NameLength = (1 +
                     wcslen(FRS_datapackage->instnames->InstanceNames[j].name))
                     * sizeof(WCHAR);
            //
            // Set the instance name
            //
            name = (PWCHAR) (&p1[1]);
            wcscpy(name, FRS_datapackage->instnames->InstanceNames[j].name);
            //
            // Set the PERF_COUNTER_BLOCK structure
            //
            pPerfCounterBlock = (PERF_COUNTER_BLOCK *)
                                (name + (RoundedLen/sizeof(WCHAR)));
            pPerfCounterBlock->ByteLength = SizeOfReplicaSetPerformanceData;
            //
            // Finally set the counter data
            //
            bte = ((PBYTE) (&pPerfCounterBlock[1]));
            CopyMemory (bte, vd, SIZEOF_REPSET_COUNTER_DATA);
            vd += SIZEOF_REPSET_COUNTER_DATA;
            bte += SIZEOF_REPSET_COUNTER_DATA;
            p1 = (PERF_INSTANCE_DEFINITION *) bte;
        }
        //
        // Update the arguments for return
        //
        *lpNumObjectTypes = REPLICASET_NUM_PERF_OBJECT_TYPES;
        *lppData = (PVOID) p1;
        //
        // Set the totalbytes being returned.
        //
        *lpcbTotalBytes = (DWORD)((PBYTE) p1 - (PBYTE) pReplicaSetDataDefinition);
        RpcBindingFree(&Handle);
        FRS_Cl = TRUE;
        return ERROR_SUCCESS;
    }

    else {
        //
        // No instances as of now, so fill zeros for the counter data
        //
        pPerfCounterBlock = (PERF_COUNTER_BLOCK *)
                            (((PBYTE)&pReplicaSetDataDefinition[1]) +
                             SSIZEOFDWORD);
        pPerfCounterBlock->ByteLength = SizeOfReplicaSetPerformanceData;
        bte = ((PBYTE) (&pPerfCounterBlock[1]));
        ZeroMemory (bte, SIZEOF_REPSET_COUNTER_DATA);
        bte += SIZEOF_REPSET_COUNTER_DATA;
        *lppData = (PVOID) bte;
        *lpNumObjectTypes = REPLICASET_NUM_PERF_OBJECT_TYPES;
        *lpcbTotalBytes =
                      (DWORD)((PBYTE) bte - (PBYTE) pReplicaSetDataDefinition);
        FRS_Cl = TRUE;
        return ERROR_SUCCESS;
    }
}



DWORD APIENTRY
CloseReplicaSetPerformanceData (
    VOID
    )

/*++

Routine Description:

    This routine decrements the open count and frees up the memory allocated by
    the Open and Collect routines if needed.

Arguments:

    none.

Return Value:

    ERROR_SUCCESS - Success

--*/

{
    EnterCriticalSection(&FRS_ThrdCounter);
    //
    // Check to see if the open count is zero. This should never happen but
    // just in case.
    //
    if (FRS_dwOpenCount == 0) {
        LeaveCriticalSection(&FRS_ThrdCounter);
        return ERROR_SUCCESS;
    }
    //
    // Decrement the Open count.
    //
    FRS_dwOpenCount--;
    //
    // If the open count becomes zero, free up the memory since no more threads
    // are going to collect data.
    //
    if (FRS_dwOpenCount == 0) {
        //
        // Call the routine that frees up the memory.
        //
        FreeReplicaSetData();
        LeaveCriticalSection(&FRS_ThrdCounter);
    } else {
        LeaveCriticalSection(&FRS_ThrdCounter);
    }
    return ERROR_SUCCESS;
}


VOID
FreeReplicaSetData(
    VOID
    )
/*++

Routine Description:

    This routine frees up the memory allocated by the Open and Collect routines.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    LONG j;

    //
    // Free up the Datapackage strucutre.
    //
    if (FRS_datapackage != NULL) {
        if (FRS_datapackage->ver != NULL) {
            free(FRS_datapackage->ver);
        }
        if (FRS_datapackage->indices != NULL) {
            if (FRS_datapackage->indices->index != NULL) {
                free(FRS_datapackage->indices->index);
            }
            free(FRS_datapackage->indices);
        }
        if (FRS_datapackage->instnames != NULL) {
            if (FRS_datapackage->instnames->InstanceNames != NULL) {
                for (j = 0; j < FRS_datapackage->numofinst; j++) {
                    if (FRS_datapackage->instnames->InstanceNames[j].name != NULL) {
                        free(FRS_datapackage->instnames->InstanceNames[j].name);
                    }
                }
                free(FRS_datapackage->instnames->InstanceNames);
            }
            free(FRS_datapackage->instnames);
        }
        free(FRS_datapackage);
        FRS_datapackage = NULL;
    }

    //
    // Free up the collect package structure.
    //
    if (FRS_collectpakg != NULL) {
        if (FRS_collectpakg->indices != NULL) {
            if (FRS_collectpakg->indices->index != NULL) {
                free(FRS_collectpakg->indices->index);
            }
            free(FRS_collectpakg->indices);
        }
        if (FRS_collectpakg->databuff != NULL) {
            if (FRS_collectpakg->databuff->data != NULL) {
                free(FRS_collectpakg->databuff->data);
            }
            free(FRS_collectpakg->databuff);
        }
        free(FRS_collectpakg);
        FRS_collectpakg = NULL;
    }
}

PVOID
FRSPerfAlloc(
    IN DWORD Size
    )
/*++
Routine Description:

        Allocate memory and fill it with zeros before returning the pointer.

Arguments:

        Size - Size of the memory request in bytes.

Return Value:

        Pointer to the allocated memory or NULL if memory wasn't available.
--*/
{
    PVOID Node;

    if (Size == 0) {
        return NULL;
    }

    Node = (PVOID) malloc (Size);
    if (Node == NULL) {
        return NULL;
    }

    ZeroMemory(Node, Size);
    return Node;
}

//
// Functions (for memory handling) used by the client stub
//
void *
midl_user_allocate
         (
          size
          )
size_t size;
{
    unsigned char *ptr;
    ptr = malloc (size);
    return ( (void *)ptr );
}

void
midl_user_free
         (
          object
          )
void * object;
{
    free (object);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perfutil.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file defines some functions used by the routines in PerformanceDLL.

Environment:

    User Mode Service

Revision History:


--*/


//#include <windows.h>
//#include <string.h>
#include <perrepsr.h>

#include "perfutil.h"

// Global Data Definitions
#define GLOBAL_STRING  L"Global"
#define FOREIGN_STRING L"Foreign"
#define COSTLY_STRING  L"Costly"
#define NULL_STRING    L"\0"

// Test for delimiter, EOL and non-digit characters
// used by IsNumberInUnicodeList routine
#define DIGIT 1
#define DELIMITER 2
#define INVALID 3

#define EvalThisChar(c,d) ( \
      (c == d) ? DELIMITER : \
      (c == 0) ? DELIMITER : \
      (c < (WCHAR) '0') ? INVALID : \
      (c > (WCHAR) '9') ? INVALID : \
       DIGIT)


DWORD
GetQueryType (
         IN LPWSTR lpValue
         )
/*++

Routine Description:

    Returns the type of query described in lpValue string so that the appropriate
    processing method may be used.

Arguments:

    lpValue - string describing the query type

Return Value:

   QUERY_GLOBAL - "Global" string
   QUERY_FOREIGN - "Foreign" string
   QUERY_COSTLY - "Costly" string
   QUERY_ITEMS - otherwise

--*/

{

   if ((lpValue == NULL) || (*lpValue == 0)) {
      return QUERY_GLOBAL;

   // Check for Global
   }else if (!wcscmp(lpValue, GLOBAL_STRING)) {
       return QUERY_GLOBAL;

   // Check for Foreign
   }else if (!wcscmp(lpValue, FOREIGN_STRING)) {
       return QUERY_FOREIGN;

   // Check for Costly
   }else if (!wcscmp(lpValue, COSTLY_STRING)) {
       return QUERY_COSTLY;
   }

   // If its not Global, nor Foreign and nor Costly, then it must be an Item list.
   return QUERY_ITEMS;
}

BOOL
IsNumberInUnicodeList (
               IN DWORD dwNumber,
               IN LPWSTR lpwszUnicodeList
               )
/*++

Routine Description:

    Checks if an item (dwNumber) is a part of a list (lpwszUnicodeList).

Arguments:

    dwNumber - Number to be found in the list
    lpwszUnicodeList - Null terminated, space delimited list of decimal numbers

Return Value:

    TRUE - The number was found
    FALSE - The number was not found

--*/

{

   DWORD dwThisNumber;
   WCHAR *pwcThisChar, wcDelimiter;
   BOOL bValidNumber, bNewItem, bReturnValue;

   if (lpwszUnicodeList == 0) { // null pointer, # not found
      return FALSE;
   }

   pwcThisChar = lpwszUnicodeList;
   dwThisNumber = 0;
   wcDelimiter = (WCHAR)' ';
   bValidNumber = FALSE;
   bNewItem = TRUE;

   while (TRUE) {
      switch ( EvalThisChar (*pwcThisChar, wcDelimiter) ) {
      case DIGIT:
               // If this is the first digit after a delimiter,
               // then set flags to start computing a new number
                   if (bNewItem) {
                      bNewItem = FALSE;
              bValidNumber = TRUE;
                   }
                   if (bValidNumber) {
              dwThisNumber *= 10;
              dwThisNumber += (*pwcThisChar - (WCHAR)'0');
           }
           break;
      case DELIMITER:
              // A delimiter is either a delimiter character or an
                  // end of string ('\0') if when the delimiter has been reached
                  // a valid number was found, then compare it to the number from
                  // the argument list. If this is the end of the string and no
                  // match was found, then return.
                  if (bValidNumber) {
                         if (dwThisNumber == dwNumber) {
                return TRUE;
             }
             bValidNumber = FALSE;
                      }
                      if (*pwcThisChar == 0) {
             return FALSE;
              } else {
             bNewItem = TRUE;
             dwThisNumber = 0;
              }
              break;
       case INVALID:
             // If an invalid number was encountered, ignore all
             // characters upto the next delimiter and start fresh.
             // The invalid number is not compared.
             bValidNumber = FALSE;
                  break;
       default: break;
      }
      pwcThisChar++;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\repconn.h ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSCON.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	REPCONN.h

Abstract

	This is the header file for the REPLICACONN Object data definition.
	It contains definitions to construct the dynamic data which is returned
	by the Configuration Registry.

Environment:

	User Mode Service

Revision History:

--*/


#ifndef _REPCONN_H_
#define _REPCONN_H_

#include <perrepsr.h>   // The counter structures header file
#include <perffrs.h>    // The RPC generated header file
#include <winperf.h>    // The PERFMON header file

//
// Number of objects being monitored
//
#define REPLICACONN_NUM_PERF_OBJECT_TYPES 1

//
// Size of DWORD
//
#define CSIZEOFDWORD sizeof(DWORD)

//
// Number of ReplicaConn Counters
//
#define FRC_NUMOFCOUNTERS 24

//
// Flag bit defs
//
#define PM_RS_FLAG_SVC_WIDE      0x00000001

//
// Structure which is used in the Open function Initialization
//
typedef struct _REPLICACONN_VALUES {
	PWCHAR name;       // name of the counter
	DWORD size;        // size of the counter type
	DWORD offset;      // offset of the counter in the structure
	DWORD counterType; // Type of (PERFMON) counter
	DWORD Flags;       // Flags. see def above.
} ReplicaConnValues;

//
// Counter Structure returned by the REPLICACONN Object
//
typedef struct _REPLICACONN_DATA_DEFINITION {
	PERF_OBJECT_TYPE ReplicaConnObjectType;          // ReplicaConn Object
	PERF_COUNTER_DEFINITION NumStat[FRC_NUMOFCOUNTERS]; // The array of PERF_COUNTER_DEFINITION structures
} REPLICACONN_DATA_DEFINITION;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\perfutil.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    The header file that defines the constants and variables used in
    the functions defined in the file perfutil.c

Environment:

    User Mode Service

Revision History:


--*/

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

#define QUERY_GLOBAL 1
#define QUERY_ITEMS 2
#define QUERY_FOREIGN 3
#define QUERY_COSTLY 4

// Signatures of functions implemented in perfutil.c
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);



//
// Counter Structure returned by the Object
//
typedef struct _FRS_PERF_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ObjectType;         // ReplicaConn or Replica Set Object
    PERF_COUNTER_DEFINITION NumStat[1];         // The array of PERF_COUNTER_DEFINITION structures
} FRS_PERF_DATA_DEFINITION, *PFRS_PERF_DATA_DEFINITION;


//
// Structure used in the Open function Initialization to set counter
// counter type, size and offset.
//
//
typedef struct _FRS_PERF_INIT_VALUES {
    PWCHAR name;                           // name of the counter
    DWORD size;                            // size of the counter type
    DWORD offset;                          // offset of the counter in the structure
    DWORD counterType;                     // Type of (PERFMON) counter
    DWORD Flags;                           // Flags. see def above.
} FRS_PERF_INIT_VALUES, *PFRS_PERF_INIT_VALUES;



DWORD
InitializeObjectData (
    DWORD                       ObjectLength,
    DWORD                       ObjectNameTitleIndex,
    DWORD                       NumCounters,
    PFRS_PERF_DATA_DEFINITION   FrsPerfDataDef,
    PFRS_PERF_INIT_VALUES       FrsInitValueDef,
    DWORD                       SizeOfCounterData
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfmon\perffrs_s_stub.c ===
#include "perffrs_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfmon\perrepsr.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    perrepsr.c

Abstract:

    This file defines the server side of PERFMON support and contains the following :

    1. Functions used to initialize the registry keys used by PERFMON.

    2. Functions that are used by the File Replication Service
       to add and delete Object Instances (PERFMON) from the Registry
       and the hash tables (the basic hashing routines used here are
       defined in the file util\qhash.c).

    3. Functions to create and use the hash tables which store data of
       the instance counters measured by PERFMON.

    4. RPC server functions used by the performance dll (client) to collect
       data and send it to the PERFMON app.

Author:

    Rohan Kumar          [rohank]   13-Sept-1998

    David Orbits         [Davidor}  6/Oct/98 - Revised.  Changed nameing,
                         changed registry query, eliminated mallocs, closed
                         key handle leak, Moved priv funcs out of common
                         header, general cleanup.

Environment:

    User Mode Service

Revision History:


--*/


//
// Included below are the header file that contain the definition
// of data structures used in the functions in this file. The header
// file "perffrs.h" defines the RPC interface and is generated at compile
// time by the build utility.
//
#include <perrepsr.h>
#include <perffrs.h>

#include "..\perfdll\repset.h"

//
// FRS_UniqueID and FRC_UniqueID are the Keys used to
// hash in the counter data structures into the hash tables
// for the Objects FILEREPLICASET and FILEREPLICACONN. They
// are unique for every instance of the Objects.
//
ULONGLONG FRS_UniqueID = 1;
ULONGLONG  FRC_UniqueID = 1;

//
// The critical section object is used for acheiving mutual exclusion
// when adding or deleting instances (the UniqueID variable has to be safe)
//
CRITICAL_SECTION *PerfmonLock = NULL;

#define AcquirePerfmonLock    EnterCriticalSection (PerfmonLock);

#define ReleasePerfmonLock    LeaveCriticalSection (PerfmonLock);

//
// Hash Table definitions
//
PQHASH_TABLE HTReplicaSet, HTReplicaConn;

HANDLE PerfmonProcessSemaphore = INVALID_HANDLE_VALUE;

//
// The Context data structure used by the hash table enumeration routines
//
typedef struct _CONTEXT_DATA {
    PWCHAR name;        // name of the Instance
    ULONGLONG KeyValue; // Key value of the Instance
    ULONG OBJType;      // Object Type of the Instance
} ContextData, *PContextData;

#define MAX_CMD_LINE 256

extern ReplicaSetValues RepSetInitData[FRS_NUMOFCOUNTERS];

#undef GET_EXCEPTION_CODE
#define GET_EXCEPTION_CODE(_x_)                                                \
{                                                                              \
    (_x_) = GetExceptionCode();                                                \
    if (((LONG)(_x_)) < 0) {                                                   \
        (_x_) = FRS_ERR_INTERNAL_API;                                          \
    }                                                                          \
    /* NTFRSAPI_DBG_PRINT2("Exception caught: %d, 0x%08x\n", (_x_), (_x_)); */ \
}

//
// The Total Instance
//
PHT_REPLICA_SET_DATA PMTotalInst = NULL;

//
// Internal functions
//

LONG
PmInitPerfmonRegistryKeys(
    VOID
    );

LONG
PmInitializeRegistry (
    DWORD
    );

ULONGLONG
PmFindTheKeyValue(
    PContextData
    );

VOID
PmSetTheCOCounters(
    PHT_REPLICA_SET_DATA
    );

DWORD
PmHashFunction(
    PVOID,
    ULONG
    );

DWORD
PmSearchTable(
    PQHASH_TABLE,
    PQHASH_ENTRY,
    PQHASH_ENTRY,
    PVOID
    );


VOID
InitializePerfmonServer (
    VOID
    )

/*++

Routine Description:

    This routine inits the perfmon server for NTFRS.

    It inits the crit sect for the PerfmonLock variable

    It creates the hash tables of the specified size to store
    Instance counter values for the Objects. It also assigns the hash function
    to be used with each created table.

    It inits the perfmon registry keys.

Arguments:

    none

Return Value:

    none

--*/

{
#undef DEBSUB
#define DEBSUB "InitializePerfmonServer:"

    ULONG WStatus;

    //
    // Use a semaphore to ensure that only one process provides perfmon data.
    // A unique semaphore is only needed in test setup when we want
    // to run multiple copies of FRS on one machine and only want
    // one of the copies to register the perfmon interface.
    // 
    if (RunningAsAService) {
        PerfmonProcessSemaphore = CreateSemaphoreW(NULL,
                                                   0,
                                                   0x7fffffff,
                                                   NULL);
    }else{
        PerfmonProcessSemaphore = CreateSemaphoreW(NULL,
                                                   0,
                                                   0x7fffffff,
                                                   L"NTFRS_Sempahore_");
    }
        WStatus = GetLastError();
        if (!HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
            PerfmonProcessSemaphore = INVALID_HANDLE_VALUE;
            DPRINT_WS(0,"CreateSemaphore returned", WStatus);
            return;
        }

        if (WIN_ALREADY_EXISTS(WStatus)) {
            FRS_CLOSE(PerfmonProcessSemaphore);
            DPRINT(0,"PerfmonProcessSemaphore already exists\n");
            return;
        }

    //
    // Allocate memory for the lock
    //
    PerfmonLock = (CRITICAL_SECTION *) FrsAlloc (sizeof(CRITICAL_SECTION));

    //
    // Initialize the critical section object
    //
    INITIALIZE_CRITICAL_SECTION(PerfmonLock);

    //
    // create the hash tables and assign the hash functions.  One table
    // for replica set objects and one for connection objects.
    //
    HTReplicaSet = FrsAllocTypeSize(QHASH_TABLE_TYPE, HASHTABLESIZE);
    SET_QHASH_TABLE_HASH_CALC(HTReplicaSet, PmHashFunction);

    HTReplicaConn = FrsAllocTypeSize(QHASH_TABLE_TYPE, HASHTABLESIZE);
    SET_QHASH_TABLE_HASH_CALC(HTReplicaConn, PmHashFunction);
}



VOID
ShutdownPerfmonServer (
    VOID
    )

/*++

Routine Description:

    This routine is called by the application just before it ends

Arguments:

    none

Return Value:

    none

--*/

{
#undef DEBSUB
#define DEBSUB "ShutdownPerfmonServer:"

    if (HANDLE_IS_VALID(PerfmonProcessSemaphore)) {

        if (PerfmonLock != NULL) {

            //
            // Delete the critical section object & Free the allocated memory
            //
            DeleteCriticalSection (PerfmonLock);
            PerfmonLock = FrsFree (PerfmonLock);
        }

        //
        // Free the hash tables.
        //
        HTReplicaSet = FrsFreeType (HTReplicaSet);
        HTReplicaConn = FrsFreeType (HTReplicaConn);

        //
        // Close the semaphore handle.
        //
        FRS_CLOSE(PerfmonProcessSemaphore);
    }
}



DWORD
PmHashFunction (
    IN PVOID Qkey,
    IN ULONG len
    )

/*++

Routine Description:

    This is the hashing function used by the functions that Lookup,
    Add or Delete entries from the Hash Tables. The Key is a 64 bit
    number and the hashing function casts it to a 32 bit number and
    returns it as the hash value.

Arguments:

    QKey - Pointer to the Key to be hashed.
    len - Length of QKey (unused here).

Return Value:

    The hashed value of the Key.

--*/

{
#undef DEBSUB
#define DEBSUB "PmHashFunction:"

    DWORD key; // hashed key value to be returned
    PULONGLONG p; // hash the key to PULONGLONG
    p = (PULONGLONG)Qkey;
    key = (DWORD)*p;
    return (key);
}





ULONG
PmSearchTable (
    IN PQHASH_TABLE Table,
    IN PQHASH_ENTRY BeforeNode,
    IN PQHASH_ENTRY TargetNode,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called by the QHashEnumerateTable function and is used
    to add context to the enumeration. Here, we go through the table till
    a node containing a specified instance (name contained in the context structure)
    is reached.

Arguments:

    Table - The hash table to be searched.
    BeforeNode - The node previous to the target node in the hash table(unused).
    AfterNode - The node which is being examined.
    Context - A structure containing the name to be matched and key value to be set.

Return Value:
    FrsErrorFoundKey - Key mapping the name was found
    FrsErrorSuccess - Key was not found

--*/

{
#undef DEBSUB
#define DEBSUB "PmSearchTable:"

    PContextData contxt;
    PWCHAR InstanceName;
    PHT_REPLICA_SET_DATA p;
    PHT_REPLICA_CONN_DATA q;

    //
    // The context is of the type pointer to ContextData datastructure
    //
    contxt = (PContextData) Context;
    InstanceName = (PWCHAR) contxt->name;

    DPRINT1(5, "PERFMON: InstanceName: %ws\n", InstanceName);
    DPRINT1(5, "PERFMON:   TargetNode: %08x\n", TargetNode);
    DPRINT1(5, "PERFMON:   TargetNode->qDATA: %08X %08x\n",
            PRINTQUAD(TargetNode->QData));


    //
    // The Object Type is either REPLICASET or REPLICACONN
    //
    if (contxt->OBJType == REPLICASET) {
        //
        // Its a REPLICASET Object
        //
        p = (PHT_REPLICA_SET_DATA)(TargetNode->QData);
        DPRINT1(5, "PERFMON:   p: %08x\n", p);
        DPRINT1(5, "PERFMON:   p->oid: %08x\n", p->oid);
        DPRINT1(5, "PERFMON:   p->oid->name: %08x\n", p->oid->name);
        DPRINT1(5, "PERFMON:   p->oid->name: %ws\n", p->oid->name);
        DPRINT1(5, "PERFMON:   p->oid->key: %08x %08x\n", PRINTQUAD(p->oid->key));
        //
        // Check to see if the names are the same
        //
        if ( (wcscmp(InstanceName, p->oid->name)) == 0) {
            //
            // Check to see if the names are the same
            //
            contxt->KeyValue = p->oid->key;
            DPRINT(5, "PERFMON:   FOUND\n");
            return FrsErrorFoundKey;
        }
        else
            return FrsErrorSuccess; // Continue enumerating through the list of nodes
    }
    else {
        //
        // Its a REPLICACONN Object.
        //
        q = (PHT_REPLICA_CONN_DATA)(TargetNode->QData);
        DPRINT1(5, "PERFMON:   q: %08x\n", q);
        DPRINT1(5, "PERFMON:   q->oid: %08x\n", q->oid);
        DPRINT1(5, "PERFMON:   q->oid->name: %08x\n", q->oid->name);
        DPRINT1(5, "PERFMON:   q->oid->name: %ws\n", q->oid->name);
        DPRINT1(5, "PERFMON:   q->oid->key: %08x %08x\n", PRINTQUAD(q->oid->key));

        if ( (wcscmp(InstanceName, q->oid->name)) == 0) {
            contxt->KeyValue = q->oid->key;
            DPRINT(5, "PERFMON:   FOUND\n");
            return FrsErrorFoundKey;
        }
        else
            return FrsErrorSuccess;
    }
}



LONG
PmInitPerfmonRegistryKeys (
    VOID
    )

/*++

Routine Description:

    This routine is the called by the ntfrs application to Initialize the
    appropriate Keys and Values of the PERFMON Objects in the Registry.
    It calls the PmInitializeRegistry routine (described below) on the Objects.
    It also adds the total instance to the REPLICASET Object.

Arguments:

    none

Return Value:
    ERROR_SUCCESS - The Initialization was successful OR
    Appropriate DWORD value for the Error status

--*/

{
#undef DEBSUB
#define DEBSUB  "PmInitPerfmonRegistryKeys:"

    LONG WStatus = ERROR_SUCCESS;
    enum object ObjType;


    //
    // Initialize the REPLICASET Object
    //
    ObjType = REPLICASET;
    WStatus = PmInitializeRegistry(ObjType);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "Error: PmInitializeRegistry(L\"FileReplicaSet\")\n");
        return WStatus;
    }

    //
    // Initialize the REPLICACONN Object
    //
    ObjType = REPLICACONN;
    WStatus = PmInitializeRegistry(ObjType);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "Error: PmInitializeRegistry(L\"FileReplicaConn\")\n");
        return WStatus;
    }

    //
    // Set the fields of the total instance
    //
    PMTotalInst = (PHT_REPLICA_SET_DATA) FrsAlloc (sizeof(HT_REPLICA_SET_DATA));
    PMTotalInst->RepBackPtr = NULL;

    //
    // Add it to the REPLICASET Hash table
    //
    WStatus = AddPerfmonInstance(REPLICASET, PMTotalInst, TOTAL_NAME);

    return WStatus;
}



LONG
PmInitializeRegistry (
    IN DWORD ObjectType
    )

/*++

Routine Description:

    This routine is the called by the PmInitPerfmonRegistryKeys function
    to Initialize the appropriate Keys and Values of the Object (ObjectType)
    in the Registry.

Arguments:

    ObjectType - The Object whose Keys and Values have to be Initialized

Return Value:

    ERROR_SUCCESS - The Initialization of the Object was successful OR
    Appropriate DWORD value for the Error status

--*/

{
#undef DEBSUB
#define DEBSUB  "PmInitializeRegistry:"

    ULONG WStatus = ERROR_SUCCESS;
    ULONG WStatus1;
    DWORD size, flag;
    HKEY key = INVALID_HANDLE_VALUE;
    PWCHAR ObjSubKey, PerfSubKey, LinSubKey, OpFn, ClFn, CollFn, iniflCmd, iniflApp, unldCmd, unldApp;
    WCHAR CommandLine[MAX_CMD_LINE];
    DWORD type;
    DWORD CounterVersion = 0;
    DWORD Temp;
    BOOL UnloadCounters = FALSE;
    BOOL LoadCounters = FALSE;

    //
    // Set all the parameters used in the function depending upon the Type of Object
    //
    if ( ObjectType == REPLICASET ) {
        //
        // The Keys to be set in the registry
        //
        ObjSubKey = REPSETOBJSUBKEY;
        PerfSubKey = REPSETPERFSUBKEY;
        LinSubKey = REPSETLINSUBKEY;
        //
        // The Open function (called by PERFMON when it starts up) of REPLICASET
        //
        OpFn = REPSETOPENFN;
        //
        // The Close function (called by PERFMON when it closes) of REPLICASET
        //
        ClFn = REPSETCLOSEFN;
        //
        // The Collect function (called by PERFMON to collect data) of REPLICASET
        //
        CollFn = REPSETCOLLECTFN;
        //
        // The lodctr utility to add the counter values
        //
        iniflApp = LDCTRAPP;
        iniflCmd = REPSETINI;
        //
        // The unlodctr utility to remove the counter values
        //
        unldApp = UNLDCTRAPP;
        unldCmd = REPSETUNLD;
    } else {
        //
        // Similar settings for the REPLICACONN Object
        //
        ObjSubKey = REPCONNOBJSUBKEY;
        PerfSubKey = REPCONNPERFSUBKEY;
        LinSubKey = REPCONNLINSUBKEY;
        OpFn = REPCONNOPENFN;
        ClFn = REPCONNCLOSEFN;
        CollFn = REPCONNCOLLECTFN;
        iniflApp = LDCTRAPP;
        iniflCmd = REPCONNINI;
        unldApp = UNLDCTRAPP;
        unldCmd = REPCONNUNLD;
    }

    //
    // Create a key for the Object under the Sevices Key in the Registry. If the Key
    // already exists, its opened.
    //
    WStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              ObjSubKey,
                              0L,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &key,
                              &flag);
    CLEANUP_WS(0, "Error: RegCreateKeyEx.", WStatus, CLEANUP2);
    size = sizeof(DWORD);
    WStatus = RegQueryValueEx(key, L"Counter Version", NULL, &type, (PUCHAR)&CounterVersion, &size);
    if (!WIN_SUCCESS(WStatus) || (type != REG_DWORD) ||
        CounterVersion != NtFrsPerfCounterVer) {

        UnloadCounters = TRUE;
        LoadCounters = TRUE;
    }
    FRS_REG_CLOSE(key);

    //
    // Create a key called Performance under the Object's Key (created above) in the Registry
    //
    WStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              PerfSubKey,
                              0L,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &key,
                              &flag);
    CLEANUP_WS(0, "Error: RegCreateKeyEx.", WStatus, CLEANUP2);

    //
    // If its a newly created Performance key, we need to set some Values to it.
    // If it is a newly created performance key then we need to load the counters.
    //
    if (flag == REG_CREATED_NEW_KEY) {
        size = ((1 + wcslen(PERFDLLDIRECTORY)) * (sizeof(WCHAR)));
        WStatus = RegSetValueEx (key, L"Library", 0L, REG_EXPAND_SZ,
                                 (BYTE *)PERFDLLDIRECTORY, size);
        CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);

        size = (1 + wcslen(OpFn)) * (sizeof(WCHAR));
        WStatus = RegSetValueEx (key, L"Open", 0L, REG_SZ, (BYTE *)OpFn, size);
        CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);

        size = (1 + wcslen(ClFn)) * (sizeof(WCHAR));
        WStatus = RegSetValueEx (key, L"Close", 0L, REG_SZ, (BYTE *)ClFn, size);
        CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);

        size = (1 + wcslen(CollFn)) * (sizeof(WCHAR));
        WStatus = RegSetValueEx (key, L"Collect", 0L, REG_SZ, (BYTE *)CollFn, size);
        CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);

        //
        // The performance subkey is newly created. We only need
        // to load counters as they are new.
        //
        UnloadCounters = FALSE;
        LoadCounters = TRUE;

    } else {

        //
        // The performance key exists. If this key exists then
        // the counters are probably loaded. If someone has
        // manually unloaded the counters by calling unloadctr from
        // command line then the counters may be unloaded.
        // Look for the FirstCounter/FirstHelp/LastCounter/LastHelp 
        // values. If they don't exist then the counters are not
        // loaded. Mark them to be loaded.
        //
        size = sizeof(DWORD);
        WStatus = RegQueryValueEx(key, L"First Counter", NULL, &type, (PUCHAR)&Temp, &size);
        if (!WIN_SUCCESS(WStatus) || (type != REG_DWORD)){
            // counters are not loaded.
            LoadCounters = TRUE;
        }

    }

    FRS_REG_CLOSE(key);

    if (UnloadCounters == TRUE) {
        //
        // Run unlodctr command on the application incase counters have changed
        // Copy the command line because CreateProcess() wants to be able to
        // write into it.  Sigh.
        //
        wcscpy(CommandLine, unldCmd);
        DPRINT1(1,"Running: %ws\n", CommandLine);
        WStatus = FrsRunProcess(unldApp,
                                CommandLine,
                                INVALID_HANDLE_VALUE,
                                INVALID_HANDLE_VALUE,
                                INVALID_HANDLE_VALUE);
        //
        // If the unloadctr above failed then don't execute loadctr.
        // This avoids the registry from getting corrupted.
        //
        DPRINT1_WS(0, "Error Running %ws;", CommandLine, WStatus);
    }

    if (LoadCounters == TRUE ) {
        //
        // Run the lodctr command on the .ini file of the Object
        // Copy the command line because CreateProcess() wants to be able to
        // write into it. Sigh.
        //
        WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ObjSubKey, 0, KEY_ALL_ACCESS, &key);
        CLEANUP_WS(0, "Error: RegOpenKeyEx.", WStatus, CLEANUP2);

        wcscpy(CommandLine, iniflCmd);
        DPRINT1(1,"Running: %ws\n", CommandLine);
        WStatus = FrsRunProcess(iniflApp,
                                CommandLine,
                                INVALID_HANDLE_VALUE,
                                INVALID_HANDLE_VALUE,
                                INVALID_HANDLE_VALUE);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // If there was an error loading the counters then set
            // the "Counter Version" value to 0 so we try to
            // load the counters the next time.
            //
            CounterVersion = 0;
            WStatus = RegSetValueEx(key, L"Counter Version", 0, REG_DWORD, (PCHAR)&CounterVersion, sizeof(DWORD));
            CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);
            DPRINT1_WS(0, "Error Running %ws;", CommandLine, WStatus);
            goto CLEANUP;
        }

        //
        // If the counters are loaded correctly then update the 
        // "Counter Version" so we don't load them again next
        // time.
        //
        WStatus = RegSetValueEx(key, L"Counter Version", 0, REG_DWORD, (PCHAR)&NtFrsPerfCounterVer, sizeof(DWORD));
        CLEANUP_WS(0, "Error: RegSetValueEx.", WStatus, CLEANUP);
        FRS_REG_CLOSE(key);
    }
    //
    // Create a key called Linkage under the Object's Key (created above) in the Registry
    //
    WStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              LinSubKey,
                              0L,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &key,
                              &flag);
    CLEANUP_WS(0, "Error: RegCreateKeyEx. (LINKAGE)", WStatus, CLEANUP2);

    //
    // Create the Export Value (for instances of Objects) under Linkage
    // Its set to NULL when the ntfrs applicationis started and the
    // Instances are added as they get created by the application
    //
    WStatus = RegSetValueEx (key, L"Export", 0L, REG_MULTI_SZ, NULL, 0);
    CLEANUP_WS(0, "Error: RegSetValueEx Export.", WStatus, CLEANUP);

CLEANUP:

    FRS_REG_CLOSE(key);

CLEANUP2:
    //
    // If the Initialization was successful, return ERROR_SUCCESS
    //
    return WStatus;
}



ULONG
AddPerfmonInstance (
    IN DWORD ObjectType,
    IN PVOID addr,
    IN PWCHAR InstanceName
    )

/*++

Routine Description:

    This routine is called by the ntfrs application to add an Instance of
    a particular Object Type to the Registry and the Hash Table.

Arguments:

    ObjectType - The Object whose instance has to be added
    addr - The data structure for the Instance Counters stored in Hash Table
    InstanceName - The instance name of the object.

Return Value:

    ERROR_SUCCESS - The Initialization of the Object was successful OR
    Appropriate DWORD value for the Error status

--*/

{
#undef DEBSUB
#define DEBSUB  "AddPerfmonInstance:"

    BOOL flag = TRUE;
    BOOL HaveKey = FALSE;
    ULONG WStatus = ERROR_SUCCESS;
    ULONG WStatus1;
    ULONG GStatus;
    DWORD Type, size, len, totallen;
    HKEY key = INVALID_HANDLE_VALUE;
    PWCHAR SubKey, p, r, s;
    PWCHAR NewExport = NULL;
    PWCHAR ValueData = NULL;
    PHT_REPLICA_SET_DATA rsdata;
    PHT_REPLICA_CONN_DATA rcdata;
    PQHASH_TABLE HashTable;
    PULONGLONG   QKey;
    PULONGLONG   QData;

    PPERFMON_OBJECT_ID PmOid;

    //
    // Addition must be mutually exclusive
    // Check is its safe to enter before going ahead
    //
    if (!HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
        return ERROR_SUCCESS;
    }

    //
    // Alloc the perfmon object ID struct and the space for the instance name.
    //
    PmOid = (PPERFMON_OBJECT_ID) FrsAlloc (sizeof(PERFMON_OBJECT_ID));
    PmOid->name = FrsAlloc((wcslen(InstanceName)+1) * sizeof(WCHAR));
    wcscpy(PmOid->name, InstanceName);

    AcquirePerfmonLock;

    //
    // set up params based on object type.  Alloc storage for OID and name.
    //
    if ( ObjectType == REPLICASET ) {
        //
        //    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Linkage"
        //
        SubKey = REPSETLINSUBKEY;
        rsdata = (PHT_REPLICA_SET_DATA) addr;

        if (rsdata->oid != NULL) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        rsdata->oid = PmOid;

        HashTable = HTReplicaSet;
        QKey = &(rsdata->oid->key);
        QData = (PULONGLONG)&(rsdata);
    } else {
        //
        //    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Linkage"
        //
        SubKey = REPCONNLINSUBKEY;
        rcdata = (PHT_REPLICA_CONN_DATA) addr;

        if (rcdata->oid != NULL) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }
        rcdata->oid = PmOid;

        HashTable = HTReplicaConn;
        QKey = &(rcdata->oid->key);
        QData = (PULONGLONG)&(rcdata);
    }

    //
    // Open the Linkge Key of the Objevt which contains the Export Value
    //
    WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE, SubKey, 0L, KEY_ALL_ACCESS, &key);
    CLEANUP1_WS(0, "Error: RegOpenKeyEx (%ws).", SubKey, WStatus, CLEANUP);

    HaveKey = TRUE;

    //
    //  Fetch the Export value
    //
    WStatus = RegQueryValueEx(key, L"Export", NULL, &Type, NULL, &size);
    CLEANUP_WS(0, "RegQueryValueEx(Export);", WStatus, CLEANUP);

    if (Type != REG_MULTI_SZ) {
        DPRINT2(0, "RegQueryValueEx(Export) is Type %d; not Type %d\n",
                Type,  REG_MULTI_SZ);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }

    //
    // Need to check if size == 0 as FrsAlloc asserts if called with 0 as the
    // first parameter (prefix fix).
    //
    ValueData = (size == 0) ? NULL : (PWCHAR) FrsAlloc (size);

    WStatus = RegQueryValueEx(key, L"Export", NULL, &Type, (PUCHAR)ValueData, &size);
    CLEANUP_WS(0, "RegQueryValueEx(Export);", WStatus, CLEANUP);

    if (Type != REG_MULTI_SZ) {
        DPRINT2(0, "RegQueryValueEx(Export) is Type %d; not Type %d\n",
                Type,  REG_MULTI_SZ);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }

    DPRINT1(4, "Export was = %ws\n", ValueData);

    if (size > sizeof(WCHAR)) {

        len = (1 + wcslen(InstanceName)) * sizeof(WCHAR);
        totallen = size + len;
        p = (PWCHAR) FrsAlloc (totallen);
        NewExport = p;
        r = ValueData;

        while (TRUE) {
            if ( (wcscmp(r, InstanceName)) == 0 ) {
                //
                // The Instance Value already exists
                //
                flag = FALSE;
                break;
            }
            wcscpy(p, r);
            p = wcschr(p, L'\0');
            r = wcschr(r, L'\0');
            p = p + 1;
            r = r + 1;
            if ( *r == L'\0') {
                break;
            }
        }
        if (flag) {
            wcscpy(p, InstanceName);
            p = wcschr(p, L'\0');
            *(p+1) = L'\0';
            //
            // If its a new Instance add it to the hash table
            //
            if ( ObjectType == REPLICASET ) {
                //
                // Set the ID of the Instance and increment for next.
                //
                rsdata->oid->key = FRS_UniqueID;
                FRS_UniqueID++;
            } else {

                //
                // Set the ID of the Instance and increment for next.
                //
                rcdata->oid->key = FRC_UniqueID;
                FRC_UniqueID++;
            }

        } else {
            //
            // This Instance already exists, so make no changes to the Export value
            //
            WStatus = ERROR_ALREADY_EXISTS;
            goto CLEANUP;
        }

    } else {
        //
        // This is the only Instance of the Object
        //
        len = (2 + wcslen(InstanceName)) * sizeof(WCHAR);
        NewExport = (PWCHAR) FrsAlloc (len);
        wcscpy(NewExport, InstanceName);
        p = wcschr(NewExport, L'\0');
        *(p+1) = L'\0';
        totallen = len;

        if ( ObjectType == REPLICASET ) {
            rsdata->oid->key = FRS_UniqueID;
            FRS_UniqueID++;
        } else {
            rcdata->oid->key = FRC_UniqueID;
            FRC_UniqueID++;
        }

    }


    DPRINT4(4, "PERFMON: Type: %d, Key: %08x %08x, QData: %08x %08x, Name: %ws\n",
           ObjectType, PRINTQUAD(*QKey), PRINTQUAD(*QData), InstanceName);

    GStatus = QHashInsert(HashTable, QKey, QData, 0, FALSE);
    if (GStatus != GHT_STATUS_SUCCESS) {
        DPRINT(0, "Error: QHashInsert Failed\n");
        WStatus = ERROR_ALREADY_EXISTS;
        goto CLEANUP;
    }

    //
    // Set the Export Value with the added instance (if any)
    //
    WStatus = RegSetValueEx (key, L"Export", 0L, REG_MULTI_SZ, (BYTE *)NewExport, totallen);
    CLEANUP_WS(0, "Error: RegSetValueEx (Export).", WStatus, CLEANUP);

    WStatus = ERROR_SUCCESS;


CLEANUP:

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR: Add instance failed for %ws :", InstanceName, WStatus);
        //
        // Failed to add the instance.  Free the OID and name.
        //
        FrsFree(PmOid->name);
        if ( ObjectType == REPLICASET ) {
            rsdata->oid = FrsFree (PmOid);
        } else {
            rcdata->oid = FrsFree (PmOid);
        }
    }

    //
    // Free the malloced memory
    //
    ValueData = FrsFree (ValueData);
    NewExport = FrsFree (NewExport);

    if (HaveKey) {
        FRS_REG_CLOSE(key);
    }

    //
    // Its safe to leave the critical section now
    //
    ReleasePerfmonLock;

    return WStatus;

}



DWORD
DeletePerfmonInstance(
    IN DWORD ObjectType,
    IN PVOID addr
    )

/*++

Routine Description:

    This routine is called by the ntfrs application to delete an Instance of a particular
    Object Type from the Registry and the Hash Table. It is very similar to the adding
    function described above.

Arguments:

    ObjectType - The Object whose instance has to be added
    addr - The data structure for the Instance Counters stored in Hash Table

Return Value:

    ERROR_SUCCESS - The Initialization of the Object was successful OR
    Appropriate DWORD value for the Error status

--*/

{
#undef DEBSUB
#define DEBSUB  "DeletePerfmonInstance:"

    ULONGLONG QKey;
    ULONG WStatus = ERROR_SUCCESS;
    ULONG WStatus1;

    PQHASH_TABLE HashTable;
    ULONG GStatus;
    DWORD Type, size, len, TotalLen;
    HKEY key = INVALID_HANDLE_VALUE;
    PWCHAR SubKey, p, r, s, InstanceName;
    PWCHAR ValueData = NULL;
    PWCHAR q = NULL;
    PHT_REPLICA_SET_DATA  rsdata;
    PHT_REPLICA_CONN_DATA rcdata;



    if (addr == NULL) {
        return ERROR_SUCCESS;
    }
    //
    // Deletion must be mutually exclusive
    // Check is its safe to enter before going ahead
    //
    if (!HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
        return ERROR_SUCCESS;
    }


    if ( ObjectType == REPLICASET ) {
        //
        // Replica Set Object
        //
        SubKey = REPSETLINSUBKEY;
        rsdata = (HT_REPLICA_SET_DATA *) addr;
        if ((rsdata->oid == NULL) || (rsdata->oid->name == NULL)) {
            return ERROR_SUCCESS;
        }
        InstanceName = rsdata->oid->name;
        HashTable = HTReplicaSet;
        QKey = rsdata->oid->key;
        DPRINT1(4, "Replica Free - %ws\n", InstanceName);
    } else {
        //
        // Replica Connection Object.
        //
        SubKey = REPCONNLINSUBKEY;
        rcdata = (HT_REPLICA_CONN_DATA *) addr;
        if ((rcdata->oid == NULL) || (rcdata->oid->name == NULL)) {
            return ERROR_SUCCESS;
        }
        InstanceName = rcdata->oid->name;
        HashTable = HTReplicaConn;
        QKey = rcdata->oid->key;
        DPRINT1(4, "Cxtion Free - %ws\n", InstanceName);
    }

    AcquirePerfmonLock;

    //
    // Pull the Instance key from the hash table.
    //
    DPRINT1(4, "QKey: %08x %08x\n", PRINTQUAD(QKey));
    if (QKey != QUADZERO ) {
        GStatus = QHashDelete(HashTable, &QKey);
        if (GStatus != GHT_STATUS_SUCCESS) {
            DPRINT1(0, "Error: QHashDelete.  GStatus = %d\n", GStatus);
        }
    }

    WStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE, SubKey, 0L, KEY_ALL_ACCESS, &key);
    CLEANUP1_WS(0, "RegOpenKeyEx(%ws);", SubKey, WStatus, CLEANUP_UNLOCK);

    //
    //  Fetch the Export value
    //
    WStatus = RegQueryValueEx(key, L"Export", NULL, &Type, NULL, &size);
    CLEANUP_WS(0, "RegQueryValueEx(Export);", WStatus, CLEANUP);

    if (Type != REG_MULTI_SZ) {
        DPRINT2(0, "RegQueryValueEx(Export) is Type %d; not Type %d\n",
                Type,  REG_MULTI_SZ);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }

    len = (1 + wcslen(InstanceName)) * sizeof(WCHAR);
    if (size < len) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }
    TotalLen = (size - len);

    //
    // Need to check if size == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
    //
    ValueData = (size == 0) ? NULL : (PWCHAR) FrsAlloc (size);

    WStatus = RegQueryValueEx(key, L"Export", NULL, &Type, (PUCHAR)ValueData, &size);
    CLEANUP_WS(0, "RegQueryValueEx(Export);", WStatus, CLEANUP);

    if (Type != REG_MULTI_SZ) {
        DPRINT2(0, "RegQueryValueEx(Export) is Type %d; not Type %d\n",
                Type,  REG_MULTI_SZ);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }

    DPRINT1(4, "Export was = %ws\n", ValueData);


    // Note: Perf: fix the below to do an inplace delete of the instance strimg.

    //
    // For REG_MULTI_SZ there are two UNICODE_NULLs at the end, one is accounted
    // for above.
    //
    if (TotalLen > sizeof(WCHAR)) {
        p = (PWCHAR) FrsAlloc (TotalLen);
        q = p;
        r = ValueData;
        while (TRUE) {
            if ( (wcscmp(r, InstanceName)) == 0) {
                r = wcschr(r, L'\0');
                r = r + 1;
                if (*r == L'\0')
                    break;
                else
                    continue;
            }
            wcscpy(p, r);
            p = wcschr(p, L'\0');
            r = wcschr(r, L'\0');
            p = p + 1;
            r = r + 1;
            if (*r == L'\0') {
                *p = L'\0';
                break;
            }
        }
    }
    else {
        q = NULL;
        TotalLen = 0;
    }

    DPRINT1(4, "Export now = %ws\n", q);

    //
    // Set the Export Value to the Updated Instance List
    //
    WStatus = RegSetValueEx (key, L"Export", 0L, REG_MULTI_SZ, (BYTE *)q, TotalLen);
    CLEANUP_WS(0, "RegSetValueEx(Export);", WStatus, CLEANUP);

CLEANUP:
    //
    // Free up the malloced memory
    //
    FrsFree (ValueData);
    FrsFree (q);
    FRS_REG_CLOSE(key);

    //
    // Free the name and oid struct so this func is not called again when the
    // replica set or connection struct is finally freed.
    //
    if ( ObjectType == REPLICASET ) {
        rsdata->oid->name = FrsFree(rsdata->oid->name);
        rsdata->oid = FrsFree(rsdata->oid);
    } else {
        rcdata->oid->name = FrsFree(rcdata->oid->name);
        rcdata->oid = FrsFree(rcdata->oid);
    }


CLEANUP_UNLOCK:
    //
    // Its safe to leave the critical section now
    //
    ReleasePerfmonLock;

    return WStatus;
}



ULONGLONG
PmFindTheKeyValue (
    IN PContextData Context
    )

/*++

Routine Description:

    This routine is called by the RPC server function GetIndicesOfInstancesFromServer, to
    get the index value of an Instance.

Arguments:

    Context - The structure containing the name of the Instance whose Key
              value has to be determined.

Return Value:

    The Key for the Instance or INVALIDKEY if the Instance was not
    found in the Hash Table

--*/

{
#undef DEBSUB
#define DEBSUB "PmFindTheKeyValue:"

    ULONGLONG QKeyValue = (ULONGLONG)INVALIDKEY;

    DWORD ret;
    PQHASH_TABLE HashTable;

    if (!HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
        return (ULONGLONG)INVALIDKEY;
    }


    HashTable = (Context->OBJType == REPLICASET) ? HTReplicaSet : HTReplicaConn;

    try {
        //
        // Deletion must be mutually exclusive
        // Check is its safe to enter before going ahead
        //
        AcquirePerfmonLock;

        //
        // Enumerate through the Hash Table and if a matching Instance
        // name is found, return its Key value
        //
        ret = QHashEnumerateTable(HashTable, PmSearchTable, Context);
        if ( ret == FrsErrorFoundKey) {
            QKeyValue = Context->KeyValue;
        }


    } finally {
        ReleasePerfmonLock;
    }

    return QKeyValue;

}

//
// The function is implemented in frsrpc.c
//
DWORD
FrsRpcAccessChecks(
    IN HANDLE   ServerHandle,
    IN DWORD    RpcApiIndex
    );


DWORD
GetIndicesOfInstancesFromServer (
    IN handle_t Handle,
    IN OUT OpenRpcData *packt
    )

/*++

Routine Description:

    This is an RPC server routine that is called by the client (Performance DLL
    for the FileReplicaSet and FileRepicaConn Objects of PERFMON) to set the
    indices for Instance names

Arguments:

    Handle - The RPC binding handle

    packt - The structure (sent by the client) containing the Instance Names
            whose indices have to be set and passed back to the client

Return Value:

    none

--*/

{
#undef DEBSUB
#define DEBSUB "GetIndicesOfInstancesFromServer:"
    LONG i;
    ContextData context;
    ULONG WStatus;
    LONG NumInstanceNames;

    WStatus = FrsRpcAccessChecks(Handle, ACX_COLLECT_PERFMON_DATA);
    CLEANUP_WS(4, "Collect Perfmon Data Access check failed.", WStatus, CLEANUP);

    //
    // Its possible that the RPC end points of PERFMON get initialized before
    // the InitializePerfmonServer gets called. If this RPC call has been made
    // before initialization, return error so that the Open function gets called
    // again by the perflib dll.
    //
    if (PMTotalInst == NULL) {
        WStatus = ERROR_INVALID_DATA;
    }
    CLEANUP_WS(4, "Perfmon server uninitialized. Can't return data.", WStatus, CLEANUP);

    try {
        if ((packt == NULL) || (packt->ver == NULL)) {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set the version to zero(its unused)
        //
        *(packt->ver) = 0;

        //
        // Set the appropriate Object Type
        //
        if (packt->ObjectType == REPSET) {
            context.OBJType = REPLICASET;
        }
        else

        if (packt->ObjectType == REPCONN) {
            context.OBJType = REPLICACONN;
        } else {

            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Check valid parameters.
        //
        if ((packt->instnames == NULL) ||
            (packt->indices == NULL)   ||
            (packt->numofinst > packt->instnames->size) ||
            (packt->numofinst > packt->indices->size)) {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }
        NumInstanceNames = packt->numofinst;

        for (i = 0; i < NumInstanceNames; i++) {

            context.name = packt->instnames->InstanceNames[i].name;

            if ((context.name == NULL) ||
                (wcslen(context.name) > PERFMON_MAX_INSTANCE_LENGTH)) {
                DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
                return ERROR_INVALID_PARAMETER;
            }

            DPRINT2(4, "The instance name of instance %d is %ws\n", i+1, context.name);
            //
            // Set the Index for the Instance name
            //
            packt->indices->index[i] = (DWORD) PmFindTheKeyValue (&context);
            DPRINT2(4, "The instance index of instance %ws is %d\n",
                    context.name, packt->indices->index[i]);
        }
    }  except (EXCEPTION_EXECUTE_HANDLER) {
       //
       // Exception
       //
       GET_EXCEPTION_CODE(WStatus);
    }

CLEANUP:

    return WStatus;

}



DWORD
GetCounterDataOfInstancesFromServer(
    IN handle_t Handle,
    IN OUT CollectRpcData *packg
    )

/*++

Routine Description:

    This is an RPC server routine that is called by the client (Performance DLL
    for the FileReplicaSet and FileRepicaConn Objects of PERFMON) to collect
    data for the Instance counters.

Arguments:

    Handle - The RPC binding handle

    packg - The structure (sent by the client) containing the indices of
            instances whose counters data has to be sent back to the client.

Return Value:

    none

--*/

{
#undef DEBSUB
#define DEBSUB "GetCounterDataOfInstancesFromServer:"

    ULONGLONG InstanceId;
    ULONGLONG CData;
    ULONG WStatus = ERROR_SUCCESS;
    LONG i, j;
    DWORD GStatus;
    ULONG_PTR Flags;
    BOOL FirstPass;
    PBYTE vd;
    PHT_REPLICA_SET_DATA rsdat;
    PHT_REPLICA_CONN_DATA rcdat;
    ULONG COffset, CSize, DataSize;
    LONG NumInstances;
    PQHASH_TABLE HashTable;
    PWCHAR OurName;

    PReplicaSetCounters Total, Rsi;

    //
    // Make security check on callers access to perfmon data.
    //
    WStatus = FrsRpcAccessChecks(Handle, ACX_COLLECT_PERFMON_DATA);
    CLEANUP_WS(4, "Collect Perfmon Data Access check failed.", WStatus, CLEANUP);

    //
    // Its possible that the RPC end points of PERFMON get initialized before
    // the InitializePerfmonServer gets called. This is possible if the service
    // is stopped and restarted and PERFMON continued to run in between.
    //
    if (PMTotalInst == NULL) {
        WStatus = ERROR_INVALID_DATA;
    }
    CLEANUP_WS(4, "Perfmon server uninitialized. Can't return data.", WStatus, CLEANUP);

    try {
        if (packg == NULL) {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set the appropriate Object Type
        //
        if (packg->ObjectType == REPSET) {
            DataSize = SIZEOF_REPSET_COUNTER_DATA;
            HashTable = HTReplicaSet;
        } else
        if (packg->ObjectType == REPCONN) {
            DataSize = SIZEOF_REPCONN_COUNTER_DATA;
            HashTable = HTReplicaConn;
        } else {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Check valid parameters.
        //
        if ((packg->databuff == NULL)         ||
            (packg->indices == NULL)          ||
            (packg->databuff->data == NULL)   ||
            (packg->numofinst > packg->indices->size)) {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }
        NumInstances = packg->numofinst;


        //
        // Set vd to the memory where counter data is to be filled
        //
        vd = packg->databuff->data;


        DPRINT1(5, "PERFMON: packg->ObjectType: %d\n", packg->ObjectType);
        DPRINT1(5, "PERFMON: packg->numofinst: %d\n", packg->numofinst);
        DPRINT1(5, "PERFMON: packg->databuff->data: %d\n", vd);
        DPRINT1(5, "PERFMON: packg->databuff->size: %d\n", packg->databuff->size);

        if (packg->ObjectType == REPSET) {
            //
            // First accumulate the totals for the replica set object
            //
            FirstPass = TRUE;
            Total = &PMTotalInst->FRSCounter;

            for (i = 0; i < NumInstances; i++) {

                if (packg->indices->index[i] == INVALIDKEY) {
                    //
                    // If the key is INVALID, data is zeros
                    //
                    DPRINT(5, "PERFMON: Invalid Key sent.\n");
                    continue;
                }

                //
                // set the value of index to quadword InstanceId
                //
                InstanceId = (ULONGLONG)packg->indices->index[i];

                //
                // Lookup for the counter data for the index value of the Instance
                //
                GStatus = QHashLookup(HTReplicaSet, &InstanceId, &CData, &Flags);
                if (GStatus != GHT_STATUS_SUCCESS) {
                    DPRINT(5, "PERFMON: Key not found.\n");
                    continue;
                }

                rsdat = (PHT_REPLICA_SET_DATA)(CData);
                //
                // Skip the total instance.
                //
                if (wcscmp(rsdat->oid->name, TOTAL_NAME) == 0) {
                    continue;
                }

                Rsi = &rsdat->FRSCounter;

                //
                // Accumulate the counters for this instance into the total.
                //
                for (j = 0; j < FRS_NUMOFCOUNTERS; j++) {
                    //
                    // If a count is Service Wide then leave the Total alone.
                    //
                    if (BooleanFlagOn(RepSetInitData[j].Flags, PM_RS_FLAG_SVC_WIDE)) {
                        continue;
                    }

                    COffset = RepSetInitData[j].offset;
                    CSize = RepSetInitData[j].size;


                    if (CSize == sizeof(ULONG)) {

                        if (FirstPass) {
                            *(PULONG)((PCHAR) Total + COffset) = (ULONG) 0;
                        }
                        *(PULONG)((PCHAR) Total + COffset) +=
                            *(PULONG)((PCHAR) Rsi + COffset);
                    } else
                    if (CSize == sizeof(ULONGLONG)) {

                        if (FirstPass) {
                            *(PULONGLONG)((PCHAR) Total + COffset) = QUADZERO;
                        }
                        *(PULONGLONG)((PCHAR) Total + COffset) +=
                            *(PULONGLONG)((PCHAR) Rsi + COffset);
                    }
                }
                FirstPass = FALSE;
            }
        }

        //
        // Check if the buffer is large enough to send all the
        // requested data.
        //
        if (packg->databuff->size < (LONG)(NumInstances*DataSize)) {
            DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
            return ERROR_INVALID_PARAMETER;
        }
        //
        // Now return the data to Perfmon.
        //
        for (i = 0; i < NumInstances; i++) {
            //
            // The amount of data returned should not exceed the buffer size
            //
            if ((vd - packg->databuff->data) > packg->databuff->size) {
                DPRINT(4, "PERFMON:  ERROR_INVALID_PARAMETER\n");
                return ERROR_INVALID_PARAMETER;
            }

            if (packg->indices->index[i] == INVALIDKEY) {
                //
                // If the key is INVALID, data is zeros
                //
                DPRINT(5, "PERFMON: Invalid Key sent.\n");
                ZeroMemory (vd, DataSize);
                vd += DataSize;
                continue;
            }

            //
            // set the value of index to quadword InstanceId
            //
            InstanceId = (ULONGLONG)packg->indices->index[i];

            //
            // Lookup for the counter data for the index value of the Instance
            //
            GStatus = QHashLookup(HashTable, &InstanceId, &CData, &Flags);
            if ( GStatus == GHT_STATUS_SUCCESS) {

                if (packg->ObjectType == REPSET) {

                    //
                    // Return data for replica set
                    //
                    rsdat = (PHT_REPLICA_SET_DATA)(CData);
                    OurName = rsdat->oid->name;
                    //
                    // Set all the Change Order counters which are the sum of the
                    // ones already set.
                    //
                    PmSetTheCOCounters(rsdat);

                    CopyMemory (vd, &(rsdat->FRSCounter), DataSize);
                } else {

                    //
                    // Return data for replica connection
                    //
                    rcdat = (PHT_REPLICA_CONN_DATA)(CData);
                    OurName = rcdat->oid->name;
                    CopyMemory (vd, &(rcdat->FRCCounter), DataSize);
                }

                DPRINT2(5, "%ws is the name associated with index %d\n",
                        OurName, packg->indices->index[i]);

            } else {
                //
                // Instance not found, return zeros for counter data
                //
                DPRINT1(0, "The instance not found for index %d\n",
                        packg->indices->index[i]);
                ZeroMemory (vd, DataSize);
            }

            //
            // Increment vd by SIZEOF_REPSET_COUNTER_DATA
            //
            vd += DataSize;
        }

    }  except (EXCEPTION_EXECUTE_HANDLER) {
       //
       // Exception
       //
       GET_EXCEPTION_CODE(WStatus);
    }

CLEANUP:
    return WStatus;
}



VOID
PmSetTheCOCounters(
    PHT_REPLICA_SET_DATA RSData
    )

/*++

Routine Description:

    This routine sets the Change Order countters which are the sums
    of the counters already set in the ntfrs application

Arguments:

    RSData - Pointer to the HT_REPLICA_SET_DATA structure whose counters
             need to be set


Return Value:

    none

--*/

{
#undef DEBSUB
#define DEBSUB "PmSetTheCOCounters:"

    //
    // Set the Local and Remote Retried Counter Values
    //
    RSData->FRSCounter.LCORetried = RSData->FRSCounter.LCORetriedGen +
                                    RSData->FRSCounter.LCORetriedFet +
                                    RSData->FRSCounter.LCORetriedIns +
                                    RSData->FRSCounter.LCORetriedRen;

    RSData->FRSCounter.RCORetried = RSData->FRSCounter.RCORetriedGen +
                                    RSData->FRSCounter.RCORetriedFet +
                                    RSData->FRSCounter.RCORetriedIns +
                                    RSData->FRSCounter.RCORetriedRen;

    //
    // Set all the CO counter values
    //
    RSData->FRSCounter.COIssued = RSData->FRSCounter.LCOIssued +
                                  RSData->FRSCounter.RCOIssued;

    RSData->FRSCounter.CORetired = RSData->FRSCounter.LCORetired +
                                   RSData->FRSCounter.RCORetired;

    RSData->FRSCounter.COAborted = RSData->FRSCounter.LCOAborted +
                                   RSData->FRSCounter.RCOAborted;

    RSData->FRSCounter.CORetried = RSData->FRSCounter.LCORetried +
                                   RSData->FRSCounter.RCORetried;

    RSData->FRSCounter.CORetriedGen = RSData->FRSCounter.LCORetriedGen +
                                      RSData->FRSCounter.RCORetriedGen;

    RSData->FRSCounter.CORetriedFet = RSData->FRSCounter.LCORetriedFet +
                                      RSData->FRSCounter.RCORetriedFet;

    RSData->FRSCounter.CORetriedIns = RSData->FRSCounter.LCORetriedIns +
                                      RSData->FRSCounter.RCORetriedIns;

    RSData->FRSCounter.CORetriedRen = RSData->FRSCounter.LCORetriedRen +
                                      RSData->FRSCounter.RCORetriedRen;

    RSData->FRSCounter.COMorphed = RSData->FRSCounter.LCOMorphed +
                                   RSData->FRSCounter.RCOMorphed;

    RSData->FRSCounter.COPropagated = RSData->FRSCounter.LCOPropagated +
                                      RSData->FRSCounter.RCOPropagated;

    RSData->FRSCounter.COReceived = RSData->FRSCounter.RCOReceived;

    RSData->FRSCounter.COSent = RSData->FRSCounter.LCOSent +
                                RSData->FRSCounter.RCOSent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\perfdll\repset.h ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSREP.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	REPSET.h

Abstract

	This is the header file for the REPLICASET Object data definition.
	It contains definitions to construct the dynamic data which is returned
	by the Configuration Registry.

Environment:

	User Mode Service

Revision History:

--*/


#ifndef _REPSET_H_
#define _REPSET_H_

#include <perrepsr.h>   // The counter structures header file
#include <perffrs.h>    // The RPC generated header file
#include <winperf.h>    // The PERFMON header file

//
// Number of objects being monitored
//
#define REPLICASET_NUM_PERF_OBJECT_TYPES 1

//
// Size of DWORD
//
#define SSIZEOFDWORD sizeof(DWORD)

//
// Number of ReplicaSet Counters
//
#define FRS_NUMOFCOUNTERS 91

//
// Flag bit defs
//
#define PM_RS_FLAG_SVC_WIDE      0x00000001

//
// Structure which is used in the Open function Initialization
//
typedef struct _REPLICASET_VALUES {
	PWCHAR name;       // name of the counter
	DWORD size;        // size of the counter type
	DWORD offset;      // offset of the counter in the structure
	DWORD counterType; // Type of (PERFMON) counter
	DWORD Flags;       // Flags. see def above.
} ReplicaSetValues;

//
// Counter Structure returned by the REPLICASET Object
//
typedef struct _REPLICASET_DATA_DEFINITION {
	PERF_OBJECT_TYPE ReplicaSetObjectType;          // ReplicaSet Object
	PERF_COUNTER_DEFINITION NumStat[FRS_NUMOFCOUNTERS]; // The array of PERF_COUNTER_DEFINITION structures
} REPLICASET_DATA_DEFINITION;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\chgorder.c ===
#define SERIALIZE_CO 0
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    chgorder.c

Abstract:

    This module processes change orders from either the local
    journal or the inbound partners.  It makes the accept/reject
    decision, putting the change order into the correct inbound log
    if accepted.

Author:

    David A. Orbits  23-June-1997

Environment

    User mode, winnt32

--*/
#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <tablefcn.h>
#include <test.h>

#include <perrepsr.h>


//
// Change order entry Flags.
//
FLAG_NAME_TABLE CoeFlagNameTable[] = {
    {COE_FLAG_IN_AGING_CACHE           , "InAgingCache "  },
    {COE_FLAG_RECOVERY_CO              , "RecoveryCo "    },
    {COE_FLAG_JUST_TOMBSTONE           , "JustTombstone " },

    {COE_FLAG_VOL_COLIST_BLOCKED       , "CoListBlked "   },
    {COE_FLAG_MOVEOUT_ENUM_DONE        , "MovOutEnumDone "},
    {COE_FLAG_NO_INBOUND               , "NoInbound "     },

    {COE_FLAG_STAGE_ABORTED            , "StageAbort "    },
    {COE_FLAG_STAGE_DELETED            , "StageDeleted "  },

    {COE_FLAG_REJECT_AT_RECONCILE      , "RejectAtRecon " },
    {COE_FLAG_DELETE_GEN_CO            , "DeleteGenCo "   },

    {COE_FLAG_REANIMATION              , "Reanimation "   },
    {COE_FLAG_PARENT_REANIMATION       , "ParReanimation "},
    {COE_FLAG_PARENT_RISE_REQ          , "ParRiseRequest "},

    {COE_FLAG_MORPH_GEN_FOLLOWER       , "MGFollower "    },
    {COE_FLAG_MG_FOLLOWER_MADE         , "MGFollowerMade "},

    {COE_FLAG_NEED_RENAME              , "NeedRename "    },
    {COE_FLAG_NEED_DELETE              , "NeedDelete "    },
    {COE_FLAG_PREINSTALL_CRE           , "PreInstallCre " },
    {COE_FLAG_TRY_OVRIDE_INSTALL       , "TryOvrRideInst "},

    {COE_FLAG_IDT_ORIG_PARENT_DEL      , "IdtOrigParDel " },
    {COE_FLAG_IDT_ORIG_PARENT_ABS      , "IdtOrigParAbs " },
    {COE_FLAG_IDT_NEW_PARENT_DEL       , "IdtNewParDel "  },
    {COE_FLAG_IDT_NEW_PARENT_ABS       , "IdtNewParAbs "  },
    {COE_FLAG_IDT_TARGET_DEL           , "IdtTargetDel "  },
    {COE_FLAG_IDT_TARGET_ABS           , "IdtTargetAbs "  },

    {COE_FLAG_OID_FROM_FILE            , "OidFmFile "     },
    {COE_FLAG_IDT_NEW_PARENT_DEL_DEF   , "IdtNewParDelDef "  }, 

    {0, NULL}
};

//
// Issue Cleanup Flags.
//
FLAG_NAME_TABLE IscuFlagNameTable[] = {
    {ISCU_CO_ABORT                     , "AbortCo "       },
    {ISCU_UPDATE_IDT_VVFLAGS           , "UpdIdtVVFlags " },

    {ISCU_ACK_INBOUND                  , "AckInb "        },
    {ISCU_UPDATEVV_DB                  , "UpdateVVDb "    },
    {ISCU_ACTIVATE_VV                  , "ActivateVV "    },
    {ISCU_ACTIVATE_VV_DISCARD          , "ActVVDiscard "  },

    {ISCU_INS_OUTLOG                   , "InsOutlog "     },
    {ISCU_INS_OUTLOG_NEW_GUID          , "InsOLogNewGuid "},

    {ISCU_DEL_IDT_ENTRY                , "DelIdt "        },
    {ISCU_UPDATE_IDT_ENTRY             , "UpdIdt "        },
    {ISCU_UPDATE_IDT_FLAGS             , "UpdIDTFlags "   },
    {ISCU_UPDATE_IDT_FILEUSN           , "UpdIdtFileUsn " },
    {ISCU_UPDATE_IDT_VERSION           , "UpdIDTVersion " },

    {ISCU_DEL_PREINSTALL               , "DelPreInstall " },
    {ISCU_DEL_STAGE_FILE               , "DelStageF "     },
    {ISCU_DEL_STAGE_FILE_IF            , "DelStageFIf "   },

    {ISCU_AIBCO                        , "AIBCO "         },
    {ISCU_ACTIVE_CHILD                 , "ActChild "      },
    {ISCU_NC_TABLE                     , "NamConfTbl "    },
    {ISCU_CHECK_ISSUE_BLOCK            , "ChkIsBlk "      },

    {ISCU_DEC_CO_REF                   , "DecCoRef "      },
    {ISCU_DEL_RTCTX                    , "DelRtCtx "      },
    {ISCU_DEL_INLOG                    , "DelInlog "      },
    {ISCU_UPDATE_INLOG                 , "UpdInlog "      },
    {ISCU_FREE_CO                      , "FreeCo "        },

    {ISCU_NO_CLEANUP_MERGE             , "NoFlagMrg "     },

    {0, NULL}
};



//
// Set to TRUE in ChgOrdAcceptShutdown() to shutdown the change order accept
// thread.  Errors and other problems may prevent the journal thread from
// running down all of the change order accept queues.  For now, use this
// boolean to help shutdown the change order accept thread.
//
BOOL ChangeOrderAcceptIsShuttingDown;

ULONG ChgOrdNextRetryTime;
PCHAR IbcoStateNames[IBCO_MAX_STATE+1];


ULONG UpdateInlogState[] = {COStatex, COFlagsx, COIFlagsx, COExtensionx
    /*, COContentCmdx, COLcmdx */};



//
// The following IDTable record fields may be updated when a change order goes
// through the retry path.
//
ULONG IdtCoRetryFieldList[] = {Flagsx, CurrentFileUsnx};
#define IdtCoRetryFieldCount  (sizeof(IdtCoRetryFieldList) / sizeof(ULONG))

//
// The following IDTable record are updated for a CO that reanimates a
// deleted file/dir.
//
ULONG IdtFieldReanimateList[] = {FileIDx, FileNamex, ParentGuidx, ParentFileIDx};
#define IdtCoReanimateFieldCount  (sizeof(IdtFieldReanimateList) / sizeof(ULONG))


//
// The max number of IDTable fields that might be updated in the retire path.
//
#define CO_ACCEPT_IDT_FIELD_UPDATE_MAX  13


// Note: Change this to init from either the DS or the registry.
#if SERIALIZE_CO
    BOOL SerializeAllChangeOrders = TRUE;
#else
    BOOL SerializeAllChangeOrders = FALSE;
#endif


//
// 64 bit Global sequence number and related lock.
//
ULONGLONG GlobSeqNum = QUADZERO;
CRITICAL_SECTION  GlobSeqNumLock;


extern FRS_QUEUE FrsVolumeLayerCOList;
extern FRS_QUEUE FrsVolumeLayerCOQueue;

extern FRS_QUEUE VolumeMonitorQueue;  // for test
extern HANDLE JournalCompletionPort;  // for test

extern PCHAR CoLocationNames[];

//
// To test for change orders with bogus event times.
//
extern ULONGLONG MaxPartnerClockSkew;   // 100 ns units.
extern DWORD    PartnerClockSkew;       // minutes

extern ULONG ChangeOrderAgingDelay;

//
// Fixed guid for the dummy cxtion (aka GhostCxtion) assigned to orphan remote
// change orders whose inbound cxtion has been deleted from the DS but they
// have already past the fetching state and can finish without the real cxtion
// coming back. No authentication checks are made for this dummy cxtion.
//
extern GUID FrsGuidGhostCxtion;
extern GUID FrsGhostJoinGuid;
extern PCXTION FrsGhostCxtion;

//
// The following quadword is stored in a QHash table to track the number of
// active change orders with a given parent directory.  A change order that
// arrives on the parent is blocked until all the changeorders on the children
// have finished.
//
typedef struct _CHILD_ACTIVE_ {
    union {
        struct {
            ULONG Count;                        // Number of active children
            PCHANGE_ORDER_ENTRY  ChangeOrder;   //
        };
        ULONGLONG Data;
    };
} CHILD_ACTIVE, *PCHILD_ACTIVE;



typedef struct _MOVEIN_CONTEXT {
    ULONG               NumFiles;
    ULONG               NumDirs;
    ULONG               NumSkipped;
    ULONG               NumFiltered;
    LONGLONG            ParentFileID;
    PREPLICA            Replica;
} MOVEIN_CONTEXT, *PMOVEIN_CONTEXT;


//
// Event time window default is 30 min (in 100 nanosec units).  Inited
// from registry.
//
LONGLONG RecEventTimeWindow;

//
// Limits on how many time and for how long we will continue to retry a
// change order when the parent is missing.
//
extern ULONG MaxCoRetryTimeoutMinutes;
extern ULONG MaxCoRetryTimeoutCount;


//
// Change order retry command server.
//
//  ** WARNING ** There is currently only one thread to service the change order
// retry scans for all replica sets.  The ActiveInlogRetry table associated with each
// replica set tracks the sequence numbers of the change orders that have been
// resubmitted.  This should also guard against the simultaneous submitting of
// the same change order by one thread doing a single connection retry and
// another thread doing an all connection retry for the same replica set.
// However, this has not been tested.
//
#define CHGORD_RETRY_MAXTHREADS    (1)
COMMAND_SERVER ChgOrdRetryCS;

//
// The time in ms between checks for retries in the inbound log.
// (FKC_INLOG_RETRY_TIME from registry)
//
ULONG InlogRetryInterval;

//
// The time to let a ChangeORder block a process queue waiting for a Join to
// complete.
//
#define  CHG_ORD_HOLD_ISSUE_LIMIT (ULONG)(2 * 60 * 1000)         //  2 min

//
// Struct for the change order accept server
//      Contains info about the queues and the threads
// Warning: Check for needed locks if we allow multiple threads.
//
#define CHGORDER_MAXTHREADS (1)


#define CHGORDER_RETRY_MIN (1 * 1000)          // 1 second
#define CHGORDER_RETRY_MAX (5 * 1000)          // 5 seconds



#define ISSUE_OK                        0
#define ISSUE_CONFLICT                  1
#define ISSUE_DUPLICATE_REMOTE_CO       2
#define ISSUE_REJECT_CO                 4
#define ISSUE_RETRY_LATER               5


#define REANIMATE_SUCCESS     0
#define REAMIMATE_RETRY_LATER 1
#define REANIMATE_CO_REJECTED 2
#define REANIMATE_FAILED      3
#define REANIMATE_NO_NEED     4

//
// ChgOrdInsertProcQ Flag defs.
//
#define IPQ_HEAD                0x00000000
#define IPQ_TAIL                0x00000001
#define IPQ_TAKE_COREF          0x00000002
#define IPQ_ASSERT_IF_ERR       0x00000004
#define IPQ_DEREF_CXTION_IF_ERR 0x00000008
#define IPQ_MG_LOOP_CHK         0x00000010


#define SIZEOF_RENAME_SUFFIX    (7 + 8) // _NTFRS_<tic count in hex>

#define MAX_RETRY_SET_OBJECT_ID 10  // retry 10 times


SubmitReplicaJoinWait(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN ULONG    TimeOut
    );

ULONG
ChgOrdFetchCmd(
    PFRS_QUEUE            *pIdledQueue,
    PCHANGE_ORDER_ENTRY   *pChangeOrder,
    PVOLUME_MONITOR_ENTRY *ppVme
    );

ULONG
ChgOrdHoldIssue(
    IN PREPLICA              Replica,
    IN PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN PFRS_QUEUE            CoProcessQueue
    );

BOOL
ChgOrdReconcile(
    PREPLICA            Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder,
    PIDTABLE_RECORD     IDTableRec
    );

BOOL
ChgOrdGenMorphCo(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            TmpIDTableCtxNC,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    );


BOOL
ChgOrdApplyMorphCo(
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    );

ULONG
ChgOrdReanimate(
    IN PTABLE_CTX          IDTableCtx,
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PTABLE_CTX          TmpIDTableCtx
    );

BOOL
ChgOrdMakeDeleteCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PIDTABLE_RECORD     IDTableRec
    );

BOOL
ChgOrdMakeRenameCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PIDTABLE_RECORD     IDTableRec
    );

BOOL
ChgOrdConvertCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN ULONG               LocationCmd
    );

BOOL
ChgOrdReserve(
    IN PIDTABLE_RECORD     IDTableRec,
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    );

ULONG
ChgOrdDispatch(
    PTHREAD_CTX           ThreadCtx,
    PIDTABLE_RECORD       IDTableRec,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    );

VOID
ChgOrdReject(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    );

ULONG
ChgOrdIssueCleanup(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    ULONG                 CleanUpFlags
    );

ULONG
ChgOrdUpdateIDTableRecord(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder
    );

ULONG
ChgOrdReadIDRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PTABLE_CTX            IDTableCtxNC,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  *IDTableRecExists
    );

ULONG
ChgOrdInsertIDRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PTABLE_CTX            DIRTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    );

ULONG
ChgOrdInsertDirRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            DIRTableCtx,
    PIDTABLE_RECORD       IDTableRec,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  InsertFlag
    );

ULONG
ChgOrdCheckAndFixTunnelConflict(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtxNew,
    PTABLE_CTX            IDTableCtxExist,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    BOOL                  *IDTableRecExists
    );

ULONG
ChgOrdCheckNameMorphConflict(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtxNC,
    ULONG                 ReplicaNumber,
    PCHANGE_ORDER_ENTRY   ChangeOrder
    );

VOID
ChgOrdProcessControlCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    );

VOID
ChgOrdTranslateGuidFid(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    );

ULONG
ChgOrdInsertInlogRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            InLogTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  RetryOutOfOrder
    );

typedef struct _MOVEOUT_CONTEXT {
    ULONG               NumFiles;
    LONGLONG            ParentFileID;
    PREPLICA            Replica;
} MOVEOUT_CONTEXT, *PMOVEOUT_CONTEXT;

JET_ERR
ChgOrdMoveoutWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
);

DWORD
ChgOrdStealObjectId(
    IN     PWCHAR                   Name,
    IN     PVOID                    Fid,
    IN     PVOLUME_MONITOR_ENTRY    pVme,
    OUT    USN                      *Usn,
    IN OUT PFILE_OBJECTID_BUFFER    FileObjID
    );

DWORD
ChgOrdSkipBasicInfoChange(
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN PBOOL                SkipCo
    );

JET_ERR
ChgOrdRetryWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

JET_ERR
ChgOrdRetryWorkerPreRead(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Context
    );

ULONG
ChgOrdMoveInDirTree(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder
    );

ULONG
ChgOrdRetryThread(
    PVOID  FrsThreadCtxArg
    );


PCHANGE_ORDER_ENTRY
ChgOrdMakeFromFile(
    IN PREPLICA       Replica,
    IN HANDLE         FileHandle,
    IN PULONGLONG     ParentFid,
    IN ULONG          LocationCmd,
    IN ULONG          CoFlags,
    IN PWCHAR         FileName,
    IN USHORT         Length
);

PCHANGE_ORDER_ENTRY
ChgOrdMakeFromIDRecord(
    IN PIDTABLE_RECORD IDTableRec,
    IN PREPLICA        Replica,
    IN ULONG           LocationCmd,
    IN ULONG           CoFlags,
    IN GUID           *CxtionGuid
);

ULONG
ChgOrdInsertProcessQueue(
    IN PREPLICA Replica,
    IN PCHANGE_ORDER_COMMAND ChangeOrder,
    IN ULONG CoeFlags,
    IN PCXTION Cxtion
    );

VOID
ChgOrdRetrySubmit(
    IN PREPLICA  Replica,
    IN PCXTION   Cxtion,
    IN USHORT Command,
    IN BOOL   Wait
    );

PCHANGE_ORDER_RECORD_EXTENSION
DbsDataConvertCocExtensionFromWin2K(
    IN PCO_RECORD_EXTENSION_WIN2K CocExtW2K
    );

BOOL
JrnlDoesChangeOrderHaveChildren(
    IN PTHREAD_CTX          ThreadCtx,
    IN PTABLE_CTX           TmpIDTableCtx,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder
    );

ULONG
JrnlGetPathAndLevel(
    IN  PGENERIC_HASH_TABLE  FilterTable,
    IN  PLONGLONG StartDirFileID,
    OUT PULONG    Level
    );

ULONG
JrnlAddFilterEntryFromCo(
    IN PREPLICA Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry
    );

ULONG
JrnlDeleteDirFilterEntry(
    IN  PGENERIC_HASH_TABLE FilterTable,
    IN  PULONGLONG DFileID,
    IN  PFILTER_TABLE_ENTRY  ArgFilterEntry
    );

ULONG
JrnlHashCalcGuid (
    PVOID Buf,
    ULONG Length
);

ULONG
OutLogInsertCo(
    PTHREAD_CTX         ThreadCtx,
    PREPLICA            Replica,
    PTABLE_CTX          OutLogTableCtx,
    PCHANGE_ORDER_ENTRY ChangeOrder
);

VOID
ChgOrdCalcHashGuidAndName (
    IN PUNICODE_STRING Name,
    IN GUID           *Guid,
    OUT PULONGLONG    HashValue
    );

LONG
FrsGuidCompare (
    IN GUID *Guid1,
    IN GUID *Guid2
    );

DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    );

ULONG
DbsUpdateIDTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    );

DWORD
StuDelete(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

DWORD
StuCreatePreInstallFile(
    IN PCHANGE_ORDER_ENTRY Coe
    );


VOID
ChgOrdDelayCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN PFRS_QUEUE       IdledQueue,
    IN PCOMMAND_SERVER  CmdServer,
    IN OUT PULONG       TimeOut
    )
/*++

Routine Description:

    Put the command back on the head of the queue and submit a
    delayed command to unidle the queue. When the "unidle" occurs,
    Cmd will be reissued. Retry forever.

Arguments:

    Cmd  -- The command packet to delay
    IdledQueue --
    CmdServer -- The command server to reactivate
    TimeOut   -- ptr to the time out value.

Return Value:
    None.
--*/
{
    //
    // Put the command back at the head of the queue
    //
    FrsUnSubmitCommand(Cmd);

    //
    // Extend the retry time (but not too long)
    //

    *TimeOut <<= 1;
    if (*TimeOut > CHGORDER_RETRY_MAX)
        *TimeOut = CHGORDER_RETRY_MAX;
    //
    // or too short
    //
    if (*TimeOut < CHGORDER_RETRY_MIN)
        *TimeOut = CHGORDER_RETRY_MIN;
    //
    // This queue will be unidled later. At that time, a thread will
    // retry the command at the head of the queue.
    //
    FrsDelCsSubmitUnIdled(CmdServer, IdledQueue, *TimeOut);
}


VOID
ChgOrdRetryPerfmonCount(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    )
/*++
Routine Description:

   Tally the perfmon counters for retry change orders.

Arguments:
   ChangeOrder-- The change order.
   Replica    -- The Replica struct.

Return Value:

   None.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdRetryPerfmonCount:"

    BOOL LocalCo, ControlCo;

    LocalCo   = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    ControlCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL);

    //
    // Increment the Change orders (Local and Remote) retried at
    // (Generate, Fetch, Install, Rename)
    //
    if (LocalCo) {
        //
        // Retried at Generate
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_STAGING_RETRY)) {
            PM_INC_CTR_REPSET(Replica, LCORetriedGen, 1);
        }
        //
        // Retried at Fetch
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_FETCH_RETRY)) {
            PM_INC_CTR_REPSET(Replica, LCORetriedFet, 1);
        }
        //
        // Retried at Install
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_RETRY)) {
            PM_INC_CTR_REPSET(Replica, LCORetriedIns, 1);
        }
        //
        // Retried at Rename or Delete
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY) ||
                 CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            PM_INC_CTR_REPSET(Replica, LCORetriedRen, 1);
        }
    }

    //
    // If it's not Local and Control CO it must be a Remote CO
    //
    else if (!ControlCo) {
        //
        // Retried at Generate
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_STAGING_RETRY)) {
            PM_INC_CTR_REPSET(Replica, RCORetriedGen, 1);
        }
        //
        // Retried at Fetch
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_FETCH_RETRY)) {
            PM_INC_CTR_REPSET(Replica, RCORetriedFet, 1);
        }
        //
        // Retried at Install
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_RETRY)) {
            PM_INC_CTR_REPSET(Replica, RCORetriedIns, 1);
        }
        //
        // Retried at Rename or Delete
        //
        else if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY) ||
                 CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            PM_INC_CTR_REPSET(Replica, RCORetriedRen, 1);
        }
    }
}


DWORD
ChgOrdInsertProcQ(
    IN PREPLICA            Replica,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN DWORD               Flags
    )
/*++
Routine Description:

   Insert the change order (Coe) onto the process queue associated with this
   Replica's VME process queue.

   IPQ_HEAD                - Insert on head of queue
   IPQ_TAIL                - Insert on tail of queue
   IPQ_TAKE_COREF          - Increment the ref count on the change order.
   IPQ_ASSERT_IF_ERR       - If insert fails then ASSERT.
   IPQ_DEREF_CXTION_IF_ERR - If insert fails then drop the changeorder count
                             for the connection assiociated with the CO.
   IPQ_MG_LOOP_CHK         - Check if this CO is in a MorphGen Loop.

Arguments:
   Replica    -- The Replica struct.
   Coe        -- The change order.
   Flags      -- see above.

Return Value:

   Win32 Status.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertProcQ:"

    DWORD  WStatus;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;


    if (BooleanFlagOn(Flags, IPQ_TAKE_COREF) && (++Coe->CoMorphGenCount > 50)) {
        DPRINT(0, "++ ERROR: ChangeOrder caught in morph gen loop\n");
        FRS_PRINT_TYPE(0, Coe);
        FRS_ASSERT(!"ChangeOrder caught in morph gen loop");
        return ERROR_OPERATION_ABORTED;
    }

    //
    // Init the cleanup flags, set the ONLIST CO flag, set entry create time
    // for no aging delay.
    //
    ZERO_ISSUE_CLEANUP(Coe);
    SET_CO_FLAG(Coe, CO_FLAG_ONLIST);
    Coe->EntryCreateTime = Coe->TimeToRun = CO_TIME_NOW(pVme);

    if (BooleanFlagOn(Flags, IPQ_TAKE_COREF)) {
        INCREMENT_CHANGE_ORDER_REF_COUNT(Coe);
    }

    if (BooleanFlagOn(Flags, IPQ_TAIL)) {
        WStatus = FrsRtlInsertTailQueue(&pVme->ChangeOrderList, &Coe->ProcessList);
    } else {
        WStatus = FrsRtlInsertHeadQueue(&pVme->ChangeOrderList, &Coe->ProcessList);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "++ ERROR - ChangeOrder insert failed.", WStatus);

        if (BooleanFlagOn(Flags, IPQ_DEREF_CXTION_IF_ERR)) {
            DROP_CO_CXTION_COUNT(Replica, Coe, WStatus);
        }

        if (BooleanFlagOn(Flags, IPQ_TAKE_COREF)) {
            DECREMENT_CHANGE_ORDER_REF_COUNT(Coe);
        }

        if (BooleanFlagOn(Flags, IPQ_ASSERT_IF_ERR)) {
            FRS_ASSERT(!"ChgOrdInsertProcQ: queue insert failed.");
        }
    }

    return WStatus;
}



DWORD
ChgOrdAccept(
    PVOID  FrsThreadCtxArg
    )
/*++
Routine Description:

    Entry point for processing change orders from the volume change order lists.


    Pull entries off the change order queue and:
      1. See if they have expired.  (They stay on the list for a short time to
         accumulate multiple changes.)

      2. If there is a change order active on this file then idle the queue
         until the active change order completes.

      3. Process expired CO by first deciding acceptance. This is
         provisional for early abort.  The final decision occurs just prior
         to installing the staged file locally.

      4. Make entry in the inbound hash table

      5. Make entry in the inbound log for this replica set and get the
         CO sequence number. State is IBCO_INITIALIZING.

      6. Send request to staging, setting state to IBCO_STAGING_REQUESTED.

    If a change order is already pending for a file we stop processing
    further change orders until the pending request completes.  If the
    pending request ultimately fails (say because we can't stage the files)
    then we abort the change order.  The DB version info on the file is not
    updated until after the file has been installed.

    As the change order progresses we update the current status in the
    change order entry in Jet at points where we need to preserve persistence.

    Inbound Change Order States:

    IBCO_INITIALIZING         Initial state when CO is first put in log.
    IBCO_STAGING_REQUESTED    Alloc staging file space for local CO
    IBCO_STAGING_INITIATED    LocalCO Staging file copy has started
    IBCO_STAGING_COMPLETE     LocalCO Staging file complete
                              At this point prelim accept rechecked and
                              becomes either final accept of abort.
                              Abort is caused by more recent local change.
    IBCO_STAGING_RETRY        Waiting to retry local CO stage file generation.

    IBCO_FETCH_REQUESTED      Alloc staging file space for remote co
    IBCO_FETCH_INITIATED      RemoteCO staging file fetch has started
    IBCO_FETCH_COMPLETE       RemoteCO Staging file fetch complete
    IBCO_FETCH_RETRY          Waiting to retry remote CO stage file fetch

    IBCO_INSTALL_REQUESTED    File install requested
    IBCO_INSTALL_INITIATED    File install has started
    IBCO_INSTALL_COMPLETE     File install is complete
    IBCO_INSTALL_WAIT         File install is waiting to try again.
    IBCO_INSTALL_RETRY        File install is retrying.
    IBCO_INSTALL_REN_RETRY    File install rename is retrying.
    IBCO_INSTALL_DEL_RETRY    Delete or Moveout CO finished except for final on-disk delete.

    IBCO_OUTBOUND_REQUEST     Request outbound propagaion
    IBCO_OUTBOUND_ACCEPTED    Request accepted and now in Outbound log

    IBCO_COMMIT_STARTED       DB state update started.
    IBCO_RETIRE_STARTED       DB state update done, freeing change order.
    IBCO_ENUM_REQUESTED       CO is being recycled to do a dir enum.

    IBCO_ABORTING             CO is being aborted.

Arguments:

    FrsThreadCtxArg - thread

Return Value:

    WIN32 status

--*/
// Note:  Need to Handle MOVERS.

{
#undef DEBSUB
#define DEBSUB  "ChgOrdAccept:"

    JET_ERR              jerr, jerr1;
    ULONG                FStatus, RStatus, WStatus;
    ULONG                GStatus, GStatusAC;
    PFRS_QUEUE           IdledQueue;
    PFRS_THREAD          FrsThread = (PFRS_THREAD)FrsThreadCtxArg;
    ULONG                TimeOut, ULong;
    PVOLUME_MONITOR_ENTRY pVme;

    PIDTABLE_RECORD      IDTableRec;

    PCHANGE_ORDER_RECORD CoCmd;
    PCHANGE_ORDER_RECORD DupCoCmd;
    PVOID                KeyArray[2];

    PCHANGE_ORDER_ENTRY  ChangeOrder;
    ULONG                Decision;

    PTHREAD_CTX          ThreadCtx;

    PTABLE_CTX           IDTableCtx, InLogTableCtx, DIRTableCtx;
    PTABLE_CTX           TmpIDTableCtx, TmpIDTableCtxNC, TmpINLOGTableCtx;
    PREPLICA             Replica;
    BOOL                 MorphOK;
    BOOL                 IDTableRecExists;

    BOOL                 NewFile, LocalCo, RetryCo, ControlCo, RecoveryCo;
    BOOL                 MorphGenCo;
    ULONG                LocationCmd;
    PREPLICA_THREAD_CTX  RtCtx = NULL;
    ULONG                i;
    BOOL                 SkipCo, DuplicateCo, ReAnimate, UnIdleProcessQueue;
    BOOL                 RetryPreinstall, FilePresent;
    BOOL                 RaiseTheDead, DemandRefreshCo, NameMorphConflict;
    BOOL                 JustTombstone, ParentReanimation;
    MOVEOUT_CONTEXT      MoveOutContext;
    CHAR                 FetchTag[32] = "CO Fetch **** ";

    DPRINT(0, "ChangeOrder Thread is starting.\n");

    TimeOut = 100;

    ChgOrdNextRetryTime = GetTickCount();

    IbcoStateNames[IBCO_INITIALIZING     ] = "IBCO_INITIALIZING     ";
    IbcoStateNames[IBCO_STAGING_REQUESTED] = "IBCO_STAGING_REQUESTED";
    IbcoStateNames[IBCO_STAGING_INITIATED] = "IBCO_STAGING_INITIATED";
    IbcoStateNames[IBCO_STAGING_COMPLETE ] = "IBCO_STAGING_COMPLETE ";
    IbcoStateNames[IBCO_STAGING_RETRY    ] = "IBCO_STAGING_RETRY    ";
    IbcoStateNames[IBCO_FETCH_REQUESTED  ] = "IBCO_FETCH_REQUESTED  ";
    IbcoStateNames[IBCO_FETCH_INITIATED  ] = "IBCO_FETCH_INITIATED  ";
    IbcoStateNames[IBCO_FETCH_COMPLETE   ] = "IBCO_FETCH_COMPLETE   ";
    IbcoStateNames[IBCO_FETCH_RETRY      ] = "IBCO_FETCH_RETRY      ";
    IbcoStateNames[IBCO_INSTALL_REQUESTED] = "IBCO_INSTALL_REQUESTED";
    IbcoStateNames[IBCO_INSTALL_INITIATED] = "IBCO_INSTALL_INITIATED";
    IbcoStateNames[IBCO_INSTALL_COMPLETE ] = "IBCO_INSTALL_COMPLETE ";
    IbcoStateNames[IBCO_INSTALL_WAIT     ] = "IBCO_INSTALL_WAIT     ";
    IbcoStateNames[IBCO_INSTALL_RETRY    ] = "IBCO_INSTALL_RETRY    ";
    IbcoStateNames[IBCO_INSTALL_REN_RETRY] = "IBCO_INSTALL_REN_RETRY";
    IbcoStateNames[IBCO_INSTALL_DEL_RETRY] = "IBCO_INSTALL_DEL_RETRY";
    IbcoStateNames[IBCO_UNUSED_16        ] = "IBCO_UNUSED_16        ";
    IbcoStateNames[IBCO_UNUSED_17        ] = "IBCO_UNUSED_17        ";
    IbcoStateNames[IBCO_UNUSED_18        ] = "IBCO_UNUSED_18        ";
    IbcoStateNames[IBCO_OUTBOUND_REQUEST ] = "IBCO_OUTBOUND_REQUEST ";
    IbcoStateNames[IBCO_OUTBOUND_ACCEPTED] = "IBCO_OUTBOUND_ACCEPTED";
    IbcoStateNames[IBCO_COMMIT_STARTED   ] = "IBCO_COMMIT_STARTED   ";
    IbcoStateNames[IBCO_RETIRE_STARTED   ] = "IBCO_RETIRE_STARTED   ";
    IbcoStateNames[IBCO_ENUM_REQUESTED   ] = "IBCO_ENUM_REQUESTED   ";
    IbcoStateNames[IBCO_ABORTING         ] = "IBCO_ABORTING         ";

    //
    // Get width of reconcilliation window from registry.
    //
    CfgRegReadDWord(FKC_RECONCILE_WINDOW, NULL, 0, &ULong);
    RecEventTimeWindow = (LONGLONG)ULong * (LONGLONG)CONVERT_FILETIME_TO_MINUTES;

    //
    // Get Inlog retry interval.
    //
    CfgRegReadDWord(FKC_INLOG_RETRY_TIME, NULL, 0, &ULong);
    InlogRetryInterval = ULong * 1000;

    //
    // Init Change order lock table.
    //
    for (i=0; i<NUMBER_CHANGE_ORDER_LOCKS; i++) {
        INITIALIZE_CRITICAL_SECTION(&ChangeOrderLockTable[i]);
    }

    INITIALIZE_CRITICAL_SECTION(&GlobSeqNumLock);

    //
    // Initialize the retry thread
    //
    FrsInitializeCommandServer(&ChgOrdRetryCS,
                               CHGORD_RETRY_MAXTHREADS,
                               L"ChgOrdRetryCS",
                               ChgOrdRetryThread);

    //
    // Allocate a context for Jet to run in this thread.
    //
    ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);

    //
    // Allocate Temp table contexts once for the ID table and the INLOG Table.
    // Don't free them until we exit.
    //
    TmpIDTableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TmpIDTableCtx->TableType = TABLE_TYPE_INVALID;
    TmpIDTableCtx->Tid = JET_tableidNil;

    TmpIDTableCtxNC = FrsAlloc(sizeof(TABLE_CTX));
    TmpIDTableCtxNC->TableType = TABLE_TYPE_INVALID;
    TmpIDTableCtxNC->Tid = JET_tableidNil;

    TmpINLOGTableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TmpINLOGTableCtx->TableType = TABLE_TYPE_INVALID;
    TmpINLOGTableCtx->Tid = JET_tableidNil;

    //
    // Setup a Jet Session returning the session ID in ThreadCtx.
    //
    jerr = DbsCreateJetSession(ThreadCtx);
    if (JET_SUCCESS(jerr)) {
        DPRINT(5,"JetOpenDatabase complete\n");
    } else {
        DPRINT_JS(0,"ERROR - OpenDatabase failed.  Thread exiting.", jerr);
        jerr = DbsCloseJetSession(ThreadCtx);
        ThreadCtx = FrsFreeType(ThreadCtx);
        return ERROR_GEN_FAILURE;
    }


    DPRINT(0, "ChangeOrder Thread has started.\n");
    DEBUG_FLUSH();
    SetEvent(ChgOrdEvent);
    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);


    //
    // Try-Finally so we shutdown Jet cleanly.
    //
    try {

    //
    // Capture exception.
    //
    try {

    while (TRUE) {
        //
        // Fetch the next change order command.  If successfull this returns
        // with the FrsVolumeLayerCOList Lock held and a reference on the Vme.
        //
        FStatus = ChgOrdFetchCmd(&IdledQueue, &ChangeOrder, &pVme);
        if ((FStatus == FrsErrorQueueIsRundown) || !FRS_SUCCESS(FStatus)) {
            //
            // Treat non-success status from fetch as a normal termination
            // in the Try-Finally clause.
            //
            WStatus = ERROR_SUCCESS;
            break;
        }

        LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

        CoCmd = &ChangeOrder->Cmd;

        strcpy(&FetchTag[14], CoLocationNames[LocationCmd]);
        CHANGE_ORDER_TRACEX(3, ChangeOrder, FetchTag, CoCmd->Flags);

        ParentReanimation = COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION);
        RecoveryCo        = COE_FLAG_ON(ChangeOrder, COE_FLAG_RECOVERY_CO);

        DemandRefreshCo   = CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH);
        MorphGenCo        = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

        ControlCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL);
        LocalCo   = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
        RetryCo   = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

        UnIdleProcessQueue = TRUE;
        NameMorphConflict  = FALSE;
        IDTableRecExists   = FALSE;
        RetryPreinstall    = FALSE;
        FilePresent        = FALSE;
        DuplicateCo        = FALSE;
        NewFile            = FALSE;

        Decision = ISSUE_OK;

        FRS_PRINT_TYPE(4, ChangeOrder);
        //
        // We did not decrement the ref count in ChgOrdFetchCmd since the
        // CO was not taken off the process queue.
        // Keep it until processing is done.
        // Another reference on the CO is taken by the VV code when the retire
        // slot is activated.  Releasing the reference is done by a request to
        // the issue cleanup logic.  But set up to decrement the ref if the
        // CO is rejected.
        //
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO | ISCU_DEC_CO_REF);

        //
        // The change order goes to the target in
        // NewReplica unless it's null then use the original Replica.
        //
        Replica = CO_REPLICA(ChangeOrder);

        FRS_ASSERT(Replica != NULL);

        if (RetryCo) {
            //
            // Update perfmon counts for retry CO's
            //
            ChgOrdRetryPerfmonCount(ChangeOrder, Replica);
        }

        //
        // For local and remote CO's, check if the connection is no longer
        // joined.  If this is true then we bail out here because it is
        // possible that a previously issued CO could be creating the parent
        // dir for this CO and if that CO didn't finish then we would be
        // propagating this one out of order.
        //
        if (!ControlCo) {

            FRS_ASSERT(LocalCo || ChangeOrder->Cxtion != NULL);
            LOCK_CXTION_TABLE(Replica);

            if ((ChangeOrder->Cxtion == NULL) ||
                !CxtionFlagIs(ChangeOrder->Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
                !GUIDS_EQUAL(&ChangeOrder->JoinGuid,
                             &ChangeOrder->Cxtion->JoinGuid)) {
                UNLOCK_CXTION_TABLE(Replica);

                FrsRtlRemoveEntryQueueLock(IdledQueue, &ChangeOrder->ProcessList);
                //
                // The queue was never idled so don't try to unidle it.
                //
                UnIdleProcessQueue = FALSE;
                FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Invalid Join Guid");
                goto CO_CLEANUP;
            }
            UNLOCK_CXTION_TABLE(Replica);
        }


        //
        // Check for a Control CO request.  This is a change order entry
        // with a special flag set.  It used for things that have to be
        // serialized with respect to other change orders already in the
        // process queue.
        //
        if (ControlCo) {

            //
            // Remove the entry from the queue and idle the queue.
            // Process the control change order, drop the queue lock and clean up.
            //
            FrsRtlRemoveEntryQueueLock(IdledQueue, &ChangeOrder->ProcessList);
            FrsRtlIdleQueueLock(IdledQueue);

            ChgOrdProcessControlCo(ChangeOrder, Replica);

            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            goto CO_CLEANUP;
        }

        //
        // Translate the Fids to Guids for Local COs and vice versa for remote COs.
        // Get the IDTable delete status for the target and the original and
        // new parent dirs.
        //
        ChgOrdTranslateGuidFid(ThreadCtx, TmpIDTableCtx, ChangeOrder, Replica);

        //
        // Make sure we still have the FID in the IDTable for a Local
        // change order if we are recovering after a crash.
        //
        if (LocalCo && RecoveryCo &&
            (ChangeOrder->FileReferenceNumber == ZERO_FID)) {
            //
            // A local recovery CO can have a zero fid if there is no
            // idtable record for the CO. This can happen if we crashed
            // after deleting the idtable record but before deleting the
            // inlog record for the CO. Reject the CO so that the inlog
            // record can be cleaned up.
            //
            DPRINT(0, "++ ERROR - local recovery change order has 0 fid; reject\n");
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected; zero fid");
            FRS_PRINT_TYPE(0, ChangeOrder);

//            FRS_ASSERT(!"local recovery change order has 0 fid");

            FrsRtlRemoveEntryQueueLock(IdledQueue, &ChangeOrder->ProcessList);
            //
            // The queue was never idled so don't try to unidle it.
            //
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            UnIdleProcessQueue = FALSE;
            ChgOrdReject(ChangeOrder, Replica);
            goto CO_CLEANUP;
        }

        //
        // Check for a dependency between this change order and the currently
        // active change orders.  If there is one then we idle the process
        // queue and the active state is marked to unidle it when the conflicting
        // CO is done. Since the queue is now idled we won't pick the CO up the
        // next time around the loop.
        //
        Decision = (SerializeAllChangeOrders) ?
                    ISSUE_OK : ChgOrdHoldIssue(Replica, ChangeOrder, IdledQueue);
        if (Decision == ISSUE_CONFLICT) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Issue Blocked");
            DPRINT(4, "++ GAC: Conflict with active change order or Join wait.\n");
            DPRINT1(4, "++ GAC: CO process queue: %ws is blocked.\n",
                     Replica->pVme->FSVolInfo.VolumeLabel);
            //
            //  Drop the process queue lock.
            //
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            UnIdleProcessQueue = FALSE;
            goto CO_CONTINUE;
        }

        //
        // Check to see if this CO is a duplicate of a currently active CO.
        // If it is then ChgOrdHoldIssue() has removed the duplicate entry
        // from the queue.  We insert it into the inbound log in the event
        // that the currently executing CO fails.  Even if it succeeds we will
        // reject this CO later and send an Ack to the inbound partner at that
        // time.
        //
        DuplicateCo = (Decision == ISSUE_DUPLICATE_REMOTE_CO);
        if (DuplicateCo) {
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Dup Remote Co");
            UnIdleProcessQueue = FALSE;
            goto CO_DEFER_DUP_CO;
        }

        //
        // Before we try to reserve a retire slot, check to see if CO needs
        // to be retried later.  Occurs when parent dir not yet created.
        //
        if (Decision == ISSUE_RETRY_LATER) {
            //
            // Retry this CO later.  Set DuplicateCO to alert retry thread.
            // Note:  This should only happen from remote COs.  If this happened
            // on a first-time-issue Local Co there would be no IDTable entry
            // present for xlate the Guid to a Fid since we haven't inserted
            // one yet.
            //
            FRS_ASSERT(!(LocalCo && !(RetryCo || RecoveryCo)));
            DuplicateCo = TRUE;
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            UnIdleProcessQueue = FALSE;

            if (ParentReanimation) {
                //
                // Don't retry parent reanimation COs.  The base CO will get
                // retried and regenerate the reanimation request.  In this
                // case the parent's parent was absent from the IDTable.  This
                // could happen if we got a tombstone for the parent and have
                // not yet seen anything for its parent.  Then a child create
                // for the tombstoned parent shows up.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Parent Reanimate. Absent Parent");
                ChgOrdReject(ChangeOrder, Replica);
                goto CO_CLEANUP;
            }

            CHANGE_ORDER_TRACE(3, ChangeOrder, "ISSUE_RETRY_LATER");
            //
            // How long are we going to wait for the parent to show up?
            // Need to run a cleanup thread periodically to look for
            // stranded COs and force them to cleanup and abort.
            // See bug 70953 for a description of the problem.
            //
            goto CO_RETRY_LATER;
        }


        //
        // Always Reserve a VV retire slot for remote COs since even if
        // it's rejected a VV update and partner ACK are still needed.
        // But, if this is a demand refresh CO (i.e. we demanded a file
        // refresh from our inbound partner) then there is no Version Vector
        // update and no CO in our inbound partner's outbound log to Ack.
        //
        // Do it here so we filter out the duplicate remote CO's first.
        //
        if (!LocalCo && !DemandRefreshCo) {

            FStatus = VVReserveRetireSlot(Replica, ChangeOrder);
            //
            // Check if a prior CO left an activated slot on VV retire list.
            // If it did and this CO is marked activated then this slot is
            // for our CO and we are doing a retry.  Otherwise the slot is for
            // a different CO and so we either insert it in the INLOG or just
            // skip it for now if it's a retry.  Note: If we crashed then we
            // lost the VV retire list so we don't get a duplicate key return.
            // The CO is marked as a recovery CO when it is reprocessed so as
            // to bypass some error checks that would apply to non-recovery COs.
            //
            if (FStatus == FrsErrorKeyDuplicate) {
                //
                // If this CO has VV_ACTIVATE set then this VV entry is ours.
                // We are now a retry CO since we couldn't quite finish before.
                // If this CO does not have VV_ACTIVATE set then it must be a dup.
                // Reject the dup CO and ACk the partner. The VV entry is activated
                // so it means that it is safe to ack the CO. The original CO
                // that activated the entry may or may not be in the inlog.
                //
                DuplicateCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED);
                if (DuplicateCo) {
                    FrsRtlRemoveEntryQueueLock(IdledQueue, &ChangeOrder->ProcessList);
                    FrsRtlIdleQueueLock(IdledQueue);
                    FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
                    CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

                    ChgOrdReject(ChangeOrder, Replica);
                    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV);
                    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
                    goto CO_CLEANUP;

                } else {
                    //
                    // This is a remote CO with VV_ACTIVATED flag set so
                    // it should be a retry change order.
                    // The state should be greater than IBCO_FETCH_RETRY or
                    // it wouldn't be activated.  It could be in an install or
                    // a rename retry state.
                    //
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Retry remote CO");
                    FRS_ASSERT(RetryCo);
                    FRS_ASSERT(!CO_STATE_IS_LE(ChangeOrder, IBCO_FETCH_RETRY));
                    //ChgOrdReject(ChangeOrder, Replica);
                    //goto CO_CLEANUP;
                }
            }
        }

        //
        // If this Remote CO should be rejected then do it now.
        // ChgOrdHoldIssue() has removed the CO from the queue.
        //
        if (Decision == ISSUE_REJECT_CO) {
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected");
            ChgOrdReject(ChangeOrder, Replica);
            UnIdleProcessQueue = FALSE;
            goto CO_CLEANUP;
        }

        //
        // No conflict we can issue the Change Order.
        // Remove the entry from the queue and idle the queue.
        //
        FrsRtlRemoveEntryQueueLock(IdledQueue, &ChangeOrder->ProcessList);
        FrsRtlIdleQueueLock(IdledQueue);


        //
        // We now have the change order off the queue.  Drop the locks blocking
        // the journal lookup.  If the Journal was about to update this change
        // order it will now not find it in the volume ChangeOrderTable so it
        // creates a new one.
        //
        FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
        //
        // Not on the process list now.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

        FRS_ASSERT(pVme == Replica->pVme);

        //
        // Allocate the replica thread context (RtCtx) for the change
        // order's DB operations.  Link it to the Replica context list head.
        // We then use this to carry the DB related state of the CO thru the
        // system.  It also allows us to queue the CO retire operation to
        // the DB system where it will have all the data to perform the
        // changeorder entry update/delete and the IDTable update.
        //
        // To make the above work we can't return any state relative to
        // specific table transactions thru the replica struct.
        //
        // Check on Replica->FStatus.
        //
        // Use RtCtx or cmdpkt instead.  The ChangeOrder needs a ptr to the
        // RtCtx.  When the ChangeOrder is done all RtCtx tables are closed,
        // The RtCtx is removed from the replica and thread ctx lists and the
        // memory is freed.  Also check that mult concurrent transactions on a
        // replica set sync access to the config record in the replica struct.
        // Before a thread passes the changeorder (and hence the RtCtx) on to
        // another thread it will have to make sure any open tables are closed
        // because the table opens are ThreadCtx specific.
        //
        // Note: If this is a Retry CO it will already have a RtCtx if we
        // got it through VVReferenceRetireSlot().  So don't alloc another.
        //
        RtCtx = ChangeOrder->RtCtx;
        if (RtCtx == NULL) {
            RtCtx = FrsAllocTypeSize(REPLICA_THREAD_TYPE,
                                     FLAG_FRSALLOC_NO_ALLOC_TBL_CTX);
            FrsRtlInsertTailList(&Replica->ReplicaCtxListHead,
                                 &RtCtx->ReplicaCtxList);
            ChangeOrder->RtCtx = RtCtx;
        } else {
            //
            // Add LocalCo because a localco winner of a name morph conflict
            // will have generated a loser-rename-co before running. The act
            // of generating the loser-rename-co leaves the original localco
            // with an RtCtx.
            //
            FRS_ASSERT(RetryCo || ParentReanimation || MorphGenCo || LocalCo);
        }
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_RTCTX);

        IDTableCtx    = &RtCtx->IDTable;
        DIRTableCtx   = &RtCtx->DIRTable;
        InLogTableCtx = &RtCtx->INLOGTable;

        //
        // Read or initialize an IDTable Record for this file.
        // Insert the GUIDs for originator, File, Old and new parent.
        // FrsErrorNotFound indicates a new record has been initialized.
        //
        FStatus = ChgOrdReadIDRecord(ThreadCtx,
                                     IDTableCtx,
                                     TmpIDTableCtxNC,
                                     ChangeOrder,
                                     Replica,
                                     &IDTableRecExists);

        //
        // If we have detected and fixed a tunnel conflict that remapped
        // the File Guid to a new file instance (File ID).
        // Need to restart processing of this CO as we would for a
        // reanimated parent dir.  This ensures that the CO issue interlock
        // checks made in ChgOrdHoldIssue get rechecked.
        //
        if (FStatus == FrsErrorTunnelConflict) {
            //
            // Do the change order cleanup but don't free the CO.
            //
            CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

            if (!LocalCo && !DemandRefreshCo) {
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
            }

            FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
            DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);
            //
            // Push this CO onto the head of the queue.
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push Tunnel Retry to QHead");
            WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD | IPQ_TAKE_COREF |
                                        IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
            if (!WIN_SUCCESS(WStatus)) {
                //
                // Insert CO onto process queue failed probably beccause process
                // queue has been run down.
                //
                ReleaseVmeRef(pVme);
                WStatus = ERROR_OPERATION_ABORTED;
                break;
            }

            //
            // The above put the CO back on the list so set the MorphGenCo flag so
            // we don't decrement the LocalCoQueueCount at the bottom of the loop.
            //
            MorphGenCo = TRUE;

            //
            //  CO ready to restart.
            //
            ChangeOrder = NULL;
            IDTableRec = NULL;
            goto CO_CONTINUE;
        }


        //
        // Get ptr to ID Table record.
        //
        IDTableRec = (PIDTABLE_RECORD) (IDTableCtx->pDataRecord);

        NameMorphConflict = (FStatus == FrsErrorNameMorphConflict);

        NewFile           = (FStatus == FrsErrorNotFound)       ||
            IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);

        if ((FStatus == FrsErrorTunnelConflictRejectCO) ||
            (!FRS_SUCCESS(FStatus) && !(NewFile || NameMorphConflict))) {
            CHANGE_ORDER_TRACEF(3, ChangeOrder, "Co Rejected", FStatus);
            ChgOrdReject(ChangeOrder, Replica);
            goto CO_CLEANUP;
        }




        //
        // If this CO is on a new file and it's a Morph generated Co then
        // the morph conflict may no longer exist because of the outcome of
        // a prior change order (e.g. it got aborted).
        // There are two case to consider: A MORPH_GEN_LEADER or a
        // MORPH_GEN_FOLLOWER.
        //
        if (NewFile && MorphGenCo) {
            if (COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER)) {

                // MorphGenFollower:  This is the rename MorphGenCo produced
                // as part of a Dir/Dir Name Morph Conflict (DLD Case).  The
                // fact that Newfile is TRUE means that the base create CO
                // (the leader) failed and is in retry so reject this MorphGenCo.
                // It gets refabricated later when the Leader is re-issued.
                //  ***** Note -- THere is similar code in ChgOrdHoldIssue() *****
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - MORPH_GEN_FOLLOWER");
                ChgOrdReject(ChangeOrder, Replica);
                goto CO_CLEANUP;
            } else {
                //
                // Do not pitch MorphGen Delete Cos.  An incoming Create Co that
                // looses the name conflict produces a MorphGenLeader DelCo
                // with no IDTable Entry.
                //  ***** Note -- THere is similar code in ChgOrdHoldIssue() *****
                //
                if ((LocationCmd != CO_LOCATION_DELETE) &&
                     BooleanFlagOn(ChangeOrder->Cmd.ContentCmd, USN_REASON_RENAME_NEW_NAME)) {
                    //
                    // MorphGenLeader: This is the rename MorphGenCo produced as
                    // part of a Dir/Dir Name
                    // Morph Conflict where ID table loses name (DDL Case).
                    // This CO is intended to free up the name so that the base CO can
                    // issue. The fact that Newfile is TRUE means that the conflicting
                    // ID table entry either does not exist any more or is still in
                    // NewFileInProgress state. Either way the conflicting dir is not
                    // on disk so the base CO will be able to proceed.
                    // Reject the Morph CO at this point.
                    //
                    if (!IDTableRecExists) {
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - MORPH_GEN_LEADER");
                        ChgOrdReject(ChangeOrder, Replica);
                        goto CO_CLEANUP;

                    } else {
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "**** WARN - MORPH_GEN_LEADER but IDT entry exists");
                        DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, TRUE);
                        FRS_PRINT_TYPE(3, ChangeOrder);
                        //
                        // IDTable record exists - Implies NewFileInProgress so
                        // there is at least one CO that is working on the ID table
                        // entry (probably in retry).  We end up deleting the ID
                        // table entry as part of reject here.
                        // (ISCU_DEL_IDT_ENTRY).  That is not a problem as the CO
                        // that is working on it will recreate it when it gets
                        // reissued again and will notice the name morph with our
                        // base CO and will do the right thing.
                        //
                        // WARN:
                        // This may cause problems so for now don't do it and
                        // wait for better data on this case.
                        //

                        //  SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_IDT_ENTRY);
                    }
                }
            }
        }



        if (LocalCo && !NewFile) {
            ChgOrdSkipBasicInfoChange(ChangeOrder, &SkipCo);
            if (SkipCo) {
                //
                // Skip some basic info changes on local change orders
                // but update the last USN field in the IDTable record so
                // we don't get confused later in staging and think another
                // change order will be coming with a more recent USN.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Basicinfo");
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_UPDATE_IDT_FILEUSN);
                ChgOrdReject(ChangeOrder, Replica);
                goto CO_CLEANUP;
            }
        }



        //
        // Now decide if we accept this change order. This deals with the
        // problem of multiple updates to the same file at different
        // replica set members.  In most cases the decision to accept the
        // change is final.  However it is possible for the target file on
        // this machine to be modified directly between now and the time
        // when we actually install the file.  As an example a slow or
        // faulty network could delay the fetch of the staging file from
        // the inbound partner (perhaps for hours or days).  To deal with this
        // case we capture the file's USN now and then we check it again
        // just before the final stage of the install.
        //
        // If this is a new file (not in our IDTable) we accept unless this
        // is a retry of a previous delete that has been superceded by
        // a reanimation.  In the latter case, let reconcile have a look.
        //
        // If the Re-animate flag is set then we have already accepted this CO.
        // Otherwise use reconcilliation algorithm to decide accept or reject.
        //
        // What if the reanimation co is a recoveryco or a retryco? Shouldn't
        // reconcile be called? Should REANIMATION be cleared when a co
        // is taken through retry?
        //

        if (NewFile && !CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - NewFile");
            goto CO_ACCEPT;
        }

        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION) &&
            !COE_FLAG_ON(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - Reanimated");
            goto CO_ACCEPT;
        }

        if (ChgOrdReconcile(Replica,
                            ChangeOrder,
                            (PIDTABLE_RECORD) IDTableCtx->pDataRecord)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - Reconcile");
            goto CO_ACCEPT;
        }

        //
        // This CO is rejected.  Set necessary cleanup flags and go clean it up.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Reconcile");
        ChgOrdReject(ChangeOrder, Replica);
        goto CO_CLEANUP;


CO_ACCEPT:


        //
        // This Change Order is being accepted.  Now check for a Name Conflict
        // in the parent dir.  This may have been detected above when we searched
        // for the IDTable record or it may have been detected in the past and
        // this CO was marked as a MorphGenLeader and it needs to refabricate
        // the MorphGenFollower rename CO because the leader got sent thru
        // the retry path.
        //
        if (NameMorphConflict ||
             (CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER) &&
              !COE_FLAG_ON(ChangeOrder, COE_FLAG_MG_FOLLOWER_MADE))) {

            //
            // Increment the Local and Remote CO Morphed counter
            //
            if (LocalCo) {
                PM_INC_CTR_REPSET(Replica, LCOMorphed, 1);
            }
            else {
                PM_INC_CTR_REPSET(Replica, RCOMorphed, 1);
            }

            MorphOK = ChgOrdGenMorphCo(ThreadCtx,
                                       TmpIDTableCtxNC,
                                       ChangeOrder,
                                       Replica);
            //
            // If the code above put the change order back on the list then
            // set the MorphGenCo flag so we don't decrement the
            // LocalCoQueueCount at the bottom of the loop.
            //
            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_ONLIST)) {
                MorphGenCo = TRUE;
            }

            if (!MorphOK) {
                //
                // Local Co's that fail to generate a Morph Co on the first time
                // through (i.e. not a Retry or Recovery CO) must be rejected
                // since there is no IDTable entry made that will translate the
                // GUID to the FID when the CO is later retried.
                //
                if (LocalCo && !(RetryCo || RecoveryCo)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Morph failure");
                    ChgOrdReject(ChangeOrder, Replica);
                    goto CO_CLEANUP;
                }
                //
                // If this is a parent reanimation CO that has encountered a
                // name morph conflict for the second time then reject it and
                // let the base CO go thru retry.  A case where this can happen
                // is when a reanimated parent causes a name morph conflict
                // in which it wins the name from the current owner in the
                // IDTable (the DDL case.)  But the rename MorphGenCo that was
                // going to free the name failed because the underlying file
                // was deleted (by a local file op).  Now the reanimation CO
                // for the winner of the name re-issues and hits the name morph
                // conflict again.  This time it has COE_FLAG_MORPH_GEN_FOLLOWER
                // set so  ChgOrdGenMorphCo() returns failure.  Since this is
                // a parent reanimation CO it should not go thru retry, instead
                // the base CO will go thru retry.  This lets the local CO that
                // deleted the parent get processed so when the base CO is later
                // retried and reanimates the parent, there won't be a name morph
                // conflict.
                //
                if (ParentReanimation) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Parent Reanimate Morph failure");
                    ChgOrdReject(ChangeOrder, Replica);
                    goto CO_CLEANUP;
                }

                //
                // Retry this CO later.  Set DuplicateCO to alert retry thread.
                //
                DuplicateCo = TRUE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Retry Later");
                goto CO_RETRY_LATER;
            }

            //
            // Loop back to the top and process the new CO.
            //
            ChangeOrder = NULL;
            IDTableRec = NULL;
            goto CO_CONTINUE;
        }

        //
        // The new change order has been accepted.
        //
        DBS_DISPLAY_RECORD_SEV(4, IDTableCtx, FALSE);

        //
        // Check for accepted Delete Co that missed in the IDTable.
        // This is a remote CO delete that arrived before the create.
        // Create a tombstone in the IDTable.
        // A second case is a delete Co that arrives after the file has been
        // deleted but has more recent event time info.  We need to process
        // this and update the IDTable to ensure a correct outcome if an update
        // CO were to arrive from a third originator.  See comment in
        // ChgOrdReadIDRecord() re: "Del Co rcvd on deleted file".
        //
        JustTombstone = (//!LocalCo &&
            (NewFile || IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) &&
            (CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_DELETE) ||
             CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_MOVEOUT)));

        if (JustTombstone) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_JUST_TOMBSTONE);
            ReAnimate = FALSE;
            goto CO_SKIP_REANIMATE;
        }

        //
        // If this is a MOVEOUT Local CO on a directory then enumerate the
        // IDTable and generate delete COs for all the children.  The Journal
        // sends the MOVEOUT to us in a bottom up order using the directory
        // filter table.
        //
        if (LocalCo &&
            CoIsDirectory(ChangeOrder) &&
            CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_MOVEOUT) &&
            !COE_FLAG_ON(ChangeOrder, COE_FLAG_MOVEOUT_ENUM_DONE)) {

            SET_COE_FLAG(ChangeOrder, COE_FLAG_MOVEOUT_ENUM_DONE);

            //
            // Push this CO back onto the front of the CO Process queue
            // and then generate Delete COs for each child.
            // Do the change order cleanup but don't free the CO.
            //
            CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

            FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
            DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

            //
            // Initialize context block before CO is pushed back to queue.
            //
            MoveOutContext.NumFiles = 0;
            MoveOutContext.ParentFileID = ChangeOrder->FileReferenceNumber;
            MoveOutContext.Replica = Replica;

            //
            // Push this CO onto the head of the queue.
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push MOVEOUT DIR CO to QHead");

            WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD |
                                        IPQ_TAKE_COREF | IPQ_ASSERT_IF_ERR);
            if (!WIN_SUCCESS(WStatus)) {
                ChgOrdReject(ChangeOrder, Replica);
                goto CO_CLEANUP;
            }

            ChangeOrder = NULL;

            //
            // The above put the change order back on the list so
            // set the MorphGenCo flag so we don't decrement the
            // LocalCoQueueCount at the bottom of the loop.
            //
            MorphGenCo = TRUE;

            //
            // Walk through the IDTable and Generate delete COs for each child
            // by calling ChgOrdMoveoutWorker() for this Replica.
            //
            jerr = DbsOpenTable(ThreadCtx, TmpIDTableCtx, Replica->ReplicaNumber, IDTablex, NULL);
            if (!JET_SUCCESS(jerr)) {
                DPRINT_JS(0, "++ ERROR - IDTable Open Failed:", jerr);
                ChgOrdReject(ChangeOrder, Replica);
                goto CO_CLEANUP;
            }

            jerr = FrsEnumerateTable(ThreadCtx,
                                     TmpIDTableCtx,
                                     GuidIndexx,
                                     ChgOrdMoveoutWorker,
                                     &MoveOutContext);
            if (jerr != JET_errNoCurrentRecord) {
                DPRINT_JS(0, "++ FrsEnumerateTable error:", jerr);
            }

            DPRINT1(4, "++ MoveOut dir done:  %d files\n", MoveOutContext.NumFiles);

            //
            // Close the IDTable, reset TableCtx Tid and Sesid.   Macro writes 1st arg.
            //
            DbsCloseTable(jerr, ThreadCtx->JSesid, TmpIDTableCtx);

            //
            // Loop back to the top and process the new delete COs.
            //
            IDTableRec = NULL;
            goto CO_CONTINUE;
        }

        //
        // Does this CO need reanimation?
        // Do not treat MorphGenCos for local deletes as reanimate cos.
        //
        // 1. A remote co for an update comes in for a tombstoned
        //    idtable entry.
        //
        // 2. The remote co becomes a reanimate co.
        //
        // 3. The reanimate remote co loses a name conflict to
        //    another idtable entry.
        //
        // 4. A MorphGenCo for a local delete is generated for the
        //    reanimate remote co that lost the name conflict.
        //
        // 5. The MorphGenCo is treated as a reanimate co because the
        //    idtable entry is deleted. This MorphGenCo for a local
        //    delete becomes a MorphGenCo for a local *CREATE* later in
        //    this function. Things go downhill from there.
        //
        //
        ReAnimate = (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED) &&
                   (!DOES_CO_DELETE_FILE_NAME(CoCmd)) &&
                   !(MorphGenCo && (LocationCmd == CO_LOCATION_DELETE)));

        //
        // Change order is accepted.  Check if the parent dir is deleted.
        // This could happen if one member deletes the parent dir while another
        // member creates a new file or updates what had been a deleted file
        // underneath the parent.  In this situation the parent dir is recreated
        // by fetching it from the inbound parent that sent us this CO.
        //
        // Do we need to check that the LocationCmd is not a Moveout,
        // movedir, movers, or a delete?  Delete and moveout were filtered
        // when we read the IDTable record above.  The test below will
        // select the IDT_NEW_PARENT_DEL test in the case of a movedir or
        // movers so an additional test of the location cmd should not be necc.
        //

        if (ChangeOrder->NewReplica != NULL) {
            RaiseTheDead = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL);
        } else {
            RaiseTheDead = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_DEL);
        }

        if (RaiseTheDead) {
            RStatus = ChgOrdReanimate(IDTableCtx,
                                      ChangeOrder,
                                      Replica,
                                      ThreadCtx,
                                      TmpIDTableCtx);

            switch (RStatus) {

            case REANIMATE_SUCCESS:
                //
                // Parent reanimated.  Go Issue the CO for it.
                //
                ChangeOrder = NULL;
                IDTableRec = NULL;
                goto CO_CONTINUE;

            case REANIMATE_CO_REJECTED:
                //
                // Can't do the reanimation.  Could be a local co or a nested
                // reanimation failed and now we are failing all nested parents
                // back to the base CO.
                //
                IDTableRec = NULL;
                goto CO_CLEANUP;

            case REANIMATE_FAILED:
                //
                // This is a system failure.   Can't insert CO on process queue
                // probably beccause process queue has been run down.
                //
                ReleaseVmeRef(pVme);
                break;

            case REAMIMATE_RETRY_LATER:
                //
                // Local Co's that fail to reanimate the parent could occur if
                // both the file and the parent have been deleted out from under
                // us.  This might happen in an obscure case where the local
                // child create ends up in a race with a remote co file create
                // that is followed immediately by a remote co file delete and a
                // parent dir delete.  The remote COs would have to arrive just
                // before the local CO create was inserted into the process
                // queue.  There would be no IDTable name conflict when the
                // remote CO is processed so the remote CO create would just
                // take over the file name.  Later when the local CO create is
                // processed our attempt to reanimate the parent will fail.  I'm
                // not even sure this can really happen but if it did and this
                // is the first time through (i.e.  not a Retry or Recovery CO)
                // the CO must be rejected since there is no IDTable entry made
                // that will translate the GUID to the FID when the CO is later
                // retried.
                //
                //
                // It doesn't seem like the above scenario actually happens.
                // There is however a problem when we fail a reanimation
                // triggered by a local Co and then abort the CO. (bug 464476)
                //
/*

                if (LocalCo && !(RetryCo || RecoveryCo)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Parent Reanimate failed");
                    ChgOrdReject(ChangeOrder, Replica);
                    goto CO_CLEANUP;
                }
*/

                //
                // Retry this CO later.  Set DuplicateCO to alert retry thread.
                // This can happen if it's the base CO and we failed to
                // reanimate one of the parents.
                //
                DuplicateCo = TRUE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Reanimate Retry Later");
                goto CO_RETRY_LATER;

            case REANIMATE_NO_NEED:
                //
                // No need to raise the co's parent because this is a
                // delete change order. This can happen if the file
                // is stuck in the preinstall or staging areas and isn't
                // really under its parent.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Reanimate Parent Not Needed");
                break;

            default:

                DPRINT1(0, "++ ERROR: Invalid status return from ChgOrdReanimate: %d\n",
                       RStatus);
                FRS_ASSERT(!"Invalid status return from ChgOrdReanimate");

            }

            if (RStatus == REANIMATE_FAILED) {
                //
                // This is a system failure.   See above.
                //
                WStatus = ERROR_OPERATION_ABORTED;
                break;
            }
        }


CO_SKIP_REANIMATE:
        //
        // Is a CO reanimation (but not a collateral parent reanimation)?
        // location cmd could have changed in some function calls above.
        //
        LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

        if (ReAnimate && !ParentReanimation) {

            CHANGE_ORDER_TRACE(3, ChangeOrder, "Issue Reanimated Target");

            //
            // Clear the IDTable Flags and transform the CO into a create.
            // If the location cmd was a movein then leave it alone since
            // code elsewhere needs to know.
            //
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_ALL);

            if (!CO_NEW_FILE(LocationCmd)) {
                SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_CREATE);
                SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
                LocationCmd = CO_LOCATION_CREATE;
            }

            //
            // Set the IDREC_FLAGS_NEW_FILE_IN_PROGRESS flag so that the
            // CO gets renamed from preinstall file to final name even
            // after it goes through retry. (Bug # 138742)
            //
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);

            SET_COE_FLAG(ChangeOrder, COE_FLAG_REANIMATION);
            FRS_PRINT_TYPE(3, ChangeOrder);
        } else
        if (ParentReanimation) {

            CHANGE_ORDER_TRACE(3, ChangeOrder, "Issue Reanimated Parent");
        } else {
            CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_GROUP_REANIMATE);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "GO Issue");
        }


        if (LocalCo) {
            //
            // Local Co  --  Create the change order guid and update filesize.
            //
            //    Morph generated Cos got their COGuid when they were originally
            //    created (for tracking purposes).  If it's a retry or recovery
            //    CO then it came from the inlog and already has a COGuid.
            //
            if (!MorphGenCo && !RetryCo && !RecoveryCo) {
                FrsUuidCreate(&CoCmd->ChangeOrderGuid);
            }

            CoCmd->FileSize = IDTableRec->FileSize;

            //
            // If it is a morph generated Co then perform the file op that
            // frees the name.  Have to wait until at least this point
            // because otherwise there could be an outstanding CO working
            // on the file.  Only Morph generated COs that matter here are
            // those that already have an ID table entry.
            // If this is a MOVEOUT generated Delete Co then NO local op is done.
            //
            if (!NewFile && MorphGenCo &&
                !COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {

                if (!ChgOrdApplyMorphCo(ChangeOrder, Replica)) {
                    goto CO_CLEANUP;
                }

            }

        } else {
            //
            // Remote Co  --  Check if this is a new file or an accepted
            // CO on a file that was previously deleted.
            //
            // A reanimation change order may be kicked through retry.
            // If so the FID may still be valid.  Code in ChgOrdReadIDRecord
            // has already checked this.  Another case is when the preinstall
            // file for a reanimated co could not be renamed into place
            // because of a sharing violation on the target parent dir so the
            // CO was kicked through retry in state IBCO_INSTALL_REN_RETRY.
            //
            // Note:  File is already present if COE_FLAG_NEED_DELETE is set
            //        because it is in the deferred delete state.
            //        Unless the FID is zero in wich case ChgOrdReadIDRecord()
            //        has determined that the FID was not valid.
            //
            if ((NewFile || ReAnimate) &&
                !JustTombstone &&
                   (!COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE) ||
                    (IDTableRec->FileID == ZERO_FID))  ) {

                if (IDTableRec->FileID == ZERO_FID) {
                    //
                    // This is a remote change order with a new or reanimated
                    // file or Dir.  Create the target file so we can get its
                    // FID for the ID and DIR Table Entries.  ChangeOrder's
                    // FileReferenceNumber field and the FileUsn field are
                    // filled in if the call succeeds.
                    //
                    WStatus = StuCreatePreInstallFile(ChangeOrder);
                    if (!WIN_SUCCESS(WStatus)) {
                        DPRINT1_WS(0, "++ WARN - StuCreatePreInstallFile(%ws) :",
                                   CoCmd->FileName, WStatus);

                        //
                        // NOTE - All failures to create a preinstall file should
                        // be retried, even hardware failures.  Once the hardware
                        // is fixed the retry should succeed.  The CO timeout
                        // code will pitch a problem CO after a week.
                        //
                        //if (!WIN_RETRY_PREINSTALL(WStatus)) {
                            //
                            // Not retriable; Give up!
                            //
                        //    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Preinstall");
                        //    ChgOrdReject(ChangeOrder, Replica);
                        //    goto CO_CLEANUP;
                        //}

                        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Retry - Preinstall");
                        RetryPreinstall = TRUE;
                        goto CO_RETRY_PREINSTALL;
                    }

                    IDTableRec->FileID = ChangeOrder->FileReferenceNumber;
                    //
                    // Clear COE_FLAG_NEED_DELETE so we don't assume we have
                    // the file/dir below and skip the refetch.
                    //
                    CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_NEED_DELETE);
                }
                //
                // Set flag to cleanup preinstall file if CO later aborts.
                //
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_PREINSTALL);
                SET_COE_FLAG(ChangeOrder, COE_FLAG_PREINSTALL_CRE);
            }
        }

        //
        // LOCAL or REMOTE CO:
        //
        // If this is a file create, insert the new entries in the ID Table.
        // If this is an update to an existing file then we don't update the
        // entry until the change order is retired.  If it aborted we would
        // have to roll it back and I'd rather not.  In addition if an outbound
        // partner needs to do a DB resync and we haven't finished a remote
        // CO install then we would be in the state of having new filter
        // info in the IDTable but old data in the disk file.
        //
        if (NewFile) {

            //
            // Write the new IDTable record into the database.
            //
            if (IDTableRecExists) {
                //
                // Info in the IDTable record inited by a prior CO that failed
                // to complete (e.g. a FID) may be stale.  The prior CO is most
                // likely in the retry state so update the IDTable record with
                // the state from the current CO.
                //
                FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                                      Replica,
                                                      IDTableCtx,
                                                      &IDTableRec->FileGuid,
                                                      GuidIndexx,
                                                      IDTablex);
                //
                // DirTable
                //
                if (FRS_SUCCESS(FStatus)) {
                   FStatus = ChgOrdInsertDirRecord(ThreadCtx,
                                                   DIRTableCtx,
                                                   IDTableRec,
                                                   ChangeOrder,
                                                   Replica,
                                                   FALSE);
                   //
                   // DirTable entry may not exist; create it
                   //
                   if (FStatus == FrsErrorNotFound) {
                       FStatus = ChgOrdInsertDirRecord(ThreadCtx,
                                                       DIRTableCtx,
                                                       IDTableRec,
                                                       ChangeOrder,
                                                       Replica,
                                                       TRUE);
                   }
                }
            } else if (JustTombstone) {
                FStatus = DbsInsertTable(ThreadCtx,
                                         Replica,
                                         IDTableCtx,
                                         IDTablex,
                                         NULL);
            } else {
                FStatus = ChgOrdInsertIDRecord(ThreadCtx,
                                               IDTableCtx,
                                               DIRTableCtx,
                                               ChangeOrder,
                                               Replica);
            }
            if (!FRS_SUCCESS(FStatus)) {
               DPRINT_FS(0, "++ ERROR - ChgOrdInsertIDRecord failed.", FStatus);
               CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - IDT Insert failed");
               ChgOrdReject(ChangeOrder, Replica);
               goto CO_CLEANUP;
            }
            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_IDT_ENTRY);
            //
            // Remember this is a new file so we can delete the IDTable entry
            // if the CO fails.
            //
            SET_CO_FLAG(ChangeOrder, CO_FLAG_NEW_FILE);

        } else if (ReAnimate) {
            //
            // Update the ID table record now to reflect the new fid and the
            // new name / parent.   to avoid problems if this change order is
            // kicked into retry.  One such problem occurs when the retry path
            // resurrects the id table entry with its old name by marking the
            // id table entry as "not deleted".  This could cause false name
            // morph conflicts later
            // if the old name is in conflict with another id table entry and
            // could potentially break the name morph logic or cause collisions
            // in the name conflict table.
            //
            CopyMemory(IDTableRec->FileName, CoCmd->FileName, CoCmd->FileNameLength);
            IDTableRec->FileName[CoCmd->FileNameLength/sizeof(WCHAR)] = UNICODE_NULL;

            IDTableRec->ParentFileID = ChangeOrder->NewParentFid;
            IDTableRec->ParentGuid   = CoCmd->NewParentGuid;

            CHANGE_ORDER_TRACE(3, ChangeOrder, "IDT Reanimate name field Update");

            // SUDARC-DEV

            // FRS_ASSERT(IDTableRec->ParentFileID != ZERO_FID);

            if (IDTableRec->ParentFileID == ZERO_FID) {
                DPRINT(4, "WARN - Parent fid is zero.\n");
            }

            // SUDARC-DEV


            FRS_ASSERT(IDTableRec->FileID != ZERO_FID);

            FStatus = DbsUpdateIDTableFields(ThreadCtx,
                                             Replica,
                                             ChangeOrder,
                                             IdtFieldReanimateList,
                                             IdtCoReanimateFieldCount);
            if (!FRS_SUCCESS(FStatus)) {
               DPRINT_FS(0, "++ ERROR - DbsUpdateIDTableFields();", FStatus);
               CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - IDT Update FID/Name failed");
               ChgOrdReject(ChangeOrder, Replica);
               goto CO_CLEANUP;
            }
       }

        //
        //  If this is not a retry of a prior CO or a recovery CO or a parent
        //  reanimation CO or a MorphGenCo or Move out generated CO
        //  then insert the change order into the Inbound Log.
        //
        if (!RetryCo &&
            !RecoveryCo &&
            !MorphGenCo &&
            !ParentReanimation &&
            !COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {

            FStatus = ChgOrdInsertInlogRecord(ThreadCtx,
                                              InLogTableCtx,
                                              ChangeOrder,
                                              Replica,
                                              DuplicateCo || RetryPreinstall);

            FRS_ASSERT(!IS_GUID_ZERO(ChangeOrder->pParentGuid));

            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "++ ERROR - ChgOrdInsertInlogRecord failed.", FStatus);
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - INLOG Insert Failed");

                ChgOrdReject(ChangeOrder, Replica);

                //
                // Check if this is a duplicate remote CO. In that case do not delete
                // the idtable entry or the preinstall file for this CO as there is
                // another CO in the inbound log that is still processing this file.
                // Check the state of the CO in the inbound log. If it has passed
                // the IBCO_FETCH_RETRY state then send the ack for this CO. If it
                // has not completed staging yet then do not send the ack for this CO.
                //


                if (FStatus == FrsErrorKeyDuplicate) {

                    //
                    // This is a duplicate CO so don't delete the preinstall file
                    // and the idtable record for it.
                    //
                    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_PREINSTALL);
                    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_IDT_ENTRY);

                    //
                    // Send an ack to the upstream member only if there is another CO in
                    // the inbound log and if its state is passed IBCO_FETCH_RETRY
                    // which we determine below by reading the record.
                    //

                    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND);

                    KeyArray[0] = (PVOID)&CoCmd->CxtionGuid;
                    KeyArray[1] = (PVOID)&CoCmd->ChangeOrderGuid;

                    jerr = DbsOpenTable(ThreadCtx, TmpINLOGTableCtx, Replica->ReplicaNumber, INLOGTablex, NULL);

                    if (!JET_SUCCESS(jerr)) {
                        DPRINT1_JS(0, "DbsOpenTable (INLOG) on replica number %d failed.",
                                   Replica->ReplicaNumber, jerr);
                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpINLOGTableCtx);
                        DbsFreeTableCtx(TmpINLOGTableCtx, 1);
                        ChgOrdReject(ChangeOrder, Replica);
                        goto CO_CLEANUP;
                    }

                    FStatus = DbsRecordOperationMKey(ThreadCtx,
                                                     ROP_READ,
                                                     KeyArray,
                                                     ILCxtionGuidCoGuidIndexx,
                                                     TmpINLOGTableCtx);


                    DPRINT_FS(0,"++ ERROR - DbsRecordOperationMKey failed.", FStatus);

                    //
                    // Send an ack to the upstream member only if there is another CO in
                    // the inbound log and if its state is passed IBCO_FETCH_RETRY
                    //

                    if (FRS_SUCCESS(FStatus)) {
                        DupCoCmd = (PCHANGE_ORDER_RECORD)TmpINLOGTableCtx->pDataRecord;

                        if (DupCoCmd->State > IBCO_FETCH_RETRY) {
                            CHANGE_ORDER_TRACE(3, ChangeOrder, "Dup Co setting ISCU_ACK_INBOUND");
                            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND);
                        }

                        DupCoCmd = NULL;
                    }

                    //
                    // Close the table and free the storage.
                    //
                    DbsCloseTable(jerr, ThreadCtx->JSesid, TmpINLOGTableCtx);
                    DPRINT_JS(0,"ERROR - JetCloseTable on TmpINLOGTableCtx failed :", jerr);

                    DbsFreeTableCtx(TmpINLOGTableCtx, 1);
                }

                goto CO_CLEANUP;
            } else {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co INLOG Insert");
            }
            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_INLOG);
        } else {
            if (MorphGenCo) {
                //
                // MorphGenCos are local Cos and start out in Staging Requested.
                //
                SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_STAGING_REQUESTED);
            }
        }

        /////////////////////////////////////////////////////////////////////
        //                                                                 //
        //  A file can end up with different names on different computers  //
        //  if an update wins out over a rename. The update will flow back //
        //  to the computers that have already executed the rename. The    //
        //  update must rename the file back to its original position.     //
        //  In some cases a movedir may get converted into a create when   //
        //  the original parent dir has been deleted.  So these creates    //
        //  could turn out to be implicit movedirs too.                    //
        //                                                                 //
        /////////////////////////////////////////////////////////////////////

        //
        // Not local change order
        // Not a control change order
        // Not a delete, movedir, moveout or movers
        //     unless it is a vvjoin CO (which could be a create or a delete)
        // BUT the parent or the file name are different than those in the ID
        // table.  This must be an update that won out over a previously
        // applied rename. Rename the file back to the name and parent at
        // the time of the update.
        //
        // VVJOIN COs are special cased to cover the following scenario,
        // A Dir move CO is still in the outbound log of upstream when the
        // connection vvjoins (because it was deleted and created again or
        // the outbound log has been trimmed) in this case we will get a vvjoin
        // create CO for a file at its new location. This vvjoin CO should
        // implicitly move the file or dir as the original CO for move is lost.
        //
        // However, in the case of delete change orders coming from a VVJoin
        // we just want to create the tombstone even if the file had moved
        // to a different parent before it was deleted on the upstream member.
        //
        LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

        if (!LocalCo && !ControlCo &&
               (    CO_NEW_FILE(LocationCmd) ||
                    !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCATION_CMD) ||
                    CO_FLAG_ON(ChangeOrder, CO_FLAG_VVJOIN_TO_ORIG)
               ) &&
               (    !GUIDS_EQUAL(&CoCmd->NewParentGuid, &IDTableRec->ParentGuid) ||
                    WSTR_NE(IDTableRec->FileName, CoCmd->FileName)
               )
           ) {

            //
            // Put out a trace record so we know when the new MOVEDIR cases hit.
            //
            if (FrsDoesCoAlterNameSpace(CoCmd) &&
                !CO_FLAG_ON(ChangeOrder, CO_FLAG_VVJOIN_TO_ORIG)) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "**** NEW Implicit MOVEDIR case");
            }

            ChangeOrder->OriginalParentFid = IDTableRec->ParentFileID;
            CoCmd->OldParentGuid           = IDTableRec->ParentGuid;
            //
            // Make it a MOVEDIR if the parent changed
            //
            if (!GUIDS_EQUAL(&CoCmd->NewParentGuid, &IDTableRec->ParentGuid)) {
                //
                // VVJOIN Cos do not have content command flag set so we should
                // set it here so that StuInstallStage installs the file after
                // moving it to the correct location.
                //
                // see above about no Implicit Movedir for delete Cos.
                // this was 256531 hit by Cox.
                //
                if (!DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                    CoCmd->ContentCmd |= USN_REASON_DATA_EXTEND;
                    SET_CO_FLAG(ChangeOrder, CO_FLAG_CONTENT_CMD);

                    SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
                    SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_MOVEDIR);
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Implicit MOVEDIR");
                    LocationCmd = CO_LOCATION_MOVEDIR;
                }

            //
            // Make it a simple rename if the parent did not change
            //
            } else {
                //
                // A simple rename does not have a location command and it
                // has a content command with the value USN_REASON_NEW_NAME.
                // The location command needs to be cleared so that StuInstallStage
                // correctly does the rename of the file to the correct location.
                // see above about no Implicit rename for delete Cos.
                //

                if (!DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                    CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
                    SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_NUM_CMD);
                    LocationCmd = CO_LOCATION_NUM_CMD;
                    SET_CO_FLAG(ChangeOrder, CO_FLAG_CONTENT_CMD);
                    CoCmd->ContentCmd |= USN_REASON_RENAME_NEW_NAME;
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Implicit RENAME");
                }
            }
        }

        //
        // Check for a Directory Enumerate pending on the IDTable entry for
        // this file.  If found, walk through and touch all the children.
        // Note that this could be triggered by some other CO that is
        // operating on this directory, not just the MOVEIN CO that put the
        // dir into the ENUM_PENDING state.  This solves the problem where
        // one CO does a MOVEIN of a subdir and a subsequent CO does a MOVEDIR
        // on a child dir before the parent of the child dir has the ENUM performed
        // on it.  (Actually not sure this can really happen because the
        // child dir would still not be in the replica set so the journal should
        // treat it as a MOVEIN.)
        //
        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_ENUM_PENDING)) {
            //
            // Do the enumeration.
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Enum Request Started");

            WStatus = ChgOrdMoveInDirTree(Replica, ChangeOrder);
            DPRINT1_WS(0, "++ ERROR - Failed to enum dir: %ws;",CoCmd->FileName, WStatus);

            //
            // Clear the flag bit in the IDTable record.
            //
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_ENUM_PENDING);
            FStatus = ChgOrdIssueCleanup(ThreadCtx,
                                         Replica,
                                         ChangeOrder,
                                         ISCU_NO_CLEANUP_MERGE |
                                         ISCU_UPDATE_IDT_FLAGS
                                         );
            DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);
        }

        //
        // If this CO is a Directory Enum request then we are now done so
        // clean it up.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_ENUM_REQUESTED)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Enum Request Completed");

            CLEAR_CO_IFLAG(ChangeOrder, CO_IFLAG_DIR_ENUM_PENDING);
            ChgOrdReject(ChangeOrder, Replica);
            goto CO_CLEANUP;
        }

        //
        //  Reserve resources for this CO in the hold issue interlock tables.
        //
        if (!ChgOrdReserve(IDTableRec, ChangeOrder, Replica)) {
            goto CO_CLEANUP;
        }
        //
        // PERF:  At this point we should be able to unidle the queue
        //       to let other threads grab a change order since the entry in
        //       the hash table provides the necessary interlock.
        //       TRY THIS LATER ONCE A SINGLE THREAD WORKS
        //
        if (SerializeAllChangeOrders) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);
        }

        //
        // Close the replica tables.   The RtCtx struct continues on with
        // the change order until it retires.
        //
        jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"++ ERROR - DbsCloseReplicaTables failed:", jerr);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Close Tbl Failed");
            ChgOrdReject(ChangeOrder, Replica);
            goto CO_CLEANUP;
        }


        //
        // If COE_FLAG_NEED_DELETE is set then the file is in the deferred
        // delete state which means the delete was never successfull
        // (say because of a sharing violation).  So we have the file.
        // We still need to fetch the file from upstream because we may
        // have a older copy of the file/dir. The only case when we
        // don't want to fetch the file from upstream is when a local
        // child create/update triggerred the reanimation of parent.
        // The upstream may or may not have the parent in this case.
        // As a future work we should send this parent reanimation CO
        // to our outbound partners so that all the members have the same
        // version of the parent.
        //
        // e.g. Everyone has V1 of parent.
        //      Member 2 locks V1.
        //      Everyone goes to V2 of parent.
        //      Member 1 locks V2
        //      Everyone deletes parent.
        //      Child created on M1 and M2.
        //      Both reanimate and keep their copy of parent.
        //      If parent reanimation is not sent out then both with have a different
        //      copy of parent.
        //
        FilePresent = COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE);
        if (FilePresent && LocalCo  && !ControlCo && ParentReanimation) {
            //
            // Retire the CO here if we already have the file and this is
            // a reanimation.  We don't need to have it deleted.
            //
            CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_NEED_DELETE);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "File Present");
            ChgOrdInboundRetired(ChangeOrder);
        } else {
            //
            // Dispatch the change order to the appropriate next stage.
            //
            FStatus = ChgOrdDispatch(ThreadCtx, IDTableRec, ChangeOrder, Replica);
            if (FStatus == FrsErrorCantMoveOut) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Retry - FrsErrorCantMoveOut");
                // Following is commented because we want to retry the delete of parent dir.
                // ChgOrdDispatch fails with FrsErrorCantMoveOut if there are
                // valid children under the parent dir.
//                ChgOrdReject(ChangeOrder, Replica);
//                goto CO_CLEANUP;
                goto CO_RETRY_LATER;
            }
        }




        ChangeOrder = NULL;
        //
        // The CO was issued but if we are serializing all change orders
        // on this volume then set the flag to leave the process queue idle.
        //
        UnIdleProcessQueue = !SerializeAllChangeOrders;
        goto CO_CONTINUE;



CO_RETRY_LATER:
CO_RETRY_PREINSTALL:
CO_DEFER_DUP_CO:
        //
        // This is a duplicate CO which cannot be processed right now.
        // If it's not a retry then insert CO into the inbound log.
        // Either way, skip it for now.  We should never be here with a
        // deamnd refresh flag set in the CO because we should detect
        // the case of a dup CO before we know the file is deleted.
        //
        if (!RetryCo && !RecoveryCo  && !MorphGenCo) {
            FRS_ASSERT(!CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH));

            FStatus = ChgOrdInsertInlogRecord(ThreadCtx,
                                              TmpINLOGTableCtx,
                                              ChangeOrder,
                                              Replica,
                                              DuplicateCo || RetryPreinstall);

            FRS_ASSERT(!IS_GUID_ZERO(ChangeOrder->pParentGuid));

            //
            // The pDataRecord points to the change order command which will
            // be freed with the change order.  Also clear the Jet Set/Ret Col
            // address fields for the Change Order Extension buffer to
            // prevent reuse since that buffer also goes with the change order.
            //
            TmpINLOGTableCtx->pDataRecord = NULL;
            DBS_SET_FIELD_ADDRESS(TmpINLOGTableCtx, COExtensionx, NULL);

            if (FStatus == FrsErrorKeyDuplicate) {
                //
                // Got a new dup remote co before we could finish and ack the
                // previous one.  Probably a result of restart.  Discard this
                // one.  Send an ack to the upstream member only if there the
                // CO in the inbound log has passed IBCO_FETCH_RETRY state
                // (which means it has already sent its Ack, which was
                // probably dropped, and won't send another) which we
                // determine below by reading the record.
                //
                FRS_ASSERT(!LocalCo);
                ChgOrdReject(ChangeOrder, Replica);

                //
                // Do not discard the vv slot as it is being used by the duplicate
                // Change order.
                //
                CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND |
                                                 ISCU_ACTIVATE_VV |
                                                 ISCU_ACTIVATE_VV_DISCARD);

                KeyArray[0] = (PVOID)&CoCmd->CxtionGuid;
                KeyArray[1] = (PVOID)&CoCmd->ChangeOrderGuid;

                jerr = DbsOpenTable(ThreadCtx, TmpINLOGTableCtx, Replica->ReplicaNumber, INLOGTablex, NULL);

                if (!JET_SUCCESS(jerr)) {
                    DPRINT1_JS(0, "DbsOpenTable (INLOG) on replica number %d failed.",
                               Replica->ReplicaNumber, jerr);
                    DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpINLOGTableCtx);
                    DbsFreeTableCtx(TmpINLOGTableCtx, 1);
                    goto CO_CLEANUP;
                }

                FStatus = DbsRecordOperationMKey(ThreadCtx,
                                                 ROP_READ,
                                                 KeyArray,
                                                 ILCxtionGuidCoGuidIndexx,
                                                 TmpINLOGTableCtx);


                DPRINT_FS(0,"++ ERROR - DbsRecordOperationMKey failed.", FStatus);

                if (FRS_SUCCESS(FStatus)) {
                    DupCoCmd = (PCHANGE_ORDER_RECORD)TmpINLOGTableCtx->pDataRecord;

                    if (DupCoCmd->State > IBCO_FETCH_RETRY) {
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "Dup Co setting ISCU_ACK_INBOUND");
                        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND);
                    }

                    DupCoCmd = NULL;
                }

                //
                // Close the table and free the storage.
                //
                DbsCloseTable(jerr, ThreadCtx->JSesid, TmpINLOGTableCtx);
                DPRINT_JS(0,"ERROR - JetCloseTable on TmpINLOGTableCtx failed :", jerr);

                DbsFreeTableCtx(TmpINLOGTableCtx, 1);

            } else

            if (!FRS_SUCCESS(FStatus)) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - INLOG Insert Failed");
                DPRINT_FS(0, "++ ERROR - ChgOrdInsertInlogRecord failed.", FStatus);
                FRS_ASSERT(!"INLOG Insert Failed");
                ChgOrdReject(ChangeOrder, Replica);
            }
        } else {
            //
            // Set the retry flag so we will try again later.
            //
            InterlockedIncrement(&Replica->InLogRetryCount);
        }


CO_CLEANUP:
        //
        // In general a branch to this point indicates that the entry in the
        // InLog did not get done.  If the CO was rejected for other reasons
        // we flow through here to cleanup state.  If it was a remote CO then
        // update the entry in the Version vector for dampening and Ack the
        // Co to our inbound partner.  We also get here if we are draining
        // the COs for this cxtion from the process queue.
        //
        FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
        DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

CO_CONTINUE:
        //
        // All done.  Decrement local change order queue count for this
        // replica at the end so there is no window during which a save mark
        // could occur and see a zero count even though we have yet to
        // actually insert the CO into the Inlog.
        //   The LocalCoQueueCount only tracks local COs that came from
        //   the NTFS journal.  i.e.,
        //      LocalCo, Not a Retry Co, Not a recovery Co, Not a block issue
        //      case, Not a control CO, and not a parent reanimation.
        // Note: A Local Co should not have the CO_FLAG_PARENT_REANIMATION
        // flag set.
        //
        // CO_FLAG_MOVEIN_GEN NOTE: This flag does not currently appear to be
        // set anywhere (6/2002).  It is tested in several places to bypass
        // an INC_LOCAL_CO_QUEUE_COUNT .  It appears that if this flag does
        // get set then the below may NOT bypass the DECREMENT so the count will
        // go negative.  This would suppress updates of the journal read point
        // during times of volume activity outside the replica tree and could
        // result in a journal wrap.  So if this flag does get set, consider
        // revamping this code to use a COE flag set by journal code when
        // a new local co is created and queued to the process queue.  Then
        // just test the flag to control the decrement.
        //
        if (LocalCo                      &&
            !RetryCo                     &&
            !RecoveryCo                  &&
            (Decision != ISSUE_CONFLICT) &&
            !ControlCo                   &&
            !MorphGenCo) {

//            FRS_ASSERT(!ParentReanimation);

            if (!ParentReanimation) {
                DEC_LOCAL_CO_QUEUE_COUNT(Replica);
            }
        }

        //
        // Unidle the queue, reset the timeout.
        //
        if (UnIdleProcessQueue) {
            FrsRtlUnIdledQueue(IdledQueue);
        }

        TimeOut = 100;
        ReleaseVmeRef(pVme);
    }  // End of while(TRUE)

    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {
        //
        // Shutdown change order accept.
        //
        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "Chg Order Accept finally.", WStatus);
        //
        // Stop the Retry thread.
        //
        FrsRunDownCommandServer(&ChgOrdRetryCS, &ChgOrdRetryCS.Queue);

    //
    // Close any open tables and terminate the Jet Session.
    //

        //
        // Close the tables and free the table ctx structs and our thread ctx.
        //
        DbsFreeTableContext(TmpIDTableCtx, ThreadCtx->JSesid);
        TmpIDTableCtx = NULL;

        DbsFreeTableContext(TmpIDTableCtxNC, ThreadCtx->JSesid);
        TmpIDTableCtxNC = NULL;

        DbsFreeTableContext(TmpINLOGTableCtx, ThreadCtx->JSesid);
        TmpINLOGTableCtx = NULL;

        //
        // Now close the jet session and free the Jet ThreadCtx.
        //
        jerr = DbsCloseJetSession(ThreadCtx);

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"++ DbsCloseJetSession :", jerr);
        } else {
            DPRINT(4,"++ DbsCloseJetSession complete\n");
        }

        ThreadCtx = FrsFreeType(ThreadCtx);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "Changeorder accept terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }

        DPRINT(0, "ChangeOrder Thread is exiting\n");
    }

    return ERROR_SUCCESS;
}


ULONG
ChgOrdFetchCmd(
    PFRS_QUEUE            *pIdledQueue,
    PCHANGE_ORDER_ENTRY   *pChangeOrder,
    PVOLUME_MONITOR_ENTRY *ppVme
    )
/*++
Routine Description:

    Fetch the next change order command from FrsVolumeLayerCOList.
    FrsVolumeLayerCOList is a striped queue that combines the change order
    process queues from each active volume.  We return with the queue lock
    and a pointer to the head entry on the queue.  If the caller can
    process the change order the caller removes the entry and drops the
    queue lock.  If the caller can't process the entry due to a conflict with
    a change order currently in process then the caller leaves the entry
    on the queue, idles the queue and calls us again.  We can then pick up
    work from another queue or wait until the conflict clears and the queue
    is un-blocked.

Arguments:

    pIdledQueue - Returns the ptr to the Change Order Process queue to idle.
    pChangeOrder - Returns the ptr to the change order entry from the queue.
    ppVme - Returns the ptr to the Volume Monitor entry associated with the queue.

Return Value:

    FrsError status

    If successful this returns with the FrsVolumeLayerCOList Lock held and a
    reference taken on the Volume Monitor Entry (Vme).

    The caller must release the lock and drop the reference.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdFetchCmd:"

    ULONG                 WStatus;
    PFRS_QUEUE            Queue;
    PLIST_ENTRY           Entry;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PVOLUME_MONITOR_ENTRY pVme;
    PREPLICA              Replica;
    ULONG                 TimeNow;
    ULONG                 WaitTime;
    BOOL                  LocalCo;

    //
    // We stay in the loop until we either get a change order to process or
    // the queue is rundown.
    //
    while(TRUE) {

        //
        // Check if it's time to retry any inbound COs.  If so then
        // submit retry cmds to the CO Retry thread.
        //
        TimeNow = GetTickCount();

        WaitTime = ChgOrdNextRetryTime - TimeNow;
        if ((WaitTime > InlogRetryInterval) || (WaitTime == 0)) {
            DPRINT3(4, "NextRetryTime: %08x  Time: %08x   Diff:  %08x\n",
                   ChgOrdNextRetryTime, TimeNow, WaitTime);
            ChgOrdNextRetryTime += InlogRetryInterval;
            //
            // Check for any CO retries needed on this replica set.
            //
            ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
                // Loop iterator pE is type PREPLICA.
                if ((pE->ServiceState == REPLICA_STATE_ACTIVE) &&
                    (pE->InLogRetryCount > 0)) {
                    //
                    // Allocate command packet and submit to the CO Retry thread.
                    //
                    ChgOrdRetrySubmit(pE, NULL, FCN_CORETRY_ALL_CXTIONS, FALSE);
                }
            );
        }

        //
        // Wait on the queue so that rundowns can be detected. Waiting
        // on the control queue (FrsVolumeLayerCOList) can hang shutdown
        // because not all pVme->ChangeOrderLists are rundown; so the
        // control queue remains "active".
        //
        WStatus = FrsRtlWaitForQueueFull(&FrsVolumeLayerCOList, 10000);

        if (WStatus == ERROR_INVALID_HANDLE ||
            ChangeOrderAcceptIsShuttingDown) {
            DPRINT(1, "Shutting down ChgOrdAccept...\n");
            //
            // Queue was run down.  Time to exit.
            //
            return FrsErrorQueueIsRundown;
        }

        if (WStatus == WAIT_TIMEOUT) {
            continue;
        }

        if (!WIN_SUCCESS(WStatus)) {
            //
            // Some other error.
            //
            DPRINT_WS(0, "Wait for queue error", WStatus);
            return FrsErrorQueueIsRundown;
        }

        //
        // Perf: With multiple queues we aren't guaranteed to get the one
        // nearest expiration. Replace below with a loop over each list on the
        // full queue so we can compute the wait times for the head item on
        // each queue then build an ordered list to tell us which entry to
        // run next.
        //
        // Now peek at the first entry on the queue and see if time is up.
        // This is ugly and it is the reason this isn't a command server.
        //
        FrsRtlAcquireListLock(&FrsVolumeLayerCOList);

        if (FrsVolumeLayerCOList.ControlCount == 0) {
            //
            // Somebody got here before we did, drop lock and go wait on the queue.
            //
            DPRINT(4, "++ Control Count is zero\n");
            FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
            continue;
        }
        //
        // Get next queue on the FULL list & get the pVme containing the queue.
        //
        Entry = GetListHead(&FrsVolumeLayerCOList.Full);
        Queue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
        pVme = CONTAINING_RECORD(Queue, VOLUME_MONITOR_ENTRY, ChangeOrderList);

        //
        // Get the reference on the Vme.  If the return is zero the Vme is gone.
        // This could happen since there is a window between getting the queue
        // and getting the entry off the queue.
        //
        if (AcquireVmeRef(pVme) == 0) {
            continue;
        }

        //
        // Get a pointer to the first change order entry on the queue.
        //
        Entry = GetListHead(&Queue->ListHead);

        ChangeOrder = CONTAINING_RECORD(Entry, CHANGE_ORDER_ENTRY, ProcessList);
        FRS_PRINT_TYPE(5, ChangeOrder);

        LocalCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

        //
        // If this is a Local Change order then Check the Jrnl Cxtion for this
        // Replica Set.  If it is unjoined then don't wait for Aging cache
        // timeout.  Fill in the Cxtion ptr in the Change order.
        //
        if (LocalCo && (ChangeOrder->Cxtion == NULL)) {

            Replica = CO_REPLICA(ChangeOrder);
            FRS_ASSERT(Replica != NULL);

            ACQUIRE_CXTION_CO_REFERENCE(Replica, ChangeOrder);
        }

        //
        // If the wait time has not expired then sleep for the time left.
        // The local change order entry stays on the queue.  It can accumulate
        // additional changes or evaporate because it is still in the aging
        // cache.  Note that when remote change orders are inserted on the
        // queue TimeNow and TimeToRun are set to the current time so they
        // don't wait.  If Cxtion is unjoined then don't wait.
        //
        if (ChangeOrder->Cxtion != NULL) {

            TimeNow = GetTickCount();
            WaitTime = ChangeOrder->TimeToRun - TimeNow;
            if ((WaitTime <= ChangeOrderAgingDelay) && (WaitTime != 0)) {
                DPRINT3(4, "TimeToRun: %08x  Time: %08x   Diff:  %08x\n",
                        ChangeOrder->TimeToRun, TimeNow, WaitTime);
                //
                // PERF: Instead of sleeping post a queue wakeup (unidle) so
                // we can continue to process other volume queues.
                //

                //
                // Drop the lock and reference for the wait.
                //
                FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
                ReleaseVmeRef(pVme);
                //Sleep(WaitTime * 100);
                Sleep(WaitTime);
                continue;
            }
        }


        //
        // Pull the local change order out of the hash table.  We have the
        // change order process list lock, preventing the journal from
        // updating it.  Recovery COs and Retry COs come from the
        // Inbound log and aren't in the aging cache.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_IN_AGING_CACHE)) {

            BOOL RetryCo, RecoveryCo, MorphGenCo;
            ULONG GStatus;

            RetryCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);
            RecoveryCo = RecoveryCo(ChangeOrder);
            MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

            FRS_ASSERT(LocalCo && !RecoveryCo && !RetryCo && !MorphGenCo);

            GStatus = GhtRemoveEntryByAddress(pVme->ChangeOrderTable,
                                              ChangeOrder,
                                              TRUE);

            CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_IN_AGING_CACHE);

            if (GStatus != GHT_STATUS_SUCCESS) {
                DPRINT(0, "++ ERROR - GhtRemoveEntryByAddress failed.\n");
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected");
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"GhtRemoveEntryByAddress failed.");
                FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
                //ChgOrdReject(ChangeOrder, Replica);
                return FrsErrorQueueIsRundown;
            }
        }

        //
        // Delay has elapsed.
        // Return the change order and its associated queue and Vme.
        // If the caller can process the change order the caller removes it
        // from the queue.
        //
        *pIdledQueue = Queue;
        *pChangeOrder = ChangeOrder;
        *ppVme = pVme;

        return FrsErrorSuccess;
    }
}


ULONG
ChgOrdHoldIssue(
    IN PREPLICA              Replica,
    IN PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN PFRS_QUEUE            CoProcessQueue
    )
/*++

Routine Description:

    This routine ensures that a new change order does on conflict with a
    change order already in progress.  If it does then we set a flag in the
    active state indicating the change order process queue is blocked and
    and return status.  The process queue is blocked while holding the change
    order lock (using the FID or parent FID) to synchronize with the active
    change order retire operation.

    There are four file dependency cases to consider plus the case of duplicates.

    1.  File update/create on file X must preceed any subsequent file
    update/delete on file X.  (X could be a file or a Dir)

    2.  Parent dir create/update (e.g.  ACL, RO) must preceed any
    subsequent child file or dir operations.

    3.  Child File or Dir operations must preceed any subsequent parent dir
    update/delete.

    4.  Any rename or delete operation that releases a filename must preceed
    any rename or create operation that will reuse the filename.

    5.  Duplicate change orders can arrive from multiple inbound partners.
    If they arrive at the same time then we could have one in progress while
    the second tries to issue.  We can't immediately dampen the second CO because
    the first may fail (E.G. can't complete the fetch) so we mark the duplicate
    CO for retry and stick it in the Inbound log incase the currently active
    CO fails.

    Three hash tables are used to keep the active state:

       - The ActiveInboundChangeOrderTable keeps an entry for the change order
         when it is issued.  The CO stays in the table until it retires or
         a retry later is requested.  This table is indexed by the FileGuid
         so consecutive changes to the same file are performed in order.

       - The ActiveChildren hash table tracks the Parent File IDs of all active
         change orders.  Each time a change order issues, the entry for its
         parent is found (or created) and incremented.  When the count goes
         to zero the entry is removed.  If a change order was waiting for the
         parent count to go to zero it is unblocked.

       - The Name Conflict table is indexed by a hash of the file name and
         the parent directory object ID.  If a conflict occurs with an
         outstanding opertion the issuing change order must block until
         the current change order completes.  A deleted file and the source
         file of a rename reserve an entry in the table so they can block issue
         of a subsequent create or a rename with a target name that matches.
         The reverse check is not needed since that is handled by the
         ActiveInboundChangeOrderTable.

Assumptions:

    1. There are no direct interdependencies between Child File or Dir operations
       and ancestor directories beyond the immediate parent.
    2. The caller has acquired the FrsVolumeLayerCOList lock.

Arguments:

    Replica - The Replica set for the CO (also get us to the volume monitor
              entry associated with the replica set).

    ChangeOrder -- The new change order to check ordering conflicts.

    CoProcessQueue  -- The process queue this change order is on.
                       If the change order can't issue we idle the queue.
                       The caller has acquired the queue lock.

Return Value:

    ISSUE_OK means no conflict so the change order can be issued.

    ISSUE_DUPLICATE_REMOTE_CO means this is a duplicate change order.

    ISSUE_CONFLICT means a dependency condition exists so this change order
                   can't issue.

    ISSUE_RETRY_LATER means that the parent dir is not present so this CO
                      will have to be retried later.

    ISSUE_REJECT_CO means that we have determined that this CO can be safely
                    rejected. This can happen:
                      -- if the inbound connection has been deleted so we
                         can't fetch the staging file.
                      -- if the CO event time is too far into the future so
                         it is considered bogus.
                      -- if the CO is a morph gen follower and it's apparent
                         that the leader didn't get its job done.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdHoldIssue:"

    ULONGLONG             QuadHashValue;
    LONGLONG              CurrentTime;
    LONGLONG              EventTimeDelta;

    ULONG                 GStatus;
    PQHASH_ENTRY          QHashEntry;
    ULONG                 LocationCmd;
    BOOL                  RemoteCo;
    BOOL                  DropRef = FALSE;
    BOOL                  ForceNameConflictCheck = FALSE;
    BOOL                  OrigParentPresent;
    BOOL                  SelectedParentPresent, EitherParentAbsent;
    BOOL                  TargetPresent;
    BOOL                  DestParentAbsentOrDel, OrigParentAbsentOrDel;
    BOOL                  DestParentDelDeferred;
    BOOL                  MorphGenCo, CoFromInlog, DeleteCo;

    PCHANGE_ORDER_ENTRY   ActiveChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    PVOLUME_MONITOR_ENTRY pVme;
    PCXTION               Cxtion;
    ULONG                 GuidLockSlot = UNDEFINED_LOCK_SLOT;
    CHAR                  GuidStr[GUID_CHAR_LEN];

#define  CXTION_STR_MAX  256
    WCHAR                 CxtionStr[CXTION_STR_MAX], WDelta[15];

    pVme = Replica->pVme;
    CoCmd = &ChangeOrder->Cmd;

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    TargetPresent = !COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_TARGET_ABS);

    OrigParentPresent = !COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS);

    EitherParentAbsent = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS |
                                                  COE_FLAG_IDT_NEW_PARENT_ABS);

    SelectedParentPresent = !COE_FLAG_ON(ChangeOrder,
                                        (ChangeOrder->NewReplica != NULL) ?
                                            COE_FLAG_IDT_NEW_PARENT_ABS :
                                            COE_FLAG_IDT_ORIG_PARENT_ABS);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

    //
    // Synchronize with the Replica command server thread that may be changing
    // the cxtion's state, joinguid, or checking Cxtion->CoProcessQueue.
    //
    LOCK_CXTION_TABLE(Replica);
    Cxtion = ChangeOrder->Cxtion;
    if (Cxtion == NULL) {
        DPRINT(0, "++ ERROR - No connection struct for inbound CO\n");
        UNLOCK_CXTION_TABLE(Replica);
        FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
        return ISSUE_REJECT_CO;
    }

    //
    // Every remote change order was received from a cxtion.  The change
    // order must be "sent" to that cxtion again for processing.  Find it.
    // If it no longer exists then discard the change order.
    //
    // The cxtion can be in any of several states that will end up sending
    // this change order through the retry path.  Those states are checked
    // later since they could change between now and issueing the change
    // order to the replica command server.
    //
    if (RemoteCo) {
        //
        // Check if the Event Time on this CO is too far in the future by
        // twice the MaxPartnerClockSkew.
        // This could happen if a member disconnected and its time was
        // set into the future while file operations were performed.
        // Then when the time is set back it reconnects and Joins successfully
        // but is now sending change orders with bogus times.
        //
        GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
        EventTimeDelta = CoCmd->EventTime.QuadPart - CurrentTime;

        if (EventTimeDelta > (LONGLONG)(MaxPartnerClockSkew<<1)) {
                EventTimeDelta = EventTimeDelta / CONVERT_FILETIME_TO_MINUTES;
                DPRINT1(0, "++ ERROR: ChangeOrder rejected based on Bogus Event Time > MaxPartnerClockSkew by %08x %08x minutes.\n",
                       PRINTQUAD(EventTimeDelta));

                UNLOCK_CXTION_TABLE(Replica);
                FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
                CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

                CHANGE_ORDER_TRACE(3, ChangeOrder, "Bogus Event Time - Rejected");

                _snwprintf(CxtionStr, CXTION_STR_MAX, FORMAT_CXTION_PATH2W,
                           PRINT_CXTION_PATH2(Replica, Cxtion));
                CxtionStr[CXTION_STR_MAX-1] = UNICODE_NULL;

                _itow(PartnerClockSkew, WDelta, 10);
                EPRINT3(EVENT_FRS_RMTCO_TIME_SKEW, WDelta, CoCmd->FileName, CxtionStr);

                DPRINT1(0, "++ ERROR: Bogus Event Time on CO via connection: %ws\n", CxtionStr);
                //
                // Should we force an unjoin on this connection?  Probably not
                // because if the time on the upstream partner was out of whack
                // and it originated a bunch of COs with the bad time but the
                // time is now ok we would just end up unjoining and rejoining
                // on every bum CO until we get them out of the system.
                //
                return ISSUE_REJECT_CO;
        }

        //
        // Check if this is a "Recovery CO" from an inbound partner.
        // If it is and the partner connection is not yet joined then we
        // hold issue until the join completes.
        //
        if (RecoveryCo(ChangeOrder)) {
            //
            // If the connection is trying to join then hold issue on this CO
            // until it either succeeds or fails.
            //
            if (CxtionStateIs(Cxtion, CxtionStateStarting) ||
                CxtionStateIs(Cxtion, CxtionStateScanning) ||
                CxtionStateIs(Cxtion, CxtionStateWaitJoin) ||
                CxtionStateIs(Cxtion, CxtionStateSendJoin)) {
                //
                // Save the queue address we are blocked on.
                // When JOIN finally succeeds or fails we get unblocked with
                // the appropriate connection state change by a replica
                // command server thread.
                //
                Cxtion->CoProcessQueue = CoProcessQueue;

                GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);
                DPRINT3(3, "++ CO hold issue on pending JOIN, vsn %08x %08x, CoGuid: %s for %ws\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
                //
                //  Idle the queue and drop the connection table lock.
                //
                FrsRtlIdleQueueLock(CoProcessQueue);
                UNLOCK_CXTION_TABLE(Replica);

                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Cxtion Join");
                return ISSUE_CONFLICT;
            }
        }
    }

    UNLOCK_CXTION_TABLE(Replica);

    //
    // If this is a remote CO then it came with a Guid.  If this is a local CO
    // then ChgOrdTranslateGuidFid() told us if there is a record in the IDTable.
    //
    // If the Guid is zero then this is a new file from a local change order
    // that was not in the IDTable.  So it can't be in the
    // ActiveInboundChangeOrderTable.
    //
    GStatus = GHT_STATUS_NOT_FOUND;

    if (RemoteCo || TargetPresent) {
        /* !IS_GUID_ZERO(&CoCmd->FileGuid) */
        FRS_ASSERT(!IS_GUID_ZERO(&CoCmd->FileGuid));

        //
        // Get the ChangeOrder lock from a lock table using a hash of the
        // change order FileGuid.  This resolves the race idleing the queue
        // here and unidleing it in ChgOrdIssueCleanup().
        //
        GuidLockSlot = ChgOrdGuidLock(&CoCmd->FileGuid);
        ChgOrdAcquireLock(GuidLockSlot);

        //
        // Check if the file has an active CO on it.  If it does then
        // we can't issue this CO because the active CO could be changing
        // the ACL or the RO bit or it could just be a prior update to the
        // file so ordering has to be maintained.
        //
        // ** NOTE ** Be careful with ActiveChangeOrder, we drop the ref on it later.
        //
        GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                            &CoCmd->FileGuid,
                            TRUE,
                            &ActiveChangeOrder);
        DropRef = (GStatus == GHT_STATUS_SUCCESS);

        //
        // Check if we have seen this change order before.  This could happen if
        // we got the same change order from two different inbound partners.  We
        // can't dampen the second one until the first one completes sucessfully.
        // If for some reason the first one fails during fetch or install (say
        // the install file is corrupt or a sharing violation on the target
        // causes a retry) then we may need to get the change from the other
        // partner.  When the first change order completes successfully all the
        // duplicates are rejected by reconcile when they are retried later.
        // At that point we can Ack the inbound partner.
        //
        if (RemoteCo &&
            (GStatus == GHT_STATUS_SUCCESS) &&
            GUIDS_EQUAL(&CoCmd->ChangeOrderGuid,
                        &ActiveChangeOrder->Cmd.ChangeOrderGuid)) {

            //DPRINT(5, "++ Hit a case of duplicate change orders.\n");
            //DPRINT(5, "++ Incoming CO\n");
            //FRS_PRINT_TYPE(5, ChangeOrder);
            //DPRINT(5, "++ Active CO\n");
            //FRS_PRINT_TYPE(5, ActiveChangeOrder);

            //
            // Remove the duplicate entry from the queue, drop the locks and
            // return with duplicate remote co status.
            //
            FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
            GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                         ActiveChangeOrder,
                                         TRUE);
            DropRef = FALSE;
            //FrsRtlIdleQueueLock(CoProcessQueue);

            ChgOrdReleaseLock(GuidLockSlot);
            GuidLockSlot = UNDEFINED_LOCK_SLOT;

            return ISSUE_DUPLICATE_REMOTE_CO;
        }

        //
        // If the conflict is with an active change order on the same file
        // then set the flag in the active change order to unidle the queue
        // when the active change order completes.
        //
        if (GStatus == GHT_STATUS_SUCCESS) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - File Busy");
            goto CONFLICT;
        }

        if (DropRef) {
            GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                         ActiveChangeOrder,
                                         TRUE);
            DropRef = FALSE;
        }

        ChgOrdReleaseLock(GuidLockSlot);
        GuidLockSlot = UNDEFINED_LOCK_SLOT;

    } else {

        MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

        //
        // Target absent and a Local CO.
        //
        //
        // If this CO is a MorphGenFollower then it is the rename MorphGenCo
        // produced as part of a Dir/Dir Name Morph Conflict (DLD Case).  The
        // fact that the target is still absent means that the base create CO
        // (the leader) failed and is in retry so reject this MorphGenCo.  It
        // gets refabricated later when the Leader is re-issued.
        //  ***** Note -- THere is similar code in ChgOrdAccept() *****
        //
        if (MorphGenCo && COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER)) {
            FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - MORPH_GEN_FOLLOWER and leader failed");

            return ISSUE_REJECT_CO;
        }

        // If this CO is a MorphGenleader then it is the rename MorphGenCo
        // produced as part of a Dir/Dir Name Morph Conflict (DDL Case).  The
        // fact that the target is absent means that there isn't a conflict .
        // anymore. Reject this CO as there is no need for a rename anymore.
        //
        // The following if makes sure that this is a morph gen rename CO generated
        // to rename the idt entry.
        //
        // Do not pitch MorphGen Delete Cos.  An incoming Create Co that
        // looses the name conflict produces a MorphGenLeader DelCo with
        // no IDTable Entry.
        //  ***** Note -- THere is similar code in ChgOrdAccept() *****
        //
        if (MorphGenCo &&
            !COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER) &&
            (GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command) != CO_LOCATION_DELETE) &&
            BooleanFlagOn(ChangeOrder->Cmd.ContentCmd, USN_REASON_RENAME_NEW_NAME)) {

            FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - IDT deleted. No rename needed.");

            return ISSUE_REJECT_CO;
        }

        //
        // The FileGuid should be zero (i.e. The file wasn't found in the IDTable).
        // Except for the case where this is a MorphGenCo (e.g. a delete) where the
        // IDTable loses the name.  It could also be a recovery local CO that
        // came from the INlog. It could also be a parent reanimation CO that was
        // triggerred by a local child update CO.
        //
        CoFromInlog = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY) ||
                      RecoveryCo(ChangeOrder);

        FRS_ASSERT(IS_GUID_ZERO(&CoCmd->FileGuid) || MorphGenCo || CoFromInlog ||
                   COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION));

        if (!CO_NEW_FILE(LocationCmd)) {

            if (IS_GUID_ZERO(&CoCmd->FileGuid)) {
                DPRINT1(0, "++ WARN - FileGuid is zero, Location cmd is not a create: %d\n",
                       LocationCmd);
            }
            //
            // An update CO could arrive out of order relative to its create
            // if the create got delayed by a sharing violation.  We don't
            // want to lose the update so we make it look like a create.
            // This also handles the case of delete change orders generated
            // by name morph conflicts in which a rename arrives for a
            // nonexistent file.  We need to force a Name table conflict
            // check below.
            //
            ForceNameConflictCheck = TRUE;
        }
        //
        // We can't return yet.  Still need to check Tunnelled OID and
        // the parent dir.
        //
    }



    //
    // If no conflict with an active change order using Cmd.ChangeOrderGuid
    // then recheck with the OID we read from the file that could have
    // been tunnelled.
    //
    if (!RemoteCo &&
        (COE_FLAG_ON(ChangeOrder, COE_FLAG_OID_FROM_FILE)) &&
        !GUIDS_EQUAL(&CoCmd->FileGuid, &ChangeOrder->FileObjectId)) {

        //
        // Get the ChangeOrder lock from a lock table using a hash of the
        // change order FileGuid.  This resolves the race idleing the queue
        // here and unidleing it in ChgOrdIssueCleanup().
        //
        GuidLockSlot = ChgOrdGuidLock(&ChangeOrder->FileObjectId);
        ChgOrdAcquireLock(GuidLockSlot);

        GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                            &ChangeOrder->FileObjectId,
                            TRUE,
                            &ActiveChangeOrder);

        DropRef = (GStatus == GHT_STATUS_SUCCESS);

        //
        // If the conflict is with an active change order on the same file
        // then set the flag in the active change order to unidle the queue
        // when the active change order completes.
        //
        if (GStatus == GHT_STATUS_SUCCESS) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict Tunnel - File Busy");
            goto CONFLICT;
        }

        if (DropRef) {
            GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                         ActiveChangeOrder,
                                         TRUE);
            DropRef = FALSE;
        }

        ChgOrdReleaseLock(GuidLockSlot);
        GuidLockSlot = UNDEFINED_LOCK_SLOT;

    }


    //
    // Check on the condition of the Parent Dirs.
    //

    //
    // If the parent of a localCo is absent then reject the CO.  This can happen
    // if the child is renamed to a new dir (MOVEDIR) and then the old parent
    // is deleted.  e.g.
    //  Variation 1                      Variation 2
    //
    //  Cre parent1                      cre parent1
    //  cre parent1\child                move pre-existing-child to parent1
    //  rename child to another dir      rename child to another dir
    //  del parent1                      del parent1
    //
    // re: Variation 1-
    // When processed the cre parent1 will not be on the disk since the delete
    // has already been executed so the cre parent1 is rejected.
    // When the cre parent1\child is processed there is no IDTable entry
    // for parent1.  So reject this Co.
    // When the rename (MOVEDIR) is processed we treat it as a MOVEIN since
    // there is no IDTable entry for the child but now we do have an IDTable
    // entry for the parent.  Del Parent1 is processed as a delete on a deleted
    // file and is rejected.
    //
    // Variation 2 is similiar to 1 but by the time we process the move of
    // a pre-existing child to parent1 (MOVEDIR) we see parent1 has been
    // deleted (and there is no IDTable entry for it just like variation 1).
    // In this case, parent1 is the new parent (or dest dir).  The next CO
    // then renames the child to some other dir and again there is no IDTable
    // entry for parent1, the source dir in this case.
    //
    // The following sequence shows a case where both parents of a movedir
    // are absent  (movedir child to par2).
    // cre par1  ;  cre par1\child  ;  cre par2  ;  movedir child to par2 ;
    // cre par3  ;  movedir child to par3  ;  del par1  ;  del par2
    //
    // Rule:  If dest parent is absent or deleted then reject the CO BUT if the
    //        CO is a delete (or MOVEOUT) then this is the end of the line for
    //        this file and there won't be any follow-on CO.
    //
    // Note: If the dest parent is marked deleted in IDTable but the target file
    // is present then there must be another operation coming up that does a
    // MOVEDIR onthe file.  We will treat that as a MOVEIN when it comes.
    //
    // Note: if the dest parent delete occured because of a remote CO delete
    // that was processed before this CO then either the target file will have
    // been deleted along with the parent (the NO ACTIVE CHILD case) or some
    // MOVEDIR has placed it under a different parent.
    //
    // Either way reject this CO and let the file be handled by a subsequent CO.
    //
    // We can not reject the local CO if the parent is marked delete deferred.
    // Instead we want this CO to reanimate the parent.
    //

    if (!RemoteCo) {
        DestParentAbsentOrDel = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_ABS |
                                                         COE_FLAG_IDT_NEW_PARENT_DEL);

        DestParentDelDeferred = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL_DEF);

        DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
                   (LocationCmd == CO_LOCATION_MOVEOUT);

        if (DestParentAbsentOrDel && !DestParentDelDeferred && !DeleteCo) {
            FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - Dest Par Abs or Del");
            return ISSUE_REJECT_CO;
        }


        if (LocationCmd == CO_LOCATION_MOVEDIR) {

            OrigParentAbsentOrDel = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS |
                                                             COE_FLAG_IDT_ORIG_PARENT_DEL);
            if (OrigParentAbsentOrDel) {
                //
                // If the source parent dir is absent or deleted then let the
                // CO continue as a simple rename.
                //
                // A simple rename does not have a location command and it
                // has a content command with the value USN_REASON_NEW_NAME.
                // The location command needs to be cleared so that StuInstallStage
                // correctly does the rename of the file to the correct location.
                //
                CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
                SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_NUM_CMD);
                LocationCmd = CO_LOCATION_NUM_CMD;
                SET_CO_FLAG(ChangeOrder, CO_FLAG_CONTENT_CMD);
                CoCmd->ContentCmd |= USN_REASON_RENAME_NEW_NAME;
                //
                // If the original parent does not exist because of variation 1
                // above then the FidToGuid translation will leave the
                // oldparentguid zero.  So copy the NewParentGuid to the OldParentGuid.
                // Leaving the oldparentguid zero hits asserts related to hash
                // table inserts.
                //
                if (IS_GUID_ZERO(&CoCmd->OldParentGuid)) {
                    COPY_GUID(&CoCmd->OldParentGuid, &CoCmd->NewParentGuid);
                }
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Src Abs/Del cvt to simple RENAME");
            }
        }
    }


    // Check for CO Timeout --
    //
    // It is possible for us to get into a state where there is a CO on a child
    // but the parent does not exist on any machine in the replica set. For
    // example,the create CO for the parent may have been held up on the
    // original machine andthe machine was removed form the replica set before
    // sending the CO.
    //
    // Whatever the cause, we are not able to detect this situation. If the
    // parent does exist, it can take an arbitrarily long amount of time to
    // reach us. Since we cannot detect the total absense of the parent, all
    // that we can do is wait a sufficiently long amount of time before giving
    // up all hope of ever seeing it.
    //
    // We give up waiting for the parent once two conditions have been met.
    // 1) We have retried this change order at least certain number of times.
    // 2) A minimum amount of time has passed since we first tried this CO.
    //

    if (EitherParentAbsent && CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)) {
        PDATA_EXTENSION_RETRY_TIMEOUT CoCmdRetryTimeout;

        CoCmdRetryTimeout = DbsDataExtensionFind(CoCmd->Extension, DataExtend_Retry_Timeout);

        if(CoCmdRetryTimeout != NULL) {
            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

            // increase retry count
            CoCmdRetryTimeout->Count++;

            //
            // we must update the inlog table because we have
            // modified the RetryTimeout counts.
            //
            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_UPDATE_INLOG);

            // get the time difference in minutes.
            EventTimeDelta = CurrentTime - CoCmdRetryTimeout->FirstTryTime;
            EventTimeDelta = EventTimeDelta / CONVERT_FILETIME_TO_MINUTES;

            // if the count is too high and enough time has passed, trash this CO
            if((CoCmdRetryTimeout->Count > MaxCoRetryTimeoutCount)
               &&(EventTimeDelta > MaxCoRetryTimeoutMinutes)) {

                //
                // Remove the CO entry from the queue and remove
                // the preinstall file and the ID Table entry.
                //
                FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
                CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_PREINSTALL);
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_IDT_ENTRY);

                return ISSUE_REJECT_CO;
            }
        }
    }



    //
    // Check if the parent DIR has an active CO on it.  If it does then
    // we can't issue this change order because the change on the parent
    // could affect the ACL or the RO bit or ...
    // Also check if there is a name conflict if this is a create or a rename.
    //
    if (SelectedParentPresent) {

        FRS_ASSERT(!IS_GUID_ZERO(ChangeOrder->pParentGuid));

        GuidLockSlot = ChgOrdGuidLock(ChangeOrder->pParentGuid);
        ChgOrdAcquireLock(GuidLockSlot);

        //
        // Check for name conflict on a create or a rename target.
        // Aliasing is possible in the hash table since we don't have the
        // full key saved.  So check for COs that remove a name since a
        // second insert with the same hash value would cause a conflict.
        //
        // If there is a conflict then set the "queue blocked" flag in
        // the name conflict table entry. The flag will be picked up by
        // the co that decs the entry's reference count to 0.
        //
        // NameConflictTable Entry: An entry in the NameConflictTable
        // contains a reference count of the number of active change
        // orders that hash to that entry and a Flags word that is set
        // to COE_FLAG_VOL_COLIST_BLOCKED if the process queue for this
        // volume is idled while waiting on the active change orders for
        // this entry to retire. The queue is idled when the entry at
        // the head of the queue hashes to this entry and so may
        // have a conflicting name (hence the name, "name conflict table").
        //
        // The NameConflictTable can give false positives. But this is okay
        // because a false positive is rare and will only idle the process
        // queue until the active change order retires. Getting rid
        // of the rare false positives would degrade performance. The
        // false positives that happen when inserting an entry into the
        // NameConflictTable are handled by using the QData field in
        // the QHashEntry as a the reference count.
        //
        // But, you ask, how can there be multiple active cos hashing to this
        // entry if the process queue is idled when a conflict is detected?
        // Easy, I say, because the filename in the co is used to detect
        // collisions while the filename in the idtable is used to reserve the
        // qhash entry.  Why?  Well, the name morph code handles the case of a
        // co's name colliding with an idtable entry.  But that code wouldn't
        // work if active change orders were constantly changing the idtable.
        // So, the NameConflictTable synchronizes the namespace amoung active
        // change orders so that the name morph code can work against a static
        // namespace.
        //
        // If this CO is a MORPH_GEN_FOLLOWER make sure we interlock with the
        // MORPH_GEN_LEADER.  The leader is removing the name so it makes an
        // entry in the name conflict table.  If the follower is a create it
        // will check against the name with one of the DOES_CO predicates
        // below, but if it is a file reanimation it may just look like an
        // update so always make the interlock check if this CO is a follower.
        //
        if (ForceNameConflictCheck          ||
            DOES_CO_CREATE_FILE_NAME(CoCmd) ||
            DOES_CO_REMOVE_FILE_NAME(CoCmd) ||
            DOES_CO_DO_SIMPLE_RENAME(CoCmd) ||
            COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER)) {

            ChgOrdCalcHashGuidAndName(&ChangeOrder->UFileName,
                                      ChangeOrder->pParentGuid,
                                      &QuadHashValue);
            //
            // There should be no ref that needs to be dropped here.
            //
            FRS_ASSERT(!DropRef);

            QHashAcquireLock(Replica->NameConflictTable);
            //
            // MOVERS: check if we are looking at correct replica if this is a movers
            //
            QHashEntry = QHashLookupLock(Replica->NameConflictTable,
                                         &QuadHashValue);
            if (QHashEntry != NULL) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Name Table");
                GuidToStr(ChangeOrder->pParentGuid, GuidStr);
                DPRINT4(4, "++ NameConflictTable hit on file %ws, ParentGuid %s, "
                        "Key %08x %08x, RefCount %08x %08x\n",
                        ChangeOrder->UFileName.Buffer, GuidStr,
                        PRINTQUAD(QuadHashValue), PRINTQUAD(QHashEntry->QData));
                FRS_PRINT_TYPE(4, ChangeOrder);
                //
                // This flag will be picked up by the change order that
                // decs this entry's count to 0.
                //
                QHashEntry->Flags |= (ULONG_PTR)COE_FLAG_VOL_COLIST_BLOCKED;
                QHashReleaseLock(Replica->NameConflictTable);
                goto NAME_CONFLICT;
            }
            QHashReleaseLock(Replica->NameConflictTable);
        }



        //
        // Check for active change order on the parent Dir.
        //
        // ** NOTE ** Be careful with ActiveChangeOrder, we drop the ref on it later.
        //
        GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                            ChangeOrder->pParentGuid,
                            TRUE,
                            &ActiveChangeOrder);

        if (GStatus == GHT_STATUS_SUCCESS) {
            DropRef = TRUE;
            CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Parent Busy");
            goto CONFLICT;
        }

        FRS_ASSERT(!DropRef);
        ChgOrdReleaseLock(GuidLockSlot);
        GuidLockSlot = UNDEFINED_LOCK_SLOT;

    } else {
        DPRINT(0, "++ ERROR - Neither parent is present.\n");
        FRS_PRINT_TYPE(4, ChangeOrder);
    }

    //
    // Check for a conflict with some operation on the Original parent FID if
    // this is a MOVEOUT, MOVERS or a MOVEDIR.
    //
    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {

        if (OrigParentPresent) {
            FRS_ASSERT(!IS_GUID_ZERO(&CoCmd->OldParentGuid));

            GuidLockSlot = ChgOrdGuidLock(&CoCmd->OldParentGuid);
            ChgOrdAcquireLock(GuidLockSlot);
            //
            // ** NOTE ** Be careful with ActiveChangeOrder, we drop the ref on it later.
            //
            GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                                &CoCmd->OldParentGuid,
                                TRUE,
                                &ActiveChangeOrder);

            if (GStatus == GHT_STATUS_SUCCESS) {
                DropRef = TRUE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Orig Parent Busy");
                goto CONFLICT;
            }

            FRS_ASSERT(!DropRef);
            ChgOrdReleaseLock(GuidLockSlot);
            GuidLockSlot = UNDEFINED_LOCK_SLOT;

        } else {
            DPRINT(0, "++ ERROR - Orig Parent not present.\n");
            FRS_PRINT_TYPE(4, ChangeOrder);
        }
    }

    //
    // Check if this is an operation on a directory with change orders still
    // active on any children.  As an example there could be an active CO that
    // deletes a file and this change order wants to delete the parent directory.
    //
    // But.. A new dir can't have any change orders active beneath it.
    //       Neither can a delete co generated to produce a tombstone.
    //
    if (!TargetPresent ||
       (!RemoteCo && (LocationCmd == CO_LOCATION_DELETE) &&
                         CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN))) {

        return ISSUE_OK;
    }

    QHashAcquireLock(pVme->ActiveChildren);
    QHashEntry = QHashLookupLock(pVme->ActiveChildren,
                                 &ChangeOrder->Cmd.FileGuid);

    //
    // If the conflict was on a dir that has change orders outstanding on one
    // or more children then set the flag bit to unblock the queue when the
    // count goes to zero.
    //
    if (QHashEntry != NULL) {
        CHAR  FileGuidString[GUID_CHAR_LEN];
        GuidToStr(&ChangeOrder->Cmd.FileGuid, FileGuidString);
        DPRINT2(4, "++ GAC: Interlock - Active children (%d) under GUID %s\n",
               QHashEntry->QData>>1, FileGuidString);

        if (!CoCmdIsDirectory(CoCmd)) {
            DPRINT(0, "++ ERROR - Non Dir entry in pVme->ActiveChildren hash table.\n");
            FRS_PRINT_TYPE(0, ChangeOrder);
        }

        //
        //  Set the flag and idle the queue and drop the table lock.
        //
        QHashEntry->QData |= 1;
        FrsRtlIdleQueueLock(CoProcessQueue);
        QHashReleaseLock(pVme->ActiveChildren);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Child Busy");
        return ISSUE_CONFLICT;
    }

    QHashReleaseLock(pVme->ActiveChildren);

    //
    // If there are any remote change orders pending for retry of the install then
    // check to see if this change order guid matches.  If it does then we
    // can retire this change order since it is a duplicate and we already
    // have the staging file.
    //
    if (0 && RemoteCo &&
        !CoCmdIsDirectory(CoCmd) &&
        (ChangeOrder->NewReplica->InLogRetryCount > 0)) {

        //
        // PERF: add code to lookup CO by GUID and check for match.
        //
        // return with a change order reject error code
        //
        // Remove the duplicate entry from the queue.
        //
        FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

        return ISSUE_REJECT_CO;
    }


    return ISSUE_OK;


    //
    // Issue conflict on the file or on the parent dir.  Set flag in Active
    // Change order to unblock the queue on retire and then drop the change
    // order GUID lock.
    //
CONFLICT:

    SET_COE_FLAG(ActiveChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);

    DPRINT1(4, "++ GAC Setting COE_FLAG_VOL_COLIST_BLOCKED, block on: %08x %08x\n",
            PRINTQUAD(ActiveChangeOrder->FileReferenceNumber));

    //
    // Conflict detected in name conflict table
    //
NAME_CONFLICT:

    if (DropRef) {
        GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                     ActiveChangeOrder,
                                     TRUE);
    }

    //
    //  Idle the queue and drop the change order lock.
    //
    FrsRtlIdleQueueLock(CoProcessQueue);

    FRS_ASSERT(GuidLockSlot != UNDEFINED_LOCK_SLOT);

    ChgOrdReleaseLock(GuidLockSlot);

    return ISSUE_CONFLICT;
}


#define HI_AIB_T            0x00000001       // AIBCO on Target
#define HI_AIB_D            0x00000002       // AIBCO plus Dup Rmt Co check
#define HI_EPA              0x00000004       // Either parent absent
#define HI_NC               0x00000008       // name Conflict check
#define HI_ASP              0x00000010       // AIBCO on Selected Parent
#define HI_AOP              0x00000020       // AIBCO on Original Parent
#define HI_AC               0x00000040       // Check for active child under dir
#define HI_ISSUE_OK         0x10000000
#define HI_ISSUE_LATER      0x20000000       // return issue-retry-later status.
#define HI_ASSERT           0x40000000
#define HI_INVALID          0x80000000


// CoType -NewFile - (Create, Update before Cre, MovIn)
//         DelFile  -  Delete file, MovOut, MovRS
//         UpdFile - Update existing file, could be MovDir)
//SelParValid - Is selected parent (either NewPar or OrigPar) have a GUID or FID?


ULONG  HoldIssueDecodeTable[32] = {
// AIBCO-Targ    NameConf           AIBCO-OldPar       IssueOK        // Rmt/ File/  CO   Sel
// DupRmtCo?                         if movxxx                        // Lcl  Dir   Type  Par
//      EitherParAbs      AIBCO on           Active                   //                  Valid?  -- Comment
//      IsRetryLater      Selected Par       Child

                   HI_NC  |HI_ASP                    |HI_ISSUE_OK,    // Lcl  File  New   y
                                                      HI_ASSERT,      // Lcl  File  New   n   -- For local Cre, how come no parent?

HI_AIB_T          |HI_NC  |HI_ASP   |HI_AOP          |HI_ISSUE_OK,    // Lcl  File  Del   y   -- If no target then we missed create.  For local del, how come?
                                                      HI_ASSERT,      // Lcl  File  Del   n   -- If either Parent missing then we missed ParCreate, For local Del, how come no parent?

HI_AIB_T          |HI_NC  |HI_ASP   |HI_AOP          |HI_ISSUE_OK,    // Lcl  File  Upd   y
                                                      HI_ASSERT,      // Lcl  File  Upd   n   -- For local Upd, how come no parent?

                                                      HI_INVALID,     //             x
                                                      HI_INVALID,     //             x

                   HI_NC  |HI_ASP                    |HI_ISSUE_OK,    // Lcl  Dir   New   y
                                                      HI_ASSERT,      // Lcl  Dir   New   n   -- For local Cre, how come no parent?

HI_AIB_T          |HI_NC  |HI_ASP   |HI_AOP  |HI_AC  |HI_ISSUE_OK,    // Lcl  Dir   Del   y   -- If no target then we missed create.  For local del, how come?
                                                      HI_ASSERT,      // Lcl  Dir   Del   n   -- If either ParGuid is zero then we missed ParCreate, For local Del, how come no parent?

HI_AIB_T          |HI_NC  |HI_ASP   |HI_AOP  |HI_AC  |HI_ISSUE_OK,    // Lcl  Dir   Upd   y
                                                      HI_ASSERT,      // Lcl  Dir   Upd   n   -- For local Upd, how come no parent?

                                                      HI_INVALID,     //             x
                                                      HI_INVALID,     //             x

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP                    |HI_ISSUE_OK,    // Rmt  File  New   y   -- Why retry later?  Cre file in preinstall.
                                                      HI_ISSUE_LATER, // Rmt  File  New   n   -- IsRetryLater  No parent means file lives in pre-install dir.  Do This?

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP   |HI_AOP          |HI_ISSUE_OK,    // Rmt  File  Del   y   -- If Target IDT Absent then we missed create. Do JustTombStone?
                                                      HI_ISSUE_LATER, // Rmt  File  Del   n   -- IsRetryLater  If either Par IDT Absent then we missed ParCreate. Do JustTombStone?

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP   |HI_AOP          |HI_ISSUE_OK,    // Rmt  File  Upd   y
                                                      HI_ISSUE_LATER, // Rmt  File  Upd   n   -- IsRetryLater  Why retry later?  Update file in preinstall.

                                                      HI_INVALID,     //             x
                                                      HI_INVALID,     //             x

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP                    |HI_ISSUE_OK,    // Rmt  Dir   New   y   -- Why retry later?  Cre dir in preinstall.
                                                      HI_ISSUE_LATER, // Rmt  Dir   New   n   -- IsRetryLater  No parent means dir lives in pre-install dir.  Do This?

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP   |HI_AOP  |HI_AC  |HI_ISSUE_OK,    // Rmt  Dir   Del   y   -- If Target IDT Absent then we missed create. Do JustTombStone?
                                                      HI_ISSUE_LATER, // Rmt  Dir   Del   n   -- IsRetryLater  If either Par IDT Absent then we missed ParCreate. Do JustTombStone?

HI_AIB_D | HI_EPA |HI_NC  |HI_ASP   |HI_AOP  |HI_AC  |HI_ISSUE_OK,    // Rmt  Dir   Upd   y   -- Why retry later?  Cre dir in preinstall.
                                                      HI_ISSUE_LATER, // Rmt  Dir   Upd   n   -- IsRetryLater  No parent means dir lives in pre-install dir.  Do This?

                                                      HI_INVALID,     //             x
                                                      HI_INVALID      //             x
};



ULONG
ChgOrdHoldIssue2(
    IN PREPLICA              Replica,
    IN PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN PFRS_QUEUE            CoProcessQueue
    )
/*++

Routine Description:

    This routine ensures that a new change order does on conflict with a
    change order already in progress.  If it does then we set a flag in the
    active state indicating the change order process queue is blocked and
    and return status.  The process queue is blocked while holding the change
    order lock (using the FID or parent FID) to synchronize with the active
    change order retire operation.

    There are four file dependency cases to consider plus the case of duplicates.

    1.  File update/create on file X must preceed any subsequent file
    update/delete on file X.  (X could be a file or a Dir)

    2.  Parent dir create/update (e.g.  ACL, RO) must preceed any
    subsequent child file or dir operations.

    3.  Child File or Dir operations must preceed any subsequent parent dir
    update/delete.

    4.  Any rename or delete operation that releases a filename must preceed
    any rename or create operation that will reuse the filename.

    5.  Duplicate change orders can arrive from multiple inbound partners.
    If they arrive at the same time then we could have one in progress while
    the second tries to issue.  We can't immediately dampen the second CO because
    the first may fail (E.G. can't complete the fetch) so we mark the duplicate
    CO for retry and stick it in the Inbound log incase the currently active
    CO fails.

    Three hash tables are used to keep the active state:

       - The ActiveInboundChangeOrderTable keeps an entry for the change order
         when it is issued.  The CO stays in the table until it retires or
         a retry later is requested.  This table is indexed by the FileGuid
         so consecutive changes to the same file are performed in order.

       - The ActiveChildren hash table tracks the Parent File IDs of all active
         change orders.  Each time a change order issues, the entry for its
         parent is found (or created) and incremented.  When the count goes
         to zero the entry is removed.  If a change order was waiting for the
         parent count to go to zero it is unblocked.

       - The Name Conflict table is indexed by a hash of the file name and
         the parent directory object ID.  If a conflict occurs with an
         outstanding opertion the issuing change order must block until
         the current change order completes.  A deleted file and the source
         file of a rename reserve an entry in the table so they can block issue
         of a subsequent create or a rename with a target name that matches.
         The reverse check is not needed since that is handled by the
         ActiveInboundChangeOrderTable.

Assumptions:

    1. There are no direct interdependencies between Child File or Dir operations
       and ancestor directories beyond the immediate parent.
    2. The caller has acquired the FrsVolumeLayerCOList lock.

Arguments:

    Replica - The Replica set for the CO (also get us to the volume monitor
              entry associated with the replica set).

    ChangeOrder -- The new change order to check ordering conflicts.

    CoProcessQueue  -- The process queue this change order is on.
                       If the change order can't issue we idle the queue.
                       The caller has acquired the queue lock.

Return Value:

    ISSUE_OK means no conflict so the change order can be issued.

    ISSUE_DUPLICATE_REMOTE_CO means this is a duplicate change order.

    ISSUE_CONFLICT means a dependency condition exists so this change order
                   can't issue.

    ISSUE_RETRY_LATER means that the parent dir is not present so this CO
                      will have to be retried later.

--*/

{
#undef DEBSUB
#define DEBSUB  "ChgOrdHoldIssue2:"

    ULONG                 GStatus;
    PQHASH_ENTRY          QHashEntry;
    ULONG                 LocationCmd;
    ULONG                 Decodex, DecodeMask;
    BOOL                  RemoteCo;
    BOOL                  DropRef = FALSE;
    BOOL                  ForceNameConflictCheck = FALSE;
    BOOL                  OrigParentPresent;
    BOOL                  SelectedParentPresent, EitherParentAbsent;
    BOOL                  TargetPresent;

    PCHANGE_ORDER_ENTRY   ActiveChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    PVOLUME_MONITOR_ENTRY pVme;
    PCXTION               Cxtion;
    ULONGLONG             QuadHashValue;
    ULONG                 GuidLockSlot = UNDEFINED_LOCK_SLOT;
    CHAR                  GuidStr[GUID_CHAR_LEN];


#undef FlagChk
#define FlagChk(_flag_) BooleanFlagOn(DecodeMask, _flag_)

    pVme = Replica->pVme;
    CoCmd = &ChangeOrder->Cmd;

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    TargetPresent = !COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_TARGET_ABS);

    OrigParentPresent = !COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS);

    EitherParentAbsent = COE_FLAG_ON(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS |
                                                  COE_FLAG_IDT_NEW_PARENT_ABS);

    SelectedParentPresent = !COE_FLAG_ON(ChangeOrder,
                                        (ChangeOrder->NewReplica != NULL) ?
                                            COE_FLAG_IDT_NEW_PARENT_ABS :
                                            COE_FLAG_IDT_ORIG_PARENT_ABS);

    //
    // Construct the dispatch index into the HoldIssueDecodeTable.
    //
    //  10   08    06    01
    // Rmt/ File/  CO   Sel
    // Lcl  Dir   Type  Par
    //                  Valid?
    //
    Decodex = 0;
    if (!RemoteCo) {
        Decodex |= 0x10;
    }

    if (CoCmdIsDirectory(CoCmd)) {
        Decodex |= 0x08;
    }

    if (!TargetPresent) {
        // New Co
        Decodex |= 0x00;
    } else
        if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
            // Del Co    (or MoveOut)
            Decodex |= 0x02;
        } else
            if (TargetPresent) {
                // Update existing file Co
                Decodex |= 0x04;
            } else
                // Invalid Co
                { Decodex |= 0x06; };

    if (SelectedParentPresent) {
        Decodex |= 0x01;
    }

    DecodeMask = HoldIssueDecodeTable[Decodex];
    CHANGE_ORDER_TRACEX(3, ChangeOrder, "DecodeIndex=", Decodex);
    CHANGE_ORDER_TRACEX(3, ChangeOrder, "DecodeMask= ", DecodeMask);

    FRS_ASSERT(!FlagChk(HI_INVALID));

    //
    // Synchronize with the Replica command server thread that may be changing
    // the cxtion's state, joinguid, or checking Cxtion->CoProcessQueue.
    //
    LOCK_CXTION_TABLE(Replica);
    Cxtion = ChangeOrder->Cxtion;
    if (Cxtion == NULL) {
        DPRINT(0, "++ ERROR - No connection struct for inbound CO\n");
        UNLOCK_CXTION_TABLE(Replica);
        FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
        return ISSUE_REJECT_CO;
    }

    //
    // Every remote change order was received from a cxtion.  The change
    // order must be "sent" to that cxtion again for processing.  Find it.
    // If it no longer exists then discard the change order.
    //
    // The cxtion can be in any of several states that will end up sending
    // this change order through the retry path.  Those states are checked
    // later since they could change between now and issueing the change
    // order to the replica command server.
    //
    if (RemoteCo) {
        //
        // Check if this is a "Recovery CO" from an inbound partner.
        // If it is and the partner connection is not yet joined then we
        // hold issue until the join completes.
        //
        if (RecoveryCo(ChangeOrder)) {
            //
            // If the connection is trying to join then hold issue on this CO
            // until it either succeeds or fails.
            //
            if (CxtionStateIs(Cxtion, CxtionStateStarting) ||
                CxtionStateIs(Cxtion, CxtionStateScanning) ||
                CxtionStateIs(Cxtion, CxtionStateWaitJoin) ||
                CxtionStateIs(Cxtion, CxtionStateSendJoin)) {
                //
                // Save the queue address we are blocked on.
                // When JOIN finally succeeds or fails we get unblocked with
                // the appropriate connection state change by a replica
                // command server thread.
                //
                Cxtion->CoProcessQueue = CoProcessQueue;

                GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);
                DPRINT3(3, "++ CO hold issue on pending JOIN, vsn %08x %08x, CoGuid: %s for %ws\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
                //
                //  Idle the queue and drop the connection table lock.
                //
                FrsRtlIdleQueueLock(CoProcessQueue);
                UNLOCK_CXTION_TABLE(Replica);

                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Cxtion Join");
                return ISSUE_CONFLICT;
            }
        }
    }

    UNLOCK_CXTION_TABLE(Replica);


    //
    // If this is a remote CO then it came with a Guid.  If this is a local CO
    // then ChgOrdTranslateGuidFid() told us if there is a record in the IDTable.
    //
    // If the Guid is zero then this is a new file from a local change order
    // that was not in the IDTable.  So it can't be in the
    // ActiveInboundChangeOrderTable.
    //
    if (FlagChk(HI_AIB_T | HI_AIB_D)) {
        GStatus = GHT_STATUS_NOT_FOUND;

        if (RemoteCo || TargetPresent) {

            FRS_ASSERT(!IS_GUID_ZERO(&CoCmd->FileGuid));

            //
            // Get the ChangeOrder lock from a lock table using a hash of the
            // change order FileGuid.  This resolves the race idleing the queue
            // here and unidleing it in ChgOrdIssueCleanup().
            //
            GuidLockSlot = ChgOrdGuidLock(&CoCmd->FileGuid);
            ChgOrdAcquireLock(GuidLockSlot);

            //
            // Check if the file has an active CO on it.  If it does then
            // we can't issue this CO because the active CO could be changing
            // the ACL or the RO bit or it could just be a prior update to the
            // file so ordering has to be maintained.
            //
            // ** NOTE ** Be careful with ActiveChangeOrder, we drop the ref on it later.
            //
            GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                                &CoCmd->FileGuid,
                                TRUE,
                                &ActiveChangeOrder);
            DropRef = (GStatus == GHT_STATUS_SUCCESS);

            //
            // Check if we have seen this change order before.  This could happen if
            // we got the same change order from two different inbound partners.  We
            // can't dampen the second one until the first one completes sucessfully.
            // If for some reason the first one fails during fetch or install (say
            // the install file is corrupt or a sharing violation on the target
            // causes a retry) then we may need to get the change from the other
            // partner.  When the first change order completes successfully all the
            // duplicates are rejected by reconcile when they are retried later.
            // At that point we can Ack the inbound partner.
            //
            if (FlagChk(HI_AIB_D)) {
                if ((GStatus == GHT_STATUS_SUCCESS) &&
                    GUIDS_EQUAL(&CoCmd->ChangeOrderGuid,
                                &ActiveChangeOrder->Cmd.ChangeOrderGuid)) {

                    //DPRINT(5, "++ Hit a case of duplicate change orders.\n");
                    //DPRINT(5, "++ Incoming CO\n");
                    //FRS_PRINT_TYPE(5, ChangeOrder);
                    //DPRINT(5, "++ Active CO\n");
                    //FRS_PRINT_TYPE(5, ActiveChangeOrder);

                    //
                    // Remove the duplicate entry from the queue, drop the locks and
                    // return with duplicate remote co status.
                    //
                    FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
                    CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);
                    GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                                 ActiveChangeOrder,
                                                 TRUE);
                    DropRef = FALSE;
                    //FrsRtlIdleQueueLock(CoProcessQueue);

                    ChgOrdReleaseLock(GuidLockSlot);
                    GuidLockSlot = UNDEFINED_LOCK_SLOT;

                    return ISSUE_DUPLICATE_REMOTE_CO;
                }
            }

            //
            // If the conflict is with an active change order on the same file
            // then set the flag in the active change order to unidle the queue
            // when the active change order completes.
            //
            if (GStatus == GHT_STATUS_SUCCESS) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - File Busy");
                goto CONFLICT;
            }

            if (DropRef) {
                GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                             ActiveChangeOrder,
                                             TRUE);
                DropRef = FALSE;
            }

            ChgOrdReleaseLock(GuidLockSlot);
            GuidLockSlot = UNDEFINED_LOCK_SLOT;

        }
    }     // end of HI_AIB_T | HI_AIB_D

#if 0
    else {
        // Do we still need this?
        //
        // The FileGuid is zero (i.e. The file wasn't found in the IDTable).
        // Make sure the location command is either a create or a movein.
        //
        FRS_ASSERT(IS_GUID_ZERO(&CoCmd->FileGuid));

        LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
        if (!CO_NEW_FILE(LocationCmd)) {

            DPRINT1(0, "++ WARN - GUID is zero, Location cmd is not a create: %d\n",
                   LocationCmd);
            //
            // An update CO could arrive out of order relative to its create
            // if the create got delayed by a sharing violation.  We don't
            // want to lose the update so we make it look like a create.
            // This also handles the case of delte change orders generated
            // by name morph conflicts in which a rename arrives for a
            // nonexistent file.  We need to force a Name table conflict
            // check below.
            //
            ForceNameConflictCheck = TRUE;
        }
        //
        // We can't return yet.  Still need to check the parent dir.
        //
    }

#endif

    if (FlagChk(HI_EPA) && EitherParentAbsent) {
        //
        // If a parent DIR is missing (either original or new) then try later.
        // Note: The parent could be deleted but in that case we will reanimate it
        // if the CO is accepted.
        //

        FRS_ASSERT((ChangeOrder->OriginalParentFid == ZERO_FID) ||
                   (ChangeOrder->NewParentFid == ZERO_FID));
        //
        // Remove the CO entry from the queue.
        //
        FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

        //
        // Send this CO to retry to wait for the parent.
        //
        // we could still build the file/dir in the preinstall dir
        return ISSUE_RETRY_LATER;
    }

    // need to check dep on old parent dir in the case of a MOVE DIR



    if (FlagChk(HI_NC)) {
    //
    // Check if the parent DIR has an active CO on it.  If it does then
    // we can't issue this change order because the change on the parent
    // could affect the ACL or the RO bit or ...
    // Also check if there is a name conflict if this is a create or a rename.
    //

        FRS_ASSERT(SelectedParentPresent);

        FRS_ASSERT(!IS_GUID_ZERO(ChangeOrder->pParentGuid));

        FRS_ASSERT(GuidLockSlot == UNDEFINED_LOCK_SLOT);

        GuidLockSlot = ChgOrdGuidLock(ChangeOrder->pParentGuid);
        ChgOrdAcquireLock(GuidLockSlot);

        //
        // Check for name conflict on a create or a rename target.
        // Aliasing is possible in the hash table since we don't have the
        // full key saved.  So check for COs that remove a name since a
        // second insert with the same hash value would cause a conflict.
        //
        // If there is a conflict then set the "queue blocked" flag in
        // the name conflict table entry. The flag will be picked up by
        // the co that decs the entry's reference count to 0.
        //
        // NameConflictTable Entry: An entry in the NameConflictTable
        // contains a reference count of the number of active change
        // orders that hash to that entry and a Flags word that is set
        // to COE_FLAG_VOL_COLIST_BLOCKED if the process queue for this
        // volume is idled while waiting on the active change orders for
        // this entry to retire. The queue is idled when the entry at
        // the head of the queue hashes to this entry and so may
        // have a conflicting name (hence the name, "name conflict table").
        //
        // The NameConflictTable can give false positives. But this is okay
        // because a false positive is rare and will only idle the process
        // queue until the active change order retires. Getting rid
        // of the rare false positives would degrade performance. The
        // false positives that happen when inserting an entry into the
        // NameConflictTable are handled by using the QData field in
        // the QHashEntry as a the reference count.
        //
        // But, you ask, how can there be multiple active cos hashing to this
        // entry if the process queue is idled when a conflict is detected?
        // Easy, I say, because the filename in the co is used to detect
        // collisions while the filename in the idtable is used to reserve the
        // qhash entry.  Why?  Well, the name morph code handles the case of a
        // co's name colliding with an idtable entry.  But that code wouldn't
        // work if active change orders were constantly changing the idtable.
        // So, the NameConflictTable synchronizes the namespace amoung active
        // change orders so that the name morph code can work against a static
        // namespace.
        //
        // If this CO is a MORPH_GEN_FOLLOWER make sure we interlock with the
        // MORPH_GEN_LEADER.  The leader is removing the name so it makes an
        // entry in the name conflict table.  If the follower is a create it
        // will check against the name with one of the DOES_CO predicates
        // below, but if it is a file reanimation it may just look like an
        // update so always make the interlock check if this CO is a follower.
        //
        if (ForceNameConflictCheck          ||
            DOES_CO_CREATE_FILE_NAME(CoCmd) ||
            DOES_CO_REMOVE_FILE_NAME(CoCmd) ||
            DOES_CO_DO_SIMPLE_RENAME(CoCmd) ||
            COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER)) {

            ChgOrdCalcHashGuidAndName(&ChangeOrder->UFileName,
                                      ChangeOrder->pParentGuid,
                                      &QuadHashValue);
            //
            // There should be no ref that needs to be dropped here.
            //
            FRS_ASSERT(!DropRef);

            QHashAcquireLock(Replica->NameConflictTable);
            // MOVERS: check if we are looking at correct replica if this is a movers")
            QHashEntry = QHashLookupLock(Replica->NameConflictTable,
                                         &QuadHashValue);
            if (QHashEntry != NULL) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Name Table");
                GuidToStr(ChangeOrder->pParentGuid, GuidStr);
                DPRINT4(4, "++ NameConflictTable hit on file %ws, ParentGuid %s, "
                        "Key %08x %08x, RefCount %08x %08x\n",
                        ChangeOrder->UFileName.Buffer, GuidStr,
                        PRINTQUAD(QuadHashValue), PRINTQUAD(QHashEntry->QData));
                FRS_PRINT_TYPE(4, ChangeOrder);
                //
                // This flag will be picked up by the change order that
                // decs this entry's count to 0.
                //
                QHashEntry->Flags |= (ULONG_PTR)COE_FLAG_VOL_COLIST_BLOCKED;
                QHashReleaseLock(Replica->NameConflictTable);
                goto NAME_CONFLICT;
            }
            QHashReleaseLock(Replica->NameConflictTable);
        }
    }  // End of HI_NC




    if (FlagChk(HI_ASP)) {

        if (GuidLockSlot == UNDEFINED_LOCK_SLOT) {
            GuidLockSlot = ChgOrdGuidLock(ChangeOrder->pParentGuid);
            ChgOrdAcquireLock(GuidLockSlot);
        }

        //
        // Check for active change order on the parent Dir.
        //
        // ** NOTE ** Be careful with ActiveChangeOrder, we drop the ref on it later.
        //
        GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                            ChangeOrder->pParentGuid,
                            TRUE,
                            &ActiveChangeOrder);

        if (GStatus == GHT_STATUS_SUCCESS) {
            DropRef = TRUE;
            CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Parent Busy");
            goto CONFLICT;
        }

        FRS_ASSERT(!DropRef);
        ChgOrdReleaseLock(GuidLockSlot);
        GuidLockSlot = UNDEFINED_LOCK_SLOT;

    }   //  end of HI_ASP

#if 0
// still need this?
    } else {
        DPRINT(0, "++ ERROR - ParentGuid is 0.  Need to check if this op is on root\n");
        FRS_PRINT_TYPE(0, ChangeOrder);
        // add check for the FID or OID being the root dir of the tree
    }
#endif



    if (FlagChk(HI_AOP)) {

        //
        // Check for a conflict with some operation on the Original parent FID if
        // this is a MOVEOUT, MOVERS or a MOVEDIR.
        //
        LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
        if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {

            FRS_ASSERT(OrigParentPresent);

            FRS_ASSERT(!IS_GUID_ZERO(&CoCmd->OldParentGuid));

            FRS_ASSERT(GuidLockSlot == UNDEFINED_LOCK_SLOT);

            GuidLockSlot = ChgOrdGuidLock(&CoCmd->OldParentGuid);
            ChgOrdAcquireLock(GuidLockSlot);
            //
            // ** NOTE ** Be careful with ActiveChangeOrder, we drop the
            //            ref on it later.
            //
            GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                                &CoCmd->OldParentGuid,
                                TRUE,
                                &ActiveChangeOrder);

            if (GStatus == GHT_STATUS_SUCCESS) {
                DropRef = TRUE;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Orig Parent Busy");
                goto CONFLICT;
            }

            FRS_ASSERT(!DropRef);
            ChgOrdReleaseLock(GuidLockSlot);
            GuidLockSlot = UNDEFINED_LOCK_SLOT;

        }
    } // End of HI_AOP



#if 0
// Remove ???
    //
    // Check if this is an operation on a directory with change orders still
    // active on any children.  As an example there could be an active CO that
    // deletes a file and this change order wants to delete the parent directory.
    //
    // But.. A new dir can't have any change orders active beneath it.
    //       Neither can a delete co generated to produce a tombstone.
    //
    if (!TargetPresent ||
       (!RemoteCo && (LocationCmd == CO_LOCATION_DELETE) &&
                         CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN))) {

        return ISSUE_OK;
    }
#endif



    if (FlagChk(HI_AC)) {

        QHashAcquireLock(pVme->ActiveChildren);
        QHashEntry = QHashLookupLock(pVme->ActiveChildren,
                                     &ChangeOrder->Cmd.FileGuid);

        //
        // If the conflict was on a dir that has change orders outstanding on one
        // or more children then set the flag bit to unblock the queue when the
        // count goes to zero.
        //
        if (QHashEntry != NULL) {
            CHAR FileGuidString[GUID_CHAR_LEN];
            GuidToStr(&ChangeOrder->Cmd.FileGuid, FileGuidString);
            DPRINT2(4, "++ GAC: Interlock - Active children (%d) under GUID %s\n",
                   QHashEntry->QData>>1, FileGuidString);

            if (!CoCmdIsDirectory(CoCmd)) {
                DPRINT(0, "++ ERROR - Non Dir entry in pVme->ActiveChildren hash table.\n");
                FRS_PRINT_TYPE(4, ChangeOrder);
            }

            //
            //  Set the flag and idle the queue and drop the table lock.
            //
            QHashEntry->QData |= 1;
            FrsRtlIdleQueueLock(CoProcessQueue);
            QHashReleaseLock(pVme->ActiveChildren);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "IsConflict - Child Busy");
            return ISSUE_CONFLICT;
        }

        QHashReleaseLock(pVme->ActiveChildren);

    }  // End of HI_AC.



    //
    // If there are any remote change orders pending for retry of the install then
    // check to see if this change order guid matches.  If it does then we
    // can retire this change order since it is a duplicate and we already
    // have the staging file.
    //
    // need to enable")
    if (0 && RemoteCo &&
        !CoCmdIsDirectory(CoCmd) &&
        (ChangeOrder->NewReplica->InLogRetryCount > 0)) {

        // PERF: add code to lookup CO by GUID and check for match")
        // return with a change order reject error code
        //
        // Remove the duplicate entry from the queue.
        //
        FrsRtlRemoveEntryQueueLock(CoProcessQueue, &ChangeOrder->ProcessList);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_ONLIST);

        return ISSUE_REJECT_CO;
    }


    return ISSUE_OK;

    //
    // Issue conflict on the file or on the parent dir.  Set flag in Active
    // Change order to unblock the queue on retire and then drop the change
    // order GUID lock.
    //
CONFLICT:

    SET_COE_FLAG(ActiveChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);

    DPRINT1(4, "++ GAC Setting COE_FLAG_VOL_COLIST_BLOCKED, block on: %08x %08x\n",
            PRINTQUAD(ActiveChangeOrder->FileReferenceNumber));

    //
    // Conflict detected in name conflict table
    //
NAME_CONFLICT:

    if (DropRef) {
        GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                     ActiveChangeOrder,
                                     TRUE);
    }

    //
    //  Idle the queue and drop the change order lock.
    //
    FrsRtlIdleQueueLock(CoProcessQueue);

    FRS_ASSERT(GuidLockSlot != UNDEFINED_LOCK_SLOT);

    ChgOrdReleaseLock(GuidLockSlot);

    return ISSUE_CONFLICT;
}





BOOL
ChgOrdReconcile(
    PREPLICA            Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder,
    PIDTABLE_RECORD     IDTableRec
    )
/*++
Routine Description:

    Reconcile the incoming change order with the current state of the file
    or dir in question.

    Some special casing is done for duplicate remote change orders.  The same
    change order can arrive from multiple inbound partners before the version
    vector can advance to dampen it.  The first CO in the set of duplicates is
    called X for the purpose of discussion.  The rest are called the
    duplicates.  The duplicate COs will end up in the inbound log if CO X fails
    to fetch the staging file.  This allows any of the duplicates to retry the
    Fetch operation later.  Any CO (either X or a duplicate) that ultimately
    completes the Fetch successfully updates the IDTable entry and activates
    the version vector retire slot that maintains ordering of the change orders
    as they propagate to the outbound log.  It (along with the outlog process)
    is also responsible for cleaning up the staging file.  Finally this CO is
    responsible for updating the version vector (through activation of the VV
    slot).

    At this point if the CO fails to complete the file install phase its state
    is marked as either IBCO_INSTALL_RETRY or IBCO_INSTALL_REN_RETRY or
    IBCO_INSTALL_DEL_RETRY.  Any
    other Dup COs are in the fetch retry or fetch request state.  The reconcile
    state (used in this function) in the IDTable entry for the file will now
    match the state in any of the duplicate COs still in the inbound log.  So
    they will be rejected on retry.  Note that the duplicate COs still need to
    ACK their inbound partners and delete their entry from the inbound log.
    They do not update the version vector since that was done by the CO
    completing the fetch.

Arguments:

    Replica -  Replica set this change order applies to.  Used to get config
               record.

    ChangeOrder - Change order entry

    IDTableRec - The IDTable record to test this change order against.

Return Value:

    TRUE if change order is accepted,  FALSE if rejected.

--*/

{
#undef DEBSUB
#define DEBSUB  "ChgOrdReconcile:"

    LONGLONG             EventTimeDelta;
    LONGLONG             SizeDelta;
    LONG                 VersionDelta;
    LONG                 RStatus;
    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;


    FRS_ASSERT(IDTableRec != NULL);

    //
    // The sequence of events are complicated:
    //
    // 1. A remote co for an update comes in for a tombstoned idtable entry.
    //
    // 2. The remote co becomes a reanimate co.
    //
    // 3. The reanimate remote co loses a name conflict to another idtable entry.
    //
    // 4. A MorphGenCo for a local delete is generated for the
    //    reanimate remote co that lost the name conflict.
    //
    // 5. The MorphGenCo completes and updates the version so that the
    //    original reanimate co that lost the name conflict will be
    //    rejected.
    //
    // 6. The upcoming check for a leaf node (i.e. no outbound partners)
    //    accepts the original reanimate co and the service goes back to step 1
    //    causing a Morph Gen loop.  To avoid this the following flag is
    //    set when the Morph Gen Co is created.
    //
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE)) {
        DPRINT(4, "++ ChangeOrder rejected based on COE_FLAG_REJECT_AT_RECONCILE\n");
        return FALSE;
    }

    //
    // If this member has no outbound partners AND has changed the file
    // previously we accept.  We detect this by comparing the Originator GUID
    // in the IDTable entry with the GUID of this member.  This avoids problems
    // where a leaf member modifies a file, thereby rejecting an update until
    // the version number test or event time test causes an accept.  A leaf
    // member should not be trying to change replicated files.
    //
    if (NO_OUTLOG_PARTNERS(Replica) &&
       GUIDS_EQUAL(&IDTableRec->OriginatorGuid, &Replica->ReplicaVersionGuid)) {
        DPRINT(4, "++ ChangeOrder accepted based on leaf node\n");
        return TRUE;
    }

    //
    // If the change order is in the IBCO_INSTALL_DEL_RETRY state then
    // accept or reject it based on the COE_FLAG_NEED_DELETE flag.
    // COE_FLAG_NEED_DELETE was set in ChgOrdReadIDRecord() when we found the
    // IDREC_FLAGS_DELETE_DEFERRED flag set.  See comments in schema.h for
    // IDREC_FLAGS_DELETE_DEFERRED for more details on this scenario.
    //
    if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
         return COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE);
    }

    // PERF: Add test of USN on the file to USN in CO (if local) to see if
    //       another Local CO could be on its way.
    //
    // The EventTimeDelta is the difference between the changeorder EventTime
    // and the saved EventTime in the IDTable of the last change order we
    // accepted.  If the EventTimeDelta is within plus or minus RecEventTimeWindow
    // then we move to the next step of the decsion sequence.  Otherwise
    // we either accept or reject the changeorder.
    //
    EventTimeDelta = CoCmd->EventTime.QuadPart - IDTableRec->EventTime;

    if (EventTimeDelta > (LONGLONG)(0)) {
        if (EventTimeDelta > RecEventTimeWindow) {
            DPRINT1(4, "++ ChangeOrder accepted based on EventTime > window: %08x %08x\n",
                   PRINTQUAD(EventTimeDelta));
            return TRUE;
        }
    } else {
        if (-EventTimeDelta > RecEventTimeWindow) {
            DPRINT1(4, "++ ChangeOrder rejected based on EventTime < window: %08x %08x\n",
                   PRINTQUAD(EventTimeDelta));
            return FALSE;
        }
    }

    DPRINT1(4, "++ ChangeOrder EventTime inside window: %08x %08x\n", PRINTQUAD(EventTimeDelta));

    //
    // The Changeorder eventtime is within the RecEventTimeWindow.  The next
    // step is to look at the version number of the file.  The version number
    // is updated each time the file is closed after being modified.  So it
    // acts like a time based on the rate of modification to the file.
    //
    VersionDelta = (LONG) (CoCmd->FileVersionNumber - IDTableRec->VersionNumber);

    if ( VersionDelta != 0 ) {
        DPRINT2(4, "++ ChangeOrder %s based on version number: %d\n",
                (VersionDelta > 0) ? "accepted" : "rejected", VersionDelta);
        return (VersionDelta > 0);
    }


    DPRINT(4, "++ ChangeOrder VersionDelta is zero.\n");

    //
    // The EventTimeDelta is inside the window and the Version Numbers match.
    // This means that the file was changed at about the same time on two
    // different members.  We have to pick a winner so we use EventTimeDelta
    // again to decide.
    //
    if ( EventTimeDelta != 0 ) {
        DPRINT2(4, "++ ChangeOrder %s based on narrow EventTime: %08x %08x\n",
                (EventTimeDelta > 0) ? "accepted" : "rejected",
                PRINTQUAD(EventTimeDelta));
        return (EventTimeDelta > 0);
    }

    DPRINT(4, "++ ChangeOrder EventTimeDelta is zero.\n");

    //
    // Both the version numbers and EventTimes match.  Check the file sizes.
    //
    SizeDelta = (LONGLONG) (CoCmd->FileSize - IDTableRec->FileSize);

    if ( SizeDelta != 0 ) {
        DPRINT2(4, "++ ChangeOrder %s based on file size: %d\n",
                (SizeDelta > 0) ? "accepted" : "rejected", SizeDelta);
        return (SizeDelta > 0);
    }

    DPRINT(4, "++ ChangeOrder SizeDelta is zero.\n");

    //
    // The final compare is to do a comparison of the Originator Guids.
    // If the Originator Guid of the incoming change order is greater
    // or equal to the Guid in the IDTable Record then we accept the
    // new change order.
    //
    RStatus = FrsGuidCompare(&CoCmd->OriginatorGuid,
                             &IDTableRec->OriginatorGuid);

    //
    // But first check to see if this is a duplicate change order
    // (Originator GUID matches value in ID record and OriginatorVSN
    // matches too).  This closes a window where the duplicate changeorder
    // is blocked behind another change order in the queue but past the point
    // of the dampening check.  The Active CO retires, unblocking the queue, and
    // now the blocking CO issues followed by the dup CO issue.
    //
    if (RStatus == 0) {
        //
        // If the change order is in the IBCO_INSTALL_REN_RETRY state then
        // accept or reject it based on the COE_FLAG_NEED_RENAME flag.
        // COE_FLAG_NEED_RENAME was set in ChgOrdReadIDRecord() when we found the
        // IDREC_FLAGS_RENAME_DEFERRED flag set.  See comments in
        // ChgOrdReadIDRecord() for more details on this scenario.
        //
        // Note:  We still have to go thru the above reconcile tests since there
        // could be multiple COs in the IBCO_INSTALL_REN_RETRY state and we
        // need to reject all of them except the most recent.  A sharing violation
        // on the target could cause this and depending on the timing of the
        // close of the file the next INSTALL_REN_RETRY CO to issue will do
        // the rename.  (This may not be a problem since the data from the
        // final rename should come from the IDTable entry not the CO.  The
        // IDTable entry should be current so that subsequent name morph
        // collision checks are accurate.)
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            //
            // Accept the CO if the file still needs to be renamed.
            // If a dup CO got to it first we would still match but if the
            // rename is done then don't do it again.
            //
            if (COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {
                DPRINT(4, "++ Remote ChangeOrder accepted based on retry rename-only\n");
            }
            return COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME);
        }


        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            //
            // Accept the CO if the file still needs to be deleted.
            // If a dup CO got to it first we would still match but if the
            // delete is done then don't do it again.
            //
            if (COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
                DPRINT(4, "++ Remote ChangeOrder accepted based on retry delete-only\n");
            }
            return COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE);
        }


        if (IDTableRec->OriginatorVSN == CoCmd->FrsVsn) {
            //
            // Duplicate retries are okay if the retry is a Dir Enum request.
            //
            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)) {
                if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {
                    if (CO_STATE_IS(ChangeOrder, IBCO_ENUM_REQUESTED)) {
                        DPRINT(4, "++ Local ChangeOrder accepted based on ENUM REQUESTED\n");
                        return TRUE;
                    }
                }
#if 0
        //
        // This code will also do a retry on a CO in the INSTALL_RETRY state.
        // This is wrong since if the reconcile state matches the install has
        // already been done and the staging file may have been deleted.  The
        // Cases for rename retry and delete retry are handled above.
        //
        // Butttt...if the disk fills we also go into install retry but if the
        // CO is not accepted here it is rejected for sameness.  Then it doesn't
        // get installed.  ??? Why does the IDTable get updated on install retry?
        //
        // The above comment may be moot at this point (3/2000) but we need
        // to do some more disk full related tests to be sure we aren't dropping
        // any files.  -- Davidor
        //
                else {
                    if (CO_STATE_IS_INSTALL_RETRY(ChangeOrder)) {
                        DPRINT(4, "++ Remote ChangeOrder accepted based on retry rename-only\n");
                        return TRUE;
                    }
                }
#endif

            }

            DPRINT(4, "++ ChangeOrder rejected for sameness\n");
            return FALSE;
        }
    } else {
        //
        // In highly connected environments lots of identical name morph
        // conflicts could occur, generating a flurry of undampened COs.  Since
        // it doesn't really matter which originator produced a given morph
        // generated CO we use CO_FLAG_SKIP_ORIG_REC_CHK to tell downstream
        // partners to skip this part of the reconcile check.  When the
        // same conflict is detected on two members they will produce change
        // orders with the same event time, version number and size.  When both
        // COs arrive at another member the second will be rejected for sameness
        // if we skip the originator guid check.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_SKIP_ORIG_REC_CHK)) {
            DPRINT(4, "++ ChangeOrder rejected for sameness -- SKIP_ORIG_REC_CHK\n");
            return FALSE;
        }
    }

    DPRINT2(4, "++ ChangeOrder %s based on guid (RStatus = %d)\n",
            (RStatus >= 0) ? "accepted" : "rejected", RStatus);
    return (RStatus >= 0);
}


BOOL
ChgOrdGenMorphCo(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            TmpIDTableCtxNC,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    )
/*++
Routine Description:

    If there is a name morph conflict we have the following cases:

    Incoming CO    IDTable Entry with name conflict
      File          File   Send out del CO for IDTable Entry to free name
      File          Dir    Dir wins the name convert CO to delete CO. (1)
      Dir           File   Dir wins the name build del CO for IDTable (2)
      Dir           Dir    send out Tree del CO for IDTable Entry to free name. (3)

    When a Local CO is built from an IDTable record the file version
    number is set to the value in the IDTable record plus one.  Since
    this is marked as a MorphGenCo this version number will not be
    revised later if this CO ends up going through retry.

    If a Local Co is built from the incoming change order (ChgOrdConvertCo)
    the file version number is set to the value of the incoming CO + 1.
    This ensures the newly generated CO will be accepted even if there
    already exists an IDTable entry for the incoming CO.  The latter
    could happen if the incoming CO is a rename or if it is a prior
    create Co that has been stuck in the IBCO_INSTALL_RETRY or
    IBCO_INSTALL_REN_RETRY states.  In addition if the incoming CO is
    a create CO that is losing its bid for the name then the delete Co
    we create will go out first, creating a tombstone, and we want the
    the original incoming CO to follow and be rejected when it matches
    up against the tombstone.

    Notes:

    (1) The incoming CO must be sent out as a delete CO because other
    replica set members may not experience the name conflict if a rename
    on the Dir occurred before this CO arrived.  So to ensure that the
    file associated with the incoming CO is gone everywhere we send out
    a delete Co.

    (2) In the case of a name morph conflict where the incoming CO is a
    directory and the current owner of the name is a file, the file
    will lose.  Otherwise we will have to abort all subsequent child creates.
    Send out a Delete Co on the IDtable record for the same reason as in (1).

    (3) re: tree del co.
    This can be a problem.  What if a new replica set member that has not
    yet synced up gets a local create dir that conflicts with an existing
    dir?  We send out the create dir which then causes that entire
    subtree to get deleted everywhere.  This is not good.  A better
    solution in this case is to just morph the dir name, giving
    priority to the name to the OLDER entry.

    Notation:

    The following 3 letter notation is used to distinguish the cases:

    The first D or F refers to the incoming CO and says if it's a dir or a file.
    The second D or F refers to the current entry in the IDTable with the same
    name (hence the name morph conflict) and if it's a dir or a file.
    The L appears as a suffix after the first (or second) D or F, indicating
    that either the incoming CO lost the name morph conflict or the IDTable
    entry lost the name morph conflict, respectively.  So there are 6 cases:


          Incoming CO is a     IDTable entry is for a     Outcome
    FFL -      file,                   file,              IDT entry loses.
    FLF -      file,                   file,              Incoming CO loses.

    FLD -      file,                   dir,               Incoming CO loses.
    DFL -      dir,                    file,              IDT entry loses.

    DDL -      dir,                    dir,               IDT entry loses.
    DLD -      dir,                    dir,               Incoming CO loses.


    There are two change orders produced as the result of any name morph
    conflict.  One is the modified incoming CO and the other is refered to
    as the MorphGenCo.  The MorphGenCo is always a local CO that gets proped
    to all other replica set members so they know the outcome of the morph
    conflict decision.  The MorphGenCo may be fabricated from either the
    incoming CO or from the IDTable entry with the same name.  If the loser
    of a name morph conflict is a file then the MorphGenCo will be a delete
    change order.  On the other hand if the loser is a directory then the
    MorphGenCo will be a rename change order to produce a nonconflicting
    directory name.

    In all cases above two change orders are pushed back onto the front of the
    process queue and processing is started over again.  The first CO that gets
    pushed back onto the process queue is termed the "follower" since it will
    issue second.  The second CO that gets pushed onto the process queue is termed
    the "leader" since it will issue first when processing resumes.

    In all cases above, except DLD, the Leader is the MorphGenCo and its job
    is to remove the name conflict.  In the DLD case the incoming CO loses the
    name so it is given a new name and will be leader.  The MorphGenCo is
    the follower in this case and is a rename CO that gets proped out to tell
    all downstream partners about the name change.

    Other details:

    MorphGenCos never go into the inbound log.  If the incoming CO fails to
    complete and must go thru retry then the MorphGenCo is aborted if it is
    the follower (DLD case).  If the MorphGenCo is the leader and it fails
    to complete then it is aborted and when the follower reissues it will
    experience a recurrance of the name morph conflict implying that the leader
    failed so it is sent thru retry and will be resubmitted later.  The leader
    might fail because of a sharing violation on the existing file or the
    journal connection could be shutting down.

    The reason that the MorphGenCos don't get put into the Inbound log is that
    if we were to crash or shutdown between before completing both change
    orders they could get restarted out of order.  The MorphGenCo is a local
    Co and the Incoming Change Order could be a remote CO.  So at restart
    the COs are inserted into the process queue as each inbound connection
    is re-established.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    TmpIDTableCtxNC -- The table context to use for IDT table access for the
                       entry with the name conflict.
    ChangeOrder-- The change order.
    Replica    -- The Replica set context.

Return Value:

    True if morph change orders were generated OK.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdGenMorphCo:"

#define MORPH_FILE_FILE 0
#define MORPH_FILE_DIR  1
#define MORPH_DIR_FILE  2
#define MORPH_DIR_DIR   3


    PCHANGE_ORDER_RECORD CoCmd = &ChangeOrder->Cmd;

    PIDTABLE_RECORD  NameConflictIDTableRec;

    ULONG MorphCase;
    BOOL  MorphNameIDTable, MorphOK, MorphGenLeader;


    //
    // If we have already been here once and marked as a MorphGenLeader
    // then this is a create DIR and we go straight to the DIR/Dir case.
    // NOTE: The NameConflictIDTableRec is not valid in this case since
    // the name had already been morphed on a prior visit so use the
    // existing name to refabricate the MorphGenFollower rename co.
    //
    MorphGenLeader = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER);

    NameConflictIDTableRec = (PIDTABLE_RECORD) TmpIDTableCtxNC->pDataRecord;


    MorphCase = 0;
    if (CoIsDirectory(ChangeOrder)) {
        MorphCase += 2;
    }
    if (MorphGenLeader ||
        BooleanFlagOn(NameConflictIDTableRec->FileAttributes,
                      FILE_ATTRIBUTE_DIRECTORY)) {
        MorphCase += 1;
    }

    MorphOK = FALSE;

    switch (MorphCase) {

    case MORPH_FILE_FILE:
        //
        // Incoming CO: File     IDTable Entry: File
        //
        // Reconcile decides who wins the name.
        // If incoming Co loses then generate a delete CO with us
        // as the originator. (get new VSN).
        // If IDtable loses the name then push incoming CO back onto
        // the process queue and generate a delete CO for the IDTable
        // entry to free the name.
        //
        if (ChgOrdReconcile(Replica, ChangeOrder, NameConflictIDTableRec)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - FFL, Name Morph, Del IDT");

            //
            // Push incoming CO first with same version number.
            // Push local delete CO for IDT file with vers num = IDT+1
            //
            MorphOK = ChgOrdMakeDeleteCo(ChangeOrder,
                                         Replica,
                                         ThreadCtx,
                                         NameConflictIDTableRec);
        } else {
            //
            // Build a delete CO unless this is a duplicate CO.
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co rejected - FLF, Name Morph, Del Inc CO");

            //
            // Push incoming CO first with same version number.
            // Push local delete CO for incoming CO with
            // vers num = incoming CO + 1
            //
            // Ensure that incoming Co gets rejected later.  If this was a
            // Leaf node member (i.e. no outbound partners) we would always
            // accept remote Cos and get into a Morph Gen loop.  See comments
            // in ChgOrdReconcile().
            // Set this flag here since after the call below the CO is back
            // on the queue and we can't touch it.
            //
            SET_COE_FLAG(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE);

            MorphOK = ChgOrdConvertCo(ChangeOrder,
                                      Replica,
                                      ThreadCtx,
                                      CO_LOCATION_DELETE);
            if (!MorphOK) {
                CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE);
            }
        }
        break;

    case MORPH_FILE_DIR:
        //
        // Incoming CO: File     IDTable Entry: Dir
        //
        // Name stays with the Dir in IDTable.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co rejected - FLD, Name Morph, Del Inc CO");
        //
        // Push incoming CO first with same version number.
        // Push local delete CO for incoming CO with
        // vers num = incoming CO + 1
        //
        // Ensure that incoming Co gets rejected later.  If this was a
        // Leaf node member (i.e. no outbound partners) we would always
        // accept remote Cos and get into a Morph Gen loop.  See comments
        // in ChgOrdReconcile().
        // Set this flag here since after the call below the CO is back
        // on the queue and we can't touch it.
        //
        SET_COE_FLAG(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE);

        MorphOK = ChgOrdConvertCo(ChangeOrder, Replica, ThreadCtx, CO_LOCATION_DELETE);
        if (!MorphOK) {
            CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_REJECT_AT_RECONCILE);
        }
        break;

    case MORPH_DIR_FILE:
        //
        // Incoming CO: Dir     IDTable Entry: File
        //
        // Name goes with incoming Dir CO.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - DFL, Name Morph, Del IDT");

        //
        // Push incoming CO first with same version number.
        // Push local delete CO for IDT file with vers num = IDT+1
        //
        MorphOK = ChgOrdMakeDeleteCo(ChangeOrder,
                                     Replica,
                                     ThreadCtx,
                                     NameConflictIDTableRec);
        break;

    case MORPH_DIR_DIR:
        //
        // Incoming CO: Dir     IDTable Entry: Dir
        //
        // Priority to the name goes to which ever is older.
        // The other gets a new name.
        // If incoming CO loses then just morph its name and send
        // out a rename CO.
        // If IDTable record loses then push this CO back onto the queue
        // and generate a rename Co.
        //
        if (MorphGenLeader) {
            // Use name as given in CO.  See comment above.
            MorphNameIDTable = FALSE;
            //
            // THis better be a dir CO and we should not be here if the
            // MorphGenFollower has already been fabricated.
            //
            FRS_ASSERT(CoIsDirectory(ChangeOrder));
            FRS_ASSERT(!COE_FLAG_ON(ChangeOrder, COE_FLAG_MG_FOLLOWER_MADE));
            DPRINT(4, "++ MorphGenLeader - IDTable entry loses name\n");
        } else
        if (CoCmd->EventTime.QuadPart > NameConflictIDTableRec->EventTime) {

            // IDTable wins the name.  Morph the change order.
            MorphNameIDTable = FALSE;
            DPRINT2(4, "++ IDTable entry wins name - CoEvt: %08x %08x, IdEvt: %08x %08x\n",
                   PRINTQUAD(CoCmd->EventTime.QuadPart),
                   PRINTQUAD(NameConflictIDTableRec->EventTime));
        } else
        if (CoCmd->EventTime.QuadPart < NameConflictIDTableRec->EventTime) {

            // Incoming CO wins the name,  Morph the IDTable entry.
            MorphNameIDTable = TRUE;
            DPRINT2(4, "++ IDTable entry loses name - CoEvt: %08x %08x, IdEvt: %08x %08x\n",
                   PRINTQUAD(CoCmd->EventTime.QuadPart),
                   PRINTQUAD(NameConflictIDTableRec->EventTime));
        } else {

            LONG RStatus1;

            DPRINT2(4, "++ IDTable Evt matches Co Evt - CoEvt: %08x %08x, IdEvt: %08x %08x\n",
                   PRINTQUAD(CoCmd->EventTime.QuadPart),
                   PRINTQUAD(NameConflictIDTableRec->EventTime));

            RStatus1 = FrsGuidCompare(&CoCmd->OriginatorGuid,
                                      &NameConflictIDTableRec->OriginatorGuid);
            MorphNameIDTable = (RStatus1 >= 0);
            DPRINT1(4, "++ Orig Guid Compare - IDTable entry %s name.\n",
                   (MorphNameIDTable ? "Loses" : "Wins"));

            if (RStatus1 == 0) {
                //
                // Looks like a duplicate.  Same event time same orig guid
                //
                DPRINT(0, "++ Warning: DIR_DIR Morph Conflict where Orig Guid in CO equals IDTrecord\n");
                DBS_DISPLAY_RECORD_SEV(0, TmpIDTableCtxNC, TRUE);
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"DIR_DIR Morph Conflict where Orig Guid in CO equals IDTrecord");

                //
                // add the following as part of the return path if we can ever
                // hit this case legitimately.
                //
                //CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - DupCo");
                //ChgOrdReject(ChangeOrder, Replica);
                //goto CO_CLEANUP;
            }
        }

        if (MorphNameIDTable) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - DDL, Name Morph IDT");
            //
            // Push incoming CO first with same version number.
            // Push local rename CO for IDT Dir with vers num = IDT+1
            //
            MorphOK = ChgOrdMakeRenameCo(ChangeOrder,
                                         Replica,
                                         ThreadCtx,
                                         NameConflictIDTableRec);
        } else {
            //
            // Incoming CO loses the name.
            //
            if (MorphGenLeader) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - DLD, Follower Regen");
            } else {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Accepted - DLD, Dir-Dir Name Morph Inc CO");
            }
            //
            // Push local rename CO for incoming CO with
            // vers num = incoming CO + 1
            // Push incoming CO with same version number and morphed name.
            //
            MorphOK = ChgOrdConvertCo(ChangeOrder,
                                      Replica,
                                      ThreadCtx,
                                      CO_LOCATION_NO_CMD);
        }

        break;

    default:
        FRS_ASSERT(!"Invalid morph case");
    }  // end switch

    return MorphOK;
}



BOOL
ChgOrdApplyMorphCo(
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    )
/*++
Routine Description:

    Apply the name change requested by the MorphGenCo to resolve the name
    conflict.


Arguments:
    ChangeOrder-- The change order.
    Replica    -- The Replica set context.

Return Value:

    True if name change required to resolve the name conflict succeeded.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdApplyMorphCo:"



ULONG WStatus;
ULONG LocationCmd;


    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

    if (LocationCmd == CO_LOCATION_DELETE) {

        //
        // Delete the underlying file to free the name.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Del Name Morph IDT loser");

        WStatus = StuDelete(ChangeOrder);
        if (WIN_SUCCESS(WStatus)) {
            return TRUE;
        }

        CHANGE_ORDER_TRACEX(3, ChangeOrder, "Del IDT loser FAILED. WStatus=", WStatus);
        //
        // Let the MorphGenCo go if it is not the leader.
        // Otherwise reject it so the follower is forced thru retry.
        //
        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER)) {
            return TRUE;
        }

    } else
    if (BooleanFlagOn(ChangeOrder->Cmd.ContentCmd, USN_REASON_RENAME_NEW_NAME)) {

        //
        // Rename the underlying dir to free the name.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Ren Name Morph IDT loser");

        WStatus = StuInstallRename(ChangeOrder, FALSE, TRUE);
        if (WIN_SUCCESS(WStatus)) {
            return TRUE;
        }

        CHANGE_ORDER_TRACEX(3, ChangeOrder, "Ren IDT loser FAILED. WStatus=", WStatus);

        //
        // Let the MorphGenCo go if it is not the leader.
        // Otherwise reject it so the follower is forced thru retry.
        //     The install rename can fail if a dir create causes a
        // parent reanimate and while the dir create is in process a second dir
        // create arrives and wins the name.  THis generates a rename MorphGenCo
        // for the in-process dir create.  Meanwhile if a local CO deletes the
        // reanimated parent (no fooling) before the first dir create is renamed
        // into place then the first dir create will go into rename retry state.
        // That unblocks the process queue so the rename MorphGenco issues and
        // it fails too because the parent dir is not present.  It later tries
        // to go thru retry and fails because local MorphGenCOs can't have
        // rename retry failures.
        //     Another scenario is the DLD case (see ChgOrdGenMorphCo()) where
        // the incoming dir create loses the name morph conflict.  In this case
        // the MorphGenCo is a follower that props out a rename CO.  However if
        // the stage file fetch for the leader Create CO fails (file was deleted
        // upstream) then there is no file to rename.  But since we can't tell
        // if the file not found status is on the parent dir or on the actual
        // target we let the FOLLOWER go.  It will get aborted later in
        // StageCsCreateStage() when we fail to generate the stage file.
        //
        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER)) {
            return TRUE;
        }

    } else {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Invalid MorphGenCo");
    }

    ChgOrdReject(ChangeOrder, Replica);
    return FALSE;

}


ULONG
ChgOrdReanimate(
    IN PTABLE_CTX          IDTableCtx,
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PTABLE_CTX          TmpIDTableCtx
    )
/*++
Routine Description:

   Check if we have to reanimate the parent directory for this change order.

Arguments:
   IDTableCtx    -- The IDTable context for the current change order.
   ChangeOrder   -- The change order.
   Replica       -- The Replica struct.
   ThreadCtx     -- ptr to the thread context for DB
   TmpIDTableCtx -- The temporary ID Table context to use for reading the IDTable
                    to reanimate the CO.

Return Value:

   REANIMATE_SUCCESS       : Reanimation was required and succeeded.
   REAMIMATE_RETRY_LATER   : Parent reanimation failed, send base CO thru retry.
   REANIMATE_CO_REJECTED   : Can't reanimation for this CO so reject the CO.
   REANIMATE_FAILED        : Internal error.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdReanimate:"

    JET_ERR               jerr, jerr1;
    PCHANGE_ORDER_RECORD  CoCmd = &ChangeOrder->Cmd;
    PCHANGE_ORDER_ENTRY   DeadCoe;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    ULONG                 FStatus, GStatus, WStatus;
    BOOL                  LocalCo, ReAnimate, DemandRefreshCo;

    PIDTABLE_RECORD IDTableRec = (PIDTABLE_RECORD) (IDTableCtx->pDataRecord);
    PIDTABLE_RECORD IDTableRecParent = NULL;

    LocalCo         = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    DemandRefreshCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH);
    ReAnimate       = IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED);

    //
    // If this is a local file op that was updating a file just milliseconds
    // before a previously issued remote co deleted the file then don't
    // try to reanimate since there is no data upstream anyway.  There are
    // 3 cases here:
    //   1. If the local user does the file update after the remote co delete
    // (via file reopen and write back) then a new file is created with
    // a new FID and object ID.  New data is replicated, User is happy.
    //   2. If the user did the update just before we started processing
    // the remote CO then reconcile will probably reject the remote co delete.
    //   3. If the user does the update between the time where we issue
    // the remote co delete and we actually delete the file then the user
    // loses.  This is no different than if the user lost the reconcile
    // decision in step 2.  Since we reject the local CO the remote CO
    // delete continues on and the file is deleted everywhere.
    //
    // Note:  There is one case where reanimation by a Local Co does make sense.
    // If an app has a file open with sharing mode deny delete and we get a
    // remote co to delete the file, the remote co will get processed and the
    // IDTable entry is marked deleted (although our attempt to actually delete
    // the file will fail with a sharing violation).  Later the app updates the
    // file and then closes it.  We see the update USN record and need to
    // reanimate since it will have a more recent event time.
    //
    if (ReAnimate &&
        LocalCo &&
        !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {
        //
        // A local Co can't reanimate a deleted file.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - No Local Co revival");
        DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, FALSE);
        FRS_PRINT_TYPE(3, ChangeOrder);
        ChgOrdReject(ChangeOrder, Replica);
        return REANIMATE_CO_REJECTED;
    }
    //
    // Don't bother to reanimate the parent for a delete. This can happen
    // if the file is stuck in the preinstall or staging areas and not
    // really in the deleted directory. Let the delete continue w/o
    // reanimation.
    //
    // Make this check before the local co check to avoid morphgenco
    // asserts when this CoCmd is a del of the IDT loser.
    //
    if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
        return REANIMATE_NO_NEED;
    }

    //
    // Read the IDTable entry for the parent
    //
    jerr = DbsReadRecord(ThreadCtx, &CoCmd->NewParentGuid, GuidIndexx, TmpIDTableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"++ ERROR - DbsReadRecord failed;", jerr);
        ChgOrdReject(ChangeOrder, Replica);
        return REANIMATE_CO_REJECTED;
    }

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    // perf: With multiple replica sets we may need a different
    //       IDTable for the next CO we process.  Could just check if
    //       there is a replica change and only close then. Or put the
    //       tmp table ctx in the replica struct so we can just switch.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
    DPRINT_JS(0,"++ ERROR - JetCloseTable failed:", jerr1);

    IDTableRecParent = (PIDTABLE_RECORD) (TmpIDTableCtx->pDataRecord);
    //
    // Parent should be marked deleted or why are we here?
    //
    FRS_ASSERT(IsIdRecFlagSet(IDTableRecParent, IDREC_FLAGS_DELETED));

    if (LocalCo && !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED) &&
        !IsIdRecFlagSet(IDTableRecParent, IDREC_FLAGS_DELETE_DEFERRED)) {
        //
        // Don't know how to revive a dead parent of a local CO.  How did it
        // get to be dead in the first place?  Here is how: If a local file op
        // is updating a file just before a previously issued remote CO
        // executes to delete the file followed by a second remote co to
        // delete the parent then we end up here with an update Local Co with
        // a deleted parent.  So, don't assert just reject the local co and
        // let the remote Co win since it already won upstream so there is no
        // data around to reanimate the file with.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Cant revive dead par of lcl co");
        DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, FALSE);
        FRS_PRINT_TYPE(3, ChangeOrder);
        ChgOrdReject(ChangeOrder, Replica);
        return REANIMATE_CO_REJECTED;
    }

    // Need to revive the parent.  Push this CO back on the front of
    // the CO queue and then make a reanimation CO for the parent.
    // Push this CO onto the front of the queue and then turn the
    // loop.  This handles nested reanimations.
    //

    //
    // If this CO has already requested its parent to be reanimated then we
    // shouldn't be here because we should have blocked on the issue check for
    // its parent in the ActiveInboundChangeOrderTable.  When the issue block
    // was released we performed the GUIDFID translation again and this time
    // the IDT Delete Status should show the parent is not deleted.
    //
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_RISE_REQ)) {
        //
        // The parent reanimation must have failed.  Reject this CO.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) {
            FRS_ASSERT(DemandRefreshCo);

            //
            // This CO is for a reanimated parent v.s. the base
            // CO that started it all. There is no inbound log entry
            // for it, no inbound partner to ack, etc.
            //
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);

            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_STAGE_FILE);

            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Nested Parent Rise Failed");
            return REANIMATE_CO_REJECTED;

        } else {
            //
            // This is the base CO that triggered the reanimation.
            // The parent still isn't here so send it through retry.
            //
            // This can happen if the parent and child were deleted on the
            // inbound partner before we could fetch the child.  And then we
            // did a retry on the child CO before we see the delete CO for
            // the child from the inbound partner.  So the parent reanimation
            // fails and the child has no parent FID.  Eventually we will get
            // a delete CO for the child and we will create a tombstone thus
            // causing this CO to be rejected when it next is retried.
            //
            // We may not get the delete of this target CO if the upstream is
            // waiting for us to ACK some COs. By not sending an ACK we will
            // block any further progress. The downside of sending an ACK before
            // fetching the file is the upstream may have to regenerate the staging
            // file again but if the target file is absent on upstream then it is not
            // going to be able to generate the staging file in any case.
            // Send an ACK here so we keep getting the COs from downstream and
            // the expectation is that eventually we will sought things out.
            // Also this will be inserted in the inbound log (before ChgOrdIssueCleanup)
            // so we will keep retrying it.

            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND);

            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Parent Rise Failed");
            return REAMIMATE_RETRY_LATER;
        }
    }

    //
    // Build a Remote change order entry for the parent from the IDtable
    // Tombstone record.  This is a fetch CO to the inbound partner
    // that sent us the base CO to begin with.
    //

    if (LocalCo && IsIdRecFlagSet(IDTableRecParent, IDREC_FLAGS_DELETE_DEFERRED)) {
        DeadCoe = ChgOrdMakeFromIDRecord(IDTableRecParent,
                                         Replica,
                                         CO_LOCATION_CREATE,
                                         CO_FLAG_GROUP_RAISE_DEAD_PARENT | CO_FLAG_LOCALCO,
                                         &CoCmd->CxtionGuid);

        SET_CHANGE_ORDER_STATE(DeadCoe, IBCO_STAGING_REQUESTED);
    } else {
        DeadCoe = ChgOrdMakeFromIDRecord(IDTableRecParent,
                                         Replica,
                                         CO_LOCATION_CREATE,
                                         CO_FLAG_GROUP_RAISE_DEAD_PARENT,
                                         &CoCmd->CxtionGuid);

        SET_CHANGE_ORDER_STATE(DeadCoe, IBCO_FETCH_REQUESTED);
    }

    //
    // Update the version number by 1 and send the reanimation CO
    // forward. This will make sure that this CO is accepted
    // on the downstream partners that have the same tombstone.
    //

    DeadCoe->Cmd.FileVersionNumber = IDTableRecParent->VersionNumber + 1;

    SET_COE_FLAG(DeadCoe, COE_FLAG_GROUP_RAISE_DEAD_PARENT);

    //
    // Mark this CO as reanimated if in fact it had been deleted
    // and now a new update has come in, overriding the deletion.
    // The other possibility is that it could be a NewFile create
    // under a deleted parent.  Not a reanimation in this case.
    //
    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION) && ReAnimate) {
        SET_COE_FLAG(ChangeOrder, COE_FLAG_REANIMATION);
    }

    //
    // Do the change order cleanup but don't free the CO.
    // There is a VV slot to clean up if this is the CO that started
    // parent reanimation.
    //
    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

    if (!LocalCo && !DemandRefreshCo) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
    }

    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
    DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

    //
    // Remember that this CO has already requested its parent to rise.
    //
    SET_COE_FLAG(ChangeOrder, COE_FLAG_PARENT_RISE_REQ);

    //  Dont we still have this ref from when it was last on
    //  the process queue?
    //INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);


    //
    // Inherit the recovery flag so this CO will block if the
    // cxtion is not yet joined.
    //
    if (RecoveryCo(ChangeOrder)) {
        SET_COE_FLAG(DeadCoe, COE_FLAG_RECOVERY_CO);
    }

    //
    // Inherit the Connection and the Join Guid from the child.
    // If the Cxtion fails, all these COs should fail.
    //
    DeadCoe->Cxtion = ChangeOrder->Cxtion;
    FRS_ASSERT(ChangeOrder->Cxtion);

    LOCK_CXTION_TABLE(Replica);
    INCREMENT_CXTION_CHANGE_ORDER_COUNT(Replica, DeadCoe->Cxtion);
    DeadCoe->JoinGuid = ChangeOrder->JoinGuid;
    UNLOCK_CXTION_TABLE(Replica);

    //
    // Push this CO onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push to QHead");
    WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD | IPQ_TAKE_COREF |
                                IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return REANIMATE_FAILED;
    }

    //
    // If we just reinserted a base local co on to the process list then increment the
    // LocalCoQueueCount for this replica.
    //
    if (LocalCo &&
        !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY      |
                                 CO_FLAG_CONTROL    |
                                 CO_FLAG_MOVEIN_GEN |
                                 CO_FLAG_MORPH_GEN)  &&
        !RecoveryCo(ChangeOrder)                     &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) {

        INC_LOCAL_CO_QUEUE_COUNT(Replica);
    }
    //
    // Push the reanimate CO onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, DeadCoe, "Co Push Parent to QHead");

    WStatus = ChgOrdInsertProcQ(Replica, DeadCoe, IPQ_HEAD |
                                IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return REANIMATE_FAILED;
    }

    //
    // Now go give the parent CO we just pushed onto the QHead a spin.
    // It could issue or it might generate another change order to
    // reanimate its parent.  The recursion will stop when we hit
    // a live parent or the root of the replica tree.
    //
    return REANIMATE_SUCCESS;
}


BOOL
ChgOrdMakeDeleteCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PIDTABLE_RECORD     IDTableRec
    )
/*++
Routine Description:

   Given the IDTable record build a delete change order.
   Make us the originator.
   Push the supplied change order onto the head of the process queue after
   doing some cleanup and then push the delete CO.

Arguments:
   ChangeOrder   -- The change order.
   Replica       -- The Replica struct.
   ThreadCtx     -- ptr to the thread context for DB
   IDTableRec    -- The ID Table record to build the delte change order from.

Return Value:

    TRUE:  Success
    FALSE: Failed to insert CO on queue.  Probably queue was run down.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdMakeDeleteCo:"

    PCONFIG_TABLE_RECORD  ConfigRecord;
    PCHANGE_ORDER_ENTRY   DelCoe;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    ULONG                 FStatus, WStatus;
    BOOL                  LocalCo, DemandRefreshCo, MorphGenFollower;


    FRS_ASSERT(!(IDTableRec->FileAttributes & FILE_ATTRIBUTE_DIRECTORY));

    MorphGenFollower = COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);
    LocalCo          = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    DemandRefreshCo  = CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH);

    //
    // There is a VV slot to clean up if this is the CO that caused the
    // name morph conflict.
    //
    if (!LocalCo && !DemandRefreshCo) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
    }

    //
    // If this CO has been here once before then this is a recurrance of a
    // name morph conflict so the MorphGenCo Leader must have aborted.
    // Send the follower thru retry so it can try again later.
    //
    if (MorphGenFollower) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Recurrance of Morph Confl, RETRY");
        return FALSE;
    }

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);


    //
    // Build a delete change order entry for the IDtable record.
    // This is a local CO that originates from this member.
    //
    DelCoe = ChgOrdMakeFromIDRecord(IDTableRec,
                                    Replica,
                                    CO_LOCATION_DELETE,
                                    CO_FLAG_LOCATION_CMD,
                                    NULL);

    //
    // Generate a new Volume Sequnce Number for the change order.
    // But since it gets put on the front of the CO process queue it
    // is probably out of order so set the flag to avoid screwing up
    // dampening.
    //
    NEW_VSN(pVme, &DelCoe->Cmd.FrsVsn);
    DelCoe->Cmd.OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

    //
    // Use the event time from the winning CO as long as it is greater than
    // the event time in the IDTable record.  If we use current time then
    // when the name morph conflict is detected at other nodes they would
    // generate a Del Co with yet a different time and cause unnecessary
    // replication of Delete Cos.
    //
    if (ChangeOrder->Cmd.EventTime.QuadPart > IDTableRec->EventTime) {
        //
        // Event time winning CO.
        //
        DelCoe->Cmd.EventTime.QuadPart = ChangeOrder->Cmd.EventTime.QuadPart;
    } else {
        //
        // Event time from IDTable record biased by Reconcile EventTimeWindow+1
        // The above had probs:  Adding in RecEventTimeWindow may be causing desired
        // reanimations to be rejected since the tombstone has a
        // much larger event time so the version number check doesn't matter
        // just make it +1 for now.
        //
        DelCoe->Cmd.EventTime.QuadPart = IDTableRec->EventTime +
                                        /* RecEventTimeWindow */ + 1;
    }

    //
    // Bump Version number to ensure the CO is accepted.
    //
    DelCoe->Cmd.FileVersionNumber = IDTableRec->VersionNumber + 1;

    //
    // Note: We wouldn't need to mark this CO as out of order if we
    // resequenced all change order VSNs (for new COs only) as they
    // were fetched off the process queue.
    //
    SET_CO_FLAG(DelCoe, CO_FLAG_LOCALCO        |
                        CO_FLAG_MORPH_GEN      |
                        CO_FLAG_OUT_OF_ORDER);

    //
    // Set the Jrnl Cxtion Guid and Cxtion ptr for this Local CO.
    //
    INIT_LOCALCO_CXTION_AND_COUNT(Replica, DelCoe);

    //
    // Tell downstream partners to skip the originator check on this Morph
    // generated CO.  See ChgOrdReconcile() for details.
    //
    SET_CO_FLAG(DelCoe, CO_FLAG_SKIP_ORIG_REC_CHK);

    //
    // Do the change order cleanup but don't free the CO.
    //
    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
    DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

    //
    // Mark the base CO as a MorphGenFollower so it gets sent thru retry
    // if the leader gets aborted.
    //
    SET_COE_FLAG(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);

    //
    // Push this CO onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push MORPH_GEN_FOLLOWER - Winner to QHead");
    WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD | IPQ_TAKE_COREF |
                                IPQ_MG_LOOP_CHK | IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return FALSE;
    }

    //
    // Push the IDTable Delete Co onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, DelCoe, "Co Push MORPH_GEN_LEADER - IDT loser to QHead");
    WStatus = ChgOrdInsertProcQ(Replica, DelCoe, IPQ_HEAD |
                                IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return FALSE;
    }

    //
    // Now go give the delete CO we just pushed onto the QHead a spin.
    //
    return TRUE;
}



BOOL
ChgOrdMakeRenameCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN PIDTABLE_RECORD     IDTableRec
    )
/*++
Routine Description:

   Given the IDTable record build a rename change order.
   Make us the originator.
   Push the supplied change order onto the head of the process queue after
   doing some cleanup and then push the rename CO.

Arguments:
   ChangeOrder   -- The change order.
   Replica       -- The Replica struct.
   ThreadCtx     -- ptr to the thread context for DB
   IDTableRec    -- The ID Table record to build the delte change order from.

Return Value:

    TRUE:  Success
    FALSE: Failed to insert CO on queue.  Probably queue was run down.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdMakeRenameCo:"

    PCONFIG_TABLE_RECORD  ConfigRecord;
    PCHANGE_ORDER_ENTRY   RenameCoe;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    ULONG                 FStatus, WStatus;
    BOOL                  LocalCo, DemandRefreshCo, MorphGenFollower;
    ULONG                 NameLen;


    FRS_ASSERT(IDTableRec->FileAttributes & FILE_ATTRIBUTE_DIRECTORY);


    LocalCo          = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    DemandRefreshCo  = CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH);
    MorphGenFollower = COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);

    //
    // There is a VV slot to clean up if this is the CO that caused the
    // name morph conflict.
    //
    if (!LocalCo && !DemandRefreshCo) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
    }

    //
    // If this CO has been here once before then this is a recurrance of a
    // name morph conflict so the MorphGenCo Leader must have aborted.
    // Send the follower thru retry so it can try again later.
    //
    if (MorphGenFollower) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Recurrance of Morph Confl, RETRY");
        return FALSE;
    }

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);


    //
    // Build a rename change order entry for the IDtable record.
    // This is a local CO that originates from this member.
    //
    RenameCoe = ChgOrdMakeFromIDRecord(IDTableRec,
                                       Replica,
                                       CO_LOCATION_NO_CMD,
                                       CO_FLAG_CONTENT_CMD,
                                       NULL);

    RenameCoe->Cmd.ContentCmd = USN_REASON_RENAME_NEW_NAME;

    //
    // Suffix "_NTFRS_<tic count in hex>" to the filename.
    //
    DPRINT1(4, "++ %ws will be morphed\n", RenameCoe->Cmd.FileName);
    NameLen = wcslen(RenameCoe->Cmd.FileName);
    if (NameLen + SIZEOF_RENAME_SUFFIX > (MAX_PATH - 1)) {
        NameLen -= ((NameLen + SIZEOF_RENAME_SUFFIX) - (MAX_PATH - 1));
    }
    swprintf(&RenameCoe->Cmd.FileName[NameLen], L"_NTFRS_%08x", GetTickCount());
    RenameCoe->Cmd.FileNameLength = wcslen(RenameCoe->Cmd.FileName) * sizeof(WCHAR);
    RenameCoe->UFileName.Length = RenameCoe->Cmd.FileNameLength;

    DPRINT1(4, "++ Morphing to %ws\n", RenameCoe->Cmd.FileName);


    //
    // Generate a new Volume Sequnce Number for the change order.
    // But since it gets put on the front of the CO process queue it
    // is probably out of order so set the flag to avoid screwing up
    // dampening.
    //
    NEW_VSN(pVme, &RenameCoe->Cmd.FrsVsn);
    RenameCoe->Cmd.OriginatorGuid = ConfigRecord->ReplicaVersionGuid;


    //
    // Use the event time from the winning CO as long as it is greater than
    // the event time in the IDTable record.  If we use current time then
    // when the name morph conflict is detected at other nodes they would
    // generate a rename Co with yet a different time and cause unnecessary
    // replication of rename Cos.
    //
    if (ChangeOrder->Cmd.EventTime.QuadPart > IDTableRec->EventTime) {
        //
        // Event time winning CO.
        //
        RenameCoe->Cmd.EventTime.QuadPart = ChangeOrder->Cmd.EventTime.QuadPart;
    } else {
        //
        // Event time from IDTable record biased by Reconcile EventTimeWindow+1
        //
        RenameCoe->Cmd.EventTime.QuadPart = IDTableRec->EventTime +
                                            /* RecEventTimeWindow */ + 1;
        //GetSystemTimeAsFileTime((PFILETIME)&RenameCoe->Cmd.EventTime.QuadPart);
    }

    //
    // Bump Version number to ensure the CO is accepted.
    //
    RenameCoe->Cmd.FileVersionNumber = IDTableRec->VersionNumber + 1;

    //
    // Note: We wouldn't need to mark this CO as out of order if we
    // resequenced all change order VSNs (for new COs only) as they
    // were fetched off the process queue.
    //
    SET_CO_FLAG(RenameCoe, CO_FLAG_LOCALCO        |
                           CO_FLAG_MORPH_GEN      |
                           CO_FLAG_OUT_OF_ORDER);

    //
    // Set the Jrnl Cxtion Guid and Cxtion ptr for this Local CO.
    //
    INIT_LOCALCO_CXTION_AND_COUNT(Replica, RenameCoe);

    //
    // Tell downstream partners to skip the originator check on this Morph
    // generated CO.  See ChgOrdReconcile() for details.
    //
    SET_CO_FLAG(RenameCoe, CO_FLAG_SKIP_ORIG_REC_CHK);

    //
    // Do the change order cleanup but don't free the CO.
    //
    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
    DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

    //
    // Mark the base CO as a MorphGenFollower so it gets sent thru retry
    // if the leader gets aborted.
    //
    SET_COE_FLAG(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);

    //
    // Push this CO onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push MORPH_GEN_FOLLOWER - Winner to QHead");
    WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD | IPQ_TAKE_COREF |
                  IPQ_MG_LOOP_CHK | IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return FALSE;
    }

    //
    // Push the IDTable Delete Co onto the head of the queue.
    //
    CHANGE_ORDER_TRACE(3, RenameCoe, "Co Push MORPH_GEN_LEADER - IDT loser to QHead");
    WStatus = ChgOrdInsertProcQ(Replica, RenameCoe, IPQ_HEAD |
                                IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return FALSE;
    }

    //
    // Now go give the delete CO we just pushed onto the QHead a spin.
    //
    return TRUE;
}


VOID
ChgOrdInjectControlCo(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN ULONG    ContentCmd
    )
/*++

Routine Description:

    Generate a directed control change order for Cxtion.

Arguments:

    Replica     - Replica for cxtion
    Cxtion      - outbound cxtion
    ContentCmd  - Type of control co

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "ChgOrdInjectControlCo:"
    PCHANGE_ORDER_ENTRY     Coe;
    PCHANGE_ORDER_COMMAND   Coc;

    //
    // Change order entry
    //
    Coe = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
    INCREMENT_CHANGE_ORDER_REF_COUNT(Coe);
    //
    // Jet context for outlog insertion
    //
    Coe->RtCtx = FrsAllocTypeSize(REPLICA_THREAD_TYPE,
                                  FLAG_FRSALLOC_NO_ALLOC_TBL_CTX);
    FrsRtlInsertTailList(&Replica->ReplicaCtxListHead,
                         &Coe->RtCtx->ReplicaCtxList);

    //
    // Change order command
    //
    Coc = &Coe->Cmd;

    //
    // Original and New Replica are the same (not a rename)
    //
    Coe->OriginalReplica = Replica;
    Coe->NewReplica = Replica;
    Coc->OriginalReplicaNum = ReplicaAddrToId(Coe->OriginalReplica);
    Coc->NewReplicaNum      = ReplicaAddrToId(Coe->NewReplica);

    //
    // Assign a change order guid
    //
    FrsUuidCreate(&Coc->ChangeOrderGuid);

    //
    // Phoney File guid
    //
    FrsUuidCreate(&Coc->FileGuid);
    if (ContentCmd == FCN_CO_ABNORMAL_VVJOIN_TERM) {
        wcscpy(Coe->Cmd.FileName, L"VVJoinTerminateAbnormal");  // for tracing.
    } else if (ContentCmd == FCN_CO_NORMAL_VVJOIN_TERM) {
        wcscpy(Coe->Cmd.FileName, L"VVJoinTerminateNormal");    // for tracing.
    } else if (ContentCmd == FCN_CO_END_OF_JOIN) {
        wcscpy(Coe->Cmd.FileName, L"EndOfJoin");                // for tracing.
    } else if (ContentCmd == FCN_CO_END_OF_OPTIMIZED_VVJOIN) {
        wcscpy(Coe->Cmd.FileName, L"EndOfOptVVJoin");                // for tracing.
    } else {
        wcscpy(Coe->Cmd.FileName, L"UnknownControl");           // for tracing.
    }

    //
    // Cxtion's guid (identifies the cxtion)
    //
    Coc->CxtionGuid = *Cxtion->Name->Guid;

    //
    // The location command is either create or delete
    //
    Coc->ContentCmd = ContentCmd;

    //
    // Control command co
    //
    SET_CO_FLAG(Coe, CO_FLAG_CONTROL);

    //
    // Directed at one cxtion
    //
    SET_CO_FLAG(Coe, CO_FLAG_DIRECTED_CO);
    //
    // Mascarade as a local change order since the staging file
    // is created from the local version of the file and isn't
    // from a inbound partner.
    //
    SET_CO_FLAG(Coe, CO_FLAG_LOCALCO);

    //
    // Refresh change orders will not be propagated by our outbound
    // partner to its outbound partners.
    //
    // Note that only the termination change order is set to refresh.
    // While we want the vvjoin change orders to propagate as regular
    // change orders, we do not want the termination co to propagate.
    //
    SET_CO_FLAG(Coe, CO_FLAG_REFRESH);

    //
    // By "out of order" we mean that the VSN on this change order
    // should not be used to update the version vector because there
    // may be other files or dirs with lower VSNs that will be sent
    // later. We wouldn't want our partner to dampen them.
    //
    SET_CO_FLAG(Coe, CO_FLAG_OUT_OF_ORDER);

    //
    // Some control Cos aren't valid across joins.
    //
    Coc->EventTime.QuadPart = Cxtion->LastJoinTime;

    //
    // Just a guess
    //
    SET_CHANGE_ORDER_STATE(Coe, IBCO_OUTBOUND_REQUEST);

    //
    // The DB server is responsible for updating the outbound log.
    //
    DbsPrepareCmdPkt(NULL,                        //  CmdPkt,
                     Replica,                     //  Replica,
                     CMD_DBS_INJECT_OUTBOUND_CO,  //  CmdRequest,
                     NULL,                        //  TableCtx,
                     Coe,                         //  CallContext,
                     0,                           //  TableType,
                     0,                           //  AccessRequest,
                     0,                           //  IndexType,
                     NULL,                        //  KeyValue,
                     0,                           //  KeyValueLength,
                     TRUE);                       //  Submit
}



BOOL
ChgOrdConvertCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica,
    IN PTHREAD_CTX         ThreadCtx,
    IN ULONG               LocationCmd
    )
/*++
Routine Description:

   Create a new CO of the specified type using the current CO.
   Make us the originator.
   Push the current CO back onto the queue.
   Push the new change order onto the head of the process
   queue after doing some cleanup.
   The new CO is a local CO while the original CO may be a remote CO that
   needs to ack its inbound partner.

   Convert is generating a new change order (rename or delete) for an
   incoming change order for a NEW FILE.  As such there is no existing file
   whose name needs to be removed, unlike ChgOrdMakeRenameCo() or
   ChgOrdMakeDeleteCo() which produce change orders from an existing IDTable
   entry.

Arguments:
   ChangeOrder   -- The change order.
   Replica       -- The Replica struct.
   ThreadCtx     -- ptr to the thread context for DB
   LocationCmd   -- Tells us what kind of CO to build.
                    Current choices are a rename CO or a delete CO.

Return Value:

    TRUE:  Success
    FALSE: Failed to insert CO on queue.  Probably queue was run down.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdConvertCo:"

    PCONFIG_TABLE_RECORD  ConfigRecord;
    PCHANGE_ORDER_ENTRY   CvtCoe;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    ULONG                 FStatus, WStatus, WStatus1;
    BOOL                  LocalCo, DemandRefreshCo, MorphGenFollower;
    ULONG                 NameLen;


    LocalCo          = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    DemandRefreshCo  = CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH);
    MorphGenFollower = COE_FLAG_ON(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);

    //
    // There is a VV slot to clean up if this is the CO that caused the
    // name morph conflict.
    //
    if (!LocalCo && !DemandRefreshCo) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
    }

    //
    // If this CO has been here once before then this is a recurrance of a
    // name morph conflict so the MorphGenCo Leader must have aborted.
    // Send the follower thru retry so it can try again later.
    //
    if (MorphGenFollower) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Recurrance of Morph Confl, RETRY");
        return FALSE;
    }


    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);


    //
    // Build a new CO out of this change order entry.
    // This is a local CO that originates from this member.
    //
    // Allocate a change order entry with room for the filename and copy
    // the change order + Filename into it.  Init the ref count to one
    // since the CO is going on the process queue.
    //
    CvtCoe = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
    CopyMemory(&CvtCoe->Cmd, &ChangeOrder->Cmd, sizeof(CHANGE_ORDER_COMMAND));
    CvtCoe->Cmd.Extension = NULL;
    CvtCoe->UFileName.Length = CvtCoe->Cmd.FileNameLength;

    //
    // Copy the Change Order Extension if provided.
    //
    if ((ChangeOrder->Cmd.Extension != NULL) &&
        (ChangeOrder->Cmd.Extension->FieldSize > 0)) {

        CvtCoe->Cmd.Extension = FrsAlloc(ChangeOrder->Cmd.Extension->FieldSize);
        CopyMemory(CvtCoe->Cmd.Extension, ChangeOrder->Cmd.Extension,
                   ChangeOrder->Cmd.Extension->FieldSize);
    }

    //
    // Normally the change order record extension is allocated for local COs
    // when the cocmd is inserted into the inbound log (by the call to
    // DbsAllocRecordStorage()).  But MorphGenCos don't get inserted into
    // the inlog so we need to do it here.
    //
    if (ChangeOrder->Cmd.Extension == NULL){
        CvtCoe->Cmd.Extension = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
        DbsDataInitCocExtension(CvtCoe->Cmd.Extension);
        DPRINT(4, "Allocating initial Coc Extension for morphco\n");
    }

    //
    // Assign a change order guid and zero the connection GUID since this
    // is a local CO.
    //
    FrsUuidCreate(&CvtCoe->Cmd.ChangeOrderGuid);
    ZeroMemory(&CvtCoe->Cmd.CxtionGuid, sizeof(GUID));

    CvtCoe->HashEntryHeader.ReferenceCount = 0;
    INCREMENT_CHANGE_ORDER_REF_COUNT(CvtCoe);  // for tracking

    //
    // File's fid and parent fid
    //
    CvtCoe->FileReferenceNumber = ChangeOrder->FileReferenceNumber;
    CvtCoe->ParentFileReferenceNumber = ChangeOrder->ParentFileReferenceNumber;

    //
    // Original parent and New parent are the same (not a rename)
    //
    CvtCoe->OriginalParentFid = ChangeOrder->OriginalParentFid;
    CvtCoe->NewParentFid = ChangeOrder->NewParentFid;

    //
    //  Copy New and orig Replica.  (CO Numbers got copied with CO above).
    //
    CvtCoe->OriginalReplica = ChangeOrder->OriginalReplica;
    CvtCoe->NewReplica      = ChangeOrder->NewReplica;

    //
    // File's attributes
    //
    CvtCoe->FileAttributes = ChangeOrder->FileAttributes;

    //
    // Create and write times
    //
    CvtCoe->FileCreateTime = ChangeOrder->FileCreateTime;
    CvtCoe->FileWriteTime = ChangeOrder->FileWriteTime;

    //
    // The sequence number is zero initially.  It may get a value when
    // the CO is inserted into an inbound or outbound log.
    //
    CvtCoe->Cmd.SequenceNumber = 0;
    CvtCoe->Cmd.PartnerAckSeqNumber = 0;

    //
    // Use the event time from the supplied CO biased by
    // Reconcile EventTimeWindow+1.  If we use current time then
    // when the name morph conflict is detected at other nodes they would
    // generate a Del or Rename Co with yet a different time and cause
    // unnecessary replication of Del or rename Cos.
    //
    CvtCoe->Cmd.EventTime.QuadPart = ChangeOrder->Cmd.EventTime.QuadPart +
                                     /* RecEventTimeWindow  */ + 1;

    // GetSystemTimeAsFileTime((PFILETIME)&CvtCoe->Cmd.EventTime.QuadPart);

    //
    // FileVersionNumber bumped by one so this CO will not get rejected.
    //
    CvtCoe->Cmd.FileVersionNumber += 1;

    //
    // File's USN
    //
    CvtCoe->Cmd.FileUsn = 0;
    CvtCoe->Cmd.JrnlUsn = 0;
    CvtCoe->Cmd.JrnlFirstUsn = 0;

    //
    // Generate a new Volume Sequnce Number for the change order.
    // But since it gets put on the front of the CO process queue it
    // is probably out of order so set the flag to avoid screwing up
    // dampening.
    //
    NEW_VSN(pVme, &CvtCoe->Cmd.FrsVsn);
    CvtCoe->Cmd.OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

    //
    // Note: We wouldn't need to mark this CO as out of order if we
    // resequenced all change order VSNs (for new COs only) as they
    // were fetched off the process queue.
    //
    CvtCoe->Cmd.Flags = 0;
    CvtCoe->Cmd.IFlags = 0;
    SET_CO_FLAG(CvtCoe, CO_FLAG_LOCALCO        |
                        CO_FLAG_MORPH_GEN      |
                        CO_FLAG_OUT_OF_ORDER);

    //
    // Set the Jrnl Cxtion Guid and Cxtion ptr for this Local CO.
    //
    INIT_LOCALCO_CXTION_AND_COUNT(Replica, CvtCoe);

    //
    // Tell downstream partners to skip the originator check on this Morph
    // generated CO.  See ChgOrdReconcile() for details.
    //
    SET_CO_FLAG(CvtCoe, CO_FLAG_SKIP_ORIG_REC_CHK);

    //
    // Delete, Rename
    //
    SET_CO_LOCATION_CMD(CvtCoe->Cmd, Command, LocationCmd);

    if (LocationCmd == CO_LOCATION_NO_CMD) {
        //
        // We're giving this object a new name.  Init the new name into
        // both the original and the new CO.
        //
        CvtCoe->Cmd.ContentCmd = USN_REASON_RENAME_NEW_NAME;
        SET_CO_FLAG(CvtCoe, CO_FLAG_CONTENT_CMD);

        ChangeOrder->Cmd.ContentCmd |= USN_REASON_RENAME_NEW_NAME;
        SET_CO_FLAG(ChangeOrder, CO_FLAG_CONTENT_CMD);

        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER)) {
            //
            // This CO is marked as a MorphGenLeader.  This means it has been
            // through here before and so it already has the Morphed dir
            // name in the CO.  Use it as is in the rename CO.
            // It was already copied into the CvtCoe above.
            //
            NOTHING;

        } else {
            //
            // Not a MorphGenLeader so build a new name.
            // Suffix "_NTFRS_<tic count in hex>" to the filename.
            //
            DPRINT1(4, "++ %ws will be morphed\n", CvtCoe->Cmd.FileName);
            NameLen = wcslen(CvtCoe->Cmd.FileName);
            if (NameLen + SIZEOF_RENAME_SUFFIX > (MAX_PATH - 1)) {
                NameLen -= ((NameLen + SIZEOF_RENAME_SUFFIX) - (MAX_PATH - 1));
            }
            swprintf(&CvtCoe->Cmd.FileName[NameLen], L"_NTFRS_%08x", GetTickCount());
            CvtCoe->Cmd.FileNameLength = wcslen(CvtCoe->Cmd.FileName) * sizeof(WCHAR);
            CvtCoe->UFileName.Length = CvtCoe->Cmd.FileNameLength;

            DPRINT1(4, "++ Morphing to %ws\n", CvtCoe->Cmd.FileName);

            //
            // MAYBE: Though it is unlikely, still need to verify that the
            // friggen name is not in use.
            //
            CopyMemory(ChangeOrder->Cmd.FileName, CvtCoe->Cmd.FileName,
                   CvtCoe->Cmd.FileNameLength + sizeof(WCHAR));

            ChangeOrder->Cmd.FileNameLength = CvtCoe->Cmd.FileNameLength;
            ChangeOrder->UFileName.Length = ChangeOrder->Cmd.FileNameLength;
        }


    } else
    if (LocationCmd == CO_LOCATION_DELETE) {
        //
        // The old code was setting USN_REASON_FILE_DELETE and
        // CO_FLAG_LOCATION_CMD. This is incorrect since later code
        // treats the co as a CO_LOCATION_CREATE. The fix was to
        // set both the content and location to specify delete.
        //
        CvtCoe->Cmd.ContentCmd = USN_REASON_FILE_DELETE;
        SET_CO_FLAG(CvtCoe, CO_FLAG_CONTENT_CMD);

        SET_CO_LOCATION_CMD(CvtCoe->Cmd, Command, CO_LOCATION_DELETE);
        SET_CO_LOCATION_CMD(CvtCoe->Cmd, DirOrFile,
                            (CvtCoe->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
                            CO_LOCATION_DIR : CO_LOCATION_FILE);
        SET_CO_FLAG(CvtCoe, CO_FLAG_LOCATION_CMD);

        //
        // If the FID is zero then load a fake value for it since this is
        // an IDTable index and there is no actual file if we are generating
        // a delete CO since it will be issued first.
        //
        if (CvtCoe->FileReferenceNumber == ZERO_FID) {
            FrsInterlockedIncrement64(CvtCoe->FileReferenceNumber,
                                      GlobSeqNum,
                                      &GlobSeqNumLock);
        }

    } else {
        DPRINT1(0, "++ ERROR: Invalid Location Cmd - %d\n", LocationCmd);
        FRS_ASSERT(!"Invalid Location Cmd");
    }

    SET_CHANGE_ORDER_STATE(CvtCoe, IBCO_INITIALIZING);

    if (LocationCmd == CO_LOCATION_NO_CMD) {
        //
        // Push the new Co onto the head of the queue.  No aging delay.
        // Do this first in the case of a rename because we want the
        // create CO to issue first to create the object.
        // We then follow this with a Local rename Co (using the same name)
        // so we can ensure the rename will propagate everywhere.
        //
        // This is necessary because a down stream partner may not encounter
        // the name morph conflict because the ultimate name winner may not
        // have arrived yet or a delete could have occurred on our winner
        // follwed by the arrival of this CO via another connection path to
        // the downstream partner.  In either case we must prop a rename to
        // ensure the name is the same everywhere.
        //

        //
        // Mark the Rename CO as a MorphGenFollower so it gets rejected if the
        // MorphGenLeader fails to create the file.
        //
        SET_COE_FLAG(CvtCoe, COE_FLAG_MORPH_GEN_FOLLOWER);

        CHANGE_ORDER_TRACE(3, CvtCoe, "Co Push MORPH_GEN_FOLLOWER to QHead");
        WStatus1 = ChgOrdInsertProcQ(Replica, CvtCoe, IPQ_HEAD |
                                     IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    }

    //
    // Do the change order cleanup but don't free the CO.
    //
    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO);

    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, 0);
    DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);

    if (LocationCmd != CO_LOCATION_NO_CMD) {
        //
        // Mark the base CO as a MorphGenFollower so it gets sent thru retry
        // if the leader gets aborted.  Only set this flag if this CO is the
        // follower.  In the CO_LOCATION_NO_CMD case the Morph Gen Co was
        // pushed on the queue above so this CO is the Leader.
        //
        SET_COE_FLAG(ChangeOrder, COE_FLAG_MORPH_GEN_FOLLOWER);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push MORPH_GEN_FOLLOWER to QHead");
    } else {
        //
        // Mark the base CO as a MorphGenLeader so if it gets reissued later
        // we know to refabricate the MorphGenFollower rename CO.
        //
        SET_CO_FLAG(ChangeOrder, CO_FLAG_MORPH_GEN_LEADER);
        //
        // Set volatile flag indicating we (the MorphGenLeader) has fabricated
        // the MorphGenFollower and pushed it onto the process queue.  This
        // prevents us from doing it again when we leave here and restart
        // processing on the MorphGenLeader CO.
        //
        SET_COE_FLAG(ChangeOrder, COE_FLAG_MG_FOLLOWER_MADE);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Push MORPH_GEN_LEADER to QHead");
    }

    //
    // Push this CO onto the head of the queue.
    //
    WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_HEAD | IPQ_TAKE_COREF |
                 IPQ_MG_LOOP_CHK | IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        return FALSE;
    }

    if (LocationCmd != CO_LOCATION_NO_CMD) {
        //
        // Push the new Co onto the head of the queue.  No aging delay.
        // Do this second in the case of the DeleteCo since we want to
        // issue the Delete first so we can prevent the subsequent name
        // conflict when the original change order issues.  The delete co
        // issues as a local CO so it propagates everywhere.  The original
        // CO that follows behind it will hit the tombstone created by the
        // delete and be aborted.
        //
        CHANGE_ORDER_TRACE(3, CvtCoe, "Co Push MORPH_GEN_LEADER to QHead");
        WStatus1 = ChgOrdInsertProcQ(Replica, CvtCoe, IPQ_HEAD |
                                     IPQ_DEREF_CXTION_IF_ERR | IPQ_ASSERT_IF_ERR);
    }

    if (!WIN_SUCCESS(WStatus1)) {
        return FALSE;
    }

    //
    // Now go give the delete CO we just pushed onto the QHead a spin.
    //
    return TRUE;
}



BOOL
ChgOrdReserve(
    IN PIDTABLE_RECORD     IDTableRec,
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    )
/*++
Routine Description:

   Reserve resources for this change order so that subsequent change orders
   will properly interlock with this change order.

Arguments:
   IDTableRec -- The IDTable record for this file / dir.
   ChangeOrder-- The change order.
   Replica    -- The Replica struct.

Return Value:

   TRUE if reservation succeeded.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdReserve:"

    PCHANGE_ORDER_RECORD  CoCmd = &ChangeOrder->Cmd;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    PQHASH_ENTRY          QHashEntry;
    UNICODE_STRING        UnicodeStr;
    ULONG                 GStatus;
    GUID                  *NParentGuid;
    GUID                  *OldParentGuid;
    CHAR  GuidStr[GUID_CHAR_LEN];

    //
    // Make entry in the Active inbound change order hash table.  This is
    // indexed by the file Guid in the change order so we can interlock against
    // activity on files that are being reanimated.  Their IDTable entries are
    // marked deleted but the FID is not updated until the CO completes
    // successfully so an incoming duplicate CO on a deleted file could get
    // thru if the index was a FID.
    //
    GStatus = GhtInsert(pVme->ActiveInboundChangeOrderTable,
                        ChangeOrder,
                        TRUE,
                        FALSE);

    if (GStatus != GHT_STATUS_SUCCESS) {
        DPRINT1(0, "++ ERROR - ActiveInboundChangeOrderTable GhtInsert Failed: %d\n", GStatus);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Rejected - AIBCO Insert Failed");
        FRS_PRINT_TYPE(0, ChangeOrder);
        FRS_ASSERT(!"AIBCO Insert Failed");
        ChgOrdReject(ChangeOrder, Replica);
        return FALSE;
    }
    SET_ISSUE_CLEANUP(ChangeOrder, ISCU_AIBCO);

    //
    // Make entry in the Name conflict table if a file name is being
    // removed so this CO interlocks with a subsequent CO that wants
    // to bring the name back.
    //
    // Don't update the name conflict table if this is a delete co
    // for a deleted id table entry. Deleted id table entries are not
    // factored into the name morph conflict detection and hence can
    // lead to duplicate entries in the name conflict table.
    //
    // NameConflictTable Entry: An entry in the NameConflictTable
    // contains a reference count of the number of active change
    // orders that hash to that entry and a Flags word that is set
    // to COE_FLAG_VOL_COLIST_BLOCKED if the process queue for this
    // volume is idled while waiting on the active change orders for
    // this entry to retire. The queue is idled when the entry at
    // the head of the queue hashes to this entry and so may
    // have a conflicting name (hence the name, "name conflict table").
    //
    // The NameConflictTable can give false positives. But this is okay
    // because a false positive is rare and will only idle the process
    // queue until the active change order retires. Getting rid
    // of the rare false positives would degrade performance. The
    // false positives that happen when inserting an entry into the
    // NameConflictTable are handled by using the QData field in
    // the QHashEntry as a the reference count.
    //
    // But, you ask, how can there be multiple active cos hashing
    // to this entry if the process queue is idled when a conflict
    // is detected? Easy, I say, because the filename in the co
    // is used to detect collisions while the filename in the idtable
    // is used to reserve the qhash entry. Why? Well, the name morph
    // code handles the case of a co's name colliding with an
    // idtable entry. But that code wouldn't work if active change
    // orders were constantly changing the idtable. So, the
    // NameConflictTable synchronizes the namespace amoung
    // active change orders so that the name morph code can work
    // against a static namespace.
    //
    if (DOES_CO_DO_SIMPLE_RENAME(CoCmd) ||
        (DOES_CO_REMOVE_FILE_NAME(CoCmd) &&
         !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED))) {
        //
        // The IDTable has the current location of the file.  Note that in the
        // case of a remote CO the file may have already been moved either by a
        // local action or the processing of a remote CO that arrived earlier
        // than this one.  Save the hash value in the change order because when
        // it retires the the data is gone since the IDTable has been updated.
        //
        RtlInitUnicodeString(&UnicodeStr,
                             IDTableRec->FileName);
        ChgOrdCalcHashGuidAndName(&UnicodeStr,
                            &IDTableRec->ParentGuid,
                            &ChangeOrder->NameConflictHashValue);

        QHashAcquireLock(Replica->NameConflictTable);
        QHashEntry = QHashInsertLock(Replica->NameConflictTable,
                                     &ChangeOrder->NameConflictHashValue,
                                     NULL,
                                     (ULONG_PTR) 0);
        QHashEntry->QData++;
        QHashReleaseLock(Replica->NameConflictTable);
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_NC_TABLE);
    } else {
        ChangeOrder->NameConflictHashValue = QUADZERO;
    }

    //
    // Update the count in an existing parent entry or create a new entry
    // in the ActiveChildren hash table.
    // Skip it if this is a TombStone IDTable Entry create and the parent
    // FID is zero.
    //
    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_JUST_TOMBSTONE) ||
        (ChangeOrder->ParentFileReferenceNumber != ZERO_FID)) {

        if (ChangeOrder->ParentFileReferenceNumber == ZERO_FID) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Warning - parent fid zero");
            FRS_PRINT_TYPE(4, ChangeOrder);
        }

        NParentGuid = FrsAlloc(sizeof(GUID));

        OldParentGuid = FrsAlloc(sizeof(GUID));

        if((NParentGuid != NULL) && (OldParentGuid != NULL)) {
            memcpy(NParentGuid, &CoCmd->NewParentGuid , sizeof(GUID));
            GuidToStr(NParentGuid, GuidStr);

            QHashAcquireLock(pVme->ActiveChildren);

            QHashEntry = QHashInsertLock(pVme->ActiveChildren,
                                         NParentGuid,
                                         NULL,
                                         (ULONG_PTR)NParentGuid);

            QHashEntry->QData += 2;

            DPRINT2(4, "++ GAC - bump count on GUID: %s, QData %08x \n",
                    GuidStr, QHashEntry->QData);
            QHashEntry = NULL;

        //
        // If this CO has a old parent and a new parent (e.g. MOVE_DIR) then
        // we need to block both parents. Check for that and block both.
        //

        if (!GUIDS_EQUAL(&CoCmd->NewParentGuid, &CoCmd->OldParentGuid)) {
            memcpy(OldParentGuid, &CoCmd->OldParentGuid , sizeof(GUID));
            GuidToStr(OldParentGuid, GuidStr);

            QHashEntry = QHashInsertLock(pVme->ActiveChildren,
                         OldParentGuid,
                         NULL,
                         (ULONG_PTR)OldParentGuid);

            QHashEntry->QData += 2;

            DPRINT2(4, "++ GAC - bump count on GUID: %s, QData %08x \n",
                GuidStr, QHashEntry->QData);
            QHashEntry = NULL;

        } else {
            FrsFree(OldParentGuid);
        }

            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVE_CHILD);

        QHashReleaseLock(pVme->ActiveChildren);
        }

    }

    return TRUE;
}


ULONG
ChgOrdDispatch(
    PTHREAD_CTX           ThreadCtx,
    PIDTABLE_RECORD       IDTableRec,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    )
/*++
Routine Description:

   Dispatch the change order to one of the following:
   1. RemoteCoAccepted() ,2. LocalCoAccepted(), 3. InboundRetired()
   4. InstallRetry()

   NOTE: On return the ChangeOrder now belongs to some other thread.

Arguments:
   IDTableRec -- The IDTable record for this file / dir.
   ChangeOrder-- The change order.
   Replica    -- The Replica struct.

Return Value:

   FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdDispatch:"

    JET_ERR               jerr, jerr1;
    PTABLE_CTX            TmpIDTableCtx;
    BOOL                  ChildrenExist;
    PCHANGE_ORDER_RECORD  CoCmd = &ChangeOrder->Cmd;
    PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
    BOOL                  LocalCo;

    LocalCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    //
    // Since we are going to issue this CO clear those flags that will get
    // set later when the CO either goes thru Retire or are handled in
    // a different way after this point.
    //
    CLEAR_ISSUE_CLEANUP(ChangeOrder, ISCU_GOIS_CLEANUP);

    if (LocalCo) {

        //
        // Increment the Local Change Orders Issued
        //
        PM_INC_CTR_REPSET(Replica, LCOIssued, 1);

        if (ChangeOrder->StreamLastMergeSeqNum > pVme->StreamSequenceNumberFetched) {
            pVme->StreamSequenceNumberFetched = ChangeOrder->StreamLastMergeSeqNum;
        }

        FRS_ASSERT(CO_STATE_IS(ChangeOrder, IBCO_STAGING_REQUESTED) ||
                   CO_STATE_IS(ChangeOrder, IBCO_STAGING_RETRY));

        VVReserveRetireSlot(Replica, ChangeOrder);
        DPRINT(4,"++ Submitting ChangeOrder to stager\n");
        FRS_PRINT_TYPE(4, ChangeOrder);
        RcsSubmitLocalCoAccepted(ChangeOrder);

    } else {
        //
        // The code in StuDeleteEmptyDirectory() will
        // delete all of the subdirs and files if the change order
        // makes it past this check. Hence, any newly created files
        // and subdirs will disappear once this retry-delete makes
        // it past this check.
        //
        // The check isn't made when the change order is not in
        // retry mode because the checks in
        // JrnlDoesChangeOrderHaveChildren are expensive and, in most
        // cases, the delete will not encounter children.
        //
        // The call is made in the context of the ChangeOrderAccetp
        // thread because this thread has other references to the
        // tables referenced by JrnlDoesChangeOrderHaveChildren() and
        // doesn't require new hash table locks. Calling the function
        // out of StuDeleteEmptyDirectory() may require new locks
        // around the hash tables.
        //
        // 210642   B3SS:Replica Synchronization test throws Alpha computer into
        //    error state.  No further replication is possible.
        //    StuDeleteEmptyDirectory() was deleting the contents whenever
        //    CO_FLAG_RETRY was set BUT this functin was only checking for
        //    children when the co's state was IBCO_INSTALL_RETRY. Fix by
        //    checking for any CO_FLAG_RETRY of a directory delete..
        //

        //
        // Increment the Remote Change Orders Issued
        //
        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL)){
            //
            // If its not local and control, its a remote CO
            //
            PM_INC_CTR_REPSET(Replica, RCOIssued, 1);
        }

        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY) &&
            CoIsDirectory(ChangeOrder) &&
            DOES_CO_DELETE_FILE_NAME(CoCmd) &&
               (CO_STATE_IS(ChangeOrder, IBCO_FETCH_REQUESTED)   ||
                CO_STATE_IS(ChangeOrder, IBCO_FETCH_RETRY)       ||
                CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY) ||
                CO_STATE_IS(ChangeOrder, IBCO_INSTALL_RETRY))){

            TmpIDTableCtx = FrsAlloc(sizeof(TABLE_CTX));
            TmpIDTableCtx->TableType = TABLE_TYPE_INVALID;
            TmpIDTableCtx->Tid = JET_tableidNil;

            jerr = DbsOpenTable(ThreadCtx, TmpIDTableCtx, Replica->ReplicaNumber, IDTablex, NULL);

            if (JET_SUCCESS(jerr)) {

                ChildrenExist = JrnlDoesChangeOrderHaveChildren(ThreadCtx, TmpIDTableCtx, ChangeOrder);

                DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                DbsFreeTableCtx(TmpIDTableCtx, 1);
                FrsFree(TmpIDTableCtx);


                if (ChildrenExist) {
                    //
                    // Attempting to delete a directory with children;
                    // retry and hope the condition clears up later.
                    //
                    // Non-replicating children don't count; the Install
                    // thread will delete them.
                    //
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Retry Delete; has children");

                    //
                    // Consider the case where machine A does a movein of a subdir
                    // and before all the files are populated on machine B, machine
                    // B does a moveout of the dir.  Since B is not fully populated
                    // B does not issue delete COs for all the children in the tree.
                    // When the delete COs for the parent dirs arrive back at machine
                    // A we will see that it has populated children and we will
                    // retry those failing delete dir COs forever.  Not good.
                    //
                    // Not clear if this is a real problem.  A will continue to send
                    // COs for the rest of the subtree to machine B.  This will cause
                    // B to reanimate the parent dirs, getting the dir state from A.
                    // The file delete COs sent from B to A for files will get deleted
                    // on A.  The Dir delete Cos sent from B to A will have active
                    // children and will not get deleted on A and these same dirs
                    // should get reanimated on B.
                    //
                    // See bug 71033

                    return FrsErrorCantMoveOut;
                }

            } else {
                DPRINT1_JS(0, "DbsOpenTable (IDTABLE) on replica number %d failed.",
                           Replica->ReplicaNumber, jerr);
                DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                DbsFreeTableCtx(TmpIDTableCtx, 1);
                FrsFree(TmpIDTableCtx);
            }
        }
        //
        // Check for install retry on the remote CO.
        //

        switch (CO_STATE(ChangeOrder)) {

        case IBCO_FETCH_REQUESTED:
        case IBCO_FETCH_RETRY:

            //
            // Go fetch the remote file.
            //
            RcsSubmitRemoteCoAccepted(ChangeOrder);
            break;

        case IBCO_INSTALL_RETRY:

            FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY));
            //
            // Retry the install.
            //
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_REQUESTED);
            RcsSubmitRemoteCoInstallRetry(ChangeOrder);
            break;


        case IBCO_INSTALL_REN_RETRY:

            FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY));
            //
            // The install completed but the rename of a newly created
            // file into its final name failed.  Since this CO made it past
            // reconcile it should have picked up the state of the deferred
            // rename flag from the IDTable record.  Check that it did.
            // The retire code is responsible for doing the file rename.
            //
            FRS_ASSERT(COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME));
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Complete final rename");
            ChgOrdInboundRetired(ChangeOrder);
            break;

        case IBCO_INSTALL_DEL_RETRY:

            FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY));
            //
            // The CO completed but the actual delete has yet to be finished.
            // Since this CO made it past reconcile it should have picked up
            // the state of the deferred delete flag from the IDTable record.
            // Check that it did.  The retire code is responsible for doing
            // the final delete.
            //
            FRS_ASSERT(COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE));
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Complete final delete");
            ChgOrdInboundRetired(ChangeOrder);
            break;


        default:

            CHANGE_ORDER_TRACE(3, ChangeOrder, "Invalid Issue State");
            FRS_ASSERT(!"ChgOrdDispatch: Invalid Issue State");

        }   // end switch


    }

    return FrsErrorSuccess;
}


VOID
ChgOrdReject(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    )
/*++
Routine Description:

   This change order has been rejected.  Set the Issue Cleanup flags depending
   on what needs to be undone.

Arguments:
   ChangeOrder-- The change order.
   Replica    -- The Replica struct.

Return Value:

   None.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdReject:"

    PCHANGE_ORDER_RECORD CoCmd = &ChangeOrder->Cmd;
    BOOL RemoteCo, RetryCo, RecoveryCo;

    RemoteCo   = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    RetryCo    = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);
    RecoveryCo = RecoveryCo(ChangeOrder);

    //
    // For whatever reason, reject this changeorder.  The flags in
    // ChangeOrder->IssueCleanup specify what must be un-done.
    // Note: Perf: The IFLAG abort bit may be sufficient?
    //
    SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);

    if (RetryCo || RecoveryCo) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_INLOG);
    }

    FRS_PRINT_TYPE(5, ChangeOrder);

    if (RemoteCo) {
        //
        // Remote CO rejected.  Activate VV retire slot if not yet done
        // so we update the version vector entry for this originator.
        //
        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
            FRS_ASSERT(CO_STATE_IS_LE(ChangeOrder, IBCO_FETCH_RETRY));

            SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACK_INBOUND);

#if 0
            //
            // If the Aborted CO is in the IBCO_FETCH_RETRY state then
            // it is possible that a staging file was created before the
            // CO was sent thru retry.  It needs to be deleted.
            //
            // PERF:  What if the same CO from mult inbound partners
            //        are in retry?  Will the later COs that get aborted
            //        del the stage file still in use by first one to succeed?
            //        YUP. FOR NOW COMMENT THIS OUT AND LET THE RESTART CODE CLEAN
            //        UP THE LEFTOVER STAGING FILES,
            //
            if (CO_STATE_IS(ChangeOrder, IBCO_FETCH_RETRY)) {
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_DEL_STAGE_FILE);
            }
#endif

            //
            // Don't bother updating the ondisk version vector if the
            // version vector has already seen this Vsn. This condition
            // can arise if a machine receives the same series of change
            // orders from two machines. The change orders could easily
            // complete out of order.
            //
            if (VVHasVsn(Replica->VVector, CoCmd)) {
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD);
            } else {
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV);
                //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
            }


        } else {
            //
            // VVretire slot has been activated for this CO.
            // If VVRETIRE_EXECuted is set then the the Outlog record has
            // been inserted.
            //
            FRS_ASSERT(!CO_STATE_IS_LE(ChangeOrder, IBCO_FETCH_RETRY));

            LOCK_GEN_TABLE(Replica->VVector);
            if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)) {
                //
                // Cause the install incomplete flag in the outlog record
                // to be cleared so OutLog process can delete the staging
                // file when it's done.
                //
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_CO_ABORT |
                                               ISCU_DEL_STAGE_FILE_IF);
            } else {
                //
                // ISCU_ACTIVATE_VV_DISCARD will clear the INS_OUTLOG
                // action in the VV slot but still updates the VV at the
                // right time.
                //
                SET_ISSUE_CLEANUP(ChangeOrder, ISCU_ACTIVATE_VV_DISCARD |
                                               ISCU_DEL_STAGE_FILE);
                SET_CO_IFLAG(ChangeOrder, CO_IFLAG_CO_ABORT);
            }
            UNLOCK_GEN_TABLE(Replica->VVector);

        }
        //
        // Install is done (or if it's not, it is now).
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
    } else {

        //
        // If this CO was going to do a Directory Enumeration then turn it off.
        //
        if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_DIR_ENUM_PENDING)) {
            CLEAR_CO_IFLAG(ChangeOrder, CO_IFLAG_DIR_ENUM_PENDING);
        }

        //
        // Advance the inlog commit point for local COs that are not reanimated
        // COs. Need to check if greater than because a retry CO that gets
        // rejected can move the commit point back.
        //
        if (CoCmd->JrnlFirstUsn != (USN) 0) {

            PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;

            AcquireQuadLock(&pVme->QuadWriteLock);
            if (Replica->InlogCommitUsn < CoCmd->JrnlFirstUsn) {
                Replica->InlogCommitUsn = CoCmd->JrnlFirstUsn;
                DPRINT1(4, "++ Replica->InlogCommitUsn: %08x %08x\n",
                        PRINTQUAD(Replica->InlogCommitUsn));
            }
            ReleaseQuadLock(&pVme->QuadWriteLock);
        }
    }
}



ULONG
ChgOrdInboundRetired(
    IN PCHANGE_ORDER_ENTRY   ChangeOrder
    )
/*++

Routine Description:

    The processing of an inbound change order is completed.

    Send a request to the DB subsystem to update the IDTable and delete the
    record from the inbound log table.

Arguments:

    ChangeOrder -- The change order

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInboundRetired:"

    PREPLICA              Replica;

    CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Enter Retire");


    Replica = CO_REPLICA(ChangeOrder);

    if (Replica == NULL) {
        DPRINT(0, "++ ERROR - ChangeOrder NewReplica and OrigReplica are NULL.\n");
        FRS_ASSERT(!"ChangeOrder NewReplica and OrigReplica are NULL");
        return FrsErrorInternalError;
    }

    //
    // This routine can execute in any thread so use the DB server to delete
    // the record from the inbound log and update the IDTable.
    // Once the Database updates are complete the DBService will call
    // us back through ChgOrdIssueCleanup() so we can cleanup our structs.
    //
    DbsPrepareCmdPkt(NULL,                        //  CmdPkt,
                     Replica,                     //  Replica,
                     CMD_DBS_RETIRE_INBOUND_CO,   //  CmdRequest,
                     NULL,                        //  TableCtx,
                     ChangeOrder,                 //  CallContext,
                     0,                           //  TableType,
                     0,                           //  AccessRequest,
                     0,                           //  IndexType,
                     NULL,                        //  KeyValue,
                     0,                           //  KeyValueLength,
                     TRUE);                       //  Submit

    return FrsErrorSuccess;
}



ULONG
ChgOrdInboundRetry(
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN ULONG                NewState
    )
/*++

Routine Description:

    The Install/generate phase of an inbound change order has failed
    and must be retried later.

    Send a request to the DB subsystem to update the change order in the inbound
    log and get the outbound log process started.  When the change order is
    later retried it goes through all the normal issue and reconcilliation
    checks.

Arguments:

    ChangeOrder -- The change order
    NewState -- The new IBCO_xx state telling what kind of CO retry is needed.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInboundRetry:"

    PREPLICA    Replica;
    ULONG       LocationCmd;

    //
    // If the connection to the inbound partner was lost then just send it
    // to the inlog for later retry.
    //
    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_NO_INBOUND)) {

        //
        // We can't do retry for directory creates because subsequent file ops could
        // fail. Although a local Co may be retried because of a lack of
        // staging space. Hence,
        //
        if (CoIsDirectory(ChangeOrder)&& !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {

            LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
            if (CO_NEW_FILE(LocationCmd)) {
                //
                // Caller should have forced an UnJoin so we don't come here.
                // This causes any further change orders from this partner
                // to go to the INLOG.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Error - can't retry failed dir cre");
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"ChgOrdInboundRetry: can't retry failed dir cre");
                return ChgOrdInboundRetired(ChangeOrder);
            }
        }
    }

    Replica = CO_REPLICA(ChangeOrder);
    if (Replica == NULL) {
        DPRINT(0, "++ ERROR - ChangeOrder NewReplica and OrigReplica are NULL.\n");
        FRS_ASSERT(!"ChgOrdInboundRetry: ChangeOrder NewReplica and OrigReplica are NULL");
        return FrsErrorInternalError;
    }

    SET_CHANGE_ORDER_STATE(ChangeOrder, NewState);
    //
    // This routine can execute in any thread so use the DB server to update
    // the record in the inbound log for retry.
    // Once the Database updates are complete the DBService will call
    // us back through ChgOrdIssueCleanup() so we can cleanup our structs.
    //
    DbsPrepareCmdPkt(NULL,                        //  CmdPkt,
                     Replica,                     //  Replica,
                     CMD_DBS_RETRY_INBOUND_CO,    //  CmdRequest,
                     NULL,                        //  TableCtx,
                     ChangeOrder,                 //  CallContext,
                     0,                           //  TableType,
                     0,                           //  AccessRequest,
                     0,                           //  IndexType,
                     NULL,                        //  KeyValue,
                     0,                           //  KeyValueLength,
                     TRUE);                       //  Submit

    return FrsErrorSuccess;
}


ULONG
ChgOrdIssueCleanup(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    ULONG                 CleanUpFlags
    )
/*++

Routine Description:

    This is a common cleanup routine used for change order abort during or after
    issue and for change order completion.

    It uses the DB thread context of the caller's thread.

    The cleanup flags drive the opertions performed.  See below.
    The sequence of the code segments below is important for both correct
    operation and recoverability.  DO NOT CHANGE unless you understand.

    Different calls use different sets of operation.  They could be broken out
    into seperate functions.  However having the code segments in one routine
    helps both maintainence and to see the overall relationship between segments.

Arguments:

    ThreadCtx    -- ptr to the thread context for DB
    Replica      -- ptr to replica struct.
    ChangeOrder  -- ptr to change order entry that has just committed.
    CleanUpFlags -- The clean up flag bits control what cleanup operations are done.

    ISCU_DEL_PREINSTALL    - Delete the pre-install file
    ISCU_DEL_IDT_ENTRY     - Delete the IDTable entry
    ISCU_UPDATE_IDT_ENTRY  - Update the IDTable entry
    ISCU_DEL_INLOG         - Delete the INlog entry (if RefCnt == 0)
    ISCU_AIBCO             - Delete Active Inbound Change Order table entry
    ISCU_ACTIVE_CHILD      - Delete the Active child entry
    ISCU_CO_GUID           - Delete the entry from the change order GUID table
    ISCU_CHECK_ISSUE_BLOCK - Check if CO is blocking another and unidle queue.
    ISCU_DEL_RTCTX         - Delete the Replica Thread Ctx struct (if RefCnt==0)
    ISCU_ACTIVATE_VV       - Activate the Version Vector retire slot for this CO
    ISCU_UPDATEVV_DB       - Update the Version Vector entry in the database.
    ISCU_ACTIVATE_VV_DISCARD  - Discard the VV retire slot.
    ISCU_ACK_INBOUND       - Notify the Inbound partner or update our local VV
    ISCU_INS_OUTLOG        - Insert the CO into the outbound log.
    ISCU_INS_OUTLOG_NEW_GUID - Re-Insert the CO into the outbound log with a new CO Guid.
    ISCU_UPDATE_INLOG      - Update the State, Flags and IFlags fields in the DB CO record.
    ISCU_DEL_STAGE_FILE    - Delete the staging file.
    ISCU_DEL_STAGE_FILE_IF - Delete staging file only IF no outbound partners
    ISCU_FREE_CO           - Free the Change Order (if RefCnt==0)
    ISCU_DEC_CO_REF        - Decrement the ref count on the CO.
    ISCU_CO_ABORT          - This CO is aborting.
    ISCU_NC_TABLE          - Delete the entry in the name conflict table.
    ISCU_UPDATE_IDT_FLAGS  - Update just IDTable record flags, not entire record
    ISCU_UPDATE_IDT_FILEUSN- Update just IDTable record file USN, not entire record.
    ISCU_UPDATE_IDT_VERSION- Update just the version info on the file.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdIssueCleanup:"

#undef FlagChk
#define FlagChk(_flag_) BooleanFlagOn(CleanUpFlags, _flag_)

    ULONGLONG             SeqNum;

    PVOLUME_MONITOR_ENTRY pVme;
    PCHANGE_ORDER_ENTRY   ActiveChangeOrder;
    PCHANGE_ORDER_ENTRY   DupChangeOrder;
    ULONG                 GStatus, WStatus, WStatus2;
    ULONG                 FStatus = FrsErrorSuccess;
    BOOL                  RestartQueue = FALSE;
    PQHASH_TABLE          ActiveChildren;
    PQHASH_ENTRY          QHashEntry;
    BOOL                  PendingCoOnParent;
    BOOL                  RetryCo;
    GUID                  *BusyParentGuid = NULL;
    CHAR                  BusyParentGuidStr[GUID_CHAR_LEN];
    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;
    PTABLE_CTX            TableCtx;
    PTABLE_CTX            InLogTableCtx;
    PWCHAR                TmpName = NULL;
    TABLE_CTX             TempTableCtx;
    PSINGLE_LIST_ENTRY    Entry;
    ULONG                 RefCount;
    ULONG                 SaveState, SaveFlags;
    JET_ERR               jerr;
    ULONG                 FieldIndex[8];
    PVOID                 pDataRecord;
    BOOL                  DelStage, UpdateOutLog, InstallIncomplete;
    BOOL                  NotifyRetryThread = FALSE;
    ULONG                 IdtFieldUpdateList[CO_ACCEPT_IDT_FIELD_UPDATE_MAX];
    ULONG                 IdtFieldUpdateCount;
    ULONG                 MissMatch;
    GUID                  OldGuid;
    CHAR                  FlagBuffer[160];



    CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO IssueCleanup, FlgsA", CleanUpFlags);
    CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO IssueCleanup, FlgsC", ChangeOrder->IssueCleanup);
    MissMatch = (~CleanUpFlags) & ChangeOrder->IssueCleanup;
    if (MissMatch != 0) {
        CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO IssueCleanup, FlgsE", MissMatch);
    }
    //
    // Merge flags with bits from CO if caller says ok.
    //
    if (!FlagChk(ISCU_NO_CLEANUP_MERGE)) {
        CleanUpFlags |= ChangeOrder->IssueCleanup;
    }

    CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO IssueCleanup, Flgs ", CleanUpFlags);

    if (CleanUpFlags == 0) {
        return FrsErrorSuccess;
    }

    FrsFlagsToStr(CleanUpFlags, IscuFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DPRINT2(3, ":: CoG %08x, Flags [%s]\n", CoCmd->ChangeOrderGuid.Data1, FlagBuffer);

    FRS_ASSERT(Replica != NULL);

    pVme = Replica->pVme;
    FRS_ASSERT((pVme != NULL) || !REPLICA_IS_ACTIVE(Replica));

    if ((pVme == NULL) || (AcquireVmeRef(pVme) == 0)) {
        FStatus = FrsErrorChgOrderAbort;
        pVme = NULL;
        //
        // Cleanup what we can.  The following depend on the Vme.
        //
        ClearFlag(CleanUpFlags, ISCU_AIBCO         |
                                ISCU_ACTIVE_CHILD  |
                                ISCU_DEL_IDT_ENTRY |
                                ISCU_DEL_PREINSTALL );
    } else {
        ActiveChildren = pVme->ActiveChildren;
    }

    //
    // If this is a Demand Refresh CO then some cleanup actions are not
    // required.  Instead of littering the various paths to this function,
    // Retry, VV execute, Retire, Reject, ... with tests for Demand Refresh
    // we just clear the appropriate flags here so the other paths can
    // ignore it for the most part. 
    //
    // We now want to send the demand refresh COs forward to other partners
    // to ensure convergence so do not clear the ISCU_INS_OUTLOG and
    // ISCU_INS_OUTLOG_NEW_GUID flags.
    //
    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_DEMAND_REFRESH)) {

        ClearFlag(CleanUpFlags,  ISCU_ACK_INBOUND         |
                                 ISCU_ACTIVATE_VV         |
                                 ISCU_UPDATEVV_DB         |
                                 ISCU_ACTIVATE_VV_DISCARD |
//                                 ISCU_INS_OUTLOG          |
//                                 ISCU_INS_OUTLOG_NEW_GUID |
                                 ISCU_DEL_INLOG           |
                                 ISCU_UPDATE_INLOG);

        CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO ISCU DemandRefresh, Flgs", CleanUpFlags);
    } else
    //
    // If this is a MorphGenCo then it is a local CO that never was inserted
    // into the Inbound Log.  Clear the Inlog related flags here.
    //
    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN)) {

        ClearFlag(CleanUpFlags,  ISCU_DEL_INLOG     |
                                 ISCU_UPDATE_INLOG);

        CHANGE_ORDER_TRACEX(3, ChangeOrder, "CO ISCU MORPH GEN, Flgs", CleanUpFlags);
    }


    RetryCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

    //
    //                                                   ISCU_DEL_PREINSTALL
    // Delete the pre-Install File
    //
    if (FlagChk(ISCU_DEL_PREINSTALL)) {
        HANDLE  Handle;

        //
        // Open the pre-install file and delete it
        //

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO PreInstall File Delete");
        TmpName = FrsCreateGuidName(&CoCmd->ChangeOrderGuid,
                                    PRE_INSTALL_PREFIX);
        WStatus2 = FrsCreateFileRelativeById(&Handle,
                                            ChangeOrder->NewReplica->PreInstallHandle,
                                            NULL,
                                            0,
                                            0,
                                            TmpName,
                                            (USHORT)(wcslen(TmpName) *
                                                     sizeof(WCHAR)),
                                            NULL,
                                            FILE_OPEN,
                                            ATTR_ACCESS | DELETE);
        if (!WIN_SUCCESS(WStatus2)) {
            DPRINT2_WS(0, "++ WARN - Failed to open pre-install file %ws for %ws for delete;",
                      TmpName, CoCmd->FileName, WStatus2);
        } else {
            FrsResetAttributesForReplication(TmpName, Handle);
            WStatus2 = FrsDeleteByHandle(TmpName, Handle);
            DPRINT2_WS(0, "++ WARN - Failed to delete pre-install file %ws for %ws;",
                      TmpName, CoCmd->FileName, WStatus2);

            FrsCloseWithUsnDampening(TmpName,
                                     &Handle,
                                     ChangeOrder->NewReplica->pVme->FrsWriteFilter,
                                     &CoCmd->FileUsn);
        }
        FrsFree(TmpName);
    }

    //
    //                                                   ISCU_DEL_STAGE_FILE
    //                                                   ISCU_DEL_STAGE_FILE_IF
    //                                                   ISCU_CO_ABORT
    // Delete the staging file if so ordered or if there are no outbound
    // partners and either the CO is aborted or a conditional delete is requested.
    //
    DelStage = FlagChk(ISCU_DEL_STAGE_FILE)  ||
               (NO_OUTLOG_PARTNERS(Replica) &&
                (FlagChk(ISCU_DEL_STAGE_FILE_IF) || FlagChk(ISCU_CO_ABORT)));

    if (DelStage) {

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO StageFile Delete");

        if (!StageDeleteFile(CoCmd, NULL, TRUE)) {
            DPRINT1(0, "++ ERROR - Failed to delete staging file: %ws\n",
                    CoCmd->FileName);
            FStatus = FrsErrorStageFileDelFailed;
        }
    }

    //
    //                                                   ISCU_DEL_STAGE_FILE_IF
    //                                                   ISCU_CO_ABORT
    // Update the Flags field on the outbound log record if we have partners
    // and the record was created and either the CO is aborted or a conditional
    // staging file delete is requested.
    //
    UpdateOutLog = !NO_OUTLOG_PARTNERS(Replica) &&
                   CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC) &&
                   (FlagChk(ISCU_DEL_STAGE_FILE_IF) || FlagChk(ISCU_CO_ABORT));

    InstallIncomplete = COC_FLAG_ON(CoCmd, CO_FLAG_INSTALL_INCOMPLETE);

    if (UpdateOutLog && (InstallIncomplete ||
                         CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY) ||
                         COE_FLAG_ON(ChangeOrder, COE_FLAG_RECOVERY_CO) ||
                         FlagChk(ISCU_CO_ABORT))) {
        //
        // Clear the Install Incomplete flag or set abort flag so the staging
        // file can be deleted when the outbound log process is done.
        // Use local table ctx if not provided.
        //
        if (ChangeOrder->RtCtx == NULL) {
            TableCtx = &TempTableCtx;
            TableCtx->TableType = TABLE_TYPE_INVALID;
            TableCtx->Tid = JET_tableidNil;
        } else {
            TableCtx = &ChangeOrder->RtCtx->OUTLOGTable;
        }

        DbsAllocTableCtxWithRecord(OUTLOGTablex, TableCtx, CoCmd);

        DPRINT2(4, "++ Clear Install Incomplete in outlog for Index %d, File: %ws\n",
                CoCmd->SequenceNumber, CoCmd->FileName);

        CLEAR_COC_FLAG(CoCmd, CO_FLAG_INSTALL_INCOMPLETE);

        //                                                   ISCU_CO_ABORT
        if (FlagChk(ISCU_CO_ABORT)) {
            SET_COC_FLAG(CoCmd, CO_FLAG_ABORT_CO);
            DPRINT2(4, "++ Set abort flag in outlog for Index %d, File: %ws\n",
                    CoCmd->SequenceNumber, CoCmd->FileName);
        }
        //
        // Clear the same flags that are cleared during insert
        // (except for ABORT).
        //
        SAVE_CHANGE_ORDER_STATE(ChangeOrder, SaveState, SaveFlags);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_GROUP_OL_CLEAR);
        if (FlagChk(ISCU_CO_ABORT)) {
            SET_COC_FLAG(CoCmd, CO_FLAG_ABORT_CO);
        }

        //
        //  ** WARNING ** WARNING ** WARNING **
        // The following doesn't work if the Outbound Log process saves any
        // state in the flags word because we overwrite it here.  The Outlog
        // process currently has no need to modify these bits so this is OK.
        // Change orders generated during VVJoin set these flags but these
        // change orders are never processed by the inlog process so we do
        // not write to their flags field.  If the Outlog process needs to
        // write these bits this code must be updated so state is not lost,
        // or the Outlog process could add its own flag word to the change order.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO OutLog Update");
        FStatus = DbsUpdateRecordField(ThreadCtx,
                                       Replica,
                                       TableCtx,
                                       OLChangeOrderGuidIndexx,
                                       &CoCmd->ChangeOrderGuid,
                                       COFlagsx);
        RESTORE_CHANGE_ORDER_STATE(ChangeOrder, SaveState, SaveFlags);
        TableCtx->pDataRecord = NULL;
        //
        // Clear the Jet Set/Ret Col address fields for the Change Order
        // Extension buffer to prevent reuse since that buffer goes with the CO.
        //
        DBS_SET_FIELD_ADDRESS(TableCtx, COExtensionx, NULL);

        if (TableCtx == &TempTableCtx) {
            DbsFreeTableCtx(TableCtx, 1);
        }
        if (!FRS_SUCCESS(FStatus)) {
            CHANGE_ORDER_TRACEF(3, ChangeOrder, "Error Updating Outlog", FStatus);
            //
            // The Outlog record might not be there if we have previously gone
            // through an IBCO_INSTALL_REN_RETRY state and already cleared the
            // CO_FLAG_INSTALL_INCOMPLETE flag.  This would have allowed the
            // Outlog cleanup thread to delete the outlog record when it
            // finished sending the CO even if the install rename had not yet
            // completed. But if InstallIncomplete is TRUE then the out log
            // record should be there.
            //
            // A similar situation occurs on deletes where a sharing violation
            // marks the IDTable as IDREC_FLAGS_DELETE_DEFERRED and sends the CO
            // thru retry in the IBCO_INSTALL_DEL_RETRY state.  The outlog
            // process can process the delete CO and cleanup so we don't find the record.
            //
            if (InstallIncomplete || (FStatus != FrsErrorNotFound)) {
                DPRINT_FS(0,"++ ERROR - Update of Flags in Outlog record failed.", FStatus);
                FStatus = FrsErrorSuccess;
            }
        }
    }


    //
    //                                                   ISCU_UPDATE_IDT_ENTRY
    // Update the IDTable record for this CO.  This must be done before we
    // Activate the VV slot in case this CO is next in line to retire.
    // OutLog process needs to see current IDTable entry.
    //
    if (FlagChk(ISCU_UPDATE_IDT_ENTRY)) {
        DPRINT(5, "Updating the IDTable record -----------\n");
        FStatus = ChgOrdUpdateIDTableRecord(ThreadCtx, Replica, ChangeOrder);
        DPRINT_FS(0,"++ ERROR - ChgOrdUpdateIDTableRecord failed.", FStatus);
        FRS_ASSERT(FRS_SUCCESS(FStatus) || !"IssueCleanup: ISCU_UPDATE_IDT_ENTRY failed");
    } else {

        PIDTABLE_RECORD IDTableRec;
        //
        //                                               ISCU_UPDATE_IDT_FLAGS
        // Not updating the entire record so check the field flags.
        //
        IdtFieldUpdateCount = 0;
        if (FlagChk(ISCU_UPDATE_IDT_FLAGS)) {
            IdtFieldUpdateList[IdtFieldUpdateCount++] = Flagsx;
        }

        //
        //                                               ISCU_UPDATE_IDT_VVFLAGS
        //
        if (FlagChk(ISCU_UPDATE_IDT_VVFLAGS)) {
            IdtFieldUpdateList[IdtFieldUpdateCount++] = IdtVVFlagsx;
        }

        //                                               ISCU_UPDATE_IDT_FILEUSN
        if (FlagChk(ISCU_UPDATE_IDT_FILEUSN)) {
            IdtFieldUpdateList[IdtFieldUpdateCount++] = CurrentFileUsnx;
            IDTableRec = (PIDTABLE_RECORD)(ChangeOrder->RtCtx->IDTable.pDataRecord);
            IDTableRec->CurrentFileUsn = CoCmd->FileUsn;
        }


        //                                               ISCU_UPDATE_IDT_VERSION
        // Update all the info related to file reconcilation so the info is
        // consistent for future reconcile checks and so correct version
        // info can be generated when local changes occur to the file/dir.
        //
        if (FlagChk(ISCU_UPDATE_IDT_VERSION)) {
            IdtFieldUpdateList[IdtFieldUpdateCount++] = VersionNumberx;
            IdtFieldUpdateList[IdtFieldUpdateCount++] = EventTimex;
            IdtFieldUpdateList[IdtFieldUpdateCount++] = OriginatorGuidx;
            IdtFieldUpdateList[IdtFieldUpdateCount++] = OriginatorVSNx;
            IdtFieldUpdateList[IdtFieldUpdateCount++] = FileSizex;

            IDTableRec = (PIDTABLE_RECORD)(ChangeOrder->RtCtx->IDTable.pDataRecord);
            IDTableRec->VersionNumber   = CoCmd->FileVersionNumber;
            IDTableRec->EventTime       = CoCmd->EventTime.QuadPart;
            IDTableRec->OriginatorGuid  = CoCmd->OriginatorGuid;
            IDTableRec->OriginatorVSN   = CoCmd->FrsVsn;
            IDTableRec->FileSize        = CoCmd->FileSize;
        }


        FRS_ASSERT(IdtFieldUpdateCount <= CO_ACCEPT_IDT_FIELD_UPDATE_MAX);
        if (IdtFieldUpdateCount > 0) {
            FStatus = DbsUpdateIDTableFields(ThreadCtx,
                                             Replica,
                                             ChangeOrder,
                                             IdtFieldUpdateList,
                                             IdtFieldUpdateCount);
            DPRINT_FS(0,"++ ERROR - DbsUpdateIDTableFields failed.", FStatus);
            FRS_ASSERT(FRS_SUCCESS(FStatus) || !"ISCU_UPDATE_IDT_VERSION - update fields failed");
        }
    }

    //
    //                                                      ISCU_ACTIVATE_VV
    //                                                      ISCU_ACTIVATE_VV_DISCARD
    // Update the version vector. This could result in just marking the
    // retire slot entry or we could end up getting called back to
    // write the outbound log entry, decrement the ref count, or update the
    // Version vector table in the database.  The cleanup flags that are passed
    // through are saved in the retire slot for use when the entry is processed.
    // The INLOG flags may not be set if this CO is rejected on the first pass
    // so the caller must tell us.
    //
    // code improvement: Use IssueCleanup flags in COe now instead of
    // saving them in the vv retire slot.
    //
    if (FlagChk(ISCU_ACTIVATE_VV) || FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {
        //
        // PERF: optimize the case where this CO is at the head of the VV retire
        //       list and is the only CO to retire.  In this case the func could
        //       just return and avoid the recursive call back.
        //
        if (!FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {
            //
            // Only do this once for the change order.
            //
            SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        }
        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO Activate VV slot");
        FStatus = VVRetireChangeOrder(ThreadCtx,
                                      Replica,
                                      ChangeOrder,
                                      (CleanUpFlags & (ISCU_INS_OUTLOG   |
                                                       ISCU_INS_OUTLOG_NEW_GUID |
                                                       ISCU_DEL_INLOG    |
                                                       ISCU_UPDATE_INLOG |
                                                       ISCU_ACTIVATE_VV_DISCARD))
                                       | ISCU_NO_CLEANUP_MERGE
                                      );
        if (FRS_SUCCESS(FStatus)) {
            //
            // Propagating the change order is now the job of VVRetireChangeOrder.
            //
            ClearFlag(CleanUpFlags, (ISCU_INS_OUTLOG | ISCU_INS_OUTLOG_NEW_GUID));
        } else
        if (FStatus == FrsErrorVVSlotNotFound) {
            //
            // No slot for an Out of order CO so we handle all cleanup ourselves.
            //
            FStatus = FrsErrorSuccess;

        } else {
            DPRINT_FS(0, "++ ERROR - VVRetireChangeOrder failed.", FStatus);
            FRS_ASSERT(FRS_SUCCESS(FStatus) || !"VVRetireChangeOrder failed");
        }
    }

    //
    //                                                   ISCU_UPDATEVV_DB
    // Update the version vector in the database.
    //
    if (FlagChk(ISCU_UPDATEVV_DB)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO DB Update VV");

        FStatus = DbsUpdateVV(ThreadCtx,
                              Replica,
                              ChangeOrder->RtCtx,
                              ChangeOrder->Cmd.FrsVsn,
                              &ChangeOrder->Cmd.OriginatorGuid);
        DPRINT_FS(0,"++ ERROR - DbsUpdateVV failed.", FStatus);
        FRS_ASSERT(FRS_SUCCESS(FStatus) || !"ISCU_UPDATEVV_DB failed");
    }

    //
    //                                                   ISCU_ACK_INBOUND
    // Let the replica subsystem know this change order is done.
    // Restore the Partner's sequence number to use in the Ack.
    // The Ack is done after the VV update so we pickup the VSN for the
    // most recent VV update for this change order originator.
    //
    if (FlagChk(ISCU_ACK_INBOUND)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO Ack Inbound");
        RcsInboundCommitOk(Replica, ChangeOrder);
    }

    //
    //                                                   ISCU_INS_OUTLOG
    //                                                   ISCU_INS_OUTLOG_NEW_GUID
    // Insert the change order into the Outbound log if any outbound partners.
    //
    if (FlagChk((ISCU_INS_OUTLOG | ISCU_INS_OUTLOG_NEW_GUID)) &&
        !NO_OUTLOG_PARTNERS(Replica)) {

        //
        // Need the list lock to preserve lock ordering when we unidle the queue.
        // This serializes any insert into outlog and update of inlog.
        // OutlogInserCo overwrites SequenceNumber which can confuse inlog update.
        //
        FrsRtlAcquireListLock(&FrsVolumeLayerCOList);

        ChgOrdAcquireLockGuid(ChangeOrder);

        //
        // Increment the (Local and Remote) CO propagated counters
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {
            PM_INC_CTR_REPSET(Replica, LCOPropagated, 1);
        }
        //
        // It's a Remote CO
        //
        else if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL)) {
            PM_INC_CTR_REPSET(Replica, RCOPropagated, 1);
        }

        TableCtx = (ChangeOrder->RtCtx != NULL) ?
            &ChangeOrder->RtCtx->OUTLOGTable : NULL;
        FRS_ASSERT(TableCtx != NULL);

        SAVE_CHANGE_ORDER_STATE(ChangeOrder, SaveState, SaveFlags);

        //
        // Update the CO state and clear the flags that should not be
        // sent to the outbound partner.
        //
        SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_OUTBOUND_REQUEST);
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_GROUP_OL_CLEAR);

        //
        // Remote retry change orders are inserted into the outbound log
        // twice; once after the failed install and again after the successful
        // install.  Needless to say, the second insert may generate duplicate
        // key errors unless it is assigned a new guid.
        //
        // This deals with the problem of an outbound partner doing a VVJOIN
        // while we still have remote COs in an install retry state.  If the
        // original remote CO was inserted into the outlog before the VVJOIN
        // request arrived then the remote CO may never have been sent
        // on to the outbound partner.  But when processing the VVJOIN, the
        // IDTable won't be up to date yet (since the install isn't finished)
        // so the downstream partner may not see the file (or the new contents
        // if this is an update).  Inserting the remote CO (for a retry) into
        // the outlog a second time closes this window.
        //
        if (FlagChk(ISCU_INS_OUTLOG_NEW_GUID)) {
            COPY_GUID(&OldGuid, &ChangeOrder->Cmd.ChangeOrderGuid);
            FrsUuidCreate(&ChangeOrder->Cmd.ChangeOrderGuid);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "CO Ins Outlog with new guid");
        }

        FStatus = OutLogInsertCo(ThreadCtx, Replica, TableCtx, ChangeOrder);

        //
        // Restore the original guid
        //
        if (FlagChk(ISCU_INS_OUTLOG_NEW_GUID)) {
            COPY_GUID(&ChangeOrder->Cmd.ChangeOrderGuid, &OldGuid);
        }

        RESTORE_CHANGE_ORDER_STATE(ChangeOrder, SaveState, SaveFlags);

        if (FStatus == FrsErrorKeyDuplicate) {

            //
            // Currently we can't rely on this check to filter out bogus
            // asserts.  Consider the following case: The same CO arrives from
            // two inbound partners, A & B.  CO-A completes the stage file
            // fetch but was blocked from the install due to sharing violation.
            // It goes thru retry and does its partner ACK and the outlog
            // insert and the VV Update.
            //
            // Now CO-B, which was in the process queue so it got past the VV
            // checks, goes to Fetch and finds the stage file already there
            // then it goes thru retry with the same sharing violation (or it
            // may even finish the install) and then it too tries to do the
            // OUTLOG insert.  It's not a recovery CO so it will Assert.  We
            // could test to see if the stage file was already present and
            // skip the assert but that doesn't handle the case of two delete
            // Change Orders since they don't have a staging file.
            //
            // So, until we can devise a more competent test we
            // will treat it as a warning and bag the assert for now.
            //
            if (!RecoveryCo(ChangeOrder)) {
                DPRINT(1, "++ WARNING -- Duplicate key insert into OUTLOG.  Not a recovery CO\n");
            }
            FStatus = FrsErrorSuccess;
        }
        else
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT1(0, "++ ERROR - Don't send %08x %08x to outbound; database error\n",
                   PRINTQUAD(CoCmd->FrsVsn));
            FRS_PRINT_TYPE(0, ChangeOrder);
            FRS_ASSERT(!"ISCU_INS_OUTLOG failed");
        }

        //
        // Release the lock to allow parallelism.
        //
        ChgOrdReleaseLockGuid(ChangeOrder);
        FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
    }

    //
    //                                                   ISCU_DEL_IDT_ENTRY
    // Delete the IDTable record for this CO.
    //
    if (FlagChk(ISCU_DEL_IDT_ENTRY)) {
        TableCtx = (ChangeOrder->RtCtx != NULL) ? &ChangeOrder->RtCtx->IDTable
                                                : NULL;

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO IDTable Delete");
        FStatus = DbsDeleteIDTableRecord(ThreadCtx,
                                         Replica,
                                         TableCtx,
                                         &CoCmd->FileGuid);

        DPRINT_FS(0,"++ ERROR - DbsDeleteIDTableRecord failed.", FStatus);
        FRS_ASSERT(FRS_SUCCESS(FStatus) || !"ISCU_DEL_IDT_ENTRY failed");

        //
        // Remove the parent FID table entry too.  Might not be there if didn't
        // get to Install Rename state on the CO.
        //
        FRS_ASSERT(pVme != NULL);  // to make prefast happy

        GStatus = QHashDelete(pVme->ParentFidTable, &ChangeOrder->FileReferenceNumber);
        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(4, "++ WARNING: QHashDelete of ParentFidTable Entry, status: %d\n", GStatus);
        }


        if (CoCmdIsDirectory(CoCmd)) {
            //
            // If this was an aborted create there might be a dir table entry.
            // Delete it and the filter table entry too.
            //
            TableCtx = (ChangeOrder->RtCtx != NULL) ? &ChangeOrder->RtCtx->DIRTable
                                                    : NULL;
            FStatus = DbsDeleteDIRTableRecord(ThreadCtx,
                                              Replica,
                                              TableCtx,
                                              &CoCmd->FileGuid);
            if (FRS_SUCCESS(FStatus)) {
                //
                // If this is a remote CO then we may need to clean up the
                // Journal's Dir Filter table too.  If it's a local CO
                // then leave it alone since the journal handles the
                // creates and deletes of filter table entries by itself.
                //
                if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {
                    JrnlAcquireChildLock(Replica);
                    WStatus = JrnlDeleteDirFilterEntry(pVme->FilterTable,
                                                       &ChangeOrder->FileReferenceNumber,
                                                       NULL);
                    JrnlReleaseChildLock(Replica);
                    DPRINT1_WS(4, "++ WARN - deleting dir filter entry for %ws;", CoCmd->FileName, WStatus);
                }
            } else {
                DPRINT_FS(4,"++ WARNING - Dir table record delete failed.", FStatus);
            }
        }
    }


//
// Check if any hold issue conflict table cleanup flag is on otherwise we can
// skip getting the lock.
//
    if (FlagChk(ISCU_HOLDIS_CLEANUP)) {

        //
        // Need the list lock to preserve lock ordering when we unidle the queue.
        //
        FrsRtlAcquireListLock(&FrsVolumeLayerCOList);

        ChgOrdAcquireLockGuid(ChangeOrder);

        //
        // Don't go to the Retire Started state if this is a Retry Co.
        //
        if (!RetryCo) {
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_RETIRE_STARTED);
        }

        //
        //                                                   ISCU_AIBCO
        // Find the change order in the Active inbound change order table.
        // Returns a reference.
        //
        if (FlagChk(ISCU_AIBCO)) {
            GStatus = GhtLookup(pVme->ActiveInboundChangeOrderTable,
                                &CoCmd->FileGuid,
                                TRUE,
                                &ActiveChangeOrder);

            if (GStatus != GHT_STATUS_SUCCESS) {
                DPRINT(0, "++ ERROR - Inbound ChangeOrder not found in ActiveInboundChangeOrderTable.\n");
                ReleaseVmeRef(pVme);
                ChgOrdReleaseLockGuid(ChangeOrder);
                FRS_ASSERT(!"Inbound CO not found in ActiveInboundChangeOrderTable");
            }

            if (ChangeOrder != ActiveChangeOrder) {
                DPRINT(0, "++ ERROR - Inbound ChangeOrder not equal ActiveChangeOrder\n");
                DPRINT(0, "++ Change order in Active Table:\n");
                FRS_PRINT_TYPE(0, ActiveChangeOrder);
                DPRINT(0, "++ Change order to be retired:\n");
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"Inbound ChangeOrder not equal ActiveChangeOrder");
                ChgOrdReleaseLockGuid(ChangeOrder);
            }
        }


        //
        //                                                   ISCU_NC_TABLE
        // Remove the entry in the Name conflict table
        //
        // If the reference count goes to 0, then pull the "Unblock the pVme
        // process queue" flag into the change order and remove the qhash entry.
        //
        // NameConflictTable Entry:
        // An entry in the NameConflictTable contains a reference count of the
        // number of active change orders that hash to that entry and a Flags
        // word that is set to COE_FLAG_VOL_COLIST_BLOCKED if the process queue
        // for this volume is idled while waiting on the active change orders
        // for this entry to retire.  The queue is idled when the entry at the
        // head of the queue hashes to this entry and so may have a conflicting
        // name (hence the name, "name conflict table").
        //
        // The NameConflictTable can give false positives.  But this is okay
        // because a false positive is rare and will only idle the process queue
        // until the active change order retires.  Getting rid of the rare false
        // positives would degrade performance.  The false positives that happen
        // when inserting an entry into the NameConflictTable are handled by
        // using the QData field in the QHashEntry as a the reference count.
        //
        // But, you ask, how can there be multiple active cos hashing to this
        // entry if the process queue is idled when a conflict is detected?
        // Easy, I say, because the filename in the co is used to detect
        // collisions while the filename in the idtable is used to reserve the
        // qhash entry.  Why?  Well, the name morph code handles the case of a
        // co's name colliding with an idtable entry.  But that code wouldn't
        // work if active change orders were constantly changing the idtable.
        // So, the NameConflictTable synchronizes the namespace amoung active
        // change orders so that the name morph code can work against a static
        // namespace.
        //
        if (FlagChk(ISCU_NC_TABLE) &&
            (ChangeOrder->NameConflictHashValue != QUADZERO) &&
            (DOES_CO_REMOVE_FILE_NAME(CoCmd) || DOES_CO_DO_SIMPLE_RENAME(CoCmd))) {

            PQHASH_TABLE Nct = Replica->NameConflictTable;
            //
            // Lock the name conflict table and find the entry for this CO
            //
            QHashAcquireLock(Nct);
            QHashEntry = QHashLookupLock(Nct, &ChangeOrder->NameConflictHashValue);
            //
            // NO ENTRY! ASSERT
            //
            if (QHashEntry == NULL) {
                DPRINT1(0, "++ ERROR - QHashLookupLock(NameConflictTable, %08x %08x) not found.\n",
                        PRINTQUAD(ChangeOrder->NameConflictHashValue));
                FRS_PRINT_TYPE(0, ChangeOrder);
                FRS_ASSERT(!"IssueCleanup: NameConflictTable entry not found");
            } else {
                //
                // If last reference, unblock the process queue if it's blocked
                // and delete the entry.
                //
                if ((--QHashEntry->QData) == QUADZERO) {
                    if (QHashEntry->Flags & ((ULONG_PTR)COE_FLAG_VOL_COLIST_BLOCKED)) {
                        SET_COE_FLAG(ChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);
                    }

                    QHashDeleteLock(Nct, &ChangeOrder->NameConflictHashValue);
                }
                //
                // Unlock the name conflict table and remove the CO reference.
                //
                QHashReleaseLock(Nct);
                ChangeOrder->NameConflictHashValue = QUADZERO;
            }
        }

        //
        //                                               ISCU_CHECK_ISSUE_BLOCK
        // Check the queue blocked flag on the change order.
        // Note - The value for RestartQueue may be overwritten below.
        //
        if (FlagChk(ISCU_CHECK_ISSUE_BLOCK)) {
            RestartQueue = COE_FLAG_ON(ChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);
            if (RestartQueue) {
                CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_VOL_COLIST_BLOCKED);
            }
        }

        //
        //                                                          ISCU_AIBCO
        // Drop the reference above on the Change order and remove the entry
        // in the AIBCO table.
        //
        if (FlagChk(ISCU_AIBCO)) {
            GhtDereferenceEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                         ActiveChangeOrder,
                                         TRUE);

            //
            // Take the change order out of the Active table.
            //
            GhtRemoveEntryByAddress(pVme->ActiveInboundChangeOrderTable,
                                    ActiveChangeOrder,
                                    TRUE);
        }

        //
        //                                                   ISCU_ACTIVE_CHILD
        // Check the parent entry in the ActiveChildren hash table.  If there is
        // a change order pending on the parent and the count of active children
        // has gone to zero then we can restart the queue.
        //

        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_JUST_TOMBSTONE) &&
            (ChangeOrder->ParentFileReferenceNumber == ZERO_FID)) {
            //
            // There is no active child interlock if this was a tombstone
            // create and there was no parent.  Barf.
            //
            ClearFlag(CleanUpFlags, ISCU_ACTIVE_CHILD);
        }


        if (FlagChk(ISCU_ACTIVE_CHILD)) {

            QHashAcquireLock(ActiveChildren);

            BusyParentGuid = &CoCmd->NewParentGuid;
                GuidToStr(BusyParentGuid, BusyParentGuidStr);

            QHashEntry = QHashLookupLock(ActiveChildren, BusyParentGuid);
            if (QHashEntry != NULL) {

                ULONGLONG Count;

                QHashEntry->QData -= 2;
                DPRINT2(4, "++ GAC Dec Count on %s, QData %08x \n",
                        BusyParentGuidStr, QHashEntry->QData);

                PendingCoOnParent = (QHashEntry->QData & 1) != 0;
                Count = QHashEntry->QData >> 1;

                //
                // If the count is zero and there is a blocked pending CO
                // waiting on our parent to be unbusy then unblock the queue.
                // Either way when the count is zero remove the entry from the
                // table.  Also propagate the restart queue flag forward.
                //
                if (Count == 0) {
                    if (!RestartQueue) {
                        RestartQueue = PendingCoOnParent;
                    }
                    QHashDeleteLock(ActiveChildren, BusyParentGuid);
                    DPRINT3(4, "++ GAC - ActiveChild count zero on %s, PendCoOnParent %d, Rq %d\n",
                        BusyParentGuidStr, PendingCoOnParent, RestartQueue);
                } else {
                    DPRINT4(4, "++ GAC - ActiveChild count (%d) not zero on %s, PendCoOnParent %d, Rq %d\n",
                           Count, BusyParentGuidStr, PendingCoOnParent,
                           RestartQueue);
                }

            } else {
                DPRINT1(0, "++ ERROR - GAC - Did not find entry in ActiveChildren Table for %s\n",
                       BusyParentGuidStr);
                FRS_ASSERT(!"Did not find entry in ActiveChildren Table");
            }

            //
            // If this CO has a old parent and a new parent (e.g. MOVE_DIR) then
            // we need to unblock both parents. Check for that and unblock both.
            //

            if (!GUIDS_EQUAL(&CoCmd->NewParentGuid, &CoCmd->OldParentGuid)) {
                BusyParentGuid = &CoCmd->OldParentGuid;
                GuidToStr(BusyParentGuid, BusyParentGuidStr);

                QHashEntry = QHashLookupLock(ActiveChildren, BusyParentGuid);
                if (QHashEntry != NULL) {

                    ULONGLONG Count;

                    QHashEntry->QData -= 2;
                    DPRINT2(4, "++ GAC Dec Count on %s, QData %08x \n",
                            BusyParentGuidStr, QHashEntry->QData);

                    PendingCoOnParent = (QHashEntry->QData & 1) != 0;
                    Count = QHashEntry->QData >> 1;

                    //
                    // If the count is zero and there is a blocked pending CO
                    // waiting on our parent to be unbusy then unblock the queue.
                    // Either way when the count is zero remove the entry from the
                    // table.  Also propagate the restart queue flag forward.
                    //
                    if (Count == 0) {
                        if (!RestartQueue) {
                            RestartQueue = PendingCoOnParent;
                        }
                        QHashDeleteLock(ActiveChildren, BusyParentGuid);
                        DPRINT3(4, "++ GAC - ActiveChild count zero on %s, PendCoOnParent %d, Rq %d\n",
                            BusyParentGuidStr, PendingCoOnParent, RestartQueue);
                    } else {
                        DPRINT4(4, "++ GAC - ActiveChild count (%d) not zero on %s, PendCoOnParent %d, Rq %d\n",
                               Count, BusyParentGuidStr, PendingCoOnParent,
                               RestartQueue);
                    }

                } else {
                    DPRINT1(0, "++ ERROR - GAC - Did not find entry in ActiveChildren Table for %s\n",
                           BusyParentGuidStr);
                    FRS_ASSERT(!"Did not find entry in ActiveChildren Table");
                }
            }
        }


        //
        // Now un-idle change order process queue for this volume and drop the locks.
        //
        if (RestartQueue && (pVme != NULL)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "CO Process Q Unblock");
            FrsRtlUnIdledQueueLock(&pVme->ChangeOrderList);
        }

        if (FlagChk(ISCU_ACTIVE_CHILD)) {
            QHashReleaseLock(ActiveChildren);
        }

        ChgOrdReleaseLockGuid(ChangeOrder);
        FrsRtlReleaseListLock(&FrsVolumeLayerCOList);

    }   // end of  if (FlagChk(ISCU_HOLDIS_CLEANUP))


    if (pVme != NULL) {
        ReleaseVmeRef(pVme);
    }

    //
    // Need the list lock to preserve lock ordering when we unidle the queue.
    // This serializes any insert into outlog and update of inlog.
    // OutlogInserCo overwrites SequenceNumber which can confuse inlog update.
    //
    FrsRtlAcquireListLock(&FrsVolumeLayerCOList);

    ChgOrdAcquireLockGuid(ChangeOrder);

    //
    //                                                   ISCU_DEC_CO_REF
    // Decrement the ref count on the change order.
    // Then use the ref count to gate whether or not to do the mem free ops
    // and delete the inbound log record.
    //
    if (FlagChk(ISCU_DEC_CO_REF)) {
        RefCount = DECREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
    } else {
        RefCount = GET_CHANGE_ORDER_REF_COUNT(ChangeOrder);
    }


    //
    //                                                   ISCU_DEL_INLOG  (1)
    // If this CO has directory enumeration pending then do not delete it
    // from the inbound log.  Instead update the state and flags.
    // The retry thread will later reprocess it to perform the enumeration
    // and perform the final cleanup.
    // The dir enum decision was made by ChgOrdUpdateIDTableRecord() above.
    // Currently this is the only instance of a change order record being
    // recycled for a "second pass" operation.  Once the inlog record state is
    // updated we can notify the INLOG retry thread.
    //
    if ((RefCount == 0) && FlagChk(ISCU_DEL_INLOG) && !FlagChk(ISCU_CO_ABORT)) {

        CHANGE_ORDER_TRACE(3, ChangeOrder, "Checking ENUM Pending");
        if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_DIR_ENUM_PENDING)) {
            ClearFlag(CleanUpFlags, ISCU_DEL_INLOG);
            SetFlag(CleanUpFlags, ISCU_UPDATE_INLOG);

            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ENUM_REQUESTED);
            NotifyRetryThread = TRUE;

            //
            // This CO is now a retry change order.
            //
            SET_CO_FLAG(ChangeOrder, CO_FLAG_RETRY);

            //
            // Prevent deletion of IDTable entry later when we retry.
            //
            CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_NEW_FILE);

            FRS_PRINT_TYPE(3, ChangeOrder);
        }
    }

    //
    //                                                   ISCU_DEL_INLOG  (2)
    // Delete the inbound log record for this CO.  This could happen either on
    // the main retire path if the change order propagates to the outbound log
    // immediately or it could happen later when the propagation is unblocked.
    //
    if ((RefCount == 0) && FlagChk(ISCU_DEL_INLOG)) {

        if (ChangeOrder->RtCtx != NULL) {
            TableCtx = &ChangeOrder->RtCtx->INLOGTable;
            pDataRecord = TableCtx->pDataRecord;
        } else {
            TableCtx = NULL;
            pDataRecord = NULL;
        }

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO INlog Delete");

        //
        // If a retry CO, bump the Inbound retry table seq num so the retry
        // thread can detect a table change when it is re-issuing retry COs.
        //
        if (RetryCo) {
            InterlockedIncrement(&Replica->AIRSequenceNum);
        }

        FStatus = DbsDeleteTableRecordByIndex(ThreadCtx,
                                              Replica,
                                              TableCtx,
                                              &CoCmd->SequenceNumber,
                                              ILSequenceNumberIndexx,
                                              INLOGTablex);

        DPRINT_FS(0,"++ ERROR - DbsDeleteTableRecordByIndex failed.", FStatus);
        if (!FRS_SUCCESS(FStatus)) {
            FRS_PRINT_TYPE(0, ChangeOrder);

            if(FStatus == FrsErrorDbWriteConflict) {

                //
                // We weren't able to Delete the table record,
                // possibly because another thread was processing a duplicate CO
                // at the same time. So let's retry this later.
                //

                DPRINT(0, "ISCU_DEL_INLOG  (2) failed.");
                NotifyRetryThread = TRUE;
            } else {

                //
                // We failed to delete the record for some other reason.
                // ASSERT!!
                //
                FRS_ASSERT(!"ISCU_DEL_INLOG  (2) failed.");

            }
        }

        //
        // The data record for the Inbound Log is the Change Order Command.
        // Make the ptr NULL here so when we free the TableCtx later we don't
        // also try to free the data record.
        //
        if (pDataRecord != NULL) {
            TableCtx->pDataRecord = NULL;
            //
            // Clear the Jet Set/Ret Col address fields for the Change Order
            // Extension buffer to prevent reuse since that buffer goes with the CO.
            //
            DBS_SET_FIELD_ADDRESS(TableCtx, COExtensionx, NULL);
        }
    } else
    //                                                   ISCU_UPDATE_INLOG
    if (FlagChk(ISCU_UPDATE_INLOG)) {
        //
        // If we aren't deleting the inlog record and the request is to update
        // the state fields then do that now.
        //
        // The inbound log table associated with this change order may not
        // be open if this is a retry operation that has been re-issued.
        //

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO INlog Update");
//        FRS_ASSERT(ChangeOrder->RtCtx != NULL)
        if (ChangeOrder->RtCtx == NULL) {
            DPRINT(5, "Using temp inlog tablectx\n");
            InLogTableCtx = &TempTableCtx;
            InLogTableCtx->TableType = TABLE_TYPE_INVALID;
            InLogTableCtx->Tid = JET_tableidNil;
            InLogTableCtx->pDataRecord = NULL;
        } else {
            InLogTableCtx = &ChangeOrder->RtCtx->INLOGTable;
        }

        if (InLogTableCtx->pDataRecord == NULL) {

            jerr = DbsOpenTable(ThreadCtx,
                                InLogTableCtx,
                                Replica->ReplicaNumber,
                                INLOGTablex,
                                CoCmd);
            if (!JET_SUCCESS(jerr)) {
                JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
                FStatus = DbsTranslateJetError(jerr, TRUE);
                FRS_ASSERT(!"ISCU_UPDATE_INLOG - DbsOpenTable failed");
            }
        }

        //
        // Seek to the change order record. Use the SequenceNumber
        // instead of the ChangeOrderGuid because the ChangeOrderGuid
        // is not unique.
        //
        jerr = DbsSeekRecord(ThreadCtx,
                             &CoCmd->SequenceNumber,
                             ILSequenceNumberIndexx,
                             InLogTableCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT1_JS(0, "++ ERROR - DbsSeekRecord on %ws :",
                       Replica->ReplicaName->Name, jerr);
            JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
            FRS_ASSERT(!"ISCU_UPDATE_INLOG - DbsSeekRecord failed");
        }

        //
        // Update the state fields in the inbound log change order record.
        //
        FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                         Replica->ReplicaNumber,
                                         InLogTableCtx,
                                         UpdateInlogState,
                                         ARRAY_SZ(UpdateInlogState));
        DPRINT_FS(0,"++ ERROR - Update of State in Inlog record failed.", FStatus);
        FRS_ASSERT(FRS_SUCCESS(FStatus) || !"ISCU_UPDATE_INLOG: UpdateInlogState failed");

        DPRINT2(4, "++ Updating CO Flags for retry: %08x , CO_IFLAGS %08x \n",
                CoCmd->Flags, CoCmd->IFlags);
        //
        // The data record for the Inbound Log is in the Change Order Command.
        // Make the ptr NULL here so when we free the TableCtx below we don't
        // also try to free the data record.
        //
        InLogTableCtx->pDataRecord = NULL;

        //
        // Close the inlog table.
        //
        DbsCloseTable(jerr, ThreadCtx->JSesid, InLogTableCtx);

        //
        // Clear the Jet Set/Ret Col address fields for the Change Order
        // Extension buffer to prevent reuse since that buffer goes with the CO.
        //
        DBS_SET_FIELD_ADDRESS(InLogTableCtx, COExtensionx, NULL);
    }

    //
    //                                                   ISCU_DEL_RTCTX
    // Free the Replica-Thread context.
    //
    if ((RefCount == 0) && FlagChk(ISCU_DEL_RTCTX)) {
        FStatus = DbsFreeRtCtx(ThreadCtx, Replica, ChangeOrder->RtCtx, TRUE);
        ChangeOrder->RtCtx = NULL;
    }


    //
    //                                                        ISCU_FREE_CO
    // Free the change order and any duplicates.  The active change order
    // serves as the head of the list.
    //
    if ((RefCount == 0) && FlagChk(ISCU_FREE_CO)) {

        //
        // Pull the entry for this CO out of the inlog retry table.
        // If the sequence number is zero then it never went into the Inlog.
        // e.g. A control change order or a rejected change order.
        //
        SeqNum = (ULONGLONG) CoCmd->SequenceNumber;
        if (SeqNum != QUADZERO) {

            //
            // Get the lock on the Active Retry table.
            //
            QHashAcquireLock(Replica->ActiveInlogRetryTable);

            if (QHashLookupLock(Replica->ActiveInlogRetryTable, &SeqNum) != NULL) {
                QHashDeleteLock(Replica->ActiveInlogRetryTable, &SeqNum);
            } else {
                DPRINT1(1, "++ Warning: ActiveInlogRetryTable QHashDelete error on seq num: %08x %08x\n",
                        PRINTQUAD(SeqNum));
            }

            //
            // Bump the sequence number to signal that the state of the
            // Inlog has changed so the retry thread can know to do a re-read
            // of the inlog record if the retry thread is currently active.
            // See ChgOrdRetryWorker().
            //
            InterlockedIncrement(&Replica->AIRSequenceNum);

            QHashReleaseLock(Replica->ActiveInlogRetryTable);
        }

        if (ChangeOrder->Cxtion != NULL) {
            DROP_CO_CXTION_COUNT(Replica, ChangeOrder, ERROR_SUCCESS);
        }
        FRS_ASSERT(ChangeOrder->DupCoList.Next == NULL);

#if 0
        while (ChangeOrder->DupCoList.Next != NULL) {
            Entry = PopEntryList(&ChangeOrder->DupCoList);
            DupChangeOrder = CONTAINING_RECORD(Entry, CHANGE_ORDER_ENTRY, DupCoList);
            //
            // Let the replica subsystem know this change order is done. These
            // change orders were never issued so their Sequence number is OK.
            //
            RcsInboundCommitOk(Replica, DupChangeOrder);
            FrsFreeType(DupChangeOrder);
        }
#endif

        //
        // RELEASE the lock BEFORE freeing the CO.
        //
        ChgOrdReleaseLockGuid(ChangeOrder);
        FrsRtlReleaseListLock(&FrsVolumeLayerCOList);

        FrsFreeType(ChangeOrder);
    } else {
        //
        // RELEASE the lock IF NOT freeing the CO.
        //
        ChgOrdReleaseLockGuid(ChangeOrder);
        FrsRtlReleaseListLock(&FrsVolumeLayerCOList);
    }

    //
    // Tell the Inlog retry thread there is work to do.
    //
    if (NotifyRetryThread) {
        InterlockedIncrement(&Replica->InLogRetryCount);
    }


    return FStatus;
}



ULONG
ChgOrdUpdateIDTableRecord(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder
    )
/*++
Routine Description:

    Update the ID Table record for this change order.  Update the DIR table
    entry as well.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- The Replica ID table to do the lookup in.
    ChangeOrder-- The change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdUpdateIDTableRecord:"


    ULONGLONG             TombstoneLife;

    FRS_ERROR_CODE        FStatus;
    ULONG                 GStatus;
    PREPLICA_THREAD_CTX   RtCtx;
    PTABLE_CTX            IDTableCtx, DIRTableCtx;
    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;
    PIDTABLE_RECORD       IDTableRec;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    ULONG                 Len;
    ULONG                 LocationCmd;
    BOOL                  DeleteCo, NewFile, RemoteCo;
    BOOL                  InsertFlag;


    FRS_ASSERT(Replica != NULL);
    FRS_ASSERT(ChangeOrder != NULL);

    ConfigRecord  = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    //
    // The Replica Thread Ctx in the change order has all the update info.
    //
    RtCtx = ChangeOrder->RtCtx;
    FRS_ASSERT(RtCtx != NULL);

    IDTableCtx    = &RtCtx->IDTable;

    FRS_PRINT_TYPE(4, ChangeOrder);

    IDTableRec = IDTableCtx->pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);

    if (ChangeOrder->FileReferenceNumber == ZERO_FID) {
        //
        // This should not occur.
        //
        FRS_PRINT_TYPE(0, ChangeOrder);
        DBS_DISPLAY_RECORD_SEV(0, IDTableCtx, FALSE);
        FRS_ASSERT(!"ChgOrdUpdateIDTableRecord failed with zero FID");
    }

    //
    // Update the IDTable record from the change order.
    //
    IDTableRec->FileID          = ChangeOrder->FileReferenceNumber;

    IDTableRec->ParentGuid      = CoCmd->NewParentGuid;
    IDTableRec->ParentFileID    = ChangeOrder->NewParentFid;

    IDTableRec->VersionNumber   = CoCmd->FileVersionNumber;
    IDTableRec->EventTime       = CoCmd->EventTime.QuadPart;
    IDTableRec->OriginatorGuid  = CoCmd->OriginatorGuid;
    IDTableRec->OriginatorVSN   = CoCmd->FrsVsn;
    IDTableRec->CurrentFileUsn  = CoCmd->FileUsn;
    IDTableRec->FileCreateTime  = ChangeOrder->FileCreateTime;
    IDTableRec->FileWriteTime   = ChangeOrder->FileWriteTime;
    IDTableRec->FileSize        = CoCmd->FileSize;

    //IDTableRec->FileObjID     =
    Len = (ULONG) CoCmd->FileNameLength;
    CopyMemory(IDTableRec->FileName, CoCmd->FileName, Len);
    IDTableRec->FileName[Len/sizeof(WCHAR)] = UNICODE_NULL;

    IDTableRec->FileIsDir       = CoCmdIsDirectory(CoCmd);
    IDTableRec->FileAttributes  = CoCmd->FileAttributes;

    IDTableRec->ReplEnabled     = TRUE;


    if (!DeleteCo) {

        PDATA_EXTENSION_CHECKSUM CocDataChkSum, IdtDataChkSum;
        PIDTABLE_RECORD_EXTENSION      IdtExt;
        PCHANGE_ORDER_RECORD_EXTENSION CocExt;

        //
        // If the Change Order has a file checksum, save it in the IDTable Record.
        //
        CocExt = CoCmd->Extension;
        CocDataChkSum = DbsDataExtensionFind(CocExt, DataExtend_MD5_CheckSum);

        if (CocDataChkSum != NULL) {
            if (CocDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                        CocDataChkSum->Prefix.Size);
            }

            DPRINT4(4, "NEW COC MD5: %08x %08x %08x %08x\n",
                    *(((ULONG *) &CocDataChkSum->Data[0])),
                    *(((ULONG *) &CocDataChkSum->Data[4])),
                    *(((ULONG *) &CocDataChkSum->Data[8])),
                    *(((ULONG *) &CocDataChkSum->Data[12])));

            //
            // We have a change order data checksum.  Look for
            // a data checksum entry in the IDTable record.
            //
            IdtExt = &IDTableRec->Extension;
            IdtDataChkSum = DbsDataExtensionFind(IdtExt, DataExtend_MD5_CheckSum);

            if (IdtDataChkSum != NULL) {
                if (IdtDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                    DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                            IdtDataChkSum->Prefix.Size);
                }

                DPRINT4(4, "OLD IDT MD5: %08x %08x %08x %08x\n",
                        *(((ULONG *) &IdtDataChkSum->Data[0])),
                        *(((ULONG *) &IdtDataChkSum->Data[4])),
                        *(((ULONG *) &IdtDataChkSum->Data[8])),
                        *(((ULONG *) &IdtDataChkSum->Data[12])));

            } else {
                //
                // Init the extension buffer.
                //
                DPRINT(4, "OLD IDT MD5: Not present\n");
                DbsDataInitIDTableExtension(IdtExt);
                IdtDataChkSum = &IdtExt->DataChecksum;
            }

            //
            // Copy the MD5 checksum into the IDTable Record.
            //
            if (IdtDataChkSum != NULL) {
                CopyMemory(IdtDataChkSum->Data, CocDataChkSum->Data, MD5DIGESTLEN);
            }
        }
    }


    //
    // This CO may have been on a New File.  Always clear the flag here.
    //
    NewFile = IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
    ClearIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);

    if (CO_NEW_FILE(LocationCmd)) {
        //
        // A staging file for the local change order could not be created.
        // We are giving up but we need any following changes to the file
        // to be marked as a "create" so that future updates or renames
        // will create the remote file. Otherwise, the remote side may attempt
        // to "rename" a non-existant file.
        //
        // Note: if this CO is for a dir MOVEIN then the affect of aborting
        // will be to skip the ENUM of the subtree.  Not the best result.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_CREATE_DEFERRED);
        }
        else
        if (!RemoteCo && CO_MOVEIN_FILE(LocationCmd)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "MOVEIN Detected");
            //
            // This is a MOVEIN change order.  If this is a directory then
            // we need to enumerate the directory.  Mark the IDTable entry as
            // ENUM_PENDING. Ditto for the change order.
            //
            if (CoCmdIsDirectory(CoCmd)) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "MOVEIN DIR Detected");
                SetIdRecFlag(IDTableRec, IDREC_FLAGS_ENUM_PENDING);
                SET_CO_IFLAG(ChangeOrder, CO_IFLAG_DIR_ENUM_PENDING);
            }
        }
    }

    //
    // File is still using its temporary name. Rename the file when
    // retiring the next change order for the file. Retry this
    // change order in the interrim.
    //
    if ((!DeleteCo) &&
         COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {
        SetIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
    }

    if (DeleteCo) {
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
            //
            // Remember that we still need to delete this file/dir.
            //
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
        } else {
            //
            // Clear the flag if we don't need to delete this file/dir.
            //
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
        }
        //
        // Mark the file as deleted, clear the FID.
        // Save the time in the TombStone garbage collect field.
        //
        SetIdRecFlag(IDTableRec, IDREC_FLAGS_DELETED);
        TombstoneLife = (ULONGLONG) ConfigRecord->TombstoneLife;  // days
        TombstoneLife = TombstoneLife * (24 * 60 * 60);  // convert to sec.
        TombstoneLife = TombstoneLife * (10*1000*1000);  // convert to 100 ns units.
        TombstoneLife = TombstoneLife + CoCmd->EventTime.QuadPart;
        COPY_TIME(&IDTableRec->TombStoneGC, &TombstoneLife);
    } else
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
        //
        // This file or dir is coming back from the dead.
        //
        ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETED);
        ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
        TombstoneLife = QUADZERO;
        COPY_TIME(&IDTableRec->TombStoneGC, &TombstoneLife);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Reviving IDTable Rec");
    }

    //
    // Update the ID Table record.
    //
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
        DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, FALSE);
        FRS_PRINT_TYPE(3, ChangeOrder);
    } else {
        DBS_DISPLAY_RECORD_SEV(5, IDTableCtx, FALSE);
    }

    FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          IDTableCtx,
                                          &IDTableRec->FileGuid,
                                          GuidIndexx,
                                          IDTablex);
    CLEANUP_FS(0,"++ ERROR - DbsUpdateTableRecordByIndex failed.", FStatus, ERROR_RETURN);

    //
    // Update the volume parent file ID table for:
    //  1. Remote Change Orders that perform either a MOVEDIR or a MOVERS or
    //  2. Local change orders that are generated by a MOVEIN sub-dir operation.
    //
    // Now that the file is installed we could start seeing local COs
    // for it. For remote CO new file creates this update doesn't occur until
    // the rename install of the pre-install file is done. See DbsRenameFid().
    //
    GStatus = GHT_STATUS_SUCCESS;

    if (RemoteCo) {

        if (CO_MOVE_RS_OR_DIR(LocationCmd)) {

            CHANGE_ORDER_TRACE(3, ChangeOrder, "MOVEDIR Par Fid Update");
            GStatus = QHashUpdate(Replica->pVme->ParentFidTable,
                                  &ChangeOrder->FileReferenceNumber,
                                  &IDTableRec->ParentFileID,
                                  Replica->ReplicaNumber);
        }
    } else {
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_MOVEIN_GEN)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "MOVEIN Par Fid Update");
            GStatus = QHashUpdate(Replica->pVme->ParentFidTable,
                                  &ChangeOrder->FileReferenceNumber,
                                  &IDTableRec->ParentFileID,
                                  Replica->ReplicaNumber);
        }
    }

    if (GStatus != GHT_STATUS_SUCCESS ) {
        DPRINT1(0, "++ WARNING - QHashUpdate on parent FID table status: %d\n", GStatus);
    }

    //
    // Update the DIR Table record.
    //
    // Currently at startup the Journal parent filter table is constructed
    // from the DIRTable.  If we were to crash between the update of the IDTable
    // above and the update below it is possible that the change order retry
    // at the next startup could fail to correct this problem.  This would leave
    // a missing dir entry in the Journal Filter table.
    // This problem should get fixed as part of the support for a guest
    // FRS member since the content of the dir tree will be sparse.
    //
    if (CoCmdIsDirectory(CoCmd)) {
        DIRTableCtx = &RtCtx->DIRTable;

        //
        // Insert or update the DIR table and the journal filter table.
        //
        if (!DeleteCo) {
            FStatus = ChgOrdInsertDirRecord(ThreadCtx,
                                            DIRTableCtx,
                                            IDTableRec,
                                            ChangeOrder,
                                            Replica,
                                            FALSE);
            //
            // DirTable entry may not exist if this is a reanimation
            // CO. For all other COs it should exist.
            //
            if ((FStatus == FrsErrorNotFound) && 
                COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {

                FStatus = ChgOrdInsertDirRecord(ThreadCtx,
                                                DIRTableCtx,
                                                IDTableRec,
                                                ChangeOrder,
                                                Replica,
                                                TRUE);
            }

            CLEANUP_FS(0,"++ ERROR - ChgOrdInsertDirRecord failed.", FStatus, ERROR_RETURN);
        } else if (!IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {

            DPRINT(4, "++ Deleting the DirTable entry -----------\n");
            //
            // Note: We don't have to update the Volume Filter Table here
            // because that was handled by the journal code when the
            // delete change order was processed for the directory.  Even if
            // this was a remote co where we issue the directory delete we still
            // see an NTFS journal close record because the file isn't deleted
            // until the last handle is closed.  Our attempt to filter that
            // USN record fails so the delete CO is processed by the journal
            // code and later discarded by change order accept.
            //
            FStatus = DbsDeleteDIRTableRecord(ThreadCtx,
                                              Replica,
                                              DIRTableCtx,
                                              &IDTableRec->FileGuid);
            //
            // If this update is on a new file entry there won't be a DirTable entry.
            // e.g. A Dir delete arrives before the create and we just create
            // a tombstone.
            //
            if (!FRS_SUCCESS(FStatus) && !NewFile) {
                DPRINT_FS(0,"++ ERROR - DbsDeleteTableRecordByIndex failed.", FStatus);
                //
                // Note: if we crashed in the middle of a retire the record
                // would not be there.  See comment above re: making the whole
                // retire a single transaction.
            }
        }
    }

    FStatus = FrsErrorSuccess;

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        Replica->FStatus = FStatus;  // note: not thread safe
    }

    return FStatus;
}


ULONG
ChgOrdReadIDRecordNewFile(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PTABLE_CTX            IDTableCtxNC,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  *IDTableRecExists
    )
/*++
Routine Description:

    Create an IDTable entry for a new file.  Also called when the flag
    IDREC_FLAGS_NEW_FILE_IN_PROGRESS is set to perform some re-init.

    This is for the change order from the replica set
    specified by the ReplicaNumber.  If there is no ID Table record for
    this file and the location operation is a create or a movein then
    open the file and get or set the object ID on the file. In the case
    of no ID Table record we init one here, all except a few fields for
    remote change orders.

    The volume monitor entry in the Replica struct provides the volume
    handle for the open.  On return the IDTable is closed.

    If this turns out to be a new file or a reanimation of an old file then
    IDTableCtxNC is used to do an ID Table lookup on the Parent Guid/Name
    Index to check for a potential name conflict.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtx -- The table context containing the ID Table record.
    IDTableCtxNC -- The table context containing the ID Table record for the Name Conflict.
    ChangeOrder-- The change order.
    Replica    -- The Replica ID table to do the lookup in.
    IDTableRecExists - Set to TRUE if the idtable record exists. The
                       caller then knows that the idtable entry shouldn't
                       be inserted.

Return Value:

    Frs Status

    FrsErrorSuccess - IDTable record was found. Data returned.

    FrsErrorNotFound - IDTable record was not found so treat as new file.

    FrsErrorNameMorphConflict - This is like FrsErrorNotFound, i.e. it is
                       a create or reanimate (i.e. tombstone
                       found) but there is a parent guid/name conflict with
                       another entry in the IDTable.  Check for a Tunneled
                       Object ID to see if this is a bogus conflict.

    FrsErrorTunnelConflict - OID got tunneled so this is really like FrsErrorSuccess
                       except the ChgOrdAccept code needs to restart the processing
                       of this CO so the proper HoldIssue interlock checks get made.

    For other error status return codes see description for ChgOrdReadIDRecord().

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdReadIDRecordNewFile:"

    JET_ERR         jerr;
    DWORD           WStatus;
    ULONG           FStatus, Status, FStatus2;
    ULONG           LocationCmd;
    ULONG           ReplicaNumber;
    HANDLE          FileHandle;
    BOOL            MorphGenCo, ExistingOid;
    BOOL            LocalCo;
    PIDTABLE_RECORD IDTableRec;
    PCHANGE_ORDER_COMMAND CoCmd;


    ////////////////////////////////////////////////////////////////////////////
    //                                                                        //
    // IDTable record not found.  See if change order is a create or a Movein.//
    //                                                                        //
    ////////////////////////////////////////////////////////////////////////////


    ReplicaNumber = Replica->ReplicaNumber;
    CoCmd = &ChangeOrder->Cmd;
    LocalCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    MorphGenCo  = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

    FStatus = FrsErrorNotFound;

    IDTableRec = IDTableCtx->pDataRecord;

    if (CO_NEW_FILE(LocationCmd)) {

        //
        // New file create.  Check if name conflict would occur.
        //
        FStatus = ChgOrdCheckNameMorphConflict(ThreadCtx,
                                               IDTableCtxNC,
                                               ReplicaNumber,
                                               ChangeOrder);

        if (FStatus == FrsErrorNameMorphConflict) {
            DPRINT(0,"++ NM: Possible Name Morph Conflict on new file\n");
            DBS_DISPLAY_RECORD_SEV(4, IDTableCtxNC, TRUE);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Poss Morph Conflict - cre");
        } else

        if (FRS_SUCCESS(FStatus)) {
            //
            // Return not found so caller will treat the CO as a new file.
            //
            FStatus = FrsErrorNotFound;

        } else {
            DPRINT_FS(0,"++ NM: WARNING - Unexpected result from ChgOrdCheckNameMorphConflict.", FStatus);
            return FStatus;
        }
    } else

    if ((!LocalCo || MorphGenCo) &&
          ((LocationCmd == CO_LOCATION_DELETE) ||
           (LocationCmd == CO_LOCATION_MOVEOUT))) {
        //
        // Return not found for remote (or name morph gened) co deletes so
        // the tombstone gets created.  Needed to make name morphing work.
        // Load a fake value for the File ID since this is an IDTable
        // index and there is no actual file.  In the case of a local Co that
        // generates a name conflict we will use its FID.
        //
        if (ChangeOrder->FileReferenceNumber == ZERO_FID) {
           FrsInterlockedIncrement64(ChangeOrder->FileReferenceNumber,
                                     GlobSeqNum,
                                     &GlobSeqNumLock);
        }

        IDTableRec->FileID = ChangeOrder->FileReferenceNumber;

        FStatus = FrsErrorNotFound;

    } else

    if (!LocalCo && (LocationCmd == CO_LOCATION_MOVEDIR)) {
        //
        // MOVERS: need to handle MOVERS too when that code is implemented
        //
        // A MoveDir can show up if a file is created before we VVJoin with
        // an inbound partner and then during the VVJoin a MoveDir is done
        // on the file.  The MoveDir on the file causes the VVJoin scan to
        // skip over the file since it knows the MoveDir CO will get sent
        // when we rescan the outlog.  So in this case we see the MoveDir
        // but we have not seen the original create for the file.
        // Since we can't be sure, treat it as a create and be happy.
        // BTW: It should be marked as an out of order CO.
        //
        SET_CO_LOCATION_CMD(*CoCmd, Command, CO_LOCATION_CREATE);
        LocationCmd = CO_LOCATION_CREATE;
        SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
        SetFlag(CoCmd->ContentCmd, USN_REASON_FILE_CREATE);
        FStatus = FrsErrorNotFound;
    } else

    if (LocalCo && (LocationCmd == CO_LOCATION_MOVEDIR)) {
        //
        // We come here in the case of a local Co that is a movedir.
        // In the case of the following sequence where the object ID arrived
        // on the new file (i.e. NEW FID) via the tunnel cache and the tunnel
        // cache hit was triggered by a MOVEDIR on the file then we need
        // to handle this by calling ChgOrdCheckAndFixTunnelConflict() later on.
        // The sequence is:
        //
        // A. create  \BankFile\1000013106\100000497\1597.TXT
        //
        // B. delete  \BankFile\1000013106\100001385\1613.TXT
        //
        // C. rename  \BankFile\1000013106\100000497\1597.TXT  TO
        //            \BankFile\1000013106\100001385\1613.TXT
        //
        // By the time we process CO-A the OID tunneling from 1613 to 1597 will
        // already be complete (aging cache delay).  So CO-A is rejected because
        // of a tunneling conflict.  CO-B is processed as usual.  CO-C is then
        // treated as a movedir so we are here.  It renames the file across
        // parent dirs.
        //
        FStatus = FrsErrorNotFound;

    } else

    if (LocationCmd == CO_LOCATION_NO_CMD) {
        //
        // An update CO could arrive out of order relative to its create
        // if the create got delayed by a sharing violation.  We don't
        // want to lose the update so we make it look like a create.
        // This also handles the case of delete change orders generated
        // by name morph conflicts in which a rename arrives for a
        // nonexistent file.  Also above MOVEDIR example applies regarding
        // Update during a VVJoin.
        //

        //
        //    if (!LocalCo &&
        //        (LocationCmd == CO_LOCATION_NO_CMD) &&
        //        BooleanFlagOn(CoCmd->ContentCmd, USN_REASON_RENAME_NEW_NAME)) {
        //
        // Looks like a bare rename.  Probably originated as a MorphGenCo
        // so turn it into a create.
        //
        SET_CO_LOCATION_CMD(*CoCmd, Command, CO_LOCATION_CREATE);
        LocationCmd = CO_LOCATION_CREATE;
        SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
        SetFlag(CoCmd->ContentCmd, USN_REASON_FILE_CREATE);
        FStatus = FrsErrorNotFound;

    } else {
        //
        // The IDTable entry is deleted if a file disappears early in the
        // change order processing.  The change order for the delete is then
        // rejected by returning an error from this function.
        //
        FStatus = FrsErrorInvalidChangeOrder;

        if (LocationCmd != CO_LOCATION_DELETE &&
            LocationCmd != CO_LOCATION_MOVEOUT) {
            DPRINT(0, "++ WARN - IDTable record not found and Location cmd not create or movein\n");
            FRS_PRINT_TYPE(1, ChangeOrder);
        }
        return FStatus;
    }

    //
    // FStatus is either FrsErrorNameMorphConflict or FrsErrorNotFound
    // at this point.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, IDTableCtx);
    //
    // New fILE.  Initialize an IDTable Entry for it.
    // Caller will decide if IDTable gets updated.
    //
    ExistingOid = PreserveFileOID;
    WStatus = DbsInitializeIDTableRecord(IDTableCtx,
                                         NULL,
                                         Replica,
                                         ChangeOrder,
                                         CoCmd->FileName,
                                         &ExistingOid);
    if (LocalCo) {
        //
        // Get the File's current USN so we can check for consistency later
        // when the change order is about to be sent to an outbound partner.
        // Put the FileGuid for the new local file in the change order.
        //
        CoCmd->FileUsn = IDTableRec->CurrentFileUsn;
        CoCmd->FileGuid = IDTableRec->FileGuid;
        //
        // Return the FileSize in the Local Change order.
        //
        CoCmd->FileSize = IDTableRec->FileSize;
    } else {
        //
        // For remote change order, set the Parent FID from the NewParent Fid.
        //
        ChangeOrder->ParentFileReferenceNumber = ChangeOrder->NewParentFid;
    }

    //
    // The file was deleted before we could get to it; ignore change order
    //
    if (WIN_NOT_FOUND(WStatus)) {
      //  FStatus = FrsErrorInvalidChangeOrder;

    SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_DELETE);
        return FStatus;
    }


    if (ExistingOid && WIN_SUCCESS(WStatus)) {
        FStatus2 = ChgOrdCheckAndFixTunnelConflict(ThreadCtx,
                                                   IDTableCtx,
                                                   IDTableCtxNC,
                                                   Replica,
                                                   ChangeOrder,
                                                   IDTableRecExists);
        if (FStatus2 == FrsErrorTunnelConflict) {
            //
            // If the OID got tunneled to this new file then any Name Morph
            // conflict detected above is bogus.
            //
            if (FStatus == FrsErrorNameMorphConflict) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "No Morph Conflict - Tunnel");
            }
            return FrsErrorTunnelConflict;

        } else

        if (FStatus2 != FrsErrorSuccess) {
            FStatus = FStatus2;
            return FStatus;
        }
    }

    if (WIN_SUCCESS(WStatus)) {
        //
        // Initialize the JetSet/RetCol arrays and data record buffer
        // addresses to read and write the fields of the data record.
        //
        DbsSetJetColSize(IDTableCtx);
        DbsSetJetColAddr(IDTableCtx);

        //
        // Update the JetSet/RetCol arrays for variable len fields.
        //
        Status = DbsAllocRecordStorage(IDTableCtx);
        if (!NT_SUCCESS(Status)) {
            DPRINT_NT(0, "++ ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
            return FrsErrorResource;
        }

        //
        // FStatus is either FrsErrorNameMorphConflict
        //                or FrsErrorNotFound
        //                or FrsErrorTunnelConflict
        //
        // Set new file flag so a crashed CO can restart correctly.
        // If we crash and later the creating change order gets rejected
        // when reprocessed at recovery this flag is used by the tombstone
        // delete code to clean out the IDTable entry.  A corrected tunnel
        // conflict means the file already exists so don't set new file flag.
        //
        if (FStatus != FrsErrorTunnelConflict) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
        }

        return FStatus;
    }

    //
    // Couldn't construct the entry.  Probably a local change order and we
    // couldn't open the file to get the required info or set the object ID.
    //
    FStatus = FrsErrorAccess;
    return FStatus;
}

ULONG
ChgOrdReadIDRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PTABLE_CTX            IDTableCtxNC,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  *IDTableRecExists
    )
/*++
Routine Description:

    Read the ID Table record for this change order from the replica set
    specified by the ReplicaNumber.  If there is no ID Table record for
    this file and the location operation is a create or a movein then
    open the file and get or set the object ID on the file. In the case
    of no ID Table record we init one here, all except a few fields for
    remote change orders.

    The volume monitor entry in the Replica struct provides the volume
    handle for the open.  On return the IDTable is closed.

    If this turns out to be a new file or a reanimation of an old file then
    IDTableCtxNC is used to do an ID Table lookup on the Parent Guid/Name
    Index to check for a potential name conflict.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtx -- The table context containing the ID Table record.
    IDTableCtxNC -- The table context containing the ID Table record for the Name Conflict.
    ChangeOrder-- The change order.
    Replica    -- The Replica ID table to do the lookup in.
    IDTableRecExists - Set to TRUE if the idtable record exists. The
                       caller then knows that the idtable entry shouldn't
                       be inserted.
                       David, please review -- should the idtable entry be updated in this
                                               case?

Return Value:

    Frs Status

    FrsErrorSuccess - IDTable record was found. Data returned.

    FrsErrorInvalidChangeOrder - IDTable record not found and the change order
                                 is not a create or movein.

    FrsErrorNotFound - IDTable record was not found but this is a create
                       or movein change order so we constructed what we could
                       based on whether the CO is local or remote.

    FrsErrorNameMorphConflict - This is like FrsErrorNotFound, i.e. it is
                       a create or reanimate (i.e. tombstone
                       found) but there is a parent guid/name conflict with
                       another entry in the IDTable.  Data for this conflicting
                       entry is returned in IDTableCtxNC.

                       Note: This can also be returned in the event of a
                       reanimation or a rename with a conflict on the target.

    FrsErrorTunnelConflict - OID got tunneled so this is really like FrsErrorSuccess
                       except the ChgOrdAccept code needs to restart the processing
                       of this CO so the proper HoldIssue interlock checks get made.


    Any other error is a failure.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdReadIDRecord:"


    USN      CurrentFileUsn;
    ULONGLONG CurrParentFid;
    FILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo;

    JET_ERR         jerr, jerr1;
    DWORD           WStatus, WStatus1;
    ULONG           FStatus, Status, GStatus, FStatus2;
    ULONG           LocationCmd;
    PVOID           pKey;
    PVOID           KeyArray[2];
    ULONG           IndexCode;
    ULONG           ReplicaNumber;
    HANDLE          FileHandle;
    LONG            RStatus;
    BOOL            MorphGenCo, RetryCo, ExistingOid;

    PIDTABLE_RECORD       IDTableRec;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PCHANGE_ORDER_COMMAND CoCmd;

    BOOL LocalCo;


    ReplicaNumber = Replica->ReplicaNumber;
    CoCmd = &ChangeOrder->Cmd;
    LocalCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    *IDTableRecExists = FALSE;

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    MorphGenCo  = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);
    RetryCo  =  BooleanFlagOn(CoCmd->Flags, CO_FLAG_RETRY);

    //
    // Read the IDTable Record for this file.  If a local ChangeOrder then
    // do the lookup by FID and if remote do it by Guid.
    // Insert the GUIDs for originator, File, Old and new parent.
    //
    jerr = DbsOpenTable(ThreadCtx, IDTableCtx, ReplicaNumber, IDTablex, NULL);
    CLEANUP_JS(0, "IDTable open failed.", jerr, RETURN_JERR);

    if (!LocalCo || MorphGenCo) {
        pKey = (PVOID)&CoCmd->FileGuid;
        IndexCode = GuidIndexx;
    } else {
        pKey = (PVOID)&ChangeOrder->FileReferenceNumber;
        IndexCode = FileIDIndexx;
    }


    jerr = DbsReadRecord(ThreadCtx, pKey, IndexCode, IDTableCtx);

    //
    // If no record there then we have a new object, file/dir.
    //
    if (jerr == JET_errRecordNotFound) {
        FStatus = ChgOrdReadIDRecordNewFile(ThreadCtx,
                                            IDTableCtx,
                                            IDTableCtxNC,
                                            ChangeOrder,
                                            Replica,
                                            IDTableRecExists);

        if ((FStatus == FrsErrorNotFound) ||
            //
            // For tunnel conflict, Fid to Guid xlate is now updated, start over.
            //
            (FStatus == FrsErrorTunnelConflict) ||
            (FStatus == FrsErrorNameMorphConflict)) {
            return FStatus;
        }

        goto RETURN_ERROR;
    }
    *IDTableRecExists = TRUE;

    //
    // Bail if some error other than record not found.
    //
    CLEANUP_JS(4, "IDTable record not found.", jerr, RETURN_JERR);


    //
    // We found the record in the table.  Fill in the remaining local
    // fields in the change order entry from the IDTable entry
    // if this is a Remote Change Order.
    //
    IDTableRec = IDTableCtx->pDataRecord;

    //
    // Reflect state of IDREC_FLAGS_DELETE_DEFERRED in the change order.
    // See related comment below on IDREC_FLAGS_RENAME_DEFERRED.
    //
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {
        SET_COE_FLAG(ChangeOrder, COE_FLAG_NEED_DELETE);
        // SUDARC-DEV - Comment out this part so that we preserve the flags in the idtable
        // record.
        // ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "IDREC_FLAGS_DELETE_DEFERRED set");
    }

    //
    // If the IDREC_FLAGS_NEW_FILE_IN_PROGRESS flag is set then this or some
    // other CO did not finish.  There are a few ways in which this could happen.
    //
    // 1. A local or remote CO was issued and the IDTable record created but
    // the system crashed before the issued CO went thru retire or retry paths
    // to clear the NEW_FILE_IN_PROGRESS Flag.
    //
    // 2. A remote CO that fails to fetch the file (e.g. cxtion unjoins) will
    // go thru the retry path in the IBCO_FETCH_RETRY state.  This leaves the
    // NEW_FILE_IN_PROGRESS Flag set because another remote CO from a different
    // inbound partner could arrive and it should be treated as a new file
    // by reconcile (since the first inbound partner may never reconnect).
    //
    // 3. A local CO gets thru the retry path in the IBCO_STAGING_RETRY state
    // because a sharing violation has prevented us from opening the file to
    // generate the staging file.  We may be giving up for now or we may be
    // shutting down.  Either way the Local CO is in the inbound log so the
    // journal commit point has advanced past the USN record that gave rise
    // to the CO.  On journal restart we will not process that USN record again.
    // But the CO saved in the inbound log does NOT have the file ID for the
    // file.  This is kept in the IDTable record and used in the Guid to Fid
    // translation to reconstruct the FID.  Actually this case is really the
    // local CO varient of case 1 since, for local COs in the staging retry
    // state, the retry path will set the IDREC_FLAGS_CREATE_DEFERRED flag
    // in the IDTable record and clear the IDREC_FLAGS_NEW_FILE_IN_PROGRESS bit.
    //
    // 4. A remote CO on a new-file-create fails to install because of a disk
    // full condition.  The initial ID table contents will have matching version
    // info so on retry the CO is rejected for sameness.  The NEW_FILE_IN_PROGRESS
    // flag ensures that the CO gets accepted.
    //
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS)) {

        CHANGE_ORDER_TRACE(3, ChangeOrder, "IDREC_FLAGS_NEW_FILE_IN_PROGRESS");
        DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, TRUE);
        FRS_PRINT_TYPE(3, ChangeOrder);

        //
        // If the CO came from the INlog as a recovery CO then we did a Guid
        // to FID translation earlier so the FID should be valid.
        // If this is a remote CO then a new pre-install file may need to
        // be created if startup recovery removed it.
        //
        // Even though IDREC_FLAGS_NEW_FILE_IN_PROGRESS is set we still need
        // to check for the presence of the pre-install file.
        // The scenario is:
        // If a remote CO arrives and creates a pre-install file but we crash
        // before writing the INLOG record (say the disk was full) then when we
        // restart the preinstall file cleanup code will delete the preinstall
        // file since there is no change order for it in the inlog.  Later when
        // the upstream partner re-sends the CO we end up here with a FID in the
        // IDTable for a deleted file.  If we don't check for it then the CO
        // will fetch the staging file but will then fail to install the CO
        // because the pre-install file is gone.  The CO will then enter an
        // install retry loop.
        //
        if (!LocalCo && (IDTableRec->FileID != ZERO_FID)) {
            FileHandle = INVALID_HANDLE_VALUE;
            WStatus = FrsOpenSourceFileById(&FileHandle,
                                            &FileNetworkOpenInfo,
                                            NULL,
                                            Replica->pVme->VolumeHandle,
                                            &IDTableRec->FileID,
                                            FILE_ID_LENGTH,
//                                            READ_ACCESS,
                                            READ_ATTRIB_ACCESS,
                                            ID_OPTIONS,
                                            SHARE_ALL,
                                            FILE_OPEN);
            if (WIN_SUCCESS(WStatus) &&
                WIN_SUCCESS(FrsReadFileParentFid(FileHandle, &CurrParentFid)) &&
                (CurrParentFid == Replica->PreInstallFid)) {

                NOTHING;
            } else {
                //
                // Either can't access the file or it's not in pre-install dir
                //
                CHANGE_ORDER_TRACEX(3, ChangeOrder, "Force create of new Pre-Install file", WStatus);
                IDTableRec->FileID = ZERO_FID;
                ChangeOrder->FileReferenceNumber = ZERO_FID;
            }

            FRS_CLOSE(FileHandle);
        }

        //
        // Treat this CO like a new file.
        //
        FStatus = ChgOrdReadIDRecordNewFile(ThreadCtx,
                                            IDTableCtx,
                                            IDTableCtxNC,
                                            ChangeOrder,
                                            Replica,
                                            IDTableRecExists);



        if ((FStatus == FrsErrorNotFound) ||
            //
            // For tunnel conflict, Fid to Guid xlate is now updated, start over.
            //
            (FStatus == FrsErrorTunnelConflict) ||
            (FStatus == FrsErrorNameMorphConflict)) {
            return FStatus;
        }

        goto RETURN_ERROR;
    }

    DbsCloseTable(jerr, ThreadCtx->JSesid, IDTableCtx);


    //
    // If the IDTable record is marked deleted and
    //    o the incoming CO is a delete or a moveout then continue processing
    //      the delete CO because the event time / version info may be more
    //      recent then what we already have recorded in our IDTable entry.
    //      This is necessary because of the following case.  Consider three
    //      members A, B and C (all disconnected at the moment).  At time T=0
    //      MA deletes file foo,  At time T=5 MB updates file foo, and at time
    //      T=10 MC deletes file foo.  Depending on the topology and therefor
    //      the order of arrival of the COs from A, B and C a given machine
    //      could decide to reanimate foo if we didn't process the second delete
    //      CO.  E.G. if the arrival order was CoA, CoC, CoB  foo would get
    //      reanimated because we ignored Coc.  If the arrival order was Coc,
    //      CoA, CoB we would not reanimate foo since the event time on CoC is
    //      more recent that the time on CoB.  Therefore send the delete COs
    //      on to reconcile to decide.
    //
    //    o this CO is an update, rename, ... then transform it into a Create
    //      so the file can come back.
    //
    // Make the IDTable record FID zero here rather than using zero for all
    // deleted entries which would create a duplicate key in the DB and make
    // the index less balanced.
    //
    // Depending on the execution timing of local and remote COs where
    // one is a delete another could well be pending while the delete
    // is being performed.  Reconcile will decide if we reanimate the file.
    //
    // Skip this test if this is a Morph Generated CO because of the following:
    //
    // 1. A remote co for an update comes in for a tombstoned idtable entry.
    //
    // 2. The remote co becomes a reanimate co.
    //
    // 3. The reanimate remote co loses a name conflict to another idtable entry.
    //
    // 4. A MorphGenCo for a local delete is generated for the
    //    reanimate remote co that lost the name conflict.
    //
    // 5. The MorphGenCo is skipped here because the idtable entry is
    //    tombstoned. The service returns to step 1.
    //
    // The fix is to allow MorphGenCo's to proceed even if the idtable
    // entry is deleted. The delete will end up being a NOP (file doesn't
    // exist) but will then be sent out to the partners to insure
    // consistency amoung the members.
    //
    if (!MorphGenCo && IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)
        && !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED)) {

        if ((LocationCmd == CO_LOCATION_DELETE) ||
            (LocationCmd == CO_LOCATION_MOVEOUT)) {

            if (LocalCo && (IDTableRec->EventTime != CoCmd->EventTime.QuadPart)) {
                //
                // Swat down this CO if it is local and the eventtime in the idtable
                // is not the same as the event time in the CoCmd.
                // We do this because if
                // a remote CO delete comes in with a very old event time we
                // update the event time in the IDTable record with the old time.
                // Now when the delete is installed we generate a very recent
                // USN record.  If we let this local delete get to reconcile it
                // will accept it based on the event time difference.  But this
                // local delete was generated by us processing a remote co delete
                // and now we are going to propagate it down stream.
                // Once change order backlogs form this can result in a cascade
                // effect until the backlogs dissapate.  Note that backlogs
                // could form at either outbound or inbound logs but the effect
                // is the same even though the specific scenario is different.
                //
                // If we get a valid local delete and update the idtable but crash
                // before we write it to the outlog. Then when we come back and process
                // the local delete from the inlog we do not want to skip it. Hence we
                // don't skip the local delete if the event times match.
                //
                FStatus = FrsErrorInvalidChangeOrder;
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Lcl Del Co rcvd on deleted file -- Skipping");
                return FStatus;
            }
            if (LocalCo) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Lcl Del Co rcvd on deleted file");
            } else {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Rmt Del Co rcvd on deleted file");
            }
            FStatus = FrsErrorSuccess;
            return FStatus;
        }

        FStatus = FrsErrorSuccess;

        if (!LocalCo) {
            //
            // If the FID is non-zero in the IDTable then check if it is valid.
            // If this is a retry fetch CO for a reanimate then the pre-install
            // file was already created the first time around so it should be
            // there.  This could also be a recovery CO if we crashed after
            // updating the FID but before the CO was marked as retry in the
            // INLOG.  This could also be a dup CO that arrived after a previous
            // CO started the reanimation but went into fetch retry cuz the
            // connection failed.  So we can't condition this check on the
            // retry or recovery flags in the CO.  The only way we can know is
            // to try to open the FID and see if the file is there.
            //
            if (IDTableRec->FileID != ZERO_FID) {
                FileHandle = INVALID_HANDLE_VALUE;
                WStatus = FrsOpenSourceFileById(&FileHandle,
                                                &FileNetworkOpenInfo,
                                                NULL,
                                                Replica->pVme->VolumeHandle,
                                                &IDTableRec->FileID,
                                                FILE_ID_LENGTH,
//                                                READ_ACCESS,
                                                READ_ATTRIB_ACCESS,
                                                ID_OPTIONS,
                                                SHARE_ALL,
                                                FILE_OPEN);
                if (WIN_SUCCESS(WStatus) &&
                    WIN_SUCCESS(FrsReadFileParentFid(FileHandle, &CurrParentFid)) &&
                    (CurrParentFid == Replica->PreInstallFid)) {

                    NOTHING;
                } else {
                    //
                    // Either can't access the file or it's not in pre-install dir
                    //
                    CHANGE_ORDER_TRACEX(3, ChangeOrder, "Force create of new Pre-Install file", WStatus);
                    IDTableRec->FileID = ZERO_FID;
                    ChangeOrder->FileReferenceNumber = ZERO_FID;
                }

                FRS_CLOSE(FileHandle);
            }

            //
            // Not a delete CO.  Check if name conflict would occur
            // if reanimation took place.  Caller will decide if this
            // CO is actually rejected or not before any name morph
            // change orders are created.
            //
            FStatus = ChgOrdCheckNameMorphConflict(ThreadCtx,
                                                   IDTableCtxNC,
                                                   ReplicaNumber,
                                                   ChangeOrder);

            if (FStatus == FrsErrorNameMorphConflict) {
                DPRINT(0,"++ NM: Possible Name Morph Conflict - reanimate\n");
                DBS_DISPLAY_RECORD_SEV(4, IDTableCtxNC, TRUE);
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Poss Morph Conflict - reani");
            } else {
                CLEANUP_FS(0,"++ NM: WARNING - Unexpected result from ChgOrdCheckNameMorphConflict.",
                           FStatus, RETURN_ERROR);
            }

        } else {
            //
            // LOCAL CO.
            // Tombstoned IDTable entry hit on Non-MorphGen Local Change Order.
            // Update FileUsn to the USN of the most recent USN record that
            // we've seen.  This is probably a MOVEIN local CO.
            //
            CoCmd->FileUsn = CoCmd->JrnlUsn;

            if (!RetryCo) {
                //
                // Bump Version number to ensure the CO is accepted if this is
                // the first time we have seen this Local Co.
                //
                CoCmd->FileVersionNumber = IDTableRec->VersionNumber + 1;
            }
        }

        CHANGE_ORDER_TRACE(3, ChangeOrder, "Co Possible Reanimate");
        FRS_PRINT_TYPE(3, ChangeOrder);

        //
        // Done if this is a Tombstone Reanimation.
        //
        return FStatus;
    }


    ////////////////////////////////////////////////////////////////////////////
    //                                                                        //
    // IDTable record found and not marked deleted.                           //
    //                                                                        //
    ////////////////////////////////////////////////////////////////////////////

    FStatus = FrsErrorSuccess;

    if (!LocalCo || MorphGenCo) {

        //
        // Handle Remote Co
        //
        ChangeOrder->FileReferenceNumber = IDTableRec->FileID;

        //
        // Check and update the state of the parent fid.
        //
        if (ChangeOrder->ParentFileReferenceNumber !=
            (ULONGLONG) IDTableRec->ParentFileID) {

            if (CO_MOVE_OUT_RS_OR_DIR(LocationCmd)) {
                //
                // Expected current location of file is in IDTable.
                //
                ChangeOrder->ParentFileReferenceNumber = IDTableRec->ParentFileID;

            } else {
                //
                // If this CO has requested its parent to be reanimated then
                // the Guid to Fid translation done earlier now has the current
                // (and correct) parent FID for this file.  Update the IDTable
                // entry to reflect the change in parent FID.  This can happen
                // if a local file op deletes the parent while create for a
                // child is in process.  when the Child create tries to do the
                // final rename it will fail since the parent is now gone.  This
                // sends it thru retry in the IBCO_INSTALL_REN_RETRY state.
                // Later the local delete is processed and the parent is marked
                // as deleted.  When the remote CO for the child is retried
                // it reanimates the parent but the IDTable entry that was
                // originally created for the child still has the File ID for
                // the old parent.
                //
                if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_RISE_REQ)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "WARN - Unexpected mismatch in parent FIDs");
                    DBS_DISPLAY_RECORD_SEV(3, IDTableCtx, TRUE);
                    FRS_PRINT_TYPE(3, ChangeOrder);

                    //
                    // This condition may not be an error because we could get
                    // the above case (rmt child create with concurrent parent
                    // local delete) where the rmt child create is followed by
                    // the local Del and then immediately by a 2nd rmt file
                    // update.  The first rmt CO will go thru install and then
                    // go to retry on the final rename.  The local delete is
                    // processed for the parent.  Then the 2nd rmt co finds the
                    // IDTable for the parent is marked as deleted and so it
                    // reanimates the parent.  It then finds the IDTable entry
                    // for the target file (created by the first rmt CO) with
                    // the IDREC_FLAGS_RENAME_DEFERRED bit set and the stale
                    // value for the parent FID created by the first rmt co.
                    // So the parent FIDs will again be mismatched but the 2nd
                    // remote CO is not any kind of a retry CO.
                    //
                    // A simpler scenario is a local rename (MOVDIR) happening at the
                    // same time as a remote update.  If the rename is processed
                    // first then the parent FID in the IDTable is updated to
                    // the new parent.  When the remote CO arrives its parent
                    // GUID is for the old parent which is translated to the
                    // old parent FID in the change order.
                    //
                    // What all this means is that if the parent FIDs don't
                    // match and this is not some flavor of a directory MOVE
                    // then the GUID to FID XLATE done on the CO before we
                    // get here has the correct value for the parent FID so
                    // we need to update the IDTable record accordingly.
                    //
                    // This is taken care of later in change order accept where
                    // we deal with the problem of simultaneous update and rename
                    // COs where the rename CO arrives first but the update CO
                    // ultimately wins and must implicitly rename the file back
                    // to its previous parent.  An update to IDTableRec->ParentFileID
                    // here will interfere with that test.
                } else {
                    IDTableRec->ParentFileID = ChangeOrder->ParentFileReferenceNumber;
                }
            }
        }

        CoCmd->FileUsn = IDTableRec->CurrentFileUsn;

        //
        // A newly created file is first installed into a temporary file
        // and then renamed to its final destination.  The deferred rename
        // flag is set in the IDTable record if the rename fails because
        // of sharing violations or a name conflict. However a subsequent
        // CO may arrive for this file so the flag in the IDTable record
        // tells us to retry the rename when this change order completes.
        // The old create change order will later be discarded by the reconcile
        // code in ChgOrdAccept().
        // NOTE: the flag is ignored when retiring the change order if
        // the change order is a delete.
        // NOTE: Clearing the IDTable flag here does not actually update the
        // database record until the CO finally retires.  At that point if
        // the COE_FLAG_NEED_RENAME is still set then the IDTable flag is
        // turned back on.
        //
        //
        // COE_FLAG_NEED_RENAME is an incore flag that tells the retire
        // code to rename the successfully installed file to its final
        // destination. It is set when the staging file is successfully
        // installed in the preinstall file or when IDREC_FLAGS_RENAME_DEFERRED
        // is set in the idtable entry.  Note that there can be multiple COs
        // active against the same file (serialized of course).  Some may have
        // made it to the rename retry state and have set IDREC_FLAGS_RENAME_DEFERRED
        // while others may be in fetch retry or install retry states.  Only when
        // a CO makes it as far as the install rename retry state do we update
        // the version (and file name) info in the idtable record.
        //
        // IDREC_FLAGS_RENAME_DEFERRED is set when renaming the preinstall
        // file to its final destination failed. The first change order that
        // next comes through for this file picks up the COE_FLAG_NEED_RENAME
        // bit and the IDREC_FLAGS_RENAME_DEFERRED bit is cleared.
        //
        // IBCO_INSTALL_REN_RETRY is a CO command State that is set when
        // a rename fails with a retriable condition. The IDtable entry
        // is marked with IDREC_FLAGS_RENAME_DEFERRED incase another change
        // order is accepted prior to this retry change order.
        // Only one CO at a time can have the COE_FLAG_NEED_RENAME set because
        // ChgOrdHoldIssue() ensures only one CO at a time is in process on a
        // given file.
        //
        // Sharing violations preventing final rename install --
        //
        // Note that more than one change order can be pending in the
        // inbound log for the same file and all can be in the IBCO_INSTALL_REN_RETRY
        // state.  Each one could be renaming the file to a different name
        // or parent dir and could have been blocked by a sharing violation.
        // Because of this the data in the IDTable entry will have the
        // currently correct target name/ parent dir for the file based on
        // those COs that have won reconcilliation.  An added wrinkle is that
        // in the case of a DIR-DIR name morph conflict where the incoming
        // remote CO loses the name we insert a local rename CO into the stream
        // to prop the name change to all outbound partners.  This increases the
        // version number but since it is a local CO it will not go through
        // rename path.  If the original incoming CO failed to complete the
        // rename when it later retries it will lose in reconcile based on
        // a lower version number.  This strands the file in the pre-install
        // area.  To avoid this problem we always accept retry change orders that
        // are in the IBCO_INSTALL_REN_RETRY state when the
        // IDREC_FLAGS_RENAME_DEFERRED flag is set.  If the RENAME_DEFERRED
        // flag is clear then the final rename has been done by another CO and
        // we can just flush the REN_RETRY change order.
        //
        // BTW: Rename is coded to be idempotent. The opens are by ID, not name,
        // and renaming a file to itself turns into a successful NOP.
        //
        // A parallel set of flags exist for deferred deletes.  That is,
        // COE_FLAG_NEED_DELETE, IDREC_FLAGS_DELETE_DEFERRED,
        // IBCO_INSTALL_DEL_RETRY.  See scenario description for
        // IDREC_FLAGS_DELETE_DEFERRED in schema.h.
        //
        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_NEED_RENAME);
            // SUDARC-DEV - Comment out this part so that we preserve the flags in the idtable
            // record.
            // ClearIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
        }

        //
        // If this is a rename CO or there is a pending rename on this file
        // (was marked in the IDTable) then check for possible name morph
        // conflict on the new name.
        //
        if (!MorphGenCo &&
            (BooleanFlagOn(CoCmd->ContentCmd, USN_REASON_RENAME_NEW_NAME) ||
             CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)             ||
             COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME))) {

            FStatus = ChgOrdCheckNameMorphConflict(ThreadCtx,
                                                   IDTableCtxNC,
                                                   ReplicaNumber,
                                                   ChangeOrder);

            if (FStatus == FrsErrorNameMorphConflict) {

                DPRINT(0,"++ NM: Possible Name Morph Conflict on rename\n");
                DBS_DISPLAY_RECORD_SEV(4, IDTableCtxNC, TRUE);
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Poss Morph Conflict - ren");
                //
                // It is possible that a previous change order has already
                // resolved the conflict.  If so don't do it again.
                // The originator guid and the VSN must match but the filename
                // must be different.
                //
                DPRINT(0,"++ NM: Checking for name conflict already resolved.\n");
                RStatus = FrsGuidCompare(&CoCmd->OriginatorGuid,
                                         &IDTableRec->OriginatorGuid);

                if ((RStatus == 0) &&
                    (IDTableRec->OriginatorVSN == CoCmd->FrsVsn)) {
                    //
                    // Conflict resolved previously.  Bag this CO.
                    //
                    FStatus = FrsErrorInvalidChangeOrder;
                    //
                    // File name on this IDTable entry better be different.
                    //
                    // The file name in the IDTable entry may be the same
                    // if a previous duplicate co won the name and the
                    // delete of the loser follows this soon-to-be rejected
                    // change order. The original remote co won the name
                    // because the name did not yet exist. The rename of
                    // the preinstall file to its final name resulted in
                    // the deletion of the local file. I assume this is
                    // the correct protocol for a remote co to "win" the
                    // name over a very recently named local file. The
                    // local file appeared with the same name as the
                    // result of a rename of an existing local file while
                    // the staging file was being fetched or installed
                    // into the preinstall area.
                    //
                    // FRS_ASSERT(wcscmp(CoCmd->FileName, IDTableRec->FileName) != 0);
                }
            } else {
                 CLEANUP_FS(0,"++ NM: WARNING - Unexpected result from ChgOrdCheckNameMorphConflict.",
                           FStatus, RETURN_ERROR);
            }
        }

#if 0
// TEST CODE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
        //
        // test code to be sure the CurrentFileUsn Is still right.
        //
        WStatus1 = FrsOpenSourceFileById(&FileHandle,
                                         &FileNetworkOpenInfo,
                                         NULL,
                                         Replica->pVme->VolumeHandle,
                                         (PULONG)&ChangeOrder->FileReferenceNumber,
                                         sizeof(ULONGLONG),
//                                         READ_ACCESS,
                                         READ_ATTRIB_ACCESS,
                                         ID_OPTIONS,
                                         SHARE_ALL,
                                         FILE_OPEN);
        if (WIN_SUCCESS(WStatus1)) {

            FrsReadFileUsnData(FileHandle, &CurrentFileUsn);
            FRS_CLOSE(FileHandle);

            if (CurrentFileUsn != IDTableRec->CurrentFileUsn) {
                DPRINT(0, "++ WARNING - ID Table record to file mismatch\n");
                DPRINT1(0, "++ File's Usn is:              %08x %08x\n",
                       PRINTQUAD(CurrentFileUsn));
                DPRINT1(0, "++ IDTable->CurrentFileUsn is: %08x %08x\n",
                       PRINTQUAD(IDTableRec->CurrentFileUsn));
            }
        } else {
            DPRINT(0, "++ ERROR - Can't open target file to check USN\n");
        }
// TEST CODE ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
#endif

    } else {
        //
        // IDTable hit on Non-MorphGen Local Change Order.  Update FileUsn to
        // the USN of the most recent USN record that we've seen.
        //
        CoCmd->FileUsn = CoCmd->JrnlUsn;


        if (!RetryCo) {
            //
            // Bump Version number to ensure the CO is accepted if this is
            // the first time we have seen this Local Co.
            //
            CoCmd->FileVersionNumber = IDTableRec->VersionNumber + 1;
        }


        //
        // Needed to dampen basic info changes (e.g., resetting the archive bit)
        // Copied from the idtable entry when the change order is created and
        // used to update the change order when the change order is retired.
        //
        ChangeOrder->FileCreateTime = IDTableRec->FileCreateTime;
        ChangeOrder->FileWriteTime  = IDTableRec->FileWriteTime;
        ChangeOrder->FileAttributes = IDTableRec->FileAttributes;
        //
        // Note: If this CO was generated off of a directory filter table
        // entry (e.g. Moveout) then the ChangeOrder->Cmd.FileAttributes will
        // be zero.  Insert the file attributes from the IDTable record since
        // we can't get them from the original file.
        //
        if (ChangeOrder->Cmd.FileAttributes == 0) {
            ChangeOrder->Cmd.FileAttributes = IDTableRec->FileAttributes;
        }

        //
        // Check if a create change order on this file has been deferred
        // because of:
        //  1. a USN change detected by the stager,
        //  2. a sharing violation prevented us from generating the stage file
        //     or stamping the OID on the file.
        //
        // If so change the Location Command to a create and clear the
        // Create Deferred bit.  Don't do this for a Delete or Moveout
        // since the file is gone and the stager will just bag the change
        // order.
        //
        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_CREATE_DEFERRED) &&
             !((LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT))) {

            if (RetryCo) {
                //
                // Bump Version number to ensure the CO is accepted if this is
                // a retry CO AND we are still trying to generate the create
                // change order for the file.  See DbsRetryInboundCo() for
                // explanation.
                //
                CoCmd->FileVersionNumber = IDTableRec->VersionNumber + 1;
            }

            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_CREATE_DEFERRED);
            SET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command, CO_LOCATION_CREATE);
            LocationCmd = CO_LOCATION_CREATE;
            SET_CO_FLAG(ChangeOrder, CO_FLAG_LOCATION_CMD);
            SetFlag(CoCmd->ContentCmd, USN_REASON_FILE_CREATE);
        }
    }

    //
    // End of IDTable record found code.
    //
    return FStatus;


RETURN_JERR:
    FStatus = DbsTranslateJetError(jerr, FALSE);

RETURN_ERROR:
    //
    // LOG an error message so the user or admin can see what happened.
    //
    DPRINT1(1, "++ WARN - Replication disabled for file %ws\n", CoCmd->FileName);

    IDTableRec = IDTableCtx->pDataRecord;
    IDTableRec->ReplEnabled = FALSE;

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, IDTableCtx);
    DPRINT_JS(0,"++ ERROR - JetCloseTable on IDTable failed:", jerr);

    return FStatus;
}


ULONG
ChgOrdInsertIDRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PTABLE_CTX            DIRTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    )
/*++
Routine Description:

    Insert a new record into the ID table and DIR table for files that
    have either been created or renamed into the replcia set.


    The caller supplies the ID and DIR table contexts to avoid
    a storage realloc on every call.

    On return the DIR and IDTables are closed.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtx -- The table context containing the ID Table record.
    DIRTableCtx -- The table context to use for DIR table access.
    ChangeOrder-- The change order.
    Replica    -- The Replica ID table to do the lookup in.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertIDRecord:"


    FILE_OBJECTID_BUFFER    FileObjID;

    JET_ERR  jerr, jerr1;
    ULONG    FStatus;
    ULONG    WStatus;
    ULONG    GStatus;
    ULONG    ReplicaNumber = Replica->ReplicaNumber;
    BOOL     RemoteCo, MorphGenCo;

    PDIRTABLE_RECORD        DIRTableRec;
    PIDTABLE_RECORD         IDTableRec;


    //
    // remote vs. local change order
    //
    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);
    IDTableRec = IDTableCtx->pDataRecord;

    //
    // We should never be inserting an IDTable record with a zero fid.
    //
    FRS_ASSERT(IDTableRec->FileID != ZERO_FID);

    //
    // Write the new IDTable record into the database.
    //
    FStatus = DbsInsertTable(ThreadCtx, Replica, IDTableCtx, IDTablex, NULL);
    //
    // NTFS tunneling will tunnel the object from a recently deleted
    // file onto a newly created file. This confuses the idtable because
    // we now have a fid whose object id matches an existing fid. We
    // workaround the problem by assigning a new object id to the file.
    //
    // link tracking: The tombstone retains the old OID so FRS blocks OID Tunneling.
    // This might be fixed by implementing tunneling support in FRS.
    //
    if (FStatus == FrsErrorKeyDuplicate && !RemoteCo && !MorphGenCo) {
        ZeroMemory(&IDTableRec->FileObjID, sizeof(IDTableRec->FileObjID));
        FrsUuidCreate((GUID *)(&IDTableRec->FileObjID.ObjectId[0]));
        WStatus = ChgOrdStealObjectId(ChangeOrder->Cmd.FileName,
                                      (PULONG)&ChangeOrder->FileReferenceNumber,
                                       Replica->pVme,
                                       &ChangeOrder->Cmd.FileUsn,
                                       &IDTableRec->FileObjID);
        CLEANUP_WS(0, "++ WORKAROUND FAILED: duplicate key error.", WStatus, ERROR_RETURN);

        COPY_GUID(&ChangeOrder->Cmd.FileGuid, IDTableRec->FileObjID.ObjectId);
        COPY_GUID(&IDTableRec->FileGuid, IDTableRec->FileObjID.ObjectId);

        FStatus = DbsInsertTable(ThreadCtx, Replica, IDTableCtx, IDTablex, NULL);
        CLEANUP_FS(0, "++ WORKAROUND FAILED: duplicate key error.", FStatus, ERROR_RETURN);

        if (FRS_SUCCESS(FStatus)) {
            DPRINT(3, "++ WORKAROUND SUCCEEDED: Ignore duplicate key error\n");
        }
    }

    if (!FRS_SUCCESS(FStatus)) {
        goto ERROR_RETURN;
    }

    //
    // If this is a dir entry insert a new entry in the DIR Table.
    // For remote COs, defer the update of the journal ParentFidTable and
    // the directory FilterTable until the rename install occurs.
    //
    //
    if (IDTableRec->FileIsDir) {
        FStatus = ChgOrdInsertDirRecord(ThreadCtx,
                                        DIRTableCtx,
                                        IDTableRec,
                                        ChangeOrder,
                                        Replica,
                                        TRUE);
    }

    if (FRS_SUCCESS(FStatus)) {
        return FrsErrorSuccess;
    }


ERROR_RETURN:
    //
    // LOG an error message so the user or admin can see what happened.
    //
    DPRINT1(0, "++ ERROR - Replication disabled for file %ws\n", ChangeOrder->Cmd.FileName);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, DIRTableCtx);
    DPRINT_JS(0,"++ ERROR - JetCloseTable on DIRTable failed:", jerr);

    return FStatus;

}


ULONG
ChgOrdInsertDirRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            DIRTableCtx,
    PIDTABLE_RECORD       IDTableRec,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  InsertFlag
    )
/*++
Routine Description:

    Insert or update a record into the DIR table for directories that
    have either been created, reanimated, or renamed into the replcia set.

    The caller supplies the DIR table contexts to avoid a storage realloc
    on every call.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    DIRTableCtx -- The table context to use for DIR table access.
    IDTableRec - ID table record.
    ChangeOrder-- The change order.
    Replica    -- The Replica ID table to do the lookup in.
    InsertFlag -- True if this is an insert.  False if this is an update.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertDirRecord:"

    JET_ERR   jerr, jerr1;
    ULONG     FStatus;
    ULONG     WStatus;
    ULONG     ReplicaNumber = Replica->ReplicaNumber;
    ULONG     LocationCmd;
    BOOL      RemoteCo;
    BOOL      MoveInGenCo;
    PDIRTABLE_RECORD  DIRTableRec;


    //
    // If this is a directory entry insert a new entry in the DIR Table.
    //
    if (!IDTableRec->FileIsDir) {
        return FrsErrorSuccess;
    }

    //
    // remote vs. local change order
    //
    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

    //
    // Open the DIR table for this replica.
    //
    jerr = DbsOpenTable(ThreadCtx, DIRTableCtx, ReplicaNumber, DIRTablex, NULL);
    CLEANUP_JS(0, "++ error opening DIRTable.", jerr, ERROR_RETURN_JERR);

    DIRTableRec = DIRTableCtx->pDataRecord;

    //
    // Build the DIRTable record and insert it into the DIR table.
    //
    DIRTableRec->DFileGuid      = IDTableRec->FileGuid;
    DIRTableRec->DFileID        = IDTableRec->FileID;
    DIRTableRec->DParentFileID  = IDTableRec->ParentFileID;
    DIRTableRec->DReplicaNumber = Replica->ReplicaNumber;
    wcscpy(DIRTableRec->DFileName, IDTableRec->FileName);

    if (InsertFlag) {
        jerr = DbsInsertTable2(DIRTableCtx);

        //
        // Update the volume filter table for a local CO that:
        //  1. Is marked recovery since we won't see it in the Journal again, or
        //  2. Is the product of a MoveIn sub-dir op since it never came from
        //     the Journal process.
        //
        MoveInGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MOVEIN_GEN);

        if (!RemoteCo && (RecoveryCo(ChangeOrder) || MoveInGenCo)) {

            if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter - Reanimate");
            } else {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter");
            }

            if (MoveInGenCo) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter - MoveInGenCo");
            }

            WStatus = JrnlAddFilterEntryFromCo(Replica, ChangeOrder, NULL);
            FStatus = FrsTranslateWin32Error(WStatus);
            CLEANUP_WS(4, "++ JrnlAddFilterEntryFromCo failed.", WStatus, ERROR_RETURN);
        }
    } else {
        //
        // Update an existing record.
        //
        jerr = DbsSeekRecord(ThreadCtx,
                             &DIRTableRec->DFileGuid,
                             DFileGuidIndexx,
                             DIRTableCtx);

        if (JET_SUCCESS(jerr)) {

            jerr = DbsUpdateTable(DIRTableCtx);

            if (JET_SUCCESS(jerr) && RemoteCo && CO_MOVE_RS_OR_DIR(LocationCmd)) {

                //
                // Update the volume filter table for new dir in
                // remote change orders.  For new file creates this update doesn't
                // occur until the rename install of the pre-install file is done.
                // See DbsRenameFid().
                //
                if (LocationCmd == CO_LOCATION_MOVERS) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo UpdVolDir Filter - MoveRs");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo UpdVolDir Filter - MoveDir");
                }

                WStatus = JrnlAddFilterEntryFromCo(Replica, ChangeOrder, NULL);
                DPRINT_WS(4, "++ JrnlAddFilterEntryFromCo failed.", WStatus);
            }
        } else if (jerr == JET_errRecordNotFound){

            //
            // The record may not be found in the dir table in some cases.
            // e.g. A update that needs reanimation goes through retry. At this point
            // it has updated the idtable and removed the delete flag. Also going through
            // retry has caused it to lose the entry flags (reanimation flag). For this CO
            // the update will fail with RecordNotFound.
            //
            DPRINT2(1, "++ WARN - DbsSeekRecord on %ws failed. Attempting insert: JStatus = %s\n",
                        Replica->ReplicaName->Name, ErrLabelJet(jerr));

            jerr = DbsInsertTable2(DIRTableCtx);
            //
            // Update the volume filter table for a local CO that:
            //  1. Is marked recovery since we won't see it in the Journal again, or
            //  2. Is the product of a MoveIn sub-dir op since it never came from
            //     the Journal process.
            //
            MoveInGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MOVEIN_GEN);

            if (!RemoteCo && (RecoveryCo(ChangeOrder) || MoveInGenCo)) {

                if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter - Reanimate");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter");
                }

                if (MoveInGenCo) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "Add Vol Dir Filter - MoveInGenCo");
                }

                WStatus = JrnlAddFilterEntryFromCo(Replica, ChangeOrder, NULL);
                FStatus = FrsTranslateWin32Error(WStatus);
                CLEANUP_WS(4, "++ JrnlAddFilterEntryFromCo failed.", WStatus, ERROR_RETURN);
            }

        } else {
            goto ERROR_RETURN_JERR;
        }
    }

    CLEANUP1_JS(0, "++ Error %s DIRTable record :",
               (InsertFlag ? "inserting" : "updating"), jerr, ERROR_RETURN_JERR);

    DbsCloseTable(jerr, ThreadCtx->JSesid, DIRTableCtx);
    DPRINT_JS(0,"++ ERROR - JetCloseTable on DIRTable failed:", jerr);

    return FrsErrorSuccess;


ERROR_RETURN_JERR:
     FStatus = DbsTranslateJetError(jerr, FALSE);

ERROR_RETURN:
    //
    // LOG an error message so the user or admin can see what happened.
    //
    DBS_DISPLAY_RECORD_SEV(0, DIRTableCtx, FALSE);
    DPRINT1(0, "++ ERROR - Replication disabled for Dir %ws\n", ChangeOrder->Cmd.FileName);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, DIRTableCtx);
    DPRINT_JS(0,"++ ERROR - JetCloseTable on DIRTable failed:", jerr);

    return FStatus;
}


ULONG
ChgOrdCheckAndFixTunnelConflict(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtxNew,
    PTABLE_CTX            IDTableCtxExist,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    BOOL                  *IDTableRecExists
    )
/*++
Routine Description:

    On input, the ChangeOrder must be for a new file and have been
    assigned a guid (even if the guid has not been hammered onto
    the file, yet). In other words, this function is designed to
    be called out of ChgOrdReadIDRecord() after the call to
    DbsInitializeIDTableRecord().

    267544  ChangeOrder->COMorphGenCount < 50 assertion in NTFRS.
        Tunneling assigns the guid of a deleted file to a newly created
        local file. In ChgOrdReadIDRecord(), a new idtable entry for
        the file is initialized with the tunneled guid. The file
        then loses a morph conflict. A delete-co is generated.
        When the delete-co is passed to ChgOrdReadIDRecord(), the
        wrong idtable record is read because the file's guid is used
        as the index. The delete-co is updated with the wrong FID and
        finally retires and updates the wrong idtable entry. The co
        for the newly created file again enters ChgOrdReadIDRecord()
        and the process is repeated until the ASSERT(morphgencount < 50).

    Read the ID Table record by guid for this change order.
    If found and the FID does not match then steal the existing
    id table entry by updating the FID to be the FID for this file.

    In other words, keep the guid/fid relationship intact in the idtable.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtxNew -- The table context for new ID Table record
    IDTableCtxExist -- The table context for existing ID Table record
    Replica -- The Replica for the ID Table to do the lookup in.
    ChangeOrder-- The change order.
    IDTableRecExists - Set to TRUE if the idtable record exists. The
                       caller then knows that the idtable entry shouldn't
                       be inserted.

Return Value:

    Frs Status:
    FrsErrorTunnelConflict -  tunnel conflict detected and resolved.
    FrsErrorSuccess        -  no conflict
    Any other error is a failure.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdCheckAndFixTunnelConflict:"
    JET_ERR                 jerr;
    ULONG                   FStatus;
    ULONG                   WStatus;
    PIDTABLE_RECORD         IDTableRecNew;
    PIDTABLE_RECORD         IDTableRecExist;
    ULONG                   IdtFieldUpdateList[1];
    PCHANGE_ORDER_COMMAND   CoCmd = &ChangeOrder->Cmd;

    //
    // Open the idtable
    //
    jerr = DbsOpenTable(ThreadCtx,
                        IDTableCtxExist,
                        Replica->ReplicaNumber,
                        IDTablex,
                        NULL);

    //
    // Unexpected problem opening the idtable
    //
    if (!JET_SUCCESS(jerr)) {
        FStatus = DbsTranslateJetError(jerr, TRUE);
        return FStatus;
    }

    //
    // Read the existing idtable record by guid (stored in new idtable entry)
    //
    IDTableRecNew = IDTableCtxNew->pDataRecord;
    jerr = DbsReadRecord(ThreadCtx,
                         &IDTableRecNew->FileGuid,
                         GuidIndexx,
                         IDTableCtxExist);

    //
    // No conflict; done
    //
    if (jerr == JET_errRecordNotFound) {
        FStatus = FrsErrorSuccess;
        goto CLEANUP;
    }

    //
    // Unexpected problem reading the idtable record
    //
    if (!JET_SUCCESS(jerr)) {
        FStatus = DbsTranslateJetError(jerr, TRUE);
        goto CLEANUP;
    }

    //
    // Does the existing idtable entry have a different fid? If so,
    // steal the entry if it is for a deleted file. This can happen
    // when tunneling assigns an old OID to a new FID.
    //
    IDTableRecExist = IDTableCtxExist->pDataRecord;
    if (IDTableRecNew->FileID == IDTableRecExist->FileID) {
        FStatus = FrsErrorSuccess;
        goto CLEANUP;
    }

    //
    // TUNNEL CONFLICT
    //
    DBS_DISPLAY_RECORD_SEV(5, IDTableCtxExist, TRUE);
    DBS_DISPLAY_RECORD_SEV(5, IDTableCtxNew, TRUE);
    if (IsIdRecFlagSet(IDTableRecExist, IDREC_FLAGS_DELETED)) {
        //
        // This case occurs when the delete of the original file preceeds the
        // create and rename of the new file to the target name.
        //
        //   del  FID_original   (has target_name, loads NTFS tunnel cache)
        //   cre  FID_new        (has a temp name)
        //   ren  FID_new to target_name    (hits in NTFS tunnel cache)
        //
        // When we see the USN record for the create the rename has already
        // been done and FID_new has the OID from FID_original via the tunnel
        // cache.  Since we have seen the delete the IDT entry has been marked
        // deleted.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Tunnel Conflict - Updating IDT");
    } else {
        //
        // This case occurs when the delete of the original file follows the
        // create of the new file.
        //
        //   cre  FID_new        (has a temp name)
        //   del  FID_original   (has target_name, loads NTFS tunnel cache)
        //   ren  FID_new to target_name    (hits in NTFS tunnel cache)
        //
        // As above when we see the USN record for the create the rename has
        // already been done and FID_new has the OID from FID_original via
        // the tunnel cache.  BUT in this case we have not yet seen the
        // USN record for the delete so the IDT entry has not been marked
        // deleted.  Since the OID got tunneled we know there is another USN
        // record coming that will reference FID_new so we can reject the
        // create CO now and let it be handled at that time.  This is similar
        // to updating a file that wasn't in the IDTable because it matched
        // the file filter at the time it was created so the USN record was
        // skipped.
        //
        //
        // Actually we cannot skip the create because the other CO that "must"
        // be coming could have been combined with this one in the aging cache.
        // THis problem occurred on saves of excel files.
        // It is even possible not to have another CO on the way:
        //
        // Consider an ap that does this:
        // Open A
        // Rename A => B
        // Close "B" (opened as A)
        // Open B
        // Mark B Deleted
        // Open A
        // Close A
        // Close B
        //
        // The Oid from the original A will be tunneled to the new A,
        // but the order of the closes will make the USN look like this:
        //
        // Rename A => B
        // Create A
        // Delete B
        //
        //
        // Now we process the create of A with the tunneled Oid before the delete of B.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Tunnel Conflict - Updating IDT [Original File not marked Deleted]");

//        CHANGE_ORDER_TRACE(3, ChangeOrder, "Tunnel Conflict - Reject CO");
//        FStatus = FrsErrorTunnelConflictRejectCO;
//        goto CLEANUP;

    }

    //
    // Pick up the version of the existing record + 1 just as if this
    // change order were a local co against the existing record (which
    // it is). Otherwise, the change order will be rejected on our
    // partners because the version on a new file is set to 0.
    //
    CoCmd->FileVersionNumber = IDTableRecExist->VersionNumber + 1;

    //
    // Update the fid in the existing id table entry
    //
    // Perf: Is the below necessary? the idtable rec will be updated
    //       by ChgOrdAccept() on return because IDTableRecExists
    //       is set to TRUE below.
    //
    IdtFieldUpdateList[0] = FileIDx;
    FStatus = DbsUpdateIDTableFields(ThreadCtx, Replica, ChangeOrder, IdtFieldUpdateList, 1);
    CLEANUP_FS(0, "++ ERROR - DbsUpdateIDTableFields failed.", FStatus, CLEANUP);

    //
    // The existing idtable entry now belongs to the new file that
    // was assigned an old OID (probably by tunneling).
    //
    *IDTableRecExists = TRUE;

    //
    // Tunnel fixup was a success.
    //
    FStatus = FrsErrorTunnelConflict;

CLEANUP:
    DbsCloseTable(jerr, ThreadCtx->JSesid, IDTableCtxExist);
    return FStatus;
}


ULONG
ChgOrdCheckNameMorphConflict(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtxNC,
    ULONG                 ReplicaNumber,
    PCHANGE_ORDER_ENTRY   ChangeOrder
    )
/*++
Routine Description:

    Read the ID Table record for the parent guid - filename for this change
    order from the replica set specified by the ReplicaNumber.
    Scan all records with matching parent guid and filename looking for an
    undeleted entry with a non-matching file guid.  If found then we have
    a name morph conflict.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtxNC -- The table context containing the ID Table record for the Name Conflict.
    ReplicaNumber -- The Replica ID for the ID Table to do the lookup in.
    ChangeOrder-- The change order.

Return Value:

    Frs Status:

    FrsErrorSuccess -  IDTable record was not found so there is no conflict.

    FrsErrorNameMorphConflict - A parent guid/name conflict with
                       another entry in the IDTable was found.
                       Data for this conflicting
                       entry is returned in IDTableCtxNC.

    Any other error is a failure.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdCheckNameMorphConflict:"


    UNICODE_STRING   TempUStr;
    JET_ERR          jerr, jerr1;
    ULONG            FStatus;
    PVOID            KeyArray[2];
    PIDTABLE_RECORD  IDTableRec;

    JET_SESID        Sesid;
    JET_TABLEID      Tid;
    USHORT           IDTFileNameLength;
    USHORT           SaveCoFileNameLength, LenLimit;

    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;


#define ESE_INDEX_LENGTH_LIMIT  (JET_cbKeyMost & 0XFFFFFFFE)

    jerr = DbsOpenTable(ThreadCtx, IDTableCtxNC, ReplicaNumber, IDTablex, NULL);

    if (!JET_SUCCESS(jerr)) {
        FStatus = DbsTranslateJetError(jerr, TRUE);
        return FStatus;
    }

    Sesid = ThreadCtx->JSesid;
    Tid   = IDTableCtxNC->Tid;

    FRS_ASSERT(ChangeOrder->pParentGuid != NULL);

    KeyArray[0] = (PVOID)ChangeOrder->pParentGuid;
    KeyArray[1] = (PVOID)CoCmd->FileName;

    SaveCoFileNameLength = ChangeOrder->UFileName.Length;

    //
    // Seek to the first record with a matching parent GUID and Filename.
    //
    FStatus = DbsRecordOperationMKey(ThreadCtx,
                                     ROP_SEEK,
                                     KeyArray,
                                     ParGuidFileNameIndexx,
                                     IDTableCtxNC);
    //
    // Read subsequent records (there could be multiples)
    // checking for a non-tombstone.
    //
    while (FRS_SUCCESS(FStatus)) {

        //
        // Read the record and check for tombstone
        //
        FStatus = DbsTableRead(ThreadCtx, IDTableCtxNC);

        IDTableRec = IDTableCtxNC->pDataRecord;


        if (!GUIDS_EQUAL(ChangeOrder->pParentGuid, &IDTableRec->ParentGuid)) {
            //
            // No more matching records.
            //
            FStatus = FrsErrorNotFound;
            break;
        }

        IDTFileNameLength = wcslen(IDTableRec->FileName) * sizeof(WCHAR);



        //
        // Indexes in Jet are limited to a max size of ESE_INDEX_LENGTH_LIMIT
        // bytes for LongText Columns.
        //
        // So we can only rely on the length check to tell us when there
        // are no more matchng entries in this key when we are going after
        // a filename shorter than this or Jet returns us a result shorter
        // than this.
        //
        if ((SaveCoFileNameLength != IDTFileNameLength) &&
            ((SaveCoFileNameLength  < ESE_INDEX_LENGTH_LIMIT) ||
             (IDTFileNameLength     < ESE_INDEX_LENGTH_LIMIT))){
            FStatus = FrsErrorNotFound;
            break;
        }

        //
        // Finally do the case insensitive compare.
        //
        FrsSetUnicodeStringFromRawString(&TempUStr,
                                         SIZEOF(IDTABLE_RECORD, FileName),
                                         IDTableRec->FileName,
                                         IDTFileNameLength);

        //
        // Either the lengths are the same or they are both over
        // ESE_INDEX_LENGTH_LIMIT, possibly both.  Either way, for the
        // purpose of loop termination we can't compare more than this.
        //
        LenLimit = min(SaveCoFileNameLength, ESE_INDEX_LENGTH_LIMIT);
        LenLimit = min(LenLimit, IDTFileNameLength);

        if (LenLimit == ESE_INDEX_LENGTH_LIMIT) {
            TempUStr.Length = LenLimit;
            ChangeOrder->UFileName.Length = LenLimit;
        }

        if (!RtlEqualUnicodeString(&TempUStr, &ChangeOrder->UFileName, TRUE)) {
            ChangeOrder->UFileName.Length = SaveCoFileNameLength;
            FStatus = FrsErrorNotFound;
            break;
        }


        if (LenLimit == ESE_INDEX_LENGTH_LIMIT) {
            TempUStr.Length = IDTFileNameLength;
            ChangeOrder->UFileName.Length = SaveCoFileNameLength;
        }

        //
        // We found a match, maybe.
        //
        DBS_DISPLAY_RECORD_SEV(5, IDTableCtxNC, TRUE);

        //
        // Check for undeleted record where the File Guid does not match the CO.
        // If such a record is found then we have a name morph conflict.
        //
        if ((!IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED) ||
             IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED))&&
            !GUIDS_EQUAL(&CoCmd->FileGuid, &IDTableRec->FileGuid)) {

            //
            // Now do the full len compare if the lengths were greater than
            // ESE_INDEX_LENGTH_LIMIT.  If the lengths are over the index
            // limit and the strings fail to compare equal then keep looking.
            //
            if ((LenLimit != ESE_INDEX_LENGTH_LIMIT) ||
                RtlEqualUnicodeString(&TempUStr, &ChangeOrder->UFileName, TRUE)) {
                FStatus = FrsErrorSuccess;
                break;
            }
        }

        //
        // go to next record in this index.
        //
        jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);

        //
        // If the record is not there then no conflict
        //
        if (jerr == JET_errNoCurrentRecord ) {
            FStatus = FrsErrorNotFound;
            break;
        }

        if (!JET_SUCCESS(jerr)) {
            FStatus = DbsTranslateJetError(jerr, FALSE);
            DPRINT_FS(0, "++ JetMove error:", FStatus);
            break;
        }

    }

    //
    // Success return above means we found a record with a matching parent
    // Guid and File name but a different File Guid.  This is a name morph
    // conflict.
    //
    if (FRS_SUCCESS(FStatus)) {
        DPRINT(0,"++ NM: Possible Name Morph Conflict\n");
        DBS_DISPLAY_RECORD_SEV(4, IDTableCtxNC, TRUE);
        FStatus = FrsErrorNameMorphConflict;
    }
    else
    if (FStatus != FrsErrorNotFound) {
        DPRINT_FS(0,"++ NM: WARNING - Unexpected result from DbsTableRead.", FStatus);
    } else {
        FStatus = FrsErrorSuccess;
    }


    DbsCloseTable(jerr, ThreadCtx->JSesid, IDTableCtxNC);
    return FStatus;
}



VOID
ChgOrdProcessControlCo(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
    )
/*++
Routine Description:

   Process the control change order.

Arguments:
   ChangeOrder-- The change order.
   Replica    -- The Replica struct.

Return Value:

   None.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdProcessControlCo:"


    PCHANGE_ORDER_RECORD CoCmd = &ChangeOrder->Cmd;
    PCXTION              CtlCxtion;

    switch (CoCmd->ContentCmd) {


    case FCN_CORETRY_LOCAL_ONLY:

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CORETRY_LOCAL_ONLY Ctrl CO");
    break;



    //
    // Retrying COs from a single inbound connection.
    //
    case FCN_CORETRY_ONE_CXTION:

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CORETRY_ONE_CXTION Ctrl CO");

        //
        // Find the inbound cxtion for this CO and advance state to starting.
        //
        LOCK_CXTION_TABLE(Replica);

        CtlCxtion = GTabLookupNoLock(Replica->Cxtions, &CoCmd->CxtionGuid, NULL);
        if (CtlCxtion != NULL) {
            FRS_ASSERT(CtlCxtion->Inbound);

            //
            // If cxtion no longer in the request start state leave it alone
            // else advance to STARTING.  Doing this here ensures that we
            // don't hold issue on the process queue (and hang) if there are
            // lingering COs for this Conection ahead of us.  I.E.  any COs
            // we see for this cxtion now are either retry COs from the inlog
            // or newly arrived COs.
            //
            if (CxtionStateIs(CtlCxtion, CxtionStateStarting)) {
                //
                // The cxtion is attempting to unjoin.  Skip the inbound log
                // scan and advance to the SENDJOIN state so the UNJOIN will
                // proceed.
                //
                if (CxtionFlagIs(CtlCxtion, (CXTION_FLAGS_DEFERRED_UNJOIN |
                                             CXTION_FLAGS_DEFERRED_DELETE))) {
                    SetCxtionState(CtlCxtion, CxtionStateSendJoin);
                    RcsSubmitReplicaCxtion(Replica, CtlCxtion, CMD_JOIN_CXTION);
                } else {
                    SetCxtionState(CtlCxtion, CxtionStateScanning);
                    //
                    // Connection startup request.  Fork a thread and
                    // paw thru Inlog.
                    //
                    ChgOrdRetrySubmit(Replica,
                                      CtlCxtion,
                                      FCN_CORETRY_ONE_CXTION,
                                      FALSE);
                }
            }
        } else {
            DPRINT(0, "++ ERROR - No connection struct for control cmd.\n");
            FRS_ASSERT(!"No connection struct for control CO");
        }

        UNLOCK_CXTION_TABLE(Replica);

    break;


    case FCN_CORETRY_ALL_CXTIONS:

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CORETRY_ALL_CXTIONS Ctrl CO");

    break;


    case FCN_CO_NORMAL_VVJOIN_TERM:

        CHANGE_ORDER_TRACE(3, ChangeOrder, "CO_NORMAL_VVJOIN_TER Ctrl CO");

    break;



    default:
        DPRINT1(0, "++ ERROR - Invalid control command: %d\n", CoCmd->ContentCmd);
        FRS_ASSERT(!"Invalid control command in CO");
    }


    //
    // Done with control cmd.  Caller is expected to
    // release process queue lock, cleanup and unidle the queue.
    //

}



VOID
ChgOrdTranslateGuidFid(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            IDTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica
    )
/*++
Routine Description:

    Perform translation of FIDs to Guids and vice versa.
    Return bit mask for delete status of target file and the original and
    new parent dirs.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    IDTableCtx -- The table context to use for the IDTable lookup.
    ChangeOrder-- The change order.
    Replica    -- The Replica struct.

Return Value:

    The results of the call are returned in the change order.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTranslateGuidFid:"


    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    ULONGLONG            TargetFid;
    PCHANGE_ORDER_RECORD CoCmd = &ChangeOrder->Cmd;
    BOOL                 CoFromInlog, MorphGenCo;
    ULONG                FStatus;
    HANDLE               Handle;
    DWORD                WStatus;


    CoFromInlog = CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY) ||
                  RecoveryCo(ChangeOrder);

    MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

    CLEAR_COE_FLAG(ChangeOrder, (COE_FLAG_IDT_ORIG_PARENT_DEL     |
                                 COE_FLAG_IDT_ORIG_PARENT_ABS     |
                                 COE_FLAG_IDT_NEW_PARENT_DEL      |
                                 COE_FLAG_IDT_NEW_PARENT_ABS      |
                                 COE_FLAG_IDT_NEW_PARENT_DEL_DEF  |
                                 COE_FLAG_IDT_TARGET_DEL          |
                                 COE_FLAG_IDT_TARGET_ABS));

    //
    // Local COs translate FIDs to Guids.  Unless they came from the Inlog
    // or were produced by Name Morph resolution.
    //
    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO) && !MorphGenCo && !CoFromInlog) {
        //
        // Fill in the Originator Guid for the local change order.
        //
        COPY_GUID(&CoCmd->OriginatorGuid, &Replica->ReplicaVersionGuid);

        //
        // (Do it here in case we create a new ID table record).
        // We supply IDTableCtx to avoid a storage realloc on every call.
        //
        // Get status of original parent.
        //
        FStatus = DbsFidToGuid(ThreadCtx,
                               ChangeOrder->OriginalReplica,
                               IDTableCtx,
                               &ChangeOrder->OriginalParentFid,
                               &CoCmd->OldParentGuid);

        if ((FStatus == FrsErrorIdtFileIsDeleted) ||
        (FStatus == FrsErrorIdtFileIsDeleteDef)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_DEL);
        } else
        if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS);
        }

        //
        // Get Status of New Parent.
        //
        if (ChangeOrder->NewParentFid != ChangeOrder->OriginalParentFid) {
            FStatus = DbsFidToGuid(ThreadCtx,
                                   ChangeOrder->NewReplica,
                                   IDTableCtx,
                                   &ChangeOrder->NewParentFid,
                                   &CoCmd->NewParentGuid);
        } else {
            CoCmd->NewParentGuid = CoCmd->OldParentGuid;
        }

        if (FStatus == FrsErrorIdtFileIsDeleted) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL);

        } else if (FStatus == FrsErrorIdtFileIsDeleteDef) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL);
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL_DEF);

        } else if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_ABS);
        }

        ChangeOrder->pParentGuid = (ChangeOrder->NewReplica != NULL) ?
                                      &CoCmd->NewParentGuid :
                                      &CoCmd->OldParentGuid;
        //
        // Get status of target file or dir.
        //
        FStatus = DbsFidToGuid(ThreadCtx,
                               Replica,
                               IDTableCtx,
                               &ChangeOrder->FileReferenceNumber,
                               &CoCmd->FileGuid);

        if ((FStatus == FrsErrorIdtFileIsDeleted)  ||
        (FStatus == FrsErrorIdtFileIsDeleteDef)){
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_TARGET_DEL);
        } else
        if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_TARGET_ABS);
        }

        //
        // Read object ID from file.  This is done here so we have it for
        // the hold issue check to deal with a tunnelled OID.
        //
        CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_OID_FROM_FILE);

        WStatus = FrsOpenSourceFileById(&Handle,
                                        NULL,
                                        NULL,
                                        Replica->pVme->VolumeHandle,
                                        &ChangeOrder->FileReferenceNumber,
                                        FILE_ID_LENGTH,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);

        if (WIN_SUCCESS(WStatus)) {
            WStatus = FrsGetObjectId(Handle, &ObjectIdBuffer);
            FRS_CLOSE(Handle);

            if (WIN_SUCCESS(WStatus)) {
                COPY_GUID(&ChangeOrder->FileObjectId, &ObjectIdBuffer.ObjectId);
                SET_COE_FLAG(ChangeOrder, COE_FLAG_OID_FROM_FILE);
            }
        } else {
            DPRINT1_WS(4, "++ Could not open (Id %08x %08x) for oid read;",
                       PRINTQUAD(ChangeOrder->FileReferenceNumber), WStatus);
        }


    } else {

        //
        // Remote COs and recovery and retry Local COs translate Guids to Fids
        // because the FID is not saved in the change order command.
        // **NOTE** -- If this happened to be a CO for a child that just
        // forced the reanimation of its parent then this CO was pushed back
        // onto the CO process queue with the "old parent FID" so the parent
        // reanimation could then proceed.  Now when the child has been
        // restarted the parent FID will have changed and the GUID to FID
        // translation here will pick that change up.
        //
        Replica = ChangeOrder->NewReplica;

        //
        // Get status of original parent.
        //
        FStatus = DbsGuidToFid(ThreadCtx,
                               Replica,
                               IDTableCtx,
                               &CoCmd->OldParentGuid,
                               &ChangeOrder->OriginalParentFid);
        if ((FStatus == FrsErrorIdtFileIsDeleted) ||
        (FStatus == FrsErrorIdtFileIsDeleteDef)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_DEL);
        } else
        if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_ORIG_PARENT_ABS);
        }

        //
        // Get Status of New Parent.
        //
        if (!GUIDS_EQUAL(&CoCmd->NewParentGuid, &CoCmd->OldParentGuid)) {
            FStatus = DbsGuidToFid(ThreadCtx,
                                   Replica,
                                   IDTableCtx,
                                   &CoCmd->NewParentGuid,
                                   &ChangeOrder->NewParentFid);
        } else {
            ChangeOrder->NewParentFid = ChangeOrder->OriginalParentFid;
        }

        if (FStatus == FrsErrorIdtFileIsDeleted) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL);

        } else if (FStatus == FrsErrorIdtFileIsDeleteDef) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL);
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_DEL_DEF);

        } else if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_NEW_PARENT_ABS);
        }

        //
        // For remote change orders, set the Parent FID from the NewParent Fid.
        //
        ChangeOrder->ParentFileReferenceNumber = ChangeOrder->NewParentFid;
        ChangeOrder->pParentGuid = &CoCmd->NewParentGuid;

        //
        // For a morph generated CO that has a FID already, preserve it.
        // Delete MorphGenCos are an example where the incoming CO is losing
        // so the FID is fake for the tombstone.
        // Still need to get the status of the IDTable entry for the target.
        // This is used to abort the MorphGenCo later in those cases where
        // the conflict causing entry was deleted or aborted.
        //
        FStatus = DbsGuidToFid(ThreadCtx,
                               Replica,
                               IDTableCtx,
                               &CoCmd->FileGuid,
                               &TargetFid);

        if ((FStatus == FrsErrorIdtFileIsDeleted) ||
        (FStatus == FrsErrorIdtFileIsDeleteDef)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_TARGET_DEL);
        } else
        if (!FRS_SUCCESS(FStatus)) {
            SET_COE_FLAG(ChangeOrder, COE_FLAG_IDT_TARGET_ABS);
        }

        if (!MorphGenCo || (ChangeOrder->FileReferenceNumber == ZERO_FID)) {
            ChangeOrder->FileReferenceNumber = TargetFid;
        }
    }

    return;
}



ULONG
ChgOrdInsertInlogRecord(
    PTHREAD_CTX           ThreadCtx,
    PTABLE_CTX            InLogTableCtx,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    PREPLICA              Replica,
    BOOL                  RetryOutOfOrder
    )
/*++
Routine Description:

    Insert the Change order command into the inbound log.
    Update the Inlog Commit USN.

Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    InLogTableCtx -- The table context to use for the Inbound log insert.
    ChangeOrder-- The change order.
    Replica    -- The Replica struct.
    RetryOutOfOrder --  TRUE - insert into the inbound log with the
                               retry flag set and marked as out of order.
                        FALSE - Don't set retry or out-of-order.

Return Value:

    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertInlogRecord:"


    ULONGLONG            SeqNum;

    PCHANGE_ORDER_RECORD CoCmd = &ChangeOrder->Cmd;

    ULONG                FStatus;
    ULONG                LocationCmd;
    ULONG                NewState;
    BOOL                 LocalCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);


    //
    // Convert the replica pointers to the local replica ID numbers for storing
    // the record in the database.
    //
    CoCmd->OriginalReplicaNum = ReplicaAddrToId(ChangeOrder->OriginalReplica);
    CoCmd->NewReplicaNum      = ReplicaAddrToId(ChangeOrder->NewReplica);

    //
    // Transform ChangeOrder as needed:
    //  1. MOVEIN -> CREATE
    //  2. MOVEOUT -> DELETE
    //  3. MOVEDIR -> MOVEDIR
    //  4. MOVERS -> DELETE to old rs, CREATE to new rs.
    //
    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    //
    // MOVERS:  Add code for movers case when supported.
    //

    //
    // Change order starts out in the staging file requested state unless it
    // is a duplicate co or a retry-preinstall co.  If duplicate co or a
    // retry-preinstall co then mark it as retry out-of-order.
    //
    if (LocalCo) {
        NewState = IBCO_STAGING_REQUESTED;

        //
        // Normally the change order record extension is allocated for local COs
        // when the co cmd is inserted into the inbound log (by the call to
        // DbsAllocRecordStorage()).  But this can be a problem if the local
        // co ends up going thru retry (e.g. sharing violation) where we update
        // the extension in the inlog record.  If the extension is null then
        // we end up failing an assert.  So allocate and init the contents here.
        //
        if (CoCmd->Extension == NULL) {
            CoCmd->Extension = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
            DbsDataInitCocExtension(CoCmd->Extension);
            DPRINT(4, "Allocating initial Coc Extension for localco\n");
        }


    } else {
        NewState = (RetryOutOfOrder ? IBCO_FETCH_RETRY : IBCO_FETCH_REQUESTED);
    }

    //
    // During retry, the duplicate co or preinstall-retry co will not
    // get a retire slot because it is marked out-of-order.
    //
    if (RetryOutOfOrder) {
        SET_CO_FLAG(ChangeOrder, CO_FLAG_RETRY | CO_FLAG_OUT_OF_ORDER);
    }

    SET_CHANGE_ORDER_STATE(ChangeOrder, NewState);

    //
    // Get the lock on the Active Retry table.
    //
    QHashAcquireLock(Replica->ActiveInlogRetryTable);

    //
    // Insert the record into the Inbound log table.  The value of the Jet
    // assigned sequence number is returned in the Sequence number field.
    // Set the record data pointer to command portion of the change order
    // entry.  The RtCtx (containing the InLogTableCtx) accompanies the
    // change order as it is processed.
    //
    FStatus = DbsInsertTable(ThreadCtx,
                             Replica,
                             InLogTableCtx,
                             INLOGTablex,
                             &ChangeOrder->Cmd);
    if (!FRS_SUCCESS(FStatus) && (RetryOutOfOrder)) {
        //
        // Never made it into the inlog so clear the flags.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_RETRY | CO_FLAG_OUT_OF_ORDER);
    }


    if ((FStatus == FrsErrorKeyDuplicate) ||
        (FStatus == FrsErrorDbWriteConflict)) {
        //
        // This can happen duing restart if we already have a change order
        // from a given connection in the inbound log and the inbound
        // partner sends it again because it didn't get an Ack when it sent
        // it the first time.  This should be a remote CO.
        //
        // The FrsErrorDbWriteConflict is returned when the change order is
        // being deleted while the insert is attempted.  Treat this insert
        // as a duplicate.
        //
        QHashReleaseLock(Replica->ActiveInlogRetryTable);
        return FrsErrorKeyDuplicate;
    } else
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "++ Error from DbsInsertTable.", FStatus);
        QHashReleaseLock(Replica->ActiveInlogRetryTable);
        return FStatus;
    }


    // There is a small window here where the new CO is in the inlog
    // and the CO SequenceNumber is not in the ActiveInlogRetryTable
    // below.  If the retry thread was active and saw the inlog record
    // but did not see the entry in the ActiveInlogRetryTable then it
    // could process the entry and try to ref the CO on the VVRetire
    // list.  If this was a DUP CO it may cause an assert because the CO
    // is not marked activated yet this is a retry CO.  The problem is
    // that entry on the VVRetire list is for ANOTHER CO already in
    // process.  Although that in-process CO has not yet activated the
    // VV Slot.
    // >>>>> One way to fix this is to stop having Jet assign the seqnum
    // Additional problem below requires the table lock.
    //
    // Another way we run into problems is as follows: (BUG 213163)
    // 1. Dup Remote Co arrives
    // 2. Insert into inlog and code below adds seq num to ActiveInlogRetryTable.
    // 3. Ctx switch to retry thread resubmits this CO (Instance A) and makes
    //    entry in ActiveInlogRetryTable.
    // 4. Ctx switch back to Dup Co which cleans up and removes entry from
    //    ActiveInlogRetryTable.
    // 5. Retry thread runs again and re-inserts Dup Remote Co a 2nd time, Instance B.
    // 6. Instance A runs to completion (may get rejected) and deletes inlog record.
    // 7. Instance B runs to completion and asserts when it tries to delete
    //    inlog record a 2nd time and doesn't find it.
    //
    // To prevent this we take the lock on the ActiveInlogRetryTable above.
    //

    //
    // All COs go into the inlog retry table to lock against reissue by the
    // retry thread.  See comment at FCN_CORETRY_ALL_CXTIONS for reason.
    // Qhash Insert has to go after DB insert cuz DB Insert assigns the seq num.
    //
    SeqNum = (ULONGLONG) ChangeOrder->Cmd.SequenceNumber;
    QHashInsertLock(Replica->ActiveInlogRetryTable, &SeqNum, NULL, 0);
    QHashReleaseLock(Replica->ActiveInlogRetryTable);

    //
    // Update count of change orders we need to retry for this replica.
    //
    if (RetryOutOfOrder) {
        InterlockedIncrement(&Replica->InLogRetryCount);
    }

    //
    // Update the USN Journal Save point for this replica set.  This is the
    // value saved the next time we update the save point in the config record.
    // Local change orders enter the volume process queue in order.
    // So any change orders earlier than this have either been dampened, rejected,
    // or written to the inbound log.   JrnlFirstUsn can be zero if it is a
    // change order produced by a sub-tree operation.  Only the Change Order
    // on the root dir will update the InlogCommitUsn.
    //
    if (LocalCo) {
        if (CoCmd->JrnlFirstUsn != (USN) 0) {
            DPRINT1(4, "++ Replica->InlogCommitUsn: %08x %08x\n",
                    PRINTQUAD(Replica->InlogCommitUsn));

            if (Replica->InlogCommitUsn < CoCmd->JrnlFirstUsn) {
                PVOLUME_MONITOR_ENTRY pVme = Replica->pVme;
                //
                // Get the lock and make the test again.
                //
                AcquireQuadLock(&pVme->QuadWriteLock);
                if (Replica->InlogCommitUsn <= CoCmd->JrnlFirstUsn) {
                    Replica->InlogCommitUsn = CoCmd->JrnlFirstUsn;
                    ReleaseQuadLock(&pVme->QuadWriteLock);
                } else {
                    ReleaseQuadLock(&pVme->QuadWriteLock);
                    FRS_ASSERT(Replica->InlogCommitUsn <= CoCmd->JrnlFirstUsn);
                }
            }
        }
    }

    return FrsErrorSuccess;
}




JET_ERR
ChgOrdMoveoutWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called with an IDTable record it tests the IDTable for a match
    with the parent file ID parameter.  If it matches it generates a
    Delete Change Order for the child and pushes it onto the change order
    process queue.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an IDTable context struct.
    Record    - A ptr to a IDTable record.
    Context   - A ptr to a MOVEOUT_CONTEXT struct.

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "ChgOrdMoveoutWorker:"

    JET_ERR                 jerr = JET_errSuccess;
    PCHANGE_ORDER_ENTRY     DelCoe;
    ULONG                   WStatus;
    ULONG                   LocationCmd;

    PREPLICA                Replica;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    PVOLUME_MONITOR_ENTRY   pVme;

    PMOVEOUT_CONTEXT        MoveOutContext = (PMOVEOUT_CONTEXT) Context;
    PIDTABLE_RECORD         IDTableRec = (PIDTABLE_RECORD) Record ;


    Replica = MoveOutContext->Replica;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    pVme = Replica->pVme;

    //
    // Include the entry if replication is enabled and not marked for deletion
    // and not a new file being created when we last shutdown.
    //
    if (IDTableRec->ReplEnabled &&
        !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED) &&
        !IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS) &&
        (MoveOutContext->ParentFileID == IDTableRec->ParentFileID)) {

        //
        // Normally there should be no dirs that are children of this parent
        // but this can happen if a remote co create is executed for a
        // dir at the same time the subtree containing this dir is being
        // moved out of the replica tree (which is why we are here).
        // The journal code removes the filter entries immediately when it
        // detects a moveout so it can skip future file changes in the subtree.
        // So any dir we now find must have come from a remote CO create that
        // occurred between the time when the journal processed the rename for
        // moveout subdir and now when we are processing the resulting dir
        // moveout CO.  We handle this by continuing the delete process on this
        // subidr.  This will also get rid of the orphaned journal filter table
        // entry created when the remote co for this dir create was processed.
        // See comment in JrnlFilterLinkChildNoError().
        //
        LocationCmd = CO_LOCATION_DELETE;
        if (IDTRecIsDirectory(IDTableRec)) {
            LocationCmd = CO_LOCATION_MOVEOUT;
            DBS_DISPLAY_RECORD_SEV(0, TableCtx, TRUE);
            DPRINT(3, "++ Hit a dir during MOVEOUT subdir processing\n");
        }

        //
        // Build a delete or moveout change order entry for the IDtable record.
        // This is a local CO that originates from this member.
        //
        DelCoe = ChgOrdMakeFromIDRecord(IDTableRec,
                                        Replica,
                                        LocationCmd,
                                        CO_FLAG_LOCATION_CMD,
                                        NULL);

        //
        // Set the Jrnl Cxtion Guid and Cxtion ptr for this Local CO.
        //
        INIT_LOCALCO_CXTION_AND_COUNT(Replica, DelCoe);

        //
        // Generate a new Volume Sequnce Number for the change order.
        // But since it gets put on the front of the CO process queue it
        // is probably out of order so set the flag to avoid screwing up
        // dampening.
        //
        NEW_VSN(pVme, &DelCoe->Cmd.FrsVsn);
        DelCoe->Cmd.OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

        //
        // Event time from current time.
        //
        // Note: An alternative is to base this event time on the event time
        //       in the original USN record that initiated the moveout?
        //       Currently there is no compelling reason to change.
        //
        GetSystemTimeAsFileTime((PFILETIME)&DelCoe->Cmd.EventTime.QuadPart);

        //
        // Bump Version number to ensure the CO is accepted.
        //
        DelCoe->Cmd.FileVersionNumber = IDTableRec->VersionNumber + 1;

        //
        // Note: We wouldn't need to mark this CO as out of order if we
        // resequenced all change order VSNs (for new COs only) as they
        // were fetched off the process queue.
        //
        SET_CO_FLAG(DelCoe, CO_FLAG_LOCALCO        |
                            CO_FLAG_MORPH_GEN      |
                            CO_FLAG_OUT_OF_ORDER);
        //
        // Mark this as a MOVEOUT generated Delete CO.  This prevents the
        // CO from being inserted into the INLOG and keeps it from deleting
        // the actual file on the Local Machine.
        //
        SET_COE_FLAG(DelCoe, COE_FLAG_DELETE_GEN_CO);

        SET_CHANGE_ORDER_STATE(DelCoe, IBCO_STAGING_REQUESTED);

        if (LocationCmd == CO_LOCATION_DELETE) {
            CHANGE_ORDER_TRACE(3, DelCoe, "Co Push Moveout DelCo to QHead");
        } else {
            CHANGE_ORDER_TRACE(3, DelCoe, "Co Push Moveout subdir to QHead");
        }

        //
        // Push the IDTable Delete Co onto the head of the queue.
        //
        MoveOutContext->NumFiles += 1;

        WStatus = ChgOrdInsertProcQ(Replica, DelCoe, IPQ_HEAD |
                                                     IPQ_DEREF_CXTION_IF_ERR);
        if (!WIN_SUCCESS(WStatus)) {
            jerr = JET_errNotInitialized;
        }
    }

    return jerr;
}




ChgOrdMoveInDirTreeWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PMOVEIN_CONTEXT             MoveInContext
    )
{
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateDirectory() to touch files
    and cause USN records to be created so the files will be replicated.

    Before the files are touched checks are made against the filename or
    directory name exclusion filters and the directory level.

    The MoveInContext supplies the FID of the parent dir, the pointer to the
    Replica struct and a flag indicating if this is a Directory scan pass
    (if TRUE) or a File Scan Pass (if FALSE).

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    MoveInContext       - global info and state

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "ChgOrdMoveInDirTreeWorker:"


    FILE_BASIC_INFORMATION  FileBasicInfo;
    FILE_INTERNAL_INFORMATION  FileInternalInfo;

    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;

    DWORD                   WStatus;
    NTSTATUS                NtStatus;

    PREPLICA                Replica;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    PVOLUME_MONITOR_ENTRY   pVme;
    ULONG                   LevelCheck;

    BOOL                    FileIsDir;
    BOOL                    Excluded;


    if (FrsIsShuttingDown) {
        DPRINT(0, "++ WARN - Movein aborted; service shutting down\n");
        return ERROR_OPERATION_ABORTED;
    }

    //
    // Filter out temporary files.
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_TEMPORARY) {
        return ERROR_SUCCESS;
    }

    FileIsDir = BooleanFlagOn(DirectoryRecord->FileAttributes,
                              FILE_ATTRIBUTE_DIRECTORY);

    //
    // Choose filter list and level (caller has filtered . and ..)
    //
    Replica = MoveInContext->Replica;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    pVme = Replica->pVme;

    if (FileIsDir) {
        //
        // No dirs at the bottom level in the volume filter table.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit-1;
        MoveInContext->NumDirs++;
    } else {
        //
        // Files are allowed at the bottom level.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit;
        MoveInContext->NumFiles++;
    }

    //
    // If the Level Limit is exceeded then skip the file or dir.
    // Skip files or dirs matching an entry in the respective exclusion list.
    //
    if ((DirectoryLevel >= LevelCheck)) {
        MoveInContext->NumFiltered++;
        return ERROR_SUCCESS;
    }
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;

    LOCK_REPLICA(Replica);
    Excluded = FALSE;

    if (FileIsDir) {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->DirNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->DirNameFilterHead);
        }
    } else {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->FileNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->FileNameFilterHead);
        }
    }

    UNLOCK_REPLICA(Replica);

    if (Excluded) {
        MoveInContext->NumFiltered++;
        return ERROR_SUCCESS;
    }

    //
    // Open the file to get the FID for the local CO.
    // Open with WRITE Access in case we need to write the Object ID.
    // Relative open
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;

    NtStatus = NtCreateFile(
                   &FileHandle,
//                   READ_ACCESS | WRITE_ACCESS | ATTR_ACCESS,
                   READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   NULL,                  // AllocationSize
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                   FILE_OPEN,
                   OPEN_OPTIONS,
                   NULL,                  // EA buffer
                   0);                    // EA buffer size

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "++ ERROR - Skipping %ws: NtCreateFile().", FileName, NtStatus);

        //
        // Could be a file attribute problem.  Get the FID and try again.
        //
        NtStatus = NtCreateFile(&FileHandle,
                                READ_ATTRIB_ACCESS,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                SHARE_ALL,
                                FILE_OPEN,
                                OPEN_OPTIONS,
                                NULL,                  // EA buffer
                                0);                    // EA buffer size

        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1_NT(0, "++ ERROR - Skipping %ws: NtCreateFile()", FileName, NtStatus);

            FileHandle = INVALID_HANDLE_VALUE;
            WStatus = FrsSetLastNTError(NtStatus);
            goto RETURN;
        }

        WStatus = FrsGetFileInternalInfoByHandle(FileHandle, &FileInternalInfo);
        CLEANUP1_WS(0, "++ ERROR - FrsGetFileInternalInfoByHandle(%ws); ",
                    FileName, WStatus, RETURN);

        FRS_CLOSE(FileHandle);

        WStatus = FrsForceOpenId(&FileHandle,
                                  NULL,
                                  pVme,
                                  &FileInternalInfo.IndexNumber.QuadPart,
                                  FILE_ID_LENGTH,
//                                  READ_ACCESS | WRITE_ACCESS | ATTR_ACCESS,
                                  READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                                  ID_OPTIONS,
                                  SHARE_ALL,
                                  FILE_OPEN);

        //
        // File has been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT2(4, "++ %ws (Id %08x %08x) has been deleted\n",
                    FileName, PRINTQUAD(FileInternalInfo.IndexNumber.QuadPart));
            goto RETURN;
        }

        if (!WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

    }

    //
    // Get the file's last write time.
    //
    ZeroMemory(&FileBasicInfo, sizeof(FileBasicInfo));
    NtStatus = NtQueryInformationFile(FileHandle,
                                      &IoStatusBlock,
                                      &FileBasicInfo,
                                      sizeof(FileBasicInfo),
                                      FileBasicInformation);
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT_NT(0, "++ NtQueryInformationFile - FileBasicInformation failed.",
                  NtStatus);
        WStatus = FrsSetLastNTError(NtStatus);
        goto RETURN;
    }

    //
    // Poke the file by setting the last write time.
    //
    FileBasicInfo.LastWriteTime.QuadPart += 1;
    if (!SetFileTime(FileHandle, NULL, NULL, (PFILETIME) &FileBasicInfo.LastWriteTime)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - Unable to set last write time on %ws.", FileName, WStatus);
        goto RETURN;
    }

    FileBasicInfo.LastWriteTime.QuadPart -= 1;
    if (!SetFileTime(FileHandle, NULL, NULL, (PFILETIME) &FileBasicInfo.LastWriteTime)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ ERROR - Unable to set last write time on %ws.", FileName, WStatus);
        goto RETURN;
    }


    FRS_CLOSE(FileHandle);

    return ERROR_SUCCESS;


RETURN:

    if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
        WStatus = ERROR_SUCCESS;
    }

    MoveInContext->NumSkipped++;

    FRS_CLOSE(FileHandle);

    return WStatus;
}


ULONG
ChgOrdMoveInDirTree(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder
    )
{
/*++

Routine Description:

    Walk the Sub dir specified in the MOVEIN Change order and produce change
    orders for each child.

Arguments:

    Replica -- ptr to the replica struct.
    ChangeOrder -- The MoveIn Dir change order.

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "ChgOrdMoveInDirTree:"

    MOVEIN_CONTEXT          MoveInContext;

    ULONG                   WStatus;
    ULONG                   FStatus;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    ULONG                   Level;
    PCHANGE_ORDER_RECORD    CoCmd = &ChangeOrder->Cmd;
    PVOLUME_MONITOR_ENTRY   pVme = Replica->pVme;


    FRS_ASSERT(CoIsDirectory(ChangeOrder));

    //
    // Open the subdir directory that is the root of the MoveIn.
    //
    WStatus = FrsForceOpenId(&FileHandle,
                              NULL,
                              pVme,
                              &ChangeOrder->FileReferenceNumber,
                              FILE_ID_LENGTH,
//                              READ_ACCESS,
                              READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                              ID_OPTIONS,
                              SHARE_ALL,
                              FILE_OPEN);
    CLEANUP1_WS(4, "++ Couldn't force open the fid for %ws;",
                CoCmd->FileName, WStatus, CLEANUP);

    //
    // Get the sub-dir nesting level on this directory.
    // Note - Can only make this call on a local CO that came from the journal.
    // Otherwise get the level from the CO itself.  If this dir was generated
    // elsewhere (like in move in dir tree worker) it may not have gone far
    // enough to make it into the filter table.
    //
    if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_MOVEIN_GEN)) {
        FStatus = JrnlGetPathAndLevel(pVme->FilterTable,
                                      &ChangeOrder->FileReferenceNumber,
                                      &Level);
        CLEANUP_FS(0, "JrnlGetPathAndLevel Failed.", FStatus, CLEANUP);
    } else {
        Level = ChangeOrder->DirNestingLevel;
    }

    //
    // Advance to the next level
    //
    ZeroMemory(&MoveInContext, sizeof(MoveInContext));
    MoveInContext.ParentFileID = ChangeOrder->FileReferenceNumber;
    MoveInContext.Replica = Replica;

    WStatus = FrsEnumerateDirectory(FileHandle,
                                    CoCmd->FileName,
                                    Level,
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                    &MoveInContext,
                                    ChgOrdMoveInDirTreeWorker);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }
    DPRINT4(4, "++ MoveIn dir done: %d dirs; %d files; %d skipped, %d filtered\n",
            MoveInContext.NumDirs, MoveInContext.NumFiles,
            MoveInContext.NumSkipped, MoveInContext.NumFiltered);

    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_CLOSE(FileHandle);

    return WStatus;
}



#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif

ULONG
ChgOrdRetryThread(
    PVOID  FrsThreadCtxArg
)
/*++
Routine Description:

    Entry point for processing inbound change orders that need to be retried.
    This is a command server thread.  It gets its actual command requests
    from the ChgOrdRetryCS queue.  Submitting a request to this queue with
    FrsSubmitCommandServer() starts this thread if it is not already running.

Arguments:

    FrsThreadCtxArg - FrsThread struct.

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdRetryThread:"

    JET_ERR              jerr, jerr1;
    ULONG                WStatus;
    ULONG                FStatus;

    PFRS_THREAD          FrsThread = (PFRS_THREAD)FrsThreadCtxArg;
    PTHREAD_CTX          ThreadCtx;
    PCOMMAND_PACKET      Cmd;
    ULONG                ReplicaNumber;
    TABLE_CTX            TempTableCtx;
    PTABLE_CTX           TableCtx = &TempTableCtx;
    PREPLICA             Replica;
    PCXTION              Cxtion;

    DPRINT(4, "++ IBCO ChgOrdRetryCS processor is starting.\n");


    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &ChgOrdRetryCS);

cant_exit_yet:
    //
    // Allocate a context for Jet to run in this thread.
    //
    ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);

    //
    // Setup a Jet Session returning the session ID in ThreadCtx.
    //
    jerr = DbsCreateJetSession(ThreadCtx);
    if (JET_SUCCESS(jerr)) {

        DPRINT(4,"++ JetOpenDatabase complete\n");
    } else {
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DPRINT_FS(0,"++ ERROR - OpenDatabase failed.  Thread exiting:", FStatus);
        WStatus = ERROR_GEN_FAILURE;
        goto EXIT_THREAD;
    }

    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;


    //
    // Look for command packets with the Replcia and Cxtion args to process.
    //
    while (Cmd = FrsGetCommandServer(&ChgOrdRetryCS)) {

        Replica = CoRetryReplica(Cmd);
        ReplicaNumber = Replica->ReplicaNumber;

        //
        // Init the table ctx and open the inbound log table for this Replica.
        //
        jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNumber, INLOGTablex, NULL);
        if (!JET_SUCCESS(jerr)) {
            FStatus = DbsTranslateJetError(jerr, FALSE);
            DPRINT1_FS(0,"++ ERROR - INLOG open for replica %d failed:",
                       ReplicaNumber, FStatus);
            DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
            continue;
        }

        //
        // Walk through the inbound log looking for change orders to reissue.
        //
        // Clear the retry CO count before making the scan.  If any reissued
        // change orders go thru retry again they bump the count to enable
        // a later re-scan.
        //
        Replica->InLogRetryCount = 0;

        jerr = DbsEnumerateTable2(ThreadCtx,
                                  TableCtx,
                                  ILSequenceNumberIndexx,
                                  ChgOrdRetryWorker,
                                  Cmd,
                                  ChgOrdRetryWorkerPreRead);

        if ((!JET_SUCCESS(jerr)) &&
            (jerr != JET_errRecordNotFound) &&
            (jerr != JET_errNoCurrentRecord) &&
            (jerr != JET_wrnTableEmpty)) {
            DPRINT_JS(0, "++ ERROR - FrsEnumerateTable for ChgOrdRetryThread :", jerr);
        }

        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DPRINT_JS(0,"++ ERROR - JetCloseTable on ChgOrdRetryThread failed:", jerr);

        //
        // If we are restarting a single connection then find
        // Cxtion struct and advance the state to JOINING.
        //
        if (Cmd->Command == FCN_CORETRY_ONE_CXTION) {
            Cxtion = CoRetryCxtion(Cmd);
            LOCK_CXTION_TABLE(Replica);
            //
            // If it is no longer in the Connection Starting state leave it
            // alone else advance to JOINING
            //
            if (CxtionStateIs(Cxtion, CxtionStateScanning)) {
                SetCxtionState(Cxtion, CxtionStateSendJoin);
                //
                // Build cmd pkt with Cxtion GName
                // Submit to Replica cmd server.
                // Calls ReplicaJoinOne() and xlate cxtion GName to ptr
                // Calls SubmitReplicaJoin()
                // Builds Comm pkt for cxtion and call SndCsSubmit() to send it.
                //
                RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_JOIN_CXTION);
            }
            UNLOCK_CXTION_TABLE(Replica);
        }

        //
        // Retire the command.
        //
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);

    }  // End while

    DbsFreeTableCtx(TableCtx, 1);

EXIT_THREAD:

    //
    // No work left.  Close the jet session and free the Jet ThreadCtx.
    //
    jerr = DbsCloseJetSession(ThreadCtx);

    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"++ DbsCloseJetSession error:", jerr);
    } else {
        DPRINT(4,"++ DbsCloseJetSession complete\n");
    }

    ThreadCtx = FrsFreeType(ThreadCtx);

    DPRINT(4, "++ Inbound change order retry thread is exiting.\n");


    //
    // Exit
    //
    FrsExitCommandServer(&ChgOrdRetryCS, FrsThread);

    //
    // A new command packet may have appeared on our queue while we were
    // cleaning up for exiting. The command server subsystem will not
    // allow us to exit until we check the command queue again because
    // we may be the only thread active on the command queue at this time.
    //
    goto cant_exit_yet;
    return ERROR_SUCCESS;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



JET_ERR
ChgOrdRetryWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Inbound log table.
    There are three cases:

    1. A normal retry where all Local COs and remote COs from all inbound
    cxtions are considered (cmd is FCN_CORETRY_ALL_CXTIONS).  If the record is
    marked for retry (has the CO_FLAG_RETRY bit set) then resubmit the CO to try
    and complete it.  The necessary work could be to complete the install,
    or the fetch, or generate a stage file.

    2. A single connection restart/recovery request (FCN_CORETRY_ONE_CXTION).
    In this case the connection is assumed to be inactive and this is part of
    the startup procedure.  Scan the entire inbound log and requeue any change
    order with a matching connection guid.  This ensures these COs are in the
    queue ahead of any new COs that arrive after we join with the inbound
    partner.

    Note - If a remote CO from a partner was in process when the cxtion
    went away and it was a RETRY CO, that CO will not be reissued when the
    FCN_CORETRY_ONE_CXTION" "is processed because the CO is still in the
    active retry table.  Since it is a retry CO it is already out of order
    so it doesn't really matter.  If the dead connection causes it to fail
    it will get retried again later.

    3. Resubmit all Local COs (FCN_CORETRY_LOCAL_ONLY).  This is typically
    only done at Replica set startup where the local COs are restarted
    regardless if they are in a retry state or not.  If this is done at any other
    time we could end up reissuing a CO that is still on its "First Issue"
    because it is not in the ActiveInlogRetry table.  This could cause a Local
    CO to look like a duplicate which will probably ASSERT.


Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an inbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the CO Retry command we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.
    JET_errInvalidObject if table may have changed and the record must be re-read.
    JET_errRecordNotFound when we hit the first record without the retry flag set.

--*/
{
#undef DEBSUB
#define DEBSUB "ChgOrdRetryWorker:"

    ULONG                 FStatus;
    PCOMMAND_PACKET       Cmd = (PCOMMAND_PACKET) Context;
    PCHANGE_ORDER_COMMAND CoCmd = (PCHANGE_ORDER_COMMAND)Record;
    PREPLICA              Replica;
    PVOLUME_MONITOR_ENTRY pVme;
    ULONGLONG             SeqNum;
    PQHASH_TABLE          ActiveInlogRetryTable;
    PCXTION               Cxtion = NULL;
    GUID                  *SingleCxtionGuid = NULL;
    ULONG                 CoeFlags = 0;
    BOOL                  RemoteCo, RetryCo;
    CHAR                  GuidStr[GUID_CHAR_LEN];
    JET_ERR               jerr;

    //
    // Abort retry worker if FRS is shutting down.
    //
    if (FrsIsShuttingDown) {
        return  JET_errTermInProgress;
    }

    Replica = CoRetryReplica(Cmd);
    pVme = Replica->pVme;
    ActiveInlogRetryTable = Replica->ActiveInlogRetryTable;
    GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);

    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    //
    // Get the lock on the Active Retry table.
    //
    QHashAcquireLock(ActiveInlogRetryTable);

    //
    // Check if an inlog record has been deleted (seq num changed).
    // If so then return to re-read the record incase this was the one deleted.
    //
    if (Replica->AIRSequenceNum != Replica->AIRSequenceNumSample) {
        DPRINT2(4, "++ Seq num changed: Sample %08x, Counter %08x -- reread record.\n",
                Replica->AIRSequenceNumSample, Replica->AIRSequenceNum);
        QHashReleaseLock(ActiveInlogRetryTable);
        return JET_errInvalidObject;
    }

    //
    // Check if it's in Active Retry table.  If so then it has not yet
    // finished from a prior retry so we skip it this time.
    //
    SeqNum = (ULONGLONG) CoCmd->SequenceNumber;

    if (QHashLookupLock(ActiveInlogRetryTable, &SeqNum) != NULL) {
        DPRINT1(4, "++ ActiveInlogRetryTable hit on seq num %08x %08x, skipping reissue\n",
               PRINTQUAD(SeqNum));
        DPRINT3(4, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- Active\n",
                PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
        QHashReleaseLock(ActiveInlogRetryTable);
        return JET_errSuccess;
    }

    RemoteCo = !BooleanFlagOn(CoCmd->Flags, CO_FLAG_LOCALCO);
    RetryCo  =  BooleanFlagOn(CoCmd->Flags, CO_FLAG_RETRY);

    //
    // Initialize the Ghost Cxtion. This cxtion is assigned to orphan remote change
    // orders in the inbound log whose cxtion is deleted from the DS but who have already
    // past the fetching state and do not need the cxtion to complete processing. No
    // authentication checks are made for this dummy cxtion.
    //

    if (FrsGhostCxtion == NULL) {
        FrsGhostCxtion = FrsAllocType(CXTION_TYPE);
        FrsGhostCxtion->Name = FrsBuildGName(FrsDupGuid(&FrsGuidGhostCxtion),
                                     FrsWcsDup(L"<Ghost Cxtion>"));
        FrsGhostCxtion->Partner = FrsBuildGName(FrsDupGuid(&FrsGuidGhostCxtion),
                                        FrsWcsDup(L"<Ghost Cxtion>"));
        FrsGhostCxtion->PartSrvName = FrsWcsDup(L"<Ghost Cxtion>");
        FrsGhostCxtion->PartnerPrincName = FrsWcsDup(L"<Ghost Cxtion>");
        FrsGhostCxtion->PartnerDnsName = FrsWcsDup(L"<Ghost Cxtion>");
        FrsGhostCxtion->PartnerSid = FrsWcsDup(L"<Ghost Cxtion>");
        FrsGhostCxtion->PartnerAuthLevel = CXTION_AUTH_NONE;
        FrsGhostCxtion->Inbound = TRUE;
        //
        // Start the ghost connection out as Joined and give it a JOIN guid.
        //
        DPRINT1(0, "***** JOINED    "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, FrsGhostCxtion));
        SetCxtionState(FrsGhostCxtion, CxtionStateJoined);
        COPY_GUID(&FrsGhostCxtion->JoinGuid, &FrsGhostJoinGuid);
        SetCxtionFlag(FrsGhostCxtion, CXTION_FLAGS_JOIN_GUID_VALID |
                              CXTION_FLAGS_UNJOIN_GUID_VALID);
    }

    switch (Cmd->Command) {

    case FCN_CORETRY_LOCAL_ONLY:
        //
        // Skip the remote COs.
        //
        if (RemoteCo) {
            DPRINT3(3, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- Local only\n",
                    PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
            QHashReleaseLock(ActiveInlogRetryTable);
            goto SKIP_RECORD;
        }
        CoeFlags = COE_FLAG_RECOVERY_CO;
        COPY_GUID(&CoCmd->CxtionGuid, &Replica->JrnlCxtionGuid);
        CHANGE_ORDER_COMMAND_TRACE(3, CoCmd, "Co FCN_CORETRY_LOCAL_ONLY");
        break;


    case FCN_CORETRY_ONE_CXTION:
        //
        // Doing single connection restart.  CxtionGuid must match.
        // Don't bother checking cxtion state since we were explicitly told
        // to retry these COs.  Some of these COs may not have the retry
        // flag set since they could be first issue COs when the inbound partner
        // connection died or the system crashed.
        //
        Cxtion = CoRetryCxtion(Cmd);
        SingleCxtionGuid = Cxtion->Name->Guid;
        FRS_ASSERT(Cxtion);

        if ((SingleCxtionGuid != NULL) &&
            !GUIDS_EQUAL(&CoCmd->CxtionGuid, SingleCxtionGuid)) {
                DPRINT3(3, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- Wrong Cxtion\n",
                    PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
                QHashReleaseLock(ActiveInlogRetryTable);
                goto SKIP_RECORD;
        }
        //
        // Mark this as a recovery change order.  This state moderates error
        // checking behavior.  E.G. CO could already be in OutLog which is not
        // an error if this is a recovery / restart CO.
        //
        CoeFlags = COE_FLAG_RECOVERY_CO;
        CHANGE_ORDER_COMMAND_TRACE(3, CoCmd, "Co FCN_CORETRY_ONE_CXTION");
        break;


    case FCN_CORETRY_ALL_CXTIONS:

        //
        // Skip the COs that don't have retry set.  We used to stop the enum
        // when the first CO without retry set was hit.  This does not work
        // because dup COs are marked as retry and they can get traped behind
        // new COs.  When an inlog scan is triggered it clears the scan flag
        // and when the new CO is hit it would stop the scan.  Now the
        // condition is the scan is done, the flag is clear but there are retry
        // COs still in the inlog that need to be processed.  Their inbound
        // partner is still waiting for the ACK so it can delete the staging
        // file (and clear any Ack Vector wrap condition).
        //
        if (!RetryCo) {
            DPRINT3(3, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- Not retry\n",
                    PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
            QHashReleaseLock(ActiveInlogRetryTable);
            goto SKIP_RECORD;
        }

        //
        // If the inbound connection is not JOINED then there is no point in processing it.
        //
        // NOTE: If the connection were to go live during a scan then COs could be
        // retried out of order.  This should not happen because we are called
        // before the connection join begins and the connection won't proceed
        // until we finish the scan and change the connection state.  If later
        // a Retry All is in process when a connection goes to the JOINED state
        // all its COs will be in the Active retry table so they will not be
        // requeued.
        //
        // Perf: Since we don't need the joined connections once the stage file
        //       is fetched we could process those remote COs that are in install
        //       retry or rename retry state but for now keep them in order.
        //
        if (!RemoteCo) {
            //
            // Update the Local Co's connection guid to match current value
            // in case this replica set was stoped and then restarted.
            //
            COPY_GUID(&CoCmd->CxtionGuid, &Replica->JrnlCxtionGuid);
        }

        //
        // Find the inbound cxtion for this CO
        //
        LOCK_CXTION_TABLE(Replica);

        Cxtion = GTabLookupNoLock(Replica->Cxtions, &CoCmd->CxtionGuid, NULL);
        if (Cxtion == NULL) {

            if (CoCmd->State > IBCO_FETCH_RETRY) {

                DPRINT3(2, "++ CO Retry submit, vsn %08x %08x, CoGuid: %s for %ws -- No Cxtion - Using Ghost Cxtion.\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);

                FRS_ASSERT(FrsGhostCxtion != NULL);
                Cxtion = FrsGhostCxtion;
            } else {

                DPRINT3(2, "++ CO Retry delete, vsn %08x %08x, CoGuid: %s for %ws -- No Cxtion - Deleting inlog record.\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);

                jerr = DbsDeleteTableRecord(TableCtx);
                DPRINT1_JS(0, "ERROR - DbsDeleteRecord on %ws :", Replica->ReplicaName->Name, jerr);

                UNLOCK_CXTION_TABLE(Replica);
                QHashReleaseLock(ActiveInlogRetryTable);
                goto SKIP_RECORD;
            }
        }

        FRS_ASSERT(Cxtion->Inbound);
        //
        // We are in the middle of a scan all so we should not see any
        // remote CO with a connection in the JOINING state.  All those
        // COs should have been requeued when the cxtion was in the
        // STARTING State and be in the ActiveInlogRetryTable Table where they
        // are filtered out above.
        //
        // WELL THIS ISN'T QUITE TRUE.
        // There appears to be a case where a previously submitted retry CO
        // for a cxtion is flushed because of an invalid join guid but the
        // cxtion is left in WaitJoin state so when the next FCN_CORETRY_ALL_CXTIONS
        // occurs it is not in the ActiveInlogRetryTable and we trigger the
        // assert.  This might be happening when the join attempt times out
        // and the cxtion state isn't changed to unjoined. Bug 319812 hit this.
        //
        // It looks like there is a potential for COs to get resubmitted out of
        // order when a previous join attempt fails and some COs were delayed
        // behind some other CO that blocked the queue.  In this case we could
        // be in the middle of flushing the old series of COs when the next
        // rejoin starts.  Since some of these could still be in the
        // ActiveInlogRetryTable they won't get resubmitted.  Not sure if this
        // is a real problem though.
        //
        //FRS_ASSERT(!CxtionStateIs(Cxtion, CxtionStateSendJoin) &&
        //           !CxtionStateIs(Cxtion, CxtionStateWaitJoin));

        //
        // If the connection isn't joined then skip the CO.
        // COs for connections in the starting state are processed
        // by a single connection restart request.
        //
        if (!CxtionStateIs(Cxtion, CxtionStateJoined)) {
            if (CoCmd->State > IBCO_FETCH_RETRY) {

                DPRINT3(2, "++ CO Retry submit, vsn %08x %08x, CoGuid: %s for %ws -- Cxtion not joined - Using Ghost Cxtion.\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);

                FRS_ASSERT(FrsGhostCxtion != NULL);
                Cxtion = FrsGhostCxtion;
            } else {
                UNLOCK_CXTION_TABLE(Replica);
                QHashReleaseLock(ActiveInlogRetryTable);
                DPRINT3(2, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- Cxtion not joined\n",
                        PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
                goto SKIP_RECORD;
            }
        }

        UNLOCK_CXTION_TABLE(Replica);

        CHANGE_ORDER_COMMAND_TRACE(3, CoCmd, "Co FCN_CORETRY_ALL_CXTIONS");
        break;


    default:
        DPRINT1(0, "ChgOrdRetryWorker: unknown command 0x%x\n", Cmd->Command);
        DPRINT3(0, "++ CO Retry skip, vsn %08x %08x, CoGuid: %s for %ws -- bad cmd\n",
                PRINTQUAD(CoCmd->FrsVsn), GuidStr, CoCmd->FileName);
        FRS_ASSERT(!"ChgOrdRetryWorker: bad cmd");
        QHashReleaseLock(ActiveInlogRetryTable);
        goto SKIP_RECORD;
    }

    //
    // All COs go into the inlog retry table to lock against reissue by the
    // retry thread.  This is because of the change to the retry thread where
    // we no longer stop the inlog enum when we hit the first CO that is not
    // marked as retry.  See comment above at FCN_CORETRY_ALL_CXTIONS.
    //

    if (!RetryCo) {
        FRS_ASSERT(BooleanFlagOn(CoeFlags, COE_FLAG_RECOVERY_CO));
    }
    QHashInsertLock(ActiveInlogRetryTable, &SeqNum, NULL, 0);

    QHashReleaseLock(ActiveInlogRetryTable);

    CHANGE_ORDER_COMMAND_TRACE(3, CoCmd, "CO Retry Submit");

    DPRINT2(4, "++ ++ CO retry submit for Index %d, State: %s\n",
            CoCmd->SequenceNumber, PRINT_COCMD_STATE(CoCmd));

    //
    // Re-insert the change order into the process queue.
    //
    FStatus = ChgOrdInsertProcessQueue(Replica, CoCmd, CoeFlags, Cxtion);

    return JET_errSuccess;


SKIP_RECORD:
    //
    // The record is being skipped but bump the count so we know to come
    // back and try again later.
    //
    InterlockedIncrement(&Replica->InLogRetryCount);
    return JET_errSuccess;

}



JET_ERR
ChgOrdRetryWorkerPreRead(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to DbsEnumerateTable2().
    It is called before each DB record read operation.
    It is used to change the seek location in the table or to setup
    table access synchronization.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an inbound log context struct.
    Context   - A ptr to the CO Retry command we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "ChgOrdRetryWorkerPreRead:"

    PCOMMAND_PACKET       Cmd = (PCOMMAND_PACKET) Context;
    PREPLICA              Replica = CoRetryReplica(Cmd);

    //
    // Sample the Active Inlog retry sequence number.  If it changes after
    // the DB read then the record may have been deleted from the table and
    // the read must be tried again.
    //
    Replica->AIRSequenceNumSample = Replica->AIRSequenceNum;

    return JET_errSuccess;
}


DWORD
ChgOrdSkipBasicInfoChange(
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN PBOOL                SkipCo
    )
/*++
Routine Description:

    If the changes to the file were unimportant, skip the change order.
    An example of an unimportant change is resetting the archive bit.

Arguments:
    Coe
    SkipCo

Thread Return Value:

    WIN32 STATUS and TRUE if the caller should skip the change order,
    otherwise FALSE.
--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdSkipBasicInfoChange:"
    ULONG                   CocAttrs;
    ULONG                   CoeAttrs;
    ULONG                   CocContentCmd;
    DWORD                   WStatus;
    HANDLE                  Handle;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    //
    // Don't skip it, yet
    //
    *SkipCo = FALSE;

    //
    // Remote Co can't be skipped
    //
    if (!CO_FLAG_ON(Coe, CO_FLAG_LOCALCO)) {
        DPRINT1(4, "++ Don't skip %ws; not local\n", Coc->FileName);
        return ERROR_SUCCESS;
    }

    //
    // Location commands can't be skipped
    //
    if (CO_FLAG_ON(Coe, CO_FLAG_LOCATION_CMD)) {
        DPRINT1(4, "++ Don't skip %ws; location cmd\n", Coc->FileName);
        return ERROR_SUCCESS;
    }

    //
    // No location command *AND* no content changes! Huh?
    //
    if (!CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD)) {
        DPRINT1(4, "++ Don't skip %ws; no content cmd\n", Coc->FileName);
        return ERROR_SUCCESS;
    }

    //
    // Something other than just a basic info change
    //
    CocContentCmd = (Coc->ContentCmd & CO_CONTENT_MASK) &
                     ~USN_REASON_BASIC_INFO_CHANGE;
    if (CocContentCmd) {
        DPRINT2(4, "++ Don't skip %ws; not just basic info change\n",
                Coc->FileName, CocContentCmd);
        return ERROR_SUCCESS;
    }

    //
    // Only ARCHIVE changes can be skipped
    //
    CocAttrs = Coc->FileAttributes &
               ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);
    CoeAttrs = Coe->FileAttributes &
               ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);
    if (CocAttrs != CoeAttrs) {
        DPRINT3(4, "++ Don't skip %ws; not just archive (%08x != %08x)\n",
                Coc->FileName, CocAttrs, CoeAttrs);
        return ERROR_SUCCESS;
    }
    //
    // Check create and write times
    // If can't access the file. The caller should retry later (if possible)
    //
    WStatus = FrsOpenSourceFileById(&Handle,
                                    &FileInfo,
                                    NULL,
                                    Coe->NewReplica->pVme->VolumeHandle,
                                    &Coe->FileReferenceNumber,
                                    FILE_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    CLEANUP1_WS(4, "++ Cannot check basic info changes for %ws;",
                Coc->FileName, WStatus, RETURN);

    FRS_CLOSE(Handle);

    //
    // It is possible for the file attributes to have changed between the
    // time the USN record was processed and now.  Record the current
    // attributes in the change order.  This is especially true for dir
    // creates since while the dir was open other changes may have occurred.
    //
    if (Coc->FileAttributes != FileInfo.FileAttributes) {
        CHANGE_ORDER_TRACEX(3, Coe, "New File Attr= ", FileInfo.FileAttributes);
        Coc->FileAttributes = FileInfo.FileAttributes;

        WStatus = ERROR_SUCCESS;
        if (Coc->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
            WStatus = FrsCheckReparse(Coc->FileName,
                                      (PULONG)&Coe->FileReferenceNumber,
                                      FILE_ID_LENGTH,
                                      Coe->NewReplica->pVme->VolumeHandle);

            if (!WIN_SUCCESS(WStatus)) {
                return WStatus;
            }
        }
    }

    if (FileInfo.CreationTime.QuadPart != Coe->FileCreateTime.QuadPart) {
        DPRINT3(4, "++ Don't skip %ws; create time %08x %08x %08x %08x\n",
                Coc->FileName, PRINTQUAD(FileInfo.CreationTime.QuadPart),
                PRINTQUAD(Coe->FileCreateTime.QuadPart));
        return ERROR_SUCCESS;
    }
    if (FileInfo.LastWriteTime.QuadPart != Coe->FileWriteTime.QuadPart) {
        DPRINT3(4, "++ Don't skip %ws; write time %08x %08x %08x %08x\n",
                Coc->FileName, PRINTQUAD(FileInfo.LastWriteTime.QuadPart),
                PRINTQUAD(Coe->FileWriteTime.QuadPart));
        return ERROR_SUCCESS;
    }

    //
    // SKIP IT
    //
    DPRINT1(0, "++ Skip local co for %ws\n", Coc->FileName);
    *SkipCo = TRUE;

RETURN:
    return WStatus;
}


DWORD
ChgOrdHammerObjectId(
    IN        PWCHAR                Name,
    IN        PVOID                 Id,
    IN        DWORD                 IdLen,
    IN        PVOLUME_MONITOR_ENTRY pVme,
    IN        BOOL                  CallerSupplied,
    OUT       USN                   *Usn,
    IN OUT    PFILE_OBJECTID_BUFFER FileObjID,
    IN OUT    BOOL                  *ExistingOid
    )
/*++
Routine Description:

    Hammer an object id onto the file by fid. The open-for-write-access
    is retried several times before giving up. The file's attributes
    may be temporarily reset.

Arguments:
    Name            - File name for error messages
    Id              - Fid or Oid
    pVme            - volume monitor entry
    CallerSupplied  - TRUE if caller is supplying object id
    Usn             - Address for dampened usn
    FileObjID       - New object id if CallerSupplied is TRUE.
                      Assigned object id if returning ERROR_SUCCESS
    ExistingOid -- INPUT:  TRUE means use existing File OID if found.
                   RETURN:  TRUE means an existing File OID was used.

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdHammerObjectId:"

    DWORD       WStatus;
    ULONG       RetrySetObjectId;
    HANDLE      Handle;
    BOOL        OidMatch = FALSE;

    DPRINT3(5, "++ Attempting to hammer object id for %ws Id 0x%08x 0x%08x (%d bytes)\n",
            Name, PRINTQUAD((*((PULONGLONG)Id))), IdLen);


    //
    // For proper cleanup in the event of failure
    //
    Handle = INVALID_HANDLE_VALUE;

    //
    // Attempt to open the file for write access
    //
    // The loop is repeated 10 times with a .1 second sleep between cycles
    //
    for (RetrySetObjectId = 0;
         RetrySetObjectId <= MAX_RETRY_SET_OBJECT_ID;
         ++RetrySetObjectId, Sleep(100)) {

        //
        // FIRST see if the object id is already on the file
        //

        WStatus = FrsOpenSourceFileById(&Handle,
                                        NULL,
                                        NULL,
                                        pVme->VolumeHandle,
                                        Id,
                                        IdLen,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        //
        // File has been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT2(4, "++ %ws (Id %08x %08x) has been deleted\n",
                    Name, PRINTQUAD(*((PULONGLONG)Id)));
            return WStatus;
        }

        if (!WIN_SUCCESS(WStatus)) {
            //
            // We are having problems...
            //
            DPRINT3_WS(4, "++ Problems opening %ws (Id %08x %08x) for read hammer (loop %d);",
                    Name, PRINTQUAD(*((PULONGLONG)Id)), RetrySetObjectId, WStatus);
            continue;
        }
        if (CallerSupplied) {
            WStatus = FrsCheckObjectId(Name,
                                       Handle,
                                       (GUID *)&FileObjID->ObjectId[0]);
            OidMatch = WIN_SUCCESS(WStatus);
        } else {
            WStatus = FrsGetObjectId(Handle, FileObjID);
        }
        if (WIN_SUCCESS(WStatus)) {
            WStatus = FrsReadFileUsnData(Handle, Usn);
        }
        FRS_CLOSE(Handle);

        //
        // If an object id is already on the file and we are keeping them
        // then we're done.
        //
        if (OidMatch || (ExistingOid && WIN_SUCCESS(WStatus))) {
            DPRINT2(4, "++ Using existing oid for %ws (Id %08x %08x)\n",
                    Name, PRINTQUAD((*((PULONGLONG)Id))) );
            *ExistingOid = TRUE;
            return WStatus;
        } else
        if (!CallerSupplied && !ExistingOid) {
            //
            // Set up to slam a new OID on the file.
            //
            CallerSupplied = TRUE;
            ZeroMemory(FileObjID, sizeof(FILE_OBJECTID_BUFFER));
            FrsUuidCreate((GUID *)FileObjID->ObjectId);
        }

        //
        // HAMMER THE OBJECT ID
        //
        *ExistingOid = FALSE;

        //
        // Open the file for write access
        //
        // overlap disables (FILE_SYNCHRONOUS_IO_NONALERT) during
        // the following open. Hence I think this causes IO_PENDING
        // to be returned by GetOrSetObjectId() below.
        // I am disabling oplocks for now.
        //
        WStatus = FrsForceOpenId(&Handle,
                                  NULL, // use oplock when safe
                                  pVme,
                                  Id,
                                  IdLen,
//                                  READ_ACCESS | WRITE_ACCESS | ATTR_ACCESS,
//                                  STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                  READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                                  ID_OPTIONS,
                                  SHARE_ALL,
                                  FILE_OPEN);
        //
        // File has been opened for write access; hammer the object id
        //
        if (WIN_SUCCESS(WStatus)) {
            break;
        }

        //
        // File has been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            CLEANUP2_WS(4, "++ %ws (Id %08x %08x) has been deleted :",
                        Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus, RETURN);
        }

        //
        // We are having problems...
        //
        DPRINT3_WS(4, "++ Problems opening %ws (Fid %08x %08x) for hammer (loop %d);",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), RetrySetObjectId, WStatus);
    }

    //
    // Couldn't open the file
    //
    CLEANUP2_WS(0, "++ ERROR - Giving up on %ws (Id %08x %08x):",
                Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus, RETURN);

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(pVme->VolumeHandle, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, "++ WARN - FrsMarkHandle(%ws (Id %08x %08x));",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Get or set the object ID.
    //
    WStatus = FrsGetOrSetFileObjectId(Handle, Name, CallerSupplied, FileObjID);


#if 0
    //
    // WARN - Even though we marked the handle above we are not seeing the source
    // info data in the USN journal.  The following may be affecting it.
    // SP1:
    // In any case the following does not work because the Journal thread
    // can process the close record before this thread is able to update the
    // Write Filter.  The net effect is that we could end up processing
    // an install as a local CO update and re-replicate the file.
    //
    FrsCloseWithUsnDampening(Name, &Handle, pVme->FrsWriteFilter, Usn);
#endif
    // Not the USN of the close record but.. whatever.
    if (Usn != NULL) {
        FrsReadFileUsnData(Handle, Usn);
    }
    FRS_CLOSE(Handle);


    //
    // Couldn't set object id
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, "++ ERROR - Cannot hammer object id for %ws (Id %08x %08x) :",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        //
        // Just to make sure the error code doesn't imply a deleted file
        // BUT don't remap ERROR_DUP_NAME because the callers of this
        // function may key off this error code and retry this operation
        // after stealing the object id from another file.
        //
        // We do not want to mask the error if it is a retriable error.
        // E.g. A DISK_FULL condition will cause the above FrsGetOrSetFileObjectId
        // call to fail. We do not want StageCsCreateStage to sbort this
        // local CO on that error. Masking a retriable error will cause
        // StageCsCreateStage to abort such COs. (Bug 164114)
        //
        if ((WStatus != ERROR_DUP_NAME) && !WIN_RETRY_STAGE(WStatus)) {
            WIN_SET_FAIL(WStatus);
        }
    }

RETURN:
    return WStatus;
}


DWORD
ChgOrdStealObjectId(
    IN     PWCHAR                   Name,
    IN     PVOID                    Fid,
    IN     PVOLUME_MONITOR_ENTRY    pVme,
    OUT    USN                      *Usn,
    IN OUT PFILE_OBJECTID_BUFFER    FileObjID
    )
/*++
Routine Description:

    Hammer an object id onto the file by fid. The open-for-write-access
    is retried several times before giving up. The file's attributes
    may be temporarily reset. If some other file is using our object
    id, assign a new object id to the other file.

Arguments:
    Name            - File name for error messages
    Id              - Fid or Oid
    IdLen           - FILE_ID_LENGTH or OBJECT_ID_LENGTH
    pVme            - volume monitor entry
    Usn             - Address for dampened usn
    FileObjID       - New object id
                      Assigned object id if returning ERROR_SUCCESS

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdStealObjectId:"
    DWORD                   WStatus;
    FILE_OBJECTID_BUFFER    NewFileObjID;
    BOOL                    ExistingOid;

RETRY_HAMMER:
    //
    // Hammer the object id to the desired value
    //
    DPRINT2(5, "++ Hammering object id for %ws (Fid %08x %08x)\n",
            Name, PRINTQUAD((*((PULONGLONG)Fid))));


    ExistingOid = FALSE;
    WStatus = ChgOrdHammerObjectId(Name,                        //Name,
                                   Fid,                         //Id,
                                   FILE_ID_LENGTH,              //IdLen,
                                   pVme,                        //pVme,
                                   TRUE,                        //CallerSupplied
                                   Usn,                         //*Usn,
                                   FileObjID,                   //FileObjID,
                                   &ExistingOid);               //*ExistingOid
    //
    // Object id in use; replace the object id on whatever file is claiming it
    //
    if (WStatus == ERROR_DUP_NAME) {
        DPRINT2(4, "++ Stealing object id for %ws (Fid %08x %08x)\n",
                Name, PRINTQUAD((*((PULONGLONG)Fid))));

        ZeroMemory(&NewFileObjID, sizeof(NewFileObjID));
        FrsUuidCreate((GUID *)(&NewFileObjID.ObjectId[0]));
        ExistingOid = FALSE;

        WStatus = ChgOrdHammerObjectId(Name,                    //Name,
                                       &FileObjID->ObjectId[0], //Id,
                                       OBJECT_ID_LENGTH,        //IdLen,
                                       pVme,                    //pVme,
                                       TRUE,                    //CallerSupplied
                                       Usn,                     //*Usn,
                                       &NewFileObjID,           //FileObjID,
                                       &ExistingOid);           //*ExistingOid
        if (WIN_SUCCESS(WStatus)) {
            DPRINT2(4, "++ Success Stealing object id for %ws (Fid %08x %08x)\n",
                    Name, PRINTQUAD((*((PULONGLONG)Fid))));
            goto RETRY_HAMMER;
        } else {
            DPRINT2_WS(0, "++ ERROR - Could not steal object id for %ws (Fid %08x %08x);",
                    Name, PRINTQUAD((*((PULONGLONG)Fid))), WStatus);
        }
    } else {
        DPRINT2_WS(4, "++ Hammer(%ws, Fid %08x %08x) Failed:",
                   Name, PRINTQUAD((*((PULONGLONG)Fid))), WStatus);
    }

    return WStatus;
}


ULONG
ChgOrdAcceptInitialize(
    VOID
    )
/*++
Routine Description:

    Initialize the send command server subsystem.

Arguments:

    None.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdAcceptInitialize:"

    //
    // Create the File System monitor thread.  It inits its process queue
    // and then waits for a packet.  First packet should be to init.
    //
    if (!ThSupCreateThread(L"COAccept", NULL, ChgOrdAccept, ThSupExitThreadNOP)) {

        DPRINT(0, "++ ERROR - Could not create ChgOrdAccept thread\n");
        return FrsErrorResource;
    }

    return FrsErrorSuccess;
}


VOID
ChgOrdAcceptShutdown(
    VOID
    )
/*++
Routine Description:

    Run down the change order list.
    queue a shutdown change order to the process queue for this volume.

Arguments:

    None.

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdAcceptShutdown:"

    LIST_ENTRY      RunDown;

    DPRINT1(3, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    FrsRtlRunDownQueue(&FrsVolumeLayerCOQueue, &RunDown);
    ChangeOrderAcceptIsShuttingDown = TRUE;
}






#if 0
DWORD
ChgOrdTestJournalPause(
    PVOID  FrsThreadCtxArg
    )
/*++
Routine Description:

    Entry point for test thread that pauses and unpauses the Journal.

Arguments:

    FrsThreadCtxArg - thread

Return Value:

    WIN32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "ChgOrdTestJournalPause:"


    PVOLUME_MONITOR_ENTRY pVme;
    ULONG i, Select, WStatus;;


    //
    // Wait till we see a completion port for the journal.
    //
    while (!HANDLE_IS_VALID(JournalCompletionPort)) {
        Sleep(1000);
    }

    Sleep(3000);

    while (TRUE) {

        for (i=0; i<FrsRtlCountQueue(&VolumeMonitorQueue); i++) {
            //
            // Every 3 sec get an entry from the VolumeMonitorQueue
            // and pause its journal for 5 seconds.
            //
            Select = i;
            pVme = NULL;
            ForEachListEntry(&VolumeMonitorQueue, VOLUME_MONITOR_ENTRY, ListEntry,
                pVme = pE;
                if ((Select--) == 0) {
                    break;
                }
            );

            if (pVme != NULL) {
                DPRINT(4, "Pausing the volume ----------------------\n");
                WStatus = JrnlPauseVolume(pVme, 5000);
                DPRINT_WS(0, "Status from Pause", WStatus);

                if (WIN_SUCCESS(WStatus)) {
                    DPRINT(4, "Delaying 3 sec ----------------------\n");
                    Sleep(3000);

                    DPRINT(4, "Unpausing the volume ----------------------\n");

                    pVme->JournalState = JRNL_STATE_STARTING;
                    WStatus = JrnlUnPauseVolume(pVme, NULL, FALSE);

                    DPRINT_WS(0, "Status from Unpause", WStatus);
                    DPRINT(4, "Delaying 1 sec ----------------------\n");
                    Sleep(1000);

                }

                if (!WIN_SUCCESS(WStatus)) {
                    DPRINT(0, "Error Abort-----------------------------\n");
                    return 0;
                }

            }
        }
    }

    return 0;
}
#endif 0



ULONG
ChgOrdInsertRemoteCo(
    IN PCOMMAND_PACKET Cmd,
    IN PCXTION         Cxtion
    )
/*++
Routine Description:

    This is how remote change orders arrive for input acceptance processing.
    The communication layer calls this routine to insert the remote
    change order on the volume change order list used by this Replica
    set.  Allocate a change order entry and copy the change order command
    into it.

Arguments:

    Cmd -- The command packet containing the change order command.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertRemoteCo:"

    PREPLICA Replica;
    PCHANGE_ORDER_COMMAND CoCmd;

    Replica = RsReplica(Cmd);
    CoCmd = RsPartnerCoc(Cmd);

    //
    // Increment the Remote Change Orders Received Variable for both the
    // replica set and the connection.
    //
    PM_INC_CTR_REPSET(Replica, RCOReceived, 1);
    PM_INC_CTR_CXTION(Cxtion, RCOReceived, 1);

    //
    // Mark this as a remote change order and insert it into the process queue.
    // A zero value for the SequenceNumber tells the cleanup code that the
    // CO was never inserted into the ActiveInlogRetryTable which happens
    // if the CO is rejected on the first attempt.
    //
    CoCmd->SequenceNumber = 0;
    ClearFlag(CoCmd->Flags, CO_FLAG_NOT_REMOTELY_VALID);
    CoCmd->Spare1Wcs = NULL;
    CoCmd->Spare2Wcs = NULL;
    CoCmd->Spare2Bin = NULL;


    SET_CHANGE_ORDER_STATE_CMD(CoCmd, IBCO_INITIALIZING);

    return ChgOrdInsertProcessQueue(RsReplica(Cmd), CoCmd, 0, Cxtion);
}


ULONG
ChgOrdInsertProcessQueue(
    IN PREPLICA Replica,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    IN ULONG CoeFlags,
    IN PCXTION Cxtion
    )
/*++
Routine Description:

    Insert the Change order into the volume process queue for input
    acceptance processing.  This could be a remote change order or a retry of
    either a local or remote CO.  Allocate a change order entry and copy the
    change order command into it.  Translate what we can to local member
    information.

    The change order process thread handles the GUID to FID translations
    since the since it already has the database tables open and it would
    tie up our caller's thread to do it here.

    The NewReplica field of the change order command is set to the pointer
    to the Replica struct.

Arguments:

    Replica -- ptr to replica struct.

    CoCmd -- ptr to change order command to submit.

    CoeFlags -- Additional control flags to OR into Coe->EntryFlags.

    Cxtion - The cxtion that received the remote co

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdInsertProcessQueue:"

    ULONG WStatus, FStatus;
    ULONG ExtSize;
    PCHANGE_ORDER_ENTRY ChangeOrder = NULL;
    BOOL Activated, Executed;
    PULONG  pULong;
    PDATA_EXTENSION_RETRY_TIMEOUT CoCmdRetryTimeout;
    LONGLONG              CurrentTime;

    //
    // If this is a change order retry we may already have a change order
    // entry sitting in the Version Vector retire list.  If so, find it,
    // get a reference and use that one (if the connection Guid matches).
    // This way if we end up aborting we can discard the VV retire slot
    // and not propagate the CO to the outbound log.  We can also accurately
    // determine the state of the VV retire executed flag.
    //
    // The following table relates the state of the VV retire activated and
    // executed flags in the change order being retried with its presence on
    // the VV retire list.
    //
    // Found   INLog Retry
    // On List    State
    //       Activated
    //              Executed   Description
    //   y      y      y       DB update beat the retry read but entry
    //                         is still on the VV retire list.  Use Reference.
    //   y      y      n       DB read beat the update.  Use Reference.
    //   y      n      y       Error - Can't have exec set w/o activate.
    //   y      n      n       Error - Not activated. Shouldn't be on list.
    //   n      y      y       DB update beat the read & list entry removed.
    //   n      y      n       DB read beat the update but then update completed
    //                         & list entry deleted before retry could get the
    //                         reference.  Set Executed flag new CO for retry.
    //   n      n      y       Error.  Can't have exec set w/o activate.
    //   n      n      n       OK.  CO didn't make it far enough last time
    //                         to activate the VV slot.
    //
    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_RETRY)) {
        Executed = BooleanFlagOn(CoCmd->IFlags, CO_IFLAG_VVRETIRE_EXEC);
        Activated  = BooleanFlagOn(CoCmd->Flags, CO_FLAG_VV_ACTIVATED);

        if (!Activated && Executed) {
            DPRINT(0, "++ ERROR - Retry CO has CO_IFLAG_VVRETIRE_EXEC flag set but"
                      " CO_FLAG_VV_ACTIVATED is clear.\n");
            FRS_ASSERT(!"ChgOrdInsertProcessQueue: CO_IFLAG_VVRETIRE_EXEC flag set, CO_FLAG_VV_ACTIVATED is clear");
        }

        ChangeOrder = VVReferenceRetireSlot(Replica, CoCmd);

        if (ChangeOrder != NULL) {
            if (!Activated) {
                DPRINT(0, "++ ERROR - Retry CO has CO_FLAG_VV_ACTIVATED flag clear"
                          " but is on the VV retire list.\n");
                FRS_ASSERT(!"ChgOrdInsertProcessQueue: CO_FLAG_VV_ACTIVATED is clear but is on the VV retire list");
            }
        } else {
            //
            // If CO_FLAG_VV_ACTIVATED is set then set CO_IFLAG_VVRETIRE_EXEC.
            // Since we didn't find the slot on the VV retire list it must have
            // been retired while this CO was waiting for retry in the INLOG.
            // This is only true if this is not a change order submitted as
            // part of recovery.  With a recovery CO there may be no entry
            // so leave the bits alone.
            //
            // NO, IGNORE RECOVERY FLAG!
            // CO_FLAG_VV_ACTIVATED prevents this co from reserving a slot
            // and from being activated during retire. Hence, the slot
            // has been effectively executed. The executed flag should be
            // set so that the INSTALL_INCOMPLETE bit can be turned off in
            // the outbound log. So ignore the recovery flag.
            //
            // Although, David thought that the original intent of the
            // check was to help recover from crashes. In that case,
            // "Activated but not Executed" implies that the co was not
            // propagated to the outlog. However, not setting _EXEC
            // doesn't help that case since Activated prevents outlog
            // insertion. It might help to clear _ACTIVATED in this case
            // instead of setting _EXEC. Of course, the co may have
            // made it into the outlog so be prepared for dup errors.
            //
            // WARN: inlog cos may not be propagated to outlog during crash recovery.
            //
            // if (Activated && !Executed &&
            //     !BooleanFlagOn(CoeFlags, COE_FLAG_RECOVERY_CO)) {
            if (Activated && !Executed) {
                SetFlag(CoCmd->IFlags, CO_IFLAG_VVRETIRE_EXEC);
            }
        }
    }

    if (ChangeOrder == NULL) {

        //
        // Allocate a change order entry with room for the filename and copy
        // the change order + Filename into it.  Init the ref count to one
        // since the CO is going on the process queue.
        //
        ChangeOrder = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
        CopyMemory(&ChangeOrder->Cmd, CoCmd, sizeof(CHANGE_ORDER_COMMAND));
        ChangeOrder->Cmd.Extension = NULL;
        ChangeOrder->UFileName.Length = ChangeOrder->Cmd.FileNameLength;
        ChangeOrder->HashEntryHeader.ReferenceCount = 0;
        INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);  // for tracking

        //
        // Copy the Change Order Extension if provided.
        //
        ExtSize = sizeof(CHANGE_ORDER_RECORD_EXTENSION);

        if ((CoCmd->Extension != NULL) &&
            (CoCmd->Extension->FieldSize > 0)) {

            if (CoCmd->Extension->FieldSize >= REALLY_BIG_EXTENSION_SIZE) {
                pULong = (PULONG) CoCmd->Extension;

                DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                           pULong, *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3));
                DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                           (PCHAR)pULong+16, *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));

                FRS_ASSERT(!"CoCmd->Extension->FieldSize corrupted");
            }

            //
            // Convert the CO_RECORD_EXTENSION_WIN2K struct from downlevel members
            // to a CHANGE_ORDER_RECORD_EXTENSION struct that we understand.
            //
            if (CoCmd->Extension->Major == CO_RECORD_EXTENSION_VERSION_WIN2K) {

                ChangeOrder->Cmd.Extension =
                    DbsDataConvertCocExtensionFromWin2K((PCO_RECORD_EXTENSION_WIN2K)CoCmd->Extension);
            } else {
                //
                // If incoming CO has larger extension, use it.
                //
                if (ExtSize < CoCmd->Extension->FieldSize) {
                    ExtSize = CoCmd->Extension->FieldSize;
                }

                ChangeOrder->Cmd.Extension = FrsAlloc(ExtSize);
                CopyMemory(ChangeOrder->Cmd.Extension, CoCmd->Extension, ExtSize);
            }
        } else {
            //
            // Incoming extension NULL or Field Size zero.  Init new one.
            //
            ChangeOrder->Cmd.Extension = FrsAlloc(ExtSize);
            DbsDataInitCocExtension(ChangeOrder->Cmd.Extension);
        }

        CoCmdRetryTimeout = DbsDataExtensionFind(ChangeOrder->Cmd.Extension, DataExtend_Retry_Timeout);

        if(CoCmdRetryTimeout != NULL) {
            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

            //
            // if this is the first time through, set the time.
            //
            if(CoCmdRetryTimeout->Count == 0) {
                CoCmdRetryTimeout->FirstTryTime = CurrentTime;
            }
        }
    }



    //
    // MOVERS is only for local ChangeOrders.  They are transformed into
    // a delete and create change orders targeted to their respective
    // replica sets.
    //
    if (CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_MOVERS)) {
        DPRINT(0, "++ ERROR - change order command is MOVERS.");
        FRS_PRINT_TYPE(0, ChangeOrder);
        FrsFreeType(ChangeOrder);
        return FrsErrorInvalidChangeOrder;
    }

    //
    // Save ptr to target replica struct.
    //
    ChangeOrder->NewReplica = Replica;
    ChangeOrder->Cmd.NewReplicaNum = ReplicaAddrToId(Replica);
    //
    // We will never see a remotely generated MOVERS.  We always
    // see a delete to the old RS followed by a create in the
    // new RS.  So set both replica ptrs to our Replica struct.
    //
    // Note: MOVERS:  This may not work for a LocalCo retry of a MOVERS.
    ChangeOrder->OriginalReplica = Replica;
    ChangeOrder->Cmd.OriginalReplicaNum = ReplicaAddrToId(Replica);

    FRS_ASSERT( CO_STATE(ChangeOrder) < IBCO_MAX_STATE );

    SET_COE_FLAG(ChangeOrder, CoeFlags);

    //
    // Put the change order on the tail end of the volume change order list.
    //
    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)     &&
        !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY      |
                                 CO_FLAG_CONTROL    |
                                 CO_FLAG_MOVEIN_GEN |
                                 CO_FLAG_MORPH_GEN)  &&
        !RecoveryCo(ChangeOrder)                     &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) {

        INC_LOCAL_CO_QUEUE_COUNT(Replica);
    }

    //
    // Pick up the cxtion's join guid (session id). The change orders
    // will be sent back through the retry path if the cxtion's
    // state has changed by the time the change orders make it
    // to the replica command server. The join guid is used for
    // asserting that we never have a change order for a joined
    // cxtion with a mismatched join guid.
    //
    // The count of remote change orders is used when transitioning
    // the cxtion from UNJOINING to UNJOINED. Further requests to
    // join are ignored until the transition. Basically, we are
    // waiting for the change orders to be put into the retry state
    // for later recovery.
    //
    // Synchronize with change order accept and the replica command server
    //
    if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {
        //
        // This change order may already have a cxtion if it was
        // pulled from the active retry table and there is no
        // guarantee that the change order in the table is from
        // the same cxtion as this change order since the table
        // is sorted by change order guid.
        //
        if (ChangeOrder->Cxtion == NULL) {
            ChangeOrder->Cxtion = Cxtion;
        }
        FRS_ASSERT(ChangeOrder->Cxtion);

        //
        // Bump the change order count associated with this connection.
        // Any change order with a non-NULL ChangeOrder->Cxtion will have
        // its remote change order count decremented at issue cleanup.
        // The count applies to control change orders too.
        //
        LOCK_CXTION_TABLE(Replica);
        INCREMENT_CXTION_CHANGE_ORDER_COUNT(Replica, ChangeOrder->Cxtion);
        UNLOCK_CXTION_TABLE(Replica);

    } else {
        //
        // Set the Jrnl Cxtion Guid and Cxtion ptr for this Local CO.
        // This bumps the Cxtion CO count.
        // Any change order with a non-NULL ChangeOrder->Cxtion will have
        // its remote change order count decremented at issue cleanup.
        // This GUID changes each time the service starts the replica set.
        //
        ChangeOrder->Cmd.CxtionGuid = Replica->JrnlCxtionGuid;
        ACQUIRE_CXTION_CO_REFERENCE(Replica, ChangeOrder);

        if (ChangeOrder->Cxtion == NULL) {
            return FrsErrorInvalidChangeOrder;
        }
    }

    //
    // Refresh the Join Guid.
    //
    ChangeOrder->JoinGuid = ChangeOrder->Cxtion->JoinGuid;

    WStatus = ChgOrdInsertProcQ(Replica, ChangeOrder, IPQ_TAIL | IPQ_DEREF_CXTION_IF_ERR);
    if (!WIN_SUCCESS(WStatus)) {
        SET_ISSUE_CLEANUP(ChangeOrder, ISCU_FREE_CO | ISCU_DEC_CO_REF);
        FStatus = ChgOrdIssueCleanup(NULL, Replica, ChangeOrder, 0);
        DPRINT_FS(0, "++ ChgOrdIssueCleanup error.", FStatus);
        return FrsErrorInternalError;
    }

    return FrsErrorSuccess;

}


VOID
ChgOrdStartJoinRequest(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
    )
/*++
Routine Description:

    An inbound connection wants to start up.  Submit a control change order
    that will scan the inlog and requeue any pending COs from this connection.

Arguments:

    Replica -- The replica set owning the connection.
    Cxtion  -- the connection being started.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdStartJoinRequest:"

    CHANGE_ORDER_COMMAND CoCmd;
    //
    // Mark this as a control change order and insert it into the process queue.
    // When it gets to the head of the queue we know all COs from this Cxtion
    // that may have been ahead of it in the queue are now in the inbound Log.
    //
    // Use a temp CoCmd since it gets copied into the change order entry when
    // it is inserted onto the process queue.
    //
    ZeroMemory( &CoCmd, sizeof(CHANGE_ORDER_COMMAND));

    CoCmd.ContentCmd = FCN_CORETRY_ONE_CXTION;
    COPY_GUID(&CoCmd.CxtionGuid, Cxtion->Name->Guid);

    SetFlag(CoCmd.Flags, CO_FLAG_CONTROL);

    wcscpy(CoCmd.FileName, L"VVJoinStartRequest");  // for tracing.

    SET_CHANGE_ORDER_STATE_CMD(&CoCmd, IBCO_INITIALIZING);

    ChgOrdInsertProcessQueue(Replica, &CoCmd, 0, Cxtion);

    return;
}



PCHANGE_ORDER_ENTRY
ChgOrdMakeFromFile(
    IN PREPLICA       Replica,
    IN HANDLE         FileHandle,
    IN PULONGLONG     ParentFid,
    IN ULONG          LocationCmd,
    IN ULONG          CoFlags,
    IN PWCHAR         FileName,
    IN USHORT         Length
)
/*++

Routine Description:

    This functions allocates a change order entry and inits some of the fields.

    Depending on the change order some of these fields may be overwritten later.

    Example Call:

    //
    // Allocate and init a local change order using the supplied file handle.
    //
    //NewCoe = ChgOrdMakeFromFile(Replica,
    //                            FileHandle,
    //                            &MoveInContext->ParentFileID,
    //                            CO_LOCATION_MOVEIN,
    //                            CO_FLAG_LOCALCO | CO_FLAG_LOCATION_CMD,
    //                            DirectoryRecord->FileName,
    //                            (USHORT)DirectoryRecord->FileNameLength);

Arguments:

    Replica - ptr to replica set for this change order.
    FileHandle - The open file handle.
    ParentFid - The parent file reference number for this file.
    LocationCmd -- A Create, delete, ... change order.
    CoFlags  --  The change order option flags.  see schema.h
    FileName - Filename for this file.  For a sub tree op it comes from the
               filter entry.
    Length - the file name length in bytes.

Return Value:

    ptr to change order entry.  NULL if can't get file info.

--*/

{
#undef DEBSUB
#define DEBSUB  "ChgOrdMakeFromFile:"

    DWORD WStatus;

    FILE_INTERNAL_INFORMATION  FileInternalInfo;

    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    BOOL IsDirectory;
    PCHANGE_ORDER_ENTRY ChangeOrder;
    PCHANGE_ORDER_COMMAND   Coc;
    PCONFIG_TABLE_RECORD    ConfigRecord;

    //
    // Get the file's attributes
    //
    if (!FrsGetFileInfoByHandle(FileName, FileHandle, &FileInfo)) {
        DPRINT1(4, "++ Can't get attributes for %ws\n", FileName);
        return NULL;
    }

    //
    // Get the fid of preinstall area for filtering.
    //
    WStatus = FrsGetFileInternalInfoByHandle(Replica->PreInstallHandle,
                                             &FileInternalInfo);
    DPRINT_WS(0, "++ ERROR - FrsGetFileInternalInfoByHandle(PreInstallDir).", WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        return NULL;
    }

    IsDirectory = (FileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

    //
    // Note: This function is currently (11/19/98) unused.  If it is ever used,
    // and the change order allocated below turns out to be a local CO,
    // remember to set the JrnlCxtion field of the change order command
    //
    // Construct new change order and allocate a change order extension.
    //
    ChangeOrder = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
    ChangeOrder->Cmd.Extension = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
    DbsDataInitCocExtension(ChangeOrder->Cmd.Extension);

    Coc = &ChangeOrder->Cmd;

    //
    // Set the initial reference count to 1.
    //
    INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);

    //
    //  Capture the file name.
    //
    FRS_ASSERT(Length <= MAX_PATH*2);
    CopyMemory(ChangeOrder->Cmd.FileName, FileName, Length);
    Coc->FileName[Length/2] = UNICODE_NULL;
    ChangeOrder->UFileName.Length = Length;
    Coc->FileNameLength = Length;

    //
    //  Set New and orig Replica fields to the replica.
    //
    ChangeOrder->OriginalReplica = Replica;
    ChangeOrder->NewReplica      = Replica;
    Coc->OriginalReplicaNum = ReplicaAddrToId(ChangeOrder->OriginalReplica);
    Coc->NewReplicaNum      = ReplicaAddrToId(ChangeOrder->NewReplica);

    //
    //  Set New and orig parent FID fields to the parent FID.
    //
    ChangeOrder->OriginalParentFid   = *ParentFid;
    ChangeOrder->NewParentFid        = *ParentFid;
    ChangeOrder->FileReferenceNumber = FileInternalInfo.IndexNumber.QuadPart;
    ChangeOrder->ParentFileReferenceNumber = *ParentFid;

    //
    // EntryCreateTime is a tick count for aging.
    //
    ChangeOrder->EntryCreateTime = CO_TIME_NOW(Replica->pVme);

    //
    // Event time from current time.
    //
    GetSystemTimeAsFileTime((PFILETIME)&Coc->EventTime.QuadPart);

    //
    // File's attributes, Create time, Write time
    //
    ChangeOrder->FileAttributes = FileInfo.FileAttributes;

    Coc->FileAttributes = FileInfo.FileAttributes;

    ChangeOrder->FileCreateTime = FileInfo.CreationTime;
    ChangeOrder->FileWriteTime  = FileInfo.LastWriteTime;

    Coc->FileSize = FileInfo.AllocationSize.QuadPart;


    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    Coc->OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

    Coc->FileVersionNumber = 0;

    //
    // File's USN
    //
    Coc->FileUsn = 0;
    Coc->JrnlUsn = 0;
    Coc->JrnlFirstUsn = 0;

    //
    // File is dir?
    //
    SET_CO_LOCATION_CMD(*Coc,
                        DirOrFile,
                        (IsDirectory ? CO_LOCATION_DIR : CO_LOCATION_FILE));

    //
    // Create, Delete, ..
    //
    SET_CO_LOCATION_CMD(*Coc, Command, LocationCmd);

    if (LocationCmd == CO_LOCATION_NO_CMD) {
        Coc->ContentCmd = USN_REASON_DATA_OVERWRITE;
    } else
    if (CO_NEW_FILE(LocationCmd)) {
        Coc->ContentCmd = USN_REASON_FILE_CREATE;
    }  else
    if (CO_DELETE_FILE(LocationCmd)) {
        Coc->ContentCmd = USN_REASON_FILE_DELETE;
    }  else {
        DPRINT1(0, "++ Error - Invalid location cmd: %d\n", LocationCmd);
        Coc->ContentCmd = USN_REASON_DATA_OVERWRITE;
    }

    //
    // Set the change order flags.
    //
    SET_CO_FLAG(ChangeOrder, CoFlags);

    return ChangeOrder;
}




PCHANGE_ORDER_ENTRY
ChgOrdMakeFromIDRecord(
    IN PIDTABLE_RECORD IDTableRec,
    IN PREPLICA        Replica,
    IN ULONG           LocationCmd,
    IN ULONG           CoFlags,
    IN GUID           *CxtionGuid
)
/*++

Routine Description:

    Create and init a change order. It starts out with a ref count of one.

    Note - Since only a single Replica arg is passed in and only a single
    parent guid is available for the IDTable record this function can not
    create rename change orders.

Arguments:

    IDTableRec - ID table record.
    Replica    -- The Replica set this CO is for.
    LocationCmd -- A Create, delete, ... change order.
    CoFlags  --  The change order option flags.  see schema.h
    CxtionGuid  -- The Guid of the connection this CO will be sent to.
                   NULL if unneeded.

Thread Return Value:

    A ptr to a change order entry.

--*/
{
#undef DEBSUB
#define DEBSUB "ChgOrdMakeFromIDRecord:"

    PCHANGE_ORDER_ENTRY     Coe;
    PCHANGE_ORDER_COMMAND   Coc;

    PDATA_EXTENSION_CHECKSUM       IdtDataChkSum;
    PIDTABLE_RECORD_EXTENSION      IdtExt;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt;


    FRS_ASSERT((LocationCmd == CO_LOCATION_NO_CMD)  ||
               (LocationCmd == CO_LOCATION_CREATE)  ||
               (LocationCmd == CO_LOCATION_MOVEOUT) ||
               (LocationCmd == CO_LOCATION_DELETE));

    //
    // Alloc Change order entry and extension.
    //
    Coe = FrsAllocType(CHANGE_ORDER_ENTRY_TYPE);
    Coe->Cmd.Extension = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
    DbsDataInitCocExtension(Coe->Cmd.Extension);

    Coc = &Coe->Cmd;

    //
    // Assign a change order guid and init ref count.
    //
    FrsUuidCreate(&Coc->ChangeOrderGuid);
    INCREMENT_CHANGE_ORDER_REF_COUNT(Coe);
    //
    // File's fid and parent FID
    //
    Coe->FileReferenceNumber = IDTableRec->FileID;
    Coe->ParentFileReferenceNumber = IDTableRec->ParentFileID;
    //
    // Original parent and New parent are the same (not a rename)
    //
    Coe->OriginalParentFid = IDTableRec->ParentFileID;
    Coe->NewParentFid = IDTableRec->ParentFileID;
    //
    // File's attributes, create and write times.
    //
    Coe->FileAttributes = IDTableRec->FileAttributes;
    Coe->FileCreateTime = IDTableRec->FileCreateTime;
    Coe->FileWriteTime = IDTableRec->FileWriteTime;
    //
    // Jet context for outlog insertion
    //
    Coe->RtCtx = FrsAllocTypeSize(REPLICA_THREAD_TYPE,
                                  FLAG_FRSALLOC_NO_ALLOC_TBL_CTX);

    FrsRtlInsertTailList(&Replica->ReplicaCtxListHead,
                         &Coe->RtCtx->ReplicaCtxList);
    //
    // The sequence number is zero initially.  It may get a value when
    // the CO is inserted into an inbound or outbound log.
    //
    Coc->SequenceNumber = 0;
    Coc->PartnerAckSeqNumber = 0;
    //
    // File's attributes, again
    //
    Coc->FileAttributes = Coe->FileAttributes;
    //
    // File's version number, size, VSN, and event time.
    //
    Coc->FileVersionNumber = IDTableRec->VersionNumber;
    Coc->FileSize = IDTableRec->FileSize;
    Coc->FrsVsn = IDTableRec->OriginatorVSN;
    Coc->EventTime.QuadPart = IDTableRec->EventTime;
    //
    // Original and New Replica are the same (not a rename)
    //
    Coe->OriginalReplica = Replica;
    Coe->NewReplica = Replica;
    Coc->OriginalReplicaNum = ReplicaAddrToId(Coe->OriginalReplica);
    Coc->NewReplicaNum      = ReplicaAddrToId(Coe->NewReplica);
    //
    // Originator guid, File guid, old and new parent guid.
    //
    Coc->OriginatorGuid = IDTableRec->OriginatorGuid;
    Coc->FileGuid = IDTableRec->FileGuid;
    Coc->OldParentGuid = IDTableRec->ParentGuid;
    Coc->NewParentGuid = IDTableRec->ParentGuid;
    //
    // Cxtion's guid (identifies the cxtion)
    //
    if (CxtionGuid != NULL) {
        Coc->CxtionGuid = *CxtionGuid;
    }
    //
    // Filename length in bytes not including the terminating NULL
    //
    Coc->FileNameLength = wcslen(IDTableRec->FileName) * sizeof(WCHAR);
    Coe->UFileName.Length = Coc->FileNameLength;
    //
    // Filename (including the terminating NULL)
    //
    CopyMemory(Coc->FileName, IDTableRec->FileName, Coc->FileNameLength + sizeof(WCHAR));
    //
    // File's USN
    //
    Coc->FileUsn = IDTableRec->CurrentFileUsn;
    Coc->JrnlUsn = 0;
    Coc->JrnlFirstUsn = 0;

    //
    // If the IDTable Record has a file checksum, copy it into the changeorder.
    //
    IdtExt = &IDTableRec->Extension;
    IdtDataChkSum = DbsDataExtensionFind(IdtExt, DataExtend_MD5_CheckSum);
    CocExt = Coc->Extension;

    if (IdtDataChkSum != NULL) {
        if (IdtDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
            DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                    IdtDataChkSum->Prefix.Size);
            //
            // Format is hosed.  Reinit it and zero checksum.
            //
            DbsDataInitIDTableExtension(IdtExt);
            IdtDataChkSum = DbsDataExtensionFind(IdtExt, DataExtend_MD5_CheckSum);
            ZeroMemory(IdtDataChkSum->Data, MD5DIGESTLEN);
        }

        DPRINT4(4, "IDT MD5: %08x %08x %08x %08x\n",
                *(((ULONG *) &IdtDataChkSum->Data[0])),
                *(((ULONG *) &IdtDataChkSum->Data[4])),
                *(((ULONG *) &IdtDataChkSum->Data[8])),
                *(((ULONG *) &IdtDataChkSum->Data[12])));

        CopyMemory(CocExt->DataChecksum.Data, IdtDataChkSum->Data, MD5DIGESTLEN);
    } else {
        ZeroMemory(CocExt->DataChecksum.Data, MD5DIGESTLEN);
    }

    //
    // File is dir?
    //
    SET_CO_LOCATION_CMD(*Coc,
                        DirOrFile,
                        ((IDTableRec->FileIsDir) ?
                        CO_LOCATION_DIR : CO_LOCATION_FILE));
    //
    // Consistency check.
    //
    FRS_ASSERT(BooleanFlagOn(IDTableRec->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)
               == ((BOOLEAN) IDTableRec->FileIsDir));

    //
    // Create, Delete, ..
    //
    SET_CO_LOCATION_CMD(*Coc, Command, LocationCmd);

    if (LocationCmd == CO_LOCATION_NO_CMD) {
        Coc->ContentCmd = USN_REASON_DATA_OVERWRITE;
    } else
    if (LocationCmd == CO_LOCATION_CREATE) {
        Coc->ContentCmd = USN_REASON_FILE_CREATE;
    }  else
    if (LocationCmd == CO_LOCATION_DELETE) {
        Coc->ContentCmd = USN_REASON_FILE_DELETE;
    }  else
    if (LocationCmd == CO_LOCATION_MOVEOUT) {
        Coc->ContentCmd = 0;
    }  else {
        DPRINT1(0, "++ Error - Invalid location cmd: %d\n", LocationCmd);
        Coc->ContentCmd = USN_REASON_DATA_OVERWRITE;
    }

    //
    // Set the change order flags.
    //
    SET_CO_FLAG(Coe, CoFlags);

    //
    // Return CO to caller.
    //
    return Coe;
}


VOID
ChgOrdRetrySubmit(
    IN PREPLICA  Replica,
    IN PCXTION   Cxtion,
    IN USHORT    Command,
    IN BOOL      Wait
    )
/*++
Routine Description:
    Submit retry request to change order retry cmd server.

Arguments:

    Replica -- Replica set on which to perform retry scan.
    CxtionGuid -- Inbound cxtion guid if doing a single cxtion only.
    Command --
        FCN_CORETRY_ONE_CXTION -- Do scan for COs from single inbound partner.
        FCN_CORETRY_ALL_CXTIONS -- Do Scan for COs from all inbound partners.
        FCN_CORETRY_LOCAL_ONLY -- Do scan for Local COs only.
    Wait -- True if we are to wait until command completes.

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdRetrySubmit:"

    PCOMMAND_PACKET  Cmd;
    CHAR  GuidStr[GUID_CHAR_LEN];
    ULONG WStatus;

    //
    // Build command to scan inlog for retry COs.  Pass Replica ptr and
    // Cxtion Guid.  If Cxtion Quid is Null then all Cxtions are done.
    //

    Cmd = FrsAllocCommand(&ChgOrdRetryCS.Queue, Command);

    CoRetryReplica(Cmd) = Replica;
    CoRetryCxtion(Cmd) = Cxtion;
    if (Cxtion) {
        GuidToStr(Cxtion->Name->Guid, GuidStr);
        DPRINT2(1, "++ ChgOrdRetryCS: submit for Replica %ws for Cxtion %s\n",
                Replica->ReplicaName->Name, GuidStr);
    } else {
        DPRINT1(1, "++ ChgOrdRetryCS: submit for Replica %ws\n",
                Replica->ReplicaName->Name);
    }


    if (Wait) {
        //
        // Make the call synchronous.
        // Don't free the packet when the command completes.
        //
        FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

        //
        // SUBMIT retry request Cmd and wait for completion.
        //
        WStatus = FrsSubmitCommandServerAndWait(&ChgOrdRetryCS, Cmd, INFINITE);
        DPRINT_WS(0, "++ ERROR - DB Command failed.", WStatus);
        FrsFreeCommand(Cmd, NULL);

    } else {

        //
        // Fire and forget the command.
        //
        FrsSubmitCommandServer(&ChgOrdRetryCS, Cmd);
    }
}


VOID
ChgOrdCalcHashGuidAndName (
    IN PUNICODE_STRING Name,
    IN GUID           *Guid,
    OUT PULONGLONG    HashValue
    )

/*++

Routine Description:

    This routine forms a 32 bit hash of the name and guid args.
    It returns this in the low 32 bits of HashValue.  The upper 32 bits are zero.

Arguments:

    Name - The filename to hash.
    Guid - The Guid to hash.
    HashValue - The resulting quadword hash value.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdCalcHashGuidAndName:"

    PUSHORT p;
    ULONG NameHash = 0;
    ULONG Shift = 0;
    ULONG GuidHash;
    CHAR  GuidStr[GUID_CHAR_LEN];

    FRS_ASSERT( ValueIsMultOf2(Name->Length) );
    FRS_ASSERT( Name->Length != 0 );


    //
    // Combine each unicode character into the hash value, shifting 4 bits
    // each time.  Start at the end of the name so file names with different
    // type codes will hash to different table offsets.
    //
    for( p = Name->Buffer + (Name->Length / sizeof(WCHAR)) - 1;
         p >= Name->Buffer;
         p-- ) {

//      NameHash = NameHash ^ (((ULONG)*p) << Shift);
        NameHash = NameHash ^ (((ULONG)towupper(*p)) << Shift);

        Shift = (Shift < 16) ? Shift + 4 : 0;
    }

    //
    //  Combine each USHORT of the Guid into the hash value, shifting 4 bits
    //  each time.
    //
    GuidHash = JrnlHashCalcGuid(Guid, sizeof(GUID));

    //p = (PUSHORT) Guid;
    //GuidHash =   (((ULONG)*(p+0)) <<  0) ^ (((ULONG)*(p+1)) <<  4)
    //           ^ (((ULONG)*(p+2)) <<  8) ^ (((ULONG)*(p+3)) << 12)
    //           ^ (((ULONG)*(p+4)) << 16) ^ (((ULONG)*(p+5)) <<  0)
    //           ^ (((ULONG)*(p+6)) <<  4) ^ (((ULONG)*(p+7)) <<  8);

    if (GuidHash == 0) {
        GuidToStr(Guid, GuidStr);
        DPRINT2(0, "++ Warning - GuidHash is zero. Guid: %s   Name: %ws\n",
                Guid, Name->Buffer);
    }

    *HashValue = (ULONGLONG) (NameHash + GuidHash);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\makefile.inc ===
MOF: dfssvc.bmf

$(O)\ntfrs.bmf: ntfrs.mof
    mofcomp -B:.\$(O)\ntfrs.bmf ntfrs.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\outlog.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    outlog.c

Abstract:

    Each Replica Set may have some number of outbound partners.  An outbound
    partner can be in one of three sets at any point in time, Inactive,
    Active, and Eligible.  The Inactive set tracks those partners that have
    not yet joined or have returned a failure status from a send request.
    The Eligible set contains those partners that can currently accept a
    change order.  They have joined and they have not exceeded their quota
    of outstanding change orders.  The Active set contains those partners
    that have joined but are not currently eligible.

    This module processes outbound change orders.  The source can be either
    local change orders or inbound remote change orders.  The flow for each
    replica set is as follows:

    - Accept change order from inbound log subsystem and insert it into
      the outbound log for the replica set.

    - Form the current set of "eligible" outbound partners (i.e. those that have
      joined and have not exceeded their outstanding Change Order Quota.

    - Find the joint leading change order index (JLx) over the eligible set.
      The Leading index for each outbound partner is the index of the next
      change order in the outbound log to be sent to that partner.

    - Starting at JLx and continuing to the current maximum change order in
      the outbound log (COmax) send the change order to each outbound partner
      (OBP) subject to the following:

        1. The current change order sequence number or index (COCx) is greater
           than or equal to the leading change order index for this
           partner (COLx) (i.e. the partner has not seen this log entry).

        2. The change order originator Guid, version number pair are greater
           than the entry in the version vector being maintained for this
           outbound partner.  The version vector was inited when the partner
           joined.  If not we don't need to send the partner this change order.

    - As the outstanding change order count for each outbound partner reaches
      their outstanding Change Order Quota the partner is removed from the
      "eligible" set.

    - The above loop ends when the eligible set is empty or we reach COmax
      in the outbound log.

    - Wait on either a new entry in the outbound log or a change order
      acknowledgement from an outbound partner and then start over, forming
      a new eligible set.

The following diagram illustrates the relationship between COTx, COLx and COmax.
It is for a 64 element Ack Vector of a typical outbound partner.  The first
line contains a 1 if an ack has been received.  The second line shows a T and
L for the Trailing and Leading index respectively (COTx and COLx).  The
difference between L and T is 23 change orders, 2 of which have been acked
leaving 21 outstanding.  The "M" is the current change order max.  Change
orders from L to M have not yet been sent out to this partner.  The line with
the caret shows the current CO being acked.  Since this is at the COTx point
it will advance by one.  The Ack vector is a sliding window of the
outstanding change orders for the partner.  The "origin" is at "T".  As
change orders are sent out "L" is advanced but it can't catch up to "T".
When "T" and "L" are the same, no change orders are still outstanding to this
partner.  This lets us track the Acks from the partner even when they return
out of order relative to the order the change orders were sent.

COTx: 215,  COLx: 238,  Outstanding: 21
 |...........................................1.1..................|
 |_______________________T______________________L________M________|
 |                       ^                                        |



Assumptions/Objectives:

1. Allow batch delivery of change orders to reduce CO packet count.

2. The inbound log subsystem enforces sequence interlocks between change
   orders but once the change order is issued it can complete out of order
   relative to when it started.  (sounds like a RISC machine).  This is because
   different change orders can involve different file sizes so their fetch times
   can vary.

3. Multiple outbound partners can have different throughputs and schedules.

4. We can do lazy database updates of the trailing change order index number
   (COTx), the outbound log commit point, that we keep for each outbound
   partner.  This allows us to reduce the frequency of database updates but it
   means that an outbound partner may see a change order more than once in the
   event of a crash.  It must be prepared to discard them.

5. Each outbound partner must respond with a positive acknowledgement when it
   retires each change order even if it never fetches the staging file
   because it either rejected the changeorder or it already got it from another
   source (i.e. it dampened it).  Failure to do this causes our ack tracker
   for this partner to stall and we periodically resend the oldest un-acked
   change order until the partner acks it or we drop the connection.

Author:

    David A. Orbits  16-Aug-1997

Environment

    User mode, winnt32

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>

//
// The following is the data entry format for tracking the dominant file in
// the Replica OutLogDominantTable and the connection MustSendTable.
//
typedef struct _DOMINANT_FILE_ENTRY_ {

    GUID        FileGuid;       // File Guid  (Must be at offset zero in struct)
    ULONGLONG   TimeSent;       // The time this File was last sent on the cxtion.
    ULONG       OLSeqNum;       // Outlog sequence number for change order.
    ULONG       Flags;          // Misc Flags.

} DOMINANT_FILE_ENTRY, *PDOMINANT_FILE_ENTRY;


//
// Context to pass to DbsEnumerateOutlogTable.
//
typedef struct _OUTLOG_TABLE_ENUM_ {

    PREPLICA    Replica;                // Pointer to the replica structure.
    ULONG       OldJointTrailingIndex;  // Old Joint trailing index.
    TABLE_CTX   VVTableCtx;             // VV table context. Used to update OutlogVVector.

} OUTLOG_TABLE_ENUM, *POUTLOG_TABLE_ENUM;

#define  DFT_FLAG_DELETE    0x00000001     // The OLSeqNum is for a CO that deletes the file.


//
// The following fields are updated when an outbound partner's OutLog process
// state is saved.
//
ULONG OutLogUpdateFieldList[] = {CrFlagsx,
                                 CrCOLxx,
                                 CrCOTxx,
                                 CrCOTslotx,
                                 CrAckVectorx,
                                 CrCOTxNormalModeSavex};


PCHAR OLReplicaProcStateNames[OL_REPLICA_PROC_MAX_STATE+1];
PCHAR OLPartnerStateNames[OLP_MAX_STATE+1];

FRS_QUEUE  OutLogWork;

BOOL NeedNewPartnerTable = TRUE;

//
// Outlog partner state flags.
//
FLAG_NAME_TABLE OlpFlagNameTable[] = {
    {OLP_FLAGS_ENABLED_CXTION    , "EnabledCxtion "  },
    {OLP_FLAGS_GENERATED_CXTION  , "GenedCxtion "    },
    {OLP_FLAGS_VVJOIN_MODE       , "VvjoinMode "     },
    {OLP_FLAGS_LOG_TRIMMED       , "LogTrimmed "     },
    {OLP_FLAGS_REPLAY_MODE       , "ReplayMode "     },
    {OLP_FLAGS_OPT_VVJOIN_MODE   , "OptVvjoinMode "  },

    {0, NULL}
};


//
// If True then hold the ReplicaList lock for the duration of an outlog cleanup
// cycle (which could be many minutes).  If False then don't hold the lock.
//
BOOL LockedOutlogCleanup = FALSE;

//
// Maximum number of replica sets that can be created.
//
extern ULONG MaxNumberReplicaSets;

//
// The default max number of change orders outstanding.
//
extern ULONG MaxOutLogCoQuota;

//
// A CO update for a given file will not be sent out more frequently than this.
//
extern ULONG GOutLogRepeatInterval;

//
// The minimum time between checks for outbound stage file cleanup.
// This cleanup pass only occurs if there has been any activity. (millisec units)
//
#define OUT_LOG_CLEAN_INTERVAL (60*1000)
//
// Max interval between forced outlog cleanup.  Purpose is to age out
// outlog change history. 8 hours.
//
#define OUT_LOG_FORCE_CLEAN_INTERVAL (8*60*60*1000)
#define OUT_LOG_POLL_INTERVAL  (30*1000)

//
// Save the partner state in the DB every OUT_LOG_SAVE_INTERVAL change orders
// handled.
//
#define OUT_LOG_SAVE_INTERVAL  15

#define OUT_LOG_TRACK_PARTNER_STATE_UPDATE(_par_, _Commit_, _Eval_)      \
{                                                                        \
    PSINGLE_LIST_ENTRY SingleList;                                       \
    SingleList = ((_par_)->COTx >=                                       \
                  ((_par_)->COTxLastSaved + OUT_LOG_SAVE_INTERVAL)) ?    \
                   (_Commit_) : (_Eval_);                                \
    PushEntryList(SingleList, &(_par_)->SaveList);                       \
}



ULONG
OutLogAddReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
);

ULONG
OutLogRemoveReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
);

ULONG
OutLogInitPartner(
    PREPLICA Replica,
    PCXTION Cxtion
);

ULONG
OutLogEnterUnjoinedPartner(
    PREPLICA Replica,
    POUT_LOG_PARTNER OutLogPartner
);

ULONG
OutLogAddNewPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogDeactivatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogActivatePartnerCmd(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     PartnerCxtion,
    IN BOOL        HaveLock
);

ULONG
OutLogActivatePartner(
    IN PREPLICA Replica,
    IN PCXTION  PartnerCxtion,
    IN BOOL     HaveLock
);

ULONG
OutLogRemovePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogReadPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogClosePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogProcess(
    PVOID  FrsThreadCtxArg
);

ULONG
OutLogProcessReplica(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
);

BOOL
OutLogSendCo(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    POUT_LOG_PARTNER      Partner,
    PCHANGE_ORDER_COMMAND CoCmd,
    ULONG                 JointLeadingIndex
);

BOOL
OutLogOptimize(
    IN PREPLICA              Replica,
    IN POUT_LOG_PARTNER      Partner,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    OUT PCHAR                *SendTag
);

VOID
OutLogSkipCo(
    PREPLICA              Replica,
    ULONG                 JointLeadingIndex
);

ULONG
OutLogCommitPartnerState(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogReadCo(
    PTHREAD_CTX          ThreadCtx,
    PREPLICA             Replica,
    ULONG                Index
);

ULONG
OutLogDeleteCo(
    PTHREAD_CTX ThreadCtx,
    PREPLICA    Replica,
    ULONG       Index
);

ULONG
OutLogStartProcess(
    PREPLICA Replica
);

ULONG
OutLogSubmitCo(
    PREPLICA Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder
);

VOID
OutLogAVToStr(
    POUT_LOG_PARTNER OutLogPartner,
    ULONG RetireCOx,
    PCHAR *OutStr1,
    PCHAR *OutStr2,
    PCHAR *OutStr3
    );

ULONG
OutLogRetireCo(
    PREPLICA Replica,
    ULONG COx,
    PCXTION Partner
);

BOOL
OutLogMarkAckVector(
    PREPLICA Replica,
    ULONG COx,
    POUT_LOG_PARTNER OutLogPartner
);

ULONG
OutLogSavePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PSINGLE_LIST_ENTRY CommitList,
    IN PSINGLE_LIST_ENTRY EvalList
);

ULONG
OutLogSaveSinglePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PTABLE_CTX         TableCtx,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogPartnerVVJoinStart(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogPartnerVVJoinDone(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogCleanupLog(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
);

ULONG
OutLogCleanup(
    PTHREAD_CTX      ThreadCtx,
    PCOMMAND_PACKET  Cmd
);

VOID
OutLogCopyCxtionToCxtionRecord(
    IN PCXTION      Cxtion,
    IN PTABLE_CTX   CxtionRecord
);

#define OUT_LOG_DUMP_PARTNER_STATE(_sev, _olp, _cox, _desc) \
    FrsPrintTypeOutLogPartner(_sev, NULL, 0, _olp, _cox, _desc, DEBSUB, __LINE__)

VOID
FrsPrintTypeOutLogPartner(
    IN ULONG            Severity,   OPTIONAL
    IN PVOID            Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN POUT_LOG_PARTNER Olp,
    IN ULONG            RetireCox,
    IN PCHAR            Description,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    );

ULONG
DbsReplicaHashCalcCoSeqNum (
    PVOID Buf,
    ULONG Length
    );

FrsDoesCoAlterNameSpace(
    IN PCHANGE_ORDER_COMMAND Coc
    );

JET_ERR
DbsEnumerateOutlogTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndexLimit,
    IN PENUMERATE_OUTLOGTABLE_ROUTINE RecordFunction,
    IN PVOID         Context
    );


VOID
ShutDownOutLog(
    VOID
    )
/*++
Routine Description:

    Run down the outbound log queue.

Arguments:

    None.

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownOutLog:"
    FrsRunDownCommand(&OutLogWork);
}








VOID
OutLogInitialize(
    VOID
    )
/*++
Routine Description:

    Initialize the Outbound log subsystem.

Arguments:

    None.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInitialize:"
    LIST_ENTRY  ListHead;


    OLReplicaProcStateNames[OL_REPLICA_INITIALIZING] = "OL_REPLICA_INITIALIZING";
    OLReplicaProcStateNames[OL_REPLICA_WAITING]      = "OL_REPLICA_WAITING";
    OLReplicaProcStateNames[OL_REPLICA_WORKING]      = "OL_REPLICA_WORKING";
    OLReplicaProcStateNames[OL_REPLICA_STOPPING]     = "OL_REPLICA_STOPPING";
    OLReplicaProcStateNames[OL_REPLICA_STOPPED]      = "OL_REPLICA_STOPPED";
    OLReplicaProcStateNames[OL_REPLICA_NOPARTNERS]   = "OL_REPLICA_NOPARTNERS";
    OLReplicaProcStateNames[OL_REPLICA_ERROR]        = "OL_REPLICA_ERROR";


    OLPartnerStateNames[OLP_INITIALIZING]       = "OLP_INITIALIZING";
    OLPartnerStateNames[OLP_UNJOINED]           = "OLP_UNJOINED";
    OLPartnerStateNames[OLP_ELIGIBLE]           = "OLP_ELIGIBLE";
    OLPartnerStateNames[OLP_STANDBY]            = "OLP_STANDBY";
    OLPartnerStateNames[OLP_AT_QUOTA]           = "OLP_AT_QUOTA";
    OLPartnerStateNames[OLP_INACTIVE]           = "OLP_INACTIVE";
    OLPartnerStateNames[OLP_ERROR]              = "OLP_ERROR";

    FrsInitializeQueue(&OutLogWork, &OutLogWork);

    //
    // Create the outlog process thread.
    //
    if (!FrsIsShuttingDown &&
        !ThSupCreateThread(L"OutLog", NULL, OutLogProcess, ThSupExitThreadNOP)) {
        DPRINT(0, "ERROR - Could not create OutLogProcess thread\n");
        FRS_ASSERT(!"Could not create OutLogProcess thread");
    }
}



BOOL
OutLogDominantKeyMatch(
    PVOID Buf,
    PVOID QKey
)
/*++

Routine Description:
    Check for an exact key match.

Arguments:
    Buf -- ptr to a Guid1.
    QKey -- ptr to Guid2.

Return Value:
    TRUE if exact match.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDominantKeyMatch:"

    PULONG pUL1, pUL2;

    pUL1 = (PULONG) Buf;
    pUL2 = (PULONG) QKey;

    if (!ValueIsMultOf4(pUL1)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL1, *pUL1);
        FRS_ASSERT(ValueIsMultOf4(pUL1));
        return 0xFFFFFFFF;
    }
    if (!ValueIsMultOf4(pUL2)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL2, *pUL2);
        FRS_ASSERT(ValueIsMultOf4(pUL2));
        return 0xFFFFFFFF;
    }

    return GUIDS_EQUAL(pUL1, pUL2);
}



ULONG
OutLogDominantHashCalc(
    PVOID Buf,
    PULONGLONG QKey
)
/*++

Routine Description:
    Calculate a hash value for the file guid used in the OutLog Dominant File Table.

Arguments:
    Buf -- ptr to a Guid.
    QKey -- Returned 8 byte hash key for the QKey field of QHASH_ENTRY.

Return Value:
    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDominantHashCalc:"

    PULONG  pUL = (PULONG) Buf;
    PUSHORT pUS = (PUSHORT) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    //
    // Calc QKey, 4 byte hash is ok.
    //
    *QKey = (ULONGLONG) (pUL[0] ^ pUL[1] ^ pUL[2] ^ pUL[3]);

    //
    // Calc hash based on the time.  Include node part for remote COs.
    //
    return (ULONG) (pUS[0] ^ pUS[1] ^ pUS[2] ^ pUS[6] ^ pUS[7]);
}

BOOL
OutLogFavorDominantFile(
    IN PCHANGE_ORDER_COMMAND  CoCmd
)
/*++

Routine Description:

    Test if this CO is a candidate for Outlog skipping.  The criteria are:
    1. Files only.
    2. CO can't change the name space so no renames, deletes or creates.
    3. CO can't be a directed co or a vvjoin co or an out of order co.
    4. CO can't be an abortco, any type of refresh co, a control co, or Morphgenco.

Arguments:

    CoCmd - ptr to CO command record.

Return Value:

    TRUE if CO is a candidate for OutLog skipping.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogFavorDominantFile:"

    CHAR FlagBuffer[160];

    //
    // Certain types of COs can't be skipped.
    //
    if (FrsDoesCoAlterNameSpace(CoCmd)) {
        DPRINT(4, "++ noskip - alters name space\n");
        return FALSE;
    }

    if (CoCmdIsDirectory(CoCmd)) {
        DPRINT(4, "++ noskip - is directory\n");
        return FALSE;
    }

    if (COC_FLAG_ON(CoCmd, (CO_FLAG_ABORT_CO          |
                            CO_FLAG_GROUP_ANY_REFRESH |
                            CO_FLAG_OUT_OF_ORDER      |
                            CO_FLAG_NEW_FILE          |
                            CO_FLAG_CONTROL           |
                            CO_FLAG_VVJOIN_TO_ORIG    |
                            CO_FLAG_MORPH_GEN         |
                            CO_FLAG_DIRECTED_CO))) {

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DPRINT2(4, "++ noskip - wrong CO type CoFlags: %08x [%s]\n",
                CoCmd->Flags, FlagBuffer);
        return FALSE;
    }

    return TRUE;
}



BOOL
OutLogIsValidDominantFile(
    IN PCHANGE_ORDER_COMMAND  CoCmd
)
/*++

Routine Description:

    Test if this CO is a valid file for the OutLog dominant file table.

    1. Files only.
    2. CO can't be a directed co or a vvjoin co or an out of order Co.
    3. CO can't be an abortco, any type of refresh co, a control co, or Morphgenco.

    Note: The dominant file table can contain name space changing COs since
    we always ship the data with the file.  So we can skip a file update CO
    in favor of some dominant CO that may also rename or even delete the file.
    The latter is especially important since there is no point in shipping
    an update if a later CO is going to just delete the file.

    Note: An out of order CO is not allowed in the dominant file table since
    it may have reconcile data that would cause it to be rejected while the
    current CO would be accepted.  If this becomes an important case code could
    be added to determine the reconciliation result between the current outlog
    CO and the dominant CO.  I doubt this is worth it.


Arguments:

    CoCmd - ptr to CO command record.

Return Value:

    TRUE if CO is a candidate for OutLog Dominant file table.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogIsValidDominantFile:"

    CHAR FlagBuffer[160];


    //
    // Certain types of COs can't be skipped.
    //
    if (CoCmdIsDirectory(CoCmd)) {
        DPRINT(4, "++ not valid dominant file: directory\n");
        return FALSE;
    }

    if (COC_FLAG_ON(CoCmd, (CO_FLAG_ABORT_CO          |
                            CO_FLAG_GROUP_ANY_REFRESH |
                            CO_FLAG_OUT_OF_ORDER      |
                            CO_FLAG_NEW_FILE          |
                            CO_FLAG_CONTROL           |
                            CO_FLAG_VVJOIN_TO_ORIG    |
                            CO_FLAG_MORPH_GEN         |
                            CO_FLAG_DIRECTED_CO))) {

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DPRINT1(4, "++ not valid dominant file: wrong CO type CoFlags: %08x \n",
                CoCmd->Flags);
        DPRINT1(4, "++ [%s]\n", FlagBuffer);
        return FALSE;
    }

    return TRUE;
}


JET_ERR
OutLogInitDominantFileTableWorker (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Outbound log table.

    It scans the Outbound log table and rebuilds the Dominate File Table.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an outbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogInitDominantFileTableWorker:"

    JET_ERR                 jerr;
    PDOMINANT_FILE_ENTRY    DomFileEntry;
    PQHASH_ENTRY            QHashEntry;

    PREPLICA                Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND   CoCmd   = (PCHANGE_ORDER_COMMAND)Record;
    CHAR                    GuidStr[GUID_CHAR_LEN];

    //
    // Ignore if entry does not meet criteria.
    //
    GuidToStr(&CoCmd->FileGuid, GuidStr);
    DPRINT2(4, ":S: Dominant file check of %ws %s\n", CoCmd->FileName, GuidStr);

    //
    // Certain types of COs are not candidates for skipping.
    //
    if (!OutLogIsValidDominantFile(CoCmd)) {
        return JET_errSuccess;
    }

    //
    // This is a candidate.  Update the Dominant File Table.
    //
    jerr = JET_errSuccess;

    QHashAcquireLock(Replica->OutLogDominantTable);

    QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        //
        // Found a match, bump the count and record latest sequence number.
        //
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
        QHashEntry->QData += 1;
        DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;
    } else {
        //
        // Not found, insert new entry.
        //
        DomFileEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
        if (DomFileEntry != NULL) {
            DomFileEntry->Flags = 0;
            COPY_GUID(&DomFileEntry->FileGuid, &CoCmd->FileGuid);
            DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;

            if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                SetFlag(DomFileEntry->Flags, DFT_FLAG_DELETE);
            }

            QHashEntry = QHashInsertLock(Replica->OutLogDominantTable,
                                         &CoCmd->FileGuid,
                                         NULL,
                                         (ULONG_PTR) DomFileEntry);

            if (QHashEntry == NULL) {
                DPRINT2(4, "++ ERROR - Failed to insert entry into Replica OutLogDominant Table for %ws (%s)",
                        CoCmd->FileName, GuidStr);
                jerr = JET_wrnNyi;
            }
        } else {
            jerr = JET_wrnNyi;
        }
    }

    QHashReleaseLock(Replica->OutLogDominantTable);

    return jerr;
}


ULONG
OutLogInitDominantFileTableWorkerPart2 (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove entries
    that have no multiples.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    FrsError Status

--*/

{
#undef DEBSUB
#define DEBSUB  "OutLogInitDominantFileTableWorkerPart2:"

    PDOMINANT_FILE_ENTRY DomFileEntry;

    if (TargetNode->QData == QUADZERO) {

        //DPRINT5(4, "BeforeNode: %08x, Link: %08x,"
        //           " Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
        //       BeforeNode, TargetNode->NextEntry, TargetNode->Flags,
        //       PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData));

        //
        // Free the dominate file entry node.
        //
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);
        FrsFree(DomFileEntry);
        TargetNode->Flags = 0;

        //
        // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}


ULONG
OutLogDumpDominantFileTableWorker(
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    Dump the OutLog Dominant File Table.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    FrsErrorSuccess

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDumpDominantFileTableWorker:"

    PDOMINANT_FILE_ENTRY DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);
    CHAR                 GuidStr[GUID_CHAR_LEN];

    GuidToStr(&DomFileEntry->FileGuid, GuidStr);

    DPRINT4(4,":S: QKey: %08x %08x, Data: %08x %08x, OLSeqNum: %6d, FileGuid: %s\n",
            PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData),
            DomFileEntry->OLSeqNum, GuidStr);

    return FrsErrorSuccess;
}


ULONG
OutLogAddReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
)
/*++
Routine Description:

    Add a new replica set to the outbound log process.  Called once when
    Replica set is created.  Determine continuation index for Out Log.
    Init the outlog partner structs.  Init the outlog table for the replica.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogAddReplica:"

    JET_ERR         jerr, jerr1;
    ULONG           FStatus;
    PTABLE_CTX      TableCtx;

    PCOMMAND_PACKET CmdPkt;
    PVOID           Key;
    PCXTION         OutCxtion;
    PCHANGE_ORDER_COMMAND   CoCmd;
    ULONG           ReplicaNumber = Replica->ReplicaNumber;

    //
    // Only init once per Replica.
    //
    if (Replica->OutLogWorkState != OL_REPLICA_INITIALIZING) {
        return FrsErrorSuccess;
    }

    //
    // Allocate a table context struct to access the outbound log.
    //
    TableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid       = JET_tableidNil;

    Replica->OutLogTableCtx   = TableCtx;
    Replica->OutLogSeqNumber = 1;
    Replica->OutLogCOMin = 1;

    //
    // Init the table context and open the outbound log table for this replica.
    // Get the sequence number from the last Outbound log record.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNumber, OUTLOGTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (outlog) on replica number %d failed.",
                   ReplicaNumber, jerr);
        DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        Replica->OutLogTableCtx = FrsFree(TableCtx);
        return DbsTranslateJetError(jerr, FALSE);
    }

    FStatus = DbsTableMoveToRecord(ThreadCtx,
                                   TableCtx,
                                   OLSequenceNumberIndexx,
                                   FrsMoveLast);
    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (FRS_SUCCESS(FStatus)) {
            CoCmd = (PCHANGE_ORDER_COMMAND) TableCtx->pDataRecord;
            Replica->OutLogSeqNumber = CoCmd->SequenceNumber+1;
        }
    } else {
        //
        // Outbound log is empty.  Reset Seq number to 1.  Zero is reserved
        // as the starting index for a partner that has never joined.  After
        // the partner joins for the first time we force a VVJoin and advance
        // the its seq number to the end of the log.
        //
        Replica->OutLogSeqNumber = 1;
    }

    //
    // Everything looks good.  Complete the rest of the init.
    //
    // Allocate an outlog record lock Table for the replica.
    //
    Replica->OutLogRecordLock = FrsFreeType(Replica->OutLogRecordLock);
    Replica->OutLogRecordLock = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                 OUTLOG_RECORD_LOCK_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(Replica->OutLogRecordLock,
                              DbsReplicaHashCalcCoSeqNum);

    //
    // Allocate a hash table to record the dominant file update change order
    // in the oubound log when multiple COs for the same file guid are present.
    // The hash function is on the file Guid.  Then enmerate the outbound log
    // and build the table.
    //
    if (Replica->OutLogDominantTable == NULL) {
        Replica->OutLogDominantTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                        OUTLOG_DOMINANT_FILE_TABLE_SIZE);
        SET_QHASH_TABLE_FLAG(Replica->OutLogDominantTable, QHASH_FLAG_LARGE_KEY);
        SET_QHASH_TABLE_HASH_CALC2(Replica->OutLogDominantTable, OutLogDominantHashCalc);
        SET_QHASH_TABLE_KEY_MATCH(Replica->OutLogDominantTable, OutLogDominantKeyMatch);
        SET_QHASH_TABLE_FREE(Replica->OutLogDominantTable, FrsFree);

        //
        // Initialize the OutLogDominant Table.
        //
        if ((Replica->OutLogSeqNumber > 1) &&
            (Replica->OutLogRepeatInterval > 0)){
            jerr = FrsEnumerateTable(ThreadCtx,
                                     TableCtx,
                                     OLSequenceNumberIndexx,
                                     OutLogInitDominantFileTableWorker,
                                     Replica);
            if ((!JET_SUCCESS(jerr)) &&
                (jerr != JET_errNoCurrentRecord) &&
                (jerr != JET_wrnTableEmpty)) {
                DPRINT1_JS(0, "++ ERROR - Initializing outlog dominant table for %ws : ",
                           Replica->ReplicaName->Name, jerr);
                DbsTranslateJetError(jerr, FALSE);
            }

            //
            // Now clear out the entries that have no multiples.
            //
            QHashEnumerateTable(Replica->OutLogDominantTable,
                                OutLogInitDominantFileTableWorkerPart2,
                                NULL);

            DPRINT1(4, ":S: Dump of outlog dominant table for %ws\n",
                    Replica->ReplicaName->Name);
            QHashEnumerateTable(Replica->OutLogDominantTable,
                                OutLogDumpDominantFileTableWorker,
                                NULL);
        }
    }

    //
    // Close the table since we are being called from DB thread at startup.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    //
    // Allocate and init a command packet to initiate outbound log work on
    // this replica.  Save the ptr to the command packet so we can reuse it
    // each time there is new work for this replica.
    //
    CmdPkt = FrsAllocCommand(&OutLogWork, CMD_OUTLOG_WORK_CO);
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);
    CmdPkt->Parameters.OutLogRequest.Replica = Replica;
    //
    // Start out with 1 outbound partner as we want COs to go to the
    // outbound log for future vvjoins.
    //
    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_NOPARTNERS);
    Replica->OutLogCxtionsJoined = 1;

    //
    // Init the out log state for each connection.
    // Make sure we continue at the maximum value for the OutLog Sequence Number.
    //
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        //
        // Ignore the (local) journal connection
        //
        if (OutCxtion->JrnlCxtion) {
            continue;
        }
        if (!OutCxtion->Inbound) {
            FRS_ASSERT(OutCxtion->OLCtx != NULL);
            if (OutCxtion->OLCtx->COLx > Replica->OutLogSeqNumber) {
                Replica->OutLogSeqNumber = OutCxtion->OLCtx->COLx;
            }
            OutLogInitPartner(Replica, OutCxtion);
        }
    }

    Replica->OutLogJTx = 0;
    Replica->OutLogJLx = Replica->OutLogSeqNumber;
    //
    // There may be old change orders in the outbound log that
    // weren't cleaned up because the service shut down before
    // the cleanup thread ran. Allow the cleanup thread to run
    // at least once to empty the outbound log of stale change
    // orders.
    //
    Replica->OutLogDoCleanup = TRUE;

    //
    // Save the cmd packet and go make an inital check for work.
    //
    OutLogAcquireLock(Replica);
    if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
    }
    Replica->OutLogCmdPkt = CmdPkt;
    OutLogReleaseLock(Replica);
    FrsSubmitCommand(CmdPkt, FALSE);

    return FrsErrorSuccess;
}



ULONG
OutLogRemoveReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
)
/*++
Routine Description:

    Remove a replica set from the outbound log process.  Free memory.

    Even though we are stopping the Outlog process additional COs can
    still be inserted into the outbound log while we are shutting down.

    OutLogInsertCo() still needs the OutLogRecordLock hash table so it can't
    be released here.  Instead it gets re-inited when the replica struct is
    reinitialized or freed.


Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    TableCtx
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRemoveReplica:"

    JET_ERR          jerr;
    NTSTATUS         Status;
    POUT_LOG_PARTNER Partner;
    PVOID            Key;
    PCXTION          OutCxtion;
    PTABLE_CTX       TableCtx;

    //
    // Set the state to Initializing.  This prevents any further calls to
    // the outlog process on behalf of this replica set.
    //
    OutLogAcquireLock(Replica);
    if (Replica->OutLogWorkState == OL_REPLICA_INITIALIZING) {
        //
        // Already removed (or never added); done
        //
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }

    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_INITIALIZING);
    OutLogReleaseLock(Replica);


    //
    // Remove the outbound connections from the outbound log.
    //
    TableCtx = DbsCreateTableContext(CXTIONTablex);
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        //
        // Ignore the (local) journal connection
        //
        if (OutCxtion->JrnlCxtion) {
            continue;
        }

        //
        // If one of the Partner Close requests failed and took an error path
        // then they may have called DbsFreeTableCtx().  Fix this here.
        //
        if (IS_INVALID_TABLE(TableCtx)) {
            Status = DbsAllocTableCtx(CXTIONTablex, TableCtx);
            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                DbsFreeTableCtx(TableCtx, 1);
                continue;
            }
        }

        OutLogClosePartner(ThreadCtx, TableCtx, Replica, OutCxtion);
    }
    DbsFreeTableContext(TableCtx, 0);

    //
    // Close any open table and release the memory.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, Replica->OutLogTableCtx);
    DbsFreeTableCtx(Replica->OutLogTableCtx, 1);
    Replica->OutLogTableCtx = FrsFree(Replica->OutLogTableCtx);
    //
    // Free the work command packet.
    //
    Replica->OutLogCmdPkt = FrsFreeType(Replica->OutLogCmdPkt);
    //
    // Free the outlog dominant QHash Table.
    //
    Replica->OutLogDominantTable = FrsFreeType(Replica->OutLogDominantTable);

    //
    // Free the remaining Outbound log partner structs.
    //
    FrsFreeTypeList(&Replica->OutLogEligible);
    FrsFreeTypeList(&Replica->OutLogStandBy);
    FrsFreeTypeList(&Replica->OutLogActive);
    FrsFreeTypeList(&Replica->OutLogInActive);



    return FrsErrorSuccess;
}


ULONG
OutLogInitPartner(
    PREPLICA Replica,
    PCXTION Cxtion
)
/*++
Routine Description:

    Add a new outbound partner to the outbound log process.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInitPartner:"
    //
    // Not much needs to be done to enable outbound
    // processing on an inbound cxtion
    //
    if (Cxtion->Inbound) {
        return FrsErrorSuccess;
    }

    FRS_ASSERT(Cxtion->OLCtx);

    OutLogEnterUnjoinedPartner(Replica, Cxtion->OLCtx);

    return FrsErrorSuccess;
}


ULONG
OutLogEnterUnjoinedPartner(
    PREPLICA Replica,
    POUT_LOG_PARTNER OutLogPartner
)
/*++
Routine Description:

    Put a newly inited outbound partner on the inactive list and set its
    state to UNJOINED.  If the Outbound Log Replica state is OL_REPLICA_NOPARTNERS
    then set it to OL_REPLICA_WAITING;

Arguments:

    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- The outbound log context for this partner.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogEnterUnjoinedPartner:"

    OutLogAcquireLock(Replica);

    InsertTailList(&Replica->OutLogInActive, &OutLogPartner->List);
    SET_OUTLOG_PARTNER_STATE(OutLogPartner, OLP_UNJOINED);

    if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WAITING);
    }

    FRS_ASSERT(OutLogPartner->Cxtion != NULL);
    //
    // Track the count of outlog connections that have joined at least once.
    // If this count is zero then we don't need to hold onto any staging files
    // or put any change orders in the outbound log since the first connection
    // to join will have to do a VVJOIN anyway.
    //
    if (OutLogPartner->Cxtion->LastJoinTime > (ULONGLONG) 1) {
        InterlockedIncrement(&Replica->OutLogCxtionsJoined);
    }

    OutLogReleaseLock(Replica);

    return FrsErrorSuccess;
}



ULONG
OutLogAddNewPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Add a new outbound partner to the Replica set.  Initialize the
    Partner state and create an initial record in the partner table.

Arguments:

    ThreadCtx -- Needed to update the database
    TableCtx -- Needed to update the database
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogAddNewPartner:"

    ULONG            FStatus;
    POUT_LOG_PARTNER OutLogPartner;

    //
    // Warning -- called for both inbound and outbound cxtions; be careful.
    //

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Allocate an outbound log partner context, link it to the connection info.
    //
    if (!Cxtion->Inbound) {
        OutLogPartner = FrsAllocType(OUT_LOG_PARTNER_TYPE);

        Cxtion->OLCtx = OutLogPartner;
        OutLogPartner->Cxtion = Cxtion;

        //
        // Create the initial state for this new outbound partner.
        // Setting these to zero will cause the new partner to do a VVJoin
        // when it first connects.
        //
        OutLogPartner->COLx = 0;
        OutLogPartner->COTx = 0;

        ResetAckVector(OutLogPartner);

        OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;
        OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    }
    //
    // Make last join time non-zero so if we come up against an old database
    // with a zero for LastJoinTime the mismatch will cause a VVJOIN.
    //
    Cxtion->LastJoinTime = (ULONGLONG) 1;

    //
    // This is a new connection. Mark it so that we know it has not
    // complete the initial sync. Also pause it so it does not start
    // joining.
    //
    if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) && Cxtion->Inbound) {
        SetCxtionFlag(Cxtion, CXTION_FLAGS_INIT_SYNC);
        SetCxtionFlag(Cxtion, CXTION_FLAGS_PAUSED);
    }

    //
    // Update the database record in memory
    //
    OutLogCopyCxtionToCxtionRecord(Cxtion, TableCtx);
    FStatus = DbsInsertTable(ThreadCtx, Replica, TableCtx, CXTIONTablex, NULL);
    DPRINT1_FS(0, "ERROR Adding %ws\\%ws\\%ws -> %ws\\%ws",
               PRINT_CXTION_PATH(Replica, Cxtion), FStatus);

    if(FRS_SUCCESS(FStatus)) {
        NeedNewPartnerTable = TRUE;
    }
    return FStatus;
}



ULONG
OutLogDeactivatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion
)
/*++
Routine Description:

    Put the partner in the Inactive state.  Incoming ACKs can still occur but
    this partner is no longer Eligible to receive change orders.  Note that
    Outbound Change orders still go into the log and when this partner is
    again eligible to receive them the COs will be sent.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDeactivatePartner:"

    ULONG            FStatus;
    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG            COx;

    //
    // No outbound log state to deactivate for inbound cxtions
    //
    if (Cxtion->Inbound) {
        FRS_ASSERT(OutLogPartner == NULL);
        return FrsErrorSuccess;
    }

    //
    // No need to deactivate more than once, yet.
    //
    if (OutLogPartner->State == OLP_INACTIVE) {
        return FrsErrorSuccess;
    }

    OutLogAcquireLock(Replica);

    SET_OUTLOG_PARTNER_INACTIVE(Replica, OutLogPartner);

    OutLogReleaseLock(Replica);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Deactivate");

    //
    // Update the database with the current state of this partner.
    //
    FStatus = OutLogCommitPartnerState(ThreadCtx, TableCtx, Replica, Cxtion);

    return FStatus;

}



ULONG
OutLogActivatePartnerCmd(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion,
    IN BOOL        HaveLock
)
/*++
Routine Description:

    Read the connection record for this outbound partner so it can resume
    sending change orders where it left off when last deactivated.
    Put the partner into the Eligible or Standby state.  This is called
    via OutLogSubmit() and the command processor so we can read the
    connection record for the partner.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    TableCtx -- ptr to the connection table ctx.
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The outbound cxtion for this partner.
    HaveLock -- True if the caller has the Outbound log process lock on this
                replica.  Otherwise we acquire it here.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogActivatePartnerCmd:"
    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG FStatus;

    //
    // Check if this is a call to activate a partner already activated.
    //
    if ((OutLogPartner->State == OLP_ELIGIBLE) ||
        (OutLogPartner->State == OLP_STANDBY)) {
        return FrsErrorSuccess;
    }

    //
    // If the outbound log process is active for this replica and this particular
    // partner is either unjoined or inactive then get its initial state from
    // its connection record.
    //
    if ((Replica->OutLogWorkState == OL_REPLICA_WORKING) ||
        (Replica->OutLogWorkState == OL_REPLICA_WAITING)) {

        if ((OutLogPartner->State == OLP_UNJOINED) ||
            (OutLogPartner->State == OLP_INACTIVE)) {
            FStatus = OutLogReadPartner(ThreadCtx, TableCtx, Replica, Cxtion);
            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "OutLogReadPartner failed.", FStatus);
                return FStatus;
            }
        } else {
            if (OutLogPartner->State != OLP_AT_QUOTA) {
                DPRINT1(1, "ERROR - Attempt to activate partner in %s state\n",
                        OLPartnerStateNames[OutLogPartner->State]);
                return FrsErrorPartnerActivateFailed;
            }
        }
    }

    FStatus = OutLogActivatePartner(Replica, Cxtion, HaveLock);
    DPRINT_FS(1, "OutLogActivatePartner failed.", FStatus);


    return FStatus;

}

ULONG
OutLogCleanupMustSendTableWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove old entries
    from the partner's must-send table.

    The must-send table records the outlog sequence number and the time sent
    of the last change order for a given file.

    If the trailing index for this partner has passed the outlog sequence number
    of the entry and the Time since the CO was sent is greater than
    3 times the OutLogRepeatInterval then we conclude that we are unlikely to
    see a further update to this file so the entry is removed from the table.

Arguments:
    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:
    FRS status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupMustSendTableWorker:"

    ULONGLONG            DeltaTime;
    POUT_LOG_PARTNER     OutLogPartner = (POUT_LOG_PARTNER) Context;
    PDOMINANT_FILE_ENTRY MustSendEntry;

    MustSendEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);

    //
    // If the outlog partner's last saved trailing Index has passed this
    // entry by then delete it.  Use last-saved since it changes more slowly.
    //
    if (MustSendEntry->OLSeqNum < OutLogPartner->COTxLastSaved) {

        if (MustSendEntry->TimeSent > 0) {
            //
            // We have sent a CO for this File in the past.
            // If we have not sent another for DeltaTime sec since
            // COTx passed us by then remove the entry.
            // The current value for DeltaTime is 3 times the RepeatInterval.
            //
            GetSystemTimeAsFileTime((PFILETIME)&DeltaTime);
            DeltaTime -= MustSendEntry->TimeSent;
            DeltaTime /= (ULONGLONG)(10 * 1000 * 1000);

            //
            // TODO:  It would be better if we could avoid using the global
            //        value here but we don't have the ptr to the Replica struct.
            //        Need to pass Replica and OutLogPartner thru a temp context
            //        to make this work.
            //
            if (DeltaTime > 3 * GOutLogRepeatInterval) {
                FrsFree(MustSendEntry);
                TargetNode->Flags = 0;
                //
                // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
                //
                return FrsErrorDeleteRequested;
            }
        } else {
            FrsFree(MustSendEntry);
            TargetNode->Flags = 0;
            return FrsErrorDeleteRequested;
        }
    }

    return FrsErrorSuccess;
}


VOID
OutLogAssignCOLx(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
)
/*++
Routine Description:

    Check if the COs currently in outlog are enough to satisfy this connection.
    If they aren't then this connection will have to go through a full idtable scan.
    Here we are atempting to avoid a full idtable scan as it is expensive,

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The outbound cxtion for this partner.
Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogAssignCOLx:"

    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    PVOID     Key;
    PVV_ENTRY MasterVVEntry;
    PVV_ENTRY OutlogVVEntry;
    PVV_ENTRY CxtionVVEntry;
    BOOL      NeedIDTableScan;
    PCOMMAND_PACKET Cmd;

    LOCK_GEN_TABLE(Replica->VVector);
    LOCK_GEN_TABLE(Replica->OutlogVVector);
    LOCK_GEN_TABLE(Cxtion->VVector);

    NeedIDTableScan = FALSE;
    Key = NULL;
    while (MasterVVEntry = GTabNextDatumNoLock(Replica->VVector, &Key)) {
        CxtionVVEntry = GTabLookupNoLock(Cxtion->VVector, &MasterVVEntry->GVsn.Guid, NULL);
        OutlogVVEntry = GTabLookupNoLock(Replica->OutlogVVector, &MasterVVEntry->GVsn.Guid, NULL);

        DPRINT1(4, "MasterVVEntry->GVsn.Vsn : %08x %08x\n",
                PRINTQUAD(MasterVVEntry->GVsn.Vsn));
        if (OutlogVVEntry != NULL) {
            DPRINT1(4, "OutlogVVEntry->GVsn.Vsn : %08x %08x\n",
                    PRINTQUAD(OutlogVVEntry->GVsn.Vsn));
        } else {
            DPRINT(4, "OutlogVVEntry->GVsn.Vsn : <null>\n");
        }

        if (CxtionVVEntry != NULL) {
            DPRINT1(4, "CxtionVVEntry->GVsn.Vsn : %08x %08x\n",
                    PRINTQUAD(CxtionVVEntry->GVsn.Vsn));
        } else {
            DPRINT(4, "CxtionVVEntry->GVsn.Vsn : <null>\n");
        }

        if ((OutlogVVEntry != NULL) &&
            (OutlogVVEntry->GVsn.Vsn != (ULONGLONG)1) &&
            ((CxtionVVEntry == NULL) ||
             (CxtionVVEntry->GVsn.Vsn < OutlogVVEntry->GVsn.Vsn))) {

            NeedIDTableScan = TRUE;
        }
    }

    if (NeedIDTableScan == TRUE) {
        OutLogPartner->COLx = 0;
        CXTION_STATE_TRACE(3, Cxtion, Replica, 1, "F, Needs IDTable Scan");
    } else {
        OutLogPartner->COLxVVJoinDone = 0;
        OutLogPartner->COLxRestart = 0;
        OutLogPartner->COLx = Replica->OutLogCOMin;
        OutLogPartner->COTx = Replica->OutLogCOMin;
        OutLogPartner->COTxNormalModeSave = 0;
        //
        // Reset the Ack Vector and start with a fresh count of outstanding COs.
        //
        ResetAckVector(OutLogPartner);

        CXTION_STATE_TRACE(3, Cxtion, Replica, 1, "F, Bypassed IDTable Scan");

        SetFlag(OutLogPartner->Flags, OLP_FLAGS_OPT_VVJOIN_MODE);
        //
        // Make sure we are not in replay mode.
        //
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_REPLAY_MODE);

        //
        // Make sure we are not in vvjoin mode.
        //
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);


/*
        We will not need this if we force a idtable scan for all vvjoining partners
        that are in seeding state. How do we know that a vvjoining partner is in seeding
        state?

        Cmd = FrsAllocCommand(Replica->Queue, CMD_VVJOIN_SUCCESS);
        FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);
        RsReplica(Cmd) = Replica;
        RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);
        RsJoinGuid(Cmd) = FrsDupGuid(&Cxtion->JoinGuid);

        FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
*/
    }

    UNLOCK_GEN_TABLE(Replica->OutlogVVector);
    UNLOCK_GEN_TABLE(Replica->VVector);
    UNLOCK_GEN_TABLE(Cxtion->VVector);
}


ULONG
OutLogActivatePartner(
    IN PREPLICA Replica,
    IN PCXTION  PartnerCxtion,
    IN BOOL     HaveLock
)
/*++
Routine Description:

    Put the partner into the Eligible or Standby state.  Internal call only.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The outbound cxtion for this partner.
    HaveLock -- True if the caller has the Outbound log process lock on this
                replica.  Otherwise we acquire it here.
Return Value:

    Frs Status
--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogActivatePartner:"
    POUT_LOG_PARTNER OutLogPartner = PartnerCxtion->OLCtx;
    ULONG NewState;
    PLIST_ENTRY NewQueue;
    BOOL Working, Waiting, AtQuota;

    //
    // Check if this is a call to activate a partner already activated.
    //
    if ((OutLogPartner->State == OLP_ELIGIBLE) ||
        (OutLogPartner->State == OLP_STANDBY)) {
        DPRINT(3, "ERROR - Bogus call to OutLogActivatePartner\n");
        return FrsErrorSuccess;
    }

    //
    // On the first activation of this outbound connection allocate the
    // cxtion MustSend hash table to record the dominant file update change
    // order in the oubound log when multiple COs for the same file guid are
    // present.  This is necessary to ensure we send something in the case of
    // a file that is experiencing frequent updates.  The hash function is on
    // the file Guid.
    //
    if (OutLogPartner->MustSendTable == NULL) {
        OutLogPartner->MustSendTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                        OUTLOG_MUSTSEND_FILE_TABLE_SIZE);
        SET_QHASH_TABLE_FLAG(OutLogPartner->MustSendTable, QHASH_FLAG_LARGE_KEY);
        SET_QHASH_TABLE_HASH_CALC2(OutLogPartner->MustSendTable, OutLogDominantHashCalc);
        SET_QHASH_TABLE_KEY_MATCH(OutLogPartner->MustSendTable, OutLogDominantKeyMatch);
        SET_QHASH_TABLE_FREE(OutLogPartner->MustSendTable, FrsFree);
    } else {

        //
        // Each time we activate an outlog partner we scan its MustSendTable
        // for expired entries.  Change orders created for VVJoins do not
        // get inserted into the MustSendTable so skip the cleanup.
        // Note: may need something smarter here if this gets expensive.
        //
        if (!InVVJoinMode(OutLogPartner)) {
            QHashEnumerateTable(OutLogPartner->MustSendTable,
                                OutLogCleanupMustSendTableWorker,
                                OutLogPartner);
        }
    }

    if (!HaveLock) {OutLogAcquireLock(Replica);}

    //
    // If VVJOIN required then set the leading index to zero to force it.
    //
    if (CxtionFlagIs(PartnerCxtion, CXTION_FLAGS_PERFORM_VVJOIN) || OutLogPartner->COLx == 0) {

        //
        // This is either a new connection or it is a connection that we decided to
        // disable so that we could cleanup the outlog. Check if the COs currently in
        // outlog are enough to satisfy this connection. If they aren't then this
        // connection will have to go through a full idtable scan. Here we are
        // atempting to avoid a full idtable scan as it is expensive,
        //
        OutLogAssignCOLx(Replica, PartnerCxtion);
        ClearCxtionFlag(PartnerCxtion, CXTION_FLAGS_PERFORM_VVJOIN);
    }

    //
    // Ditto if we had to trim the outlog of change orders that never
    // got sent to this cxtion.
    //
    if (BooleanFlagOn(OutLogPartner->Flags, OLP_FLAGS_LOG_TRIMMED)) {
        OutLogPartner->COLx = 0;
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_LOG_TRIMMED);
    }


    FrsRemoveEntryList(&OutLogPartner->List);

    //
    // If the Outbound log process is not running for this replica,
    // stick the partner struct on the InActive list.
    // Note: we could still see more ACKs come in for this partner.
    //
    NewQueue = &Replica->OutLogInActive;
    NewState = OLP_INACTIVE;

    //
    // If the replica is in the working state, put the partner struct
    // on the standby list (if it's not at the quota limit).  The outbound
    // log process will pick it up when it first starts but if it is
    // already started it will wait until the next cycle.
    //
    // If Replica is waiting for outbound log work put the partner
    // struct on the Eligible list, set the Replica outbound log
    // state to working and insert the command packet on the queue.
    //
    Working = (Replica->OutLogWorkState == OL_REPLICA_WORKING);
    Waiting = (Replica->OutLogWorkState == OL_REPLICA_WAITING);
    AtQuota = (OutLogPartner->OutstandingCos >= OutLogPartner->OutstandingQuota);

    if (Working || Waiting) {

        if (AtQuota) {
            //
            // Activating a partner that is still at max quota for COs
            // outstanding.  Put it on the active list but it won't go to the
            // eligible list until some Acks come back.
            //
            NewQueue = &Replica->OutLogActive;
            NewState = OLP_AT_QUOTA;
            DPRINT3(1, "STILL_AT_QUOTA on OutLog partner %08x on Replica %08x, %ws\n",
                   OutLogPartner, Replica, Replica->ReplicaName->Name);
            FRS_PRINT_TYPE(0, OutLogPartner);
        } else {
            NewQueue = (Working ? &Replica->OutLogStandBy : &Replica->OutLogEligible);
            NewState = (Working ? OLP_STANDBY             : OLP_ELIGIBLE);
        }
    }

    SET_OUTLOG_PARTNER_STATE(OutLogPartner, NewState);
    InsertTailList(NewQueue, &OutLogPartner->List);

    //
    // If Replica is waiting for outbound log work set the Replica outbound
    // log state to working and insert the command packet on the queue.
    //
    if (Waiting && !AtQuota) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
        FrsSubmitCommand(Replica->OutLogCmdPkt, FALSE);
    }

    if (!HaveLock) {OutLogReleaseLock(Replica);}
    return FrsErrorSuccess;
}


ULONG
OutLogClosePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion
)
/*++
Routine Description:

    Close the partner, saving its state, and Remove the partner from the
    Outbound log process.  Free the context.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
              Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogClosePartner:"

    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG            COx;

    //
    // Not open or an inbound cxtion; done
    //
    if (OutLogPartner == NULL) {
        return FrsErrorSuccess;
    }

    OutLogAcquireLock(Replica);
    FrsRemoveEntryList(&OutLogPartner->List);
    SET_OUTLOG_PARTNER_STATE(OutLogPartner, OLP_INITIALIZING);
    OutLogReleaseLock(Replica);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Close partner");

    //
    // Update the database with the current state of this partner.
    //
    return OutLogCommitPartnerState(ThreadCtx, TableCtx, Replica, Cxtion);
}




ULONG
OutLogRemovePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION ArgCxtion
)
/*++
Routine Description:

    This partner is being removed from the database.

    Remove the partner from the Outbound log process.  If this is the last
    outbound partner for this replica set then empty the outbound log and
    set the outbound replica state to OL_REPLICA_NOPARTNERS.

Assumes:

    The connection is already removed from the connection table so we
    enumerate the table to see if any more oubound partners exist.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    ArgCxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRemovePartner:"

    PVOID           Key;
    PCXTION_RECORD  CxtionRecord = TableCtx->pDataRecord;
    ULONG           FStatus = FrsErrorSuccess;
    PCXTION         Cxtion;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Copy the fields from the cxtion into the table's cxtion record
    //
    OutLogCopyCxtionToCxtionRecord(ArgCxtion, TableCtx);

    //
    // Seek to the CxtionTable record and delete it.
    //
    FStatus = DbsDeleteTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &CxtionRecord->CxtionGuid,
                                          CrCxtionGuidxIndexx,
                                          CXTIONTablex);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "ERROR Deleting %ws\\%ws\\%ws -> %ws\\%ws",
                   PRINT_CXTION_PATH(Replica, ArgCxtion), FStatus);
        return FStatus;
    }

    NeedNewPartnerTable = TRUE;

    //
    // Inbound partner; done
    //
    if (ArgCxtion->Inbound) {
        return FStatus;
    }
    FRS_ASSERT(ArgCxtion->OLCtx);

    //
    // An embedded closepartner w/o the state update
    //
    OutLogAcquireLock(Replica);
    FrsRemoveEntryList(&ArgCxtion->OLCtx->List);
    SET_OUTLOG_PARTNER_STATE(ArgCxtion->OLCtx, OLP_INITIALIZING);
    OutLogReleaseLock(Replica);

    //
    // There may be old change orders in the outbound log that
    // weren't cleaned up because the service shut down before
    // the cleanup thread ran. Allow the cleanup thread to run
    // at least once to empty the outbound log of stale change
    // orders.
    //
    Replica->OutLogDoCleanup = TRUE;

    //
    // See if any outbound partners remain.
    //
    LOCK_CXTION_TABLE(Replica);
    Key = NULL;
    while (Cxtion = GTabNextDatumNoLock(Replica->Cxtions, &Key)) {
        if (!Cxtion->Inbound  &&
            !GUIDS_EQUAL(ArgCxtion->Name->Guid, Cxtion->Name->Guid)) {
            UNLOCK_CXTION_TABLE(Replica);
            return FStatus;
        }
    }
    UNLOCK_CXTION_TABLE(Replica);

    //
    // No outbound connections left.
    //
    OutLogAcquireLock(Replica);
    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_NOPARTNERS);
    //
    // Set outbound partners to 1 so that COs go to the
    // outbound log for future vvjoins.
    //
    Replica->OutLogCxtionsJoined = 1;
    OutLogReleaseLock(Replica);

    return FStatus;
}

ULONG
OutLogReadPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Read the outlog partner state from the connection record so we can
    reactivate the partner.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogReadPartner:"

    PCXTION_RECORD   CxtionRecord = TableCtx->pDataRecord;
    ULONG            FStatus = FrsErrorSuccess;
    POUT_LOG_PARTNER OutLogPartner;
    ULONG            COx;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Open the connection table for the replica set and read the connection
    // record identified by the connection guid.
    //
    FStatus = DbsReadTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        TableCtx,
                                        Cxtion->Name->Guid,
                                        CrCxtionGuidx,
                                        CXTIONTablex);

    if (!FRS_SUCCESS(FStatus)) {
        return FrsErrorBadOutLogPartnerData;
    }

    //
    // this record should not be for an inbound partner.
    //
    if (Cxtion->Inbound) {
        DPRINT(0, "ERROR - Can't get Outlog partner data from an imbound cxtion.\n");
        return FrsErrorBadOutLogPartnerData;
    }

    OutLogPartner = Cxtion->OLCtx;
    FRS_ASSERT(Cxtion->OLCtx);
    FRS_ASSERT(OutLogPartner->Cxtion == Cxtion);

    OutLogPartner->Flags = CxtionRecord->Flags;
    //
    // The restart point (COLxRestart) is where the leading index left off
    // when the connection last shutdown.  Set the active leading index (COLx)
    // to the saved trailing index so we can resend any change orders that had
    // not been Acked at the time the connection went down.  They could have
    // been lost in transit or if the destination crashed before writing them
    // to the inbound log.  Of course in the meantime Acks may come in for
    // those COs if the outbound partner still has them.  A few special checks
    // are made elsewhere to detect this case and keep the leading index from
    // falling behind the trailing index.  See OutLogMarkAckVector().
    //
    // COLxVVJoinDone is similar to COLxRestart except that it applies only
    // after a VVJoin has finished.  The only behaviorial difference is that
    // The out-of-order change order flag is not set because the normal mode
    // change orders that get sent on the second OutLog pass of a VVJoin are
    // sent in order.  They should get dampened if a directed CO from the VV
    // join has already sent the file.
    //
    OutLogPartner->COLxVVJoinDone = 0;
    OutLogPartner->COLxRestart = CxtionRecord->COLx;
    OutLogPartner->COLx = CxtionRecord->COTx;
    OutLogPartner->COTx = CxtionRecord->COTx;

    OutLogPartner->COTxNormalModeSave = CxtionRecord->COTxNormalModeSave;
    OutLogPartner->COTslot = CxtionRecord->COTslot;
    OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;  //CxtionRecord->OutstandingQuota
    CopyMemory(OutLogPartner->AckVector, CxtionRecord->AckVector, ACK_VECTOR_BYTES);
    OutLogPartner->AckVersion = CxtionRecord->AckVersion;

    OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    OutLogPartner->OutstandingCos = 0;

    //
    // If the change order leading index for this partner is greater than
    // where we are currently inserting new records then advance to it.
    // Use InterlockedCompareExchange to make sure it doesn't move backwards.
    // This could happen if we get context switched and another thread advances
    // the sequence number.
    //
    ADVANCE_VALUE_INTERLOCKED(&Replica->OutLogSeqNumber, OutLogPartner->COLx);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Reactivate");

    //
    // Check if we were already in vvjoin mode.
    // Force a VV join in this case.
    //
    if (InVVJoinMode(OutLogPartner) || InOptVVJoinMode(OutLogPartner)) {
        SetCxtionFlag(Cxtion, CXTION_FLAGS_PERFORM_VVJOIN);
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_OPT_VVJOIN_MODE);
        DPRINT1(4, "Clearing vvjoin mode and optimized vvjoin mode (Flags are now %08x)\n",
                OutLogPartner->Flags);
    }

    return FrsErrorSuccess;
}




ULONG
OutLogUpdatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Update the cxtion record in the database.

    ** Warning ** This gets called for both inbound and outbound connections.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogUpdatePartner:"

    ULONG               FStatus;
    PCXTION_RECORD      CxtionRecord = TableCtx->pDataRecord;
    POUT_LOG_PARTNER    OutLogPartner = Cxtion->OLCtx;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Copy the fields from the cxtion into the table's cxtion record
    //
    OutLogCopyCxtionToCxtionRecord(Cxtion, TableCtx);

    //
    // Open the table and update the requested record.
    //
    FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &CxtionRecord->CxtionGuid,
                                          CrCxtionGuidx,
                                          CXTIONTablex);

    DBS_DISPLAY_RECORD_SEV(4, TableCtx, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    NeedNewPartnerTable = TRUE;

    //
    // Track the value of the last Change Order Trailing Index saved for
    // outbound connections.
    //
    if (!Cxtion->Inbound) {
        OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    }

    return FrsErrorSuccess;
}


ULONG
OutLogProcess(
    PVOID  FrsThreadCtxArg
)
/*++
Routine Description:

    Entry point for processing output log change orders.

Arguments:

    FrsThreadCtxArg - thread

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogProcess:"

    JET_ERR              jerr, jerr1;
    ULONG                WStatus = ERROR_SUCCESS;
    ULONG                FStatus;
    NTSTATUS             Status;

    PFRS_THREAD          FrsThread = (PFRS_THREAD)FrsThreadCtxArg;
    PTHREAD_CTX          ThreadCtx;
    PTABLE_CTX           TableCtx;
    LIST_ENTRY           DeadList;
    PCOMMAND_PACKET      CmdPkt;
    PCOMMAND_PACKET      Cmd;
    PLIST_ENTRY          Entry;
    PREPLICA             Replica;
    PCXTION              PartnerCxtion;
    ULONG                COx;
    ULONG                WaitTime;
    BOOL                 CompleteCommand;

    DPRINT(0, "Outbound log processor is starting.\n");

    //
    // The database must be started before we create a jet session
    //      WARN: the database startup code will be adding command
    //      packets to our queue while we are waiting. This should
    //      be okay.
    //      WARN: The database event may be set by the shutdown
    //      code in order to force threads to exit.
    //
    WaitForSingleObject(DataBaseEvent, INFINITE);
    if (FrsIsShuttingDown) {
        ShutDownOutLog();
        goto EXIT_THREAD_NO_INIT;
    }

    //
    // Try-Finally so we shutdown Jet cleanly.
    //
    try {

    //
    // Capture exception.
    //
    try {
        //
        // Allocate a context for Jet to run in this thread.
        //
        ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);
        TableCtx = DbsCreateTableContext(CXTIONTablex);

        //
        // Setup a Jet Session returning the session ID in ThreadCtx.
        //
        jerr = DbsCreateJetSession(ThreadCtx);
        if (JET_SUCCESS(jerr)) {

            DPRINT(4,"JetOpenDatabase complete\n");
        } else {
            DPRINT_JS(0,"ERROR - OpenDatabase failed.  Thread exiting.", jerr);
            FStatus = DbsTranslateJetError(jerr, FALSE);
            DbsFreeTableContext(TableCtx, 0);
            jerr = DbsCloseJetSession(ThreadCtx);
            ThreadCtx = FrsFreeType(ThreadCtx);
            return ERROR_GEN_FAILURE;
        }

        DPRINT(0, "Outbound log processor has started.\n");

        //
        // Queue the cleanup command to the delayed command server.
        //
        Cmd = FrsAllocCommand(&OutLogWork, CMD_OUTLOG_CLEANUP);
        RsTimeout(Cmd) = 0;
        FrsDelQueueSubmit(Cmd, OUT_LOG_CLEAN_INTERVAL);

        while(TRUE) {
            Entry = FrsRtlRemoveHeadQueueTimeout(&OutLogWork, OUT_LOG_POLL_INTERVAL);
            if (Entry == NULL) {
                WStatus = GetLastError();
            } else {
                WStatus = ERROR_SUCCESS;
            }

            //
            // Check the return code from remove queue.
            //
            if (WStatus == WAIT_TIMEOUT) {
                DPRINT(5, "Wait timeout\n");
                continue;
            }

            if (WStatus == ERROR_INVALID_HANDLE) {
                DPRINT(1, "OutLog Queue was RunDown.\n");
                //
                // Queue was run down.  Time to exit.
                //
                WStatus = ERROR_SUCCESS;
                goto EXIT_LOOP;
            }

            //
            // Some other error?
            //
            CLEANUP_WS(0, "Wait for queue error", WStatus, EXIT_LOOP);

            //
            // Check for a valid command packet.
            //
            CmdPkt = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
            if (CmdPkt->Header.Type != COMMAND_PACKET_TYPE) {
                DPRINT1(0, "ERROR - Unknown packet type %d\n", CmdPkt->Header.Type);
                FrsCompleteCommand(CmdPkt, ERROR_GEN_FAILURE);
                continue;
            }

            Replica = CmdPkt->Parameters.OutLogRequest.Replica;
            PartnerCxtion = CmdPkt->Parameters.OutLogRequest.PartnerCxtion;

            //
            // If one of the commands below took an error then they may have
            // called DbsFreeTableCtx().  Fix this here.
            //
            if (IS_INVALID_TABLE(TableCtx)) {
                Status = DbsAllocTableCtx(CXTIONTablex, TableCtx);
                if (!NT_SUCCESS(Status)) {
                    DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                    DbsFreeTableCtx(TableCtx, 1);
                    FrsCompleteCommand(CmdPkt, ERROR_GEN_FAILURE);
                    continue;
                }
            }


            // Note: add try except around the command rather than process terminate

            CompleteCommand = TRUE;
            switch (CmdPkt->Command) {

            case CMD_OUTLOG_WORK_CO:
                DPRINT(5, "OutLogProcessReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
                    break;
                }
                //
                // Process outbound log change orders for this Replica set.
                //
                FStatus = OutLogProcessReplica(ThreadCtx, Replica);

                //
                // If more work to do then requeue the command packet at the end
                // to give other replica sets a chance.
                //
                if (FStatus == FrsErrorMoreWork) {
                    if (!FrsIsShuttingDown) {
                        FrsSubmitCommand(CmdPkt, FALSE);
                        FStatus = FrsErrorSuccess;
                    }
                }

                //
                // If we finished all the work on this replica then we leave it off the
                // queue.  When more work arrives the cmd packet is re-submitted.
                //
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "ERROR: OutLogProcessReplica failed.", FStatus);
                    WStatus = ERROR_GEN_FAILURE;
                }
                break;



            case CMD_OUTLOG_ADD_REPLICA:
                DPRINT(5, "OutLogAddReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogAddReplica(ThreadCtx, Replica);
                break;

            case CMD_OUTLOG_REMOVE_REPLICA:
                DPRINT(5, "OutLogRemoveReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogRemoveReplica(ThreadCtx, Replica);
                break;

            case CMD_OUTLOG_INIT_PARTNER:
                DPRINT(5, "OutLogInitPartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogInitPartner(Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_ADD_NEW_PARTNER:
                DPRINT(5, "OutLogAddNewPartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogAddNewPartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_UPDATE_PARTNER:
                DPRINT(5, "OutLogUpdatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogUpdatePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_DEACTIVATE_PARTNER:
                DPRINT(5, "OutLogDeactivatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogDeactivatePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_ACTIVATE_PARTNER:
                DPRINT(5, "OutLogActivatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogActivatePartnerCmd(ThreadCtx,
                                                   TableCtx,
                                                   Replica,
                                                   PartnerCxtion,
                                                   FALSE);
                break;

            case CMD_OUTLOG_CLOSE_PARTNER:
                DPRINT(5, "OutLogClosePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogClosePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_REMOVE_PARTNER:
                DPRINT(5, "OutLogRemovePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogRemovePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_RETIRE_CO:
                DPRINT(5, "OutLogRetireCo CALL <<<<<<<<<<<<<<<<<<<< \n");
                COx = CmdPkt->Parameters.OutLogRequest.SequenceNumber;
                FStatus = OutLogRetireCo(Replica, COx, PartnerCxtion);
                break;

            case CMD_OUTLOG_CLEANUP:
                DPRINT(5, "OutLogCleanup CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogCleanup(ThreadCtx, CmdPkt);
                if (FRS_SUCCESS(FStatus)) {
                    CompleteCommand = FALSE;
                }
                break;

            default:
                DPRINT1(0, "ERROR - Unknown OutLog command %d\n", (ULONG)CmdPkt->Command);
                FStatus = FrsErrorInvalidOperation;

            }  // end switch

            //
            // Retire the command packet. (Note if this is our "work" packet the
            // completion routine is a no-op).
            //
            if (CompleteCommand == TRUE) {
                FrsCompleteCommand(CmdPkt, FStatus);
            }

            continue;

EXIT_LOOP:
            break;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        //
        // Shutdown
        //
        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "Outlog finally.", WStatus);

        //
        // Do outbound log cleanup on each replica if something happened.
        //
        ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
            // Loop iterator pE is type PREPLICA.
            if (pE->OutLogDoCleanup) {
                DPRINT3(4, "OutLog Cleanup for replica %ws, id: %d, (%08x)\n",
                        pE->ReplicaName->Name, pE->ReplicaNumber, pE);
                OutLogCleanupLog(ThreadCtx, pE);
            }
            //
            // Close down the connection info on each outbound partner.
            //
            OutLogRemoveReplica(ThreadCtx, pE);
        );

        DbsFreeTableContext(TableCtx, 0);

        //
        // Now close the jet session and free the Jet ThreadCtx.
        //
        jerr = DbsCloseJetSession(ThreadCtx);

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"DbsCloseJetSession error:", jerr);
        } else {
            DPRINT(4,"DbsCloseJetSession complete\n");
        }

        ThreadCtx = FrsFreeType(ThreadCtx);
    }

EXIT_THREAD_NO_INIT:
    DPRINT1(3, "<<<<<<<...T E R M I N A T I N G -- %s...>>>>>>>>\n", DEBSUB);


    DPRINT(0, "Outbound log processor is exiting.\n");

    //
    // Trigger FRS shutdown if we terminated abnormally.
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "Outbound log processor terminated abnormally, rundown outlog queue.\n");
        ShutDownOutLog();
        DPRINT(0, "Outbound log processor terminated abnormally, forcing service shutdown.\n");
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);
    }

    ThSupSubmitThreadExitCleanup(FrsThreadCtxArg);
    ExitThread(WStatus);


    return ERROR_SUCCESS;

}


ULONG
OutLogProcessReplica(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
)
/*++
Routine Description:

    New work has arrived for this replica.  This could be due to a new change
    order arriving in the outbound log or an outbound partner could have
    acknowledged a change order making it eligible to receive the next one.

    There could be many change orders queued for this replica set.  To keep
    this replica set from consuming resources to the exclusion of other
    replica sets we process a limited number of change orders and then return
    with stats FrsErrorMoreWork.  This causes the command packet to be requeued
    at the end of the OutLogWork queue so we can service other replica sets.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status
        FrsErrorMoreWork - if there is more work to do on this Replica Set.
        FrsErrorSuccess  - if there is no more work or no eligible outbound
                           parnters for this replica set.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogProcessReplica:"

    ULONG FStatus;
    PLIST_ENTRY Entry;
    POUT_LOG_PARTNER Partner;
    ULONG JointLeadingIndex;
    PCHANGE_ORDER_COMMAND CoCmd;
    BOOL MoreCo;
    ULONG LoopCheck = 0;

    //
    // Get the outbound log lock for this replica and hold it until we
    // are finished.  If this is a performance problem with the Ack side
    // then split the lock.
    //
    OutLogAcquireLock(Replica);

    Replica->OutLogRepeatInterval = GOutLogRepeatInterval;

    //
    // A delay before processing the OutLog can give frequently changing files
    // a chance to get into the DominantFileTable.  The question is what is
    // the right delay and where is the right place to put it?
    //
    // Sleep(20*1000);

START_OVER:
    JointLeadingIndex = 0xFFFFFFFF;

    if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }


    //
    // Move standby partner entries to the Eligible list.
    //
    ForEachSimpleListEntry(&Replica->OutLogStandBy, OUT_LOG_PARTNER, List,
        // Iterator pE is type *OUT_LOG_PARTNER
        FrsRemoveEntryList(&pE->List);
        pE->State = OLP_ELIGIBLE;
        InsertTailList(&Replica->OutLogEligible, &pE->List);
    );

    //
    // Find the Joint Leading Index for the current group of Eligible partners.
    //
    ForEachSimpleListEntry(&Replica->OutLogEligible, OUT_LOG_PARTNER, List,
        // Iterator pE is type *OUT_LOG_PARTNER

        //
        // A zero in COLx could mean any of the following:
        // 1. This is the first time the partner has ever joined
        // 2. A previous VV Join was interrupted
        // 3. Change order's destined for cxtion were trimmed from the log.
        // 4. The last join time on this connection does not match
        //    (implies DB inconsistency)
        // so do a VVJoin.
        //
        if  (pE->COLx == 0) {
            FStatus = OutLogPartnerVVJoinStart(ThreadCtx, Replica, pE);

            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "Error return from OutLogPartnerVVJoinStart:", FStatus);
                FrsRemoveEntryList(&pE->List);
                InsertTailList(&Replica->OutLogActive, &pE->List);
                FRS_PRINT_TYPE(0, pE);
                continue;
            }
        }

        if (pE->COLx < JointLeadingIndex) {
            JointLeadingIndex = pE->COLx;
        }
    );


    DPRINT1(4, "JointLeadingIndex = 0x%x\n", JointLeadingIndex);
    if (IsListEmpty(&Replica->OutLogEligible)) {
        DPRINT(4, "OutLogEligible list is empty\n");
    }

    //
    // Send change orders to the partners on the eligible list.
    //
    MoreCo = TRUE;
    while (!IsListEmpty(&Replica->OutLogEligible) && !FrsIsShuttingDown) {

        FStatus = OutLogReadCo(ThreadCtx, Replica, JointLeadingIndex);

        if (FStatus == FrsErrorRecordLocked) {
            //
            // We hit the end of the log.  That's it for now.   Change the
            // Replica state to waiting if nothing appeared on the standby list.
            //
            MoreCo = FALSE;
            break;
        } else

        if (FStatus == FrsErrorNotFound) {
            //
            // Deleted log record.  Update ack vector and leading index
            // for each eligible partner and go to the next record.
            // The change order has already been sent and cleaned up.
            //
            OutLogSkipCo(Replica, JointLeadingIndex);

        } else

        if (FRS_SUCCESS(FStatus)){
            //
            // Process the change order.
            // Clear IFLAG bits we don't want to send to outbound partner.
            // Save the Ack sequence number in the CO command so the outbound
            // partner can return it to us.  It's in CO command record so it
            // lives across CO retries in the outbound partner.
            //
            CoCmd = (PCHANGE_ORDER_COMMAND) Replica->OutLogTableCtx->pDataRecord;
            ClearFlag(CoCmd->IFlags, CO_IFLAG_GROUP_OL_CLEAR);
            CoCmd->PartnerAckSeqNumber = CoCmd->SequenceNumber;

            //
            // Send the change order to each Eligible partner.
            //
            Entry = GetListHead(&Replica->OutLogEligible);

            while( Entry != &Replica->OutLogEligible) {
                Partner = CONTAINING_RECORD(Entry, OUT_LOG_PARTNER, List);
                Entry = GetListNext(Entry);

                if(OutLogSendCo(ThreadCtx,
                                Replica,
                                Partner,
                                CoCmd,
                                JointLeadingIndex)) {
                    LoopCheck += 1;
                    FRS_ASSERT(LoopCheck < 1000);
                    goto START_OVER;
                }
            }
        } else {

            //
            // When outlog triming is added see if the jet read is getting
            // JET_errNoCurrentRecord (which otherwise is mapped to FrsErrorInternalError
            //
            DPRINT_FS(0, "ERROR - Unexpected return from OutLogReadCo.", FStatus);
            MoreCo = FALSE;
            break;
        }


        JointLeadingIndex += 1;
    }   // while loop over change orders.

    //
    // Check the Eligible or Standby lists for more work.
    //
    if (IsListEmpty(&Replica->OutLogStandBy) &&
        (!MoreCo || IsListEmpty(&Replica->OutLogEligible)) ) {
        FStatus = FrsErrorSuccess;
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WAITING);
    } else {
        FStatus = FrsErrorMoreWork;
    }


    OutLogReleaseLock(Replica);
    return FStatus;
}

BOOL
OutLogSendCo(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    POUT_LOG_PARTNER      Partner,
    PCHANGE_ORDER_COMMAND CoCmd,
    ULONG                 JointLeadingIndex
)
/*++
Routine Description:

    Send the change order to the specified outbound partner.

    Assumes caller has the OutLog lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Partner -- ptr to outbound partner context
    CoCmd  -- Change order to send
    JointLeadingIndex -- Sequence number of OutLog CO being sent.

Return Value:

    TRUE - State change requires caller to reevaluate JointLeadingIndex.
    FALSE - Request processed normally

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSendCo:"

#define OLSEND_UPDATE_JLX  (TRUE)
#define OLSEND_KEEP_JLX    (FALSE)

    ULONG      FStatus;
    BOOL       CoDampened, SendIt;
    BOOL       AdjustCOLx;
    PCXTION    Cxtion;
    BOOL       ReevaluateJLx = OLSEND_KEEP_JLX;
    PCHAR      SendTag       = "NotSent";
    ULONG      jerr;
    TABLE_CTX  TempTableCtx;
    PTABLE_CTX TableCtx      = &TempTableCtx;

    //
    // If the Ack Vector has wrapped such that we are still waiting
    // for an Ack from the change order in the next slot then we
    // have to stall until the Ack comes in.  This can happen if
    // the CO is fetching a large file or we run into a slug of
    // dampened COs which we quickly run thru.
    //
    if (AVWrapped(Partner)) {
        SET_OUTLOG_PARTNER_AVWRAP(Replica, Partner);
        FRS_PRINT_TYPE(1, Partner);
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, "AVWrap ", Replica, Partner->Cxtion);
        //
        // Force a rejoin if the ack vector remains wrapped and there
        // is no network activity from this cxtion's partner. The
        // unacked cos will be resent when the cxtion is rejoined.
        //
        Cxtion = Partner->Cxtion;
        if (Cxtion &&
            CxtionStateIs(Cxtion, CxtionStateJoined)) {
            RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_HUNG_CXTION);
        }
        return OLSEND_UPDATE_JLX;
    }

    //
    // If we have already sent this CO to the partner then move on
    // to the next partner in the list.
    //
    if (JointLeadingIndex < Partner->COLx) {
        CHANGE_ORDER_TRACE2_OLOG(5, CoCmd, "Skip JLx<COLx ", Replica, Partner->Cxtion);
        return OLSEND_KEEP_JLX;
    }

    FRS_ASSERT(JointLeadingIndex == Partner->COLx);

    //
    // Send out the CO.  The Ack Vector bit could be set if this is
    // a reactivation of the partner or the partner has recently left
    // VVJoin mode.  Don't send the CO again.
    // The CO could also be dampened later based on the version vector.
    //
    CoDampened = SendIt = FALSE;

    if (ReadAVBit(Partner->COLx, Partner) == 1) {
        //
        // The AckVector bit was one.  Clear it and don't send CO.
        //
        ClearAVBit(Partner->COLx, Partner);
        SendTag = "Skip AV=1";
        goto SEND;
    }


    //
    // If this connection is in VVJoin Mode then only send it
    // directed change orders.  Otherwise send out all COs.
    //
    if (!BooleanFlagOn(CoCmd->Flags, CO_FLAG_DIRECTED_CO)) {
        //
        // This is a normal CO.
        // If destination partner is in VVJoin Mode then don't send.
        //
        if (InVVJoinMode(Partner)) {
            DPRINT3(4, "%-11ws (%08x %08x): Partner in VVJoin Mode, hold normal COs - "
                    "Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
                    CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
                    PRINT_CXTION_PATH(Replica, Partner->Cxtion));
            SendTag = "Skip INVVJoin";
        } else {

            if (InReplayMode(Partner) && VVHasVsn(Partner->Cxtion->VVector, CoCmd)) {
                //
                // If we are in the replay range of a completed VVJoin then mark
                // this CO as out of order if it is going to be dampened by the
                // VV on the cxtion.
                // If while we are scanning through the idtable to build tables
                // for vvjoin 2 COs come in the system. The one with lower VSN
                // updates/creates a entry in the idtable before our current scan point
                // and the other CO with higher VSN updates/creates entry at a point
                // ahead of the current scan point. We will send the CO for the higher
                // VSN which will update the VV for that connection as part of vvjoin.
                // Later when we do out replay we will dampen the CO with the lower VSN
                // which has never been sent to the downstream partner.
                //
                SetFlag(CoCmd->Flags, CO_FLAG_OUT_OF_ORDER);
            }

            SendIt = TRUE;
        }
        goto SEND;
    }

    //
    // This is a directed CO.
    // If it is not for this connection then don't send it.
    //
    if (!GUIDS_EQUAL(Partner->Cxtion->Name->Guid, &CoCmd->CxtionGuid)) {
        DPRINT3(4, "%-11ws (%08x %08x): Not sending directed CO to "
                "Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
                CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
                PRINT_CXTION_PATH(Replica, Partner->Cxtion));
        SendTag = "Skip DirCO";
        goto SEND;
    }

    //
    // This is a directed CO for this connection.  If we are in the
    // replay range of a completed VVJoin then don't send it again.
    // NOTE: This only works if no directed COs are sent to this
    // outbound partner other than VVJoin COs while in VVJoin Mode.
    // This is currently true.  Refresh change order requests don't
    // go through the outbound log.
    //
    if (Partner->COLx < Partner->COLxVVJoinDone) {
        // This CO was already sent.
        SendTag = "Skip COLx<VVJoinDone";
        goto SEND;
    }

    //
    // Send it but check if it is a control change order first.
    //
    SendIt = TRUE;
    DPRINT3(4, "%-11ws (%08x %08x): Sending directed CO to Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
            CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
            PRINT_CXTION_PATH(Replica, Partner->Cxtion));

    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_CONTROL)) {
        //
        // Currently don't prop control change orders.
        //
        SendIt = FALSE;

        //
        // Check for a control CO that is terminating a VVJoin on this connection.
        //
        if ((CoCmd->ContentCmd == FCN_CO_NORMAL_VVJOIN_TERM) ||
            (CoCmd->ContentCmd == FCN_CO_ABNORMAL_VVJOIN_TERM)) {

            //
            // If this is a normal termination and we are currently in replay mode
            // then come out of the replay mode.
            //
            if (InReplayMode(Partner) && (CoCmd->ContentCmd == FCN_CO_NORMAL_VVJOIN_TERM)) {
                ClearFlag(Partner->Flags, OLP_FLAGS_REPLAY_MODE);

                //
                // Open the connection table and update the partner state.
                //
                TableCtx->TableType = TABLE_TYPE_INVALID;
                TableCtx->Tid = JET_tableidNil;

                jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
                if (!JET_SUCCESS(jerr)) {
                    DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                                Replica->ReplicaNumber, jerr);
                }

                OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, Partner);

                DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
                DbsFreeTableCtx(TableCtx, 1);

                FRS_PRINT_TYPE(4, Partner);

                DPRINT1(4, "Replay mode completed: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                goto SEND;
            }

            if (!InVVJoinMode(Partner)) {
                DPRINT1(4, "Not in vvjoin mode: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                goto SEND;
            }
            //
            // Losing track of the outstanding cos can result in lost change
            // orders for a trigger cxtion.  So wait for the outstanding change
            // orders to finish.
            //
            if (Partner->OutstandingCos) {
                //
                // Pretend it is at quota to reuse an existing codepath
                //
                DPRINT2(4, "WARN - Waiting for %d Cos at vvjoindone: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        Partner->OutstandingCos, PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
                return OLSEND_UPDATE_JLX;
            }

            FStatus = OutLogPartnerVVJoinDone(ThreadCtx, Replica, Partner);
            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "Error return from OutLogPartnerVVJoinDone:", FStatus);
                FrsRemoveEntryList(&Partner->List);
                InsertTailList(&Replica->OutLogActive, &Partner->List);
                FRS_PRINT_TYPE(0, Partner);
                return OLSEND_KEEP_JLX;
            }

            //
            // If termination was abnormal then start it up again.
            //
            if (CoCmd->ContentCmd == FCN_CO_ABNORMAL_VVJOIN_TERM) {
                FStatus = OutLogPartnerVVJoinStart(ThreadCtx, Replica, Partner);
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "Error return from OutLogPartnerVVJoinStart:", FStatus);
                    FrsRemoveEntryList(&Partner->List);
                    InsertTailList(&Replica->OutLogActive, &Partner->List);
                    FRS_PRINT_TYPE(0, Partner);
                    return OLSEND_KEEP_JLX;
                }
            }

            //
            // Leading index was changed for connection reevaluate JointLeadingIndex.
            //
            return OLSEND_UPDATE_JLX;
        }

        if (CoCmd->ContentCmd == FCN_CO_END_OF_JOIN) {
            if (Partner->Cxtion->PartnerMinor < NTFRS_COMM_MINOR_3) {
                DPRINT3(2, "WARN - Downrev partner (%d (them) < %d (us)): %ws\\%ws\\%ws -> %ws\\%ws\n",
                        Partner->Cxtion->PartnerMinor, NtFrsCommMinor,
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));

            //
            // This control co is for this join and the join is still valid
            //
            } else
            if (CoCmd->EventTime.QuadPart == (LONGLONG)Partner->Cxtion->LastJoinTime &&
                CxtionStateIs(Partner->Cxtion, CxtionStateJoined)) {

                if (Partner->OutstandingCos > 0) {
                    //
                    // Pretend it is at quota to reuse an existing codepath
                    //
                    DPRINT2(4, "WARN - Waiting for %d Cos at end of join: %ws\\%ws\\%ws -> %ws\\%ws\n",
                            Partner->OutstandingCos, PRINT_CXTION_PATH(Replica, Partner->Cxtion));

                    SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
                    return OLSEND_UPDATE_JLX;
                } else {

                    DPRINT1(4, "Unjoining at end of join: %ws\\%ws\\%ws -> %ws\\%ws\n",
                            PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                    //
                    // Stop sending change orders and unjoin the cxtion
                    //
                    SET_OUTLOG_PARTNER_UNJOINED(Replica, Partner);
                    RcsSubmitReplicaCxtion(Replica, Partner->Cxtion, CMD_UNJOIN);
                }
            } else {
                DPRINT1(4, "Ignoring; end-of-join guid invalid: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
            }

        } else if (CoCmd->ContentCmd == FCN_CO_END_OF_OPTIMIZED_VVJOIN) {
            //
            // This control co is for this join and the join is still valid
            //
            if (CoCmd->EventTime.QuadPart == (LONGLONG)Partner->Cxtion->LastJoinTime &&
                CxtionStateIs(Partner->Cxtion, CxtionStateJoined) &&
                InOptVVJoinMode(Partner)) {

                if (Partner->OutstandingCos > 0) {
                    //
                    // Pretend it is at quota to reuse an existing codepath
                    //
                    DPRINT2(4, "WARN - Waiting for %d Cos at end-of-opt-vvjoin: %ws\\%ws\\%ws -> %ws\\%ws\n",
                            Partner->OutstandingCos, PRINT_CXTION_PATH(Replica, Partner->Cxtion));

                    //
                    // We have to send this multiple times because we do not have
                    // a mechanism to reliably deliver this message to the downstream
                    // partner.
                    //
                    DPRINT1(4, "Sending vvjoinsuccess at end-of-opt-vvjoin : %ws\\%ws\\%ws -> %ws\\%ws\n",
                            PRINT_CXTION_PATH(Replica, Partner->Cxtion));

                    RcsSubmitReplicaCxtion(Replica, Partner->Cxtion, CMD_VVJOIN_SUCCESS);

                    SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
                    return OLSEND_UPDATE_JLX;

                } else {

                    DPRINT1(4, "Sending vvjoinsuccess at end-of-opt-vvjoin : %ws\\%ws\\%ws -> %ws\\%ws\n",
                            PRINT_CXTION_PATH(Replica, Partner->Cxtion));

                    RcsSubmitReplicaCxtion(Replica, Partner->Cxtion, CMD_VVJOIN_SUCCESS);

                    ClearFlag(Partner->Flags, OLP_FLAGS_OPT_VVJOIN_MODE);

                    //
                    // Open the connection table and update the partner state.
                    //
                    TableCtx->TableType = TABLE_TYPE_INVALID;
                    TableCtx->Tid = JET_tableidNil;

                    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
                    if (!JET_SUCCESS(jerr)) {
                        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                                    Replica->ReplicaNumber, jerr);
                    }

                    OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, Partner);

                    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
                    DbsFreeTableCtx(TableCtx, 1);

                    FRS_PRINT_TYPE(4, Partner);
                }


            } else {
                DPRINT1(4, "Ignoring; end-of-opt-vvjoin guid invalid: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
            }
        } else {
            DPRINT2(0, "WARN - Ignoring bad control code %d: %ws\\%ws\\%ws -> %ws\\%ws\n",
                    CoCmd->ContentCmd, PRINT_CXTION_PATH(Replica, Partner->Cxtion));
        }
    }



SEND:
    //
    // Send the CO if enabled.  If it was dampened then set the Ack flag here.
    //
    AdjustCOLx = TRUE;

    ReevaluateJLx = OLSEND_KEEP_JLX;
    if (SendIt) {

        //
        // If this connection is being restarted and the leading
        // index is less than the Restart leading index then mark
        // the CO out of order so it can get past VV dampening checks.
        // We don't know what may have been sent and acked ahead of
        // this point.
        //
        if (Partner->COLx < Partner->COLxRestart) {
            SetFlag(CoCmd->Flags, CO_FLAG_OUT_OF_ORDER);
        }

        //
        // Finally check to see if there is a more recent change order for
        // this file in the OutLogDominantFileTable for this Replica Set.
        //
        SendIt = OutLogOptimize(Replica, Partner, CoCmd, &SendTag);
        if (!SendIt) {
            goto SEND;
        }

        //
        // Increment the Local OR Remote CO Sent counters for both the
        // replica set and the connection.
        //
        if (COC_FLAG_ON(CoCmd, CO_FLAG_LOCALCO)) {
            //
            // Its a Local CO
            //
            PM_INC_CTR_REPSET(Replica, LCOSent, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, LCOSent, 1);
        }
        else if (!COC_FLAG_ON(CoCmd, CO_FLAG_CONTROL)) {
            //
            // Its a Remote CO
            //
            PM_INC_CTR_REPSET(Replica, RCOSent, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, RCOSent, 1);
        }

        //
        // Set the Ack Vector Version number into the change order for match
        // up later when the Ack comes in.
        //
        CoCmd->AckVersion = Partner->AckVersion;

        CoDampened = !RcsSendCoToOneOutbound(Replica, Partner->Cxtion, CoCmd);
        if (CoDampened) {
            SendTag = "VVDampened";
            //
            // Increment the OutBound CO dampned counter for both the
            // replica set and the connection.
            //
            PM_INC_CTR_REPSET(Replica, OutCODampned, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, OutCODampned, 1);

        }
    } else {
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, SendTag, Replica, Partner->Cxtion);
        SendTag = NULL;
    }

    if (CoDampened || !SendIt) {
        //
        // CO was dampened.  Set the Ack flag in the ack vector and
        // advance the trailing index for this partner.  The bits
        // behind the trailing index are cleared.
        //
        AdjustCOLx = OutLogMarkAckVector(Replica, Partner->COLx, Partner);
    } else {
        //
        // It was sent.  If the partner has hit its quota of outstanding
        // COs remove it move it from the Eligible list to the Active List.
        // Have the caller reevaluate the joint leading index so it can jump
        // ahead to the next CO to send.
        //
        Partner->OutstandingCos += 1;
        if (Partner->OutstandingCos >= Partner->OutstandingQuota) {
            SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
            ReevaluateJLx = OLSEND_UPDATE_JLX;
        }

        SendTag = "Send";

    }

    if (SendTag != NULL) {
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, SendTag, Replica, Partner->Cxtion);
    }

    if (AdjustCOLx) {
        Partner->COLx += 1;
    }

    //
    // Save the max Outlog progress point for error checks.
    //
    if (Partner->COLx > Replica->OutLogCOMax) {
        Replica->OutLogCOMax = Partner->COLx;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4, Partner, Partner->COLx-1,
                               (CoDampened || !SendIt ? "dampened" : "send"));

    return ReevaluateJLx;
}


BOOL
OutLogOptimize(
    IN PREPLICA              Replica,
    IN POUT_LOG_PARTNER      Partner,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    OUT PCHAR                *SendTag
)
/*++
Routine Description:

    Finally check to see if there is a more recent change order for
    this file in the OutLogDominantFileTable and that this CO is not
    already in our MustSend Table for this connection.

    Assumes caller has the OutLog lock.

Arguments:
    Replica -- The replica set struct for the outbound log.
    Partner -- ptr to outbound partner context
    CoCmd  -- Change order to send
    SendTag -- return a ptr to a tag string for logging.

Return Value:
    TRUE - This CO must be sent out.
    FALSE - This CO can be skipped.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogOptimize:"

    ULONGLONG             DeltaTime;
    PQHASH_ENTRY          QHashEntry;
    PDOMINANT_FILE_ENTRY  MustSendEntry, DomFileEntry;

    //
    // If not a valid candidate for skipping then send it.
    //
    // TODO: If the CO in the dominant file table is a delete then we should
    //       favor it and suppress a create CO.  This will evaporate a
    //       create - delete sequence.
    //
    if ((Replica->OutLogRepeatInterval == 0) ||
        !OutLogFavorDominantFile(CoCmd)) {
        goto SEND_IT;
    }

    QHashAcquireLock(Partner->MustSendTable);

    QHashEntry = QHashLookupLock(Partner->MustSendTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        //
        // Found a match check if this is our MustSend CO.
        //
        DPRINT1(4, "OPT: hit in MustSend Table for COx 0x%x\n", CoCmd->SequenceNumber);
        MustSendEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
        if (MustSendEntry->OLSeqNum > CoCmd->SequenceNumber) {
            //
            // Not yet.
            //
            QHashReleaseLock(Partner->MustSendTable);
            *SendTag = "Skip, Not Dominant";
            goto DO_NOT_SEND;
        }

        if (MustSendEntry->TimeSent > 0) {
            //
            // We have sent a CO for this File in the past.
            // Do not send another for at least RepeatInterval seconds if
            // there is a more recent CO in the DominantFileTable.
            //
            GetSystemTimeAsFileTime((PFILETIME)&DeltaTime);
            DeltaTime -= MustSendEntry->TimeSent;
            DeltaTime /= (ULONGLONG)(10 * 1000 * 1000);
            if (DeltaTime < Replica->OutLogRepeatInterval) {
                //
                // We sent one less than RepeatInterval seconds ago.  Don't
                // send this one if we have a later one in the Dominant
                // File Table.
                //
                QHashAcquireLock(Replica->OutLogDominantTable);
                QHashEntry = QHashLookupLock(Replica->OutLogDominantTable,
                                             &CoCmd->FileGuid);
                if (QHashEntry != NULL) {
                    DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
                    if (DomFileEntry->OLSeqNum > CoCmd->SequenceNumber){
                        //
                        // There is a later one so skip this one.  But don't
                        // update the MustSendEntry since the later one may
                        // be a long distance back in the queue and we may hit
                        // another CO for this file in the mean time but after
                        // the RepeatInterval has been exceeded.
                        //
                        *SendTag = "Skip, To soon to send";
                        QHashReleaseLock(Replica->OutLogDominantTable);
                        QHashReleaseLock(Partner->MustSendTable);
                        goto DO_NOT_SEND;
                    }
                }
                QHashReleaseLock(Replica->OutLogDominantTable);
            }
        }
        //
        // No dominant CO found.  Send this one.
        //
        MustSendEntry->OLSeqNum = CoCmd->SequenceNumber;
        GetSystemTimeAsFileTime((PFILETIME)&MustSendEntry->TimeSent);

        QHashReleaseLock(Partner->MustSendTable);
        goto SEND_IT;
    }

    //
    // No entry in MustSendTable for this connection.
    // Check for an entry in the OutLog Dominant File Table.
    //
    DPRINT1(4, "OPT: miss in MustSend Table for COx 0x%x\n", CoCmd->SequenceNumber);
    QHashAcquireLock(Replica->OutLogDominantTable);
    QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);

        //if (DomFileEntry->OLSeqNum >= CoCmd->SequenceNumber) {
            //
            // This CO can be skipped, but make entry in the MustSend table
            // so we have the time sent for future checks.
            //
            MustSendEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
            if (MustSendEntry != NULL) {
                memcpy(MustSendEntry, DomFileEntry, sizeof(DOMINANT_FILE_ENTRY));
                MustSendEntry->Flags = 0;
                MustSendEntry->TimeSent = 0;

                QHashEntry = QHashInsertLock(Partner->MustSendTable,
                                             &CoCmd->FileGuid,
                                             NULL,
                                             (ULONG_PTR) MustSendEntry);
                if (QHashEntry != NULL) {
                    DPRINT1(4, "OPT: new entry made in MustSend Table for COx 0x%x\n",
                            CoCmd->SequenceNumber);
                    if (DomFileEntry->OLSeqNum != CoCmd->SequenceNumber){
                        //
                        // We can skip it since there is a later one.
                        // Still made the entry above so we have the
                        // TimeSent for future checks.
                        //
                        QHashReleaseLock(Replica->OutLogDominantTable);
                        QHashReleaseLock(Partner->MustSendTable);
                        *SendTag = "Skip, New Dominant";
                        goto DO_NOT_SEND;
                    } else {
                        GetSystemTimeAsFileTime((PFILETIME)&MustSendEntry->TimeSent);
                    }
                } else {
                    DPRINT(4, "++ WARN - Failed to insert entry into Partner MustSendTable\n");
                    FrsFree(MustSendEntry);
                }
            }
        //}
    } else {
        DPRINT1(4, "OPT: miss in Dom Table for COx 0x%x\n", CoCmd->SequenceNumber);
    }

    QHashReleaseLock(Replica->OutLogDominantTable);
    QHashReleaseLock(Partner->MustSendTable);

SEND_IT:

    return TRUE;

DO_NOT_SEND:

    PM_INC_CTR_REPSET(Replica, OutCODampned, 1);
    PM_INC_CTR_CXTION(Partner->Cxtion, OutCODampned, 1);
    return FALSE;
}

VOID
OutLogSkipCo(
    PREPLICA              Replica,
    ULONG                 JointLeadingIndex
)
/*++
Routine Description:

    The change order at this index has been deleted so skip over it
    for all eligible outbound partners.

    Assumes caller has the OutLog lock.

Arguments:

    Replica -- The replica set struct for the outbound log.
    JointLeadingIndex -- Sequence number of OutLog CO being skiped.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSkipCo:"

    ULONG FStatus;
    PLIST_ENTRY Entry;
    POUT_LOG_PARTNER Partner;
    BOOL AdjustCOLx;


    //
    // Skip over the CO for each Eligible partner.
    //
    Entry = GetListHead(&Replica->OutLogEligible);

    while( Entry != &Replica->OutLogEligible) {
        Partner = CONTAINING_RECORD(Entry, OUT_LOG_PARTNER, List);
        Entry = GetListNext(Entry);

        //
        // If the Ack Vector has wrapped such that we are still waiting
        // for an Ack from the change order in the next slot then we
        // have to stall until the Ack comes in.  This can happen if
        // the CO is fetching a large file or we run into a slug of
        // dampened COs which we quickly run thru.
        //
        // Note: can not wait forever.  need to force a rejoin at some
        // point. Integrate this with outlog trimming since both will
        // force a VVJoin.
        //
        if (AVWrapped(Partner)) {
            SET_OUTLOG_PARTNER_AVWRAP(Replica, Partner);
            FRS_PRINT_TYPE(1, Partner);
            continue;
        }

        //
        // If we have already sent this CO to the partner then move on
        // to the next partner in the list.
        //
        if (JointLeadingIndex < Partner->COLx) {
            continue;
        }

        FRS_ASSERT(JointLeadingIndex == Partner->COLx);

        //
        // The Ack Vector bit could be set if this is
        // a reactivation of the partner or the partner has recently left
        // VVJoin mode.
        //

        if (ReadAVBit(Partner->COLx, Partner) == 1) {
            //
            // The AckVector bit was one, clear it.
            //
            ClearAVBit(Partner->COLx, Partner);
        }

        //
        // CO was skipped.  Set the Ack flag in the ack vector and
        // advance the trailing index for this partner.  The bits
        // behind the trailing index are cleared.
        //
        AdjustCOLx = OutLogMarkAckVector(Replica, Partner->COLx, Partner);

        if (AdjustCOLx) {
            Partner->COLx += 1;
        }

        //
        // Save the max Outlog progress point for error checks.
        //
        if (Partner->COLx > Replica->OutLogCOMax) {
            Replica->OutLogCOMax = Partner->COLx;
        }

        //OUT_LOG_DUMP_PARTNER_STATE(4, Partner, Partner->COLx-1, "Co Deleted");

    }  // while on eligible list

    return;
}



ULONG
OutLogCommitPartnerState(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Update the database with the current state for the specified partner.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The Outbound Partner that is Acking the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCommitPartnerState:"

    return OutLogUpdatePartner(ThreadCtx, TableCtx, Replica, Cxtion);
}




ULONG
OutLogReadCo(
    PTHREAD_CTX          ThreadCtx,
    PREPLICA             Replica,
    ULONG                Index
)
/*++
Routine Description:

    Read the change order specified by the Index from the Outbound Log for
    the Replica.  The data is returned in the Replica->OutLogTableCtx struct.

Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Index -- The Index / Sequence Number to use to select the change order.

Return Value:

    Frs Status

--*/
{

#undef DEBSUB
#define DEBSUB  "OutLogReadCo:"

    ULONG                FStatus;
    PTABLE_CTX           TableCtx = Replica->OutLogTableCtx;
    ULONGLONG            Data;

    FRS_ASSERT(IS_OUTLOG_TABLE(TableCtx));

    // Note: Consider a record cache to reduce calls to Jet.

    QHashAcquireLock(Replica->OutLogRecordLock);

    //
    // First check if the outlog record is currently being written or we are
    // at the end of the log.
    //
    Data = Index;

    if ((Index != 0) &&
        ((Index >= Replica->OutLogSeqNumber) ||
         (QHashLookupLock(Replica->OutLogRecordLock, &Data) != NULL))) {
        DPRINT3(3, "OutLog Record lock on Index %08x %08x (Index %08x, Replica %08x)\n",
                PRINTQUAD(Data), Index, Replica->OutLogSeqNumber);
        QHashReleaseLock(Replica->OutLogRecordLock);
        return FrsErrorRecordLocked;
    }

    QHashReleaseLock(Replica->OutLogRecordLock);

    //
    // Open the outbound log table for the replica set and read the requested
    // record identified by the sequence number.
    //
    FStatus = DbsReadTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        TableCtx,
                                        &Index,
                                        OLSequenceNumberIndexx,
                                        OUTLOGTablex);

    if (!FRS_SUCCESS(FStatus)) {

        if (FStatus == FrsErrorNotFound) {
            //
            // No record at this sequence number, probably deleted.
            //
            DPRINT1(4, "Record 0x%x deleted\n", Index);
        }
        return FStatus;
    }

    //DUMP_TABLE_CTX(OutLogTableCtx);
    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    return FrsErrorSuccess;
}


ULONG
OutLogDeleteCo(
    PTHREAD_CTX ThreadCtx,
    PREPLICA    Replica,
    ULONG       Index
)
/*++
Routine Description:

    Delete the change order specified by the Index from the Outbound Log for
    the Replica.  This uses the common Replica->OutLogTableCtx so it must
    be called by the thread that is doing work for this Replica.

    NOTE - THIS IS ONLY OK IF WE KNOW WHICH THREAD IS WORKING ON THE REPLICA
           OR THERE IS ONLY ONE OUTBOUND LOG PROCESS THREAD.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Index -- The Index / Sequence Number to use to select the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDeleteCo:"

    return  DbsDeleteTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        Replica->OutLogTableCtx,
                                        &Index,
                                        OLSequenceNumberIndexx,
                                        OUTLOGTablex);

}




ULONG
OutLogInsertCo(
    PTHREAD_CTX         ThreadCtx,
    PREPLICA            Replica,
    PTABLE_CTX          OutLogTableCtx,
    PCHANGE_ORDER_ENTRY ChangeOrder
)
/*++
Routine Description:

    Insert the change order into the outbound log.  This call should only be
    made after the Inbound change order has been completed and the IDTable
    state is updated.  After this call succeeds the caller should then
    delete the record from the Inbound Log.

    Note - This is where the sequence number for the record is assigned.

    Note - This is called by ChgOrdIssueCleanup() in a database thread.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogTableCtx -- The table context to use for outbound log table access.
    ChangeOrder -- The new change order to check ordering conflicts.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInsertCo:"

    ULONGLONG             Data;
    JET_ERR               jerr;
    ULONG                 FStatus = FrsErrorSuccess;
    ULONG                 GStatus;
    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;
    ULONG                 SequenceNumberSave;
    PDOMINANT_FILE_ENTRY  DomFileEntry;
    PQHASH_ENTRY          QHashEntry;
    CHAR                  GuidStr[GUID_CHAR_LEN];
    PDATA_EXTENSION_RETRY_TIMEOUT CoCmdRetryTimeout = NULL;
    LONGLONG              CurrentTime;
    LONGLONG              FirstTryTimeSave = (LONGLONG)0;

    //
    // Insert the change order into the outbound log.  Log Cleanup will delete
    // the staging file after it has been sent to all the partners.
    //
    // ** Note ** - The Replica Outlog Sequence number is at the max of all
    // partner leading indexs and the record in the log with the largest
    // sequence number+1.  The interlocked increment is done first to get
    // the next sequence number and then one is subtracted from the result.
    //
    // ** Note ** This change order command is an inbound change order so for
    // consistency and correctness in subsequent operations we save and restore
    // the Sequence Number around this call.  The alternative is to make a copy
    // of the data record first.
    //
    SequenceNumberSave = CoCmd->SequenceNumber;

    //
    // Save the replica ptrs by converting them to local replica ID numbers
    // for storing the record in the database.
    //
    CoCmd->OriginalReplicaNum = ReplicaAddrToId(ChangeOrder->OriginalReplica);
    CoCmd->NewReplicaNum      = ReplicaAddrToId(ChangeOrder->NewReplica);

    //
    // Use the Change Order extension to store the time the CO was inserted into
    // the outbound log. Save the current value and restore it after inserting the CO.
    // Use the extension only if it is present. VVjoin cos and controls cos do not
    // have the extension.

    if (CoCmd->Extension != NULL) {
        CoCmdRetryTimeout = DbsDataExtensionFind(CoCmd->Extension, DataExtend_Retry_Timeout);

        if(CoCmdRetryTimeout != NULL) {
            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

            FirstTryTimeSave = CoCmdRetryTimeout->FirstTryTime;

            CoCmdRetryTimeout->FirstTryTime = CurrentTime;

        }
    }

    //
    // Get the Outlog record lock and add this sequence number to it.
    // This is needed so the outlog process can tell if it hit the end of log
    // if it does a read and gets back record not found.  This lock table
    // allows it to distinguish between a missing outlog change order that
    // will require a VVJoin Scan for the partner from a change order outlog
    // write that hasn't finished yet.
    //
    QHashAcquireLock(Replica->OutLogRecordLock);

    // Perf Note: If we keep the lock table then get rid of the interlocked ops
    CoCmd->SequenceNumber = InterlockedIncrement(&Replica->OutLogSeqNumber) - 1;

    Data = CoCmd->SequenceNumber;
    QHashInsertLock(Replica->OutLogRecordLock, &Data, &Data, 0);

    QHashReleaseLock(Replica->OutLogRecordLock);

    //
    // Open the Outbound log table.
    //
    if (!IS_TABLE_OPEN(OutLogTableCtx)) {
        jerr = DbsOpenTable(ThreadCtx,
                            OutLogTableCtx,
                            Replica->ReplicaNumber,
                            OUTLOGTablex,
                            CoCmd);
        if (!JET_SUCCESS(jerr)) {
            FStatus = DbsTranslateJetError(jerr, TRUE);
            goto RETURN;
        }
    }

    //
    // Update the OutLogDominantTable as necessary.
    //
    Replica->OutLogRepeatInterval = GOutLogRepeatInterval;
    DPRINT1(4, "OPT: Replica OutLogRepeatInterval = %d\n", Replica->OutLogRepeatInterval);
    if ((Replica->OutLogRepeatInterval > 0) &&
         OutLogIsValidDominantFile(CoCmd)) {
        QHashAcquireLock(Replica->OutLogDominantTable);

        DPRINT1(4, "OPT: valid Dom File for COx 0x%x\n", CoCmd->SequenceNumber);

        QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
        if (QHashEntry != NULL) {
            //
            // Found a match, bump the count and record latest sequence number.
            //
            DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
            DPRINT2(4, "OPT: hit in Dom Table for new COx 0x%x, old COx 0x%x\n",
                    CoCmd->SequenceNumber, DomFileEntry->OLSeqNum);
            QHashEntry->QData += 1;
            DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;
            QHashReleaseLock(Replica->OutLogDominantTable);
        } else {
            //
            // Not found in Dominant Table, do the OutLog lookup.
            // Note: The record is not read from the table so we don't know
            // if the CO found actually meets all the requirements for
            // skipping.  That check is made when we actually try to send the
            // CO.  The entries in the OutLogDominantTable do not have to meet
            // the requirements for skipping.  We only want to know that there
            // is a future CO for this File that we will be sending if a previous
            // CO can be skipped.  So a sequence like update a large file followed
            // by a delete of the file will only send the delete.
            //
            QHashReleaseLock(Replica->OutLogDominantTable);
            DPRINT1(4, "OPT: miss in Dom Table for COx 0x%x\n", CoCmd->SequenceNumber);

            jerr = DbsSeekRecord(ThreadCtx,
                                 &CoCmd->FileGuid,
                                 OLFileGuidIndexx,
                                 OutLogTableCtx);
            if (JET_SUCCESS(jerr)) {
                //
                // Found another CO with the same file Guid.  Add an entry to the
                // DominantFileTable.
                //
                GuidToStr(&CoCmd->FileGuid, GuidStr);
                DPRINT3(4, "Found new dominant file entry for replica %ws file: %ws (%s)\n",
                        Replica->ReplicaName->Name, CoCmd->FileName, GuidStr);

                DomFileEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
                if (DomFileEntry != NULL) {
                    DomFileEntry->Flags = 0;
                    COPY_GUID(&DomFileEntry->FileGuid, &CoCmd->FileGuid);
                    DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;

                    if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                        SetFlag(DomFileEntry->Flags, DFT_FLAG_DELETE);
                    }

                    DPRINT1(4, "OPT: Insert new Dom File for COx 0x%x\n", CoCmd->SequenceNumber);
                    GStatus = QHashInsert(Replica->OutLogDominantTable,
                                          &CoCmd->FileGuid,
                                          NULL,
                                          (ULONG_PTR) DomFileEntry,
                                          FALSE);
                    if (GStatus != GHT_STATUS_SUCCESS) {
                        DPRINT2(4, "++ ERROR - Failed to insert entry into Replica OutLogDominant Table for %ws (%s)",
                                CoCmd->FileName, GuidStr);
                    }
                }
            } else {

                DPRINT1_JS(4, "OPT: Seek for Dom File for COx 0x%x failed", CoCmd->SequenceNumber, jerr);
            }
        }
    }

    //
    // Insert the new CO record into the database.
    //
    jerr = DbsInsertTable2(OutLogTableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "error inserting outlog record:", jerr);
        FStatus = DbsTranslateJetError(jerr, TRUE);
        DBS_DISPLAY_RECORD_SEV(5, OutLogTableCtx, FALSE);
        DUMP_TABLE_CTX(OutLogTableCtx);
    }

    DbsCloseTable(jerr, ThreadCtx->JSesid, OutLogTableCtx);
    DPRINT_JS(0,"Error - JetCloseTable failed:", jerr);


RETURN:
    //
    // Release the record lock.
    //
    if (QHashDelete(Replica->OutLogRecordLock, &Data) != GHT_STATUS_SUCCESS) {
        DPRINT(0, "Error deleting outlog lock table entry\n");
        FRS_ASSERT(!"Error deleting outlog lock table entry");
    }

    CoCmd->SequenceNumber = SequenceNumberSave;

    //
    // Restore the original FirstTryTime in case it is being used.
    //
        if(CoCmdRetryTimeout != NULL) {
        CoCmdRetryTimeout->FirstTryTime = FirstTryTimeSave;
        }

    //
    // Don't free the data record when we free the OutLogTableCtx.
    // The data record is part of the change order.
    //
    OutLogTableCtx->pDataRecord = NULL;

    //
    // Clear the Jet Set/Ret Col address fields for the Change Order
    // Extension buffer to prevent reuse since that buffer goes with the CO.
    //
    DBS_SET_FIELD_ADDRESS(OutLogTableCtx, COExtensionx, NULL);

    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    //
    // Poke the Outbound log processor.
    //
    OutLogStartProcess(Replica);

    return FrsErrorSuccess;

}



ULONG
OutLogStartProcess(
    PREPLICA Replica
)
/*++
Routine Description:

    If Outbound log processing for this replica is waiting then queue
    the start work command packet to crank it up.

Arguments:

    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogStartProcess:"


    if (FrsIsShuttingDown) {
        return FrsErrorSuccess;
    }

    if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
        //
        // Get the lock and recheck.
        //
        OutLogAcquireLock(Replica);
        if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
            SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
            FrsSubmitCommand(Replica->OutLogCmdPkt, FALSE);
        }
        OutLogReleaseLock(Replica);
    }

    return FrsErrorSuccess;
}



ULONG
OutLogSubmitCo(
    PREPLICA Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder
)
/*++
Routine Description:

    Send the change order to the Outbound Log process to insert it into
    the log and send it to the outbound partners.

    Make a check for a pending change order in the outbound log that applies
    to the same file.  If found and not currently active we delete the
    change order and staging file since this change order will send the
    file again.  Even if the change order has been sent but the file has
    not been fetched or a fetch is in progress we should be able to abort
    the fetch with an error response such that the fetching partner will
    abort the change order.  Note that it still is expected to send the
    ACK response indicating the CO is retired.

    Note - If there are no outbound partners defined for this replica set
    this call is a nop.

Arguments:

    Replica -- The replica set struct for the outbound log.

    ChangeOrder -- The new change order to check ordering conflicts.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSubmitCo:"

    ULONG WStatus;

    return FrsErrorSuccess;
}





ULONG
OutLogRetireCo(
    PREPLICA Replica,
    ULONG COx,
    PCXTION PartnerCxtion
)
/*++
Routine Description:

    The specified outbound partner is Acking the change order. Set the bit in
    the AckVector and advance the trailing change order index.  Add the
    partner back to the eligible list if necc.

Arguments:

    Replica -- The replica set struct for the outbound log.
    COx  -- The sequence number / index of the change order to retire.
    Partner -- The Outbound Partner that is Acking the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRetireCo:"

    POUT_LOG_PARTNER OutLogPartner = PartnerCxtion->OLCtx;

    OutLogAcquireLock(Replica);

    //
    // Make sure the index of the retiring change order makes sense.
    //
    if (COx > Replica->OutLogCOMax) {
        DPRINT2(0, "WARNING: COx (0x%x) > Replica->OutLogCOMax (0x%x)\n",
               COx, Replica->OutLogCOMax);
    }

    //
    // Check if this is a duplicate Ack.  Could happen if outbound partner has
    // crashed and is restarting.
    //
    if ((COx < OutLogPartner->COTx) ||
       (ReadAVBit(COx, OutLogPartner) != 0))  {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }

    //
    // Set the Ack flag in the ack vector and advance the trailing index for
    // this partner.
    //
    OutLogMarkAckVector(Replica, COx, OutLogPartner);

    //
    // Decrement the count of outstanding change orders for this partner.
    // If the partner is at the Quota limit then queue the partner struct to
    // either the Eligible or Standby lists depending on the outbound log
    // processing state of this replica.
    //
    // If we crash and come back up we could still have change orders out
    // that acks are comming back for.  Since we don't know how many
    // we make sure the OutstandingCo count doesn't go below zero.
    //
    if (OutLogPartner->OutstandingCos > 0) {
        OutLogPartner->OutstandingCos -= 1;
    }

    // Perf Note: Add code to test if the COLx is equal to the max change order seq
    // number for this replica so we suppress queueing the the cmd pkt
    // just to discover there is no pending COs for this replica.

    if (OutLogPartner->State == OLP_AT_QUOTA) {

        //
        // Note - if we ever do dynamic adjustment of OutstandingQuotas then
        // this assert must be fixed.
        //
        FRS_ASSERT(OutLogPartner->OutstandingCos < OutLogPartner->OutstandingQuota);

        //
        // Reactivate this partner since it is now below quota.
        //
        OutLogActivatePartner(Replica, PartnerCxtion, TRUE);

    }

    OutLogReleaseLock(Replica);

    return FrsErrorSuccess;
}



BOOL
OutLogMarkAckVector(
    PREPLICA Replica,
    ULONG COx,
    POUT_LOG_PARTNER OutLogPartner
)
/*++
Routine Description:

    The specified outbound partner is Acking the change order. Set the bit in
    the AckVector and advance the trailing change order index.

    Note: The caller must acquire the outbound log lock.

Arguments:

    Replica -- The replica set struct for the outbound log.
    COx  -- The sequence number / index of the change order to retire.
    Partner -- The Outbound Partner that is Acking the change order.

Return Value:

    TRUE if the caller should update COLx if appropriate.
    FALSE if COLx was adjusted here then caller should leave it alone.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogMarkAckVector:"

    ULONG Slotx, MaxSlotx;
    BOOL CxtionRestarting, CxtionVVJoining;
    BOOL AdjustCOLx = TRUE;

    //
    // Check if COx is outside the range of the Ack Vector.  If it is then
    // ignore it.  This could happen when a partner is out of date and needs
    // to do a VVJoin.  When the VVJoin terminates we restart at the point in
    // the outlog where the VVJoin started.  This could be a long way back and
    // we could get Acks for VVJoin COs sent that are still ahead of us in the
    // Outlog.  It could also happen when the start of a VVJoin advances the
    // outlog index for the connection to the end of the Outlog.  We could still
    // get some Acks dribbling in for old change orders that are now just
    // finishing from this outbound partner.
    //
    if (SeqNumOutsideAVWindow(COx, OutLogPartner)) {
        DPRINT1(4, "Ack sequence number, 0x%x is outside current AV window. Ignored\n",
               COx);

        OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, COx, "Outside AVWindow");
        return TRUE;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, COx, "Retire (Start)");

    //
    // Set the bit in the Ack Vector at the Change order index.
    //
    SetAVBit(COx, OutLogPartner);
    Slotx = AVSlot(COx, OutLogPartner);

    //
    // If this was the trailing change order index then advance it to the
    // slot of the next unacknowledged change order.
    //
    if (Slotx == OutLogPartner->COTslot) {
        MaxSlotx = Slotx + ACK_VECTOR_SIZE;
        while (++Slotx < MaxSlotx) {
            //
            // As the trailing index is advanced clear the bits behind it.
            // Stop when we hit the next 0 bit.
            //
            OutLogPartner->COTx += 1;
            ClearAVBitBySlot(Slotx-1, OutLogPartner);
            //
            // If this connection is restarting then COLx could be left behind
            // COTx if an ACK comes in for a CO that was sent prior to the
            // connection shutdown.  This can only happen until COLx catches
            // back up to COLxRestart.  During this period keep COLx up with COTx.
            //
            if (OutLogPartner->COLx < (OutLogPartner->COTx-1)) {
                CxtionRestarting = OutLogPartner->COLx <= OutLogPartner->COLxRestart;
                CxtionVVJoining = OutLogPartner->COLx <= OutLogPartner->COLxVVJoinDone;
                if (!CxtionRestarting && !CxtionVVJoining) {
                    OUT_LOG_DUMP_PARTNER_STATE(0,
                                               OutLogPartner,
                                               OutLogPartner->COTx, "Bug");
                    FRS_ASSERT(!"COLx < COTx but Cxtion not Restarting or VVJoining");
                }
                OutLogPartner->COLx = OutLogPartner->COTx;
                AdjustCOLx = FALSE;
                OUT_LOG_DUMP_PARTNER_STATE(0,
                                           OutLogPartner,
                                           OutLogPartner->COTx, "Bug2");
            }

            if (ReadAVBitBySlot(Slotx, OutLogPartner) == 0) {
                break;
            }
        }

        OutLogPartner->COTslot = Slotx & (ACK_VECTOR_SIZE-1);
        Replica->OutLogDoCleanup = TRUE;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4,
                               OutLogPartner,
                               OutLogPartner->COTx,
                               "Retire (end)");

    return AdjustCOLx;
}



ULONG
OutLogSaveSinglePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PTABLE_CTX         TableCtx,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    Save the state of a single outbound partner in the database.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    TableCtx -- ptr to the OutLogTable ctx.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSaveSinglePartnerState:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;

    PCXTION_RECORD     CxtionRecord = TableCtx->pDataRecord;
    GUID               *CxtionGuid;


    CxtionRecord->Flags = OutLogPartner->Flags;
    CxtionRecord->COLx = OutLogPartner->COLx;
    CxtionRecord->COTx = OutLogPartner->COTx;
    CxtionRecord->COTxNormalModeSave = OutLogPartner->COTxNormalModeSave;
    CxtionRecord->COTslot = OutLogPartner->COTslot;
    CopyMemory(CxtionRecord->AckVector, OutLogPartner->AckVector, ACK_VECTOR_BYTES);

    //
    // Seek to the record using the connection GUID.
    //
    CxtionGuid = OutLogPartner->Cxtion->Name->Guid;

    jerr = DbsSeekRecord(ThreadCtx, CxtionGuid, CrCxtionGuidx, TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "ERROR Seeking %ws\\%ws\\%ws -> %ws\\%ws :",
                  PRINT_CXTION_PATH(Replica, OutLogPartner->Cxtion), jerr);
        return DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Save the record fields.
    //
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     OutLogUpdateFieldList,
                                     ARRAY_SZ(OutLogUpdateFieldList));
    DPRINT1_FS(0, "ERROR - OutLogSaveSinglePartnerState on %ws:", Replica->ReplicaName->Name, FStatus);

    OutLogPartner->COTxLastSaved = OutLogPartner->COTx;

    return FStatus;
}



ULONG
OutLogSavePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PSINGLE_LIST_ENTRY CommitList,
    IN PSINGLE_LIST_ENTRY EvalList
)
/*++
Routine Description:

    Update the outbound log state for each partner on the CommitList.
    Then for each partner on the EvalList update the state only if the
    last saved Change Order Trailing index (COTxLastSaved) is less than
    the new joint trailing index that was computed before we were called.
    This is necessary because our caller is about to clean the OutBound log
    up to the new JTx point so those records will be gone from the table.
    If we crash we want COTx to be >= the JTx delete point.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    CommitList -- Ptr to list head of Outlog Partners that need state saved.
    EvalList -- Ptr to list head of OutLog partners than need to be evaluated
                for state save.  They most move up to at least the new Joint
                Trailing Index for the Replica.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSavePartnerState:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus = FrsErrorSuccess;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    POUT_LOG_PARTNER   OutLogPartner;
    PCXTION_RECORD     CxtionRecord;
    GUID               *CxtionGuid;

    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;
    //
    // Open the connection table for this replica.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    CxtionRecord = TableCtx->pDataRecord;

    //
    // Update the state of every partner on the commit list.  This ensures that
    // partners that are active will have their state updated even if an inactive
    // partner is preventing the JTx from advancing.
    //
    ForEachSingleListEntry( CommitList, OUT_LOG_PARTNER, SaveList,
        //
        // Iterator pE is of type POUT_LOG_PARTNER.
        //
        OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, pE);
    );

    //
    // Check the COTxLastSaved of each partner on the Eval list.
    // If it is Less than the new JointTrailing Index then update its state too.
    //
    ForEachSingleListEntry( EvalList, OUT_LOG_PARTNER, SaveList,
        //
        // Iterator pE is of type POUT_LOG_PARTNER.
        //
        if (pE->COTxLastSaved < Replica->OutLogJTx) {
            OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, pE);
        }
    );

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"ERROR - JetCloseTable on OutLogSavePartnerState failed:", jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }

    DbsFreeTableCtx(TableCtx, 1);

    return FStatus;
}

ULONG
OutLogPartnerVVJoinStart(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    This outbound partner has just entered VVJoin mode.
    Save the current Outlog sequence number for continuation when the
    partner leaves VVJoin Mode.  Reset the ACK vector and update the
    partner state in the database so if the VVJoin is interrupted we can
    restart it.

    Note: The caller must get the Outlog lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogPartnerVVJoinStart:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    FRS_ASSERT(!InVVJoinMode(OutLogPartner));

    //
    // Save the current OutLog insertion point as the restart point when
    // the partner returns to normal mode.
    //
    if (OutLogPartner->COTxNormalModeSave == 0) {
        OutLogPartner->COTxNormalModeSave = Replica->OutLogSeqNumber;
    }

    //
    // Advance the leading and trailing outlog indexes to the end of the outlog.
    //
    OutLogPartner->COLxVVJoinDone = 0;
    OutLogPartner->COLxRestart = 0;
    OutLogPartner->COLx = Replica->OutLogSeqNumber;
    OutLogPartner->COTx = Replica->OutLogSeqNumber;
    OutLogPartner->COTxLastSaved = OutLogPartner->COTxNormalModeSave;

    //
    // For a partner entering VVJoin Mode I would expect the outstanding CO
    // count to be zero.  But it might not be.
    //
    if (OutLogPartner->OutstandingCos > 0) {
        DPRINT1(0, "WARNING: OutstandingCos is %d.  setting to zero.\n", OutLogPartner->OutstandingCos);
    }

    //
    // Reset the Ack Vector and start with a fresh count of outstanding COs.
    //
    ResetAckVector(OutLogPartner);

    //
    // Enable VVJoin Mode.
    //
    SetFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);

    //
    // Make sure we are not in replay mode.
    //
    ClearFlag(OutLogPartner->Flags, OLP_FLAGS_REPLAY_MODE);

    //
    // Make sure we are not in opt vvjoin mode.
    //
    ClearFlag(OutLogPartner->Flags, OLP_FLAGS_OPT_VVJOIN_MODE);

    //
    // Open the connection table and update the partner state now that
    // we are entering VVJoin Mode.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, OutLogPartner);

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DbsFreeTableCtx(TableCtx, 1);

    FRS_PRINT_TYPE(4, OutLogPartner);
    //
    // Compare the version vectors with the idtable and generate change orders
    //
    SubmitVvJoin(Replica, OutLogPartner->Cxtion, CMD_VVJOIN_START);

    return FrsErrorSuccess;
}

ULONG
OutLogPartnerVVJoinDone(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    This outbound partner is now leaving VVJoin mode.
    Restore the saved Outlog sequence number so we now send out any
    normal mode change orders that were held up while the VVJoin was going on.

    Reset the ACK vector and update the partner state in the database
    so we know we have left VVJoin mode if the system crashes.

    Note: The caller must get the Outlog lock.

Arguments:
    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:
    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogPartnerVVJoinDone:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    FRS_ASSERT(InVVJoinMode(OutLogPartner));

    //
    // Restore the OutLog restart point for this partner.
    //
    OutLogPartner->COLxVVJoinDone = OutLogPartner->COLx;
    OutLogPartner->COLxRestart = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COLx = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTx = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTxLastSaved = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTxNormalModeSave = 0;

    //
    // Reset the Ack Vector and start with a fresh count of outstanding COs.
    //
    ResetAckVector(OutLogPartner);

    //
    // Leave VVJoin Mode.
    //
    ClearFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);

    //
    // Enter Replay Mode.
    //
    SetFlag(OutLogPartner->Flags, OLP_FLAGS_REPLAY_MODE);

    //
    // Open the connection table and update the partner state.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, OutLogPartner);

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DbsFreeTableCtx(TableCtx, 1);

    FRS_PRINT_TYPE(4, OutLogPartner);

    return FrsErrorSuccess;
}

JET_ERR
OutLogCleanupWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    OutLogTableCtx,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    IN PVOID         Context,
    IN ULONG         OutLogSeqNumber
)
/*++

Routine Description:

    This is a worker function passed to DbsEnumerateOutlogTable().
    Each time it is called it may delete the record from the table
    and/or delete the corresponding staging file.

Arguments:

    ThreadCtx - Needed to access Jet.
    OutLogTableCtx  - A ptr to an outbound log context struct.
    CoCmd     - A ptr to a change order command record. (NULL if record
                was deleted)
    Context   - A ptr to the Replica struct we are cleaning up.
    OutLogSeqNumber - The sequence number of this record.

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCleanupWorker:"

    JET_ERR    jerr, jerr1;
    ULONG      FStatus;
    POUTLOG_TABLE_ENUM pOutlogTableEnum = (POUTLOG_TABLE_ENUM) Context;
    PREPLICA   Replica = pOutlogTableEnum->Replica;
    ULONG      JointTrailingIndex = Replica->OutLogJTx;
    BOOL       DirectedCo;
    PCXTION    Cxtion;
    PVOID      Key;

    PTABLE_CTX VVTableCtx = &pOutlogTableEnum->VVTableCtx;
    PVVTABLE_RECORD VVTableRec;
        PDATA_EXTENSION_RETRY_TIMEOUT CoCmdRetryTimeout;
    LONGLONG   CurrentTime;
    LONGLONG   TimeDelta;
    PVV_ENTRY  OutlogVVEntry;
    PVV_ENTRY  VVEntry;
    ULONGLONG  VVEntryVsn;
    BOOL       DeleteFromOutlog = FALSE;


    FRS_ASSERT(VVTableCtx->pDataRecord != NULL);

    //
    // Abort cleanup if service is shutting down.
    //
    if (FrsIsShuttingDown) {
        return JET_errTermInProgress;
    }

    //
    // If this record has already been deleted then continue enumeration.
    //
    if (CoCmd == NULL) {
        return JET_errSuccess;
    }

    //
    // If the local install is not done then don't delete the staging file.
    //
    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_INSTALL_INCOMPLETE)) {
        DPRINT2(4, "Install Incomplete for Index 0x%x, File: %ws\n",
                OutLogSeqNumber, CoCmd->FileName);
        return JET_errSuccess;
    }

    DirectedCo = BooleanFlagOn(CoCmd->Flags, CO_FLAG_DIRECTED_CO);

    if (!DirectedCo) {

        //
        // Check if it is time to delete this CO from the outbound log.
        // The outlog insert time of the CO is stored in the extension field.
        //

        DeleteFromOutlog = FALSE;

        CoCmdRetryTimeout = DbsDataExtensionFind(CoCmd->Extension, DataExtend_Retry_Timeout);

        if(CoCmdRetryTimeout != NULL) {

            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
            TimeDelta = CurrentTime - CoCmdRetryTimeout->FirstTryTime;
            TimeDelta = TimeDelta / CONVERT_FILETIME_TO_MINUTES;

            if (TimeDelta > DebugInfo.OutlogChangeHistory) {
                DeleteFromOutlog = TRUE;
                //
                // This is a Normal CO so check it against the JointTrailingIndex to
                // see if it can be deleted.  Note that the JTX has been held back
                // for those partners in VV Join Mode so they will get these COs when
                // they are done with VVJoin Mode.
                //
                if (OutLogSeqNumber >= JointTrailingIndex) {
                    //
                    // Find the connection that is holding us back.
                    //
                    Key = NULL;
                    while (Cxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
                        if (Cxtion->JrnlCxtion || Cxtion->Inbound) {
                            continue;
                        }

                        if (Cxtion->OLCtx == NULL) {
                            continue;
                        }

                        if (InVVJoinMode(Cxtion->OLCtx)) {
                            if (OutLogSeqNumber >= Cxtion->OLCtx->COTxNormalModeSave) {
                                SetCxtionFlag(Cxtion, CXTION_FLAGS_TRIM_OUTLOG);
                                DPRINT1(0, "Deleting connection in vvjoin mode %ws\n", Cxtion->Name->Name);
                            }
                        } else if (OutLogSeqNumber >= Cxtion->OLCtx->COTx) {
                            SetCxtionFlag(Cxtion, CXTION_FLAGS_TRIM_OUTLOG);
                            DPRINT1(0, "Deleting connection %ws\n", Cxtion->Name->Name);
                        }
                    }

                    FrsDsSetDsPollingInterval(1,0,0);

                    return JET_errRecordNotFound;
                }
            }
        }

        //
        // Terminate the enumeration early in both of the following
        // cases.
        // No VVJoins going on AND:
        //
        // 1. We have caught up with the JointTrailingIndex.
        //    (OutLogSeqNumber >= JointTrailingIndex)
        //
        // 2. There are no outbound connections or there are
        //    outbound connections but they have never joined.
        //    (JointTrailingIndex == 0xFFFFFFFF)
        //    Also the CO has not lived in the outlog past the
        //    Outlog Change History.
        //    (DeleteFromOutlog == FALSE)
        //
        if (((DeleteFromOutlog == FALSE) &&
              (JointTrailingIndex == 0xFFFFFFFF)) ||

            (OutLogSeqNumber >= JointTrailingIndex)) {

            if (Replica->OutLogCountVVJoins != 0) {
                //
                // Since we have VVJoins active just skip this CO and keep looking
                // for directed COs that can be deleted.
                //
                return JET_errSuccess;
            } else {
                //
                // No VVJoins active so we can stop this cleanup pass.
                //
                return JET_errRecordNotFound;
            }
        }


    } else {
        //
        // This is a directed CO.  It may be VVJoin Related or just a partner
        // initiated refresh request.  It is directed to a single outbound
        // partner.  Either way test the sequence number against
        // the specified partner's current COTx to decide deletion.
        //
        Cxtion = GTabLookup(Replica->Cxtions, &CoCmd->CxtionGuid, NULL);

        //
        // If we don't find the connection then it is deleted so delete the
        // change order.
        //
        if (Cxtion != NULL) {
            FRS_ASSERT(!Cxtion->Inbound);
            FRS_ASSERT(Cxtion->OLCtx != NULL);

            //
            // Check the sequence number against the current trailing index on
            // this connection.  This works regardless of the connection being
            // in Join Mode since the current value is still correct.
            //
            if (OutLogSeqNumber >= Cxtion->OLCtx->COTx) {
                return JET_errSuccess;
            }
        }
    }

    //
    // We do not want to try to delete staging file every time we scan the outbound log.
    //
    if ((OutLogSeqNumber < pOutlogTableEnum->OldJointTrailingIndex) && !DirectedCo && (DeleteFromOutlog == FALSE)) {
        return JET_errSuccess;
    }

    DPRINT2(4, "Deleting Staging file for Index 0x%x, File: %ws\n",
            OutLogSeqNumber, CoCmd->FileName);
    //
    // Delete the staging file and then the log record.
    //
    if (StageDeleteFile(CoCmd, NULL, TRUE)) {
        //
        // Now delete the outlog record.  If we fail to delete the staging
        // file for some reason the outlog record will stay around so
        // we can try next time.  If there is a problem, complain but keep
        // going.
        //

        if (!DirectedCo) {

            if ((DebugInfo.SaveOutlogChangeHistory == FALSE) || (DeleteFromOutlog == TRUE)) {
                OutlogVVEntry = GTabLookupNoLock(Replica->OutlogVVector, &CoCmd->OriginatorGuid, NULL);
                //
                // The CO can be in the outbound log but has not yet updated the
                // vv in the DB.
                //
                if (OutlogVVEntry == NULL) {
                    OutlogVVEntry = FrsAlloc(sizeof(VV_ENTRY));
                    COPY_GUID(&OutlogVVEntry->GVsn.Guid, &CoCmd->OriginatorGuid);

                    OutlogVVEntry->GVsn.Vsn = (ULONGLONG)1;

                    //
                    // Initialize the list head. We do not use the list head for outlogVV
                    // but we still need to initialize it because the APIs that work with
                    // VVs expect it.
                    //
                    InitializeListHead(&OutlogVVEntry->ListHead);

                    //
                    // Add it to the outlog version vector table.
                    //
                    GTabInsertEntryNoLock(Replica->OutlogVVector, OutlogVVEntry, &OutlogVVEntry->GVsn.Guid, NULL);
                }

                DPRINT1(4, "CoCmd->FrsVsn     : %08x %08x\n",
                        PRINTQUAD(CoCmd->FrsVsn));

                DPRINT1(4, "VVEntry->GVsn.Vsn : %08x %08x\n",
                        PRINTQUAD(OutlogVVEntry->GVsn.Vsn));

                if (CoCmd->FrsVsn > OutlogVVEntry->GVsn.Vsn) {
                    OutlogVVEntry->GVsn.Vsn = CoCmd->FrsVsn;

                    jerr = DbsSeekRecord(ThreadCtx, &CoCmd->OriginatorGuid, VVOriginatorGuidIndexx, VVTableCtx);

                    VVTableRec = (PVVTABLE_RECORD)VVTableCtx->pDataRecord;

                    if (JET_SUCCESS(jerr)) {

                        DPRINT2(4, "VVTableRec->VVOriginatorVsn %08x %08x \
                                VVTableRec->VVOutlogOriginatorVsn %08x %08x\n",
                                PRINTQUAD(VVTableRec->VVOriginatorVsn),
                                PRINTQUAD(VVTableRec->VVOutlogOriginatorVsn));

                        VVTableRec->VVOutlogOriginatorVsn = OutlogVVEntry->GVsn.Vsn;

                        //
                        // Write the desired field.
                        //
                        FStatus = DbsWriteTableField(ThreadCtx, Replica->ReplicaNumber, VVTableCtx, VVOutlogOriginatorVsnx);
                        DPRINT1_FS(0, "++ ERROR - DbsWriteTableField on %ws :", Replica->ReplicaName->Name, FStatus);
                    } else {
                        DPRINT1_JS(0, "++ ERROR - DbsSeekRecord on %ws :", Replica->ReplicaName->Name, jerr);

                        COPY_GUID(&VVTableRec->VVOriginatorGuid, &OutlogVVEntry->GVsn.Guid);
                        VVTableRec->VVOriginatorVsn = 1;
                        VVTableRec->VVOutlogOriginatorVsn = OutlogVVEntry->GVsn.Vsn;

                        FStatus = DbsInsertTable2(VVTableCtx);
                        if (!FRS_SUCCESS(FStatus)) {
                            return JET_errRecordNotFound;
                        }
                    }

                }

                //
                // Update the start point of the outbound log
                // We increment OutLogCOMin by 1. That could be pointing to a deleted record
                // but that should not matter as we skip deleted records.
                //
                Replica->OutLogCOMin = CoCmd->SequenceNumber + 1;

            } else {
                return JET_errSuccess;
            }
        }

        DPRINT2(4, "Deleting Outlog record for Index 0x%x, File: %ws\n",
                OutLogSeqNumber, CoCmd->FileName);

        jerr = DbsDeleteTableRecord(OutLogTableCtx);
        DPRINT_JS(0, "ERROR - DbsDeleteTableRecord :", jerr);
    }

    //
    // Return success until we hit the Joint Trailing Index.
    //
    return JET_errSuccess;
}



ULONG
OutLogCleanupDominantFileTableWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove entries
    that have no multiples.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupDominantFileTableWorker:"

    PREPLICA   Replica = (PREPLICA) Context;

    PDOMINANT_FILE_ENTRY DomFileEntry;

    DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);

    //
    // If the  OutlogCoMin has passed this entry then delete it.
    //
    if (DomFileEntry->OLSeqNum <= Replica->OutLogCOMin) {
        FrsFree(DomFileEntry);
        TargetNode->Flags = 0;
        //
        // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}


VOID
OutLogJointTrailingIndexMerge(
    POUT_LOG_PARTNER Olp,
    PREPLICA         Replica,
    PULONG           JointTrailingIndex
)
/*++
Routine Description:

    Combine outlog partner info to form new joint trailing index.
    Count the number of outlog partners in VV Join Mode.

    Note: The caller has acquired the outbound log lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    JointTrailingIndex -- new value returned for JointTrailingIndex.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogJointTrailingIndexMerge:"

    ULONG  CleanPoint;


    //
    // Current clean point for this partner is the CO Trailing Index.
    //
    CleanPoint = Olp->COTx;

    //
    // Unless partner is in VV Join Mode in which the clean point was saved
    // in COTxNormalModeSave before entering Join Mode.
    // Count the number of outlog partners in VVJoin Mode.
    //
    if (InVVJoinMode(Olp)) {
        CleanPoint = Olp->COTxNormalModeSave;
        Replica->OutLogCountVVJoins += 1;
    }

    //
    // If this clean point is less than the current JointTrailingIndex then
    // move the JointTrailingIndex back. A zero clean point means this partner
    // has never joined so we will force him to do a VVJoin the first time
    // it joins.  Meanwhile we don't take up log or staging file space if
    // he never joins.
    //
    if ((CleanPoint != 0) && (CleanPoint < *JointTrailingIndex)) {
        *JointTrailingIndex = CleanPoint;
    }

}


ULONG
OutLogCleanupLog(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
)
/*++
Routine Description:

    It's time to remove the outbound log change orders that have been
    sent to all the partners for this Replica.  This is done by calculating
    the Joint Trailing Index across all partners and then deleting the
    records up to that point.  When the record is deleted the staging file
    is also deleted.

    WARNING:  It is only safe to call this function after all outbound
    connections have been initialized.  They don't have to be active but
    we need to have loaded up their trailing index state into their
    OUT_LOG_PARTNER struct.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupLog:"

    JET_ERR    jerr, jerr1;
    ULONG      FStatus;
    ULONG      JointTrailingIndex = 0xFFFFFFFF;
    ULONG      OldJointTrailingIndex;
    OUTLOG_TABLE_ENUM OutlogTableEnum;
    TABLE_CTX  TempTableCtx;
    PTABLE_CTX TableCtx = &TempTableCtx;
    SINGLE_LIST_ENTRY CommitList, EvalList;


    //
    // Get the outbound log lock for this replica and hold it until we
    // are finished.
    //
    OutLogAcquireLock(Replica);
    LOCK_GEN_TABLE(Replica->OutlogVVector);
    Replica->OutLogDoCleanup = FALSE;
    Replica->OutLogCountVVJoins = 0;
    CommitList.Next = NULL;
    EvalList.Next   = NULL;


    //
    // Find the Joint Trailing Index across all partners regardless of their
    // current connected/unconnected state.  Iterator pE is type *OUT_LOG_PARTNER
    // Also count the number of outlog partners in VV Join Mode.
    //

    ForEachSimpleListEntry(&Replica->OutLogEligible, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogStandBy, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogActive, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogInActive, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
    );

    DPRINT1(4, "Old JointTrailingIndex = 0x%x\n", Replica->OutLogJTx);
    DPRINT1(4, "New JointTrailingIndex = 0x%x\n", JointTrailingIndex);
    DPRINT1(4, "Count of OutLog Partners in VVJoin Mode = %d\n",
            Replica->OutLogCountVVJoins);

    OldJointTrailingIndex = Replica->OutLogJTx;
    Replica->OutLogJTx = JointTrailingIndex;

    OutLogSavePartnerState(ThreadCtx, Replica, &CommitList, &EvalList);

    OutLogReleaseLock(Replica);

    //
    // Clear out the Dominant File Table.up to the JointTrailingIndex.
    //
    QHashEnumerateTable(Replica->OutLogDominantTable,
                        OutLogCleanupDominantFileTableWorker,
                        Replica);

    //
    // Walk through the outbound log up to the JointTrailingIndex (passed
    // through the Replica struct) and delete each record and the staging file.
    // Init the table ctx and then open the outbound log table for this Replica.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, OUTLOGTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (outlog) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        UNLOCK_GEN_TABLE(Replica->OutlogVVector);
        return FStatus;
    }

    OutlogTableEnum.Replica = Replica;
    OutlogTableEnum.OldJointTrailingIndex = OldJointTrailingIndex;

    // Init the table ctx.
    OutlogTableEnum.VVTableCtx.TableType = TABLE_TYPE_INVALID;
    OutlogTableEnum.VVTableCtx.Tid = JET_tableidNil;

    //
    // Open the VVTable and pass the table context to the worker function.
    //
    jerr = DbsOpenTable(ThreadCtx,&OutlogTableEnum.VVTableCtx,Replica->ReplicaNumber,VVTablex,NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (vvtable) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);

        // Close and free VVTable context

        DbsCloseTable(jerr, ThreadCtx->JSesid, (&OutlogTableEnum.VVTableCtx));
        DbsFreeTableCtx(&OutlogTableEnum.VVTableCtx, 1);

        // Close and free Outlog table context.

        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        UNLOCK_GEN_TABLE(Replica->OutlogVVector);
        return FStatus;
    }

    jerr = DbsEnumerateOutlogTable(ThreadCtx,
                                   TableCtx,
                                   Replica->OutLogSeqNumber,
                                   OutLogCleanupWorker,
                                   &OutlogTableEnum);

    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_errRecordNotFound) &&
        (jerr != JET_errNoCurrentRecord)) {
        DPRINT_JS(0, "ERROR - FrsEnumerateTable for OutLogCleanupWorker :", jerr);
    }

    // Close and free VVTable context

    DbsCloseTable(jerr, ThreadCtx->JSesid, (&OutlogTableEnum.VVTableCtx));
    DbsFreeTableCtx(&OutlogTableEnum.VVTableCtx, 1);

    // Close and free Outlog table context.

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DbsFreeTableCtx(TableCtx, 1);

    UNLOCK_GEN_TABLE(Replica->OutlogVVector);
    return DbsTranslateJetError(jerr, FALSE);

}

ULONG
OutLogCleanup(
    PTHREAD_CTX      ThreadCtx,
    PCOMMAND_PACKET  Cmd
)
/*++
Routine Description:

    connections have been initialized.  They don't have to be active but
    we need to have loaded up their trailing index state into their
    OUT_LOG_PARTNER struct.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Cmd       -- Command packet.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCleanup:"

    ULONGLONG StartTime, StopTime, qTimeDelta;
    ULONG     TimeDelta, TotalSets, i, ArrayLen, OutlogChangeHistoryInMs;
    PREPLICA  *CleanupArray, Replica;

    GetSystemTimeAsFileTime((PFILETIME)&StartTime);

    //
    //  Allocate an array to hold the ptrs to each active replica set.
    //
    ArrayLen = MaxNumberReplicaSets;

    AquireListLock(&ReplicaListHead);

RETRY:
    CleanupArray = FrsAlloc(ArrayLen * sizeof(PREPLICA));
    TotalSets = 0;

    ForEachListEntryLock( &ReplicaListHead, REPLICA, ReplicaList,
        // Induction variable pE is of type PREPLICA.
        CleanupArray[TotalSets++] = pE;

        if (TotalSets >= ArrayLen) {
            FrsFree(CleanupArray);
            ArrayLen += MaxNumberReplicaSets;
            FRS_ASSERT(ArrayLen < 1000000);
            goto RETRY;
        }
    );

    if (!LockedOutlogCleanup) {
        ReleaseListLock(&ReplicaListHead);
    }

    //
    // Do outbound log cleanup on each replica if something happened.
    // We do not have the ReplicaList lock because cleanup can take many
    // minutes and we will block other threads that need to access the list.
    //
    for (i=0; i<TotalSets; i++) {
        Replica = CleanupArray[i];

        DPRINT1(5, "LogCleanup on %ws\n", Replica->ReplicaName->Name);

        if ((Replica->OutLogDoCleanup || (RsTimeout(Cmd) == 0)) && !FrsIsShuttingDown) {
            DPRINT3(4, "OutLog Cleanup for replica %ws, id: %d, (%08x)\n",
                    Replica->ReplicaName->Name, Replica->ReplicaNumber, Replica);

            OutLogCleanupLog(ThreadCtx, Replica);
        }
    }

    GetSystemTimeAsFileTime((PFILETIME)&StopTime);

    //
    // get the time difference in millisec and scale by 50 so the time spent
    // in cleanup is around 2% max. But not more frequently than OUT_LOG_CLEAN_INTERVAL
    // and not less frequently than OUT_LOG_FORCE_CLEAN_INTERVAL.
    //
    qTimeDelta = StopTime - StartTime;
    qTimeDelta = qTimeDelta / ((ULONGLONG)1000L * 10L);
    TimeDelta = max((ULONG) qTimeDelta * 50, OUT_LOG_CLEAN_INTERVAL);
    TimeDelta = min(TimeDelta, OUT_LOG_FORCE_CLEAN_INTERVAL);

    //
    // If changes are being saved in the outbound log then
    // adjust the cleanup interval accordingly.
    // If the Outlog Change History is set to 30 minutes
    // we don't want to wait 8 hours for the cleanup to
    // run.
    //
    // NOTE: DebugInfo.OutlogChangeHistory is in minutes, so we need to
    //       convert to milliseconds.
    //

    OutlogChangeHistoryInMs = DebugInfo.OutlogChangeHistory * 60 * 1000;

    if (DebugInfo.SaveOutlogChangeHistory == TRUE) {
        TimeDelta = min(TimeDelta, OutlogChangeHistoryInMs);
    }
    DPRINT2(4, "Time for cleanup (ms): %08x %08x  Next Cleanup after: %d ms\n",
            PRINTQUAD(qTimeDelta), TimeDelta);

    //
    // Force the timeout after attempting cleanup RsTimeout(Cmd) times.
    //
    if (RsTimeout(Cmd) == 0) {
        if (DebugInfo.SaveOutlogChangeHistory == TRUE) {
            RsTimeout(Cmd) = min(OUT_LOG_FORCE_CLEAN_INTERVAL, OutlogChangeHistoryInMs) - TimeDelta;
        } else {
            RsTimeout(Cmd) = OUT_LOG_FORCE_CLEAN_INTERVAL - TimeDelta;
        }
    } else
    if (RsTimeout(Cmd) < TimeDelta) {

        // RsTimeout is a ULONG, it cannot be negative!
        RsTimeout(Cmd) = 0;

    } else {
        RsTimeout(Cmd) -= TimeDelta;
    }


    if (LockedOutlogCleanup) {
        ReleaseListLock(&ReplicaListHead);
    }

    FrsFree(CleanupArray);

    if (!FrsIsShuttingDown) {
        FrsDelQueueSubmit(Cmd, TimeDelta);
        return FrsErrorSuccess;
    }

    return FrsErrorShuttingDown;
}


VOID
OutLogCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    If a completion event exists in the command packet then
    simply set the event and return. Otherwise, free the command
    packet.

Arguments:
    Cmd
    Arg - Cmd->CompletionArg

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCompletionRoutine:"
    DPRINT1(5, "----- OutLog completion 0x%x\n", Cmd);

    if (HANDLE_IS_VALID(Cmd->Parameters.OutLogRequest.CompletionEvent)) {
        SetEvent(Cmd->Parameters.OutLogRequest.CompletionEvent);
        return;
    }
    //
    // Send the packet on to the generic completion routine for freeing
    //
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
}


ULONG
OutLogSubmit(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to the outbound log processor

Arguments:
    Replica
    Cxtion
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "OutLogSubmit:"
    DWORD           WStatus;
    ULONG           FStatus;
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(&OutLogWork, Command);
    FrsSetCompletionRoutine(Cmd, OutLogCompletionRoutine, NULL);

    Cmd->Parameters.OutLogRequest.Replica = Replica;
    Cmd->Parameters.OutLogRequest.PartnerCxtion = Cxtion;
    Cmd->Parameters.OutLogRequest.CompletionEvent = FrsCreateEvent(TRUE, FALSE);

    DPRINT2(5, "----- Submitting Command 0x%x for %ws\\%ws\\%ws -> %ws\\%ws\n",
            Command, PRINT_CXTION_PATH(Replica, Cxtion));

    //
    // Hand off to the outbound log processor
    //
    WStatus = FrsRtlInsertTailQueue(&OutLogWork, &Cmd->ListEntry);
    if (!WIN_SUCCESS(WStatus)) {
        FRS_CLOSE(Cmd->Parameters.OutLogRequest.CompletionEvent);
        Cmd->Parameters.OutLogRequest.CompletionEvent = NULL;
        FrsCompleteCommand(Cmd, FrsErrorQueueIsRundown);
        return FrsErrorQueueIsRundown;
    }

    //
    // Wait for the command to finish
    //
    WaitForSingleObject(Cmd->Parameters.OutLogRequest.CompletionEvent, INFINITE);
    FStatus = Cmd->ErrorStatus;
    FRS_CLOSE(Cmd->Parameters.OutLogRequest.CompletionEvent);
    Cmd->Parameters.OutLogRequest.CompletionEvent = NULL;
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);

    DPRINT1_FS(0, "ERROR Submitting %ws\\%ws\\%ws -> %ws\\%ws",
               PRINT_CXTION_PATH(Replica, Cxtion), FStatus);
    return FStatus;
}


VOID
OutLogCopyCxtionToCxtionRecord(
    IN PCXTION      Cxtion,
    IN PTABLE_CTX   TableCtx
    )
/*++

Routine Description:

    Copy the cxtion fields into the cxtion record for DB update.

Arguments:

    Cxtion
    TableCtx

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCopyCxtionToCxtionRecord:"
    POUT_LOG_PARTNER    OutLogPartner;
    IN PCXTION_RECORD   CxtionRecord = TableCtx->pDataRecord;

    //
    // Update the database record in memory
    //
    if (!Cxtion->Name->Name) {
        DPRINT(0, "ERROR - Cxtion's name is NULL!\n");
        Cxtion->Name->Name = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->Partner->Name) {
        DPRINT1(0, "ERROR - %ws: Cxtion's partner's name is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->Partner->Name = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartSrvName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartSrvName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartSrvName = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartnerPrincName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerPrincName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerPrincName = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartnerSid) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerSid is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerSid = FrsWcsDup(L"<unknown>");
    }

    //
    // Cxtion Guid and Name
    //
    COPY_GUID(&CxtionRecord->CxtionGuid, Cxtion->Name->Guid);
    wcsncpy(CxtionRecord->CxtionName, Cxtion->Name->Name, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->CxtionName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner Guid and Name
    //
    COPY_GUID(&CxtionRecord->PartnerGuid, Cxtion->Partner->Guid);
    wcsncpy(CxtionRecord->PartnerName, Cxtion->Partner->Name, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->PartnerName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner DNS Name
    //
    wcsncpy(CxtionRecord->PartnerDnsName, Cxtion->PartnerDnsName, DNS_MAX_NAME_LENGTH + 1);
    CxtionRecord->PartnerDnsName[DNS_MAX_NAME_LENGTH] = L'\0';

    //
    // Partner PrincName and Server Name
    //
    DbsPackStrW(Cxtion->PartnerPrincName, CrPartnerPrincNamex, TableCtx);
    wcsncpy(CxtionRecord->PartSrvName, Cxtion->PartSrvName, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->PartSrvName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner SID
    //
    DbsPackStrW(Cxtion->PartnerSid, CrPartnerSidx, TableCtx);

    //
    // Partner Auth Level
    //
    CxtionRecord->PartnerAuthLevel = Cxtion->PartnerAuthLevel;

    //
    // Inbound Flag
    //
    CxtionRecord->Inbound = Cxtion->Inbound;

    //
    // LastJoinTime
    //
    COPY_TIME(&CxtionRecord->LastJoinTime, &Cxtion->LastJoinTime);

    CxtionRecord->TerminationCoSeqNum = Cxtion->TerminationCoSeqNum;

    //
    // Cxtion options.
    //
    CxtionRecord->Options = Cxtion->Options;

    //
    // Cxtion Flags
    // High short belongs to cxtion
    //
    CxtionRecord->Flags &= ~CXTION_FLAGS_CXTION_RECORD_MASK;
    CxtionRecord->Flags |= (Cxtion->Flags & CXTION_FLAGS_CXTION_RECORD_MASK);

    //
    // OUT LOG PARTNER.  An inbound connection won't have an OutLogPartner struct.
    //
    OutLogPartner = Cxtion->OLCtx;
    if (OutLogPartner) {
        //
        // Low short belongs to outlogpartner
        //
        CxtionRecord->Flags &= ~OLP_FLAGS_CXTION_RECORD_MASK;
        CxtionRecord->Flags |= (OutLogPartner->Flags & OLP_FLAGS_CXTION_RECORD_MASK);
        CxtionRecord->COLx = OutLogPartner->COLx;
        CxtionRecord->COTx = OutLogPartner->COTx;
        CxtionRecord->COTxNormalModeSave = OutLogPartner->COTxNormalModeSave;
        CxtionRecord->COTslot = OutLogPartner->COTslot;
        CxtionRecord->OutstandingQuota = OutLogPartner->OutstandingQuota;
        CopyMemory(CxtionRecord->AckVector, OutLogPartner->AckVector, ACK_VECTOR_BYTES);
        CxtionRecord->AckVersion = OutLogPartner->AckVersion;
    }
    //
    // Pack the schedule blob
    //
    DbsPackSchedule(Cxtion->Schedule, CrSchedulex, TableCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\schema.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    schema.c

Abstract:

    Defines the initial values for the table layout structs in Jet
    for the NT File Replication Service.

    Note:  The record layout and enums for record entries are defined in schema.h
           Any change here must be reflected there.

    See the comment header in schema.h for the procedure to add a new table
    definition.


    This header defines structures and macros for managing and initializing
    columns, indexes and tables in a JET Database.

    For each jet table there is a column descriptor struct, and index descriptor
    struct, a JET_SETCOLUMN array and an entry in a table descriptor struct.
    In addition there are ennums defined for the entries in the column descriptor,
    index descriptor and Table arrays.  The example below illustrates the
    construction of the descriptors for the "IDTable".  Note the use of the
    "IDTable" and "IDTABLE" prefixes.  Also note the use of the "x" suffix on
    column field names in the enum declarations.

    //
    // The enum for the IDTable column entries.
    //
    typedef enum IDTABLE_COL_LIST {
        FileGuidx = 0,          // The guid assigned to the file.
        IDTABLE_MAX_COL
    };
    //
    // The IDTable column descriptor definition.
    //
    JET_COLUMNCREATE IDTableColDesc[]=
    {
        {"FileGuid", JET_coltypBinary, 16, JET_bitColumnFixed, NULL, 0}
    };


    //
    // The IDTable JET_SETCOLUMN array for reading/writing IDTable rows.
    //
    JET_SETCOLUMN IDTableJetSetCol[IDTABLE_MAX_COL];


    //
    // The enum for the IDTable index entries.
    //
    typedef enum IDTABLE_INDEX_LIST {
        GuidIndexx = 0,         // The index on the file GUID.
        IDTABLE_MAX_INDEX
    };
    //
    // The IDTable index descriptor definition.
    //
    JET_INDEXCREATE IDTableIndexDesc[] = {
        {"GuidIndex", "+FileGuid\0", 11, JET_bitIndexUnique,  60}
    };


    //
    // The enum for the each defined table with an entry for the IDTable.
    //
    typedef enum TABLE_LIST {
        IDTablex = 0,           // The ID table description.
        TABLE_LIST_MAX
    };
    //
    // The Table descriptor array with an entry for the IDTable.
    //
    TABLE_DESC DBTables[] = {
        {"IDTable", INIT_IDTABLE_PAGES, INIT_IDTABLE_DENSITY,
        IDTABLE_MAX_COL, IDTableColDesc, IDTABLE_MAX_INDEX, IDTableIndexDesc}

    };



The JET_COLUMNCREATE struct describes each column in a table.  It has the name
the data type, the max size, the GRbits, the default value, the returned
column ID and an error status.

The JET_INDEXCREATE struct describes each index in a table.  It has the name of
the index, the key description of the index, the GRbits, the requested
density of the index pages amd an error status.

The JET_TABLECREATE struct describes each type of table in the database.  It has
the name of the table, the initial size of the table in pages, the initial
density parameter for the data pages (to allow for inserts without having to
split the page right away), the column count, a ptr to the COLUMN_DESC struct,
the index count, a pointer to the INDEX_DESC struct.  It also has a grbits param
and jet returns the table ID and a count of the number of columns and indexes
created.  Jet97 provides for creating a template table which you can then use to
create duplicate tables.  A parameter in the JET_TABLECREATE struct contains the
name of the template table to use for the create.  This ensures that the column
IDs in all instances of the tables are the same so we need to keep only one copy
of a JET_SETCOLUMN struct (with the column IDs) to read and write records in any
instance of the table.

Another grbit is JET_bitFixedDDL.  When a table is created with this flag
no columns or indexes can be deleted or created in the table.  This allows
jet to avoid taking some critical sections when doing set/retrieve on the
column data thus improving performance/scalability.

Author:

    David Orbits (davidor) - 14-Mar-1997

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <ntreppch.h>
#pragma  hdrstop

#define MB2 (2*1024*1024)

#define CBJCC sizeof(JET_COLUMNCREATE)
#define CBJIC sizeof(JET_INDEXCREATE)

typedef struct ___tag_JET_COLUMNCREATE // from jet header for ref only.
    {
    unsigned long   cbStruct;          // size of this structure
    char           *szColumnName;      // column name
    JET_COLTYP      coltyp;            // column type
    unsigned long   cbMax;             // the maximum length of this column (only relevant for binary and text columns)
    JET_GRBIT       grbit;             // column options
    void           *pvDefault;         // default value (NULL if none)
    unsigned long   cbDefault;         // length of default value
    unsigned long   cp;                // code page (for text columns only)
    JET_COLUMNID    columnid;          // returned column id
    JET_ERR         err;               // returned error code
    } ___JET_COLUMNCREATE;



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **             P a r t n e r   C o n n e c t i o n   T a b l e               **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The Connection Table column descriptions are as follows.
// Note - the order of the enum in schema.h and the table entries must be kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType                    ColMaxWidth    GrBits    pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.

JET_COLUMNCREATE CXTIONTableColDesc[]=
{
    {CBJCC, "CxtionGuid",      JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "CxtionName",      JET_coltypLongText,    2*(MAX_RDN_VALUE_SIZE+1),
                                                                 0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerGuid",     JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "PartnerName",     JET_coltypLongText,    2*(MAX_RDN_VALUE_SIZE+1),
                                                                 0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartSrvName",     JET_coltypLongText,    2*(MAX_RDN_VALUE_SIZE+1),
                                                                 0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerDnsName",  JET_coltypLongText,    2*(DNS_MAX_NAME_LENGTH+1),
                                                                 0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Inbound",         JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Schedule",        JET_coltypLongBinary, MB2,        0         , NULL, 0},
    {CBJCC, "TerminationCoSeqNum", JET_coltypLong,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastJoinTime",    JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Flags",           JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "COLx",            JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "COTx",            JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "COTxNormalModeSave", JET_coltypLong ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "COTslot",         JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OutstandingQuota",JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "AckVector",       JET_coltypBinary  ,   ACK_VECTOR_BYTES,
                                                         JET_bitColumnFixed, NULL, 0},

    {CBJCC, "PartnerNetBiosName", JET_coltypLongText,   MB2,     0            , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerPrincName",   JET_coltypLongText,   MB2,     0            , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerCoDn",        JET_coltypLongText,   MB2,     0            , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerCoGuid",      JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},

    // Note: PartnerDn is a misnomer; it should be PartnerSid.
    // BUT don't change the field name, PartnerDn! May cause DB problems.
    {CBJCC, "PartnerDn",          JET_coltypLongText,   MB2,     0            , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Options",            JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OverSite",           JET_coltypLongText,   MB2,     0            , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "PartnerAuthLevel",   JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},

    // Note: Spare1Ull field is now used for AckVector Version.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Ull",          JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",          JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Guid",         JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",         JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Bin",          JET_coltypLongBinary, MB2,         0        , NULL, 0},
    {CBJCC, "Spare2Bin",          JET_coltypLongBinary, MB2,         0        , NULL, 0}
};


//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS CXTIONTableRecordFields[] = {
    {sizeof(CXTION_RECORD)     , 0,               CXTION_TABLE_MAX_COL },
    {RECORD_FIELD(CXTION_RECORD, CxtionGuid,             DT_GUID      )},
    {RECORD_FIELD(CXTION_RECORD, CxtionName,             DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerGuid,            DT_GUID      )},
    {RECORD_FIELD(CXTION_RECORD, PartnerName,            DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartSrvName,            DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerDnsName,         DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, Inbound,                DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, Schedule,               DT_BINARY    )},
    {RECORD_FIELD(CXTION_RECORD, TerminationCoSeqNum,    DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, LastJoinTime,           DT_FILETIME  )},
    {RECORD_FIELD(CXTION_RECORD, Flags,                  DT_CXTION_FLAGS)},
    {RECORD_FIELD(CXTION_RECORD, COLx,                   DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, COTx,                   DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, COTxNormalModeSave,     DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, COTslot,                DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, OutstandingQuota,       DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, AckVector,              DT_BINARY    )},

    {RECORD_FIELD(CXTION_RECORD, PartnerNetBiosName,     DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerPrincName,       DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerCoDn,            DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerCoGuid,          DT_GUID      )},
    {RECORD_FIELD(CXTION_RECORD, PartnerSid,             DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, Options,                DT_ULONG     )},
    {RECORD_FIELD(CXTION_RECORD, OverSite,               DT_UNICODE   )},
    {RECORD_FIELD(CXTION_RECORD, PartnerAuthLevel,       DT_ULONG     )},

    {RECORD_FIELD(CXTION_RECORD, AckVersion,             DT_FILETIME  )},
    {RECORD_FIELD(CXTION_RECORD, Spare2Ull,              DT_LONGLONG_SPARE  )},
    {RECORD_FIELD(CXTION_RECORD, Spare1Guid,             DT_GUID_SPARE      )},
    {RECORD_FIELD(CXTION_RECORD, Spare2Guid,             DT_GUID_SPARE      )},
    {RECORD_FIELD(CXTION_RECORD, Spare1Bin,              DT_BINARY_SPARE    )},
    {RECORD_FIELD(CXTION_RECORD, Spare2Bin,              DT_BINARY_SPARE    )}
};


JET_SETCOLUMN      CXTIONTableJetSetCol[CXTION_TABLE_MAX_COL];
JET_RETRIEVECOLUMN CXTIONTableJetRetCol[CXTION_TABLE_MAX_COL];


//
// The Connection Table index descriptions are as follows.
// Note - the order of the enum and the table entries must be kept in sync.
//

//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//             Name             Key        KeyLen    JIndexGrBits      Density
//
JET_INDEXCREATE CXTIONTableIndexDesc[] = {
    {CBJIC, "GCxtionGuid",  "+CxtionGuid\0", 13,     JET_bitIndexUnique,  80}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                           I n b o u n d   L o g                           **
 **                    C h a n g e    O r d e r   T a b l e                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The Inbound Log change order Table column descriptions are as follows.
// Note - the order of the enum in schema.h and the table entries must be
// kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType       ColMaxWidth    GrBits         pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.
// ** Note ** The Sequence number field, an auto inc column, must be the first
// column of the record because DbsInsertTable2 retrieves it for us after the
// insert.

JET_COLUMNCREATE ILChangeOrderTableColDesc[]=
{
    {CBJCC, "SequenceNumber",    JET_coltypLong,     4, JET_bitColumnAutoincrement |
                                                        JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Flags",             JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "IFlags",            JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "State",             JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ContentCmd",        JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Lcmd",              JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileAttributes",    JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileVersionNumber", JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "PartnerAckSeqNumber", JET_coltypLong,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileSize",          JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileOffset",        JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FrsVsn",            JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileUsn",           JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "JrnlUsn",           JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "JrnlFirstUsn",      JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    // Note: The following two fields now refer to OriginalReplicaNum and NewReplicaNum.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "OriginalReplica",   JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "NewReplica",        JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "ChangeOrderGuid",   JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OriginatorGuid",    JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileGuid",          JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OldParentGuid",     JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "NewParentGuid",     JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "CxtionGuid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},

    // Note: Spare1Ull field is now used for AckVector Version.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Ull",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Guid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Wcs",         JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare2Wcs",         JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},

    // Note: Spare1Bin field is now used for Change Order Command Extension.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Bin",         JET_coltypLongBinary, MB2,         0     , NULL, 0},
    {CBJCC, "Spare2Bin",         JET_coltypLongBinary, MB2,         0     , NULL, 0},

    {CBJCC, "EventTime",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileNameLength",    JET_coltypShort,    2, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileName",          JET_coltypLongText, 2*(MAX_PATH+1),
                                                                   0      , NULL, 0, CP_UNICODE_FOR_JET}
};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS ILChangeOrderRecordFields[] = {
    {sizeof(CHANGE_ORDER_RECORD) , 0,                    CHANGE_ORDER_MAX_COL },
    {RECORD_FIELD(CHANGE_ORDER_RECORD, SequenceNumber,      DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Flags,               DT_COCMD_FLAGS  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, IFlags,              DT_COCMD_IFLAGS )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, State,               DT_COSTATE      )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, ContentCmd,          DT_USN_FLAGS    )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Lcmd,                DT_CO_LOCN_CMD  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileAttributes,      DT_FILEATTR     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileVersionNumber,   DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, PartnerAckSeqNumber, DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileSize,            DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileOffset,          DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FrsVsn,              DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileUsn,             DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, JrnlUsn,             DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, JrnlFirstUsn,        DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OriginalReplicaNum,  DT_REPLICA_ID   )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, NewReplicaNum,       DT_REPLICA_ID   )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, ChangeOrderGuid,     DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OriginatorGuid,      DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileGuid,            DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OldParentGuid,       DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, NewParentGuid,       DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, CxtionGuid,          DT_CXTION_GUID  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, AckVersion,          DT_FILETIME     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Ull,           DT_LONGLONG_SPARE)},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare1Guid,          DT_GUID_SPARE    )},
    // Warning: See comment in schema.h before using Spare2Guid, Spare1Wcs or Spare2Wcs.
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Guid,          DT_GUID_SPARE    )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare1Wcs,           DT_UNICODE_SPARE )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Wcs,           DT_UNICODE_SPARE )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Extension,           DT_COCMD_EXTENSION /*| DT_NO_DEFAULT_ALLOC_FLAG */)},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Bin,           DT_BINARY_SPARE  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, EventTime,           DT_FILETIME     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileNameLength,      DT_SHORT        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileName,            DT_UNICODE      )}
};



JET_SETCOLUMN      ILChangeOrderJetSetCol[CHANGE_ORDER_MAX_COL];
JET_RETRIEVECOLUMN ILChangeOrderJetRetCol[CHANGE_ORDER_MAX_COL];


//
// The Table index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//

typedef struct ___tagJET_INDEXCREATE // from jet header for ref only.
    {
    unsigned long   cbStruct;       // size of this structure
    char           *szIndexName;    // index name
    char           *szKey;          // index key
    unsigned long   cbKey;          // length of key
    JET_GRBIT       grbit;          // index options
    unsigned long   ulDensity;      // index density
    JET_ERR         err;            // returned error code
    } ___JET_INDEXCREATE;


//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//             Name             Key        KeyLen    JIndexGrBits      Density
//
// ** Note the file guid index is not unique because the Inbound log could
//    have a new change order come in on a file while a previous change
//    order is pending because of an incomplete install.
//
// ** The Change Order Guid is not unique because a duplicate CO could arrive
//    from a different inbound partner while we already have that CO in the
//    inbound log because of a retry.  We need to track them all because each
//    partner needs an Ack.
//
JET_INDEXCREATE ILChangeOrderIndexDesc[] = {
{CBJIC, "LSequenceNumberIndex", "+SequenceNumber\0" , 17, JET_bitIndexUnique |
                                                          JET_bitIndexPrimary, 80},
{CBJIC, "GFileGuidIndex",       "+FileGuid\0"       , 11,       0           ,  80},
{CBJIC, "GChangeOrderGuid",     "+ChangeOrderGuid\0", 18,       0           ,  80},
{CBJIC, "2GGCxtionGuidCoGuid",  "+CxtionGuid\0+ChangeOrderGuid\0",
                                                      30, JET_bitIndexUnique,  80}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//


//
// Change Order record flags.
//
FLAG_NAME_TABLE CoFlagNameTable[] = {
    {CO_FLAG_ABORT_CO            , "Abort "       },
    {CO_FLAG_VV_ACTIVATED        , "VVAct "       },
    {CO_FLAG_CONTENT_CMD         , "Content "     },
    {CO_FLAG_LOCATION_CMD        , "Locn "        },

    {CO_FLAG_ONLIST              , "OnList "      },
    {CO_FLAG_LOCALCO             , "LclCo "       },
    {CO_FLAG_RETRY               , "Retry "       },
    {CO_FLAG_INSTALL_INCOMPLETE  , "InstallInc "  },

    {CO_FLAG_REFRESH             , "Refresh "     },
    {CO_FLAG_OUT_OF_ORDER        , "OofOrd "      },
    {CO_FLAG_NEW_FILE            , "NewFile "     },
    {CO_FLAG_FILE_USN_VALID      , "FileUsnValid "},

    {CO_FLAG_CONTROL             , "CtrlCo "      },
    {CO_FLAG_DIRECTED_CO         , "DirectedCo "  },
    {CO_FLAG_UNUSED4000          , "4000 "        },
    {CO_FLAG_UNUSED8000          , "8000 "        },

    {CO_FLAG_UNUSED10000         , "10000 "       },
    {CO_FLAG_DEMAND_REFRESH      , "DemandRef "   },
    {CO_FLAG_VVJOIN_TO_ORIG      , "VVjoinToOrig "},
    {CO_FLAG_MORPH_GEN           , "MorphGen "    },

    {CO_FLAG_SKIP_ORIG_REC_CHK   , "SkipOrigChk " },
    {CO_FLAG_MOVEIN_GEN          , "MoveinGen "   },
    {CO_FLAG_MORPH_GEN_LEADER    , "MorphGenLdr " },
    {CO_FLAG_JUST_OID_RESET      , "OidReset "    },

    {CO_FLAG_COMPRESSED_STAGE    , "CmpresStage " },

    {CO_FLAG_SKIP_VV_UPDATE      , "SkipVVUpdt "  },

    {0, NULL}
};


//
// Change Order record Interlocked flags.
//
FLAG_NAME_TABLE CoIFlagNameTable[] = {

    {CO_IFLAG_VVRETIRE_EXEC       , "IFlagVVRetireExec "  },
    {CO_IFLAG_CO_ABORT            , "IFlagCoAbort "        },
    {CO_IFLAG_DIR_ENUM_PENDING    , "IFlagDirEnumPending " },

    {0, NULL}
};

//
// Decode table for USN Reason Mask in ContentCmd.
//
FLAG_NAME_TABLE UsnReasonNameTable[] = {

    {USN_REASON_CLOSE                   , "Close "        },
    {USN_REASON_FILE_CREATE             , "Create "       },
    {USN_REASON_FILE_DELETE             , "Delete "       },
    {USN_REASON_RENAME_NEW_NAME         , "RenNew "       },
    {USN_REASON_RENAME_OLD_NAME         , "RenOld "       },

    {USN_REASON_DATA_OVERWRITE          , "DatOvrWrt "    },
    {USN_REASON_DATA_EXTEND             , "DatExt "       },
    {USN_REASON_DATA_TRUNCATION         , "DatTrunc "     },
    {USN_REASON_BASIC_INFO_CHANGE       , "Info "         },
    {USN_REASON_OBJECT_ID_CHANGE        , "Oid "          },

    {USN_REASON_STREAM_CHANGE           , "StreamNam "    },
    {USN_REASON_NAMED_DATA_OVERWRITE    , "StrmOvrWrt "   },
    {USN_REASON_NAMED_DATA_EXTEND       , "StrmExt "      },
    {USN_REASON_NAMED_DATA_TRUNCATION   , "StrmTrunc "    },
    {USN_REASON_EA_CHANGE               , "EAChg "        },
    {USN_REASON_SECURITY_CHANGE         , "Security "     },
    {USN_REASON_INDEXABLE_CHANGE        , "IndexableChg " },
    {USN_REASON_HARD_LINK_CHANGE        , "HLink "        },
    {USN_REASON_COMPRESSION_CHANGE      , "CompressChg "  },
    {USN_REASON_ENCRYPTION_CHANGE       , "EncryptChg "   },
    {USN_REASON_REPARSE_POINT_CHANGE    , "Reparse "      },

    {0, NULL}
};


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                         O u t b o u n d   L o g                           **
 **                    C h a n g e    O r d e r   T a b l e                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The Outbound Log change order Table column descriptions are as follows.
// Note - the order of the enum in schema.h and the table entries must be
// kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType       ColMaxWidth    GrBits         pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.
//

JET_COLUMNCREATE OLChangeOrderTableColDesc[]=
{
    {CBJCC, "SequenceNumber",    JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Flags",             JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "IFlags",            JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "State",             JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ContentCmd",        JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Lcmd",              JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileAttributes",    JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileVersionNumber", JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "PartnerAckSeqNumber", JET_coltypLong,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileSize",          JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileOffset",        JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FrsVsn",            JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileUsn",           JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "JrnlUsn",           JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "JrnlFirstUsn",      JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    // Note: The following two fields now refer to OriginalReplicaNum and NewReplicaNum.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "OriginalReplica",   JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "NewReplica",        JET_coltypLong,     4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "ChangeOrderGuid",   JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OriginatorGuid",    JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileGuid",          JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OldParentGuid",     JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "NewParentGuid",     JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "CxtionGuid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},

    // Note: Spare1Ull field is now used for AckVector Version.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Ull",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Guid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",        JET_coltypBinary,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Wcs",         JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare2Wcs",         JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},

    // Note: Spare1Bin field is now used for Change Order Command Extension.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Bin",         JET_coltypLongBinary, MB2,         0     , NULL, 0},
    {CBJCC, "Spare2Bin",         JET_coltypLongBinary, MB2,         0     , NULL, 0},

    {CBJCC, "EventTime",         JET_coltypCurrency, 8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileNameLength",    JET_coltypShort,    2, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileName",          JET_coltypLongText, 2*(MAX_PATH+1),
                                                                   0      , NULL, 0, CP_UNICODE_FOR_JET}
};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS OLChangeOrderRecordFields[] = {
    {sizeof(CHANGE_ORDER_RECORD) , 0,                    CHANGE_ORDER_MAX_COL },
    {RECORD_FIELD(CHANGE_ORDER_RECORD, SequenceNumber,      DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Flags,               DT_COCMD_FLAGS  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, IFlags,              DT_COCMD_IFLAGS )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, State,               DT_COSTATE      )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, ContentCmd,          DT_USN_FLAGS    )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Lcmd,                DT_CO_LOCN_CMD  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileAttributes,      DT_FILEATTR     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileVersionNumber,   DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, PartnerAckSeqNumber, DT_ULONG        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileSize,            DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileOffset,          DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FrsVsn,              DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileUsn,             DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, JrnlUsn,             DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, JrnlFirstUsn,        DT_X8           )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OriginalReplicaNum,  DT_REPLICA_ID   )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, NewReplicaNum,       DT_REPLICA_ID   )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, ChangeOrderGuid,     DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OriginatorGuid,      DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileGuid,            DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, OldParentGuid,       DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, NewParentGuid,       DT_GUID         )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, CxtionGuid,          DT_CXTION_GUID  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, AckVersion,          DT_FILETIME     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Ull,           DT_LONGLONG_SPARE)},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare1Guid,          DT_GUID_SPARE    )},
    // Warning: See comment in schema.h before using Spare2Guid, Spare1Wcs or Spare2Wcs.
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Guid,          DT_GUID_SPARE    )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare1Wcs,           DT_UNICODE_SPARE )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Wcs,           DT_UNICODE_SPARE )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Extension,           DT_COCMD_EXTENSION /*| DT_NO_DEFAULT_ALLOC_FLAG*/ )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, Spare2Bin,           DT_BINARY_SPARE  )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, EventTime,           DT_FILETIME     )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileNameLength,      DT_SHORT        )},
    {RECORD_FIELD(CHANGE_ORDER_RECORD, FileName,            DT_UNICODE      )}
};



JET_SETCOLUMN      OLChangeOrderJetSetCol[CHANGE_ORDER_MAX_COL];
JET_RETRIEVECOLUMN OLChangeOrderJetRetCol[CHANGE_ORDER_MAX_COL];


//
// The Table index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//             Name             Key        KeyLen    JIndexGrBits      Density
//
JET_INDEXCREATE OLChangeOrderIndexDesc[] = {
{CBJIC, "LSequenceNumberIndex", "+SequenceNumber\0" , 17, JET_bitIndexUnique |
                                                          JET_bitIndexPrimary, 80},
{CBJIC, "GFileGuidIndex",       "+FileGuid\0"       , 11,         0         ,  80},
{CBJIC, "GChangeOrderGuid",     "+ChangeOrderGuid\0", 18, JET_bitIndexUnique,  80}

};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                         D i r T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The DIRTable column descriptions are as follows.  Note - the order of the
// enum in schema.h and the table entries must be kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType       ColMaxWidth    GrBits    pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.

JET_COLUMNCREATE DIRTableColDesc[]=
{
    {CBJCC, "DFileGuid",       JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "DFileID",         JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "DParentFileID",   JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "DReplicaNumber",  JET_coltypLong    ,    4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "DFileName",       JET_coltypLongText,    2*(MAX_PATH+1),
                                                            0         , NULL, 0, CP_UNICODE_FOR_JET}
};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS DIRTableRecordFields[] = {
    {sizeof(DIRTABLE_RECORD)     , 0,                          DIRTABLE_MAX_COL },
    {RECORD_FIELD(DIRTABLE_RECORD, DFileGuid,                   DT_GUID        )},
    {RECORD_FIELD(DIRTABLE_RECORD, DFileID,                     DT_X8          )},
    {RECORD_FIELD(DIRTABLE_RECORD, DParentFileID,               DT_X8          )},
    {RECORD_FIELD(DIRTABLE_RECORD, DReplicaNumber,              DT_ULONG       )},
    {RECORD_FIELD(DIRTABLE_RECORD, DFileName,                   DT_UNICODE     )}
};



JET_SETCOLUMN      DIRTableJetSetCol[DIRTABLE_MAX_COL];
JET_RETRIEVECOLUMN DIRTableJetRetCol[DIRTABLE_MAX_COL];


//
// The DIRTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//

//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//             Name             Key        KeyLen    JIndexGrBits      Density
//
JET_INDEXCREATE DIRTableIndexDesc[] = {
    {CBJIC, "GDFileGuidIndex", "+DFileGuid\0", 12,   JET_bitIndexUnique |
                                                     JET_bitIndexPrimary,  60},
    {CBJIC, "QDFileIDIndex",   "+DFileID\0",   10,   JET_bitIndexUnique,   60}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//





 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                           I D T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The IDTable column descriptions are as follows.  Note - the order of the
// enum in schema.h and the table entries must be kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType       ColMaxWidth    GrBits    pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.

JET_COLUMNCREATE IDTableColDesc[]=
{
    {CBJCC, "FileGuid",       JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileID",         JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ParentGuid",     JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ParentFileID",   JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "VersionNumber",  JET_coltypLong,        4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "EventTime",      JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OriginatorGuid", JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "OriginatorVSN",  JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "CurrentFileUsn", JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "FileCreateTime", JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileWriteTime",  JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileSize",       JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileObjID",      JET_coltypBinary,      FILE_OBJECTID_SIZE,
                                                        JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileName",       JET_coltypLongText,    2*(MAX_PATH+1),
                                                                0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "FileIsDir",      JET_coltypLong,        4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileAttributes", JET_coltypLong,        4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Flags",          JET_coltypLong,        4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplEnabled",    JET_coltypLong,        4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "TombStoneGC",    JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "OutLogSeqNum",   JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},

    // Note: Spare1Ull field is now used for the IdtVVFlags.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Ull",      JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",      JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "Spare1Guid",     JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",     JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "Spare1Wcs",      JET_coltypLongText,   MB2,         0        , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare2Wcs",      JET_coltypLongText,   MB2,         0        , NULL, 0, CP_UNICODE_FOR_JET},

    // Note: Spare1Bin field is now used for the IDTable Data Extension.
    //       Can't change field name without compatibility probs with existing DBs.
    {CBJCC, "Spare1Bin",      JET_coltypLongBinary, MB2,         0        , NULL, 0},
    {CBJCC, "Spare2Bin",      JET_coltypLongBinary, MB2,         0        , NULL, 0}

};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS IDTableRecordFields[] = {
    {sizeof(IDTABLE_RECORD)     , 0,              IDTABLE_MAX_COL },
    {RECORD_FIELD(IDTABLE_RECORD, FileGuid,       DT_GUID        )},
    {RECORD_FIELD(IDTABLE_RECORD, FileID,         DT_X8          )},
    {RECORD_FIELD(IDTABLE_RECORD, ParentGuid,     DT_GUID        )},
    {RECORD_FIELD(IDTABLE_RECORD, ParentFileID,   DT_X8          )},
    {RECORD_FIELD(IDTABLE_RECORD, VersionNumber,  DT_ULONG       )},
    {RECORD_FIELD(IDTABLE_RECORD, EventTime,      DT_FILETIME    )},
    {RECORD_FIELD(IDTABLE_RECORD, OriginatorGuid, DT_GUID        )},
    {RECORD_FIELD(IDTABLE_RECORD, OriginatorVSN,  DT_X8          )},
    {RECORD_FIELD(IDTABLE_RECORD, CurrentFileUsn, DT_USN         )},
    {RECORD_FIELD(IDTABLE_RECORD, FileCreateTime, DT_FILETIME    )},
    {RECORD_FIELD(IDTABLE_RECORD, FileWriteTime,  DT_FILETIME    )},
    {RECORD_FIELD(IDTABLE_RECORD, FileSize,       DT_X8          )},
    {RECORD_FIELD(IDTABLE_RECORD, FileObjID,      DT_OBJID       )},
    {RECORD_FIELD(IDTABLE_RECORD, FileName,       DT_UNICODE     )},
    {RECORD_FIELD(IDTABLE_RECORD, FileIsDir,      DT_BOOL        )},
    {RECORD_FIELD(IDTABLE_RECORD, FileAttributes, DT_FILEATTR    )},
    {RECORD_FIELD(IDTABLE_RECORD, Flags,          DT_IDT_FLAGS   )},
    {RECORD_FIELD(IDTABLE_RECORD, ReplEnabled,    DT_BOOL        )},
    {RECORD_FIELD(IDTABLE_RECORD, TombStoneGC,    DT_FILETIME    )},

    {RECORD_FIELD(IDTABLE_RECORD, OutLogSeqNum,   DT_X8           )},
    {RECORD_FIELD(IDTABLE_RECORD, IdtVVFlags,     DT_X8           )},
    {RECORD_FIELD(IDTABLE_RECORD, Spare2Ull,      DT_X8_SPARE     )},
    {RECORD_FIELD(IDTABLE_RECORD, Spare1Guid,     DT_GUID_SPARE   )},
    {RECORD_FIELD(IDTABLE_RECORD, Spare2Guid,     DT_GUID_SPARE   )},
    {RECORD_FIELD(IDTABLE_RECORD, Spare1Wcs,      DT_UNICODE_SPARE)},
    {RECORD_FIELD(IDTABLE_RECORD, Spare2Wcs,      DT_UNICODE_SPARE)},
    {RECORD_FIELD(IDTABLE_RECORD, Extension,      DT_IDT_EXTENSION | DT_FIXED_SIZE_BUFFER)},
    {RECORD_FIELD(IDTABLE_RECORD, Spare2Bin,      DT_BINARY_SPARE )}

};



JET_SETCOLUMN IDTableJetSetCol[IDTABLE_MAX_COL];
JET_RETRIEVECOLUMN IDTableJetRetCol[IDTABLE_MAX_COL];


//
// The IDTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.  The Guid is the primary
// key because the FID can change, e.g. Reformat and file restore.
//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//             Name             Key        KeyLen    JIndexGrBits      Density
//
JET_INDEXCREATE IDTableIndexDesc[] = {
    {CBJIC, "GGuidIndex",    "+FileGuid\0", 11,   JET_bitIndexUnique |
                                                  JET_bitIndexPrimary,  60},
    {CBJIC, "QFileIDIndex",  "+FileID\0",    9,   JET_bitIndexUnique,  60},
    {CBJIC, "2GWParGuidFileName",  "+ParentGuid\0+FileName\0", 23, 0,  80}

};



// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So don't make fileID a primary index since on a directory restore all the
// file IDs could change and have to be updated.
//



//
// IDRecord Table Flags.
//
FLAG_NAME_TABLE IDRecFlagNameTable[] = {
    {IDREC_FLAGS_DELETED               , "DELETED "      },
    {IDREC_FLAGS_CREATE_DEFERRED       , "CreDefer "     },
    {IDREC_FLAGS_DELETE_DEFERRED       , "DelDefer "     },
    {IDREC_FLAGS_RENAME_DEFERRED       , "RenDefer "     },

    {IDREC_FLAGS_NEW_FILE_IN_PROGRESS  , "NewFileInProg "},
    {IDREC_FLAGS_ENUM_PENDING          , "EnumPending "  },
    {0, NULL}
};



//
// FileAttribute Flags
//

FLAG_NAME_TABLE FileAttrFlagNameTable[] = {
    {FILE_ATTRIBUTE_READONLY           , "READONLY "           },
    {FILE_ATTRIBUTE_HIDDEN             , "HIDDEN "             },
    {FILE_ATTRIBUTE_SYSTEM             , "SYSTEM "             },
    {FILE_ATTRIBUTE_DIRECTORY          , "DIRECTORY "          },
    {FILE_ATTRIBUTE_ARCHIVE            , "ARCHIVE "            },
    {FILE_ATTRIBUTE_DEVICE             , "DEVICE "             },
    {FILE_ATTRIBUTE_NORMAL             , "NORMAL "             },
    {FILE_ATTRIBUTE_TEMPORARY          , "TEMPORARY "          },
    {FILE_ATTRIBUTE_SPARSE_FILE        , "SPARSE_FILE "        },
    {FILE_ATTRIBUTE_REPARSE_POINT      , "REPARSE_POINT "      },
    {FILE_ATTRIBUTE_COMPRESSED         , "COMPRESSED "         },
    {FILE_ATTRIBUTE_OFFLINE            , "OFFLINE "            },
    {FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, "NOT_CONTENT_INDEXED "},
    {FILE_ATTRIBUTE_ENCRYPTED          , "ENCRYPTED "          },

    {0, NULL}
};









 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                           V V T a b l e                                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// The VVTable column descriptions are as follows.  Note - the order of the
// enum in schema.h and the table entries must be kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name             ColType       ColMaxWidth    GrBits    pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.

JET_COLUMNCREATE VVTableColDesc[]=
{
    {CBJCC, "VVOriginatorGuid",JET_coltypBinary,     16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "VVOriginatorVsn", JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},

    // Spare1Ull is now used for storing the VSN of the last CO that was deleted
    // from the outlog. This is used to build the OutlogVVector. It is called
    // VVOutlogOriginatorVsn
    {CBJCC, "Spare1Ull",       JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",       JET_coltypCurrency,    8, JET_bitColumnFixed, NULL, 0}
};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS VVTableRecordFields[] = {
    {sizeof(VVTABLE_RECORD)      , 0,                           VVTABLE_MAX_COL },
    {RECORD_FIELD(VVTABLE_RECORD,  VVOriginatorGuid,            DT_GUID        )},
    {RECORD_FIELD(VVTABLE_RECORD,  VVOriginatorVsn,             DT_X8          )},
    {RECORD_FIELD(VVTABLE_RECORD,  VVOutlogOriginatorVsn,       DT_LONGLONG    )},
    {RECORD_FIELD(VVTABLE_RECORD,  Spare2Ull,                   DT_LONGLONG_SPARE)}
};

JET_SETCOLUMN      VVTableJetSetCol[VVTABLE_MAX_COL];
JET_RETRIEVECOLUMN VVTableJetRetCol[VVTABLE_MAX_COL];


//
// The VVTable index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//

//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//               Name               Key         KeyLen    JIndexGrBits     Density
//
JET_INDEXCREATE VVTableIndexDesc[] = {
    {CBJIC, "GVVGuidIndex", "+VVOriginatorGuid\0", 19, JET_bitIndexUnique |
                                                       JET_bitIndexPrimary,  80}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **            R E P L I C A   S E T   C O N F I G   T A B L E                **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
//
// Note: Order of entries must track enum in schema.h
//
// There is only one config table in the database.  Each row in the table
// describes the configuration info for a single replica set.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.
//
//
//             Name                    ColType      ColMaxWidth    JColGrBits    pvDefault cbDefault
//

JET_COLUMNCREATE ConfigTableColDesc[]=
{
    {CBJCC, "ReplicaSetGuid",          JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaMemberGuid",       JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaSetName",          JET_coltypText      ,   2*(DNS_MAX_NAME_LENGTH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaNumber",           JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaMemberUSN",        JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "ReplicaMemberName",       JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaMemberDn",         JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaServerDn",         JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaSubscriberDn",     JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaRootGuid",         JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MembershipExpires",       JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaVersionGuid",      JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaSetExt",           JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ReplicaMemberExt",        JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ReplicaSubscriberExt",    JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ReplicaSubscriptionsExt", JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ReplicaSetType",          JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaSetFlags",         JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaMemberFlags",      JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaSubscriberFlags",  JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaDsPoll",           JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaAuthLevel",        JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaCtlDataCreation",  JET_coltypText      ,   2*(CONTROL_STRING_MAX+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCtlInboundBacklog",JET_coltypText      ,   2*(CONTROL_STRING_MAX+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCtlOutboundBacklog",JET_coltypText     ,   2*(CONTROL_STRING_MAX+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaFaultCondition",   JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "TimeLastCommand",         JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "DSConfigVersionNumber",   JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FSVolInfo",               JET_coltypBinary    , sizeof(FILE_FS_VOLUME_INFORMATION)+MAXIMUM_VOLUME_LABEL_LENGTH,
                                                                          0         , NULL, 0},
    {CBJCC, "FSVolGuid",               JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FSVolLastUSN",            JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FrsVsn",                  JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "LastShutdown",            JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastPause",               JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastDSCheck",             JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastDSChangeAccepted",    JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastReplCycleStart",      JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "DirLastReplCycleEnded",   JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaDeleteTime",       JET_coltypCurrency  ,   8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "LastReplCycleStatus",     JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "FSRootPath",              JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "FSRootSD",                JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "FSStagingAreaPath",       JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "SnapFileSizeLimit",       JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ActiveServCntlCommand",   JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ServiceState",            JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "ReplDirLevelLimit",       JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "InboundPartnerState",     JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "DsInfo",                  JET_coltypLongBinary, MB2,         0         , NULL, 0},

    {CBJCC, "CnfFlags",                JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "AdminAlertList",          JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},

    {CBJCC, "ThrottleSched",           JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ReplSched",               JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "FileTypePrioList",        JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},

    {CBJCC, "ResourceStats",           JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "PerfStats",               JET_coltypLongBinary, MB2,         0         , NULL, 0},
    {CBJCC, "ErrorStats",              JET_coltypLongBinary, MB2,         0         , NULL, 0},

    {CBJCC, "FileFilterList",          JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "DirFilterList",           JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "TombstoneLife",           JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "GarbageCollPeriod",       JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MaxOutBoundLogSize",      JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MaxInBoundLogSize",       JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "UpdateBlockedTime",       JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "EventTimeDiffThreshold",  JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileCopyWarningLevel",    JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileSizeWarningLevel",    JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FileSizeNoRepLevel",      JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "CnfUsnJournalID",         JET_coltypCurrency,     8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",               JET_coltypCurrency,     8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Guid",              JET_coltypBinary,      16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",              JET_coltypBinary,      16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Wcs",               JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare2Wcs",               JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare1Bin",               JET_coltypLongBinary, MB2,         0     , NULL, 0},
    {CBJCC, "Spare2Bin",               JET_coltypLongBinary, MB2,         0     , NULL, 0},

    //
    // Everything below this line is present only in the FRS <init> record.
    // Everything above is per-replica state.
    //
    // Future:  move the following to the Service Table and then remove from config record.

    {CBJCC, "MachineName",             JET_coltypText      ,   2*(MAX_RDN_VALUE_SIZE+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "MachineGuid",             JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MachineDnsName",          JET_coltypLongText  ,   2*(DNS_MAX_NAME_LENGTH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "TableVersionNumbers",     JET_coltypBinary    ,  SIZEOF(CONFIG_TABLE_RECORD, TableVersionNumbers),
                                                                  JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FSDatabasePath",          JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "FSBackupDatabasePath",    JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                          0         , NULL, 0, CP_UNICODE_FOR_JET},

    {CBJCC, "ReplicaNetBiosName",      JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaPrincName",        JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCoDn",             JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCoGuid",           JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaWorkingPath",      JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaVersion",          JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "FrsDbMajor",              JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FrsDbMinor",              JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},

    {CBJCC, "JetParameters",           JET_coltypLongBinary,  sizeof(JET_SYSTEM_PARAMS),
                                                                          0         , NULL, 0}
};



//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS ConfigTableRecordFields[] = {
    {sizeof(CONFIG_TABLE_RECORD)     , 0,               CONFIG_TABLE_MAX_COL },
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSetGuid,        DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberGuid,     DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSetName,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaNumber,         DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberUSN,      DT_X8         )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberName,     DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberDn,       DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaServerDn,       DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSubscriberDn,   DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaRootGuid,       DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, MembershipExpires,     DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaVersionGuid,    DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSetExt,         DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberExt,      DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSubscriberExt,  DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSubscriptionsExt, DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSetType,        DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSetFlags,       DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaMemberFlags,    DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaSubscriberFlags,DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaDsPoll,         DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaAuthLevel,      DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaCtlDataCreation, DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaCtlInboundBacklog, DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaCtlOutboundBacklog, DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaFaultCondition, DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, TimeLastCommand,       DT_FILETIME   )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, DSConfigVersionNumber, DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSVolInfo,             DT_FSVOLINFO  )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSVolGuid,             DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSVolLastUSN,          DT_USN        )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FrsVsn,                DT_X8         )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastShutdown,          DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastPause,             DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastDSCheck,           DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastDSChangeAccepted,  DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastReplCycleStart,    DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, DirLastReplCycleEnded, DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaDeleteTime,     DT_FILETIME   )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, LastReplCycleStatus,   DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSRootPath,            DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSRootSD,              DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSStagingAreaPath,     DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, SnapFileSizeLimit,     DT_LONG       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ActiveServCntlCommand, DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ServiceState,          DT_LONG       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplDirLevelLimit,     DT_LONG       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, InboundPartnerState,   DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, DsInfo,                DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, CnfFlags,              DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, AdminAlertList,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ThrottleSched,         DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplSched,             DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FileTypePrioList,      DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ResourceStats,         DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, PerfStats,             DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ErrorStats,            DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FileFilterList,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, DirFilterList,         DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, TombstoneLife,         DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, GarbageCollPeriod,     DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, MaxOutBoundLogSize,    DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, MaxInBoundLogSize,     DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, UpdateBlockedTime,     DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, EventTimeDiffThreshold,DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FileCopyWarningLevel,  DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FileSizeWarningLevel,  DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FileSizeNoRepLevel,    DT_ULONG      )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, CnfUsnJournalID,       DT_X8            )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare2Ull,             DT_LONGLONG_SPARE)},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare1Guid,            DT_GUID_SPARE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare2Guid,            DT_GUID_SPARE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare1Wcs,             DT_UNICODE_SPARE )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare2Wcs,             DT_UNICODE_SPARE )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare1Bin,             DT_BINARY_SPARE  )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, Spare2Bin,             DT_BINARY_SPARE  )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, MachineName,           DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, MachineGuid,           DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, MachineDnsName,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, TableVersionNumbers,   DT_BINARY     )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSDatabasePath,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FSBackupDatabasePath,  DT_UNICODE    )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaNetBiosName,    DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaPrincName,      DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaCoDn,           DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaCoGuid,         DT_GUID       )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaWorkingPath,    DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, ReplicaVersion,        DT_UNICODE    )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FrsDbMajor,            DT_ULONG      )},
    {RECORD_FIELD(CONFIG_TABLE_RECORD, FrsDbMinor,            DT_ULONG      )},

    {RECORD_FIELD(CONFIG_TABLE_RECORD, JetParameters,         DT_BINARY     )}

};


JET_SETCOLUMN ConfigTableJetSetCol[CONFIG_TABLE_MAX_COL];
JET_RETRIEVECOLUMN ConfigTableJetRetCol[CONFIG_TABLE_MAX_COL];


//
// The ConfigTable index descriptions are as follows.  Note - the order of the
// enum in schema.h and the table entries must be kept in sync.
//
// If the first character of the Index Name is a digit then this index is
// composed of n keys.  The following n characters tell us how to compute
// the keylength for each component.  E.G. a 2 key index on a Guid and a
// Long binary would have a name prefix of "2GL...".
// If the first character is not a digit then this is a single key index
// and the first character is the key length code as follows:
//
//  L: Long binary     length is 4 bytes
//  Q: Quad binary     length is 8 bytes
//  G: 16 byte GUID    length is 16 bytes
//  W: Wide Char       length is 2 * _wcslen
//  C: Narrow Char     length is _strlen
//
//            Name                           Key              KeyLen  JIndexGrBits Density
//
JET_INDEXCREATE ConfigTableIndexDesc[] = {
{CBJIC, "LReplicaNumberIndex",    "+ReplicaNumber\0"    ,16, JET_bitIndexUnique |
                                                             JET_bitIndexPrimary, 80},
{CBJIC, "GReplicaMemberGuidIndex","+ReplicaMemberGuid\0",20, JET_bitIndexUnique, 80},
{CBJIC, "WReplicaSetNameIndex",   "+ReplicaSetName\0"   ,17,         0         , 80}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
//


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                     S e r v i c e    T a b l e                            **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// There is only one Service table in the database.  It has a single record
// with service specific params that apply to all replica sets.
// The ServiceTable column descriptions are as follows.  Note - the order of the
// enum in schema.h and the table entries must be kept in sync.
//
// Note: Buffers are allocated at runtime to hold data for fields with
// a ColMaxWidth greater than 4 bytes where the field def in the corresponding
// record struct is 4 bytes (i.e. it holds a pointer).  For fields where the
// ColMaxWidth equals the field size in the record struct the data is in the
// record struct and no buffer is allocated.

//
//           Name                   ColType       ColMaxWidth    GrBits    pvDefault cbDefault
//

// **** Make sure any escrowed columns have an initial value.

JET_COLUMNCREATE ServiceTableColDesc[]=
{
    {CBJCC, "FrsDbMajor",          JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FrsDbMinor",          JET_coltypLong      ,   4, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MachineName",         JET_coltypText      ,   2*(MAX_RDN_VALUE_SIZE+1),
                                                                      0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "MachineGuid",         JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "MachineDnsName",      JET_coltypLongText  ,   2*(DNS_MAX_NAME_LENGTH+1),
                                                                      0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "TableVersionNumbers", JET_coltypBinary    ,  SIZEOF(CONFIG_TABLE_RECORD, TableVersionNumbers),
                                                              JET_bitColumnFixed, NULL, 0},
    {CBJCC, "FSDatabasePath",      JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                      0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "FSBackupDatabasePath",JET_coltypLongText  ,   2*(MAX_PATH+1),
                                                                      0         , NULL, 0, CP_UNICODE_FOR_JET},

    {CBJCC, "ReplicaNetBiosName",  JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaPrincName",    JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCoDn",         JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaCoGuid",       JET_coltypBinary    ,  16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "ReplicaWorkingPath",  JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "ReplicaVersion",      JET_coltypLongText  , MB2,         0         , NULL, 0, CP_UNICODE_FOR_JET},


    {CBJCC, "Spare1Ull",           JET_coltypCurrency,     8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Ull",           JET_coltypCurrency,     8, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Guid",          JET_coltypBinary,      16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare2Guid",          JET_coltypBinary,      16, JET_bitColumnFixed, NULL, 0},
    {CBJCC, "Spare1Wcs",           JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare2Wcs",           JET_coltypLongText,   MB2,         0     , NULL, 0, CP_UNICODE_FOR_JET},
    {CBJCC, "Spare1Bin",           JET_coltypLongBinary, MB2,         0     , NULL, 0},
    {CBJCC, "Spare2Bin",           JET_coltypLongBinary, MB2,         0     , NULL, 0},

    {CBJCC, "JetParameters",       JET_coltypLongBinary,  sizeof(JET_SYSTEM_PARAMS),
                                                                          0         , NULL, 0}
};

//
// The following is used to build the Jet Set Column struct for record read/write.
// The first 2 params build the field offset and size.  The 3rd param is the
// data type.
//
//
// *** WARNING ***
//
// If the record structure field size is less than the max column width AND
// is big enough to hold a pointer AND has a datatype of DT_BINARY then the
// record is assumed to be variable length.  The record insert code
// automatically adjusts the length from the record's Size prefix.  All
// DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
// fields that are variable length which don't have a size prefix like
// FSVolInfo in the config record.  But these fields MUST have a unique / non
// binary data type assigned to them.  Failure to do this causes the insert
// routines to stuff things up to ColMaxWidth bytes into the database.
//

RECORD_FIELDS ServiceTableRecordFields[] = {
    {sizeof(SERVICE_TABLE_RECORD)     , 0,              SERVICE_TABLE_MAX_COL },

    {RECORD_FIELD(SERVICE_TABLE_RECORD, FrsDbMajor,            DT_ULONG      )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, FrsDbMinor,            DT_ULONG      )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, MachineName,           DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, MachineGuid,           DT_GUID       )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, MachineDnsName,        DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, TableVersionNumbers,   DT_BINARY     )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, FSDatabasePath,        DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, FSBackupDatabasePath,  DT_UNICODE    )},

    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaNetBiosName,    DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaPrincName,      DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaCoDn,           DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaCoGuid,         DT_GUID       )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaWorkingPath,    DT_UNICODE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, ReplicaVersion,        DT_UNICODE    )},

    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare1Ull,             DT_LONGLONG_SPARE)},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare2Ull,             DT_LONGLONG_SPARE)},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare1Guid,            DT_GUID_SPARE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare2Guid,            DT_GUID_SPARE    )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare1Wcs,             DT_UNICODE_SPARE )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare2Wcs,             DT_UNICODE_SPARE )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare1Bin,             DT_BINARY_SPARE  )},
    {RECORD_FIELD(SERVICE_TABLE_RECORD, Spare2Bin,             DT_BINARY_SPARE  )},

    {RECORD_FIELD(SERVICE_TABLE_RECORD, JetParameters,         DT_BINARY     )}
};

JET_SETCOLUMN      ServiceTableJetSetCol[SERVICE_TABLE_MAX_COL];
JET_RETRIEVECOLUMN ServiceTableJetRetCol[SERVICE_TABLE_MAX_COL];


//
// The Service Table index descriptions are as follows.  Note - the order of the
// enum and the table entries must be kept in sync.
//

//
// See the comment under the config table index description for the meaning
// and usage of the first character in the index name field.
//
//               Name               Key         KeyLen    JIndexGrBits     Density
//
JET_INDEXCREATE ServiceTableIndexDesc[] = {
    {CBJIC, "LFrsDbMajor", "+FrsDbMajor\0", 13,      JET_bitIndexPrimary,  80}
};
// Note - Key must have a double null at the end.  KeyLen includes this extra null.
// The key designated as the primary index can't be changed.  A Jet rule.
// So on a directory restore all the directory file IDs can change and
// the records have to be deleted and the table reconstructed.
//



//
//  The TableVersionNumbers array as saved in the init record when new tables
//  are created.  This is used to detect a mismatch between a database and
//  the version of FRS running.
//
ULONG TableVersionNumbers[FRS_MAX_TABLE_TYPES]=
{
    VersionCount,
    VersionINLOGTable,
    VersionOUTLOGTable,
    VersionIDTable,
    VersionDIRTable,
    VersionVVTable,
    VersionCXTIONTable,
    VersionConfigTable,
    VersionServiceTable,
    0, 0, 0,  0, 0, 0, 0
};


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **    T A B L E   C R E A T E  &  P R O P E R T Y   D E F I N I T I O N S    **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The list of Jet Tables created for each replica set are as follows.
// Note - the order of the enum in schema.h and the table entries and the
//        table property entries must be kept in sync.
//

#define CBJTC sizeof(JET_TABLECREATE)

#define INIT_INBOUND_LOG_TABLE_PAGES 50
#define INIT_INBOUND_LOG_TABLE_DENSITY  90

#define INIT_OUTBOUND_LOG_TABLE_PAGES 50
#define INIT_OUTBOUND_LOG_TABLE_DENSITY  90

#define INIT_IDTABLE_PAGES 50
#define INIT_IDTABLE_DENSITY  60

#define INIT_DIRTABLE_PAGES 10
#define INIT_DIRTABLE_DENSITY  80

#define INIT_VVTABLE_PAGES 1
#define INIT_VVTABLE_DENSITY  80

#define INIT_CXTIONTABLE_PAGES 2
#define INIT_CXTIONTABLE_DENSITY  90

#define INIT_CONFIG_PAGES 10
#define INIT_CONFIG_DENSITY  90

#define INIT_SERVICE_PAGES 4
#define INIT_SERVICE_DENSITY  90


typedef struct ___tagJET_TABLECREATE   // from Jet header for ref only.
    {
    ULONG       cbStruct;              // size of this structure
    CHAR       *szTableName;           // name of table to create.
    CHAR       *szTemplateTableName;   // name of table from which to inherit base DDL
    ULONG       ulPages;               // initial pages to allocate for table.
    ULONG       ulDensity;             // table density.
    JET_COLUMNCREATE  *rgcolumncreate; // array of column creation info
    ULONG       cColumns;              // number of columns to create
    JET_INDEXCREATE   *rgindexcreate;  // array of index creation info
    ULONG       cIndexes;              // number of indexes to create
    JET_GRBIT   grbit;                 // JET_bitTableCreateTemplateTable when creating template
                                       // JET_bitTableCreateFixedDDL when creating derived table.
    JET_TABLEID tableid;               // returned tableid.
    ULONG       cCreated;              // count of objects created (columns+table+indexes).
} ___JET_TABLECREATE;



JET_TABLECREATE DBTables[] = {

    {CBJTC, "INLOGTable", NULL, INIT_INBOUND_LOG_TABLE_PAGES, INIT_INBOUND_LOG_TABLE_DENSITY,
    ILChangeOrderTableColDesc, CHANGE_ORDER_MAX_COL, ILChangeOrderIndexDesc, ILCHANGE_ORDER_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    {CBJTC, "OUTLOGTable", NULL, INIT_OUTBOUND_LOG_TABLE_PAGES, INIT_OUTBOUND_LOG_TABLE_DENSITY,
    OLChangeOrderTableColDesc, CHANGE_ORDER_MAX_COL, OLChangeOrderIndexDesc, OLCHANGE_ORDER_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    {CBJTC, "IDTable", NULL, INIT_IDTABLE_PAGES, INIT_IDTABLE_DENSITY,
    IDTableColDesc, IDTABLE_MAX_COL, IDTableIndexDesc, IDTABLE_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    {CBJTC, "DIRTable", NULL, INIT_DIRTABLE_PAGES, INIT_DIRTABLE_DENSITY,
    DIRTableColDesc, DIRTABLE_MAX_COL, DIRTableIndexDesc, DIRTABLE_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    {CBJTC, "VVTable", NULL, INIT_VVTABLE_PAGES, INIT_VVTABLE_DENSITY,
    VVTableColDesc, VVTABLE_MAX_COL, VVTableIndexDesc, VVTABLE_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    {CBJTC, "CXTIONTable", NULL, INIT_CXTIONTABLE_PAGES, INIT_CXTIONTABLE_DENSITY,
    CXTIONTableColDesc, CXTION_TABLE_MAX_COL, CXTIONTableIndexDesc, CXTION_TABLE_MAX_INDEX,
    JET_bitTableCreateTemplateTable},

    //
    // set rgcolumncreate to ConfigTableColDesc so init is simpler.
    //
    {CBJTC, "Unused", NULL, 0, 0, ConfigTableColDesc, 0, NULL, 0, 0},

    {CBJTC, "ConfigTable", NULL, INIT_CONFIG_PAGES, INIT_CONFIG_DENSITY,
    ConfigTableColDesc, CONFIG_TABLE_MAX_COL,
    ConfigTableIndexDesc, CONFIG_TABLE_MAX_INDEX,
    JET_bitTableCreateFixedDDL},

    {CBJTC, "ServiceTable", NULL, INIT_SERVICE_PAGES, INIT_SERVICE_DENSITY,
    ServiceTableColDesc, SERVICE_TABLE_MAX_COL,
    ServiceTableIndexDesc, SERVICE_TABLE_MAX_INDEX,
    JET_bitTableCreateFixedDDL}

};

//
// The following describes some properties of each defined table in the schema.
// This is used mainly for initialization.
//
// Name           RecordFields       Flags

FRS_TABLE_PROPERTIES FrsTableProperties[] = {
    {"INLOGTable",    ILChangeOrderRecordFields, FRS_TPF_NONE  },
    {"OUTLOGTable",   OLChangeOrderRecordFields, FRS_TPF_NONE  },
    {"IDTable",       IDTableRecordFields      , FRS_TPF_NONE  },
    {"DIRTable",      DIRTableRecordFields     , FRS_TPF_NONE  },
    {"VVTable",       VVTableRecordFields      , FRS_TPF_NONE  },
    {"CXTIONTable",   CXTIONTableRecordFields  , FRS_TPF_NONE  },
    {"Unused",        NULL                     , 0             },  // Gap between single instance tables.
    {"ConfigTable",   ConfigTableRecordFields  , FRS_TPF_SINGLE},
    {"ServiceTable",  ServiceTableRecordFields , FRS_TPF_SINGLE}
};




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **        J E T   S Y S T E M   P A R A M E T E R S   T A B L E              **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// Definition of the Jet system parameters stored in config record.
// If you add or delete a parameter adjust MAX_JET_SYSTEM_PARAMS accordingly.
//
JET_SYSTEM_PARAMS JetSystemParamsDef = {
    sizeof(JET_SYSTEM_PARAMS)       ,
    {
        {"SystemPath            ", JET_paramSystemPath            , JPARAM_TYPE_STRING, OFFSET(JET_SYSTEM_PARAMS, ChkPointFilePath) },
        {"TempPath              ", JET_paramTempPath              , JPARAM_TYPE_STRING, OFFSET(JET_SYSTEM_PARAMS, TempFilePath) },
        {"LogFilePath           ", JET_paramLogFilePath           , JPARAM_TYPE_STRING, OFFSET(JET_SYSTEM_PARAMS, LogFilePath) },
        {"BaseName              ", JET_paramBaseName              , JPARAM_TYPE_SKIP, 0 },
        {"EventSource           ", JET_paramEventSource           , JPARAM_TYPE_STRING, OFFSET(JET_SYSTEM_PARAMS, EventSource) },
        {"MaxSessions           ", JET_paramMaxSessions           , JPARAM_TYPE_LONG, 200 },
        {"MaxOpenTables         ", JET_paramMaxOpenTables         , JPARAM_TYPE_SKIP, 0 },
        {"PreferredMaxOpenTables", JET_paramPreferredMaxOpenTables, JPARAM_TYPE_SKIP, 0 },
        {"MaxCursors            ", JET_paramMaxCursors            , JPARAM_TYPE_SKIP, 0 },
        {"MaxVerPages           ", JET_paramMaxVerPages           , JPARAM_TYPE_SKIP, 0 },

        {"MaxTemporaryTables    ", JET_paramMaxTemporaryTables    , JPARAM_TYPE_SKIP, 0 },
        {"LogFileSize           ", JET_paramLogFileSize           , JPARAM_TYPE_SKIP, 0 },
        {"LogBuffers            ", JET_paramLogBuffers            , JPARAM_TYPE_SKIP, 0 },
        {"WaitLogFlush          ", JET_paramWaitLogFlush          , JPARAM_TYPE_SKIP, 0 },
        {"LogCheckpointPeriod   ", JET_paramLogCheckpointPeriod   , JPARAM_TYPE_SKIP, 0 },
        {"LogWaitingUserMax     ", JET_paramLogWaitingUserMax     , JPARAM_TYPE_SKIP, 0 },
        {"CommitDefault         ", JET_paramCommitDefault         , JPARAM_TYPE_SKIP, 0 },
        {"CircularLog           ", JET_paramCircularLog           , JPARAM_TYPE_SKIP, 0 },
        {"DbExtensionSize       ", JET_paramDbExtensionSize       , JPARAM_TYPE_SKIP, 0 },
        {"PageTempDBMin         ", JET_paramPageTempDBMin         , JPARAM_TYPE_SKIP, 0 },

        {"PageFragment          ", JET_paramPageFragment          , JPARAM_TYPE_SKIP, 0 },
        {"PageReadAheadMax      ", JET_paramPageReadAheadMax      , JPARAM_TYPE_SKIP, 0 },
        {"BatchIOBufferMax      ", JET_paramBatchIOBufferMax      , JPARAM_TYPE_SKIP, 0 },
        {"CacheSize             ", JET_paramCacheSize             , JPARAM_TYPE_SKIP, 0 },
        {"CacheSizeMax          ", JET_paramCacheSizeMax          , JPARAM_TYPE_SKIP, 0 },
        {"CheckpointDepthMax    ", JET_paramCheckpointDepthMax    , JPARAM_TYPE_SKIP, 0 },
        {"LRUKCorrInterval      ", JET_paramLRUKCorrInterval      , JPARAM_TYPE_SKIP, 0 },
        {"LRUKHistoryMax        ", JET_paramLRUKHistoryMax        , JPARAM_TYPE_SKIP, 0 },
        {"LRUKPolicy            ", JET_paramLRUKPolicy            , JPARAM_TYPE_SKIP, 0 },
        {"LRUKTimeout           ", JET_paramLRUKTimeout           , JPARAM_TYPE_SKIP, 0 },

        {"LRUKTrxCorrInterval   ", JET_paramLRUKTrxCorrInterval   , JPARAM_TYPE_SKIP, 0 },
        {"OutstandingIOMax      ", JET_paramOutstandingIOMax      , JPARAM_TYPE_SKIP, 0 },
        {"StartFlushThreshold   ", JET_paramStartFlushThreshold   , JPARAM_TYPE_SKIP, 0 },
        {"StopFlushThreshold    ", JET_paramStopFlushThreshold    , JPARAM_TYPE_SKIP, 0 },
        {"TableClassName        ", JET_paramTableClassName        , JPARAM_TYPE_SKIP, 0 },
        {"ExceptionAction       ", JET_paramExceptionAction       , JPARAM_TYPE_SKIP, 0 },
        {"EventLogCache         ", JET_paramEventLogCache         , JPARAM_TYPE_SKIP, 0 },
        {"end                   ",            0                   , JPARAM_TYPE_LAST, 0 },
    },

    "",    // CHAR ChkPointFilePath[MAX_PATH];
    "",    // CHAR TempFilePath[MAX_PATH];
    "",    // CHAR LogFilePath[MAX_PATH];
    "FileReplSvc "              // CHAR EventSource[20];
};


#if 0
//
// The Jet97 aka Jet500 system parameters and defaults are shown below
// for reference only.  See the Jet header file for the latest info.
//
JET_paramSystemPath              // path to check point file [".\\"]
JET_paramTempPath                // path to the temporary database [".\\"]
JET_paramLogFilePath             // path to the log file directory [".\\"]
JET_paramBaseName                // base name for all DBMS object names ["edb"]
JET_paramEventSource             // language independant process descriptor string [""]
//
//  performance parameters
//
JET_paramMaxSessions             // maximum number of sessions [128]
JET_paramMaxOpenTables           // maximum number of open directories [300]
                                 //  need 1 for each open table index,
                                 //  plus 1 for each open table with no indexes,
                                 //  plus 1 for each table with long column data,
                                 //  plus a few more.

                                 // for 4.1, 1/3 for regular table, 2/3 for index
JET_paramPreferredMaxOpenTables  // preferred maximum number of open directories [300]
JET_paramMaxCursors              // maximum number of open cursors [1024]
JET_paramMaxVerPages             // maximum version store size in 16kByte units [64]
JET_paramMaxTemporaryTables      // maximum concurrent open temporary
                                 // table/index creation [20]
JET_paramLogFileSize             // log file size in kBytes [5120]
JET_paramLogBuffers              // log buffers in 512 bytes [21]
JET_paramWaitLogFlush            // log flush wait time in milliseconds [0]
JET_paramLogCheckpointPeriod     // checkpoint period in 512 bytes [1024]
JET_paramLogWaitingUserMax       // maximum sessions waiting log flush [3]
JET_paramCommitDefault           // default grbit for JetCommitTransaction [0]
JET_paramCircularLog             // boolean flag for circular logging [0]
JET_paramDbExtensionSize         // database extension size in pages [16]
JET_paramPageTempDBMin           // minimum size temporary database in pages [0]
JET_paramPageFragment            // maximum disk extent considered fragment in pages [8]
JET_paramPageReadAheadMax        // maximum read-ahead in pages [20]
//
//  cache performance parameters
//
JET_paramBatchIOBufferMax        // maximum batch I/O buffers in pages [64]
JET_paramCacheSize               // current cache size in pages [512]
JET_paramCacheSizeMax            // maximum cache size in pages [512]
JET_paramCheckpointDepthMax      // maximum checkpoint depth in bytes [10MB]
JET_paramLRUKCorrInterval        // time (usec) under which page accesses are
                                 // correlated [10000]
JET_paramLRUKHistoryMax          // maximum LRUK history records [1024]
                                 // (proportional to cache size max)
JET_paramLRUKPolicy              // K-ness of LRUK page eviction algorithm (1...2) [2]
JET_paramLRUKTimeout             // time (sec) after which cached pages are
                                 // always evictable [100]
JET_paramLRUKTrxCorrInterval     // time (usec) under which page accesses by the
                                 // same transaction are correlated [5000000]
JET_paramOutstandingIOMax        // maximum outstanding I/Os [64]
JET_paramStartFlushThreshold     // evictable pages at which to start a flush
                                 // [100] (proportional to CacheSizeMax)
JET_paramStopFlushThreshold      // evictable pages at which to stop a flush
                                 // [400] (proportional to CacheSizeMax)
JET_paramTableClassName          // table stats class name (class #, string)

JET_paramExceptionAction         // what to do with exceptions generated within JET
JET_paramEventLogCache           // number of bytes of eventlog records to cache
                                 // if service is not available [0]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repl\journal.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    journal.c

Abstract:

    This module contains routines to process the NTFS Volume Journal for the
    File Replication service.  It uses a single thread with an I/O completion
    port to post reads to all volume journals we need to monitor.

    As USN buffers are filled they a queued to a JournalProcessQueue for
    further processing. The Journal Read Thread gets a free buffer from
    the free list and posts another read to the volume journal.

    A thread pool processes the USN buffers from the JournalprocessQueue.

Author:

    David A. Orbits (davidor)  6-Apr-1997

Environment:

    User Mode Service

Revision History:

//      JOURNAL RECORD FORMAT
//
//  The initial Major.Minor version of the Usn record will be 1.0.
//  In general, the MinorVersion may be changed if fields are added
//  to this structure in such a way that the previous version of the
//  software can still correctly the fields it knows about.  The
//  MajorVersion should only be changed if the previous version of
//  any software using this structure would incorrectly handle new
//  records due to structure changes.
//
//  see \nt\public\sdk\inc\ntioapi.h for the USN_RECORD declaration.
//

#define USN_REASON_DATA_OVERWRITE        (0x00000001)
#define USN_REASON_DATA_EXTEND           (0x00000002)
#define USN_REASON_DATA_TRUNCATION       (0x00000004)

#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND     (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)

#define USN_REASON_FILE_CREATE           (0x00000100)
#define USN_REASON_FILE_DELETE           (0x00000200)
#define USN_REASON_EA_CHANGE             (0x00000400)
#define USN_REASON_SECURITY_CHANGE       (0x00000800)

#define USN_REASON_RENAME_OLD_NAME       (0x00001000)  // rename
#define USN_REASON_RENAME_NEW_NAME       (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE      (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE     (0x00008000)

#define USN_REASON_HARD_LINK_CHANGE      (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE    (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE     (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE      (0x00080000)

#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE         (0x00200000)  // named streame cre, del or ren.

#define USN_REASON_CLOSE                 (0x80000000)

--*/


#define UNICODE 1
#define _UNICODE 1



#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "journal:"
#include <frs.h>
#include <genhash.h>
#include <tablefcn.h>
#include <eventlog.h>
#include <perrepsr.h>

#pragma warning( disable:4102)  // unreferenced label

//
// The default for Journal Max Size now comes from the registry.
#define JRNL_DEFAULT_ALLOC_DELTA      (1*1024*1024)
#define JRNL_USN_SAVE_POINT_INTERVAL      (16*1024)

#define JRNL_CLEAN_WRITE_FILTER_INTERVAL  (60*1000)   /* once a minute */

#define NumberOfJounalBuffers 3

#define FRS_CANCEL_JOURNAL_READ 0xFFFFFFFF
#define FRS_PAUSE_JOURNAL_READ  0xFFFFFFF0


//
// Every 'VSN_SAVE_INTERVAL' VSNs that are handed out, save the state in the
// config record.  On restart we take the largest value and add
// 2*(VSN_SAVE_INTERVAL+1) to it so if a crash occurred we ensure that it
// never goes backwards.
//
// A Vsn value of 0 means there is no Vsn. This convention is required
// by FrsPendingInVVector().
//
// MUST BE Power of 2.
#define VSN_SAVE_INTERVAL 0xFF
#define VSN_RESTART_INCREMENT  (2*(VSN_SAVE_INTERVAL+1))


//
// Deactivate the Volume Monitor Entry by setting IoActive False, pulling
// it off the _Queue and queueing it to the VolumeMonitorStopQueue.
// Also store an error status.  This code assumes you have already ACQUIRED
// THE LOCK ON the VolumeMonitorQueue.
//
#define VmeDeactivate(_Queue, _pVme, _WStatus)                          \
    FrsRtlRemoveEntryQueueLock(_Queue, &_pVme->ListEntry);              \
    _pVme->IoActive = FALSE;                                            \
    _pVme->WStatus = _WStatus;                                          \
    /*_pVme->ActiveReplicas -= 1;    */                                 \
    DPRINT2(4, "++ vmedeactivate -- onto stop queue %ws (%08x)\n",     \
            _pVme->FSVolInfo.VolumeLabel, _pVme);                       \
    FrsRtlInsertTailQueue(&VolumeMonitorStopQueue, &_pVme->ListEntry);  \
    ReleaseVmeRef(_pVme);


//
// The Journal free buffer queue holds the free buffers for journal reads.
//
FRS_QUEUE JournalFreeQueue;

//
// The Journal process queue holds the list of journal buffers with
// data to process.
//
FRS_QUEUE JournalProcessQueue;

//
// The Journal I/O completion port.  We keep a read outstanding on each
// NTFS volume monitored.
//
HANDLE JournalCompletionPort;

//
// The handle to the Journal read thread.
//
HANDLE JournalReadThreadHandle = NULL;

//
// Set this flag to stop any further issuing of journal reads.
//
volatile BOOL KillJournalThreads = FALSE;

//
// This is the volume monitor queue.  The Journal read thread waits until
// this queue goes non-empty before it waits on the completion port.  This
// way it knows the completion port exists without having to poll.
//
FRS_QUEUE VolumeMonitorQueue;

//
// When I/O is Stoped on a given journal the Journal read thread places
// the volume monitor entry on the Stop queue.
//
FRS_QUEUE VolumeMonitorStopQueue;

//
// This is the control queue for all the volume monitor entry change order
// queues.
//
FRS_QUEUE FrsVolumeLayerCOList;
FRS_QUEUE FrsVolumeLayerCOQueue;

//
// This is the expected version number from the USN journal.
//
USHORT ConfigUsnMajorVersion = 2;

//
// This is the count of outstanding journal read requests.
//
ULONG JournalActiveIoRequests = 0;

//
// Change order delay in aging cache.  (milliseconds)
//
ULONG ChangeOrderAgingDelay;


//
// This lock is held by JrnlSetReplicaState() when moving a replica
// between lists.
//
CRITICAL_SECTION JrnlReplicaStateLock;

//
// Lock to protect the child lists in the Filter Table.  (must be pwr of 2)
// Instead of paying the overhead of having one per node we just use an array
// to help reduce contention.  We use the ReplicaNumber masked by the lock
// table size as the index.
//
// Acquire the lock on the ReplicaSet Filter table Child List before
// inserting or removing a child from the list.
//
CRITICAL_SECTION JrnlFilterTableChildLock[NUMBER_FILTER_TABLE_CHILD_LOCKS];

//
// The list of all Replica Structs active, stopped and faulted.
//
extern FRS_QUEUE ReplicaListHead;
extern FRS_QUEUE ReplicaStoppedListHead;
extern FRS_QUEUE ReplicaFaultListHead;

//
//  This is used to init our new value for FrsVsn.
//
extern ULONGLONG MaxPartnerClockSkew;

//
// Global sequence number.  Inited here with first Vme VSN.
//
extern CRITICAL_SECTION GlobSeqNumLock;
extern ULONGLONG GlobSeqNum;

//
// The table below describes what list the Replica struct should be on for
// a given state as well as the state name.
//
REPLICA_SERVICE_STATE ReplicaServiceState[] = {
    {NULL,                    "ALLOCATED"},
    {&ReplicaListHead,        "INITIALIZING"},
    {&ReplicaListHead,        "STARTING"},
    {&ReplicaListHead,        "ACTIVE"},
    {&ReplicaListHead,        "PAUSE1"},
    {&ReplicaListHead,        "PAUSING (2)"},
    {&ReplicaListHead,        "PAUSED"},
    {&ReplicaListHead,        "STOPPING"},
    {&ReplicaStoppedListHead, "STOPPED"},
    {&ReplicaFaultListHead,   "ERROR"},
    {&ReplicaFaultListHead,   "JRNL_WRAP_ERROR"},
    {NULL,                    "REPLICA_DELETED"},
    {&ReplicaFaultListHead,   "MISMATCHED_VOLUME_SERIAL_NO"},
    {&ReplicaFaultListHead,   "MISMATCHED_REPLICA_ROOT_OBJECT_ID"},
    {&ReplicaFaultListHead,   "MISMATCHED_REPLICA_ROOT_FILE_ID"},
    {&ReplicaFaultListHead,   "MISMATCHED_JOURNAL_ID"}
};


//
// The following struct is used to encapsulate the context of a change
// order request so it can be passed as a context parameter in an
// enumerated call.
//
typedef struct _CHANGE_ORDER_PARAMETERS_ {

    PREPLICA    OriginalReplica; // Original Replica Set
    PREPLICA    NewReplica;      // The New Replica set in the case of a rename.

    ULONGLONG   NewParentFid;    // The new parent FID in case of a rename.
    ULONG       NewLocationCmd;  // MovDir, MovRs, ...

    PUSN_RECORD UsnRecord;       // Usn Record that triggered the change order
                                 // creation (i.e. the operation on the root of the subtree).

    PFILTER_TABLE_ENTRY OrigParentFilterEntry; // Original parent filter entry of root filter entry
    PFILTER_TABLE_ENTRY NewParentFilterEntry;  // Current/New parent filter entry of root filter entry

} CHANGE_ORDER_PARAMETERS, *PCHANGE_ORDER_PARAMETERS;


typedef struct _OP_FIELDS_ {
        unsigned Op1 : 4;
        unsigned Op2 : 4;
        unsigned Op3 : 4;
        unsigned Op4 : 4;
        unsigned Op5 : 4;
        unsigned Op6 : 4;
        unsigned Op7 : 4;
        unsigned Op8 : 4;
} OP_FIELDS, *POP_FIELDS;


typedef struct _CO_LOCATION_CONTROL_CMD_ {
    union {
        OP_FIELDS  OpFields;
        ULONG      UlongOpFields;
        } u1;
} CO_LOCATION_CONTROL_CMD;

#define OpInval 0       // Invalid op (only check for Op1, else done).
#define OpEvap  1       // Evaporate the change order
#define OpNRs   2       // update New Replica Set and New Directory.
#define OpNDir  3       // Update New Directory
#define OpNSt   4       // Update New State stored in next nibble.

#define NSCre     CO_LOCATION_CREATE    // Create a File or Dir (New FID Generated)
#define NSDel     CO_LOCATION_DELETE    // Delete a file or Dir (FID retired)
#define NSMovIn   CO_LOCATION_MOVEIN    // Rename into a R.S.
#define NSMovIn2  CO_LOCATION_MOVEIN2   // Rename into a R.S. from a prev MOVEOUT
#define NSMovOut  CO_LOCATION_MOVEOUT   // Rename out of any R.S.
#define NSMovRs   CO_LOCATION_MOVERS    // Rename from one R.S. to another R.S.
#define NSMovDir  CO_LOCATION_MOVEDIR   // Rename from one dir to another (Same R.S.)
#define NSMax     CO_LOCATION_NUM_CMD   // No prior Location cmd.  Prior change
                                        // Order had a content cmd.
#define NSNoLocationCmd  CO_LOCATION_NO_CMD

PCHAR CoLocationNames[]= {"Create" , "Delete", "Movein" , "Movein2",
                          "Moveout", "Movers", "MoveDir", "NoCmd"};

//
// The following dispatch table specifies what operations are performed when
// a second change arrives for a given FID and a prior change order is still
// pending.  The states correspond to the change order location command that
// is to be executed by the update process.  Each entry in the dispatch table
// is a ULONG composed of up to 8 operation nibbles which are executed in a loop.
// The operations could evaporate the change order (e.g. a create followed by
// a delete.  The create was pending and the delete came in so just blow off
// the change order.  The operation could update the parent directory or the
// replica set the directory lives in, or the location command (and thus the
// state) that is to be performed.  The MovIn2 state is not a unique input,
// rather it is a special state that lets us remember there was a prior MovOut
// done so if the MovIn2 is followed by a Del or a MovOut we know there is still
// work to be done in the database so we can't evaporate the change order.
// See note (a) below.
//


CO_LOCATION_CONTROL_CMD ChangeOrderLocationStateTable[NSMax+1][NSMax] = {

//                           Followed by Second Op On Same Fid
//
//      Cre     Del         MovIn MovIn2  MovOut             MovRs                MovDir

// First
// Op On
// Fid

//Cre
        {{0},  {OpEvap},      {0},  {0},  {OpEvap },        {OpNRs},               {OpNDir}},

//Del
        {{0},  {0},           {0},  {0},  {0},              {0},                   {0}},

//MovIn
        {{0},  {OpEvap},      {0},  {0},  {OpEvap },        {OpNRs},               {OpNDir}},

//MovIn2(a)
        {{0},  {OpNSt,NSDel}, {0},  {0},  {OpNSt,NSMovOut}, {OpNRs},               {OpNDir}},

//MovOut
        {{0},  {0},           {OpNRs,OpNSt,NSMovIn2},
                                   {0},  {0},              {0},                   {0}},

//MovRs
        {{0},  {OpNSt,NSDel}, {0},  {0},  {OpNSt,NSMovOut}, {OpNRs},               {OpNDir}},

//MovDir
        {{0},  {OpNSt,NSDel}, {0},  {0},  {OpNSt,NSMovOut}, {OpNRs,OpNSt,NSMovRs}, {OpNDir}},
//<NONE>
        {{OpNRs, OpNSt,NSCre},
              {OpNSt,NSDel}, {OpNRs,OpNSt,NSMovIn},
                                   {0},  {OpNSt,NSMovOut}, {OpNRs,OpNSt,NSMovRs}, {OpNDir,OpNSt,NSMovDir}}

    };

//  (a) The MovIn2 state is artificially introduced to deal with the sequence
//  of MovOut followed by a MovIn.  There are two problems here.  One is that
//  many changes could have happened to the file or dir while it was outside
//  the R.S. since we were not monitoring it.  Consequently the update process
//  must do a complete evaluation of the the file/dir properties so we don't
//  fail to replicate some change.  The second problem is that in the normal
//  case a MovIn followed by either a delete or a MovOut results in evaporating
//  the change order.  However if a MovOut has occurred in the past followed
//  by a MovIn we cannot assume that the file or Dir was never in the R.S.
//  to begin with. Consider the sequence of MovOut, MovIn, Del.  Without the
//  MovIn2 state the MovIn followed by Del would result in evaporating the
//  change order so the file or dir would be still left in the database.
//  By transitioning to the MovIn2 state we go to the Del state when we see
//  the Delete so we can remove the entry from the database.  Similarly once
//  in the MovIn2 state if we see a MovOut then we go to the MovOut state
//  rather than evaporating the change order since we still have to update
//  the database with the MovOut.
//
//  Note: think about a similar problem where the file filter string changes
//       and a file is touched so a create CO is generated.  If the file is
//       then deleted the CO is evaporated.  This means that a del CO will
//       not be propagated so the file is deleted everywhere.  Do we need
//       a Cre2 CO analogous to the MovIn2 state?

typedef
ULONG
(NTAPI *PJRNL_FILTER_ENUM_ROUTINE) (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

LONG
JrnlGetFileCoLocationCmd(
    PVOLUME_MONITOR_ENTRY pVme,
    IN PUSN_RECORD UsnRecord,
    OUT PFILTER_TABLE_ENTRY  *PrevParentFilterEntry,
    OUT PFILTER_TABLE_ENTRY  *CurrParentFilterEntry
);

ULONG
JrnlEnterFileChangeOrder(
    IN PUSN_RECORD UsnRecord,
    IN ULONG LocationCmd,
    IN PFILTER_TABLE_ENTRY  OldParentFilterEntry,
    IN PFILTER_TABLE_ENTRY  NewParentFilterEntry
    );

PCHANGE_ORDER_ENTRY
JrnlCreateCo(
    IN PREPLICA       Replica,
    IN PULONGLONG     Fid,
    IN PULONGLONG     ParentFid,
    IN PUSN_RECORD    UsnRecord,
    IN BOOL           IsDirectory,
    IN PWCHAR         FileName,
    IN USHORT         Length
);

BOOL
JrnlMergeCoTest(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PUNICODE_STRING     UFileName,
    IN PULONGLONG          ParentFid,
    IN ULONG               StreamLastMergeSeqNum
);

VOID
JrnlUpdateNst(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PUNICODE_STRING UFileName,
    IN PULONGLONG      ParentFid,
    IN ULONG           StreamSequenceNumber
);

VOID
JrnlFilterUpdate(
    IN PREPLICA CurrentReplica,
    IN PUSN_RECORD          UsnRecord,
    IN ULONG                LocationCmd,
    IN PFILTER_TABLE_ENTRY  OldParentFilterEntry,
    IN PFILTER_TABLE_ENTRY  NewParentFilterEntry
    );

ULONG
JrnlProcessSubTree(
    IN PFILTER_TABLE_ENTRY  RootFilterEntry,
    IN PCHANGE_ORDER_PARAMETERS Cop
    );

ULONG
JrnlProcessSubTreeEntry(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

ULONG
JrnlUpdateChangeOrder(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA NewReplica,
    IN ULONGLONG NewParentFid,
    IN ULONG NewLocationCmd,
    IN PUSN_RECORD UsnRecord
    );

ULONG
JrnlAddFilterEntryFromUsn(
    IN PREPLICA Replica,
    IN PUSN_RECORD UsnRecord,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry
    );

ULONG
JrnlAddFilterEntry(
    IN PREPLICA Replica,
    IN PFILTER_TABLE_ENTRY FilterEntry,
    OUT PFILTER_TABLE_ENTRY  *RetFilterEntry,
    IN BOOL Replace
    );

ULONG
JrnlDeleteDirFilterEntry(
    IN  PGENERIC_HASH_TABLE FilterTable,
    IN  PULONGLONG DFileID,
    IN  PFILTER_TABLE_ENTRY  ArgFilterEntry
    );

ULONG
JrnlGetPathAndLevel(
    IN  PGENERIC_HASH_TABLE  FilterTable,
    IN  PLONGLONG StartDirFileID,
    OUT PULONG    Level
);

ULONG
JrnlCommand(
    PCOMMAND_PACKET CmdPkt
    );

ULONG
JrnlPrepareService1(
    PREPLICA Replica
    );

ULONG
JrnlPrepareService2(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA Replica
    );

ULONG
JrnlInitOneReplicaSet(
    PCOMMAND_PACKET CmdPkt
    );

ULONG
JrnlCleanOutReplicaSet(
    PREPLICA Replica
    );

JET_ERR
JrnlInsertParentEntry(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
    );

ULONG_PTR
JrnlFilterLinkChild (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

ULONG_PTR
JrnlFilterLinkChildNoError (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

ULONG
JrnlFilterUnlinkChild (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

ULONG_PTR
JrnlFilterGetRoot (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );

ULONG
JrnlSubTreePrint (
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer,
    PVOID Context
    );
#if 0
ULONG
JrnlCheckStartFailures(
    PFRS_QUEUE Queue
    );
#endif

ULONG
JrnlOpen(
    IN PREPLICA Replica,
    OUT PVOLUME_MONITOR_ENTRY *pVme,
    PCONFIG_TABLE_RECORD ConfigRecord
    );

ULONG
JrnlSubmitReadThreadRequest(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN ULONG Request,
    IN ULONG NewState
    );

ULONG
JrnlShutdownSingleReplica(
    IN PREPLICA Replica,
    IN BOOL HaveLock
    );

ULONG
JrnlCloseVme(
    IN PVOLUME_MONITOR_ENTRY pVme
    );

ULONG
JrnlCloseAll(
    VOID
    );

ULONG
JrnlClose(
    IN HANDLE VolumeHandle
    );


DWORD
WINAPI
JournalReadThread(
    IN LPVOID Context
    );

ULONG
JrnlGetEndOfJournal(
    IN PVOLUME_MONITOR_ENTRY pVme,
    OUT USN                  *EndOfJournal
    );

NTSTATUS
FrsIssueJournalAsyncRead(
    IN PJBUFFER Jbuff,
    IN PVOLUME_MONITOR_ENTRY pVme
    );

ULONG
JrnlEnumerateFilterTreeBU(
    PGENERIC_HASH_TABLE Table,
    PFILTER_TABLE_ENTRY FilterEntry,
    PJRNL_FILTER_ENUM_ROUTINE Function,
    PVOID Context
    );

ULONG
JrnlEnumerateFilterTreeTD(
    PGENERIC_HASH_TABLE Table,
    PFILTER_TABLE_ENTRY FilterEntry,
    PJRNL_FILTER_ENUM_ROUTINE Function,
    PVOID Context
    );

VOID
JrnlHashEntryFree(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );

BOOL
JrnlCompareFid(
    PVOID Buf1,
    PVOID Buf2,
    ULONG Length
    );

ULONG
JrnlHashCalcFid (
    PVOID Buf,
    ULONG Length
    );

ULONG
NoHashBuiltin (
    PVOID Buf,
    ULONG Length
    );

BOOL
JrnlCompareGuid(
    PVOID Buf1,
    PVOID Buf2,
    ULONG Length
    );

ULONG
JrnlHashCalcGuid (
    PVOID Buf,
    ULONG Length
    );

ULONG
JrnlHashCalcUsn (
    PVOID Buf,
    ULONG Length
    );

VOID
CalcHashFidAndName(
    IN PUNICODE_STRING Name,
    IN PULONGLONG      Fid,
    OUT PULONGLONG     HashValue
    );

ULONG
JrnlCleanWriteFilter(
    PCOMMAND_PACKET CmdPkt
    );

ULONG
JrnlCleanWriteFilterWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    );

VOID
JrnlSubmitCleanWriteFilter(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN ULONG                TimeOut
    );

#define FRS_JOURNAL_FILTER_PRINT(_Sev_, _Table_, _Buffer_) \
        JrnlFilterPrint(_Sev_, _Table_, _Buffer_)
#define FRS_JOURNAL_FILTER_PRINT_FUNCTION JrnlFilterPrintJacket
VOID
JrnlFilterPrint(
    ULONG PrintSev,
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );

VOID
JrnlFilterPrintJacket(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );

#define FRS_JOURNAL_CHANGE_ORDER_PRINT(_Table_, _Buffer_) \
        JrnlChangeOrderPrint( _Table_, _Buffer_)
#define FRS_JOURNAL_CHANGE_ORDER_PRINT_FUNCTION JrnlChangeOrderPrint
VOID
JrnlChangeOrderPrint(
    PGENERIC_HASH_TABLE Table,
    PVOID Buffer
    );

ULONG
ChgOrdAcceptInitialize(
    VOID
    );

VOID
ChgOrdAcceptShutdown(
    VOID
    );

DWORD
FrsDeleteById(
    IN PWCHAR                  VolumeName,
    IN PWCHAR                  Name,
    IN PVOLUME_MONITOR_ENTRY   pVme,
    IN PVOID                   Id,
    IN DWORD                   IdLen
    );


DWORD
JournalMonitorInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the NTFS Journal monitor routines and starts
    the JournalReadThread.

Arguments:

    None.

Thread Return Value:

    Win32 status


--*/
{
#undef DEBSUB
#define DEBSUB  "JournalMonitorInit:"

    ULONG WStatus;
    ULONG ThreadId;
    JET_ERR jerr;
    ULONG i;

    if (JournalActiveIoRequests != 0) {
        DPRINT1(0, ":S: ERROR - Can't initialize journal with active I/O (%d) in progress.\n",
                JournalActiveIoRequests);
        return ERROR_REQUEST_ABORTED;
    }

    //
    // No completion port yet.
    //
    FRS_CLOSE(JournalCompletionPort);
    JournalCompletionPort = NULL;

    //
    // Read change order aging cache delay.
    //
    CfgRegReadDWord(FKC_CO_AGING_DELAY, NULL, 0, &ChangeOrderAgingDelay);
    ChangeOrderAgingDelay *= 1000;

    //
    // Init the list of volumes we monitor.
    //
    FrsInitializeQueue(&VolumeMonitorQueue, &VolumeMonitorQueue);
    FrsInitializeQueue(&VolumeMonitorStopQueue, &VolumeMonitorStopQueue);

    //
    // Free list for journal buffers.
    //
    FrsInitializeQueue(&JournalFreeQueue, &JournalFreeQueue);

    //
    // Locks for the Filter Table Child Lists.
    //
    for (i=0; i<NUMBER_FILTER_TABLE_CHILD_LOCKS; i++) {
        INITIALIZE_CRITICAL_SECTION(&JrnlFilterTableChildLock[i]);
    }
    FrsInitializeQueue(&FrsVolumeLayerCOList, &FrsVolumeLayerCOList);
    FrsInitializeQueue(&FrsVolumeLayerCOQueue, &FrsVolumeLayerCOList);

    //
    // Wait for the DB to start up. During shutdown, this event is
    // set. Any extraneous commands issued by the journal are
    // subsequently ignored by the database.
    //
    WaitForSingleObject(DataBaseEvent, INFINITE);
    if (FrsIsShuttingDown) {
        return ERROR_PROCESS_ABORTED;
    }

    //
    // Create a journal read thread.  It will wait until an entry is placed
    // on the VolumeMonitorQueue.
    //

    if (!HANDLE_IS_VALID(JournalReadThreadHandle)) {
        JournalReadThreadHandle = CreateThread(NULL,
                                               0,
                                               JournalReadThread,
                                               (LPVOID) NULL,
                                               0,
                                               &ThreadId);

        if (!HANDLE_IS_VALID(JournalReadThreadHandle)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "Error from CreateThread", WStatus);
            return WStatus;
        }

        DbgCaptureThreadInfo2(L"JrnlRead", JournalReadThread, ThreadId);
    }

    return ERROR_SUCCESS;
}


VOID
JournalMonitorShutdown(
    VOID
    )
/*++

Routine Description:

    This routine releases handles and frees storage for