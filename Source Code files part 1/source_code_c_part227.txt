ile='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetMethodImplementationFlags"]/*' />
    	public override MethodImplAttributes GetMethodImplementationFlags()
    	{
    		return m_dwMethodImplFlags;
    	}

    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.Attributes"]/*' />
    	public override MethodAttributes Attributes {
    		get {return m_iAttributes;}
    	}

		/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.CallingConvention"]/*' />
		public override CallingConventions CallingConvention {
    		get {return m_callingConvention;}
		}

    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetCustomAttributes"]/*' />
    	public override Object[] GetCustomAttributes(bool inherit)
    	{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
    	}

    	// Return a custom attribute identified by Type
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetCustomAttributes1"]/*' />
    	public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
    	{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
    	}

		/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.IsDefined"]/*' />
		public override bool IsDefined(Type attributeType, bool inherit)
		{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
    	}


		// Use this function if client decides to form the custom attribute blob themselves
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.SetCustomAttribute"]/*' />
    	public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
    	{
    		if (con == null)
    			throw new ArgumentNullException("con");
    		if (binaryAttribute == null)
    			throw new ArgumentNullException("binaryAttribute");

            TypeBuilder.InternalCreateCustomAttribute(
                m_mdMethod.Token,
                ((ModuleBuilder )m_module).GetConstructorToken(con).Token,
                binaryAttribute,
                m_module,
                false);
    	}

		// Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            if (customBuilder == null)
            {
                throw new ArgumentNullException("customBuilder");
            }
            customBuilder.CreateCustomAttribute((ModuleBuilder)m_module, m_mdMethod.Token);
        }


    	// Property representing the class that was used in reflection to obtain
    	// this Member.
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.ReflectedType"]/*' />
    	public override Type ReflectedType {
    		get {return InternalReflectedClass(false);}
    	}

    	internal override Type InternalReflectedClass(bool returnGlobalClass)
		{
			if (returnGlobalClass == false &&
				m_containingType.m_isHiddenGlobalType == true)
			{
				return null;
			}
			return m_containingType;
		}

 		// Method Handle routines
		/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.MethodHandle"]/*' />
		public override RuntimeMethodHandle MethodHandle {
			get {throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));}
		}


    	/**********************************************
         * Returns the name of this Method.
         * @return The name of this method class.
    	**********************************************/
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.Name"]/*' />
    	public override String Name {
    		get { return m_strName; }
    	}

    	/**********************************************
    	 *
    	 * Private methods
    	 *
    	 **********************************************/

    	/**********************************************
    	 * Make a private constructor so these cannot be constructed externally.
    	 * @internonly
    	 **********************************************/
        private MethodBuilder() {}

    	/**********************************************
         * Constructs a MethodBuilder.  The name of the method and the
         * signature must be provided.  This is the minimum information
         * set required to add a <i>MethodWrite</i> to a <i>TypeBuilder</i>
         * and get a token for it.  The default attribute of a method is MethodInfo.Public.
         *
         * This is call internally by TypeBuilder.  It is not exposed externally.  MethodBuilder
         * object always exist within the context of a Type.
         *
         * @param name The name of the method.
         * @exception ArgumentException if <EM>startIndex</EM> + <EM>length</EM> is greater than <EM>value.Length</EM>
         * @param signature The signature of the method.
         * @exception ArgumentException Thrown if <var>name</var> or <var>signature</var> is null.
    	 * @see System.Reflection.MethodBuilder.GetSignature()
    	 * @internalonly
    	**********************************************/
        internal MethodBuilder(
            String              name,
            MethodAttributes    attributes,
            CallingConventions  callingConvention,
            Type                returnType,
            Type[]              parameterTypes,
            Module              mod,
            TypeBuilder         type,
            bool                bIsGlobalMethod)
        {
            if (name == null)
                throw new ArgumentNullException("name");
			if (name.Length == 0)
				throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
            if (name[0] == '\0')
                throw new ArgumentException(Environment.GetResourceString("Argument_IllegalName"), "name");
            if (mod == null)
                throw new ArgumentNullException("mod");
    	    Init(name, attributes, callingConvention, returnType, parameterTypes, mod, type, bIsGlobalMethod);
        }

        private void Init(
            String              name,
            MethodAttributes    attributes,
            CallingConventions  callingConvention,
            Type                returnType,
            Type[]              parameterTypes,
            Module              mod,
            TypeBuilder         type,
            bool                bIsGlobalMethod)
        {
            m_strName = name;
            m_localSignature = SignatureHelper.GetLocalVarSigHelper(mod);
            m_module = mod;
            m_containingType = type;
            if (returnType == null)
            {
                m_returnType = typeof(void);
            }
    		else
            {
                m_returnType = returnType;
            }

            if ((attributes & MethodAttributes.Static) == 0)
            {
                // turn on the has this calling convention
                callingConvention = callingConvention | CallingConventions.HasThis;
            }
            else if ((attributes & MethodAttributes.Virtual)!=0)
            {
                //A method can't be both static and virtual
                throw new ArgumentException(Environment.GetResourceString("Arg_NoStaticVirtual"));
            }
            if ((attributes & MethodAttributes.SpecialName) != MethodAttributes.SpecialName)
            {
                if ((type.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                {
                    // methods on interface have to be abstract + virtual except special name methods(such as type initializer
                    if ((attributes & (MethodAttributes.Abstract | MethodAttributes.Virtual)) != (MethodAttributes.Abstract | MethodAttributes.Virtual))
                        throw new ArgumentException(Environment.GetResourceString("Argument_BadAttributeOnInterfaceMethod"));               
                }
            }

            m_callingConvention =  callingConvention;
            m_returnType = returnType;

            if (parameterTypes != null)
            {
                m_parameterTypes = new Type[parameterTypes.Length];
                Array.Copy(parameterTypes, m_parameterTypes, parameterTypes.Length);
            }
            else
                m_parameterTypes = null;

            m_signature = SignatureHelper.GetMethodSigHelper(mod, callingConvention, returnType, parameterTypes);
            m_iAttributes = attributes;
            m_bIsGlobalMethod = bIsGlobalMethod;
            m_bIsBaked=false;
            m_fInitLocals = true;

            m_localSymInfo = new LocalSymInfo();
            m_ubBody = null;
            m_ilGenerator = null;


    		// default is managed IL
    		// Manged IL has bit flag 0x0020 set off

    		m_dwMethodImplFlags = MethodImplAttributes.IL;
        }

    	/**********************************************
    	 * Set the token within the context of the defining TypeBuilder.
    	 * @param token The token within the containing TypeBuilder.
    	**********************************************/
        internal void SetToken(MethodToken token)
        {
            m_mdMethod = token;
        }


    	/**********************************************
         * Returns the il bytes of this method.
         * @return The il of this method.
         * This il is not valid until somebody has called BakeByteArray
    	**********************************************/
        internal byte[] GetBody() {
            return m_ubBody;
        }

    	/**********************************************
         * Return the token fixups
    	**********************************************/
        internal int []GetTokenFixups() {
            return mm_mdMethodFixups;
        }

    	/**********************************************
         * Return the RVA fixups;
    	**********************************************/
        internal int []GetRVAFixups() {
            return m_RVAFixups;
        }

    	/**********************************************
         * @return Returns the signature for this method.
    	**********************************************/
        internal SignatureHelper GetMethodSignature() {
            return m_signature;
        }

        internal SignatureHelper GetLocalsSignature() {
            if (m_ilGenerator != null)
            {
                if (m_ilGenerator.m_localCount != 0)
                {
                    // If user is using ILGenerator::DeclareLocal, then get local signaturefrom there.
                    return m_ilGenerator.m_localSignature;
                }
            }
            return m_localSignature;
        }

    	/**********************************************
         * Returns the number of exceptions
         * @return the number of exceptions in this class.  Each catch block is considered to be a separate
         * exception
    	**********************************************/
        internal int GetNumberOfExceptions() {
            return m_numExceptions;
        }

    	/**********************************************
         * Returns an array of __ExceptionInstance's for this method.  Each __ExceptionInstance represents
         * a separate try-catch tuple.
         * @return The exceptions in this method.
    	**********************************************/
        internal __ExceptionInstance[] GetExceptionInstances() {
            return m_exceptions;
        }

        internal int CalculateNumberOfExceptions(__ExceptionInfo [] excp) {
            int num=0;
            if (excp==null) {
                return 0;
            }
            for (int i=0; i<excp.Length; i++) {
                num+=excp[i].GetNumberOfCatches();
            }
            return num;
        }

        internal bool     IsTypeCreated() { return (m_containingType != null && m_containingType.m_hasBeenCreated); }

        internal TypeBuilder GetTypeBuilder() { return m_containingType;}

        /**********************************************
    	 *
    	 * Private variables
    	 *
    	 **********************************************/
        private String		    m_strName;					// The name of the method
        private MethodToken	    m_mdMethod;					// The token of this method
        private Module          m_module;

        private byte[]		    m_ubBody;					// The IL for the method
        private int			    m_numExceptions;			// The number of exceptions.  Each try-catch tuple is a separate exception.
        private __ExceptionInstance[] m_exceptions;		    //The instance of each exception.
        private int[]		    m_RVAFixups;				// The location of all RVA fixups.  Primarily used for Strings.
        private int[]		    mm_mdMethodFixups;			// The location of all of the token fixups.
        private SignatureHelper m_signature;
        private SignatureHelper m_localSignature;
        private MethodAttributes m_iAttributes;
        private bool		    m_bIsGlobalMethod;
        internal bool		    m_bIsBaked;
    	internal Type        	m_returnType;
        private ParameterBuilder m_retParam;
        internal Type[]         m_parameterTypes;
        private CallingConventions m_callingConvention;
    	private MethodImplAttributes m_dwMethodImplFlags;
        private TypeBuilder     m_containingType;
        internal LocalSymInfo   m_localSymInfo;             // keep track debugging local information
        internal ILGenerator    m_ilGenerator;
        private bool            m_fInitLocals;              // indicating if the method stack frame will be zero initialized or not.
    }




    /***************************
    *
    * This class tracks the local variable's debugging information and namespace information with a given
    * active lexical scope.
    *
    ***************************/
    internal class LocalSymInfo
    {
        internal LocalSymInfo()
        {
            // initialize data variables
            m_iLocalSymCount = 0;
            m_iNameSpaceCount = 0;
        }

        internal void AddLocalSymInfo(
            String          strName,
            byte[]          signature,
            int             slot,
            int             startOffset,
            int             endOffset)
        {
            // make sure that arrays are large enough to hold addition info
            EnsureCapacity();
            m_iStartOffset[m_iLocalSymCount] = startOffset;
            m_iEndOffset[m_iLocalSymCount] = endOffset;
            m_iLocalSlot[m_iLocalSymCount] = slot;
            m_strName[m_iLocalSymCount] = strName;
            m_ubSignature[m_iLocalSymCount] = signature;
            m_iLocalSymCount++;
        }

        internal void AddUsingNamespace(
            String          strNamespace)
        {
            EnsureCapacityNamespace();
            m_namespace[m_iNameSpaceCount++] = strNamespace;

        }

        /**************************
        *
        * Helper to ensure arrays are large enough
        *
        **************************/
        private void EnsureCapacityNamespace()
        {
            if (m_iNameSpaceCount == 0)
            {
                m_namespace = new String[InitialSize];
            }
            else if (m_iNameSpaceCount == m_namespace.Length)
            {
                String [] strTemp = new String [m_iNameSpaceCount * 2];
                Array.Copy(m_namespace, strTemp, m_iNameSpaceCount);
                m_namespace = strTemp;

            }
        }

        private void EnsureCapacity()
        {
            if (m_iLocalSymCount == 0)
            {
                // First time. Allocate the arrays.
                m_strName = new String[InitialSize];
                m_ubSignature = new byte[InitialSize][];
                m_iLocalSlot = new int[InitialSize];
                m_iStartOffset = new int[InitialSize];
                m_iEndOffset = new int[InitialSize];
            }
            else if (m_iLocalSymCount == m_strName.Length)
            {
                // the arrays are full. Enlarge the arrays
                int[] temp = new int [m_iLocalSymCount * 2];
                Array.Copy(m_iLocalSlot, temp, m_iLocalSymCount);
                m_iLocalSlot = temp;

                temp = new int [m_iLocalSymCount * 2];
                Array.Copy(m_iStartOffset, temp, m_iLocalSymCount);
                m_iStartOffset = temp;

                temp = new int [m_iLocalSymCount * 2];
                Array.Copy(m_iEndOffset, temp, m_iLocalSymCount);
                m_iEndOffset = temp;

                String [] strTemp = new String [m_iLocalSymCount * 2];
                Array.Copy(m_strName, strTemp, m_iLocalSymCount);
                m_strName = strTemp;

                byte[][] ubTemp = new byte[m_iLocalSymCount * 2][];
                Array.Copy(m_ubSignature, ubTemp, m_iLocalSymCount);
                m_ubSignature = ubTemp;

            }
        }

        internal virtual void EmitLocalSymInfo(ISymbolWriter symWriter)
        {
            int         i;

            for (i = 0; i < m_iLocalSymCount; i ++)
            {
                symWriter.DefineLocalVariable(
                            m_strName[i],
                            FieldAttributes.PrivateScope, // @todo: What is local variable attributes???
                            m_ubSignature[i],
                            SymAddressKind.ILOffset,
                            m_iLocalSlot[i],
                            0,          // addr2 is not used yet
                            0,          // addr3 is not used
                            m_iStartOffset[i],
                            m_iEndOffset[i]);
            }
            for (i = 0; i < m_iNameSpaceCount; i ++)
            {
                symWriter.UsingNamespace(m_namespace[i]);
            }

        }

        // class variables
        internal String[]       m_strName;
        internal byte[][]       m_ubSignature;
        internal int[]          m_iLocalSlot;
        internal int[]          m_iStartOffset;
        internal int[]          m_iEndOffset;
        internal int            m_iLocalSymCount;         // how many entries in the arrays are occupied
        internal String[]       m_namespace;
        internal int            m_iNameSpaceCount;
        internal const int      InitialSize = 16;
    }



    /****************************************
     *
     * Internal exception structure. This is shared between managed and
     * unmanaged. Make sure that they are in ssync if apply changes.
     *
     ****************************************/
    internal struct __ExceptionInstance {
        internal int m_exceptionClass;
        internal int m_startAddress;
        internal int m_endAddress;
    	internal int m_filterAddress;
        internal int m_handleAddress;
        internal int m_handleEndAddress;
        internal int m_type;

        internal __ExceptionInstance(int start, int end, int filterAddr, int handle, int handleEnd, int type, int exceptionClass) {
            BCLDebug.Assert(handleEnd != -1,"handleEnd != -1");
            m_startAddress=start;
            m_endAddress=end;
    		m_filterAddress = filterAddr;
            m_handleAddress=handle;
            m_handleEndAddress=handleEnd;
            m_type=type;
            m_exceptionClass = exceptionClass;
        }

    	// Satisfy JVC's value class requirements
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is __ExceptionInstance)) {
    			__ExceptionInstance that = (__ExceptionInstance) obj;
    			return that.m_exceptionClass == m_exceptionClass &&
    				that.m_startAddress == m_startAddress && that.m_endAddress == m_endAddress &&
    				that.m_filterAddress == m_filterAddress &&
    				that.m_handleAddress == m_handleAddress && that.m_handleEndAddress == m_handleEndAddress;
    		}
    		else
    			return false;
    	}
        
		public override int GetHashCode() 
		{
            return m_exceptionClass ^ m_startAddress ^ m_endAddress ^ m_filterAddress ^ m_handleAddress ^ m_handleEndAddress ^ m_type;
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\operandtype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**Class: OperandType
**
**Author: Craig Schertz (cschertz)
**
**Purpose: Exposes OperandType Attribute of IL .
**
** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND!
** See cschertz for more information.**
============================================================*/
namespace System.Reflection.Emit {

using System;

/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType"]/*' />
[Serializable]
public enum OperandType
{

	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineBrTarget"]/*' />
	InlineBrTarget	= 0,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineField"]/*' />
	InlineField	= 1,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineI"]/*' />
	InlineI	= 2,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineI8"]/*' />
	InlineI8	= 3,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineMethod"]/*' />
	InlineMethod	= 4,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineNone"]/*' />
	InlineNone	= 5,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlinePhi"]/*' />
	/// <internalonly/>
	InlinePhi	= 6,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineR"]/*' />
	InlineR	= 7,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineSig"]/*' />
	InlineSig	= 9,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineString"]/*' />
	InlineString	= 10,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineSwitch"]/*' />
	InlineSwitch	= 11,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineTok"]/*' />
	InlineTok	= 12,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineType"]/*' />
	InlineType	= 13,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.InlineVar"]/*' />
	InlineVar	= 14,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.ShortInlineBrTarget"]/*' />
	ShortInlineBrTarget	= 15,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.ShortInlineI"]/*' />
	ShortInlineI	= 16,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.ShortInlineR"]/*' />
	ShortInlineR	= 17,
	/// <include file='doc\OperandType.uex' path='docs/doc[@for="OperandType.ShortInlineVar"]/*' />
	ShortInlineVar	= 18,
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\modulebuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace System.Reflection.Emit {
    using System.Runtime.InteropServices;
    using System;
    using IList = System.Collections.IList;
    using ArrayList = System.Collections.ArrayList;
    using CultureInfo = System.Globalization.CultureInfo;
    using ResourceWriter = System.Resources.ResourceWriter;
    using IResourceWriter = System.Resources.IResourceWriter;
    using System.Diagnostics.SymbolStore;
    using System.Reflection;
    using System.Diagnostics;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Threading;

    /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder"]/*' />
    // deliberately not [serializable]
    public class ModuleBuilder : Module
    {   
        // WARNING!! WARNING!!
        // ModuleBuilder should not contain any data members as its reflectbase is the same as Module.
    
        //***********************************************
        // public API to to a type. The reason that we need this function override from module
        // is because clients might need to get foo[] when foo is being built. For example, if 
        // foo class contains a data member of type foo[].
        // This API first delegate to the Module.GetType implementation. If succeeded, great! 
        // If not, we have to look up the current module to find the TypeBuilder to represent the base
        // type and form the Type object for "foo[,]".
        //***********************************************
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetType"]/*' />
        public override Type GetType(String className) 
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetType(className, false, false, ref stackMark);
        }
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetType1"]/*' />
        public override Type GetType(String className, bool ignoreCase)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetType(className, false, ignoreCase, ref stackMark);
        }
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetType2"]/*' />
        public override Type GetType(String className, bool throwOnError, bool ignoreCase)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetType(className, throwOnError, ignoreCase, ref stackMark);
        }

        private Type GetType(String className, bool throwOnError, bool ignoreCase, ref StackCrawlMark stackMark)
        {
            try
            {
                Enter();

                // Module.GetType() will verify className.                
                Type baseType = base.GetTypeInternal(className, ignoreCase, throwOnError, ref stackMark);
                if (baseType != null)
                    return baseType;

                // Now try to see if we contain a TypeBuilder for this type or not.
                // Might have a compound type name, indicated via an unescaped
                // '[', '*' or '&'. Split the name at this point.
                String baseName = null;
                String parameters = null;
                int startIndex = 0;

                while (startIndex < className.Length)
                {
                    // Are there any possible special characters left?
                    int i = className.IndexOfAny(new char[]{'[', '*', '&'}, startIndex);
                    if (i == -1)
                    {
                        // No, type name is simple.
                        baseName = className;
                        parameters = null;
                        break;
                    }

                    // Found a potential special character, but it might be escaped.
                    int slashes = 0;
                    for (int j = i - 1; j >= 0 && className[j] == '\\'; j--)
                        slashes++;

                    // Odd number of slashes indicates escaping.
                    if (slashes % 2 == 1)
                    {
                        startIndex = i + 1;
                        continue;
                    }

                    // Found the end of the base type name.
                    baseName = className.Substring(0, i);
                    parameters = className.Substring(i);
                    break;
                }

                // If we didn't find a basename yet, the entire class name is
                // the base name and we don't have a composite type.
                if (baseName == null)
                {
                    baseName = className;
                    parameters = null;
                }

                if (parameters != null)
                {
                    // try to see if reflection can find the base type. It can be such that reflection
                    // does not support the complex format string yet!

                    baseType = base.GetTypeInternal(baseName, ignoreCase, false, ref stackMark);
                }

                if (baseType == null)
                {
                    // try to find it among the unbaked types.
                    // starting with the current module first of all.
                    baseType = FindTypeBuilderWithName(baseName, ignoreCase, ref stackMark);
                    if (baseType == null && Assembly is AssemblyBuilder)
                    {
                        // now goto Assembly level to find the type.
                        int         size;
                        ArrayList   modList;

                        modList = Assembly.m_assemblyData.m_moduleBuilderList;
                        size = modList.Count;
                        for (int i = 0; i < size && baseType == null; i++) 
                        {
                            ModuleBuilder mBuilder = (ModuleBuilder) modList[i];
                            baseType = mBuilder.FindTypeBuilderWithName(baseName, ignoreCase, ref stackMark);
                        }
                    }
                    if (baseType == null)
                        return null;
                }
                
                if (parameters == null)         
                    return baseType;
            
                return GetType(parameters, baseType);
            
            }
            finally
            {
                Exit();
            }
        }

        //***********************************************
        //
        // This function takes a string to describe the compound type, such as "[,][]", and a baseType.
        // 
        //***********************************************
        
        private Type GetType(String strFormat, Type baseType)
        {
            if (strFormat == null || strFormat.Equals(String.Empty))
            {
                return baseType;
            }

            // convert the format string to byte array and then call FormCompoundType
            char[]      bFormat = strFormat.ToCharArray();
            return SymbolType.FormCompoundType(bFormat, baseType, 0);

        }

        // Helper to look up TypeBuilder by name.
        internal virtual Type FindTypeBuilderWithName(String strTypeName, bool ignoreCase, ref StackCrawlMark stackMark)
        {
            int         size = m_TypeBuilderList.Count;
            int         i;
            Type        typeTemp = null;

            for (i = 0; i < size; i++) 
            {
                typeTemp = (Type) m_TypeBuilderList[i];
                if (ignoreCase == true)
                {
                    if (String.Compare(typeTemp.FullName, strTypeName, ignoreCase, CultureInfo.InvariantCulture) == 0)
                        break;                    
                }
                else
                {
                    if (typeTemp.FullName.Equals( strTypeName))
                        break;
                }
            } 
            if (i == size)
                typeTemp = null;

            // Security access check.
            if (typeTemp != null)
            {
                Type t = typeTemp;
                while (t.IsNestedPublic)
                    t = t.DeclaringType;
                if (!t.IsPublic && Assembly.nGetExecutingAssembly(ref stackMark) != t.Assembly)
                {
                    try
                    {
                        new ReflectionPermission(ReflectionPermissionFlag.TypeInformation).Demand();
                    }
                    catch (Exception)
                    {
                        typeTemp = null;
                    }
                }
            }

            return typeTemp;
        }
        
        // Returns an array of classes defined within the Module.
        // 
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetTypes"]/*' />
        public override Type[] GetTypes()
        {
            int size = m_TypeBuilderList.Count;
            Type[] moduleTypes = new Type[size];
            TypeBuilder tmpTypeBldr;
            bool checkedCaller = false;
            Assembly caller = null;
            bool checkedReflPerm = false;
            bool hasReflPerm = false;
            int filtered = 0;
            Type t;
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;

            for (int i = 0; i < size; i++)
            {
                EnumBuilder enumBldr = m_TypeBuilderList[i] as EnumBuilder;
                tmpTypeBldr = m_TypeBuilderList[i] as TypeBuilder;
                if (enumBldr != null)
                    tmpTypeBldr = enumBldr.m_typeBuilder;
                    
                if (tmpTypeBldr != null)
                {
                    if (tmpTypeBldr.m_hasBeenCreated)
                        moduleTypes[i] = tmpTypeBldr.UnderlyingSystemType;
                    else
                        moduleTypes[i] = tmpTypeBldr;
                }
                else
                {
                    // RuntimeType case: This will happen in TlbImp.
                    moduleTypes[i] =  (Type) m_TypeBuilderList[i];
                }
                
                // Type access check.
                t = moduleTypes[i];
                while (t.IsNestedPublic)
                    t = t.DeclaringType;
                if (!t.IsPublic)
                {
                    if (!checkedCaller)
                    {
                        caller = Assembly.nGetExecutingAssembly(ref stackMark);
                        checkedCaller = true;
                    }
                    if (caller != t.Assembly)
                    {
                        if (!checkedReflPerm)
                        {
                            try
                            {
                                new ReflectionPermission(ReflectionPermissionFlag.TypeInformation).Demand();
                                hasReflPerm = true;
                            }
                            catch (Exception)
                            {
                                hasReflPerm = false;
                            }
                            checkedReflPerm = true;
                        }
                        if (!hasReflPerm)
                        {
                            moduleTypes[i] = null;
                            filtered++;
                        }
                    }
                }
            }

            if (filtered > 0)
            {
                Type[] filteredTypes = new Type[size - filtered];
                int src, dst;
                for (src = 0, dst = 0; src < size; src++)
                {
                    if (moduleTypes[src] != null)
                    {
                        filteredTypes[dst] = moduleTypes[src];
                        dst++;
                    }
                }
                moduleTypes = filteredTypes;
            }

            return moduleTypes;
        }

        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.FullyQualifiedName"]/*' />
        public override String FullyQualifiedName {
            get
            {
                String fullyQualifiedName = m_moduleData.m_strFileName;
                if (fullyQualifiedName == null)
                    return null;
                if (Assembly.m_assemblyData.m_strDir != null)
                {
                    fullyQualifiedName = Path.Combine(Assembly.m_assemblyData.m_strDir, fullyQualifiedName);
                    fullyQualifiedName = Path.GetFullPath(fullyQualifiedName);                            
                }
                
                if (Assembly.m_assemblyData.m_strDir != null && fullyQualifiedName != null) 
                {
                    new FileIOPermission( FileIOPermissionAccess.PathDiscovery, fullyQualifiedName ).Demand();
                }

                return fullyQualifiedName;
            }
        }

                               
        /*******************
         *
         * Constructs a TypeBuilder. The class is defined within the runtime and a methoddef 
         * token is generated for this class.  The parent and attributes are defined.
         *  
         * @param name The name of the class.
         * @param attr The attribute to be associated with a class
         * @param parent The Type that represents the Parent of this class.  If
         * this value is null then System.Object is the parent
         * @exception ArgumentException Thrown if <var>name</var> is null. 
         * @exception NotSupportedException Thrown if the <var>module</var> is not
         * a module that supports Dynamic IL.
         *
         * @return A TypeBuilder created with all of the requested attributes.
         *******************/    
        // new definition with TypeAttributes
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType"]/*' />
        
        public TypeBuilder DefineType(
            String      name) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, TypeAttributes.NotPublic, null, null, this, PackingSize.Unspecified, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType1"]/*' />
        
        public TypeBuilder DefineType(
            String      name, 
            TypeAttributes attr, 
            Type        parent, 
            Type []     interfaces) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
    
                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, parent, interfaces, this, PackingSize.Unspecified, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType2"]/*' />
        
        public TypeBuilder DefineType(
            String      name, 
            TypeAttributes attr, 
            Type        parent) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
    
                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, parent, null, this, PackingSize.Unspecified, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType3"]/*' />
        
        public TypeBuilder DefineType(String name, TypeAttributes attr) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
    
                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, null, null, this, PackingSize.Unspecified, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        // specifying type size as a whole
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType4"]/*' />
        
        public TypeBuilder DefineType(String name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder = new TypeBuilder(name, attr, parent, this, packingSize, typesize, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
        
        // specifying type size as a whole
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType5"]/*' />
        
        public TypeBuilder DefineType(String name, TypeAttributes attr, Type parent, int typesize) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder = new TypeBuilder(name, attr, parent, this, PackingSize.Unspecified, typesize, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // specifying packing size
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineType6"]/*' />
        
        public TypeBuilder DefineType(
            String      name, 
            TypeAttributes attr, 
            Type        parent, 
            PackingSize packsize) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder = new TypeBuilder(name, attr, parent, null, this, packsize, null);
                m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        // Define Enum
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineEnum"]/*' />
        
        public EnumBuilder DefineEnum(            
            String      name,                       // name of type
            TypeAttributes visibility,              // any bits on TypeAttributes.VisibilityMask)
            Type        underlyingType)             // underlying type for an Enum
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineEnum( " + name + " )");
                EnumBuilder enumBuilder;
                enumBuilder = new EnumBuilder(name, underlyingType, visibility, this);
                m_TypeBuilderList.Add(enumBuilder);
                return enumBuilder;
            }
            finally
            {
                Exit();
            }
        }
    
        /**********************************************
        *
        * Define embedded managed resource to be stored in this module
        * @todo: Can only be used for persistable module???
        *
        **********************************************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineResource"]/*' />
        
        public IResourceWriter DefineResource(
            String      name,
            String      description)
        {
            return DefineResource(name, description, ResourceAttributes.Public);
        }

        /**********************************************
        *
        * Define embedded managed resource to be stored in this module
        * @todo: Can only be used for persistable module???
        *
        **********************************************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineResource1"]/*' />
        
        public IResourceWriter DefineResource(
            String      name,
            String      description,
            ResourceAttributes attribute)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineResource( " + name + ")");

                if (IsTransient())
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadResourceContainer"));

                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");

                Assembly assembly = this.Assembly;
                if (assembly is AssemblyBuilder)
                {
                    AssemblyBuilder asmBuilder = (AssemblyBuilder)assembly;
                    if (asmBuilder.IsPersistable())
                    {
                        asmBuilder.m_assemblyData.CheckResNameConflict(name);

                        MemoryStream stream = new MemoryStream();
                        ResourceWriter resWriter = new ResourceWriter(stream);
                        ResWriterData resWriterData = new ResWriterData( resWriter, stream, name, String.Empty, String.Empty, attribute);

                        // chain it to the embedded resource list
                        resWriterData.m_nextResWriter = m_moduleData.m_embeddedRes;
                        m_moduleData.m_embeddedRes = resWriterData;
                        return resWriter;
                    }
                    else
                    {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadResourceContainer"));
                    }
                }
                else
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadResourceContainer"));
                }
            }
            finally
            {
                Exit();
            }
        }
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineGlobalMethod"]/*' />
        public MethodBuilder DefineGlobalMethod(
            String          name, 
            MethodAttributes attributes,
            Type            returnType,
            Type[]          parameterTypes)
        {
            return DefineGlobalMethod(name, attributes, CallingConventions.Standard, returnType, parameterTypes);
        }

        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineGlobalMethod1"]/*' />
        public MethodBuilder DefineGlobalMethod(
            String          name, 
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefineGlobalMethod( " + name + " )");
    
                if (m_moduleData.m_fGlobalBeenCreated == true)
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_GlobalsHaveBeenCreated"));
                }
            
                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
            
                //If this method is declared to be a constructor,
            
                //Global methods must be static.
                // @cor.h
                // meichint: This statement is ok
                if ((attributes & MethodAttributes.Static)==0) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_GlobalFunctionHasToBeStatic"));
                }
                m_moduleData.m_fHasGlobal = true;
                return m_moduleData.m_globalTypeBuilder.DefineMethod(name, attributes, callingConvention, returnType, parameterTypes);
            }
            finally
            {
                Exit();
            }
        }
        
        //****************************
        // This method will define an initialized Data in .sdata. 
        // We will create a fake TypeDef to represent the data with size. This TypeDef
        // will be the signature for the Field. 
        //****************************
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineInitializedData"]/*' />
        public FieldBuilder DefineInitializedData(
            String          name, 
            byte[]          data,
            FieldAttributes attributes)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                if (m_moduleData.m_fGlobalBeenCreated == true)
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_GlobalsHaveBeenCreated"));
                }
            
                m_moduleData.m_fHasGlobal = true;
                return m_moduleData.m_globalTypeBuilder.DefineInitializedData(name, data, attributes);
            }
            finally
            {
                Exit();
            }
        }
        
        //****************************
        // This method will define an uninitialized Data in .sdata. 
        // We will create a fake TypeDef to represent the data with size. This TypeDef
        // will be the signature for the Field. 
        //****************************
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineUninitializedData"]/*' />
        public FieldBuilder DefineUninitializedData(
            String          name, 
            int             size,
            FieldAttributes attributes)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                if (m_moduleData.m_fGlobalBeenCreated == true)
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_GlobalsHaveBeenCreated"));
                }
            
                m_moduleData.m_fHasGlobal = true;
                return m_moduleData.m_globalTypeBuilder.DefineUninitializedData(name, size, attributes);
            }
            finally
            {
                Exit();
            }
        }
        
        
        /*******************
         *
         * Return a token for the class relative to the Module.  Tokens
         * are used to indentify objects when the objects are used in IL
         * instructions.  Tokens are always relative to the Module.  For example,
         * the token value for System.String is likely to be different from
         * Module to Module.  Calling GetTypeToken will cause a reference to be
         * added to the Module.  This reference becomes a perminate part of the Module,
         * multiple calles to this method with the same class have no additional side affects.
         * 
         * @param type A class representing the type.
         * @return The Token of the class 
         * @exception ArgumentException If <var>type</var> is null.
         * 
         * This function optimize to use the TypeDef token if Type is within the same module.
         * We should also be aware of multiple dynamic modules and multiple implementation of Type!!!
         *
         *******************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetTypeToken"]/*' />
        public TypeToken GetTypeToken(Type type)
        {
            try
            {
                Enter();

                TypeToken   tkToken;
                bool        isSameAssembly;
                bool        isSameModule;
                Module      refedModule;
                String      strRefedModuleFileName = String.Empty;
            
                // assume that referenced module is non-transient. Only if the referenced module is dynamic,
                // and transient, this variable will be set to true.
                bool     isRefedModuleTransient = false;
    
                if (type == null)
                    throw new ArgumentNullException("type");

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.GetTypeToken( " + type.FullName + " )");
    
                refedModule = type.Module;
                isSameModule = refedModule.Equals(this);
    
    // Console.WriteLine("***** " + type.FullName);     
            
                if (type.IsByRef)
                {
                    // cannot be by ref!!! Throw exception
                    throw new ArgumentException(Environment.GetResourceString("Argument_CannotGetTypeTokenForByRef"));   
                }
            
                if (type is SymbolType)
                {
                    if (type.IsPointer || type.IsArray)
                    {
                        SignatureBuffer sigBuf = new SignatureBuffer();
                        SymbolType      symType = (SymbolType) type;

                        // convert SymbolType to blob form
                        symType.ToSigBytes(this, sigBuf);

                        return new TypeToken( InternalGetTypeSpecTokenWithBytes(sigBuf.m_buf, sigBuf.m_curPos) );
                    }
                    else
                        throw new ArgumentException(Environment.GetResourceString("Argument_UnknownTypeForGetTypeToken"));   

                }
            
                Type        baseType;
                baseType = GetBaseType(type);

                if ( (type.IsArray || type.IsPointer) && baseType != type)
                {
                    // We will at most recursive once. 
                    int         baseToken;
                    baseToken = GetTypeToken(baseType).Token;
                    if (!(type is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "type");
                    return new TypeToken( InternalGetTypeSpecToken((RuntimeType)type, baseToken) );
                }

                // After this point, it is not an array type nor Pointer type

                if (isSameModule)
                {
                    // no need to do anything additional other than defining the TypeRef Token
                    if (type is TypeBuilder)
                    {
                        // optimization: if the type is defined in this module,
                        // just return the token
                        //
                        TypeBuilder typeBuilder = (TypeBuilder) type;
                        return typeBuilder.TypeToken;
                    }
                    else if (type is EnumBuilder)
                    {
                        TypeBuilder typeBuilder = ((EnumBuilder) type).m_typeBuilder; 
                        return typeBuilder.TypeToken; 
                    }
                    return new TypeToken(GetTypeRefNested(type, this, String.Empty));
                }
                        
                // After this point, the referenced module is not the same as the referencing
                // module.
                //
                isSameAssembly = refedModule.Assembly.Equals(Assembly);
                if (refedModule is ModuleBuilder)
                {
                    ModuleBuilder       refedModuleBuilder = (ModuleBuilder) refedModule;
                    if (refedModuleBuilder.IsTransient())
                    {
                        isRefedModuleTransient = true;
                    }
                    // get the referenced module's file name
                    strRefedModuleFileName = refedModuleBuilder.m_moduleData.m_strFileName;
                }
                else
                    strRefedModuleFileName = refedModule.ScopeName;
                        
                // We cannot have a non-transient module referencing to a transient module.
                if (IsTransient() == false && isRefedModuleTransient)
                {
                    // we got problem here.
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadTransientModuleReference"));   
                }
                
                tkToken = new TypeToken(GetTypeRefNested(type, refedModule, strRefedModuleFileName));
                return tkToken;
            }
            finally
            {
                Exit();
            }
        }
        

        /*******************
         *
         * This function will walk compound type to the inner most BaseType. Such as returning int for
         * "ptr [] int".
         *
         *******************/
        internal Type GetBaseType(Type type)
        {
            if (type.IsByRef == false && type.IsPointer == false && type.IsArray == false)
            {
                return type;
            }
            return GetBaseType( type.GetElementType() );
        }


        /*******************
         *
         * This function will generate correct TypeRef token for top level type and nested type.
         *
         *******************/
        internal int GetTypeRefNested(Type type, Module refedModule, String strRefedModuleFileName)
        {
            Type    enclosingType = type.DeclaringType;
            int     tkResolution = 0;
            String  typeName = type.FullName;

// Console.WriteLine("GetTypeRefNested " + type.FullName);
            if (enclosingType != null)
            {
// Console.WriteLine("EnclosingType " + enclosingType.FullName);
                tkResolution = GetTypeRefNested(enclosingType, refedModule, strRefedModuleFileName);
                typeName = UnmangleTypeName(typeName);
            }

            return InternalGetTypeToken(typeName, refedModule,
                                        strRefedModuleFileName, tkResolution);
        }

        /*******************
         *
         * Return a token for the class relative to the Module. 
         * 
         * @param name A String representing the name of the class.
         * @return The Token of the class 
         * @see #GetTypeToken
         * @exception ArgumentNullException If <var>name</var> is null.
         * @exception TypeLoadException If <var>name</var> is not found.
         * @exception NotSupportedException If this module does not support Dynamic IL
         *
         *******************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetTypeToken1"]/*' />
        public TypeToken GetTypeToken(String name)
        {
            // Module.GetType() verifies name
            
            // Unfortunately, we will need to load the Type and then call GetTypeToken in 
            // order to correctly track the assembly reference information.
            
            return GetTypeToken(base.GetType(name, false, true));
        }
        
        // Return a MemberRef token if MethodInfo is not defined in this module. Or 
        // return the MethodDef token. 
        // 
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetMethodToken"]/*' />
        public MethodToken GetMethodToken(MethodInfo method)
        {
            try
            {
                Enter();

                int     tr;
                int     mr = 0;
                
                if ( method == null ) {
                    throw new ArgumentNullException("method");
                }
    
                if ( method is MethodBuilder )
                {
                    MethodBuilder methBuilder = (MethodBuilder) method;
                    if (methBuilder.GetModule() == this)
                    {
                        return methBuilder.GetToken();  
                    }
                    else
                    {
                        if (method.DeclaringType == null)
                        {
                            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_CannotImportGlobalFromDifferentModule"));
                        }
                        // field is defined in a different module
                        tr = GetTypeToken(method.DeclaringType).Token;
                        mr = InternalGetMemberRef(method.ReflectedType.Module, tr, methBuilder.GetToken().Token);
                    }
                }
                else if (method is SymbolMethod)
                {
                    SymbolMethod symMethod = (SymbolMethod) method;
                    if (symMethod.GetModule() == this)
                    {
                        return symMethod.GetToken();
                    }
                    else
                    {
                        // form the method token
                        return symMethod.GetToken(this);
                    }
                }
                else
                {
                    Type declaringType = method.DeclaringType;
                    // We need to get the TypeRef tokens
                    if (declaringType == null)
                    {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_CannotImportGlobalFromDifferentModule"));
                    }
                    if (declaringType.IsArray == true)
                    {
                        // use reflection to build signature to work around the E_T_VAR problem in EEClass
                        ParameterInfo[] paramInfo = method.GetParameters();
                        Type[] tt = new Type[paramInfo.Length];
                        for (int i = 0; i < paramInfo.Length; i++)
                        {
                            tt[i] = paramInfo[i].ParameterType;
                        }
                        return GetArrayMethodToken(declaringType, method.Name, method.CallingConvention, method.ReturnType, tt);
                    }
                    else if (method is RuntimeMethodInfo)
                    {
                        tr = GetTypeToken(declaringType).Token;
                        mr = InternalGetMemberRefOfMethodInfo(tr, method);
                    }
                    else
                    {
                        // some user derived ConstructorInfo
                        // go through the slower code path, i.e. retrieve parameters and form signature helper.
                        ParameterInfo[] parameters = method.GetParameters();
                        Type[] parameterTypes = new Type[parameters.Length];
                        for (int i = 0; i < parameters.Length; i++)
                            parameterTypes[i] = parameters[i].ParameterType;                
                        tr = GetTypeToken(method.ReflectedType).Token;
                        SignatureHelper sigHelp = SignatureHelper.GetMethodSigHelper(
                                                    this, 
                                                    method.CallingConvention, 
                                                    method.ReturnType, 
                                                    parameterTypes);
                        int length;                                           
                        byte[] sigBytes = sigHelp.InternalGetSignature(out length);
                        mr = InternalGetMemberRefFromSignature(tr, method.Name, sigBytes, length);                 
                        
                    }
                }
    
                return new MethodToken(mr);
            }
            finally
            {
                Exit();
            }
        }
    
        
    
    
        // Return a token for the MethodInfo for a method on an Array.  This is primarily
        // used to get the LoadElementAddress method. 
        // 
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetArrayMethodToken"]/*' />
        public MethodToken GetArrayMethodToken(
            Type        arrayClass, 
            String      methodName, 
            CallingConventions callingConvention,
            Type        returnType,
            Type[]      parameterTypes)
        {
            try
            {
                Enter();

                Type        baseType;
                int         baseToken;
                int length;
            
                if (arrayClass == null)
                    throw new ArgumentNullException("arrayClass");
                if (methodName == null)
                    throw new ArgumentNullException("methodName");
                if (methodName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "methodName");
                if (arrayClass.IsArray == false)
                    throw new ArgumentException(Environment.GetResourceString("Argument_HasToBeArrayClass")); 
                SignatureHelper sigHelp = SignatureHelper.GetMethodSigHelper(this, callingConvention, returnType, parameterTypes);
                byte[] sigBytes = sigHelp.InternalGetSignature(out length);
    
                // track the TypeRef of the array base class
                for (baseType = arrayClass; baseType.IsArray; baseType = baseType.GetElementType());
                baseToken = GetTypeToken(baseType).Token;
    
                TypeToken typeSpec = GetTypeToken(arrayClass);

                return nativeGetArrayMethodToken(typeSpec.Token, methodName, sigBytes, length, baseToken);
            }
            finally
            {
                Exit();
            }
        }

    
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetArrayMethod"]/*' />
        public MethodInfo GetArrayMethod(
            Type        arrayClass, 
            String      methodName, 
            CallingConventions callingConvention,
            Type        returnType,
            Type[]      parameterTypes)
        {
            MethodToken token = GetArrayMethodToken(arrayClass, methodName, callingConvention, returnType, parameterTypes);
            return new SymbolMethod(this, token, arrayClass, methodName, callingConvention, returnType, parameterTypes);
        }

        // Return a token for the FieldInfo relative to the Module. 
        // 
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetFieldToken"]/*' />
        public FieldToken GetFieldToken(FieldInfo field) 
        {
            try
            {
                Enter();

                int     tr;
                int     mr = 0;
                
                if (field == null) {
                    throw new ArgumentNullException("con");
                }
                if (field is FieldBuilder)
                {
                    FieldBuilder fdBuilder = (FieldBuilder) field;
                    if (fdBuilder.GetTypeBuilder().Module.Equals(this))
                    {
                        // field is defined in the same module
                        return fdBuilder.GetToken();
                    }
                    else
                    {
                        // field is defined in a different module
                        if (field.DeclaringType == null)
                        {
                            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_CannotImportGlobalFromDifferentModule"));
                        }
                        tr = GetTypeToken(field.DeclaringType).Token;
                        mr = InternalGetMemberRef(field.ReflectedType.Module, tr, fdBuilder.GetToken().Token);
                    }
                }
                else if (field is RuntimeFieldInfo)
                {
                    // FieldInfo is not an dynamic field
                    
                    // We need to get the TypeRef tokens
                    if (field.DeclaringType == null)
                    {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_CannotImportGlobalFromDifferentModule"));
                    }
                    tr = GetTypeToken(field.DeclaringType).Token;       
                    mr = InternalGetMemberRefOfFieldInfo(tr, (RuntimeFieldInfo)field);
                }
                else
                {
                    // user defined FieldInfo
                    tr = GetTypeToken(field.ReflectedType).Token;
                    SignatureHelper sigHelp = SignatureHelper.GetFieldSigHelper(this);
                    sigHelp.AddArgument(field.FieldType);
                    int length;                                           
                    byte[] sigBytes = sigHelp.InternalGetSignature(out length);
                    mr = InternalGetMemberRefFromSignature(tr, field.Name, sigBytes, length);                 
                }
                
                return new FieldToken(mr, field.GetType());
            }
            finally
            {
                Exit();
            }
        }
        
        // Returns a token representing a String constant.  If the string 
        // value has already been defined, the existing token will be returned.
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetStringConstant"]/*' />
        public StringToken GetStringConstant(String str) 
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            return new StringToken(InternalGetStringConstant(str));
        }
    
    
        // Sets the entry point of the module to be a given method.  If no entry point
        // is specified, calling EmitPEFile will generate a dll.
        internal void SetEntryPoint(MethodInfo entryPoint) 
        {           
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            m_EntryPoint = GetMethodToken(entryPoint);
        }

       // Use this function if client decides to form the custom attribute blob themselves
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.SetCustomAttribute"]/*' />
        
        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            if (con == null)
                throw new ArgumentNullException("con");
            if (binaryAttribute == null)
                throw new ArgumentNullException("binaryAttribute");
            
            TypeBuilder.InternalCreateCustomAttribute(
                1,                                          // This is hard coding the module token to 1
                this.GetConstructorToken(con).Token,
                binaryAttribute,
                this,
                false);
        }

       // Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.SetCustomAttribute1"]/*' />
        
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            if (customBuilder == null)
            {
                throw new ArgumentNullException("customBuilder");
            }

            customBuilder.CreateCustomAttribute(this, 1);   // This is hard coding the module token to 1
        }

    
        // This is a helper called by AssemblyBuilder save to presave information for the persistable modules.
        internal void PreSave(String fileName)
        {
            try
            {
                Enter();

                Object      item;
                TypeBuilder typeBuilder;
                if (m_moduleData.m_isSaved == true)
                {
                    // can only save once
                    throw new InvalidOperationException(String.Format(Environment.GetResourceString(
                        "InvalidOperation_ModuleHasBeenSaved"),
                        m_moduleData.m_strModuleName));
                }
            
                if (m_moduleData.m_fGlobalBeenCreated == false && m_moduleData.m_fHasGlobal == true)
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_GlobalFunctionNotBaked")); 

                int size = m_TypeBuilderList.Count;
                for (int i=0; i<size; i++) 
                {
                    item = m_TypeBuilderList[i];
                    if (item is TypeBuilder)
                    {
                        typeBuilder = (TypeBuilder) item;
                    }
                    else
                    {
                        EnumBuilder enumBuilder = (EnumBuilder) item;
                        typeBuilder = enumBuilder.m_typeBuilder;
                    }
                    if (typeBuilder.m_hasBeenCreated == false && typeBuilder.m_isHiddenType == false)
                    {
                        // cannot save to PE file without creating all of the types first 
                        throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_NotAllTypesAreBaked"), typeBuilder.Name)); 
                    }
                }

                InternalPreSavePEFile();
            }
            finally
            {
                Exit();
            }
        }
        
        // This is a helper called by AssemblyBuilder save to save information for the persistable modules.
        internal void Save(String fileName, bool isAssemblyFile)
        {
            try
            {
                Enter();

                if (m_moduleData.m_embeddedRes != null)
                {
                    // There are embedded resources for this module
                    ResWriterData   resWriter;
                    byte[]          resBytes;
                    int             iCount;

                    // Set the number of resources embedded in this PE
                    for (resWriter = m_moduleData.m_embeddedRes, iCount = 0; resWriter != null; resWriter = resWriter.m_nextResWriter, iCount++);
                    InternalSetResourceCounts(iCount);

                    // Add each resource content into the to be saved PE file
                    for (resWriter = m_moduleData.m_embeddedRes; resWriter != null; resWriter = resWriter.m_nextResWriter)
                    {
                        resWriter.m_resWriter.Generate();
                        resBytes = resWriter.m_memoryStream.ToArray();
                        InternalAddResource(resWriter.m_strName, 
                                            resBytes,
                                            resBytes.Length,
                                            m_moduleData.m_tkFile,
                                            (int) resWriter.m_attribute);
                    }
                }

                if (m_moduleData.m_strResourceFileName != null)
                    InternalDefineNativeResourceFile(m_moduleData.m_strResourceFileName);
                else
                if(m_moduleData.m_resourceBytes != null)
                    InternalDefineNativeResourceBytes(m_moduleData.m_resourceBytes);

                if (isAssemblyFile)
                    InternalSavePEFile(fileName, m_EntryPoint, (int)Assembly.m_assemblyData.m_peFileKind, true); 
                else
                    InternalSavePEFile(fileName, m_EntryPoint, (int)PEFileKinds.Dll, false); 
                m_moduleData.m_isSaved = true;
            }
            finally
            {
                Exit();
            }
        }
    
        // Define signature token given a signature helper. This will define a metadata
        // token for the signature described by SignatureHelper.
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetSignatureToken"]/*' />
        public SignatureToken GetSignatureToken(SignatureHelper sigHelper)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.GetSignatureToken( )");
            
            int sigLength;
            byte[] sigBytes;
    
            if (sigHelper == null)
            {
                throw new ArgumentNullException("sigHelper");
            }

            // get the signature in byte form
            sigBytes = sigHelper.InternalGetSignature(out sigLength);
            return new SignatureToken(TypeBuilder.InternalGetTokenFromSig(this, sigBytes, sigLength), this);
        }
    
    
    
        // This is needed because some of our client will want to produce
        // the signature blob by themself. We want to be able to just accept a byte array
        // and length for the signature.
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetSignatureToken1"]/*' />
        public SignatureToken GetSignatureToken(byte[] sigBytes, int sigLength)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.GetSignatureToken( )");
    
            return new SignatureToken(TypeBuilder.InternalGetTokenFromSig(this, sigBytes, sigLength), this);
        }
    
        // Return a token for the ConstructorInfo relative to the Module. 
        // 
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetConstructorToken"]/*' />
        public MethodToken GetConstructorToken(ConstructorInfo con)
        {
            return InternalGetConstructorToken(con, false);
        }

        // helper to get constructor token. If usingRef is true, we will never use the def
        // token 
        internal MethodToken InternalGetConstructorToken(ConstructorInfo con, bool usingRef)
        {
            // @todo: for VX consolidate the code here with GetMethodToken
            int     tr;
            int     mr = 0;
            
            if (con == null) {
                throw new ArgumentNullException("con");
            }
            if (con is ConstructorBuilder)
            {
                ConstructorBuilder conBuilder = (ConstructorBuilder) con;
                if (usingRef == false && conBuilder.ReflectedType.Module.Equals(this))
                {
                    // constructor is defined in the same module
                    return conBuilder.GetToken();
                }
                else
                {
                    // constructor is defined in a different module
                    tr = GetTypeToken(con.ReflectedType).Token;
                    mr = InternalGetMemberRef(con.ReflectedType.Module, tr, conBuilder.GetToken().Token);
                }
            }
            else if (con is RuntimeConstructorInfo && con.ReflectedType.IsArray == false)
            {
                // constructor is not an dynamic field
                
                // We need to get the TypeRef tokens
                tr = GetTypeToken(con.ReflectedType).Token;     
                mr = InternalGetMemberRefOfMethodInfo(tr, con);
            }
            else 
            {
                // some user derived ConstructorInfo
                // go through the slower code path, i.e. retrieve parameters and form signature helper.
                ParameterInfo[] parameters = con.GetParameters();
                Type[] parameterTypes = new Type[parameters.Length];
                for (int i = 0; i < parameters.Length; i++)
                    parameterTypes[i] = parameters[i].ParameterType;                
                tr = GetTypeToken(con.ReflectedType).Token;
                SignatureHelper sigHelp = SignatureHelper.GetMethodSigHelper(
                                            this, 
                                            con.CallingConvention, 
                                            null, 
                                            parameterTypes);
                int length;                                           
                byte[] sigBytes = sigHelp.InternalGetSignature(out length);
                mr = InternalGetMemberRefFromSignature(tr, con.Name, sigBytes, length);                 
            }
            
            return new MethodToken( mr );
        }
    
        /*******************
        *
        * returning the ISymbolWriter associated
        *
        ********************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.GetSymWriter"]/*' />
        
        public ISymbolWriter GetSymWriter()
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            return m_iSymWriter;
        }
        
        /*******************
        *
        * Set the user entry point. Compiler may generate startup stub before calling user main.
        * The startup stub will be the entry point. While the user "main" will be the user entry
        * point so that debugger will not step into the compiler entry point.
        *
        ********************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.SetUserEntryPoint"]/*' />
        
        public void SetUserEntryPoint(
            MethodInfo  entryPoint)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                if (entryPoint == null)
                {
                    throw new ArgumentNullException("entryPoint");
                }
            
                if (m_iSymWriter == null)
                {
                    // Cannot set entry point when it is not a debug module
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
                }
    
                if (entryPoint.DeclaringType != null)
                {
                    if (entryPoint.DeclaringType.Module != this)
                    {
                        // you cannot pass in a MethodInfo that is not contained by this ModuleBuilder
                        throw new InvalidOperationException(Environment.GetResourceString("Argument_NotInTheSameModuleBuilder"));
                    }
                }
                else
                {
                    // unfortunately this check is missing for global function passed in as RuntimeMethodInfo. 
                    // The problem is that Reflection does not 
                    // allow us to get the containing module giving a global function
                    MethodBuilder mb = entryPoint as MethodBuilder;
                    if (mb != null && mb.GetModule() != this)
                    {
                        // you cannot pass in a MethodInfo that is not contained by this ModuleBuilder
                        throw new InvalidOperationException(Environment.GetResourceString("Argument_NotInTheSameModuleBuilder"));                    
                    }                    
                }
                    
                // get the metadata token value and create the SymbolStore's token value class
                SymbolToken       tkMethod = new SymbolToken(GetMethodToken(entryPoint).Token);
    
                // set the UserEntryPoint
                m_iSymWriter.SetUserEntryPoint(tkMethod);
            }
            finally
            {
                Exit();
            }
        }
    
        /*******************
        *
        * Define a document for source
        *
        ********************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineDocument"]/*' />
        
        public ISymbolDocumentWriter DefineDocument(
            String      url,
            Guid        language,
            Guid        languageVendor,
            Guid        documentType)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                if (m_iSymWriter == null)
                {
                    // Cannot DefineDocument when it is not a debug module
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
                }
    
                return m_iSymWriter.DefineDocument(url, language, languageVendor, documentType);
            }
            finally
            {
                Exit();
            }
        }
    
        /*******************
        *
        * This is different from CustomAttribute. This is stored into the SymWriter.
        *
        ********************/
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.SetSymCustomAttribute"]/*' />
        
        public void SetSymCustomAttribute(
            String      name,           // SymCustomAttribute's name
            byte[]     data)           // the data blob
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                if (m_iSymWriter == null)
                {
                    // Cannot SetSymCustomAttribute when it is not a debug module
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
                }
            
                // @review: [meichint] I hard coded token 0 as module token here.
                SymbolToken      tk = new SymbolToken();
                m_iSymWriter.SetSymAttribute(tk, name, data);
            }
            finally
            {
                Exit();
            }
        }
    
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefinePInvokeMethod"]/*' />
        
        public MethodBuilder DefinePInvokeMethod(
            String          name,                   // name of the function of the dll entry
            String          dllName,                // dll containing the PInvoke method
            MethodAttributes attributes,            // Method attributes
            CallingConventions callingConvention,   // calling convention
            Type            returnType,             // return type
            Type[]          parameterTypes,         // parameter type
            CallingConvention   nativeCallConv,     // The native calling convention.
            CharSet             nativeCharSet)      // Method's native character set.
        {
            return DefinePInvokeMethod(name, dllName, name, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
        }
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefinePInvokeMethod1"]/*' />
        
        public MethodBuilder DefinePInvokeMethod(
            String          name,                   // name of the function of the dll entry
            String          dllName,                // dll containing the PInvoke method
            String          entryName,              // entry point's name
            MethodAttributes attributes,            // Method attributes
            CallingConventions callingConvention,   // calling convention
            Type            returnType,             // return type
            Type[]          parameterTypes,         // parameter type
            CallingConvention   nativeCallConv,     // The native calling convention.
            CharSet             nativeCharSet)      // Method's native character set.
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.DefinePInvokeMethodEx( )");
      
                //Global methods must be static.        
                if ((attributes & MethodAttributes.Static)==0) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_GlobalFunctionHasToBeStatic"));
                }
                m_moduleData.m_fHasGlobal = true;
                return m_moduleData.m_globalTypeBuilder.DefinePInvokeMethod(name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
            }
            finally
            {
                Exit();
            }
        }
        

        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.CreateGlobalFunctions"]/*' />
        
        public void CreateGlobalFunctions()
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: ModuleBuilder.CreateGlobalFunctions( )");
            
                if (m_moduleData.m_fGlobalBeenCreated)
                {
                    // cannot create globals twice
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
                }
                m_moduleData.m_globalTypeBuilder.CreateType();
                m_moduleData.m_fGlobalBeenCreated = true;
            }
            finally
            {
                Exit();
            }
        }
    
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.IsTransient"]/*' />
        public bool IsTransient()
        {
            return m_moduleData.IsTransient();
        }
        
        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineUnmanagedResource"]/*' />
        public void DefineUnmanagedResource(
            Byte[]      resource)
        {
            if (m_moduleData.m_strResourceFileName != null ||
                m_moduleData.m_resourceBytes != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            
            if (resource == null)            
                throw new ArgumentNullException("resource");
            
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
        
            m_moduleData.m_resourceBytes = new byte[resource.Length];
            System.Array.Copy(resource, m_moduleData.m_resourceBytes, resource.Length);
            m_moduleData.m_fHasExplicitUnmanagedResource = true;
        }

        /// <include file='doc\ModuleBuilder.uex' path='docs/doc[@for="ModuleBuilder.DefineUnmanagedResource1"]/*' />
        public void DefineUnmanagedResource(
            String      resourceFileName)
        {
			// No resource should have been set already.
            if (m_moduleData.m_strResourceFileName != null ||
                m_moduleData.m_resourceBytes != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            
			// Must have a file name.
            if (resourceFileName == null)            
                throw new ArgumentNullException("resourceFileName");
            
			// Defer to internal implementation.
			DefineUnmanagedResourceFileInternal(resourceFileName);
            m_moduleData.m_fHasExplicitUnmanagedResource = true;
        }
        
        internal void DefineUnmanagedResourceFileInternal(
            String      resourceFileName)
        {
			// Shouldn't have resource bytes, but a previous file is OK, because assemblyBuilder.Save
			//  creates then deletes a temp file.
            if (m_moduleData.m_resourceBytes != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            
            if (resourceFileName == null)            
                throw new ArgumentNullException("resourceFileName");
            
            if (m_moduleData.m_fHasExplicitUnmanagedResource)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
                                                               
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            // Check caller has the right to read the file.
            string strFullFileName;
            strFullFileName = Path.GetFullPath(resourceFileName);
            new FileIOPermission(FileIOPermissionAccess.Read, strFullFileName).Demand();
            
            new EnvironmentPermission(PermissionState.Unrestricted).Assert();
            try {
                if (File.Exists(resourceFileName) == false)
                    throw new FileNotFoundException(String.Format(Environment.GetResourceString(
                        "IO.FileNotFound_FileName"),
                        resourceFileName), resourceFileName);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
                                                    
            m_moduleData.m_strResourceFileName = strFullFileName;
        }
        
        /**********************************************
         * Empty private constructor to prevent user from instansiating an instance
        **********************************************/ 
        private ModuleBuilder()
        {
        }

        /**********************************************
         * If the instance of the containing assembly builder is
         * to be synchronized, obtain the lock.
         **********************************************/ 
        internal void Enter()
        {
            Assembly.m_assemblyData.Enter();
        }
        
        /**********************************************
         * If the instance of the containing assembly builder is
         * to be synchronized, free the lock.
         **********************************************/ 
        internal void Exit()
        {
            Assembly.m_assemblyData.Exit();
        }

        internal void Init(
            String             strModuleName,
            String             strFileName,
            ISymbolWriter      writer)
        {
            m_moduleData = new ModuleBuilderData(this, strModuleName, strFileName);
            m_TypeBuilderList = new ArrayList();    
            m_iSymWriter = writer;

            if (writer != null)
            {
                // Set the underlying writer for the managed writer
                // that we're using.  Note that this function requires
                // unmanaged code access.
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
                writer.SetUnderlyingWriter(m_pInternalSymWriter);
            }
        }

        // Gets the original type name, without '+' name mangling.
        static internal String UnmangleTypeName(String typeName)
        {
            int i = typeName.Length-1;
            while(true) {
                i = typeName.LastIndexOf('+', i);
                if (i == -1)
                    break;

                bool evenSlashes = true;
                int iSlash = i;
                while (typeName[--iSlash] == '\\')
                    evenSlashes = !evenSlashes;

                // Even number of slashes means this '+' is a name separator
                if (evenSlashes)
                    break;

                i = iSlash;
            }

            return typeName.Substring(i+1);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\ilgenerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ILGenerator
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The class which knows how to generate a byte stream containing
**          each of the IL instructions
**
** Date:  November 16, 1998
**
===========================================================*/
namespace System.Reflection.Emit {
	using System;
	using TextWriter = System.IO.TextWriter;
	using System.Diagnostics.SymbolStore;
    using System.Runtime.InteropServices;
	using System.Reflection;
    /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator"]/*' />
    public class ILGenerator {

        internal const byte PrefixInstruction = (byte)0xFF;

        internal const int  defaultSize=16;
        internal const int  DefaultFixupArraySize = 64;
        internal const int  DefaultLabelArraySize = 16;
        internal const int  DefaultExceptionArraySize = 8;

        internal int        m_length;
        internal byte[]     m_ILStream;

        internal int[]      m_labelList;
        internal int        m_labelCount;

        internal __FixupData[] m_fixupData;
        //internal Label[]    m_fixupLabel;
        //internal int[]      m_fixupPos;

        // @todo: [meichint]
        // we can remove this list by storing the skipping bytes in the fixup itself
        //internal int[]      m_fixupInstSize;
        internal int        m_fixupCount;

        internal int[]      m_RVAFixupList;
        internal int        m_RVAFixupCount;

        internal int[]      m_RelocFixupList;
        internal int        m_RelocFixupCount;

        internal int        m_exceptionCount;
        internal int        m_currExcStackCount;
        internal __ExceptionInfo[] m_exceptions;        //This is the list of all of the exceptions in this ILStream.
        internal __ExceptionInfo[] m_currExcStack;      //This is the stack of exceptions which we're currently in.


        internal ScopeTree  m_ScopeTree;                // this variable tracks all debugging scope information
        internal LineNumberInfo m_LineNumberInfo;       // this variable tracks all line number information

        internal MethodBuilder m_methodBuilder;
        internal int	    m_localCount;
        internal SignatureHelper m_localSignature;

		internal int m_maxStackSize = 0;				// Maximum stack size not counting the exceptions.

		internal int m_maxMidStack = 0;					// Maximum stack size for a given basic block.
		internal int m_maxMidStackCur = 0;				// Running count of the maximum stack size for the current basic block.

        // Puts opcode onto the stream of instructions.
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit"]/*' />
        public virtual void Emit(OpCode opcode) {
			EnsureCapacity(3);
			internalEmit(opcode);

		}

		private void internalEmit(OpCode opcode)
		{
            if (opcode.m_size == 1) {
                m_ILStream[m_length++] = opcode.m_s2;
            } else {
                m_ILStream[m_length++] = opcode.m_s1;
                m_ILStream[m_length++] = opcode.m_s2;
            }

			UpdateStackSize(opcode, opcode.StackChange());

		}

		// Updates internal variables for keeping track of the stack size
		// requirements for the function.  stackchange specifies the amount
		// by which the stacksize needs to be updated.
		internal void UpdateStackSize(OpCode opcode, int stackchange)
		{
			// Special case for the Return.  Returns pops 1 if there is a
			// non-void return value.

			// @todo This is way to expensive for what we gain
			// I am taking it out for now
			//if (opcode.Equals(OpCodes.Ret) &&
			//	(m_methodBuilder.ReturnType != typeof(Void)))
			//{
			//	stackchange--;
			//}

			// Update the running stacksize.  m_maxMidStack specifies the maximum
			// amount of stack required for the current basic block irrespective of
			// where you enter the block.
			m_maxMidStackCur += stackchange;
			if (m_maxMidStackCur > m_maxMidStack)
				m_maxMidStack = m_maxMidStackCur;
			else if (m_maxMidStackCur < 0)
				m_maxMidStackCur = 0;

			// If the current instruction signifies end of a basic, which basically
			// means an unconditional branch, add m_maxMidStack to m_maxStackSize.
			// m_maxStackSize will eventually be the sum of the stack requirements for
			// each basic block.
			if (opcode.EndsUncondJmpBlk())
			{
				m_maxStackSize += m_maxMidStack;
				m_maxMidStack = 0;
				m_maxMidStackCur = 0;
			}
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit1"]/*' />
        public virtual void Emit(OpCode opcode, byte arg) {
            EnsureCapacity(4);
            internalEmit(opcode);
            m_ILStream[m_length++]=arg;
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
            /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit2"]/*' />
        [CLSCompliant(false)]
            public void Emit(OpCode opcode, sbyte arg) {
            EnsureCapacity(4);
            internalEmit(opcode);
			// @COOLPORT: Fix this
            if (arg<0) {
                m_ILStream[m_length++]=(byte)(256+arg);
            } else {
                m_ILStream[m_length++]=(byte) arg;
            }
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit3"]/*' />
        public virtual void Emit(OpCode opcode, short arg) {
            EnsureCapacity(5);
            internalEmit(opcode);
            m_ILStream[m_length++]=(byte)(arg&0xFF);
            m_ILStream[m_length++]=(byte)((arg&0xFF00)>>8);
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit4"]/*' />
        public virtual void Emit(OpCode opcode, int arg) {
            EnsureCapacity(7);
            internalEmit(opcode);
            m_length=PutInteger4(arg, m_length, m_ILStream);
        }

        //***********************************************
        //
        // Puts <VAR>opcode</VAR> onto the stream and then the metadata token represented
        // by <VAR>meth</VAR>.  The location of <VAR>meth</VAR> is recorded so that the token can be
        // patched if necessary when persisting the module to a PE.
        // @param opcode The IL instruction to be emitted onto the stream.
        // @param meth A MethodToken representing the metadata token for this method.
        //
        //***********************************************


        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit5"]/*' />
        public virtual void Emit(OpCode opcode, MethodInfo meth)
        {
			int	stackchange = 0;

            if (meth == null)
                throw new ArgumentNullException("meth");

            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            int tempVal = modBuilder.GetMethodToken( meth ).Token;

            EnsureCapacity(7);
            internalEmit(opcode);

			// The only IL instructions that have a Varpush stack behaviour
			// that take a Method token as an operand are, call and callvirt.
			// Push one if there is a non-void return value.
			if (opcode.m_push == StackBehaviour.Varpush)
			{
				BCLDebug.Assert(opcode.Equals(OpCodes.Call) ||
								opcode.Equals(OpCodes.Callvirt),
								"Unexpected opcode encountered for StackBehaviour of VarPush.");
				if (meth.ReturnType != typeof(void))
					stackchange++;
			}
			// The only IL instructions that have a Varpop stack behaviour and that
			// take a MethodToken as an operand are call, callvirt and newobj.  Pop the
			// parameters including "this" if there is  one.  Do not pop the this
			// parameter for newobj instruction.
			if (opcode.m_pop == StackBehaviour.Varpop)
			{
				BCLDebug.Assert(opcode.Equals(OpCodes.Call) ||
								opcode.Equals(OpCodes.Callvirt) ||
								opcode.Equals(OpCodes.Newobj),
								"Unexpected opcode encountered for StackBehaviour of VarPush.");
				if (meth is MethodBuilder)
				{
					if (((MethodBuilder)meth).GetParameterTypes() != null)
						stackchange -= ((MethodBuilder)meth).GetParameterTypes().Length;
				}
				else if (meth is SymbolMethod)
				{
					if (((SymbolMethod)meth).GetParameterTypes() != null)
						stackchange -= ((SymbolMethod)meth).GetParameterTypes().Length;
				}
				else if (meth.GetParameters() != null)
					stackchange -= meth.GetParameters().Length;
				if (!(meth is SymbolMethod) && meth.IsStatic == false && !(opcode.Equals(OpCodes.Newobj)))
					stackchange--;
			}
			UpdateStackSize(opcode, stackchange);
            RecordTokenFixup();
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }

        //***********************************************
        //
        // Emit calli instructions
        //
        //***********************************************
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitCalli"]/*' />
        public void EmitCalli(
            OpCode          opcode,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes,
            Type[]          optionalParameterTypes)
        {
			int stackchange = 0;
            SignatureHelper     sig;
            if (optionalParameterTypes != null)
            {
                if ((callingConvention & CallingConventions.VarArgs) == 0)
                {
                    // This is bad! Client should not supply optional parameter in default calling convention
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotAVarArgCallingConvention"));
                }
            }

            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            sig = GetVarArgSignature(callingConvention,
                                     returnType,
                                     parameterTypes,
                                     optionalParameterTypes);

            EnsureCapacity(7);
            Emit(OpCodes.Calli);

			// The opcode passed in must be the calli instruction.
			BCLDebug.Assert(opcode.Equals(OpCodes.Calli),
							"Unexpected opcode passed to EmitCalli.");
			// If there is a non-void return type, push one.
			if (returnType != typeof(void))
				stackchange++;
			// Pop off arguments if any.
			if (parameterTypes != null)
				stackchange -= parameterTypes.Length;
			// Pop off vararg arguments.
			if (optionalParameterTypes != null)
				stackchange -= optionalParameterTypes.Length;
			// Pop the this parameter if the method has a this parameter.
            if ((callingConvention & CallingConventions.HasThis) == CallingConventions.HasThis)
				stackchange--;
			// Pop the native function pointer.
			stackchange--;
			UpdateStackSize(opcode, stackchange);

            RecordTokenFixup();
            m_length=PutInteger4(modBuilder.GetSignatureToken(sig).Token, m_length, m_ILStream);
        }
        
        //***********************************************
        //
        // Emit calli instructions taking a unmanaged calling convention
        // System.Runtime.InteropServices such as STDCALL, CDECL,..
        //
        //***********************************************
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitCalli1"]/*' />
        public void EmitCalli(
            OpCode          opcode,
            CallingConvention unmanagedCallConv,
            Type            returnType,
            Type[]          parameterTypes)
        {
			int             stackchange = 0;
            int             cParams = 0;
            int             i;
            SignatureHelper sig;
            
            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();

			// The opcode passed in must be the calli instruction.
			BCLDebug.Assert(opcode.Equals(OpCodes.Calli),
							"Unexpected opcode passed to EmitCalli.");
            if (parameterTypes != null)
            {
                cParams = parameterTypes.Length;
            }
            
            sig = SignatureHelper.GetMethodSigHelper(
                m_methodBuilder.GetModule(), 
                unmanagedCallConv, 
                returnType);
                            
            if (parameterTypes != null)
            {
                for (i = 0; i < cParams; i++) 
                {
                    sig.AddArgument(parameterTypes[i]);
                }
            }
                                  
			// If there is a non-void return type, push one.
			if (returnType != typeof(void))
				stackchange++;
                
			// Pop off arguments if any.
			if (parameterTypes != null)
				stackchange -= cParams;
                
			// Pop the native function pointer.
			stackchange--;
			UpdateStackSize(opcode, stackchange);

            EnsureCapacity(7);
            Emit(OpCodes.Calli);
            RecordTokenFixup();
            m_length=PutInteger4(modBuilder.GetSignatureToken(sig).Token, m_length, m_ILStream);
        }
                  

        //***********************************************
        //
        // Emit call instructions
        //
        //***********************************************
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitCall"]/*' />
        public void EmitCall(
            OpCode      opcode,                     // call instruction, such as call, callvirt, calli
            MethodInfo  methodInfo,                 // target method
            Type[]      optionalParameterTypes)     // optional parameters if methodInfo is a vararg method
        {
            int         tk;
			int			stackchange = 0;

            if (methodInfo == null)
                throw new ArgumentNullException("methodInfo");

            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            tk = GetVarArgMemberRefToken(methodInfo, optionalParameterTypes);

            EnsureCapacity(7);
            internalEmit(opcode);

			// The opcode must be one of call, callvirt, or newobj.
			BCLDebug.Assert(opcode.Equals(OpCodes.Call) ||
							opcode.Equals(OpCodes.Callvirt) ||
							opcode.Equals(OpCodes.Newobj),
							"Unexpected opcode passed to EmitCall.");
			// Push the return value if there is one.
			if (methodInfo.ReturnType != typeof(void))
				stackchange++;
			// Pop the parameters.
			if (methodInfo is MethodBuilder)
			{
				if (((MethodBuilder)methodInfo).GetParameterTypes() != null)
					stackchange -= ((MethodBuilder)methodInfo).GetParameterTypes().Length;
			}
			else if (methodInfo is SymbolMethod)
			{
				if (((SymbolMethod)methodInfo).GetParameterTypes() != null)
					stackchange -= ((SymbolMethod)methodInfo).GetParameterTypes().Length;
			}
			else if (methodInfo.GetParameters() != null)
				stackchange -= methodInfo.GetParameters().Length;
			// Pop the this parameter if the method is non-static and the
			// instruction is not newobj.
			if (!(methodInfo is SymbolMethod) && methodInfo.IsStatic == false && !(opcode.Equals(OpCodes.Newobj)))
				stackchange--;
			// Pop the optional parameters off the stack.
			if (optionalParameterTypes != null)
				stackchange -= optionalParameterTypes.Length;
			UpdateStackSize(opcode, stackchange);

            RecordTokenFixup();
            m_length=PutInteger4(tk, m_length, m_ILStream);
        }

        internal int GetVarArgMemberRefToken(MethodInfo methodInfo, Type[] optionalParameterTypes)
        {
            Type[]          parameterTypes;
            ParameterInfo[] paramInfo;
            SignatureHelper sig;
            int             i;
            int             sigLength;
            byte[]          sigBytes;
            int             tkParent;
            ModuleBuilder   modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();

            if (optionalParameterTypes != null)
            {
                if ((methodInfo.CallingConvention & CallingConventions.VarArgs) == 0)
                {
                    // This is bad! Client should not supply optional parameter in default calling convention
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotAVarArgCallingConvention"));
                }
            }
            if (methodInfo is MethodBuilder)
            {
                parameterTypes = ((MethodBuilder) methodInfo).GetParameterTypes();
            }
            else if (methodInfo is SymbolMethod)
            {
                parameterTypes = ((SymbolMethod) methodInfo).GetParameterTypes();
            }
            else
            {
                paramInfo = methodInfo.GetParameters();
                if (paramInfo != null && paramInfo.Length != 0)
                {
                    parameterTypes = new Type[paramInfo.Length];
                    for (i=0; i < paramInfo.Length; i++)
                    {
                        parameterTypes[i] = paramInfo[i].ParameterType;
                    }
                }
                else
                    parameterTypes = null;
            }

            sig = GetVarArgSignature(methodInfo.CallingConvention,
                                     methodInfo.ReturnType,
                                     parameterTypes,
                                     optionalParameterTypes);
            sigBytes = sig.InternalGetSignature(out sigLength);
            if (methodInfo.DeclaringType.Module == modBuilder)
            {
                // We want to put the MethodDef token as the parent token
                tkParent = modBuilder.GetMethodToken(methodInfo).Token;
            }
            else
            {
                tkParent = modBuilder.GetTypeToken(methodInfo.DeclaringType).Token;
            }
            return modBuilder.InternalGetMemberRefFromSignature(tkParent, methodInfo.Name, sigBytes, sigLength);
        }

        internal SignatureHelper GetVarArgSignature(
            CallingConventions  call,
            Type                returnType,
            Type[]              parameterTypes,
            Type[]              optionalParameterTypes)
        {
            int             cParams;
            int             i;
            SignatureHelper sig;
            if (parameterTypes == null)
            {
                cParams = 0;
            }
            else
            {
                cParams = parameterTypes.Length;
            }
            sig = SignatureHelper.GetMethodSigHelper(m_methodBuilder.GetModule(), call, returnType);
            for (i=0; i < cParams; i++)
            {
                sig.AddArgument(parameterTypes[i]);
            }
            if (optionalParameterTypes != null && optionalParameterTypes.Length != 0)
            {
                // add the sentinel
                sig.AddSentinel();
                for (i=0; i < optionalParameterTypes.Length; i++)
                {
                    sig.AddArgument(optionalParameterTypes[i]);
                }
            }
            return sig;
        }


        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit6"]/*' />
        public virtual void Emit(OpCode opcode, SignatureHelper signature)
        {
			int stackchange = 0;
            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            if (signature == null)
                throw new ArgumentNullException("signature");

            SignatureToken sig = modBuilder.GetSignatureToken(signature);

            int tempVal = sig.Token;

            EnsureCapacity(7);
            internalEmit(opcode);

			// The only IL instruction that has VarPop behaviour, that takes a
			// Signature token as a parameter is calli.  Pop the parameters and
			// the native function pointer.  To be conservative, do not pop the
			// this pointer since this information is not easily derived from
			// SignatureHelper.
			if (opcode.m_pop == StackBehaviour.Varpop)
			{
				BCLDebug.Assert(opcode.Equals(OpCodes.Calli),
								"Unexpected opcode encountered for StackBehaviour VarPop.");
				// Pop the arguments..
				stackchange -= signature.m_argCount;
				// Pop native function pointer off the stack.
				stackchange--;
				UpdateStackSize(opcode, stackchange);
			}

            RecordTokenFixup();
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit7"]/*' />
        public virtual void Emit(OpCode opcode, ConstructorInfo con) {
			int stackchange = 0;

            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            int tempVal = modBuilder.GetConstructorToken( con ).Token;

            EnsureCapacity(7);
            internalEmit(opcode);

			// Make a conservative estimate by assuming a return type and no
			// this parameter.
			if (opcode.m_push == StackBehaviour.Varpush)
			{
				// Instruction must be one of call or callvirt.
				BCLDebug.Assert(opcode.Equals(OpCodes.Call) ||
								opcode.Equals(OpCodes.Callvirt),
								"Unexpected opcode encountered for StackBehaviour of VarPush.");
				stackchange++;
			}
			if (opcode.m_pop == StackBehaviour.Varpop)
			{
				// Instruction must be one of call, callvirt or newobj.
				BCLDebug.Assert(opcode.Equals(OpCodes.Call) ||
								opcode.Equals(OpCodes.Callvirt) ||
								opcode.Equals(OpCodes.Newobj),
								"Unexpected opcode encountered for StackBehaviour of VarPop.");
				if (con is RuntimeConstructorInfo)
				{
					if (con.GetParameters() != null)
						stackchange -= con.GetParameters().Length;
				}
				else if (con is ConstructorBuilder)
				{
					if (((ConstructorBuilder)con).m_methodBuilder.GetParameterTypes() != null)
						stackchange -= ((ConstructorBuilder)con).m_methodBuilder.GetParameterTypes().Length;
				}
				else
					BCLDebug.Assert(false, "Unexpected type of ConstructorInfo encountered.");
			}
			UpdateStackSize(opcode, stackchange);

            RecordTokenFixup();
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }

        // Puts opcode onto the stream and then the metadata token represented
        // by cls.  The location of cls is recorded so that the token can be
        // patched if necessary when persisting the module to a PE.
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit8"]/*' />
        public virtual void Emit(OpCode opcode, Type cls)
        {
            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            int tempVal = modBuilder.GetTypeToken( cls ).Token;

            EnsureCapacity(7);
            internalEmit(opcode);
            RecordTokenFixup();
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit9"]/*' />
        public virtual void Emit(OpCode opcode, long arg) {
            EnsureCapacity(11);
            internalEmit(opcode);
            m_ILStream[m_length++]=(byte)(arg&0xFF);
            m_ILStream[m_length++]=(byte)((arg&0x00FF00)>>8);
            m_ILStream[m_length++] = (byte)((arg&0x0000000000FF0000L)>>16);
            m_ILStream[m_length++] = (byte)((arg&0x00000000FF000000L)>>24);
            m_ILStream[m_length++] = (byte)((arg&0x000000FF00000000L)>>32);
            m_ILStream[m_length++] = (byte)((arg&0x0000FF0000000000L)>>40);
            m_ILStream[m_length++] = (byte)((arg&0x00FF000000000000L)>>48);
            m_ILStream[m_length++] = (byte)((unchecked((ulong)arg)&0xFF00000000000000uL)>>56);
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit10"]/*' />
        public virtual void Emit(OpCode opcode, float arg) {
            EnsureCapacity(7);
            internalEmit(opcode);
            byte[] b = BitConverter.GetBytes(arg);
            for (int i=0; i<4; i++) {
                m_ILStream[m_length++]=(byte)b[i];
            }
        }

        // Puts opcode onto the stream of instructions followed
        // by arg
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit11"]/*' />
        public virtual void Emit(OpCode opcode, double arg) {
            EnsureCapacity(11);
            internalEmit(opcode);
            byte[] b = BitConverter.GetBytes(arg);
            for (int i=0; i<8; i++) {
                m_ILStream[m_length++]=b[i];
            }
        }

        // Puts opcode onto the stream and leaves space to include label
        // when fixups are done.  Labels are created using ILGenerator.DefineLabel and
        // their location within the stream is fixed by using ILGenerator.MarkLabel.
        // If a single-byte instruction (designated by the _S suffix in OpCodes.cool) is used,
        // the label can represent a jump of at most 127 bytes along the stream.
        //
        // opcode must represent a branch instruction (although we don't explicitly
        // verify this).  Since branches are relative instructions, label will be replaced with the
        // correct offset to branch during the fixup process.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit12"]/*' />
        public virtual void Emit(OpCode opcode, Label label) {
            int tempVal = label.GetLabelValue();
            EnsureCapacity(7);

            //@todo Craig OPCODESWORK
            internalEmit(opcode);
            if (OpCodes.TakesSingleByteArgument(opcode)) {
                AddFixup(label, m_length, 1);
                m_length++;
            } else {
                AddFixup(label, m_length, 4);
                m_length+=4;
            }
        }

        // Emitting a switch table
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit13"]/*' />
        public virtual void Emit(
                                 OpCode       opcode,
                                 Label[]     labels)             // array of labels. All of the labels will be used
        {
            int i;
            int remaining;                  // number of bytes remaining for this switch instruction to be substracted
            // for computing the offset

            int count = labels.Length;

            EnsureCapacity( count * 4 + 7 );
            internalEmit(opcode);
            m_length = PutInteger4( count, m_length, m_ILStream );
            for ( remaining = count * 4, i = 0; remaining > 0; remaining -= 4, i++ ) {
                AddFixup( labels[i], m_length, remaining );
                m_length += 4;
            }
        }


        // Emit the instruction which takes a field
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit14"]/*' />
        public virtual void Emit(OpCode opcode, FieldInfo field)
        {
            
            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            int tempVal = modBuilder.GetFieldToken( field ).Token;
            EnsureCapacity(7);
            internalEmit(opcode);
            RecordTokenFixup();
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }


        // Puts the opcode onto the IL stream followed by the metadata token
        // represented by str.  The location of str is recorded for future
        // fixups if the module is persisted to a PE.

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit15"]/*' />
        public virtual void Emit(OpCode opcode, String str) {
            ModuleBuilder modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();
            int tempVal = modBuilder.GetStringConstant(str).Token;
            EnsureCapacity(7);
            internalEmit(opcode);
            m_length=PutInteger4(tempVal, m_length, m_ILStream);
        }


        // Puts the opcode onto the IL stream followed by the information for
        // local variable local.
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.Emit16"]/*' />
        public virtual void Emit(OpCode opcode, LocalBuilder local)
        {
            if (local == null)
            {
                throw new ArgumentNullException("local");
            }
            int tempVal = local.GetLocalIndex();
            if (local.GetMethodBuilder() != m_methodBuilder)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnmatchedMethodForLocal"), "local");
            }
			// If the instruction is a ldloc, ldloca a stloc, morph it to the optimal form.
			if (opcode.Equals(OpCodes.Ldloc))
			{
				switch(tempVal)
				{
					case 0:
						opcode = OpCodes.Ldloc_0;
						break;
					case 1:
						opcode = OpCodes.Ldloc_1;
						break;
					case 2:
						opcode = OpCodes.Ldloc_2;
						break;
					case 3:
						opcode = OpCodes.Ldloc_3;
						break;
					default:
						if (tempVal <= 255)
							opcode = OpCodes.Ldloc_S;
						break;
				}
			}
			else if (opcode.Equals(OpCodes.Stloc))
			{
				switch(tempVal)
				{
					case 0:
						opcode = OpCodes.Stloc_0;
						break;
					case 1:
						opcode = OpCodes.Stloc_1;
						break;
					case 2:
						opcode = OpCodes.Stloc_2;
						break;
					case 3:
						opcode = OpCodes.Stloc_3;
						break;
					default:
						if (tempVal <= 255)
							opcode = OpCodes.Stloc_S;
						break;
				}
			}
			else if (opcode.Equals(OpCodes.Ldloca))
			{
				if (tempVal <= 255)
					opcode = OpCodes.Ldloca_S;
			}

            EnsureCapacity(7);
            internalEmit(opcode);
            // @todo Craig OPCODESWORK
			if (opcode.OperandType == OperandType.InlineNone)
				return;
            else if (!OpCodes.TakesSingleByteArgument(opcode))
            {
                m_ILStream[m_length++]=(byte)(tempVal&0xFF);
                m_ILStream[m_length++]=(byte)((tempVal&0xFF00)>>8);
            }
            else
            {
                //Handle stloc_1, ldloc_1
                if (tempVal > Byte.MaxValue)
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadInstructionOrIndexOutOfBound"));
                }
                m_ILStream[m_length++]=(byte)tempVal;
            }
        }


        // Appends the given bytes to the end of the current stream.  Does not support fixups.
        //
        internal virtual void Append (byte []value) {
            Append(value, 0, value.Length);
        }

        internal virtual void Append (byte [] value, int startIndex, int length) {
            if (value==null || startIndex<0 || length<0 || startIndex > value.Length - length) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadILGeneratorUsage"));
            }
            EnsureCapacity(m_length + length);
            Array.Copy(value, startIndex, m_ILStream, m_length, length);
            m_length+=length;
        }


        // Begin an Exception block.  Creating an Exception block records some information,
        // but does not actually emit any IL onto the stream.  Exceptions should be created and
        // marked in the following form:
        //
        // Emit Some IL
        // BeginExceptionBlock
        // Emit the IL which should appear within the "try" block
        // BeginCatchBlock
        // Emit the IL which should appear within the "catch" block
        // Optional: BeginCatchBlock (this can be repeated an arbitrary number of times
        // EndExceptionBlock
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginExceptionBlock"]/*' />
        public virtual Label BeginExceptionBlock() {

			// Delay init
			if (m_exceptions == null)
			{
				m_exceptions = new __ExceptionInfo[DefaultExceptionArraySize];
			}

			if (m_currExcStack == null)
			{
				m_currExcStack = new __ExceptionInfo[DefaultExceptionArraySize];
			}

            if (m_exceptionCount>=m_exceptions.Length) {
                m_exceptions=EnlargeArray(m_exceptions);
            }

            if (m_currExcStackCount>=m_currExcStack.Length) {
                m_currExcStack = EnlargeArray(m_currExcStack);
            }

            Label endLabel = DefineLabel();
            __ExceptionInfo exceptionInfo = new __ExceptionInfo(m_length, endLabel);

            // add the exception to the tracking list
            m_exceptions[m_exceptionCount++] = exceptionInfo;

            // Make this exception the current active exception
            m_currExcStack[m_currExcStackCount++] = exceptionInfo;
            return endLabel;
        }


        // End an Exception block.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EndExceptionBlock"]/*' />
        public virtual void EndExceptionBlock() {
            if (m_currExcStackCount==0) {
                throw new NotSupportedException(Environment.GetResourceString("Argument_NotInExceptionBlock"));
            }

           // Pop the current exception block
            __ExceptionInfo current = m_currExcStack[m_currExcStackCount-1];
            m_currExcStack[m_currExcStackCount-1] = null;
            m_currExcStackCount--;

            Label endLabel = current.GetEndLabel();
            int state = current.GetCurrentState();

            if (state == __ExceptionInfo.State_Filter ||
				state == __ExceptionInfo.State_Try)
            {
                // This is a bad state to end an Exception block
                // @todo: better exception
                throw new InvalidOperationException(Environment.GetResourceString("Argument_BadExceptionCodeGen"));
            }

            if (state == __ExceptionInfo.State_Catch) {
                this.Emit(OpCodes.Leave, endLabel);
            } else if (state == __ExceptionInfo.State_Finally || state == __ExceptionInfo.State_Fault) {
                this.Emit(OpCodes.Endfinally);
            }

            //Check if we've alredy set this label.
            //The only reason why we might have set this is if we have a finally block.
            if (m_labelList[endLabel.GetLabelValue()]==-1) {
                MarkLabel(endLabel);
            } else {
                MarkLabel(current.GetFinallyEndLabel());
            }

            current.Done(m_length);
        }

        // Begins a eception filter block.  Emits a branch instruction to the end of the current exception
        // block.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginExceptFilterBlock"]/*' />
        public virtual void BeginExceptFilterBlock() {
            if (m_currExcStackCount==0) {
                throw new NotSupportedException(Environment.GetResourceString("Argument_NotInExceptionBlock"));
            }

    		__ExceptionInfo current = m_currExcStack[m_currExcStackCount-1];

            Label endLabel = current.GetEndLabel();
            this.Emit(OpCodes.Leave, endLabel);

            current.MarkFilterAddr(m_length);
        }

        // Begins a catch block.  Emits a branch instruction to the end of the current exception
        // block.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginCatchBlock"]/*' />
        public virtual void BeginCatchBlock(Type exceptionType) {
            if (m_currExcStackCount==0) {
                throw new NotSupportedException(Environment.GetResourceString("Argument_NotInExceptionBlock"));
            }
            __ExceptionInfo current = m_currExcStack[m_currExcStackCount-1];

            if (current.GetCurrentState() == __ExceptionInfo.State_Filter) {
                if (exceptionType != null) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_ShouldNotSpecifyExceptionType"));
                }

                this.Emit(OpCodes.Endfilter);
            } else {
                // execute this branch if previous clause is Catch or Fault
                if (exceptionType==null) {
                    throw new ArgumentNullException("exceptionType");
                }

                Label endLabel = current.GetEndLabel();
                this.Emit(OpCodes.Leave, endLabel);

            }

            current.MarkCatchAddr(m_length, exceptionType);
        }

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginFaultBlock"]/*' />
        public virtual void BeginFaultBlock()
        {
            if (m_currExcStackCount==0) {
                throw new NotSupportedException(Environment.GetResourceString("Argument_NotInExceptionBlock"));
            }
            __ExceptionInfo current = m_currExcStack[m_currExcStackCount-1];

            // emit the leave for the clause before this one.
            Label endLabel = current.GetEndLabel();
            this.Emit(OpCodes.Leave, endLabel);

            current.MarkFaultAddr(m_length);
        }

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginFinallyBlock"]/*' />
        public virtual void BeginFinallyBlock() {
            if (m_currExcStackCount==0) {
                throw new NotSupportedException(Environment.GetResourceString("Argument_NotInExceptionBlock"));
            }
            __ExceptionInfo current = m_currExcStack[m_currExcStackCount-1];
            int         state = current.GetCurrentState();
            Label       endLabel = current.GetEndLabel();
            int         catchEndAddr = 0;
            if (state != __ExceptionInfo.State_Try)
            {
                // generate leave for any preceeding catch clause
                this.Emit(OpCodes.Leave, endLabel);                
                catchEndAddr = m_length;
            }
            
            MarkLabel(endLabel);


            Label finallyEndLabel = this.DefineLabel();
            current.SetFinallyEndLabel(finallyEndLabel);
            
            // generate leave for try clause                                                  
            this.Emit(OpCodes.Leave, finallyEndLabel);
            if (catchEndAddr == 0)
                catchEndAddr = m_length;
            current.MarkFinallyAddr(m_length, catchEndAddr);
        }

        // Declares a new Label.  This is just a token and does not yet represent any particular location
        // within the stream.  In order to set the position of the label within the stream, you must call
        // Mark Label.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.DefineLabel"]/*' />
        public virtual Label DefineLabel() {

			// Delay init the lable array in case we dont use it
			if (m_labelList == null){
				m_labelList = new int[DefaultLabelArraySize];
			}

            if (m_labelCount>=m_labelList.Length) {
                m_labelList = EnlargeArray(m_labelList);
            }
            m_labelList[m_labelCount]=-1;
            return new Label(m_labelCount++);
        }

        // Defines a label by setting the position where that label is found within the stream.
        // Does not allow a label to be defined more than once.
        //
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.MarkLabel"]/*' />
        public virtual void MarkLabel(Label loc) {
            int labelIndex = loc.GetLabelValue();

            //This should never happen.
            if (labelIndex<0 || labelIndex>=m_labelList.Length) {
                throw new ArgumentException (Environment.GetResourceString("Argument_InvalidLabel"));
            }

            if (m_labelList[labelIndex]!=-1) {
                throw new ArgumentException (Environment.GetResourceString("Argument_RedefinedLabel"));
            }

            m_labelList[labelIndex]=m_length;
        }

        // BakeByteArray is a package private function designed to be called by MethodDefinition to do
        // all of the fixups and return a new byte array representing the byte stream with labels resolved, etc.
        //
        //@ToDo:  Do we want to mark this class once we've baked the byte array s.t. they can't use it again?
        internal virtual byte[] BakeByteArray() {
            int newSize;
            int updateAddr;
            byte []newBytes;

            if (m_currExcStackCount!=0) {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnclosedExceptionBlock"));
            }
    		if (m_length == 0)
    			return null;

            //Calculate the size of the new array.
            newSize = m_length;

            //Allocate space for the new array.
            newBytes = new byte[newSize];

            //Copy the data from the old array
            Array.Copy(m_ILStream, newBytes, newSize);

            //Do the fixups.
            //This involves iterating over all of the labels and
            //replacing them with their proper values.
            for (int i=0; i < m_fixupCount; i++) {
                updateAddr = GetLabelPos(m_fixupData[i].m_fixupLabel) - (m_fixupData[i].m_fixupPos + m_fixupData[i].m_fixupInstSize);

                //Handle single byte instructions
                //Throw an exception if they're trying to store a jump in a single byte instruction that doesn't fit.
                if (m_fixupData[i].m_fixupInstSize == 1) {

                    //Verify that our one-byte arg will fit into a Signed Byte.
                    if (updateAddr<SByte.MinValue || updateAddr>SByte.MaxValue) {

                        throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_IllegalOneByteBranch"),m_fixupData[i].m_fixupPos, updateAddr));
                    }

                    //Place the one-byte arg
                    if (updateAddr<0) {
                        //This is a hack to give the same byte pattern as a signed byte to an unsigned quantity.
                        newBytes[m_fixupData[i].m_fixupPos] = (byte)(256+updateAddr);
                    } else {
                        newBytes[m_fixupData[i].m_fixupPos] = (byte)updateAddr;
                    }
                } else {
                    //Place the four-byte arg
                    PutInteger4(updateAddr, m_fixupData[i].m_fixupPos, newBytes);
                }
            }
            return newBytes;
        }


        //
        //
        internal virtual __ExceptionInfo[] GetExceptions() {
            __ExceptionInfo []temp;
            if (m_currExcStackCount!=0) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.Argument_UnclosedExceptionBlock));
            }
            
            if (m_exceptionCount == 0)
            {
				return null;
			}
            
            temp = new __ExceptionInfo[m_exceptionCount];
            Array.Copy(m_exceptions, temp, m_exceptionCount);
            SortExceptions(temp);
            return temp;
        }

        //
        // Macros
        //
        // These are helper functions to do common things without having to write all of
        // the il for them.

        // Emits the il to throw an exception
    	//
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.ThrowException"]/*' />
        public virtual void ThrowException(Type excType) {
            if (excType==null) {
                throw new ArgumentNullException("excType");
            }

    		ModuleBuilder  modBuilder = (ModuleBuilder) m_methodBuilder.GetModule();

            if (!excType.IsSubclassOf(typeof(Exception)) && excType!=typeof(Exception)) {
                throw new ArgumentException(Environment.GetResourceString("Argument_NotExceptionType"));
            }
            ConstructorInfo con = excType.GetConstructor(Type.EmptyTypes);
            if (con==null) {
                throw new ArgumentException(Environment.GetResourceString("Argument_MissingDefaultConstructor"));
            }
            this.Emit(OpCodes.Newobj, con);
            this.Emit(OpCodes.Throw);
        }

        // Emits the IL to call Console.WriteLine with a string.

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitWriteLine"]/*' />
        public virtual void EmitWriteLine(String value)
        {
    		if (m_methodBuilder==null) {
                throw new ArgumentException(Environment.GetResourceString("InvalidOperation_BadILGeneratorUsage"));
            }

            Emit(OpCodes.Ldstr, value);
            Type[] parameterTypes = new Type[1];
            parameterTypes[0] = typeof(String);
            MethodInfo mi = typeof(Console).GetMethod("WriteLine", parameterTypes);
            Emit(OpCodes.Call, mi);
        }


        // Emits the IL necessary to call WriteLine with lcl.  It is
        // an error to call EmitWriteLine with a lcl which is not of
        // one of the types for which Console.WriteLine implements overloads. (e.g.
        // we do *not* call ToString on the locals.
        //

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitWriteLine1"]/*' />
        public virtual void EmitWriteLine(LocalBuilder localBuilder) {
            Object			cls;
            if (m_methodBuilder==null)
            {
                throw new ArgumentException(Environment.GetResourceString("InvalidOperation_BadILGeneratorUsage"));
            }

            MethodInfo prop = typeof(Console).GetMethod("get_Out");
            Emit(OpCodes.Call, prop);
            Emit(OpCodes.Ldloc, localBuilder);
            Type[] parameterTypes = new Type[1];
            cls = localBuilder.LocalType;
            if (cls is TypeBuilder || cls is EnumBuilder) {
                throw new ArgumentException(Environment.GetResourceString("NotSupported_OutputStreamUsingTypeBuilder"));
            }
            parameterTypes[0] = (Type)cls;
            MethodInfo mi = typeof(TextWriter).GetMethod("WriteLine", parameterTypes);
			 if (mi==null) {
                throw new ArgumentException(Environment.GetResourceString("Argument_EmitWriteLineType"), "localBuilder");
            }

            Emit(OpCodes.Callvirt, mi);
        }


        // Emits the IL necessary to call WriteLine with fld.  It is
        // an error to call EmitWriteLine with a fld which is not of
        // one of the types for which Console.WriteLine implements overloads. (e.g.
        // we do *not* call ToString on the fields.
        //
    	//
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EmitWriteLine2"]/*' />
        public virtual void EmitWriteLine(FieldInfo fld)
        {
            Object cls;

            if (fld == null)
            {
    			throw new ArgumentNullException("fld");
            }
            
            MethodInfo prop = typeof(Console).GetMethod("get_Out");
            Emit(OpCodes.Call, prop);

            if ((fld.Attributes & FieldAttributes.Static)!=0) {
                Emit(OpCodes.Ldsfld, fld);
            } else {
                Emit(OpCodes.Ldarg, (short)0); //Load the this ref.
                Emit(OpCodes.Ldfld, fld);
            }
            Type[] parameterTypes = new Type[1];
            cls = fld.FieldType;
            if (cls is TypeBuilder || cls is EnumBuilder) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_OutputStreamUsingTypeBuilder"));
            }
            parameterTypes[0] = (Type)cls;
            MethodInfo mi = typeof(TextWriter).GetMethod("WriteLine", parameterTypes);
            if (mi==null) {
                throw new ArgumentException(Environment.GetResourceString("Argument_EmitWriteLineType"), "fld");
            }
            Emit(OpCodes.Callvirt, mi);
        }


        /*******************
        *
        * debugging APIs
        *
        ********************/

    	/**********************************************
    	 * Declare a local of type "local". The current active lexical scope
         * will be the scope that local will live.
    	**********************************************/
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.DeclareLocal"]/*' />
        public LocalBuilder DeclareLocal(Type localType)
        {

            LocalBuilder    localBuilder;

            if (m_methodBuilder.IsTypeCreated())
            {
                // cannot change method after its containing type has been created
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeHasBeenCreated"));
            }

            if (localType==null) {
                throw new ArgumentNullException("localType");
            }

            if (m_methodBuilder.m_bIsBaked) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_MethodBaked"));
            }

            // add the localType to local signature
            m_localSignature.AddArgument(localType);

            localBuilder = new LocalBuilder(m_localCount, localType, m_methodBuilder);
            m_localCount++;
            return localBuilder;
        }

    	/**********************************************
    	 * Specifying the namespace to be used in evaluating locals and watches
         * for the current active lexical scope.
    	**********************************************/
        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.UsingNamespace"]/*' />
        public void UsingNamespace(
            String          usingNamespace)
        {
            int         index;
            if (usingNamespace == null)
                throw new ArgumentNullException("usingNamespace");
			if (usingNamespace.Length == 0)
				throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "usingNamespace");

            index = m_methodBuilder.GetILGenerator().m_ScopeTree.GetCurrentActiveScopeIndex();
            if (index == -1)
            {
                m_methodBuilder.m_localSymInfo.AddUsingNamespace(usingNamespace);
            }
            else
            {
                m_ScopeTree.AddUsingNamespaceToCurrentScope(usingNamespace);
            }
        }


        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.MarkSequencePoint"]/*' />
        public virtual void MarkSequencePoint(
    	    ISymbolDocumentWriter document,
    	    int		startLine,       // line number is 1 based
    	    int		startColumn,     // column is 0 based
    	    int		endLine,         // line number is 1 based
    	    int		endColumn)       // column is 0 based
        {
            if (startLine == 0 || startLine < 0 || endLine == 0 || endLine < 0)
            {
                throw new ArgumentOutOfRangeException("startLine");
            }
            m_LineNumberInfo.AddLineNumberInfo(document, m_length, startLine, startColumn, endLine, endColumn);
        }

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.BeginScope"]/*' />
        public virtual void BeginScope()
        {
            m_ScopeTree.AddScopeInfo(ScopeAction.Open, m_length);
        }

        /// <include file='doc\ILGenerator.uex' path='docs/doc[@for="ILGenerator.EndScope"]/*' />
        public virtual void EndScope()
        {
            m_ScopeTree.AddScopeInfo(ScopeAction.Close, m_length);
        }

        //
        // Helper Functions.
        //
        //
        // package private constructor. This code path is used when client create
        // ILGenerator through MethodBuilder.
        //

		internal ILGenerator(MethodBuilder methodBuilder) : this(methodBuilder, 64)
		{


		}
        internal ILGenerator(MethodBuilder methodBuilder, int size)
		{
			if (size < defaultSize)
			{
	            m_ILStream = new byte[defaultSize];
			}
			else
			{
	            m_ILStream = new byte[size];
			}

            m_length=0;

            m_labelCount=0;
            m_fixupCount=0;
            m_labelList = null;

			m_fixupData = null;

            m_exceptions = null; 
            m_exceptionCount=0;
            m_currExcStack = null; 
            m_currExcStackCount=0;

            m_RelocFixupList = new int[DefaultFixupArraySize];
            m_RelocFixupCount=0;
            m_RVAFixupList = new int[DefaultFixupArraySize];
            m_RVAFixupCount=0;

            // initialize the scope tree
            m_ScopeTree = new ScopeTree();
            m_LineNumberInfo = new LineNumberInfo();
            m_methodBuilder = methodBuilder;

            // initialize local signature
            m_localCount=0;
            m_localSignature = SignatureHelper.GetLocalVarSigHelper(m_methodBuilder.GetTypeBuilder().Module);

        }

        internal static int []EnlargeArray(int []incoming) {
            int [] temp = new int [incoming.Length*2];
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        internal static byte []EnlargeArray(byte []incoming) {
            byte [] temp = new byte [incoming.Length*2];
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        internal static byte []EnlargeArray(byte []incoming , int requiredSize) {
            byte [] temp = new byte [requiredSize];
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        internal static __FixupData []EnlargeArray(__FixupData[] incoming) {
            __FixupData [] temp = new __FixupData[incoming.Length*2];
            //Does arraycopy work for value classes?
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        internal static Type []EnlargeArray(Type [] incoming) {
            Type [] temp = new Type[incoming.Length*2];
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        internal static __ExceptionInfo []EnlargeArray(__ExceptionInfo[] incoming) {
            __ExceptionInfo [] temp = new __ExceptionInfo[incoming.Length*2];
            Array.Copy(incoming, temp, incoming.Length);
            return temp;
        }

        // Guarantees an array capable of holding at least size elements.
        internal virtual void EnsureCapacity(int size) {
            if (m_length + size >= m_ILStream.Length)
            {
                if (m_length+size >= 2*m_ILStream.Length)
                {
                    m_ILStream = EnlargeArray(m_ILStream, m_length+size);
                }
                else
                {
                    m_ILStream = EnlargeArray(m_ILStream);
                }
            }
        }

        // Puts an Int32 onto the stream. This is an internal routine, so it does not do any error checking.
        //
        internal virtual int PutInteger4(int value, int startPos, byte []array) {
            array[startPos++]=(byte)(value&0xFF);
            array[startPos++]=(byte)((value&0xFF00)>>8);
            array[startPos++]=(byte)((value&0xFF0000)>>16);
            array[startPos++]=(byte)((value&0xFF000000)>>24);
            return startPos;
        }


        // Gets the position in the stream of a particular label.
        // Verifies that the label exists and that it has been given a value.
        //
        internal virtual int GetLabelPos (Label lbl) {
            int index = lbl.GetLabelValue();
            if (index<0 || index>=m_labelCount) {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadLabel"));
            }
            if (m_labelList[index]<0) {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadLabelContent"));
            }
            return m_labelList[index];
        }

        // Notes the label, position, and instruction size of a new fixup.  Expands
        // all of the fixup arrays as appropriate.
        //
        internal virtual void AddFixup(
            Label       lbl,            // label to be stored
            int         pos,            // position of the fixup
            int         instSize)       // remaining bytes to be substracted when computing the offset later on
        {

			if (m_fixupData == null){
				m_fixupData = new __FixupData[DefaultFixupArraySize];
			}
            if (m_fixupCount>=m_fixupData.Length) {
                m_fixupData = EnlargeArray(m_fixupData);
            }
            m_fixupData[m_fixupCount].m_fixupPos = pos;
            m_fixupData[m_fixupCount].m_fixupLabel= lbl;
            m_fixupData[m_fixupCount].m_fixupInstSize = instSize;
            m_fixupCount++;
        }

        // Returns the maximum stack size required for the method.
		 internal virtual int GetMaxStackSize()
		 {
			return m_maxStackSize + m_methodBuilder.GetNumberOfExceptions();
		 }

        // In order to call exceptions properly we have to sort them in ascending order by their end position.
        // Just a cheap insertion sort.  We don't expect many exceptions (<10), where InsertionSort beats QuickSort.
        // If we have more exceptions that this in real life, we should consider moving to a QuickSort.
        internal virtual void SortExceptions(__ExceptionInfo []exceptions) {
            int least;
            __ExceptionInfo temp;
            int length = exceptions.Length;
            for (int i=0; i<length; i++) {
                least = i;
                for (int j=i+1; j<length; j++) {
					if (exceptions[least].IsInner(exceptions[j])) {
                        least = j;
                    }
                }
                temp = exceptions[i];
                exceptions[i]=exceptions[least];
                exceptions[least]=temp;
            }
        }


        private void RecordTokenFixup() {
            if (m_RelocFixupCount>=m_RelocFixupList.Length) {
                m_RelocFixupList = EnlargeArray(m_RelocFixupList);
            }
            m_RelocFixupList[m_RelocFixupCount++]=m_length;
        }

        //@ToDo:  Do we just want to pass the length as a param and avoid this ugly copy?
        internal virtual int []GetTokenFixups() {
            int[] narrowTokens = new int[m_RelocFixupCount];
            Array.Copy(m_RelocFixupList, narrowTokens, m_RelocFixupCount);
            return narrowTokens;
        }

        //@ToDo:  Do we just want to pass the length as a param and avoid this ugly copy?
        internal virtual int []GetRVAFixups() {
            int[] narrowRVAs = new int[m_RVAFixupCount];
            Array.Copy(m_RVAFixupList, narrowRVAs, m_RVAFixupCount);
            return narrowRVAs;
        }
    }


	internal struct __FixupData
	{
		internal Label m_fixupLabel;
		internal int m_fixupPos;
        // @todo: [meichint]
        // we can remove this  by storing the skipping bytes in the fixup itself
		internal int m_fixupInstSize;

	}

    internal class __ExceptionInfo {

        internal const int None=0;              //COR_ILEXCEPTION_CLAUSE_NONE
        internal const int Filter=1;            //COR_ILEXCEPTION_CLAUSE_FILTER
        internal const int Finally=2;           //COR_ILEXCEPTION_CLAUSE_FINALLY
        internal const int Fault=4;             //COR_ILEXCEPTION_CLAUSE_FAULT
        internal const int PreserveStack = 4;   //COR_ILEXCEPTION_CLAUSE_PRESERVESTACK

        internal const int State_Try = 0;
    	internal const int State_Filter =1;
        internal const int State_Catch = 2;
        internal const int State_Finally = 3;
        internal const int State_Fault = 4;
        internal const int State_Done = 5;

        internal int m_startAddr;
    	internal int []m_filterAddr;
        internal int []m_catchAddr;
        internal int []m_catchEndAddr;
        internal int []m_type;
        internal Type []m_catchClass;
        internal Label m_endLabel;
        internal Label m_finallyEndLabel;
        internal int m_endAddr;
        internal int m_endFinally;
        internal int m_currentCatch;

        int m_currentState;


        //This will never get called.  The values exist merely to keep the
        //compiler happy.
        private __ExceptionInfo() {
            m_startAddr = 0;
    		m_filterAddr = null;
            m_catchAddr = null;
            m_catchEndAddr = null;
            m_endAddr = 0;
            m_currentCatch = 0;
            m_type = null;
            m_endFinally = -1;
            m_currentState = State_Try;
        }

        internal __ExceptionInfo(int startAddr, Label endLabel) {
            m_startAddr=startAddr;
            m_endAddr=-1;
    		m_filterAddr=new int[4];
            m_catchAddr=new int[4];
            m_catchEndAddr=new int[4];
            m_catchClass=new Type[4];
            m_currentCatch=0;
            m_endLabel=endLabel;
            m_type=new int[4];
            m_endFinally=-1;
            m_currentState = State_Try;
        }

        private void MarkHelper(
            int         catchorfilterAddr,      // the starting address of a clause
            int         catchEndAddr,           // the end address of a previous catch clause. Only use when finally is following a catch
            Type        catchClass,             // catch exception type
            int         type)                   // kind of clause
        {
            if (m_currentCatch>=m_catchAddr.Length) {
    			m_filterAddr=ILGenerator.EnlargeArray(m_filterAddr);
                m_catchAddr=ILGenerator.EnlargeArray(m_catchAddr);
                m_catchEndAddr=ILGenerator.EnlargeArray(m_catchEndAddr);
                m_catchClass=ILGenerator.EnlargeArray(m_catchClass);
                m_type = ILGenerator.EnlargeArray(m_type);
            }
    		if (type == Filter)
    		{
    			m_type[m_currentCatch]=type;
    			m_filterAddr[m_currentCatch] = catchorfilterAddr;
    			m_catchAddr[m_currentCatch] = -1;
    			if (m_currentCatch > 0)
    			{
    				BCLDebug.Assert(m_catchEndAddr[m_currentCatch-1] == -1,"m_catchEndAddr[m_currentCatch-1] == -1");
    				m_catchEndAddr[m_currentCatch-1] = catchorfilterAddr;
    			}
    		}
    		else
    		{
                // catch or Fault clause
    			m_catchClass[m_currentCatch]=catchClass;
    			if (m_type[m_currentCatch] != Filter)
    			{
    				m_type[m_currentCatch]=type;
    			}
    			m_catchAddr[m_currentCatch]=catchorfilterAddr;
    			if (m_currentCatch > 0)
    			{
    					if (m_type[m_currentCatch] != Filter)
    					{
    						BCLDebug.Assert(m_catchEndAddr[m_currentCatch-1] == -1,"m_catchEndAddr[m_currentCatch-1] == -1");
    						m_catchEndAddr[m_currentCatch-1] = catchEndAddr;
    					}
    			}
    			m_catchEndAddr[m_currentCatch]=-1; // Some bad value
    			m_currentCatch++;
    		}

    		if (m_endAddr==-1)
    		{
    			m_endAddr=catchorfilterAddr;
    		}
        }

    	internal virtual void MarkFilterAddr(int filterAddr)
    	{
            m_currentState = State_Filter;
    		MarkHelper(filterAddr, filterAddr, null, Filter);
    	}

    	internal virtual void MarkFaultAddr(int faultAddr)
    	{
            m_currentState = State_Fault;
    		MarkHelper(faultAddr, faultAddr, null, Fault);
    	}

        internal virtual void MarkCatchAddr(int catchAddr, Type catchException) {
            m_currentState = State_Catch;
            MarkHelper(catchAddr, catchAddr, catchException, None);
        }

        internal virtual void MarkFinallyAddr(int finallyAddr, int endCatchAddr) {
            if (m_endFinally!=-1) {
                throw new ArgumentException(Environment.GetResourceString("Argument_TooManyFinallyClause"));
            } else {
                m_currentState = State_Finally;
                m_endFinally=finallyAddr;
            }
            MarkHelper(finallyAddr, endCatchAddr, null, Finally);
        }

        internal virtual void Done(int endAddr) {
            BCLDebug.Assert(m_currentCatch > 0,"m_currentCatch > 0");
    		BCLDebug.Assert(m_catchAddr[m_currentCatch-1] > 0,"m_catchAddr[m_currentCatch-1] > 0");
            BCLDebug.Assert(m_catchEndAddr[m_currentCatch-1] == -1,"m_catchEndAddr[m_currentCatch-1] == -1");
            m_catchEndAddr[m_currentCatch-1] = endAddr;
            m_currentState = State_Done;
        }

        internal virtual int GetStartAddress() {
            return m_startAddr;
        }

        internal virtual int GetEndAddress() {
            return m_endAddr;
        }

        internal virtual int GetFinallyEndAddress() {
            return m_endFinally;
        }

        internal virtual Label GetEndLabel() {
            return m_endLabel;
        }

    	internal virtual int [] GetFilterAddresses() {
    		return m_filterAddr;
    	}

        internal virtual int [] GetCatchAddresses() {
            return m_catchAddr;
        }

        internal virtual int [] GetCatchEndAddresses() {
            return m_catchEndAddr;
        }

        internal virtual Type [] GetCatchClass() {
            return m_catchClass;
        }

        internal virtual int GetNumberOfCatches() {
            return m_currentCatch;
        }

        internal virtual int[] GetExceptionTypes() {
            return m_type;
        }

        internal virtual void SetFinallyEndLabel(Label lbl) {
            m_finallyEndLabel=lbl;
        }

        internal virtual Label GetFinallyEndLabel() {
            return m_finallyEndLabel;
        }

		// Specifies whether exc is an inner exception for "this".  The way
		// its determined is by comparing the end address for the last catch
		// clause for both exceptions.  If they're the same, the start address
		// for the exception is compared.
		// WARNING: This is not a generic function to determine the innerness
		// of an exception.  This is somewhat of a mis-nomer.  This gives a
		// random result for cases where the two exceptions being compared do
		// not having a nesting relation. 
		internal bool IsInner(__ExceptionInfo exc) {
            BCLDebug.Assert(m_currentCatch > 0,"m_currentCatch > 0");
            BCLDebug.Assert(exc.m_currentCatch > 0,"exc.m_currentCatch > 0");

			int exclast = exc.m_currentCatch - 1;
			int last = m_currentCatch - 1;

			if (exc.m_catchEndAddr[exclast]  < m_catchEndAddr[last])
				return true;
			else if (exc.m_catchEndAddr[exclast] == m_catchEndAddr[last])
			{
				BCLDebug.Assert(exc.GetEndAddress() != GetEndAddress(),
								"exc.GetEndAddress() != GetEndAddress()");
				if (exc.GetEndAddress() > GetEndAddress())
					return true;
			}
			return false;
		}

        // 0 indicates in a try block
        // 1 indicates in a filter block
        // 2 indicates in a catch block
        // 3 indicates in a finally block
    	// 4 indicates Done
        internal virtual int GetCurrentState() {
            return m_currentState;
        }
    }


    /***************************
    *
    * Scope Tree is a class that track the scope structure within a method body
    * It keeps track two parallel array. m_ScopeAction keeps track the action. It can be
    * OpenScope or CloseScope. m_iOffset records the offset where the action
    * takes place.
    *
    ***************************/
	[Serializable]
    enum ScopeAction
    {
        Open        = 0x0,
        Close       = 0x1,
    }

    internal class ScopeTree
    {
        internal ScopeTree()
        {
            // initialize data variables
            m_iOpenScopeCount = 0;
            m_iCount = 0;
        }

        /***************************
        *
        * Find the current active lexcial scope. For example, if we have
        * "Open Open Open Close",
        * we will return 1 as the second BeginScope is currently active.
        *
        ***************************/
        internal int GetCurrentActiveScopeIndex()
        {
            int         cClose = 0;
            int         i = m_iCount - 1;

            if (m_iCount == 0)
            {
                return -1;
            }
            for (; cClose > 0 || m_ScopeActions[i] == ScopeAction.Close; i--)
            {
                if (m_ScopeActions[i] == ScopeAction.Open)
                {
                    cClose--;
                }
                else
                    cClose++;
            }

            return i;
        }

        internal void AddLocalSymInfoToCurrentScope(
            String          strName,
            byte[]          signature,
            int             slot,
            int             startOffset,
            int             endOffset)
        {
            int         i = GetCurrentActiveScopeIndex();
            if (m_localSymInfos[i] == null)
            {
                m_localSymInfos[i] = new LocalSymInfo();
            }
            m_localSymInfos[i].AddLocalSymInfo(strName, signature, slot, startOffset, endOffset);
        }

        internal void AddUsingNamespaceToCurrentScope(
            String          strNamespace)
        {
            int         i = GetCurrentActiveScopeIndex();
            if (m_localSymInfos[i] == null)
            {
                m_localSymInfos[i] = new LocalSymInfo();
            }
            m_localSymInfos[i].AddUsingNamespace(strNamespace);
        }

        internal void AddScopeInfo(ScopeAction sa, int iOffset)
        {
            if (sa == ScopeAction.Close && m_iOpenScopeCount <=0)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_UnmatchingSymScope"));
            }

            // make sure that arrays are large enough to hold addition info
            EnsureCapacity();

            // @hack:: [meichint]
            // smc is asserting when we declare m_ScopeAction as ScopeAction[]
            //
            m_ScopeActions[m_iCount] = sa;
            m_iOffsets[m_iCount] = iOffset;
            m_localSymInfos[m_iCount] = null;
            m_iCount++;
            if (sa == ScopeAction.Open)
            {
                m_iOpenScopeCount++;
            }
    		else
    			m_iOpenScopeCount--;

        }

        /**************************
        *
        * Helper to ensure arrays are large enough
        *
        **************************/
        internal void EnsureCapacity()
        {
            if (m_iCount == 0)
            {
                // First time. Allocate the arrays.
                m_iOffsets = new int[InitialSize];
                m_ScopeActions = new ScopeAction[InitialSize];
                m_localSymInfos = new LocalSymInfo[InitialSize];
            }
            else if (m_iCount == m_iOffsets.Length)
            {

                // the arrays are full. Enlarge the arrays
                int[] temp = new int [m_iCount * 2];
                Array.Copy(m_iOffsets, temp, m_iCount);
                m_iOffsets = temp;

                ScopeAction[] tempSA = new ScopeAction[m_iCount * 2];
                Array.Copy(m_ScopeActions, tempSA, m_iCount);
                m_ScopeActions = tempSA;

                LocalSymInfo[] tempLSI = new LocalSymInfo[m_iCount * 2];
                Array.Copy(m_localSymInfos, tempLSI, m_iCount);
                m_localSymInfos = tempLSI;

            }
        }

        internal void EmitScopeTree(ISymbolWriter symWriter)
        {
            int         i;
            for (i = 0; i < m_iCount; i++)
            {
                if (m_ScopeActions[i] == ScopeAction.Open)
                {
                    symWriter.OpenScope(m_iOffsets[i]);
                }
                else
                {
                    symWriter.CloseScope(m_iOffsets[i]);
                }
                if (m_localSymInfos[i] != null)
                {
                    m_localSymInfos[i].EmitLocalSymInfo(symWriter);
                }
            }
        }

        internal int[]          m_iOffsets;                 // array of offsets
        internal ScopeAction[]  m_ScopeActions;             // array of scope actions
        internal int            m_iCount;                   // how many entries in the arrays are occupied
        internal int            m_iOpenScopeCount;          // keep track how many scopes are open
        internal const int      InitialSize = 16;
        internal LocalSymInfo[] m_localSymInfos;            // keep track debugging local information
    }


    /***************************
    *
    * This class tracks the line number info
    *
    ***************************/
    internal class LineNumberInfo
    {
        internal LineNumberInfo()
        {
            // initialize data variables
            m_DocumentCount = 0;
            m_iLastFound = 0;
        }

        internal void AddLineNumberInfo(
            ISymbolDocumentWriter document,
            int             iOffset,
            int             iStartLine,
            int             iStartColumn,
            int             iEndLine,
            int             iEndColumn)
        {
            int         i;
            
            // make sure that arrays are large enough to hold addition info
            i = FindDocument(document);
			
            BCLDebug.Assert(i < m_DocumentCount, "Bad document look up!");
            m_Documents[i].AddLineNumberInfo(document, iOffset, iStartLine, iStartColumn, iEndLine, iEndColumn);
        }
        
        // Find a REDocument representing document. If we cannot find one, we will add a new entry into
        // the REDocument array.
        //
        internal int FindDocument(ISymbolDocumentWriter document)
        {
            int         i;
            
            // This is an optimization. The chance that the previous line is coming from the same
            // document is very high.
            //                
            if (m_iLastFound < m_DocumentCount && m_Documents[m_iLastFound] == document)
                return m_iLastFound;
                
            for (i = 0; i < m_DocumentCount; i++)
            {
                if (m_Documents[i].m_document == document)
                {
                    m_iLastFound = i;
                    return m_iLastFound;
                }
            }
            
            // cannot find an existing document so add one to the array                                       
            EnsureCapacity();
            m_iLastFound = m_DocumentCount;
            m_Documents[m_DocumentCount++] = new REDocument(document);
            return m_iLastFound;
        }

        /**************************
        *
        * Helper to ensure arrays are large enough
        *
        **************************/
        internal void EnsureCapacity()
        {
            if (m_DocumentCount == 0)
            {
                // First time. Allocate the arrays.
                m_Documents = new REDocument[InitialSize];
            }
            else if (m_DocumentCount == m_Documents.Length)
            {
                // the arrays are full. Enlarge the arrays
                REDocument[] temp = new REDocument [m_DocumentCount * 2];
                Array.Copy(m_Documents, temp, m_DocumentCount);
				m_Documents = temp;
            }
        }

        internal void EmitLineNumberInfo(ISymbolWriter symWriter)
        {
            for (int i = 0; i < m_DocumentCount; i++)
                m_Documents[i].EmitLineNumberInfo(symWriter);
        }

        internal int         m_DocumentCount;           // how many documents that we have right now
        internal REDocument[]  m_Documents;             // array of documents
        internal const int   InitialSize = 16;
        private  int         m_iLastFound;
    }


    /***************************
    *
    * This class tracks the line number info
    *
    ***************************/
    internal class REDocument
    {
        internal REDocument(ISymbolDocumentWriter document)
        {
            // initialize data variables
            m_iLineNumberCount = 0;
            m_document = document;
        }

        internal void AddLineNumberInfo(
            ISymbolDocumentWriter document,
            int             iOffset,
            int             iStartLine,
            int             iStartColumn,
            int             iEndLine,
            int             iEndColumn)
        {
            BCLDebug.Assert(document == m_document, "Bad document look up!");
            
            // make sure that arrays are large enough to hold addition info
            EnsureCapacity();
			
            m_iOffsets[m_iLineNumberCount] = iOffset;
            m_iLines[m_iLineNumberCount] = iStartLine;
            m_iColumns[m_iLineNumberCount] = iStartColumn;
            m_iEndLines[m_iLineNumberCount] = iEndLine;
            m_iEndColumns[m_iLineNumberCount] = iEndColumn;
            m_iLineNumberCount++;
        }

        /**************************
        *
        * Helper to ensure arrays are large enough
        *
        **************************/
        internal void EnsureCapacity()
        {
            if (m_iLineNumberCount == 0)
            {
                // First time. Allocate the arrays.
                m_iOffsets = new int[InitialSize];
                m_iLines = new int[InitialSize];
                m_iColumns = new int[InitialSize];
                m_iEndLines = new int[InitialSize];
                m_iEndColumns = new int[InitialSize];
            }
            else if (m_iLineNumberCount == m_iOffsets.Length)
            {
                // @concern: will it be cheaper if we boundle these three arrays into
                // one value class and thus do one alloc and one copy?

                // the arrays are full. Enlarge the arrays
                int[] temp = new int [m_iLineNumberCount * 2];
                Array.Copy(m_iOffsets, temp, m_iLineNumberCount);
                m_iOffsets = temp;

                temp = new int [m_iLineNumberCount * 2];
                Array.Copy(m_iLines, temp, m_iLineNumberCount);
                m_iLines = temp;

                temp = new int [m_iLineNumberCount * 2];
                Array.Copy(m_iColumns, temp, m_iLineNumberCount);
                m_iColumns = temp;

                temp = new int [m_iLineNumberCount * 2];
                Array.Copy(m_iEndLines, temp, m_iLineNumberCount);
                m_iEndLines = temp;

                temp = new int [m_iLineNumberCount * 2];
                Array.Copy(m_iEndColumns, temp, m_iLineNumberCount);
                m_iEndColumns = temp;
            }
        }

        internal void EmitLineNumberInfo(ISymbolWriter symWriter)
        {
            int[]       iOffsetsTemp;
            int[]       iLinesTemp;
            int[]       iColumnsTemp;
            int[]       iEndLinesTemp;
            int[]       iEndColumnsTemp;

            if (m_iLineNumberCount == 0)
                return;
            // reduce the array size to be exact
            iOffsetsTemp = new int [m_iLineNumberCount];
            Array.Copy(m_iOffsets, iOffsetsTemp, m_iLineNumberCount);

            iLinesTemp = new int [m_iLineNumberCount];
            Array.Copy(m_iLines, iLinesTemp, m_iLineNumberCount);

            iColumnsTemp = new int [m_iLineNumberCount];
            Array.Copy(m_iColumns, iColumnsTemp, m_iLineNumberCount);

            iEndLinesTemp = new int [m_iLineNumberCount];
            Array.Copy(m_iEndLines, iEndLinesTemp, m_iLineNumberCount);

            iEndColumnsTemp = new int [m_iLineNumberCount];
            Array.Copy(m_iEndColumns, iEndColumnsTemp, m_iLineNumberCount);

            symWriter.DefineSequencePoints(m_document, iOffsetsTemp, iLinesTemp, iColumnsTemp, iEndLinesTemp, iEndColumnsTemp); 
        }

        internal int[]       m_iOffsets;                 // array of offsets
        internal int[]       m_iLines;                   // array of offsets
        internal int[]       m_iColumns;                 // array of offsets
        internal int[]       m_iEndLines;                // array of offsets
        internal int[]       m_iEndColumns;              // array of offsets
        internal ISymbolDocumentWriter m_document;       // The ISymbolDocumentWriter that this REDocument is tracking.
        internal int         m_iLineNumberCount;         // how many entries in the arrays are occupied
        internal const int InitialSize = 16;
    }       // end of REDocument




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\parameterbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ParameterBuilder
**
** Author: Mei-Chin Tsai
**
** ParameterBuilder is used to create/associate parameter information
**
** Date:  Aug 99
** 
===========================================================*/
namespace System.Reflection.Emit {
	using System.Runtime.InteropServices;
	using System;
	using System.Reflection;
    /// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder"]/*' />
    public class ParameterBuilder
    {
        // set ParamMarshal
        /// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.SetMarshal"]/*' />
        public virtual void SetMarshal(UnmanagedMarshal unmanagedMarshal)
        {
            if (unmanagedMarshal == null)
            {
    			throw new ArgumentNullException("unmanagedMarshal");
            }
            
            byte []        ubMarshal = unmanagedMarshal.InternalGetBytes();        
            TypeBuilder.InternalSetMarshalInfo(
                m_methodBuilder.GetModule(),
                m_pdToken.Token, 
                ubMarshal, 
                ubMarshal.Length);
        }
    
        // Set the default value of the parameter
        /// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.SetConstant"]/*' />
        public virtual void SetConstant(Object defaultValue) 
        {
            TypeBuilder.SetConstantValue(
                m_methodBuilder.GetModule(),
                m_pdToken.Token, 
				m_methodBuilder.m_parameterTypes[m_iPosition-1],
                defaultValue);
        }
        
		// Use this function if client decides to form the custom attribute blob themselves
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.SetCustomAttribute"]/*' />
    	public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
    	{
    		if (con == null)
    			throw new ArgumentNullException("con");
    		if (binaryAttribute == null)
    			throw new ArgumentNullException("binaryAttribute");
    		
            TypeBuilder.InternalCreateCustomAttribute(
                m_pdToken.Token,
                ((ModuleBuilder )m_methodBuilder.GetModule()).GetConstructorToken(con).Token,
                binaryAttribute,
                m_methodBuilder.GetModule(),
                false);
    	}

		// Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            if (customBuilder == null)
            {
    			throw new ArgumentNullException("customBuilder");
            }
            customBuilder.CreateCustomAttribute((ModuleBuilder) (m_methodBuilder .GetModule()), m_pdToken.Token);
        }
        
        //*******************************
    	// Make a private constructor so these cannot be constructed externally.
        //*******************************
        private ParameterBuilder() {}


        internal ParameterBuilder(
            MethodBuilder   methodBuilder, 
            int 		    sequence, 
            ParameterAttributes attributes, 
            String 	        strParamName)			// can be NULL string
        {
            m_iPosition = sequence;
            m_strParamName = strParamName;
            m_methodBuilder = methodBuilder;
            m_strParamName = strParamName;
            m_attributes = attributes;
            m_pdToken = new ParameterToken( TypeBuilder.InternalSetParamInfo(
                        m_methodBuilder.GetModule(), 
                        m_methodBuilder.GetToken().Token, 
                        sequence, 
                        attributes, 
                        strParamName));
        }
    
        /// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.GetToken"]/*' />
        public virtual ParameterToken GetToken()
        {
            return m_pdToken;
        } 
    
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.Name"]/*' />
    	public virtual String Name {
    		get {return m_strParamName;}
    	}
    
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.Position"]/*' />
    	public virtual int Position {
    		get {return m_iPosition;}
    	}
    						
		// COOLPORT: This cast needs to be removed...
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.Attributes"]/*' />
    	public virtual int Attributes {
    		get {return (int) m_attributes;}
    	}
    						
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.IsIn"]/*' />
    	public bool IsIn {
    		get {return ((m_attributes & ParameterAttributes.In) != 0);}
    	}
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.IsOut"]/*' />
    	public bool IsOut {
    		get {return ((m_attributes & ParameterAttributes.Out) != 0);}
    	}
    	/// <include file='doc\ParameterBuilder.uex' path='docs/doc[@for="ParameterBuilder.IsOptional"]/*' />
    	public bool IsOptional {
    		get {return ((m_attributes & ParameterAttributes.Optional) != 0);}
    	}
    
        private String              m_strParamName;
        private int                 m_iPosition;
        private ParameterAttributes m_attributes;
        private MethodBuilder       m_methodBuilder;
        private ParameterToken      m_pdToken;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\opcodes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**Class: OpCodes
**
**Author: Craig Schertz (cschertz)
**
**Purpose: Exposes all of the il instructions supported by the runtime.
**
** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND!
** See cschertz for more information.**
============================================================*/
namespace System.Reflection.Emit {

using System;

/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes"]/*' />
public class OpCodes {

/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.OpCodes"]/*' />

	private OpCodes() { 
	}

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Nop"]/*' />
	public static readonly OpCode Nop                  = new OpCode("nop", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x0, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Break"]/*' />
	public static readonly OpCode Break                = new OpCode("break", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x1, FlowControl.Break, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg_0"]/*' />
	public static readonly OpCode Ldarg_0              = new OpCode("ldarg.0", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg_1"]/*' />
	public static readonly OpCode Ldarg_1              = new OpCode("ldarg.1", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg_2"]/*' />
	public static readonly OpCode Ldarg_2              = new OpCode("ldarg.2", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x4, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg_3"]/*' />
	public static readonly OpCode Ldarg_3              = new OpCode("ldarg.3", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x5, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc_0"]/*' />
	public static readonly OpCode Ldloc_0              = new OpCode("ldloc.0", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x6, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc_1"]/*' />
	public static readonly OpCode Ldloc_1              = new OpCode("ldloc.1", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x7, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc_2"]/*' />
	public static readonly OpCode Ldloc_2              = new OpCode("ldloc.2", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x8, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc_3"]/*' />
	public static readonly OpCode Ldloc_3              = new OpCode("ldloc.3", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x9, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc_0"]/*' />
	public static readonly OpCode Stloc_0              = new OpCode("stloc.0", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0xa, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc_1"]/*' />
	public static readonly OpCode Stloc_1              = new OpCode("stloc.1", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0xb, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc_2"]/*' />
	public static readonly OpCode Stloc_2              = new OpCode("stloc.2", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0xc, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc_3"]/*' />
	public static readonly OpCode Stloc_3              = new OpCode("stloc.3", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0xd, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg_S"]/*' />
	public static readonly OpCode Ldarg_S              = new OpCode("ldarg.s", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0xe, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarga_S"]/*' />
	public static readonly OpCode Ldarga_S             = new OpCode("ldarga.s", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0xf, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Starg_S"]/*' />
	public static readonly OpCode Starg_S              = new OpCode("starg.s", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0x10, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc_S"]/*' />
	public static readonly OpCode Ldloc_S              = new OpCode("ldloc.s", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0x11, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloca_S"]/*' />
	public static readonly OpCode Ldloca_S             = new OpCode("ldloca.s", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0x12, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc_S"]/*' />
	public static readonly OpCode Stloc_S              = new OpCode("stloc.s", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.ShortInlineVar, OpCodeType.Macro, 1, (byte)0xff, (byte)0x13, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldnull"]/*' />
	public static readonly OpCode Ldnull               = new OpCode("ldnull", StackBehaviour.Pop0, StackBehaviour.Pushref, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x14, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_M1"]/*' />
	public static readonly OpCode Ldc_I4_M1            = new OpCode("ldc.i4.m1", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x15, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_0"]/*' />
	public static readonly OpCode Ldc_I4_0             = new OpCode("ldc.i4.0", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x16, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_1"]/*' />
	public static readonly OpCode Ldc_I4_1             = new OpCode("ldc.i4.1", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x17, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_2"]/*' />
	public static readonly OpCode Ldc_I4_2             = new OpCode("ldc.i4.2", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x18, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_3"]/*' />
	public static readonly OpCode Ldc_I4_3             = new OpCode("ldc.i4.3", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x19, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_4"]/*' />
	public static readonly OpCode Ldc_I4_4             = new OpCode("ldc.i4.4", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1a, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_5"]/*' />
	public static readonly OpCode Ldc_I4_5             = new OpCode("ldc.i4.5", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1b, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_6"]/*' />
	public static readonly OpCode Ldc_I4_6             = new OpCode("ldc.i4.6", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1c, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_7"]/*' />
	public static readonly OpCode Ldc_I4_7             = new OpCode("ldc.i4.7", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1d, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_8"]/*' />
	public static readonly OpCode Ldc_I4_8             = new OpCode("ldc.i4.8", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1e, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4_S"]/*' />
	public static readonly OpCode Ldc_I4_S             = new OpCode("ldc.i4.s", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.ShortInlineI, OpCodeType.Macro, 1, (byte)0xff, (byte)0x1f, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I4"]/*' />
	public static readonly OpCode Ldc_I4               = new OpCode("ldc.i4", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineI, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x20, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_I8"]/*' />
	public static readonly OpCode Ldc_I8               = new OpCode("ldc.i8", StackBehaviour.Pop0, StackBehaviour.Pushi8, OperandType.InlineI8, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x21, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_R4"]/*' />
	public static readonly OpCode Ldc_R4               = new OpCode("ldc.r4", StackBehaviour.Pop0, StackBehaviour.Pushr4, OperandType.ShortInlineR, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x22, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldc_R8"]/*' />
	public static readonly OpCode Ldc_R8               = new OpCode("ldc.r8", StackBehaviour.Pop0, StackBehaviour.Pushr8, OperandType.InlineR, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x23, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Dup"]/*' />
	public static readonly OpCode Dup                  = new OpCode("dup", StackBehaviour.Pop1, StackBehaviour.Push1_push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x25, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Pop"]/*' />
	public static readonly OpCode Pop                  = new OpCode("pop", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x26, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Jmp"]/*' />
	public static readonly OpCode Jmp                  = new OpCode("jmp", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineMethod, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x27, FlowControl.Call, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Call"]/*' />
	public static readonly OpCode Call                 = new OpCode("call", StackBehaviour.Varpop, StackBehaviour.Varpush, OperandType.InlineMethod, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x28, FlowControl.Call, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Calli"]/*' />
	public static readonly OpCode Calli                = new OpCode("calli", StackBehaviour.Varpop, StackBehaviour.Varpush, OperandType.InlineSig, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x29, FlowControl.Call, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ret"]/*' />
	public static readonly OpCode Ret                  = new OpCode("ret", StackBehaviour.Varpop, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x2a, FlowControl.Return, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Br_S"]/*' />
	public static readonly OpCode Br_S                 = new OpCode("br.s", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2b, FlowControl.Branch, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Brfalse_S"]/*' />
	public static readonly OpCode Brfalse_S            = new OpCode("brfalse.s", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2c, FlowControl.Cond_Branch, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Brtrue_S"]/*' />
	public static readonly OpCode Brtrue_S             = new OpCode("brtrue.s", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2d, FlowControl.Cond_Branch, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Beq_S"]/*' />
	public static readonly OpCode Beq_S                = new OpCode("beq.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2e, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bge_S"]/*' />
	public static readonly OpCode Bge_S                = new OpCode("bge.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x2f, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bgt_S"]/*' />
	public static readonly OpCode Bgt_S                = new OpCode("bgt.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x30, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ble_S"]/*' />
	public static readonly OpCode Ble_S                = new OpCode("ble.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x31, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Blt_S"]/*' />
	public static readonly OpCode Blt_S                = new OpCode("blt.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x32, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bne_Un_S"]/*' />
	public static readonly OpCode Bne_Un_S             = new OpCode("bne.un.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x33, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bge_Un_S"]/*' />
	public static readonly OpCode Bge_Un_S             = new OpCode("bge.un.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x34, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bgt_Un_S"]/*' />
	public static readonly OpCode Bgt_Un_S             = new OpCode("bgt.un.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x35, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ble_Un_S"]/*' />
	public static readonly OpCode Ble_Un_S             = new OpCode("ble.un.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x36, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Blt_Un_S"]/*' />
	public static readonly OpCode Blt_Un_S             = new OpCode("blt.un.s", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x37, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Br"]/*' />
	public static readonly OpCode Br                   = new OpCode("br", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x38, FlowControl.Branch, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Brfalse"]/*' />
	public static readonly OpCode Brfalse              = new OpCode("brfalse", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x39, FlowControl.Cond_Branch, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Brtrue"]/*' />
	public static readonly OpCode Brtrue               = new OpCode("brtrue", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x3a, FlowControl.Cond_Branch, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Beq"]/*' />
	public static readonly OpCode Beq                  = new OpCode("beq", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3b, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bge"]/*' />
	public static readonly OpCode Bge                  = new OpCode("bge", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3c, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bgt"]/*' />
	public static readonly OpCode Bgt                  = new OpCode("bgt", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3d, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ble"]/*' />
	public static readonly OpCode Ble                  = new OpCode("ble", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3e, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Blt"]/*' />
	public static readonly OpCode Blt                  = new OpCode("blt", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x3f, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bne_Un"]/*' />
	public static readonly OpCode Bne_Un               = new OpCode("bne.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x40, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bge_Un"]/*' />
	public static readonly OpCode Bge_Un               = new OpCode("bge.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x41, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Bgt_Un"]/*' />
	public static readonly OpCode Bgt_Un               = new OpCode("bgt.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x42, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ble_Un"]/*' />
	public static readonly OpCode Ble_Un               = new OpCode("ble.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x43, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Blt_Un"]/*' />
	public static readonly OpCode Blt_Un               = new OpCode("blt.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Macro, 1, (byte)0xff, (byte)0x44, FlowControl.Cond_Branch, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Switch"]/*' />
	public static readonly OpCode Switch               = new OpCode("switch", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.InlineSwitch, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x45, FlowControl.Cond_Branch, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_I1"]/*' />
	public static readonly OpCode Ldind_I1             = new OpCode("ldind.i1", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x46, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_U1"]/*' />
	public static readonly OpCode Ldind_U1             = new OpCode("ldind.u1", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x47, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_I2"]/*' />
	public static readonly OpCode Ldind_I2             = new OpCode("ldind.i2", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x48, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_U2"]/*' />
	public static readonly OpCode Ldind_U2             = new OpCode("ldind.u2", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x49, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_I4"]/*' />
	public static readonly OpCode Ldind_I4             = new OpCode("ldind.i4", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4a, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_U4"]/*' />
	public static readonly OpCode Ldind_U4             = new OpCode("ldind.u4", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4b, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_I8"]/*' />
	public static readonly OpCode Ldind_I8             = new OpCode("ldind.i8", StackBehaviour.Popi, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4c, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_I"]/*' />
	public static readonly OpCode Ldind_I              = new OpCode("ldind.i", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4d, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_R4"]/*' />
	public static readonly OpCode Ldind_R4             = new OpCode("ldind.r4", StackBehaviour.Popi, StackBehaviour.Pushr4, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4e, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_R8"]/*' />
	public static readonly OpCode Ldind_R8             = new OpCode("ldind.r8", StackBehaviour.Popi, StackBehaviour.Pushr8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x4f, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldind_Ref"]/*' />
	public static readonly OpCode Ldind_Ref            = new OpCode("ldind.ref", StackBehaviour.Popi, StackBehaviour.Pushref, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x50, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_Ref"]/*' />
	public static readonly OpCode Stind_Ref            = new OpCode("stind.ref", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x51, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_I1"]/*' />
	public static readonly OpCode Stind_I1             = new OpCode("stind.i1", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x52, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_I2"]/*' />
	public static readonly OpCode Stind_I2             = new OpCode("stind.i2", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x53, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_I4"]/*' />
	public static readonly OpCode Stind_I4             = new OpCode("stind.i4", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x54, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_I8"]/*' />
	public static readonly OpCode Stind_I8             = new OpCode("stind.i8", StackBehaviour.Popi_popi8, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x55, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_R4"]/*' />
	public static readonly OpCode Stind_R4             = new OpCode("stind.r4", StackBehaviour.Popi_popr4, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x56, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_R8"]/*' />
	public static readonly OpCode Stind_R8             = new OpCode("stind.r8", StackBehaviour.Popi_popr8, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x57, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Add"]/*' />
	public static readonly OpCode Add                  = new OpCode("add", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x58, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Sub"]/*' />
	public static readonly OpCode Sub                  = new OpCode("sub", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x59, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Mul"]/*' />
	public static readonly OpCode Mul                  = new OpCode("mul", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5a, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Div"]/*' />
	public static readonly OpCode Div                  = new OpCode("div", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5b, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Div_Un"]/*' />
	public static readonly OpCode Div_Un               = new OpCode("div.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5c, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Rem"]/*' />
	public static readonly OpCode Rem                  = new OpCode("rem", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5d, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Rem_Un"]/*' />
	public static readonly OpCode Rem_Un               = new OpCode("rem.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5e, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.And"]/*' />
	public static readonly OpCode And                  = new OpCode("and", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x5f, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Or"]/*' />
	public static readonly OpCode Or                   = new OpCode("or", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x60, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Xor"]/*' />
	public static readonly OpCode Xor                  = new OpCode("xor", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x61, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Shl"]/*' />
	public static readonly OpCode Shl                  = new OpCode("shl", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x62, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Shr"]/*' />
	public static readonly OpCode Shr                  = new OpCode("shr", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x63, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Shr_Un"]/*' />
	public static readonly OpCode Shr_Un               = new OpCode("shr.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x64, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Neg"]/*' />
	public static readonly OpCode Neg                  = new OpCode("neg", StackBehaviour.Pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x65, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Not"]/*' />
	public static readonly OpCode Not                  = new OpCode("not", StackBehaviour.Pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x66, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_I1"]/*' />
	public static readonly OpCode Conv_I1              = new OpCode("conv.i1", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x67, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_I2"]/*' />
	public static readonly OpCode Conv_I2              = new OpCode("conv.i2", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x68, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_I4"]/*' />
	public static readonly OpCode Conv_I4              = new OpCode("conv.i4", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x69, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_I8"]/*' />
	public static readonly OpCode Conv_I8              = new OpCode("conv.i8", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x6a, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_R4"]/*' />
	public static readonly OpCode Conv_R4              = new OpCode("conv.r4", StackBehaviour.Pop1, StackBehaviour.Pushr4, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x6b, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_R8"]/*' />
	public static readonly OpCode Conv_R8              = new OpCode("conv.r8", StackBehaviour.Pop1, StackBehaviour.Pushr8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x6c, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_U4"]/*' />
	public static readonly OpCode Conv_U4              = new OpCode("conv.u4", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x6d, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_U8"]/*' />
	public static readonly OpCode Conv_U8              = new OpCode("conv.u8", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x6e, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Callvirt"]/*' />
	public static readonly OpCode Callvirt             = new OpCode("callvirt", StackBehaviour.Varpop, StackBehaviour.Varpush, OperandType.InlineMethod, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x6f, FlowControl.Call, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Cpobj"]/*' />
	public static readonly OpCode Cpobj                = new OpCode("cpobj", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x70, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldobj"]/*' />
	public static readonly OpCode Ldobj                = new OpCode("ldobj", StackBehaviour.Popi, StackBehaviour.Push1, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x71, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldstr"]/*' />
	public static readonly OpCode Ldstr                = new OpCode("ldstr", StackBehaviour.Pop0, StackBehaviour.Pushref, OperandType.InlineString, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x72, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Newobj"]/*' />
	public static readonly OpCode Newobj               = new OpCode("newobj", StackBehaviour.Varpop, StackBehaviour.Pushref, OperandType.InlineMethod, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x73, FlowControl.Call, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Castclass"]/*' />
	public static readonly OpCode Castclass            = new OpCode("castclass", StackBehaviour.Popref, StackBehaviour.Pushref, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x74, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Isinst"]/*' />
	public static readonly OpCode Isinst               = new OpCode("isinst", StackBehaviour.Popref, StackBehaviour.Pushi, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x75, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_R_Un"]/*' />
	public static readonly OpCode Conv_R_Un            = new OpCode("conv.r.un", StackBehaviour.Pop1, StackBehaviour.Pushr8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x76, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Unbox"]/*' />
	public static readonly OpCode Unbox                = new OpCode("unbox", StackBehaviour.Popref, StackBehaviour.Pushi, OperandType.InlineType, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x79, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Throw"]/*' />
	public static readonly OpCode Throw                = new OpCode("throw", StackBehaviour.Popref, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7a, FlowControl.Throw, true,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldfld"]/*' />
	public static readonly OpCode Ldfld                = new OpCode("ldfld", StackBehaviour.Popref, StackBehaviour.Push1, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7b, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldflda"]/*' />
	public static readonly OpCode Ldflda               = new OpCode("ldflda", StackBehaviour.Popref, StackBehaviour.Pushi, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7c, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stfld"]/*' />
	public static readonly OpCode Stfld                = new OpCode("stfld", StackBehaviour.Popref_pop1, StackBehaviour.Push0, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7d, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldsfld"]/*' />
	public static readonly OpCode Ldsfld               = new OpCode("ldsfld", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7e, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldsflda"]/*' />
	public static readonly OpCode Ldsflda              = new OpCode("ldsflda", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x7f, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stsfld"]/*' />
	public static readonly OpCode Stsfld               = new OpCode("stsfld", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineField, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x80, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stobj"]/*' />
	public static readonly OpCode Stobj                = new OpCode("stobj", StackBehaviour.Popi_pop1, StackBehaviour.Push0, OperandType.InlineType, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x81, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I1_Un"]/*' />
	public static readonly OpCode Conv_Ovf_I1_Un       = new OpCode("conv.ovf.i1.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x82, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I2_Un"]/*' />
	public static readonly OpCode Conv_Ovf_I2_Un       = new OpCode("conv.ovf.i2.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x83, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I4_Un"]/*' />
	public static readonly OpCode Conv_Ovf_I4_Un       = new OpCode("conv.ovf.i4.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x84, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I8_Un"]/*' />
	public static readonly OpCode Conv_Ovf_I8_Un       = new OpCode("conv.ovf.i8.un", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x85, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U1_Un"]/*' />
	public static readonly OpCode Conv_Ovf_U1_Un       = new OpCode("conv.ovf.u1.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x86, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U2_Un"]/*' />
	public static readonly OpCode Conv_Ovf_U2_Un       = new OpCode("conv.ovf.u2.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x87, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U4_Un"]/*' />
	public static readonly OpCode Conv_Ovf_U4_Un       = new OpCode("conv.ovf.u4.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x88, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U8_Un"]/*' />
	public static readonly OpCode Conv_Ovf_U8_Un       = new OpCode("conv.ovf.u8.un", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x89, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I_Un"]/*' />
	public static readonly OpCode Conv_Ovf_I_Un        = new OpCode("conv.ovf.i.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x8a, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U_Un"]/*' />
	public static readonly OpCode Conv_Ovf_U_Un        = new OpCode("conv.ovf.u.un", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x8b, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Box"]/*' />
	public static readonly OpCode Box                  = new OpCode("box", StackBehaviour.Pop1, StackBehaviour.Pushref, OperandType.InlineType, OpCodeType.Primitive, 1, (byte)0xff, (byte)0x8c, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Newarr"]/*' />
	public static readonly OpCode Newarr               = new OpCode("newarr", StackBehaviour.Popi, StackBehaviour.Pushref, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x8d, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldlen"]/*' />
	public static readonly OpCode Ldlen                = new OpCode("ldlen", StackBehaviour.Popref, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x8e, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelema"]/*' />
	public static readonly OpCode Ldelema              = new OpCode("ldelema", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineType, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x8f, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_I1"]/*' />
	public static readonly OpCode Ldelem_I1            = new OpCode("ldelem.i1", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x90, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_U1"]/*' />
	public static readonly OpCode Ldelem_U1            = new OpCode("ldelem.u1", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x91, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_I2"]/*' />
	public static readonly OpCode Ldelem_I2            = new OpCode("ldelem.i2", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x92, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_U2"]/*' />
	public static readonly OpCode Ldelem_U2            = new OpCode("ldelem.u2", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x93, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_I4"]/*' />
	public static readonly OpCode Ldelem_I4            = new OpCode("ldelem.i4", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x94, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_U4"]/*' />
	public static readonly OpCode Ldelem_U4            = new OpCode("ldelem.u4", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x95, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_I8"]/*' />
	public static readonly OpCode Ldelem_I8            = new OpCode("ldelem.i8", StackBehaviour.Popref_popi, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x96, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_I"]/*' />
	public static readonly OpCode Ldelem_I             = new OpCode("ldelem.i", StackBehaviour.Popref_popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x97, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_R4"]/*' />
	public static readonly OpCode Ldelem_R4            = new OpCode("ldelem.r4", StackBehaviour.Popref_popi, StackBehaviour.Pushr4, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x98, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_R8"]/*' />
	public static readonly OpCode Ldelem_R8            = new OpCode("ldelem.r8", StackBehaviour.Popref_popi, StackBehaviour.Pushr8, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x99, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldelem_Ref"]/*' />
	public static readonly OpCode Ldelem_Ref           = new OpCode("ldelem.ref", StackBehaviour.Popref_popi, StackBehaviour.Pushref, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9a, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_I"]/*' />
	public static readonly OpCode Stelem_I             = new OpCode("stelem.i", StackBehaviour.Popref_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9b, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_I1"]/*' />
	public static readonly OpCode Stelem_I1            = new OpCode("stelem.i1", StackBehaviour.Popref_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9c, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_I2"]/*' />
	public static readonly OpCode Stelem_I2            = new OpCode("stelem.i2", StackBehaviour.Popref_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9d, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_I4"]/*' />
	public static readonly OpCode Stelem_I4            = new OpCode("stelem.i4", StackBehaviour.Popref_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9e, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_I8"]/*' />
	public static readonly OpCode Stelem_I8            = new OpCode("stelem.i8", StackBehaviour.Popref_popi_popi8, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0x9f, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_R4"]/*' />
	public static readonly OpCode Stelem_R4            = new OpCode("stelem.r4", StackBehaviour.Popref_popi_popr4, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0xa0, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_R8"]/*' />
	public static readonly OpCode Stelem_R8            = new OpCode("stelem.r8", StackBehaviour.Popref_popi_popr8, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0xa1, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stelem_Ref"]/*' />
	public static readonly OpCode Stelem_Ref           = new OpCode("stelem.ref", StackBehaviour.Popref_popi_popref, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 1, (byte)0xff, (byte)0xa2, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I1"]/*' />
	public static readonly OpCode Conv_Ovf_I1          = new OpCode("conv.ovf.i1", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb3, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U1"]/*' />
	public static readonly OpCode Conv_Ovf_U1          = new OpCode("conv.ovf.u1", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb4, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I2"]/*' />
	public static readonly OpCode Conv_Ovf_I2          = new OpCode("conv.ovf.i2", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb5, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U2"]/*' />
	public static readonly OpCode Conv_Ovf_U2          = new OpCode("conv.ovf.u2", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb6, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I4"]/*' />
	public static readonly OpCode Conv_Ovf_I4          = new OpCode("conv.ovf.i4", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb7, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U4"]/*' />
	public static readonly OpCode Conv_Ovf_U4          = new OpCode("conv.ovf.u4", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb8, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I8"]/*' />
	public static readonly OpCode Conv_Ovf_I8          = new OpCode("conv.ovf.i8", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xb9, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U8"]/*' />
	public static readonly OpCode Conv_Ovf_U8          = new OpCode("conv.ovf.u8", StackBehaviour.Pop1, StackBehaviour.Pushi8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xba, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Refanyval"]/*' />
	public static readonly OpCode Refanyval            = new OpCode("refanyval", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineType, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xc2, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ckfinite"]/*' />
	public static readonly OpCode Ckfinite             = new OpCode("ckfinite", StackBehaviour.Pop1, StackBehaviour.Pushr8, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xc3, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Mkrefany"]/*' />
	public static readonly OpCode Mkrefany             = new OpCode("mkrefany", StackBehaviour.Popi, StackBehaviour.Push1, OperandType.InlineType, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xc6, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldtoken"]/*' />
	public static readonly OpCode Ldtoken              = new OpCode("ldtoken", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineTok, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd0, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_U2"]/*' />
	public static readonly OpCode Conv_U2              = new OpCode("conv.u2", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd1, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_U1"]/*' />
	public static readonly OpCode Conv_U1              = new OpCode("conv.u1", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd2, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_I"]/*' />
	public static readonly OpCode Conv_I               = new OpCode("conv.i", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd3, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_I"]/*' />
	public static readonly OpCode Conv_Ovf_I           = new OpCode("conv.ovf.i", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd4, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_Ovf_U"]/*' />
	public static readonly OpCode Conv_Ovf_U           = new OpCode("conv.ovf.u", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd5, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Add_Ovf"]/*' />
	public static readonly OpCode Add_Ovf              = new OpCode("add.ovf", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd6, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Add_Ovf_Un"]/*' />
	public static readonly OpCode Add_Ovf_Un           = new OpCode("add.ovf.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd7, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Mul_Ovf"]/*' />
	public static readonly OpCode Mul_Ovf              = new OpCode("mul.ovf", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd8, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Mul_Ovf_Un"]/*' />
	public static readonly OpCode Mul_Ovf_Un           = new OpCode("mul.ovf.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xd9, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Sub_Ovf"]/*' />
	public static readonly OpCode Sub_Ovf              = new OpCode("sub.ovf", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xda, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Sub_Ovf_Un"]/*' />
	public static readonly OpCode Sub_Ovf_Un           = new OpCode("sub.ovf.un", StackBehaviour.Pop1_pop1, StackBehaviour.Push1, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xdb, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Endfinally"]/*' />
	public static readonly OpCode Endfinally           = new OpCode("endfinally", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xdc, FlowControl.Return, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Leave"]/*' />
	public static readonly OpCode Leave                = new OpCode("leave", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineBrTarget, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xdd, FlowControl.Branch, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Leave_S"]/*' />
	public static readonly OpCode Leave_S              = new OpCode("leave.s", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.ShortInlineBrTarget, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xde, FlowControl.Branch, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stind_I"]/*' />
	public static readonly OpCode Stind_I              = new OpCode("stind.i", StackBehaviour.Popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xdf, FlowControl.Next, false,  -2);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Conv_U"]/*' />
	public static readonly OpCode Conv_U               = new OpCode("conv.u", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 1, (byte)0xff, (byte)0xe0, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix7"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix7              = new OpCode("prefix7", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xf8, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix6"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix6              = new OpCode("prefix6", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xf9, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix5"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix5              = new OpCode("prefix5", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xfa, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix4"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix4              = new OpCode("prefix4", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xfb, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix3"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix3              = new OpCode("prefix3", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xfc, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix2"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix2              = new OpCode("prefix2", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xfd, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefix1"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefix1              = new OpCode("prefix1", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xfe, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Prefixref"]/*' />
	/// <internalonly/>
	public static readonly OpCode Prefixref            = new OpCode("prefixref", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Nternal, 1, (byte)0xff, (byte)0xff, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Arglist"]/*' />
	public static readonly OpCode Arglist              = new OpCode("arglist", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x0, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ceq"]/*' />
	public static readonly OpCode Ceq                  = new OpCode("ceq", StackBehaviour.Pop1_pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x1, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Cgt"]/*' />
	public static readonly OpCode Cgt                  = new OpCode("cgt", StackBehaviour.Pop1_pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x2, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Cgt_Un"]/*' />
	public static readonly OpCode Cgt_Un               = new OpCode("cgt.un", StackBehaviour.Pop1_pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x3, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Clt"]/*' />
	public static readonly OpCode Clt                  = new OpCode("clt", StackBehaviour.Pop1_pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x4, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Clt_Un"]/*' />
	public static readonly OpCode Clt_Un               = new OpCode("clt.un", StackBehaviour.Pop1_pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x5, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldftn"]/*' />
	public static readonly OpCode Ldftn                = new OpCode("ldftn", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineMethod, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x6, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldvirtftn"]/*' />
	public static readonly OpCode Ldvirtftn            = new OpCode("ldvirtftn", StackBehaviour.Popref, StackBehaviour.Pushi, OperandType.InlineMethod, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x7, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarg"]/*' />
	public static readonly OpCode Ldarg                = new OpCode("ldarg", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x9, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldarga"]/*' />
	public static readonly OpCode Ldarga               = new OpCode("ldarga", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xa, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Starg"]/*' />
	public static readonly OpCode Starg                = new OpCode("starg", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xb, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloc"]/*' />
	public static readonly OpCode Ldloc                = new OpCode("ldloc", StackBehaviour.Pop0, StackBehaviour.Push1, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xc, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Ldloca"]/*' />
	public static readonly OpCode Ldloca               = new OpCode("ldloca", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xd, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Stloc"]/*' />
	public static readonly OpCode Stloc                = new OpCode("stloc", StackBehaviour.Pop1, StackBehaviour.Push0, OperandType.InlineVar, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xe, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Localloc"]/*' />
	public static readonly OpCode Localloc             = new OpCode("localloc", StackBehaviour.Popi, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0xf, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Endfilter"]/*' />
	public static readonly OpCode Endfilter            = new OpCode("endfilter", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x11, FlowControl.Return, true,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Unaligned"]/*' />
	public static readonly OpCode Unaligned            = new OpCode("unaligned.", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.ShortInlineI, OpCodeType.Prefix, 2, (byte)0xfe, (byte)0x12, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Volatile"]/*' />
	public static readonly OpCode Volatile             = new OpCode("volatile.", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Prefix, 2, (byte)0xfe, (byte)0x13, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Tailcall"]/*' />
	public static readonly OpCode Tailcall             = new OpCode("tail.", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Prefix, 2, (byte)0xfe, (byte)0x14, FlowControl.Meta, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Initobj"]/*' />
	public static readonly OpCode Initobj              = new OpCode("initobj", StackBehaviour.Popi, StackBehaviour.Push0, OperandType.InlineType, OpCodeType.Objmodel, 2, (byte)0xfe, (byte)0x15, FlowControl.Next, false,  -1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Cpblk"]/*' />
	public static readonly OpCode Cpblk                = new OpCode("cpblk", StackBehaviour.Popi_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x17, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Initblk"]/*' />
	public static readonly OpCode Initblk              = new OpCode("initblk", StackBehaviour.Popi_popi_popi, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x18, FlowControl.Next, false,  -3);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Rethrow"]/*' />
	public static readonly OpCode Rethrow              = new OpCode("rethrow", StackBehaviour.Pop0, StackBehaviour.Push0, OperandType.InlineNone, OpCodeType.Objmodel, 2, (byte)0xfe, (byte)0x1a, FlowControl.Throw, true,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Sizeof"]/*' />
	public static readonly OpCode Sizeof               = new OpCode("sizeof", StackBehaviour.Pop0, StackBehaviour.Pushi, OperandType.InlineType, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x1c, FlowControl.Next, false,  1);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.Refanytype"]/*' />
	public static readonly OpCode Refanytype           = new OpCode("refanytype", StackBehaviour.Pop1, StackBehaviour.Pushi, OperandType.InlineNone, OpCodeType.Primitive, 2, (byte)0xfe, (byte)0x1d, FlowControl.Next, false,  0);

	/// <include file='doc\OpCodes.uex' path='docs/doc[@for="OpCodes.TakesSingleByteArgument"]/*' />
	public static bool TakesSingleByteArgument(OpCode inst)
	{
		switch(inst.m_operand)
		{
			case OperandType.ShortInlineBrTarget :
			case OperandType.ShortInlineI :
			case OperandType.ShortInlineVar :
			return true;
		};
		return false;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\parametertoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ParameterToken
**
** Author: meichint
**
** Purpose: metadata tokens for a parameter
**
** Date:  Aug 99
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    // The ParameterToken class is an opaque representation of the Token returned
    // by the MetaData to represent the parameter. 
    /// <include file='doc\ParameterToken.uex' path='docs/doc[@for="ParameterToken"]/*' />
	[Serializable()]  
    public struct ParameterToken {
    
		/// <include file='doc\ParameterToken.uex' path='docs/doc[@for="ParameterToken.Empty"]/*' />
		public static readonly ParameterToken Empty = new ParameterToken();
        internal int m_tkParameter;
    
        //public ParameterToken() {
        //    m_tkParameter=0;
        //}
        
        internal ParameterToken(int tkParam) {
            m_tkParameter = tkParam;
        }
    
        /// <include file='doc\ParameterToken.uex' path='docs/doc[@for="ParameterToken.Token"]/*' />
        public int Token {
            get { return m_tkParameter; }
        }
        
        // Satisfy JVC's value class requirements
    	/// <include file='doc\ParameterToken.uex' path='docs/doc[@for="ParameterToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_tkParameter;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\ParameterToken.uex' path='docs/doc[@for="ParameterToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is ParameterToken))
    			return ((ParameterToken)obj).Token == m_tkParameter;
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\propertytoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  PropertyToken
**
** Author: Mei-Chin Tsai
**
** Propertybuilder is for client to define properties for a class
**
** Date: June 7, 99
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\PropertyToken.uex' path='docs/doc[@for="PropertyToken"]/*' />
	[Serializable()] 
    public struct PropertyToken {
    
		/// <include file='doc\PropertyToken.uex' path='docs/doc[@for="PropertyToken.Empty"]/*' />
		public static readonly PropertyToken Empty = new PropertyToken();

        internal int m_property;
    
        /// <include file='doc\PropertyToken.uex' path='docs/doc[@for="PropertyToken.Token"]/*' />
        public int Token {
            get { return m_property; }
        }
    	
    	// Satisfy value class requirements
    	/// <include file='doc\PropertyToken.uex' path='docs/doc[@for="PropertyToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_property;
    	}
    	
    	// Satisfy value class requirements
    	/// <include file='doc\PropertyToken.uex' path='docs/doc[@for="PropertyToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is PropertyToken))
    			return ((PropertyToken)obj).m_property == m_property;
    		else
    			return false;
    	}
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\pefilekinds.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit {
    
	using System;
    // This Enum matchs the CorFieldAttr defined in CorHdr.h
    /// <include file='doc\PEFileKinds.uex' path='docs/doc[@for="PEFileKinds"]/*' />
	[Serializable()] 
    public enum PEFileKinds
    {
        /// <include file='doc\PEFileKinds.uex' path='docs/doc[@for="PEFileKinds.Dll"]/*' />
        Dll			=   0x0001,  
		/// <include file='doc\PEFileKinds.uex' path='docs/doc[@for="PEFileKinds.ConsoleApplication"]/*' />
		ConsoleApplication = 0x0002,
		/// <include file='doc\PEFileKinds.uex' path='docs/doc[@for="PEFileKinds.WindowApplication"]/*' />
		WindowApplication = 0x0003,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\signaturetoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Signature:  SignatureToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Signature to the ILGenerator signature.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\SignatureToken.uex' path='docs/doc[@for="SignatureToken"]/*' />
	[Serializable()] 
    public struct SignatureToken {
    
		/// <include file='doc\SignatureToken.uex' path='docs/doc[@for="SignatureToken.Empty"]/*' />
		public static readonly SignatureToken Empty = new SignatureToken();

        internal int m_signature;
        internal ModuleBuilder m_moduleBuilder;
          
        internal SignatureToken(int str, ModuleBuilder mod) {
            m_signature=str;
            m_moduleBuilder = mod;
        }
    
        /// <include file='doc\SignatureToken.uex' path='docs/doc[@for="SignatureToken.Token"]/*' />
        public int Token {
            get { return m_signature; }
        }
    	
        // Satisfy JVC's value class requirements
    	/// <include file='doc\SignatureToken.uex' path='docs/doc[@for="SignatureToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_signature;
    	}
    
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\SignatureToken.uex' path='docs/doc[@for="SignatureToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is SignatureToken))
    			return ((SignatureToken)obj).m_signature == m_signature;
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\propertybuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  PropertyBuilder
**
** Author: Mei-Chin Tsai
**
** Propertybuilder is for client to define properties for a class
**
** Date: June 7, 99
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
	using CultureInfo = System.Globalization.CultureInfo;
    // 
    // A PropertyBuilder is always associated with a TypeBuilder.  The TypeBuilder.DefineProperty
    // method will return a new PropertyBuilder to a client.
    // 
    /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder"]/*' />
    public sealed class PropertyBuilder : PropertyInfo
    { 
    
    	// Make a private constructor so these cannot be constructed externally.
        private PropertyBuilder() {}
    	
        // Constructs a PropertyBuilder.  
    	//
        internal PropertyBuilder(
    		Module			mod,					// the module containing this PropertyBuilder
    		String			name,					// property name
    		SignatureHelper	sig,					// property signature descriptor info
    		PropertyAttributes	attr,				// property attribute such as DefaultProperty, Bindable, DisplayBind, etc
			Type			returnType,				// return type of the property.
    		PropertyToken	prToken,				// the metadata token for this property
            TypeBuilder     containingType)         // the containing type
        {
            if (name == null)
                throw new ArgumentNullException("name");
			if (name.Length == 0)
				throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
            if (name[0] == '\0')
                throw new ArgumentException(Environment.GetResourceString("Argument_IllegalName"), "name");
    		
            m_name = name;
            m_module = mod;
            m_signature = sig;
            m_attributes = attr;
			m_returnType = returnType;
    		m_prToken = prToken;
            m_getMethod = null;
            m_setMethod = null;
            m_containingType = containingType;
        }
    
        //************************************************
        // Set the default value of the Property
        //************************************************
        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetConstant"]/*' />
        public void SetConstant(Object defaultValue) 
        {
            m_containingType.ThrowIfCreated();
        
            TypeBuilder.SetConstantValue(
                m_module,
                m_prToken.Token,
				m_returnType,
                defaultValue);
        }
        

    	// Return the Token for this property within the TypeBuilder that the
    	// property is defined within.
        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.PropertyToken"]/*' />
        public PropertyToken PropertyToken
        {
    		get {return m_prToken;}
        }
    
    	// @todo: we need to add in the corresponding ones that take MethodInfo
    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetGetMethod"]/*' />
    	public void SetGetMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            m_containingType.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_prToken.Token,
    			MethodSemanticsAttributes.Getter, 
    			mdBuilder.GetToken().Token);
            m_getMethod = mdBuilder;
    	}
    
    
    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetSetMethod"]/*' />
    	public void SetSetMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            m_containingType.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_prToken.Token,
    			MethodSemanticsAttributes.Setter, 
    			mdBuilder.GetToken().Token);
            m_setMethod = mdBuilder;                
    	}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.AddOtherMethod"]/*' />
    	public void AddOtherMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            m_containingType.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_prToken.Token,
    			MethodSemanticsAttributes.Other, 
    			mdBuilder.GetToken().Token);
    	}
    
		// Use this function if client decides to form the custom attribute blob themselves
    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetCustomAttribute"]/*' />
    	public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
    	{
    		if (con == null)
    			throw new ArgumentNullException("con");
    		if (binaryAttribute == null)
    			throw new ArgumentNullException("binaryAttribute");
    		
            m_containingType.ThrowIfCreated();
            TypeBuilder.InternalCreateCustomAttribute(
                m_prToken.Token,
                ((ModuleBuilder )m_module).GetConstructorToken(con).Token,
                binaryAttribute,
                m_module,
                false);
    	}

		// Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            if (customBuilder == null)
            {
    			throw new ArgumentNullException("customBuilder");
            }
            m_containingType.ThrowIfCreated();
            customBuilder.CreateCustomAttribute((ModuleBuilder)m_module, m_prToken.Token);
        }

		// Not supported functions in dynamic module.
		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetValue"]/*' />
		public override Object GetValue(Object obj,Object[] index)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetValue1"]/*' />
		public override Object GetValue(Object obj,BindingFlags invokeAttr,Binder binder,Object[] index,CultureInfo culture)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetValue"]/*' />
    	public override void SetValue(Object obj,Object value,Object[] index)
    	{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.SetValue1"]/*' />
    	public override void SetValue(Object obj,Object value,BindingFlags invokeAttr,Binder binder,Object[] index,CultureInfo culture)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetAccessors"]/*' />
		public override MethodInfo[] GetAccessors(bool nonPublic)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetGetMethod"]/*' />
    	public override MethodInfo GetGetMethod(bool nonPublic)
		{
            if (nonPublic || m_getMethod == null)
			    return m_getMethod;
            // now check to see if m_getMethod is public
            if ((m_getMethod.Attributes & MethodAttributes.Public) == MethodAttributes.Public)
                return m_getMethod;
            return null;
		}

		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetSetMethod"]/*' />
		public override MethodInfo GetSetMethod(bool nonPublic)
		{
            if (nonPublic || m_setMethod == null)
			    return m_setMethod;
            // now check to see if m_setMethod is public
            if ((m_setMethod.Attributes & MethodAttributes.Public) == MethodAttributes.Public)
                return m_setMethod;
            return null;
		}

		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetIndexParameters"]/*' />
		public override ParameterInfo[] GetIndexParameters()
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

		/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.PropertyType"]/*' />
		public override Type PropertyType {
    		get { return m_returnType; }
    	}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.Attributes"]/*' />
    	public override PropertyAttributes Attributes {
    		get { return m_attributes;}
    	}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.CanRead"]/*' />
    	public override bool CanRead {
    		get { if (m_getMethod != null) return true; else return false; } }

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.CanWrite"]/*' />
    	public override bool CanWrite {
    		get { if (m_setMethod != null) return true; else return false; }
    	}

        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

        /// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.IsDefined"]/*' />
        public override bool IsDefined (Type attributeType, bool inherit)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
		}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.Name"]/*' />
    	public override String Name {
    		get { return m_name; }
    	}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.DeclaringType"]/*' />
    	public override Type DeclaringType {
    		get { return m_containingType; }
    	}

    	/// <include file='doc\PropertyBuilder.uex' path='docs/doc[@for="PropertyBuilder.ReflectedType"]/*' />
    	public override Type ReflectedType {
    		get { return m_containingType; }
    	}

        // These are package private so that TypeBuilder can access them.
        private String				m_name;				// The name of the property
        private PropertyToken	    m_prToken;			// The token of this property
        private Module				m_module;
        private SignatureHelper		m_signature;
    	private PropertyAttributes  m_attributes;		// property's attribute flags
		private Type				m_returnType;		// property's return type
        private MethodInfo          m_getMethod;
        private MethodInfo          m_setMethod;
        private TypeBuilder         m_containingType;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\stringtoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StringToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a String to the ILGenerator class.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\StringToken.uex' path='docs/doc[@for="StringToken"]/*' />
	[Serializable()] 
    public struct StringToken {
    
        internal int m_string;
    
        //public StringToken() {
        //    m_string=0;
        //}
        
        internal StringToken(int str) {
            m_string=str;
        }
    
        // Returns the metadata token for this particular string.  
        // Generated by a call to Module.GetStringConstant().
        //
        /// <include file='doc\StringToken.uex' path='docs/doc[@for="StringToken.Token"]/*' />
        public int Token {
            get { return m_string; }
        }
        
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\StringToken.uex' path='docs/doc[@for="StringToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_string;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\StringToken.uex' path='docs/doc[@for="StringToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is StringToken))
    			return ((StringToken)obj).m_string == m_string;
    		else
    			return false;
    	}
    }








}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\symbolmethod.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymbolMethod
**
** Author: Mei-Chin Tsai
**
** This is a kind of MethodInfo to represent methods for array type of unbaked type
**
** Date:  Mar, 2000
** 
===========================================================*/
namespace System.Reflection.Emit {
	using System.Runtime.InteropServices;
	using System;
	using System.Reflection;
	using CultureInfo = System.Globalization.CultureInfo;
    
    sealed internal class SymbolMethod : MethodInfo
    {
        private ModuleBuilder       m_module;
        private Type                m_containingType;
        private String              m_name;
        private CallingConventions  m_callingConvention;
        private Type                m_returnType;
        private MethodToken         m_mdMethod;
        private Type[]              m_parameterTypes;
        private SignatureHelper     m_signature;

        //***********************************************
        //
        // Constructor
        // 
        //***********************************************
        internal SymbolMethod(
            ModuleBuilder mod,
            MethodToken token,
            Type        arrayClass, 
            String      methodName, 
            CallingConventions callingConvention,
            Type        returnType,
            Type[]      parameterTypes)

        {
            m_module = mod;
            m_containingType = arrayClass;
            m_name = methodName;
            m_callingConvention = callingConvention;
            m_returnType = returnType;
            m_mdMethod = token;
            if (parameterTypes != null)
            {
                m_parameterTypes = new Type[parameterTypes.Length];
                Array.Copy(parameterTypes, m_parameterTypes, parameterTypes.Length);
            }
            else
                m_parameterTypes = null;    
            m_signature = SignatureHelper.GetMethodSigHelper(mod, callingConvention, returnType, parameterTypes);
        }

        public Module GetModule()
        {
            return m_module;
        }

     	internal Type[] GetParameterTypes()
    	{
            return m_parameterTypes;
    	}

        public MethodToken GetToken()
        {
            return m_mdMethod;
        }

        internal MethodToken GetToken(ModuleBuilder mod)
        {
            return mod.GetArrayMethodToken(m_containingType, m_name, m_callingConvention, m_returnType, m_parameterTypes);
        }
    	
        /**********************************************
    	 * 
    	 * Abstract methods inherited from the base class
    	 * 
    	 **********************************************/
    	public override Type ReturnType {
    		get {
                return m_returnType;
            }
    	}

  		// This method will return an object that represents the 
		//	custom attributes for the return type.
		public override ICustomAttributeProvider ReturnTypeCustomAttributes {
			get {return null;} 
		}
                              
    	public override Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture)
    	{
    		// This will not be supported.
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}
    		
    	public  String Signature {
    		get {return m_signature.ToString();}
    	}
    
     	public override ParameterInfo[] GetParameters()
    	{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}
    		
    	public override MethodImplAttributes GetMethodImplementationFlags()
    	{
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}
    		
    	public override MethodAttributes Attributes {
    		get {    		
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
            }
    	}
    		
		public override CallingConventions CallingConvention {
    		get {return m_callingConvention;}
		}

    	public override Object[] GetCustomAttributes(bool inherit)
    	{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}
    		
    	// Return a custom attribute identified by Type
    	public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
    	{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}

		public override bool IsDefined(Type attributeType, bool inherit)
		{
    		// @todo: implement this
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));
    	}
    	
    	// Property representing the class that was used in reflection to obtain
    	// this Member.
    	public override Type ReflectedType {
    		get {return (Type) m_containingType;}
    	}

    	// Return the base implementation for a method.
    	public override MethodInfo GetBaseDefinition()
    	{
    		return this;
    	}
 
    
    	/**********************************************
         * Returns the name of this Method.
         * @return The name of this method class.
    	**********************************************/
    	public override String Name {
    		get { return m_name; }
    	}

		// Return the Type that declared this Method.
		//COOLPORT: Do something....
		public override Type DeclaringType {
    		get {return m_containingType;}
		}

 		// Method Handle routines
		public override RuntimeMethodHandle MethodHandle {
			get {throw new NotSupportedException(Environment.GetResourceString("NotSupported_SymbolMethod"));}
		}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\stackbehaviour.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**Class: StackBehaviour
**
**Author: Craig Schertz (cschertz)
**
**Purpose: Exposes StackBehaviour Attribute of IL .
**
** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND!
** See cschertz for more information.**
============================================================*/
namespace System.Reflection.Emit {

using System;

/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour"]/*' />
[Serializable]
public enum StackBehaviour
{

	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pop0"]/*' />
	Pop0	= 0,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pop1"]/*' />
	Pop1	= 1,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pop1_pop1"]/*' />
	Pop1_pop1	= 2,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi"]/*' />
	Popi	= 3,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_pop1"]/*' />
	Popi_pop1	= 4,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_popi"]/*' />
	Popi_popi	= 5,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_popi8"]/*' />
	Popi_popi8	= 6,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_popi_popi"]/*' />
	Popi_popi_popi	= 7,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_popr4"]/*' />
	Popi_popr4	= 8,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popi_popr8"]/*' />
	Popi_popr8	= 9,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref"]/*' />
	Popref	= 10,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_pop1"]/*' />
	Popref_pop1	= 11,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi"]/*' />
	Popref_popi	= 12,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi_popi"]/*' />
	Popref_popi_popi	= 13,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi_popi8"]/*' />
	Popref_popi_popi8	= 14,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi_popr4"]/*' />
	Popref_popi_popr4	= 15,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi_popr8"]/*' />
	Popref_popi_popr8	= 16,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Popref_popi_popref"]/*' />
	Popref_popi_popref	= 17,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Push0"]/*' />
	Push0	= 18,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Push1"]/*' />
	Push1	= 19,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Push1_push1"]/*' />
	Push1_push1	= 20,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pushi"]/*' />
	Pushi	= 21,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pushi8"]/*' />
	Pushi8	= 22,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pushr4"]/*' />
	Pushr4	= 23,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pushr8"]/*' />
	Pushr8	= 24,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Pushref"]/*' />
	Pushref	= 25,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Varpop"]/*' />
	Varpop	= 26,
	/// <include file='doc\StackBehaviour.uex' path='docs/doc[@for="StackBehaviour.Varpush"]/*' />
	Varpush	= 27,
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\signaturehelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit {
    using System.Text;
    using System;
    using System.Reflection;
	using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
        
    /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper"]/*' />
    public sealed class SignatureHelper {
        internal const int mdtTypeRef  = 0x01000000;
        internal const int mdtTypeDef  = 0x02000000;
        internal const int mdtTypeSpec = 0x21000000;
    
        //The following fields are duplicated from cor.h and must be kept in sync
        internal const byte ELEMENT_TYPE_END            = 0x0;
        internal const byte ELEMENT_TYPE_VOID           = 0x1;
        internal const byte ELEMENT_TYPE_BOOLEAN        = 0x2;  
        internal const byte ELEMENT_TYPE_CHAR           = 0x3;  
        internal const byte ELEMENT_TYPE_I1             = 0x4;  
        internal const byte ELEMENT_TYPE_U1             = 0x5; 
        internal const byte ELEMENT_TYPE_I2             = 0x6;  
        internal const byte ELEMENT_TYPE_U2             = 0x7;  
        internal const byte ELEMENT_TYPE_I4             = 0x8;  
        internal const byte ELEMENT_TYPE_U4             = 0x9;  
        internal const byte ELEMENT_TYPE_I8             = 0xa;  
        internal const byte ELEMENT_TYPE_U8             = 0xb;  
        internal const byte ELEMENT_TYPE_R4             = 0xc;  
        internal const byte ELEMENT_TYPE_R8             = 0xd;  
        internal const byte ELEMENT_TYPE_STRING         = 0xe;  
        
        internal const byte ELEMENT_TYPE_PTR            = 0x0f;     // PTR <type> 
        internal const byte ELEMENT_TYPE_BYREF          = 0x10;     // BYREF <type> 
        
        internal const byte ELEMENT_TYPE_VALUETYPE      = 0x11;     // VALUETYPE <class Token> 
        internal const byte ELEMENT_TYPE_CLASS          = 0x12;     // CLASS <class Token>  
        
        internal const byte ELEMENT_TYPE_ARRAY          = 0x14;     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

        internal const byte ELEMENT_TYPE_TYPEDBYREF     = 0x16;     // This is a simple type.       

        internal const byte ELEMENT_TYPE_I              = 0x18;     // native-pointer-sized integer.
        internal const byte ELEMENT_TYPE_U              = 0x19;     // native-pointer-sized unsigned integer.
        internal const byte ELEMENT_TYPE_FNPTR          = 0x1B;     // FNPTR <complete sig for the function including calling convention>
        internal const byte ELEMENT_TYPE_OBJECT         = 0x1C;     // Shortcut for System.Object
        internal const byte ELEMENT_TYPE_SZARRAY        = 0x1D;     // SZARRAY <type> : Shortcut for single dimension zero lower bound array
               
        internal const byte ELEMENT_TYPE_CMOD_REQD      = 0x1F;     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
        internal const byte ELEMENT_TYPE_CMOD_OPT       = 0x20;     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

        internal const byte ELEMENT_TYPE_MAX            = 0x22;     // first invalid element type   

        internal const byte ELEMENT_TYPE_SENTINEL       = 0x41;     // SENTINEL for vararg

        internal const int IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0;  
        internal const int IMAGE_CEE_UNMANAGED_CALLCONV_C    = 0x1;  
        internal const int IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL = 0x2;  
        internal const int IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL = 0x3;
        internal const int IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL = 0x4;
        
        internal const int IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5;  
        internal const int IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6;  
        internal const int IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7;
        internal const int IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8;
        internal const int IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9;
        internal const int IMAGE_CEE_CS_CALLCONV_MAX       = 0x10;   // first invalid calling convention    
            
        // The high bits of the calling convention convey additional info   
        internal const int IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f;  // Calling convention is bottom 4 bits 
        internal const int IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20;  // Top bit indicates a 'this' parameter    
        internal const int IMAGE_CEE_CS_CALLCONV_RETPARAM  = 0x40;  // The first param in the sig is really the return value   
    
        internal const int NO_SIZE_IN_SIG                  = -1;
        internal static readonly Type SystemObject         = typeof(System.Object);
        internal static readonly Type SystemString         = typeof(System.String);
    
        internal byte []            m_signature;
        internal int                m_currSig;              // index into m_signature buffer for next available byte
        internal int                m_sizeLoc;              // size of the m_signature buffer
        internal ModuleBuilder      m_module;
        internal bool               bSigDone;
        internal int                m_argCount;             // tracking number of arguments in the signature
    

        // Helper to determine is a type is a simple (built-in) type.   
        internal static bool IsSimpleType(int type)
        {
            if (type <= ELEMENT_TYPE_STRING) 
                return true;
            if (type == ELEMENT_TYPE_TYPEDBYREF || type == ELEMENT_TYPE_I || type == ELEMENT_TYPE_U || type == ELEMENT_TYPE_OBJECT) 
                return true;
            return false;
        }
        
        //************************************************
        //
        // private constructor. Use this constructor to instantiate a local var sig  or Field where
        // return type is not applied.
        //
        //************************************************
        private SignatureHelper(Module mod, int callingConvention) 
        {
            Init(mod, callingConvention);
        }
        
        //************************************************
        //
        // private constructor. Use this constructor to instantiate a any signatures that will require
        // a return type.
        //
        //************************************************
        private SignatureHelper(
            Module          mod, 
            int             callingConvention, 
            Type            returnType) 
        {        
            Init(mod, callingConvention);
            if (callingConvention==IMAGE_CEE_CS_CALLCONV_FIELD) {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadFieldSig"));
            }
    
            AddOneArgTypeHelper(returnType);               
           
        }

        private void Init(Module mod, int callingConvention)
        {        
            m_signature=new byte[32];
            m_currSig=0;
            m_module = (ModuleBuilder) mod;
            m_argCount=0;
            bSigDone=false;

            AddData(callingConvention);
            if (callingConvention==IMAGE_CEE_CS_CALLCONV_FIELD) 
            {
                m_sizeLoc = NO_SIZE_IN_SIG;
            } 
            else 
            {
                m_sizeLoc = m_currSig++;
            }
        }

    
        internal static SignatureHelper GetMethodSigHelper(
            Module          mod, 
            CallingConventions callingConvention, 
            Type            returnType, 
            Type[]          parameterTypes) 
        {
            SignatureHelper sigHelp;
            int             intCall;
                
            if (returnType == null)
            {
                returnType = typeof(void);
            }            

            intCall = IMAGE_CEE_CS_CALLCONV_DEFAULT;
            if ((callingConvention & CallingConventions.VarArgs) == CallingConventions.VarArgs)
            {
                intCall = IMAGE_CEE_CS_CALLCONV_VARARG;
            }

            if ((callingConvention & CallingConventions.HasThis) == CallingConventions.HasThis)
            {
                intCall |= IMAGE_CEE_CS_CALLCONV_HASTHIS;
            }

            sigHelp = new SignatureHelper(mod, intCall, (Type)returnType);
            
            if (parameterTypes != null)
            {
                for (int i=0; i<parameterTypes.Length; i++) 
                {
                    sigHelp.AddArgument(parameterTypes[i]);
                }
            }
            return sigHelp;
        }

        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetMethodSigHelper2"]/*' />
        public static SignatureHelper GetMethodSigHelper(
            Module          mod, 
            CallingConvention unmanagedCallConv, 
            Type            returnType) 
        {
            SignatureHelper sigHelp;
            int             intCall;
                
            if (returnType == null)
            {
                returnType = typeof(void);
            }            

            if (unmanagedCallConv ==  CallingConvention.Cdecl)
                intCall = IMAGE_CEE_UNMANAGED_CALLCONV_C;
            else if (unmanagedCallConv ==  CallingConvention.StdCall)
                intCall = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL;
            else if (unmanagedCallConv ==  CallingConvention.ThisCall)
                intCall = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL;
            else if (unmanagedCallConv ==  CallingConvention.FastCall)
                intCall = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL;
            else
                throw new ArgumentException(Environment.GetResourceString("Argument_UnknownUnmanagedCallConv"), "unmanagedCallConv");                          
            
            sigHelp = new SignatureHelper(mod, intCall, (Type)returnType);
            
            return sigHelp;
        }


        //************************************************
        //
        // Public static helpers to get different kinds of flavor of signatures.
        //
        //************************************************
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetLocalVarSigHelper"]/*' />
        public static SignatureHelper GetLocalVarSigHelper(Module mod) 
        {
            return new SignatureHelper(mod, IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
        }
        
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetFieldSigHelper"]/*' />
        public static SignatureHelper GetFieldSigHelper(Module mod) 
        {
            return new SignatureHelper(mod, IMAGE_CEE_CS_CALLCONV_FIELD);
        }
    
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetMethodSigHelper"]/*' />
        public static SignatureHelper GetMethodSigHelper(
            Module              mod, 
            CallingConventions  callingConvention, 
            Type                returnType) 
        {
            return GetMethodSigHelper(mod, callingConvention, returnType, null);
        }

        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetMethodSigHelper1"]/*' />
        public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes) 
        {
            return GetMethodSigHelper(mod, CallingConventions.Standard, returnType, parameterTypes);
        }
        
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetPropertySigHelper"]/*' />
        public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes) 
        {
            SignatureHelper sigHelp;
                
            if (returnType == null)
            {
                returnType = typeof(void);
            }            

            sigHelp = new SignatureHelper(mod, IMAGE_CEE_CS_CALLCONV_PROPERTY, (Type)returnType);
            
            if (parameterTypes != null)
            {
                for (int i=0; i<parameterTypes.Length; i++) 
                {
                    sigHelp.AddArgument(parameterTypes[i]);
                }
            }
            return sigHelp;
        }


        //************************************************
        //
        // Add an argument to the signature.  Takes a Type and determines whether it
        // is one of the primitive types of which we have special knowledge or a more
        // general class.  In the former case, we only add the appropriate short cut encoding, 
        // otherwise we will calculate proper description for the type.
        //
        //************************************************
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.AddArgument"]/*' />
        public void AddArgument(Type clsArgument) {
            if (bSigDone) {
                throw new ArgumentException(Environment.GetResourceString("Argument_SigIsFinalized"));
            }
    
            IncrementArgCounts();
    
            AddOneArgTypeHelper(clsArgument);
        }
    
        //************************************************
        //
        // Mark the vararg fix part. This is only used if client is creating a vararg signature call site.
        //
        //************************************************
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.AddSentinel"]/*' />
        public void AddSentinel()
        {
            AddElementType(ELEMENT_TYPE_SENTINEL);
        }

        //************************************************
        //
        // This function will not increase the argument count. It only fills in bytes 
        // in the signature based on clsArgument. This helper is called for return type.
        //
        //************************************************
        private void AddOneArgTypeHelper(Type clsArgument)
        {
            if (clsArgument == null)
                throw new ArgumentNullException("clsArgument");
            if (clsArgument is TypeBuilder)
            {
                TypeBuilder clsBuilder = (TypeBuilder) clsArgument;
                TypeToken   tkType;
                if (clsBuilder.Module == m_module)
                {
                    tkType = clsBuilder.TypeToken;
                }
                else
                {
                    tkType = m_module.GetTypeToken(clsArgument);
                }
                if (clsArgument.IsValueType) {
                    InternalAddTypeToken(tkType, ELEMENT_TYPE_VALUETYPE);
                } else {
                    InternalAddTypeToken(tkType, ELEMENT_TYPE_CLASS);
                }
            }
            else if (clsArgument is EnumBuilder)
            {
                TypeBuilder clsBuilder = ((EnumBuilder) clsArgument).m_typeBuilder;
                TypeToken   tkType;
                if (clsBuilder.Module == m_module)
                {
                    tkType = clsBuilder.TypeToken;
                }
                else
                {
                    tkType = m_module.GetTypeToken(clsArgument);
                }

                if (clsArgument.IsValueType) {
                    InternalAddTypeToken(tkType, ELEMENT_TYPE_VALUETYPE);
                } else {
                    InternalAddTypeToken(tkType, ELEMENT_TYPE_CLASS);
                }
            }
            else if (clsArgument is SymbolType)
            {
                SignatureBuffer sigBuf = new SignatureBuffer();
                SymbolType      symType = (SymbolType) clsArgument;
                int             i;

                // convert SymbolType to blob form
                symType.ToSigBytes(m_module, sigBuf);

                // add to our signature buffer
                // ensure the size of the signature buffer
                if ((m_currSig + sigBuf.m_curPos) > m_signature.Length)
                    m_signature = ExpandArray(m_signature, m_currSig + sigBuf.m_curPos);

                // copy over the signature segment
                for (i = 0; i < sigBuf.m_curPos; i++)
                {
                    m_signature[m_currSig++] = sigBuf.m_buf[i];
                }
            }
            else
            {
                if (clsArgument.IsByRef)
                {      
                    AddElementType(ELEMENT_TYPE_BYREF);
                    clsArgument = clsArgument.GetElementType();
                }

                if (clsArgument.IsArray || clsArgument.IsPointer)
                {
                    AddArrayOrPointer(clsArgument);
                    return;
                }
    
                RuntimeType rType = clsArgument as RuntimeType;
                int type = rType != null ? GetCorElementTypeFromClass(rType) : ELEMENT_TYPE_MAX;
                if (IsSimpleType(type)) 
                {
                    // base element type
                    AddElementType(type);
                } 
                else 
                {
                    if (clsArgument.IsValueType) 
                    {
                        InternalAddTypeToken(m_module.GetTypeToken(clsArgument), ELEMENT_TYPE_VALUETYPE);
                    } 
                    else 
                    {
                        if (clsArgument == SystemObject)
                            // use the short cut for System.Object
                            AddElementType(ELEMENT_TYPE_OBJECT);
                        else if (clsArgument == SystemString)
                            // use the short cut for System.String
                            AddElementType(ELEMENT_TYPE_STRING);
                        else                    
                            InternalAddTypeToken(m_module.GetTypeToken(clsArgument), ELEMENT_TYPE_CLASS);
                    }
                }
            }
        }
    
        //************************************************
        //
        // Adds an array type or signature to the signature.  
        // Most of the work for this method is done in
        // native because it is substantially easier to walk string array signatures there.
        // Arrays, and hence their signatures, can be arbitrarily complex so there is no way
        // of accurately predicting the length ahead of time.  We guess at a maximum of 10. If the
        // native method is unable to fit within that space, it returns the required length with the
        // high-bit turned on.  We expand the array to that size and then call the method again.
        //
        //************************************************
        internal void AddArrayOrPointer(Type clsArgument) 
        {
            if (clsArgument.IsPointer)
            {
                AddElementType(ELEMENT_TYPE_PTR);
                AddOneArgTypeHelper(clsArgument.GetElementType());
            }
            else
            {

                BCLDebug.Assert(clsArgument.IsArray, "Not an array type!");

                RuntimeType rType = clsArgument as RuntimeType;
                int type = rType != null ? GetCorElementTypeFromClass(rType) : ELEMENT_TYPE_MAX;
            
                if (type == ELEMENT_TYPE_SZARRAY)
                {
                    AddElementType(type);
                    AddOneArgTypeHelper(clsArgument.GetElementType());
                }
                if (type == ELEMENT_TYPE_ARRAY)
                {
                    
                    AddElementType(type);
                    AddOneArgTypeHelper(clsArgument.GetElementType());
                    // put the rank information
                    AddData(clsArgument.GetArrayRank());

                    // @todo: put the bound information
                    AddData(0);
                    AddData(0);

                }
            }
        }
    
        
    
        //************************************************
        //
        // A managed representation of CorSigCompressData; 
        // replicated here so that we don't have to call through to native
        // The signature is expanded automatically if there's not enough room.
        //
        //************************************************
        private void AddData(int data) 
        {
            if (m_currSig+4>=m_signature.Length) 
            {
                m_signature = ExpandArray(m_signature);
            }
    
            if (data<=0x7F) 
            {
                m_signature[m_currSig++] = (byte)(data&0xFF);
            } 
            else if (data<=0x3FFF) 
            {
                m_signature[m_currSig++] = (byte)((data>>8) | 0x80);
                m_signature[m_currSig++] = (byte)(data&0xFF);
            } 
            else if (data<=0x1FFFFFFF) 
            {
                m_signature[m_currSig++] = (byte)((data>>24) | 0xC0);
                m_signature[m_currSig++] = (byte)((data>>16) & 0xFF);
                m_signature[m_currSig++] = (byte)((data>>8)  & 0xFF);
                m_signature[m_currSig++] = (byte)((data)     & 0xFF);
            } 
            else 
            {
                // something is wrong here... If integer is too big to be encoded,
                // we should throw exception
                throw new ArgumentException(Environment.GetResourceString("Argument_LargeInteger"));
            }            
            
        }

        
        //************************************************
        //
        // Adds an element to the signature.  A managed represenation of CorSigCompressElement
        //
        //************************************************
        private void AddElementType(int cvt) 
        {
            if (m_currSig+1>=m_signature.Length) 
            {
                m_signature = ExpandArray(m_signature);
            }
            m_signature[m_currSig++]=(byte)cvt;
        }
    
        //************************************************
        //
        // A managed represenation of CompressToken
        // Pulls the token appart to get a rid, adds some appropriate bits
        // to the token and then adds this to the signature.
        //
        //************************************************
        private void AddToken(int token) 
        {
            int rid =  (token & 0x00FFFFFF); //This is RidFromToken;
            int type = (token & unchecked((int)0xFF000000)); //This is TypeFromToken;
    
            if (rid > 0x3FFFFFF) 
            {
                // token is too big to be compressed    
                throw new ArgumentException(Environment.GetResourceString("Argument_LargeInteger"));
            }
    
            rid = (rid << 2);   
            
            // TypeDef is encoded with low bits 00  
            // TypeRef is encoded with low bits 01  
            // TypeSpec is encoded with low bits 10    
            if (type==mdtTypeRef) 
            { 
                //if type is mdtTypeRef
                rid|=0x1;
            } 
            else if (type==mdtTypeSpec) 
            { 
                //if type is mdtTypeSpec
                rid|=0x2;
            }
    
            AddData(rid);
        }
    
        //************************************************
        //
        // Add a type token into signature. CorType will be either ELEMENT_TYPE_CLASS or ELEMENT_TYPE_VALUECLASS
        //
        //************************************************
        private void InternalAddTypeToken(TypeToken clsToken, int CorType) 
        {
            AddElementType(CorType);
            AddToken(clsToken.Token);
        }
    

        //************************************************
        //
        // Expand the signature buffer size
        //
        //************************************************
        private byte[] ExpandArray(byte[] inArray) 
        {
            return ExpandArray(inArray, inArray.Length*2);
        }
    
        //************************************************
        //
        // Expand the signature buffer size
        //
        //************************************************
        private byte[] ExpandArray(byte[] inArray, int requiredLength) 
        {
            if (requiredLength < inArray.Length) 
            {
                requiredLength = inArray.Length*2;
            }
            byte[] outArray = new byte[requiredLength];
            Array.Copy(inArray, outArray, inArray.Length);
            return outArray;
        }
    
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.Equals"]/*' />
        public override bool Equals(Object obj) 
        {
            if (!(obj is SignatureHelper)) 
            {
                return false;
            }
            
            SignatureHelper temp = (SignatureHelper)obj;
            
            if (temp.m_module !=m_module || temp.m_currSig!=m_currSig || temp.m_sizeLoc!=m_sizeLoc || temp.bSigDone !=bSigDone) 
            {
                return false;
            }
            
            for (int i=0; i<m_currSig; i++) 
            {
                if (m_signature[i]!=temp.m_signature[i]) 
                    return false;
            }
            return true;
        }
    
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            // Start the hash code with the hash code of the module and the values of the member variables.
            int HashCode = m_module.GetHashCode() + m_currSig + m_sizeLoc;

            // Add one if the sig is done.
            if (bSigDone)
                HashCode += 1;

            // Then add the hash code of all the arguments.
            for (int i=0; i < m_currSig; i++) 
                HashCode += m_signature[i].GetHashCode();

            return HashCode;
        }

        //************************************************
        //
        // Chops the internal signature to the appropriate length.  Adds the 
        // end token to the signature and marks the signature as finished so that
        // no further tokens can be added.
        //
        // return the full signature in a trimmed array.
        //
        //************************************************
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.GetSignature"]/*' />
        public byte[] GetSignature() 
        {
            if (!bSigDone) 
            {
                SetNumberOfSignatureElements(true);
                bSigDone=true;
            }
    
            //This case will only happen if the user got the signature through 
            //InternalGetSignature first and then called GetSignature.
            if (m_signature.Length>m_currSig) 
            {
                byte[] temp = new byte[m_currSig];
                Array.Copy(m_signature, temp, m_currSig);
                m_signature=temp;
            }
            return m_signature;
        }
    
        //************************************************
        //
        // Increase argument count
        //
        //************************************************
        private void IncrementArgCounts() 
        {
            if (m_sizeLoc==NO_SIZE_IN_SIG) 
            { 
                //We don't have a size if this is a field.
                return;
            }
            m_argCount++;
        }
    
        //************************************************
        //
        // An internal method to return the signature.  Does not trim the
        // array, but passes out the length of the array in an out parameter.
        // This is the actual array -- not a copy -- so the callee must agree
        // to not copy it.
        //
        // param length : an out param indicating the length of the array.
        // return : A reference to the internal ubyte array.
        //************************************************
        internal byte[] InternalGetSignature(out int length) 
        {
    
            if (!bSigDone) 
            {
                bSigDone=true;

                //If we have more than 128 variables, we can't just set the length, we need 
                //to compress it.  Unfortunately, this means that we need to copy the entire 
                //array.  Bummer, eh?
                SetNumberOfSignatureElements(false);
            }
    
            length = m_currSig;
            return m_signature;
        }
    
        //************************************************
        //
        // For most signatures, this will set the number of elements in a byte which we have reserved for it.
        // However, if we have a field signature, we don't set the length and return.
        // If we have a signature with more than 128 arguments, we can't just set the number of elements,
        // we actually have to allocate more space (e.g. shift everything in the array one or more spaces to the
        // right.  We do this by making a copy of the array and leaving the correct number of blanks.  This new
        // array is now set to be m_signature and we use the AddData method to set the number of elements properly.
        // The forceCopy argument can be used to force SetNumberOfSignatureElements to make a copy of
        // the array.  This is useful for GetSignature which promises to trim the array to be the correct size anyway.
        //
        //************************************************
        private void SetNumberOfSignatureElements(bool forceCopy) 
        {
            byte[] temp;
            int newSigSize;
            int currSigHolder = m_currSig;
    
            if (m_sizeLoc==NO_SIZE_IN_SIG) 
            {
                return;
            }
    
            //If we have fewer than 128 arguments and we haven't been told to copy the
            //array, we can just set the appropriate bit and return.
            if (m_argCount<0x80 && !forceCopy) 
            {
                m_signature[m_sizeLoc]=(byte)m_argCount;
                return;
            } 
    
            //We need to have more bytes for the size.  Figure out how many bytes here.
            //Since we need to copy anyway, we're just going to take the cost of doing a
            //new allocation.
            if (m_argCount<0x7F) 
                newSigSize=1;
            else if (m_argCount<0x3FFF) 
                newSigSize=2;
            else 
                newSigSize=4;
            
            //Allocate the new array.
            temp = new byte[m_currSig+newSigSize-1];
    
            //Copy the calling convention.  The calling convention is always just one byte
            //so we just copy that byte.  Then copy the rest of the array, shifting everything
            //to make room for the new number of elements.
            temp[0]=m_signature[0];
            Array.Copy(m_signature, m_sizeLoc+1, temp, m_sizeLoc+newSigSize, currSigHolder-(m_sizeLoc+1));
            m_signature=temp;
            
            //Use the AddData method to add the number of elements appropriately compressed.
            m_currSig=m_sizeLoc;
            AddData(m_argCount);
            m_currSig = currSigHolder+(newSigSize-1);
        }
    
        /// <include file='doc\SignatureHelper.uex' path='docs/doc[@for="SignatureHelper.ToString"]/*' />
        public override String ToString() 
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("Length: " + m_currSig + Environment.NewLine);
            if (m_sizeLoc!=-1) 
                sb.Append("Arguments: " + m_signature[m_sizeLoc] + Environment.NewLine);
            else 
                sb.Append("Field Signature" + Environment.NewLine);

            sb.Append("Signature: " + Environment.NewLine);
            for (int i=0; i<=m_currSig; i++) 
            {
                sb.Append(m_signature[i] + "  ");
            }

            sb.Append(Environment.NewLine);
            return sb.ToString();
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetCorElementTypeFromClass(RuntimeType cls);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\symboltype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymbolType
**
** Author: Mei-Chin Tsai
**
** This is a kind of Type object that will represent the compound expression
** of a parameter type or field type.
**
** Date:  Jan, 2000
** 
===========================================================*/
namespace System.Reflection.Emit {
	using System.Runtime.InteropServices;
	using System;
	using System.Reflection;
	using CultureInfo = System.Globalization.CultureInfo;
	[Serializable]
    internal enum TypeKind
    {
        IsArray                     = 1,
        IsPointer                   = 2,
        IsByRef                     = 3,
    }

    sealed internal class SymbolType : Type
    {

        //***********************************************
        //
        // Data members
        // 
        //***********************************************
        internal TypeKind       m_typeKind;
        internal Type           m_baseType;

        // for array type
        internal int            m_cRank;        // count of dimension

        // if LowerBound and UpperBound is equal, that means one element. If UpperBound is less than LowerBound,
        // then the size is not specified.
        internal int[]          m_iaLowerBound;
        internal int[]          m_iaUpperBound; // count of dimension

        private char[]          m_bFormat;      // format string to form the full name.



        //***********************************************
        //
        // This function takes a string to describe the compound type, such as "[,][]", and a baseType.
        // 
        // Example: [2..4]  - one dimension array with lower bound 2 and size of 3
        // Example: [3, 5, 6] - three dimension array with lower bound 3, 5, 6
        // Example: [-3, ] [] - one dimensional array of two dimensional array (with lower bound -3 for 
        //          the first dimension)
        // Example: []* - pointer to a one dimensional array
        // Example: *[] - one dimensional array. The element type is a pointer to the baseType
        // Example: []& - ByRef of a single dimensional array. Only one & is allowed and it must appear the last!
        // Example: [?] - Array with unknown bound
        //
        //***********************************************
        internal static Type FormCompoundType(char[] bFormat, Type baseType, int curIndex)
        {

            SymbolType     symbolType;
            int         iLowerBound;
            int         iUpperBound;

            if (bFormat == null || curIndex == bFormat.Length)
            {
                // we have consumed all of the format string
                return baseType;
            }

            // @todo: baseType cannot be already a array type or a pointer type.
            // We need to do checking here...

            if (bFormat[curIndex] == '&')
            {
                // ByRef case

                symbolType = new SymbolType(TypeKind.IsByRef);
                symbolType.SetFormat(bFormat, curIndex);
                curIndex++;
                if (curIndex != bFormat.Length)
                {
                    // ByRef has to be the last char!!
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadSigFormat"));
                }
                symbolType.SetElementType(baseType);
                return symbolType;

            }
            if (bFormat[curIndex] == '[')
            {
                // Array type.
                symbolType = new SymbolType(TypeKind.IsArray);
                symbolType.SetFormat(bFormat, curIndex);
                curIndex++;

                iLowerBound = 0;
                iUpperBound = -1;

                // Example: [2..4]  - one dimension array with lower bound 2 and size of 3
                // Example: [3, 5, 6] - three dimension array with lower bound 3, 5, 6
                // Example: [-3, ] [] - one dimensional array of two dimensional array (with lower bound -3 sepcified)
                while (bFormat[curIndex] != ']')
                {
                    // consume, one dimension at a time
                    if ((bFormat[curIndex] >= '0' && bFormat[curIndex] <= '9') || bFormat[curIndex] == '-')
                    {
                        bool    isNegative = false;
                        if (bFormat[curIndex] == '-')
                        {
                            isNegative = true;
                            curIndex++;
                        }

                        // lower bound is specified. Consume the low bound
                        while (bFormat[curIndex] >= '0' && bFormat[curIndex] <= '9')
                        {
                            iLowerBound = iLowerBound * 10;
                            iLowerBound += bFormat[curIndex] - '0';
                            curIndex++;
                        }
                        if (isNegative)
                        {
                            iLowerBound = 0 - iLowerBound;
                        }

                        // set the upper bound to be less than LowerBound to indicate that upper bound it not specified
                        // yet!
                        iUpperBound = iLowerBound - 1;

                    }
                    if (bFormat[curIndex] == '.')
                    {                       
                        // upper bound is specified

                        // skip over ".."
                        curIndex++;
                        if (bFormat[curIndex] != '.')
                        {
                            // bad format!! Throw exception
                            throw new ArgumentException(Environment.GetResourceString("Argument_BadSigFormat"));
                        }

                        curIndex++;
                        // consume the upper bound
                        if ((bFormat[curIndex] >= '0' && bFormat[curIndex] <= '9') || bFormat[curIndex] == '-')
                        {
                            bool    isNegative = false;
                            iUpperBound = 0;
                            if (bFormat[curIndex] == '-')
                            {
                                isNegative = true;
                                curIndex++;
                            }

                            // lower bound is specified. Consume the low bound
                            while (bFormat[curIndex] >= '0' && bFormat[curIndex] <= '9')
                            {
                                iUpperBound = iUpperBound * 10;
                                iUpperBound += bFormat[curIndex] - '0';
                                curIndex++;
                            }
                            if (isNegative)
                            {
                                iUpperBound = 0 - iUpperBound;
                            }
                            if (iUpperBound < iLowerBound)
                            {
                                // User specified upper bound less than lower bound, this is an error.
                                // Throw error exception.
                                throw new ArgumentException(Environment.GetResourceString("Argument_BadSigFormat"));
                            }
                        }
                    }

                    if (bFormat[curIndex] == ',')
                    {
                        // We have more dimension to deal with.
                        // now set the lower bound, the size, and increase the dimension count!
                        curIndex++;
                        symbolType.SetBounds(iLowerBound, iUpperBound);

                        // clear the lower and upper bound information for next dimension
                        iLowerBound = 0;
                        iUpperBound = -1;
                    }
					else if (bFormat[curIndex] != ']')
					{
						throw new ArgumentException(Environment.GetResourceString("Argument_BadSigFormat"));
					}
                }
                
                // The last dimension information
                symbolType.SetBounds(iLowerBound, iUpperBound);

                // skip over ']'
                curIndex++;

                // set the base type of array
                symbolType.SetElementType(baseType);
                return FormCompoundType(bFormat, symbolType, curIndex);
            }
            else if (bFormat[curIndex] == '*')
            {
                // pointer type.

                symbolType = new SymbolType(TypeKind.IsPointer);
                symbolType.SetFormat(bFormat, curIndex);
                curIndex++;
                symbolType.SetElementType(baseType);
                return FormCompoundType(bFormat, symbolType, curIndex);
            }
            return null;
        }

        //***********************************************
        //
        // Constructor
        // 
        //***********************************************
        internal SymbolType(TypeKind typeKind)
        {
            m_typeKind = typeKind;            
            m_iaLowerBound = new int[4];
            m_iaUpperBound = new int[4];
        }

        //***********************************************
        //
        // Set the base ElementType
        // 
        //***********************************************
        internal void SetElementType(Type baseType)
        {
            if (baseType == null)
                throw new ArgumentNullException("baseType");
            m_baseType = baseType;
        }

        //***********************************************
        //
        // Increase the rank, set lower and upper bound
        // 
        //***********************************************
        internal void SetBounds(int lower, int upper)
        {
            if (m_iaLowerBound.Length <= m_cRank)
            {
                // resize the bound array
                int[]  iaTemp = new int[m_cRank * 2];
                Array.Copy(m_iaLowerBound, iaTemp, m_cRank);
                m_iaLowerBound = iaTemp;            
                Array.Copy(m_iaUpperBound, iaTemp, m_cRank);
                m_iaUpperBound = iaTemp;            
            }
            m_iaLowerBound[m_cRank] = lower;
            m_iaUpperBound[m_cRank] = upper;
            m_cRank++;
        }

        //***********************************************
        //
        // Cache the text display format for this SymbolType
        // 
        //***********************************************
        internal void SetFormat(char[] bFormat, int curIndex)
        {
            char[]  bFormatTemp = new char[bFormat.Length - curIndex];
            Array.Copy(bFormat, curIndex, bFormatTemp, 0, bFormat.Length - curIndex);
            m_bFormat = bFormatTemp;
        }

        //***********************************************
        //
        // Translate the type into signature format
        // 
        //***********************************************
        internal void ToSigBytes(ModuleBuilder moduleBuilder, SignatureBuffer sigBuf)
        {

            bool        isArray = false;

            // now process whatever information that we have here.
            if (m_typeKind == TypeKind.IsArray)
            {
                if (m_cRank == 1 && m_iaLowerBound[0] == 0 && m_iaUpperBound[0] == -1)
                {
                    // zero lower bound, unspecified count. So simplify to SZARRAY
                    sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_SZARRAY);
                }
                else
                {
                    // ELEMENT_TYPE_ARRAY :  ARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  
                    // @todo: fill the signature blob
                    sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_ARRAY);
                    isArray = true;
                }
            }
            else if (m_typeKind == TypeKind.IsPointer)
            {
                sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_PTR);
            }
            else if (m_typeKind == TypeKind.IsByRef)
            {
                sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_BYREF);
            }

            if (m_baseType is SymbolType)
            {
                // the base type is still a SymbolType. So recursively form the signature blob
                ((SymbolType) m_baseType).ToSigBytes(moduleBuilder, sigBuf);
            }
            else
            {
                // we have walked to the most nested class.
				
				int     cvType;
                if (m_baseType is RuntimeType)
                    cvType = SignatureHelper.GetCorElementTypeFromClass((RuntimeType)m_baseType);
				else
					cvType = SignatureHelper.ELEMENT_TYPE_MAX;
					
                if (SignatureHelper.IsSimpleType(cvType)) 
                {
                    sigBuf.AddElementType(cvType);
                } 
                else 
                {
                    if (m_baseType.IsValueType) 
                    {                 
                        sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_VALUETYPE);
                        sigBuf.AddToken(moduleBuilder.GetTypeToken(m_baseType).Token);
                    } 
                    else if (m_baseType == SignatureHelper.SystemObject)
						sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_OBJECT);
					else if (m_baseType == SignatureHelper.SystemString)
						sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_STRING);
					else
                    {
                        sigBuf.AddElementType(SignatureHelper.ELEMENT_TYPE_CLASS);
                        sigBuf.AddToken(moduleBuilder.GetTypeToken(m_baseType).Token);
                    }
                }
            }
            if (isArray)
            {
                // ELEMENT_TYPE_ARRAY :  ARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  
                // generic array!! Put in the dimension, sizes and lower bounds information.
                
                int     index;
                int     i;

                sigBuf.AddData(m_cRank);
                
                // determine the number of dimensions that we have to specify the size
                for (index = m_cRank - 1; index >= 0 && m_iaLowerBound[index] > m_iaUpperBound[index]; index--);
                sigBuf.AddData(index + 1);
                for (i=0; i <= index; i++)
                {
                    if (m_iaLowerBound[index] > m_iaUpperBound[index])
                    {
                        // bad signature!!
                        throw new ArgumentException(Environment.GetResourceString("Argument_BadSigFormat"));
                    }
                    else
                    {
                        sigBuf.AddData(m_iaUpperBound[i] - m_iaLowerBound[i] + 1);
                    }
                }


                // loop from last dimension back to first dimension. Look for the first one that does
                // not have lower bound equals to zero. If this is index, then 0..index has to specify the
                // lower bound.
                for (index = m_cRank - 1; index >= 0 && m_iaLowerBound[index] == 0; index--);
                sigBuf.AddData(index + 1);
                for (i=0; i <= index; i++)
                {
                    sigBuf.AddInteger(m_iaLowerBound[i]);
                }

            }
        }

        
        //****************************************************
        // 
        // abstract methods defined in the base class
        // 
        //************************************************        
        public override int GetArrayRank() {
            if (IsArray)
            {
                return m_cRank;
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SubclassOverride"));
        }
        
        public override Guid GUID {
            get {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
            }
        }

        public override Object InvokeMember(
            String      name,
            BindingFlags invokeAttr,
            Binder     binder,
            Object      target,
            Object[]   args,
            ParameterModifier[]       modifiers,
            CultureInfo culture,
            String[]    namedParameters)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

        public override Module Module {
            get {
                Type baseType;
                for (baseType = m_baseType; baseType is SymbolType; baseType = ((SymbolType) baseType).m_baseType);
                return baseType.Module;
            }
        }
        
        public override Assembly Assembly {
            get {
                Type baseType;
                for (baseType = m_baseType; baseType is SymbolType; baseType = ((SymbolType) baseType).m_baseType);
                return baseType.Assembly;
            }
        }
        
        public override RuntimeTypeHandle TypeHandle {
             get {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
            }     
        }
    
        public override String Name {
            get { 
                Type baseType;
				SymbolType compundType = this;
                for (baseType = m_baseType; baseType is SymbolType; baseType = ((SymbolType)baseType).m_baseType)
					compundType = (SymbolType)baseType; 
                String sFormat = new String(compundType.m_bFormat);
                return baseType.Name + sFormat;
            }
        }
        
        public override String FullName {
            get { 
                Type baseType;
				SymbolType compundType = this;
                for (baseType = m_baseType; baseType is SymbolType; baseType = ((SymbolType)baseType).m_baseType)
					compundType = (SymbolType)baseType; 
                String sFormat = new String(compundType.m_bFormat);
                return baseType.FullName + sFormat;
            }
        }

        public override String AssemblyQualifiedName {
            get { 
                Assembly container = this.Module.Assembly;
                if(container != null) {
                    return Assembly.CreateQualifiedName(container.FullName, this.FullName); 
                }
                else 
                    return Assembly.CreateQualifiedName(null, this.FullName); 
            }
        }
            
        // Return the name of the class.  The name does not contain the namespace.
        public override String ToString(){
            return FullName;
        }

    
        public override String Namespace {
            get { return m_baseType.Namespace;}
        }
    
        public override Type BaseType {
            get{ return typeof(System.Array);}
        }
        
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
        
        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
        
        protected override MethodInfo GetMethodImpl(String name,BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override FieldInfo GetField(String name, BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
        
        public override FieldInfo[] GetFields(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override Type GetInterface(String name,bool ignoreCase)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override Type[] GetInterfaces()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override EventInfo GetEvent(String name,BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override EventInfo[] GetEvents()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        protected override PropertyInfo GetPropertyImpl(String name, BindingFlags bindingAttr, Binder binder, 
                Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
    
        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

        public override Type[] GetNestedTypes(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
   
        public override Type GetNestedType(String name, BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

        public override MemberInfo[] GetMember(String name,  MemberTypes type, BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }
        
        public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

        public override InterfaceMapping GetInterfaceMap(Type interfaceType)
		{
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
		}

        public override EventInfo[] GetEvents(BindingFlags bindingAttr)
		{
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
		}
    
        protected override TypeAttributes GetAttributeFlagsImpl()
        {
            // Return the attribute flags of the base type?
            Type baseType;
            for (baseType = m_baseType; baseType is SymbolType; baseType = ((SymbolType)baseType).m_baseType);
            return baseType.Attributes;
        }
        
        protected override bool IsArrayImpl()
        {
            if (m_typeKind == TypeKind.IsArray)
                return true;
            return false;              
        }
        protected override bool IsPointerImpl()
        {
            if (m_typeKind == TypeKind.IsPointer)
                return true;
            return false;
        }

        protected override bool IsByRefImpl()
        {
            return (m_typeKind == TypeKind.IsByRef);
        }

        protected override bool IsPrimitiveImpl()
        {
            return false;
        }
        
        protected override bool IsValueTypeImpl() 
        {
            return false;
        }
        
        protected override bool IsCOMObjectImpl()
        {
            return false;
        }
            
        
        public override Type GetElementType()
        {
            return m_baseType;
        }

        protected override bool HasElementTypeImpl()
        {
            return (m_baseType != null);
        }

    
        public override Type UnderlyingSystemType {
            get {
                return this;
            }
        }
            
        //ICustomAttributeProvider
        public override Object[] GetCustomAttributes(bool inherit)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

       // Returns true if one or more instance of attributeType is defined on this member. 
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonReflectedType"));      
        }

    }

    //**********************************************
    // Internal class to hold signature blob
    //**********************************************
    internal class SignatureBuffer
    {
        internal const uint       SIGN_MASK_ONEBYTE  = 0xffffffc0;        // Mask the same size as the missing bits.  
        internal const uint       SIGN_MASK_TWOBYTE  = 0xffffe000;        // Mask the same size as the missing bits.  
        internal const uint       SIGN_MASK_FOURBYTE = 0xf0000000;        // Mask the same size as the missing bits.  

        internal SignatureBuffer()
        {
            m_buf = new byte[10];
            m_curPos = 0;
        }
        
        private void EnsureCapacity(int iSize)
        {
            if (m_buf.Length < (m_curPos + iSize))
            {
                byte[] temp = new byte[m_buf.Length * 2];
                Array.Copy(m_buf, temp, m_curPos);
                m_buf = temp;            
            }
        }
        
        //***********************************************
        // A managed representation of CorSigCompressToken; 
        // replicated here so that we don't have to call through to native
        // The signature is expanded automatically if there's not enough room.
        //***********************************************
        internal void AddInteger(int iData) 
        {
            uint       isSigned = 0;   
        
            if (iData < 0)  
                isSigned = 0x1; 
                   
            if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
            {   
                iData &= (int) ~SIGN_MASK_ONEBYTE;    
            }   
            else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
            {   
                iData &= (int) ~SIGN_MASK_TWOBYTE;    
            }           
            else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
            {   
                iData &= (int) ~SIGN_MASK_FOURBYTE;   
            }   
            else    
            {   
                // out of compressable range    
                throw new ArgumentException(Environment.GetResourceString("Argument_LargeInteger"));
            }   
            iData = (int) (iData << 1 | (int)isSigned);  
            AddData(iData); 
                
        }
        
        //***********************************************
        // A managed representation of CorSigCompressToken; 
        // replicated here so that we don't have to call through to native
        // The signature is expanded automatically if there's not enough room.
        //***********************************************
        internal void AddToken(int token) 
        {
            int rid =  (token & 0x00FFFFFF);        //This is RidFromToken;
            int type = (token & unchecked((int)0xFF000000));   //This is TypeFromToken;
    
            if (rid > 0x3FFFFFF) {
                // token is too big to be compressed    
                throw new ArgumentException(Environment.GetResourceString("Argument_LargeInteger"));
            }
    
            rid = (rid << 2);   
            
            // TypeDef is encoded with low bits 00  
            // TypeRef is encoded with low bits 01  
            // TypeSpec is encoded with low bits 10    
            if (type == SignatureHelper.mdtTypeRef) { //if type is mdtTypeRef
                rid|=0x1;
            } else if (type == SignatureHelper.mdtTypeSpec) { //if type is mdtTypeSpec
                rid|=0x2;
            }
            AddData(rid);
        }
        
         //***********************************************
         // A managed representation of CorSigCompressData; 
         // replicated here so that we don't have to call through to native
         // The signature is expanded automatically if there's not enough room.
         //***********************************************
        internal void AddData(int data) 
        {
            EnsureCapacity(4);
    
            if (data<=0x7F) {
                PutByte( (byte)(data&0xFF) );
            } else if (data<=0x3FFF) {
                PutByte( (byte)((data>>8) | 0x80) );
                PutByte( (byte)(data&0xFF) );
            } else if (data<=0x1FFFFFFF) {
                PutByte( (byte)((data>>24) | 0xC0) );
                PutByte( (byte)((data>>16) & 0xFF) );
                PutByte( (byte)((data>>8)  & 0xFF) );
                PutByte( (byte)((data)     & 0xFF) );
            } else {
                // something is wrong here... If integer is too big to be encoded,
                // we should throw exception
                throw new ArgumentException(Environment.GetResourceString("Argument_LargeInteger"));
            }            
            
        }
    
         //***********************************************
         // Adds an element to the signature.  A managed represenation of CorSigCompressElement
         //***********************************************
        internal void AddElementType(int cvt) 
        {
            EnsureCapacity(1);
            PutByte( (byte)cvt );
        }
        
        

        internal void PutByte(byte b)
        {
            m_buf[m_curPos++] = b;
        }
        internal int        m_curPos;
        internal byte[]     m_buf;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\iresourcereader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  IResourceReader
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Abstraction to read streams of resources.
**
** Date:  March 30, 1999
** 
===========================================================*/
namespace System.Resources {    
    using System;
    using System.IO;
    using System.Collections;
    
    /// <include file='doc\IResourceReader.uex' path='docs/doc[@for="IResourceReader"]/*' />
    public interface IResourceReader : IEnumerable, IDisposable
    {
	// Interface does not need to be marked with the serializable attribute
    	// Closes the ResourceReader, releasing any resources associated with it.
    	// This could close a network connection, a file, or do nothing.
    	/// <include file='doc\IResourceReader.uex' path='docs/doc[@for="IResourceReader.Close"]/*' />
    	void Close();


        /// <include file='doc\IResourceReader.uex' path='docs/doc[@for="IResourceReader.GetEnumerator"]/*' />
        new IDictionaryEnumerator GetEnumerator();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\iresourcewriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  IResourceWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Default way to write strings to a COM+ resource 
** file.
**
** Date:  March 26, 1999
** 
===========================================================*/
namespace System.Resources {
	using System;
	using System.IO;
    /// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter"]/*' />
    public interface IResourceWriter : IDisposable
    {
	// Interface does not need to be marked with the serializable attribute
    	// Adds a string resource to the list of resources to be written to a file.
    	// They aren't written until WriteFile() is called.
    	// 
    	/// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter.AddResource"]/*' />
    	void AddResource(String name, String value);
    
    	// Adds a resource to the list of resources to be written to a file.
    	// They aren't written until WriteFile() is called.
    	// 
    	/// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter.AddResource1"]/*' />
    	void AddResource(String name, Object value);
    
    	// Adds a named byte array as a resource to the list of resources to 
    	// be written to a file. They aren't written until WriteFile() is called.
    	// 
    	/// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter.AddResource2"]/*' />
    	void AddResource(String name, byte[] value);
    
        // Closes the underlying resource file.
        /// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter.Close"]/*' />
        void Close();

    	// After calling AddResource, this writes all resources to the output
        // stream.  This does NOT close the output stream.
    	/// <include file='doc\IResourceWriter.uex' path='docs/doc[@for="IResourceWriter.Generate"]/*' />
    	void Generate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\typetoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  TypeToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Class to the ILGenerator class.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
	using System.Threading;
    /// <include file='doc\TypeToken.uex' path='docs/doc[@for="TypeToken"]/*' />
	[Serializable()] 
    public struct TypeToken {
    
		/// <include file='doc\TypeToken.uex' path='docs/doc[@for="TypeToken.Empty"]/*' />
		public static readonly TypeToken Empty = new TypeToken();

        internal int m_class;
    
        //public TypeToken() {
        //    m_class=0;
        //}
        
        internal TypeToken(int str) {
            m_class=str;
        }
    
        /// <include file='doc\TypeToken.uex' path='docs/doc[@for="TypeToken.Token"]/*' />
        public int Token {
            get { return m_class; }
        }
        
        // Satisfy JVC's value class requirements
    	/// <include file='doc\TypeToken.uex' path='docs/doc[@for="TypeToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_class;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\TypeToken.uex' path='docs/doc[@for="TypeToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is TypeToken))
    			return ((TypeToken)obj).m_class == m_class;
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\neutralresourceslanguageattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  NeutralResourcesLanguageAttribute
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Tells the ResourceManager what language your main
**          assembly's resources are written in.  The 
**          ResourceManager won't try loading a satellite
**          assembly for that culture, which helps perf.
**
** Date:  March 14, 2001
**
===========================================================*/

using System;

namespace System.Resources {
    
    /// <include file='doc\NeutralResourcesLanguageAttribute.uex' path='docs/doc[@for="NeutralResourcesLanguageAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class NeutralResourcesLanguageAttribute : Attribute 
    {
        private String _culture;

        /// <include file='doc\NeutralResourcesLanguageAttribute.uex' path='docs/doc[@for="NeutralResourcesLanguageAttribute.NeutralResourcesLanguageAttribute"]/*' />
        public NeutralResourcesLanguageAttribute(String cultureName)
        {
            if (cultureName == null)
                throw new ArgumentNullException("cultureName");
            _culture = cultureName;
        }

        /// <include file='doc\NeutralResourcesLanguageAttribute.uex' path='docs/doc[@for="NeutralResourcesLanguageAttribute.CultureName"]/*' />
        public String CultureName {
            get { return _culture; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\missingmanifestresourceexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  MissingManifestResourceException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception for a missing assembly-level resource 
**
** Date:  March 24, 2000
**
===========================================================*/

using System;
using System.Runtime.Serialization;

namespace System.Resources {
    /// <include file='doc\MissingManifestResourceException.uex' path='docs/doc[@for="MissingManifestResourceException"]/*' />
    [Serializable()]
    public class MissingManifestResourceException : SystemException
    {
        /// <include file='doc\MissingManifestResourceException.uex' path='docs/doc[@for="MissingManifestResourceException.MissingManifestResourceException"]/*' />
        public MissingManifestResourceException() 
            : base(Environment.GetResourceString("Arg_MissingManifestResourceException")) {
    		SetErrorCode(__HResults.COR_E_MISSINGMANIFESTRESOURCE);
        }
        
        /// <include file='doc\MissingManifestResourceException.uex' path='docs/doc[@for="MissingManifestResourceException.MissingManifestResourceException1"]/*' />
        public MissingManifestResourceException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MISSINGMANIFESTRESOURCE);
        }
    	
        /// <include file='doc\MissingManifestResourceException.uex' path='docs/doc[@for="MissingManifestResourceException.MissingManifestResourceException2"]/*' />
        public MissingManifestResourceException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MISSINGMANIFESTRESOURCE);
        }

        /// <include file='doc\MissingManifestResourceException.uex' path='docs/doc[@for="MissingManifestResourceException.MissingManifestResourceException3"]/*' />
        protected MissingManifestResourceException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\typebuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  TypeBuilder
**
** Author: Daryl Olander (darylo)
**
** TypeBuilder is the center point of the reflection ability
**  to create new classes by emitting IL.
**
** Date:  November 98
**
===========================================================*/
namespace System.Reflection.Emit {

    // @TODO: How do we expect these to be used.  Right now I look at them
    //  as a single shot.  Once you define a class this class is pretty much
    //  useless.  Is this right?  (The methods may be reused.)
    // @TODO: Namespace?
    // @TODO: IF we support a namespace, what are the access requirements on
    //  namespace.  Obviously we should be allowed to create dynamically classes
    //  in some namespace simply to access scoped objects inside that namespace.
    // @TODO: Security???

    using System;
    using System.Runtime.Remoting.Activation;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using ArrayList = System.Collections.ArrayList;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Threading;

    // enumerator for specifying type's pack size
    /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize"]/*' />
    [Flags, Serializable]
    public enum PackingSize
    {
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Unspecified"]/*' />
        Unspecified                 = 0,

        // New names
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Size1"]/*' />
        Size1                       = 1,
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Size2"]/*' />
        Size2                       = 2,
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Size4"]/*' />
        Size4                       = 4,
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Size8"]/*' />
        Size8                       = 8,
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="PackingSize.Size16"]/*' />
        Size16                      = 16,
    }

    // The TypeBuilder is the root class used to control the creation of
    // dynamic classes in the runtime.  TypeBuilder defines a set of routines that are
    // used to create classes, added method and fields to that class, and then create the
    // class inside the runtime.
    //
    /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder"]/*' />
    sealed public class TypeBuilder : Type
    {
        // This value indicating that total size for the type is not specified
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.UnspecifiedTypeSize"]/*' />
        public const int UnspecifiedTypeSize     = 0;


        // Return the total size of a type
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.Size"]/*' />
        public int Size {
            get { return m_iTypeSize; }
        }

        // Return the packing size of a type
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.PackingSize"]/*' />
        public PackingSize PackingSize {
            get { return m_iPackingSize; }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.SetParent"]/*' />
        public void SetParent(Type parent)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }
            ThrowIfCreated();
            
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.SetParent( " + parent.FullName + " )");

            TypeToken tkParent = m_module.GetTypeToken(parent);
            InternalSetParentType(m_tdType.Token, tkParent.Token, m_module);
            m_typeParent = parent;
        }


        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.AddInterfaceImplementation"]/*' />
        public void AddInterfaceImplementation(Type interfaceType)
        {
            if (interfaceType == null)
            {
                throw new ArgumentNullException("interfaceType");
            }
            ThrowIfCreated();
            
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.AddInterfaceImplementationrent( " + interfaceType.FullName + " )");

            TypeToken tkInterface = m_module.GetTypeToken(interfaceType);
            InternalAddInterfaceImpl(m_tdType.Token, tkInterface.Token, m_module);
        }

        // Adds a new method to the Type.  The new method will have the name as
        // its name, and a signature represented by signature.  The new method
        // is represented by the MethodBuilder object which is returned.
        //
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineMethod"]/*' />
        public MethodBuilder DefineMethod(
            String          name,
            MethodAttributes attributes,
            Type            returnType,
            Type[]          parameterTypes)
        {
            return DefineMethod(name, attributes, CallingConventions.Standard, returnType, parameterTypes);
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineMethod1"]/*' />
        public MethodBuilder DefineMethod(
            String          name,
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineMethod( " + name + " )");


                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");

                ThrowIfCreated();

                if (!m_isHiddenGlobalType)
                {
                    if (((m_iAttr & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface) &&
                        (attributes & MethodAttributes.Abstract)==0)
                        throw new ArgumentException(Environment.GetResourceString("Argument_BadAttributeOnInterfaceMethod"));               
                }

                // pass in Method attributes
                MethodBuilder method = new MethodBuilder(name, attributes, callingConvention, returnType, parameterTypes, m_module, this, false);

                //The signature grabbing code has to be up here or the signature won't be finished
                //and our equals check won't work.
                int sigLength;
                byte[] sigBytes = method.GetMethodSignature().InternalGetSignature(out sigLength);

                if (!m_isHiddenGlobalType)
                {
                    //If this method is declared to be a constructor,
                    //increment our constructor count.
                    if ((method.Attributes & MethodAttributes.SpecialName)!=0 &&
                        method.Name.Equals(ConstructorInfo.ConstructorName)) {
                        m_constructorCount++;
                    }
                }

                m_listMethods.Add(method);

                MethodToken token = InternalDefineMethod(m_tdType,
                                                         name,
                                                         sigBytes,
                                                         sigLength,
                                                         method.Attributes,
                                                         m_module);

                method.SetToken(token);
                return method;
            }
            finally
            {
                Exit();
            }
        }

        // create a property builder. It is very strange.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineProperty"]/*' />
        public PropertyBuilder DefineProperty(
            String          name,
            PropertyAttributes attributes,
            Type            returnType,
            Type[]          parameterTypes)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineProperty( " + name + " )");

                SignatureHelper sigHelper;
                int         sigLength;
                byte[]      sigBytes;

                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
                ThrowIfCreated();

                // get the signature in SignatureHelper form
                sigHelper = SignatureHelper.GetPropertySigHelper(
                    m_module,
                    returnType,
                    parameterTypes);

                // get the signature in byte form
                sigBytes = sigHelper.InternalGetSignature(out sigLength);

                PropertyToken prToken = InternalDefineProperty(
                    m_module,
                    m_tdType.Token,
                    name,
                    (int) attributes,
                    sigBytes,
                    sigLength,
                    0,
                    0);

                // create the property builder now.
                return new PropertyBuilder(
                        m_module,
                        name,
                        sigHelper,
                        attributes,
                        returnType,
                        prToken,
                        this);
            }
            finally
            {
                Exit();
            }
        }


        // create an event builder.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineEvent"]/*' />
        public EventBuilder DefineEvent(
            String          name,
            EventAttributes attributes,
            Type            eventtype)
        {
            try
            {
                Enter();

                int             tkType;
                EventToken      evToken;

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineEvent( " + name + " )");

                ThrowIfCreated();
  
                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
                if (name[0] == '\0')
                    throw new ArgumentException(Environment.GetResourceString("Argument_IllegalName"), "name");

                tkType = m_module.GetTypeToken( eventtype ).Token;

                // Internal helpers to define property records
                evToken = InternalDefineEvent(
                    m_module,
                    m_tdType.Token,
                    name,
                    (int) attributes,
                    tkType);

                // create the property builder now.
                return new EventBuilder(
                        m_module,
                        name,
                        attributes,
                        tkType,
                        this,
                        evToken);
            }
            finally
            {
                Exit();
            }
        }

        // Define PInvokeMethod
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefinePInvokeMethod"]/*' />
        public MethodBuilder DefinePInvokeMethod(
            String          name,                   // name of the function of the dll entry
            String          dllName,                // dll containing the PInvoke method
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes,
            CallingConvention   nativeCallConv,     // The native calling convention.
            CharSet             nativeCharSet)      // Method's native character set.
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefinePInvokeMethodEx( " + name + ", " + dllName + " )");

            MethodBuilder method = DefinePInvokeMethodHelper(name, dllName, name, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
            return method;
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefinePInvokeMethod1"]/*' />
        public MethodBuilder DefinePInvokeMethod(
            String          name,                   // name of the function of the dll entry
            String          dllName,                // dll containing the PInvoke method
            String          entryName,              // the entry point's name
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes,
            CallingConvention   nativeCallConv,     // The native calling convention.
            CharSet             nativeCharSet)      // Method's native character set.
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefinePInvokeMethodEx( " + name + ", " + dllName + " )");

            MethodBuilder method = DefinePInvokeMethodHelper(name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
            return method;
        }

        private MethodBuilder DefinePInvokeMethodHelper(
            String          name,                   // name of the function of the dll entry
            String          dllName,                // dll containing the PInvoke method
            String          importName,             // the import entry's name
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type            returnType,
            Type[]          parameterTypes,
            CallingConvention   nativeCallConv,     // The native calling convention.
            CharSet             nativeCharSet)      // Method's native character set.
        {
            try
            {
                Enter();

                ThrowIfCreated();

                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
                if (dllName == null)
                    throw new ArgumentNullException("dllName");
                if (dllName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "dllName");
                if (importName == null)
                    throw new ArgumentNullException("importName");
                if (importName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "importName");

                if ((m_iAttr & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface)
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadPInvokeOnInterface"));

                if ((attributes & MethodAttributes.Abstract) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadPInvokeMethod"));

                //HACK HACK HACK
                //This is a phenomenally inefficient method of checking for duplictates, but since we currently
                //store MethodBuilders, we need to be able to compare them if we want to check for dupes.
                //Fix this.
                attributes = attributes | MethodAttributes.PinvokeImpl;
                MethodBuilder method = new MethodBuilder(name, attributes, callingConvention, returnType, parameterTypes, m_module, this, false);

                //The signature grabbing code has to be up here or the signature won't be finished
                //and our equals check won't work.
                int sigLength;
                byte[] sigBytes = method.GetMethodSignature().InternalGetSignature(out sigLength);

                if (m_listMethods.Contains(method)) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_MethodRedefined"));
                }
                m_listMethods.Add(method);

                MethodToken token = InternalDefineMethod(m_tdType,
                                                         name,
                                                         sigBytes,
                                                         sigLength,
                                                         attributes,
                                                         m_module);
                
                int linkFlags = 0;
                switch (nativeCallConv)
                {
                case CallingConvention.Winapi:
                    linkFlags = (int)PInvokeMap.CallConvWinapi;
                    break;
                case CallingConvention.Cdecl:
                    linkFlags = (int)PInvokeMap.CallConvCdecl;
                    break;
                case CallingConvention.StdCall:
                    linkFlags = (int)PInvokeMap.CallConvStdcall;
                    break;
                case CallingConvention.ThisCall:
                    linkFlags = (int)PInvokeMap.CallConvThiscall;
                    break;
                case CallingConvention.FastCall:
                    linkFlags = (int)PInvokeMap.CallConvFastcall;
                    break;
                }
                switch (nativeCharSet)
                {
                case CharSet.None:
                    linkFlags |= (int)PInvokeMap.CharSetNotSpec;
                    break;
                case CharSet.Ansi:
                    linkFlags |= (int)PInvokeMap.CharSetAnsi;
                    break;
                case CharSet.Unicode:
                    linkFlags |= (int)PInvokeMap.CharSetUnicode;
                    break;
                case CharSet.Auto:
                    linkFlags |= (int)PInvokeMap.CharSetAuto;
                    break;
                }
                
                InternalSetPInvokeData(m_module,
                                       dllName,
                                       importName,
                                       token.Token,
                                       0,
                                       linkFlags);
                method.SetToken(token);

                return method;
            }
            finally
            {
                Exit();
            }
        }


        // Define the default construct which simply calls the parent default
        // constructor.  This will happen automatically if the user doesn't call
        // this, but this method is left exposed to make it easier to change the
        // privileges associated with the default constructor.
        //

        // Define the type initializer
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineTypeInitializer"]/*' />
        public ConstructorBuilder DefineTypeInitializer()
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineTypeInitializer( )");

            try
            {
                Enter();

                ThrowIfCreated();

                MethodAttributes        attr;

                // change the attributes and the class constructor's name
                attr = MethodAttributes.Private |
                       MethodAttributes.Static |
                       MethodAttributes.SpecialName;
                ConstructorBuilder constBuilder = new ConstructorBuilder(ConstructorInfo.TypeConstructorName,
                                                                         attr,
                                                                         CallingConventions.Standard,
                                                                         null,
                                                                         m_module,
                                                                         this);
                return constBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // Defines the class instance constructor
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineConstructor"]/*' />
        public ConstructorBuilder DefineConstructor(
            MethodAttributes attributes,
            CallingConventions callingConvention,
            Type[]          parameterTypes)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineConstructor( )");

                ThrowIfCreated();

                // change the attributes and the class constructor's name
                String name;
                if ((attributes & MethodAttributes.Static) == 0)
                    name = ConstructorInfo.ConstructorName;
                else
                    name = ConstructorInfo.TypeConstructorName;
                attributes = attributes | MethodAttributes.SpecialName;
                ConstructorBuilder constBuilder = new ConstructorBuilder(name,
                                                                         attributes,
                                                                         callingConvention,
                                                                         parameterTypes,
                                                                         m_module,
                                                                         this);
                m_constructorCount++;
                return constBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // Defines the class instance constructor and also set the body of the default
        // constructor to call the parent constructor.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineDefaultConstructor"]/*' />
        public ConstructorBuilder DefineDefaultConstructor(
            MethodAttributes attributes)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineDefaultConstructorEx( )");


                ConstructorBuilder  constBuilder;

                // get the parent class's default constructor
                // We really don't want (BindingFlags.Instance|BindingFlags.Public|BindingFlags.NonPublic) here.  We really want
                // constructors visible from the subclass, but that is not currently
                // available in BindingFlags.  This more open binding is open to
                // runtime binding failures (like if we resolve to a private
                // constructor).
                ConstructorInfo con = m_typeParent.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,null,Type.EmptyTypes,null);
                if (con == null) {
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_NoParentDefaultConstructor"));
                }

                // Define the constructor Builder
                constBuilder = DefineConstructor(attributes, CallingConventions.Standard, null);
                m_constructorCount++;

                // generate the code to call the parent's default constructor
                ILGenerator il = constBuilder.GetILGenerator();
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Call,con);
                il.Emit(OpCodes.Ret);
                constBuilder.m_ReturnILGen = false;
                return constBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // Causes the class to be created within the runtime.  Classes are built up
        // by adding fields and methods to them.  When this process is finished,
        // CreateClass is called which caused this instance to be generated as
        // a true class loaded in the runtime. One the instance has been created calling
        // this routine will result in an error.
        //
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.CreateType"]/*' />
        public Type CreateType()
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.CreateType() ");

                byte [] body;
                MethodAttributes methodAttrs;
                int maxstack;

                ThrowIfCreated();
                
                if (m_DeclaringType != null)
                {
                    if (m_DeclaringType.m_hasBeenCreated != true)
                    {                        
                        // Enclosing type has to be created before the nested type can be created.
                        throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_NestingTypeIsNotCreated"),
                            m_DeclaringType.Name));
                    }
                }
                                
                if (!m_isHiddenGlobalType)
                {
                    // create a public default constructor if this class has no constructor.
                    // except if the type is Interace, ValueType or Enum.
                    if (m_constructorCount==0 &&
                        ((m_iAttr & TypeAttributes.Interface) == 0) &&
                        !IsValueType)
                    {
                        this.DefineDefaultConstructor(MethodAttributes.Public);
                    }
                }

                int size = m_listMethods.Count;
                for (int i=0;i<size;i++)
                {
                    MethodBuilder meth = (MethodBuilder) m_listMethods[i];
                    methodAttrs = meth.Attributes;

                    // Any of these flags in the implemenation flags is set, we will not attach the IL method body
                    if (((meth.GetMethodImplementationFlags() & (MethodImplAttributes.CodeTypeMask|MethodImplAttributes.PreserveSig|MethodImplAttributes.Unmanaged)) != MethodImplAttributes.IL) ||
                         ((methodAttrs & MethodAttributes.PinvokeImpl) != (MethodAttributes) 0))
                    {
                        continue;
                    }

                    int sigLength;
                    byte[] LocalSig= meth.GetLocalsSignature().InternalGetSignature(out sigLength);

                    // @todo: meichint
                    // should not this check live on DefineMethod?
                    //Check that they haven't declared an abstract method on a non-abstract class
                    if (((methodAttrs & MethodAttributes.Abstract)!=0) &&
                        ((m_iAttr & TypeAttributes.Abstract)==0))
                    {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadTypeAttributesNotAbstract"));
                    }

                    body = meth.GetBody();

                    //If this is an abstract method or an interface, we don't need to set the IL.

                    if ((methodAttrs & MethodAttributes.Abstract)!=0)
                    {
                        // We won't check on Interface because we can have class static initializer on interface.
                        // We will just let EE or validator to catch the problem.

                        // ((m_iAttr & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface))

                        if (body!=null)
                        {
                            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadMethodBody"));
                        }
                    }
                    else if (body==null)
                    {
                        //If it's not an abstract or an interface, set the IL.
                        if (meth.m_ilGenerator != null)
                        {
                            // we need to bake the method here.
                            meth.CreateMethodBodyHelper(meth.GetILGenerator());
                        }
                        body = meth.GetBody();
                        if (body == null)
                        {
                            throw new InvalidOperationException(String.Format(Environment.GetResourceString(
                                "InvalidOperation_BadEmptyMethodBody"),
                                meth.Name) ); 
                        
                        }
                    }

                    if (meth.m_ilGenerator != null)
                        maxstack = meth.m_ilGenerator.GetMaxStackSize();
                    else
                    {
                        // this is the case when client provide an array of IL byte stream rather than
                        // going through ILGenerator.
                        maxstack = 16;
                    }
                    InternalSetMethodIL(meth.GetToken(),
                                        meth.InitLocals,
                                        body,
                                        LocalSig,
                                        sigLength,
                                        maxstack,
                                        meth.GetNumberOfExceptions(),
                                        meth.GetExceptionInstances(),
                                        meth.GetTokenFixups(),
                                        meth.GetRVAFixups(),
                                        m_module);

                }

                m_hasBeenCreated = true;

                // Terminate the process.
                Type cls = TermCreateClass(m_tdType,m_module);

                if (!m_isHiddenGlobalType)
                {
                    m_runtimeType = (RuntimeType) cls;
                  
                    // if this type is a nested type, we need to invalidate the cached nested runtime type on the nesting type
                    if (m_DeclaringType != null && (RuntimeType)m_DeclaringType.m_runtimeType != null)
                    {
                        ((RuntimeType)m_DeclaringType.m_runtimeType).InvalidateCachedNestedType();
                    }
                    return cls;
                }
                else
                {
                    return null;
                }
            }
            finally
            {
                Exit();
                m_listMethods = null;
            }
        }


        /*******************
         * Specify that methodInfoBody is implementing methodInfoDeclaration
         *******************/
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineMethodOverride"]/*' />
        public void DefineMethodOverride(
            MethodInfo      methodInfoBody,
            MethodInfo      methodInfoDeclaration)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineMethodOverride( " + methodInfoBody + "' " + methodInfoDeclaration + " )");

                ThrowIfCreated();
                               
                if (methodInfoBody == null)
                {
                    throw new ArgumentNullException("methodInfoBody");
                }
                if (methodInfoDeclaration == null)
                {
                    throw new ArgumentNullException("methodInfoDeclaration");
                }
                                         
                if (methodInfoBody.DeclaringType != this)
                {
                    // Loader restriction: body method has to be from this class
                    throw new ArgumentException(Environment.GetResourceString("ArgumentException_BadMethodImplBody"));
                }
                
                MethodToken     tkBody;
                MethodToken     tkDecl;
                tkBody = m_module.GetMethodToken(methodInfoBody);
                tkDecl = m_module.GetMethodToken(methodInfoDeclaration);
                InternalDefineMethodImpl(m_module, m_tdType.Token, tkBody.Token, tkDecl.Token);
            }
            finally
            {
                Exit();
            }
        }

        /*******************
         * Define a field member for this type.
         *******************/
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineField"]/*' />
        public FieldBuilder DefineField(
            String          fieldName,          // field name
            Type            type,               // field type
            FieldAttributes attributes)         // attributes
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineField( " + fieldName + " )");

                ThrowIfCreated();

                if (m_underlyingSystemType == null && IsEnum == true)
                {
                    if ((attributes & FieldAttributes.Static) == 0)
                    {
                        // remember the underlying type for enum type
                        m_underlyingSystemType = type;
                    }                   
                }
                return new FieldBuilder(this, fieldName, type, attributes);
            }
            finally
            {
                Exit();
            }
        }


        //****************************
        // This method will define an initialized Data in .sdata.
        // We will create a fake TypeDef to represent the data with size. This TypeDef
        // will be the signature for the Field.
        //****************************
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineInitializedData"]/*' />
        public FieldBuilder DefineInitializedData(
            String          name,
            byte[]          data,
            FieldAttributes attributes)
        {
            try
            {
                Enter();

                if (data == null)
                {
                    throw new ArgumentNullException("data");
                }
                return DefineDataHelper(name, data, data.Length, attributes);
            }
            finally
            {
                Exit();
            }
        }

        //****************************
        // This method will define an uninitialized Data in .sdata.
        // We will create a fake TypeDef to represent the data with size. This TypeDef
        // will be the signature for the Field.
        //****************************
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineUninitializedData"]/*' />
        public FieldBuilder DefineUninitializedData(
            String          name,
            int             size,
            FieldAttributes attributes)
        {
            try
            {
                Enter();

                return DefineDataHelper(name, null, size, attributes);
            }
            finally
            {
                Exit();
            }
        }

        internal FieldBuilder DefineDataHelper(
            String          name,
            byte[]          data,
            int             size,
            FieldAttributes attributes)
        {
            String          strValueClassName;
            TypeBuilder     valueClassType;
            FieldBuilder    fdBuilder;
            TypeAttributes  typeAttributes;

            if (name == null)
                throw new ArgumentNullException("name");
            if (name.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");

            if (size <= 0 || size >= 0x003f0000)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadSizeForData"));

            ThrowIfCreated();

            // form the value class name
            strValueClassName = ModuleBuilderData.MULTI_BYTE_VALUE_CLASS + size;

            // Is this already defined in this module?
            StackCrawlMark stackMark = StackCrawlMark.LookForMe;
            Type temp = m_module.FindTypeBuilderWithName(strValueClassName, false, ref stackMark);
            valueClassType = temp as TypeBuilder;

            if (valueClassType == null)
            {
                typeAttributes = TypeAttributes.Public | TypeAttributes.ExplicitLayout | TypeAttributes.Class |
                                 TypeAttributes.Sealed | TypeAttributes.AnsiClass;

                // Define the backing value class
                valueClassType = m_module.DefineType(strValueClassName, typeAttributes, typeof(System.ValueType), PackingSize.Size1, size);
                valueClassType.m_isHiddenType = true;
                valueClassType.CreateType();
            }

            fdBuilder = DefineField(name, valueClassType, (attributes | FieldAttributes.Static));

            // now we need to set the RVA
            fdBuilder.SetData(data, size);
            return fdBuilder;
        }


        /*******************
         * Define nested type
         *******************/
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType"]/*' />
        public TypeBuilder DefineNestedType(
            String      name)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.NestedType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, TypeAttributes.NestedPrivate, null, null, m_module, PackingSize.Unspecified, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType1"]/*' />
        public TypeBuilder DefineNestedType(
            String      name,
            TypeAttributes attr,
            Type        parent,
            Type []     interfaces)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedType( " + name + " )");

                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, parent, interfaces, m_module, PackingSize.Unspecified, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType2"]/*' />
        public TypeBuilder DefineNestedType(
            String      name,
            TypeAttributes attr,
            Type        parent)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedType( " + name + " )");

                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, parent, null, m_module, PackingSize.Unspecified, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType3"]/*' />
        public TypeBuilder DefineNestedType(
            String      name,
            TypeAttributes attr)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedType( " + name + " )");

                TypeBuilder typeBuilder;
                typeBuilder =  new TypeBuilder(name, attr, null, null, m_module, PackingSize.Unspecified, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // specifying type size as a whole
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType4"]/*' />
        public TypeBuilder DefineNestedType(
            String      name,
            TypeAttributes attr,
            Type        parent,
            int         typeSize)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder = new TypeBuilder(name, attr, parent, m_module, PackingSize.Unspecified, typeSize, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // specifying packing size
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DefineNestedType5"]/*' />
        public TypeBuilder DefineNestedType(
            String      name,
            TypeAttributes attr,
            Type        parent,
            PackingSize packSize)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedType( " + name + " )");
                TypeBuilder typeBuilder;
                typeBuilder = new TypeBuilder(name, attr, parent, null, m_module, packSize, this);
                m_module.m_TypeBuilderList.Add(typeBuilder);
                return typeBuilder;
            }
            finally
            {
                Exit();
            }
        }

        // Return the class that declared this Field.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.DeclaringType"]/*' />
        public override Type DeclaringType {
                get {return m_DeclaringType;}
        }

        // Return the class that was used to obtain this field.
        // @todo: fix this to return enclosing type if nested
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.ReflectedType"]/*' />
        public override Type ReflectedType {
                get {return m_DeclaringType;}
        }


        /******
        // Define Enum
        public EnumBuilder DefineNestedEnum(
            String      name,                       // name of type
            TypeAttributes visibility,              // any bits on TypeAttributes.VisibilityMask)
            Type        underlyingType)             // underlying type for an Enum
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.DefineNestedEnum( " + name + " )");
                EnumBuilder enumBuilder;
                enumBuilder = new EnumBuilder(name, underlyingType, visibility, this);
                m_module.m_TypeBuilderList.Add(enumBuilder);
                return enumBuilder;
            }
            finally
            {
                Exit();
            }
        }
        ***************/

        // Add declarative security to the class.
        //
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.AddDeclarativeSecurity"]/*' />
        public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: TypeBuilder.AddDeclarativeSecurity( )");

                if ((action < SecurityAction.Demand) || (action > SecurityAction.InheritanceDemand))
                    throw new ArgumentOutOfRangeException("action");

                if (pset == null)
                    throw new ArgumentNullException("pset");

                ThrowIfCreated();

                // Translate permission set into serialized format (uses standard binary serialization format).
                byte[] blob = null;
                if (!pset.IsEmpty())
                    blob = pset.EncodeXml();

                // Write the blob into the metadata.
                InternalAddDeclarativeSecurity(m_module, m_tdType.Token, action, blob);
            }
            finally
            {
                Exit();
            }
        }

        // Get the internal metadata token for this class.
        // Cannot remove this deprecated method until we can enable the get property of TypeToken
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.TypeToken"]/*' />
        public TypeToken TypeToken {
            get {return  m_tdType; }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.Name"]/*' />
        public override String Name {
            get { return m_strName; }
        }

        /****************************************************
         *
         * abstract methods defined in the base class
         *
         */
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GUID"]/*' />
        public override Guid GUID {
            get {
                if (m_runtimeType != null)
                {
                    return m_runtimeType.GUID;
                }
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
                //we'll never get here, but it makes the compiler smile.
                //return Guid.Empty;
            }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.InvokeMember"]/*' />
        public override Object InvokeMember(
            String      name,
            BindingFlags invokeAttr,
            Binder     binder,
            Object      target,
            Object[]   args,
            ParameterModifier[]       modifiers,
            CultureInfo culture,
            String[]    namedParameters)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.Module"]/*' />
        public override Module Module {
            get {return m_module;}
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.Assembly"]/*' />
        public override Assembly Assembly {
            get {return m_module.Assembly;}
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.TypeHandle"]/*' />
        public override RuntimeTypeHandle TypeHandle {
            // @todo: what is this?? How do we support this for dynamic module?
            get {throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule")); }
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.FullName"]/*' />
        public override String FullName {
            get { return m_strFullQualName;}
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.Namespace"]/*' />
        public override String Namespace {
            get { return m_strNameSpace;}
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.AssemblyQualifiedName"]/*' />
        public override String AssemblyQualifiedName {
            get {
                if(m_module != null) {
                    Assembly container = m_module.Assembly;
                    if(container != null) {
                        return Assembly.CreateQualifiedName(container.FullName, m_strFullQualName);
                    }
                }
                return null;
            }
        }

        // Return the name of the class.  The name does not contain the namespace.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.ToString"]/*' />
        public override String ToString(){
            return FullName;
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.BaseType"]/*' />
        public override Type BaseType {
            get{return m_typeParent;}
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetConstructorImpl"]/*' />
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetConstructor(bindingAttr, binder, callConvention,
                            types, modifiers);
            }
            // @todo: implement this when we have a constructor builder inherits from constructor
            // info.
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetConstructors"]/*' />
        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetConstructors(bindingAttr);
            }
            // @todo: implement this when we have a constructor builder inherits from constructor
            // info.
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetMethodImpl"]/*' />
        protected override MethodInfo GetMethodImpl(String name,BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            if (m_runtimeType != null)
            {
                if (types == null)
                    return m_runtimeType.GetMethod(name, bindingAttr);
                else
                    return m_runtimeType.GetMethod(name, bindingAttr, binder, callConvention, types, modifiers);
            }
            // @todo: support this when MethodBuilder inherit from MethodInfo
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetMethods"]/*' />
        public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetMethods(bindingAttr);
            }
            // @todo: support this when MethodBuilder inherit from MethodInfo
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetField"]/*' />
        public override FieldInfo GetField(String name, BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetField(name, bindingAttr);
            }
            // @todo: support this when FieldBuilder inherit from FieldInfo
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetFields"]/*' />
        public override FieldInfo[] GetFields(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetFields(bindingAttr);
            }
            // @todo: support this when FieldBuilder inherit from FieldInfo
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetInterface"]/*' />
        public override Type GetInterface(String name,bool ignoreCase)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetInterface(name, ignoreCase);
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetInterfaces"]/*' />
        public override Type[] GetInterfaces()
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetInterfaces();
            }

            if (m_typeInterfaces == null)
            {
                return new Type[0];
            }
            Type[]      interfaces = new Type[m_typeInterfaces.Length];
            Array.Copy(m_typeInterfaces, interfaces, m_typeInterfaces.Length);
            return interfaces;
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetEvent"]/*' />
        public override EventInfo GetEvent(String name,BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetEvent(name, bindingAttr);
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetEvents"]/*' />
        public override EventInfo[] GetEvents()
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetEvents();
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetPropertyImpl"]/*' />
        protected override PropertyInfo GetPropertyImpl(String name, BindingFlags bindingAttr, Binder binder,
                Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetProperties"]/*' />
        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetProperties(bindingAttr);
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetNestedTypes"]/*' />
        public override Type[] GetNestedTypes(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetNestedTypes(bindingAttr);
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetNestedType"]/*' />
        public override Type GetNestedType(String name, BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetNestedType(name,bindingAttr);
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetMember"]/*' />
        public override MemberInfo[] GetMember(String name, MemberTypes type, BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetMember(name, type, bindingAttr);
            }

            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetInterfaceMap"]/*' />
        public override InterfaceMapping GetInterfaceMap(Type interfaceType)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetInterfaceMap(interfaceType);
            }

            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetEvents1"]/*' />
        public override EventInfo[] GetEvents(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetEvents(bindingAttr);
            }

            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetMembers"]/*' />
        public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
        {
            if (m_runtimeType != null)
            {
                return m_runtimeType.GetMembers(bindingAttr);
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
        
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsAssignableFrom"]/*' />
        public override bool IsAssignableFrom(Type c)
        {
            if (TypeBuilder.IsTypeEqual(c, this))
                return true;
        
            RuntimeType fromRuntimeType = c as RuntimeType;
            TypeBuilder fromTypeBuilder = c as TypeBuilder;
            
            if (fromTypeBuilder != null && fromTypeBuilder.m_runtimeType != null)
                fromRuntimeType = (RuntimeType) fromTypeBuilder.m_runtimeType;                                      
                
            if (fromRuntimeType != null)
            {
                // fromType is baked. So if this type is not baked, it cannot be assignable to!
                if (m_runtimeType == null)
                    return false;
                    
                // since toType is also baked, delegate to the base
                return ((RuntimeType) m_runtimeType).IsAssignableFrom(fromRuntimeType);
            }
            
            // So if c is not a runtimeType nor TypeBuilder. We don't know how to deal with it. 
            // return false then.
            if (fromTypeBuilder == null)
                return false;
                                 
            // If fromTypeBuilder is a subclass of this class, then c can be cast to this type.
            if (fromTypeBuilder.IsSubclassOf(this))
                return true;
                
            if (this.IsInterface == false)
                return false;
                                                                                  
            // now is This type a base type on one of the interface impl?
            Type[] interfaces = fromTypeBuilder.GetInterfaces();
            for (int i = 0; i < interfaces.Length; i++)
            {
                // unfortunately, IsSubclassOf does not cover the case when they are the same type.
                if (TypeBuilder.IsTypeEqual(interfaces[i], this))
                    return true;
            
                if (interfaces[i].IsSubclassOf(this))
                    return true;
            }
            return false;                                                                               
        }        

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetAttributeFlagsImpl"]/*' />
        protected override TypeAttributes GetAttributeFlagsImpl()
        {
            return m_iAttr;
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsArrayImpl"]/*' />
        protected override bool IsArrayImpl()
        {
            return false;
        }
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsByRefImpl"]/*' />
        protected override bool IsByRefImpl()
        {
            return false;
        }
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsPointerImpl"]/*' />
        protected override bool IsPointerImpl()
        {
            return false;
        }
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsPrimitiveImpl"]/*' />
        protected override bool IsPrimitiveImpl()
        {
            return false;
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsCOMObjectImpl"]/*' />
        protected override bool IsCOMObjectImpl()
        {
            return ((GetAttributeFlagsImpl() & TypeAttributes.Import) != 0) ? true : false ;
        }


        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetElementType"]/*' />
        public override Type GetElementType()
        {
            // @TODO: This is arrays, pointers, byref...
            // You will never have to deal with a TypeBuilder if you are just referring to
            // arrays.
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.HasElementTypeImpl"]/*' />
        protected override bool HasElementTypeImpl()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
        
        internal static bool IsTypeEqual(Type t1, Type t2)
        {
            // Maybe we are lucky that they are equal in the first place
            if (t1 == t2)
                return true;
            TypeBuilder tb1 = null;
            TypeBuilder tb2 = null;  
            Type        runtimeType1 = null;              
            Type        runtimeType2 = null;    
            
            // set up the runtimeType and TypeBuilder type corresponding to t1 and t2
            if (t1 is TypeBuilder)
            {
                tb1 = (TypeBuilder) t1;
                // This will be null if it is not baked.
                runtimeType1 = tb1.m_runtimeType;
            }
            else
                runtimeType1 = t1;
            if (t2 is TypeBuilder)
            {
                tb2 = (TypeBuilder) t2;
                // This will be null if it is not baked.
                runtimeType2 = tb2.m_runtimeType;
            }
            else
                runtimeType2 = t2;
                
            // If the type builder view is eqaul then it is equal                
            if (tb1 != null && tb2 != null && tb1 == tb2)
                return true;
            // if the runtimetype view is eqaul than it is equal                
            if (runtimeType1 != null && runtimeType2 != null && runtimeType1 == runtimeType2)                
                return true;
            return false;                
        }
        
        // over the IsSubClassOf. This will make IsEnum and IsValueType working correctly                                    
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsSubclassOf"]/*' />
        public override bool IsSubclassOf(Type c)
        {
            Type p = this;
            if (TypeBuilder.IsTypeEqual(p, c))
                return false;
            p = p.BaseType;                
            while (p != null) {
                if (TypeBuilder.IsTypeEqual(p, c))
                    return true;
                p = p.BaseType;
            }
            return false;
        }
        

        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.UnderlyingSystemType"]/*' />
        public override Type UnderlyingSystemType {
            get {
                if (m_runtimeType != null)
                {
                    return m_runtimeType.UnderlyingSystemType;
                }
                if (IsEnum)
                {                   
                    if (m_underlyingSystemType != null)
                        return m_underlyingSystemType;
                    else
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NoUnderlyingTypeOnEnum"));
                        
                }
                return this;
            }
        }

        //ICustomAttributeProvider
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
        {
            if (m_runtimeType != null)
            {
                return CustomAttribute.GetCustomAttributes(m_runtimeType, null, inherit);
            }
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        // Return a custom attribute identified by Type
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            if (m_runtimeType != null)
            {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            attributeType = attributeType.UnderlyingSystemType;
            if (!(attributeType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
                return CustomAttribute.GetCustomAttributes(m_runtimeType, attributeType, inherit);
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

       // Returns true if one or more instance of attributeType is defined on this member.
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.IsDefined"]/*' />
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (m_runtimeType != null)
            {
                return CustomAttribute.IsDefined(m_runtimeType, attributeType, inherit);
            }
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }


        // Custom attribute support.

       // Use this function if client decides to form the custom attribute blob themselves
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.SetCustomAttribute"]/*' />
        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {
            if (con == null)
                throw new ArgumentNullException("con");
            if (binaryAttribute == null)
                throw new ArgumentNullException("binaryAttribute");

            TypeBuilder.InternalCreateCustomAttribute(
                m_tdType.Token,
                ((ModuleBuilder )m_module).GetConstructorToken(con).Token,
                binaryAttribute,
                m_module,
                false);
        }

       // Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            if (customBuilder == null)
            {
                throw new ArgumentNullException("customBuilder");
            }

            customBuilder.CreateCustomAttribute((ModuleBuilder)m_module, m_tdType.Token);
        }

        internal override int InternalGetTypeDefToken()
        {
            return m_tdType.Token;
        }

        /*
        /// <include file='doc\TypeBuilder.uex' path='docs/doc[@for="TypeBuilder.VerifyTypeAttributes"]/*' />
        public TypeToken TypeToken {
            get { return m_tdType; }
        }
        */

        /*****************************************************
         *
         * private/protected functions
         *
         */

        // Verifies that the given list of attributes is valid for a class.
        //
        internal void VerifyTypeAttributes(TypeAttributes attr) {
            if (((attr & TypeAttributes.Sealed)!=0) && ((attr & TypeAttributes.Abstract)!=0)) {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeAttrAbstractNFinal"));
            }

            // Verify attr consistency for Nesting or otherwise.
            if (DeclaringType == null)
            {
                // Not a nested class.
                if ( ((attr & TypeAttributes.VisibilityMask) != TypeAttributes.NotPublic) &&
                     ((attr & TypeAttributes.VisibilityMask) != TypeAttributes.Public) )
                {
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeAttrNestedVisibilityOnNonNestedType"));
                }
            }
            else
            {
                // Nested class.
                if ( ((attr & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic) ||
                     ((attr & TypeAttributes.VisibilityMask) == TypeAttributes.Public) )
                {
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeAttrNonNestedVisibilityNestedType"));
                }
            }

            // Verify that the layout mask is valid.
            if ( ((attr & TypeAttributes.LayoutMask) != TypeAttributes.AutoLayout) &&
                 ((attr & TypeAttributes.LayoutMask) != TypeAttributes.SequentialLayout) &&
                 ((attr & TypeAttributes.LayoutMask) != TypeAttributes.ExplicitLayout) )
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeAttrInvalidLayout"));
            }

            // Check if the user attempted to set any reserved bits.
            if ((attr & TypeAttributes.ReservedMask) != 0)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeAttrReservedBitsSet"));
            }
        }

        //*******************************
        // Make a private constructor so these cannot be constructed externally.
        //*******************************
        private TypeBuilder() {}


        // Constructs a TypeBuilder. The class is defined within the runtime and a methoddef
        // token is generated for this class.  The parent and attributes are defined.
        //
        internal TypeBuilder(
            String      name,                       // name of type
            TypeAttributes attr,                    // type attribute
            Type        parent,                     // base class
            Type[]      interfaces,                 // implemented interfaces
            Module      module,                     // module containing this type
            PackingSize iPackingSize,               // Packing size of this type
            TypeBuilder enclosingType)              // enclosing type. Null if Top level type
        {
            Init(name, attr, parent, interfaces, module, iPackingSize, UnspecifiedTypeSize, enclosingType);
        }

        // instantiating a type builder with totalsize or packing size information.
        // Note that if you specify the total size for a type, you cannot define any specific
        // fields. However, you can define user methods on it.
        internal TypeBuilder(
            String          name,                    // name of type
            TypeAttributes  attr,                    // type attribute
            Type            parent,                  // base class
            Module          module,                  // module containing this type
            PackingSize     iPackingSize,            // Packing size of this type
            int             iTypeSize,               // Total size of this type
            TypeBuilder     enclosingType)           // enclosing type. Null if Top level type
        {
            Init(name, attr, parent, null, module, iPackingSize, iTypeSize, enclosingType);
        }


        // Used to construct the place holder for global functions and data members
        internal TypeBuilder(
            ModuleBuilder  module)                     // module containing this type
        {
            // set the token to be the null TypeDef token
            m_tdType = new TypeToken(SignatureHelper.mdtTypeDef);
            m_isHiddenGlobalType = true;
            m_module = (ModuleBuilder) module;
            m_listMethods = new ArrayList();
        }

        private void Init(
            String          fullname,               // name of type
            TypeAttributes  attr,                   // type attribute
            Type            parent,                 // base class
            Type[]          interfaces,             // implemented interfaces
            Module          module,                 // module containing this type
            PackingSize     iPackingSize,           // Packing size of this type
            int             iTypeSize,              // Total size for the type
            TypeBuilder     enclosingType)          // enclosing type. Null if Top level type
        {
            int         i;
            int[]       interfaceTokens;
            interfaceTokens = null;
            m_hasBeenCreated = false;
            m_runtimeType = null;
            m_isHiddenGlobalType = false;
            m_isHiddenType = false;
            m_module = (ModuleBuilder) module;
            m_DeclaringType = enclosingType;
            m_tkComType = 0;
            Assembly containingAssem = m_module.Assembly;
            m_underlyingSystemType = null;          // used when client use TypeBuilder to define Enum

            if (fullname == null)
                throw new ArgumentNullException("fullname");
            if (fullname.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "fullname");

            if (fullname[0] == '\0')
                throw new ArgumentException(Environment.GetResourceString("Argument_IllegalName"), "fullname");
                                                               
            // @todo:  Take this restriction away in V2.
            if (fullname.Length > 1023)
                throw new ArgumentException(Environment.GetResourceString("Argument_TypeNameTooLong"), "fullname");

            // cannot have two types within the same assembly of the same name
            containingAssem.m_assemblyData.CheckTypeNameConflict(fullname, enclosingType);

            CheckForSpecialChars(fullname);

            if (enclosingType != null)
            {
                // Nested Type should have nested attribute set.
                // If we are renumbering TypeAttributes' bit, we need to change the logic here.
                if ( ((attr & TypeAttributes.VisibilityMask) == TypeAttributes.Public) ||
                     ((attr & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic))
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadNestedTypeFlags"), "attr");

                m_strFullQualName = enclosingType.FullName + "+" + fullname;
            }
            else
                m_strFullQualName = fullname;

            if (interfaces != null)
            {
                for (i = 0; i < interfaces.Length; i++)
                {
                    if (interfaces[i] == null)
                    {
                        // cannot contain null in the interface list
                        throw new ArgumentNullException("interfaces");
                    }
                }
                interfaceTokens = new int[interfaces.Length];
                for (i = 0; i < interfaces.Length; i++)
                {
                    interfaceTokens[i] = m_module.GetTypeToken(interfaces[i]).Token;
                }
            }

            int     iLast = fullname.LastIndexOf('.');
            if (iLast == -1 || iLast == 0)
            {
                // no name space
                m_strNameSpace = String.Empty;
                m_strName = fullname;
            }
            else
            {
                // split the name space
                m_strNameSpace = fullname.Substring(0, iLast);
                m_strName = fullname.Substring(iLast + 1);
            }

            if (parent != null) {
                if (parent.IsSealed || parent.IsArray ||
                    ( (parent.IsSubclassOf(typeof(Delegate))) &&
                      (parent != typeof(MulticastDelegate)) ))
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadParentType"));

                // An interface may not have a parent.
                // A class cannot inherit from an interface.
                if (((attr & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface) ||
                    parent.IsInterface)
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadParentType"));

                m_typeParent = parent;

            } else {
                if ((attr & TypeAttributes.Interface) != TypeAttributes.Interface)
                {
                    m_typeParent = typeof(Object);
                }
                else
                {
                    if ((attr & TypeAttributes.Abstract)==0)
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadInterfaceNotAbstract"));

                    // there is no extends for interface class
                    m_typeParent = null;
                }
            }

            VerifyTypeAttributes(attr);

            m_iAttr = attr;

            m_listMethods = new ArrayList();

            //Copy the interfaces so that changes to the external array don't affect us.
            //@ToDo: Implement verification that each of these is actually an interface.
            if (interfaces==null)
            {
                m_typeInterfaces = null;
            }
            else
            {
                m_typeInterfaces = new Type[interfaces.Length];
                Array.Copy(interfaces, m_typeInterfaces, interfaces.Length);
            }

            m_constructorCount=0;

            int tkParent = 0;
            if (m_typeParent != null)
                tkParent = m_module.GetTypeToken(m_typeParent).Token;

            int tkEnclosingType = 0;
            if (enclosingType != null)
            {
                tkEnclosingType = enclosingType.m_tdType.Token;
            }

            m_tdType = InternalDefineClass(fullname, tkParent, interfaceTokens, m_iAttr, m_module, Guid.Empty, tkEnclosingType);
            m_iPackingSize = iPackingSize;
            m_iTypeSize = iTypeSize;
            if ((m_iPackingSize != 0) || (m_iTypeSize != 0))
                InternalSetClassLayout(Module, m_tdType.Token, m_iPackingSize, m_iTypeSize);

            // If the type is public and it is contained in a assemblyBuilder,
            // update the public COMType list.
            if (IsPublicComType(this))
            {
                if (containingAssem is AssemblyBuilder)
                {
                    AssemblyBuilder assemBuilder = (AssemblyBuilder) containingAssem;
                    if (assemBuilder.IsPersistable() && m_module.IsTransient() == false)
                    {
                        assemBuilder.m_assemblyData.AddPublicComType(this);
                    }
                }
            }
        }

        /**********************************************
         * If the instance of the containing assembly builder is
         * to be synchronized, obtain the lock.
         **********************************************/
        internal void Enter()
        {
            Module.Assembly.m_assemblyData.Enter();
        }

        /**********************************************
         * If the instance of the containing assembly builder is
         * to be synchronized, free the lock.
         **********************************************/
        internal void Exit()
        {
            Module.Assembly.m_assemblyData.Exit();
        }

        //*****************************************
        // Internal Helper to determine if a type should be added to ComType table.
        // A top level type should be added if it is Public.
        // A nested type should be added if the top most enclosing type is Public and all the enclosing
        // types are NestedPublic
        //*****************************************
        static private bool IsPublicComType(Type type)
        {
            Type       enclosingType = type.DeclaringType;
            if (enclosingType != null )
            {
                if (IsPublicComType(enclosingType))
                {
                    if ((type.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic)
                    {
                         return true;
                    }
                }
            }
            else
            {
                if ((type.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public)
                {
                    return true;
                }
            }
            return false;
        }

        // Throws if there is a special char in the type name without a matching '\'
        internal static void CheckForSpecialChars(String typeName)
        {
            int endIndex = typeName.Length-1;
            CheckForSpecialCharHelper(typeName, endIndex);

            char lastChar = typeName[endIndex];
            if ((lastChar == '*') ||
                (lastChar == '&')) {

                bool evenSlashes = true;
                while ((endIndex > 0) &&
                       (typeName[--endIndex] == '\\'))
                    evenSlashes = !evenSlashes;

                // Even number of slashes means this is a lone special char
                if (evenSlashes)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidTypeNameChar"));
            }
        }

        private static void CheckForSpecialCharHelper(String typeName, int endIndex)
        {
            int originalEnd = endIndex;
            char[] specialChars = { ',', '[', ']', '+', '\\' };

            while (endIndex >= 0) {
                endIndex = typeName.LastIndexOfAny(specialChars, endIndex);
                if (endIndex == -1)
                    return;

                bool evenSlashes = true;
                if ((typeName[endIndex] == '\\') &&
                    (endIndex != originalEnd)) {
                    char nextChar = typeName[endIndex+1];
                    if ((nextChar == '+') ||
                        (nextChar == '[') ||
                        (nextChar == ']') ||
                        (nextChar == '&') ||
                        (nextChar == '*') ||
                        (nextChar == ','))
                        evenSlashes = false;
                }

                while ((--endIndex >= 0) &&
                       typeName[endIndex] == '\\')
                    evenSlashes = !evenSlashes;

                // Even number of slashes means this is a lone special char
                if (evenSlashes)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidTypeName"));
            }
        }

        // This is a helper function that is used by ParameterBuilder, PropertyBuilder,
        // and FieldBuilder to validate a default value and save it in the meta-data.
        internal static void SetConstantValue(
            Module      module,
            int         tk,
            Type        destType,
            Object      value)
        {
            if (value == null)
            {
                if (destType.IsValueType)
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConstantNull"));
            }
            else
            {
                // client is going to set non-null constant value
                Type type = value.GetType();
                
                // The default value on the enum typed field/parameter is the underlying type.
                if (destType.IsEnum == false)
                {
                    if (destType != type)
                        throw new ArgumentException(Environment.GetResourceString("Argument_ConstantDoesntMatch"));
                        

                    switch(Type.GetTypeCode(type))
                    {
                    case TypeCode.Boolean:
                    case TypeCode.Char:
                    case TypeCode.SByte:
                    case TypeCode.Byte:
                    case TypeCode.Int16:
                    case TypeCode.UInt16:
                    case TypeCode.Int32:
                    case TypeCode.UInt32:
                    case TypeCode.Int64:
                    case TypeCode.UInt64:
                    case TypeCode.Single:
                    case TypeCode.Double:
                    case TypeCode.Decimal:
                    case TypeCode.String:
                        break;
                    default:
                        {
                            if (type != typeof(System.DateTime))
                                throw new ArgumentException(Environment.GetResourceString("Argument_ConstantNotSupported"));
                            break;
                        }
                   
                    }
                }
                else
                {
                    // The constant value supplied should match the underlying type of the enum 
                    if (destType.UnderlyingSystemType != type)
                        throw new ArgumentException(Environment.GetResourceString("Argument_ConstantDoesntMatch"));
                    
                }
            }
            
            InternalSetConstantValue(
                module,
                tk, 
                new Variant(value));
        }

        /*****************************************************
         *
         * Native Helpers
         *
         */
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern TypeToken InternalDefineClass(
            String      fullname,
            int         tkParent,
            int[]       interfaceTokens,
            TypeAttributes         attr,
            Module      module,
            Guid        guid,
            int         tkEnclosingType);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void InternalSetParentType(
            int         tdTypeDef,
            int         tkParent,
            Module      module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void InternalAddInterfaceImpl(
            int         tdTypeDef,
            int         tkInterface,
            Module      module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern MethodToken InternalDefineMethod(
            TypeToken   handle,
            String      name,
            byte[]      signature,
            int         sigLength,
            MethodAttributes attributes,
            Module      module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int InternalDefineField(
            TypeToken   handle,
            String      name,
            byte[]      signature,
            int         sigLength,
            FieldAttributes attributes,
            Module      module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetMethodIL(
            MethodToken     methodHandle,
            bool            isInitLocals,
            byte[]          body,
            byte[]          LocalSig,
            int             sigLength,
            int             maxStackSize,
            int             numExceptions,
            __ExceptionInstance[] exceptions,
            int             []tokenFixups,
            int             []rvaFixups,
            Module          module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type TermCreateClass(TypeToken handle, Module module);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalCreateCustomAttribute(
            int     tkAssociate,
            int     tkConstructor,
            byte[]  attr,
            Module  module,
            bool    toDisk);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetPInvokeData(Module module, String DllName, String name, int token, int linkType, int linkFlags);

        // Internal helpers to define property records
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern PropertyToken InternalDefineProperty(
            Module      module,
            int         handle,
            String      name,
            int         attributes,
            byte[]      signature,
            int         sigLength,
            int         notifyChanging,
            int         notifyChanged);

        // Internal helpers to define event records
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern EventToken InternalDefineEvent(
            Module      module,
            int         handle,
            String      name,
            int         attributes,
            int         tkEventType);

        // Internal helpers to define MethodSemantics records
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalDefineMethodSemantics(
            Module      module,
            int         tkAssociation,
            MethodSemanticsAttributes         semantics,
            int         tkMethod);

        // Internal helpers to define MethodImpl record
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalDefineMethodImpl(ModuleBuilder module, int tkType, int tkBody, int tkDecl);

        // Internal helpers to define MethodImpl flags
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetMethodImpl(
            Module                  module,
            int                     tkMethod,
            MethodImplAttributes    MethodImplAttributes);

        // Internal helpers to set parameter information
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int InternalSetParamInfo(
            Module                  module,
            int                     tkMethod,
            int                     iSequence,
            ParameterAttributes     iParamAttributes,
            String                  strParamName);

        // Internal helpers to get signature token
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int InternalGetTokenFromSig(
            Module      module,
            byte[]      signature,
            int         sigLength);

        // Internal helpers to set field layout information
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetFieldOffset(
            Module      module,
            int         fdToken,
            int         iOffset);

        // Internal helpers to set class layout information
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetClassLayout(
            Module      module,
            int         tdToken,
            PackingSize iPackingSize,
            int         iTypeSize);


        // Internal helpers to set marshal information
        // tk can be Field token or Parameter token
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetMarshalInfo(
            Module      module,
            int         tk,
            byte[]      ubMarshal,
            int         ubSize);

        // helper to set default constant on field or default value on parameter
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSetConstantValue(
            Module      module,
            int         tk,
            Variant     var);

        // Helper to add declarative security to a class or method
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalAddDeclarativeSecurity(
            Module      module,
            int             parent,
            SecurityAction  action,
            byte[]         blob);
            
        internal bool IsCreated() 
        { 
            return m_hasBeenCreated;
        }
        
        internal void ThrowIfCreated()
        {
            if (IsCreated())
            {
                // cannot add fields after type is created
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeHasBeenCreated"));
            }
        }
        

        /*****************************************************
         *
         * private data members
         *
         */
        private TypeToken       m_tdType;           // MethodDef token for this class.
        private ModuleBuilder   m_module;           // The module the class is defined inside of
        private String          m_strName;          // Name of the type
        private String          m_strNameSpace;     // NameSpace of the type
        private String          m_strFullQualName;  // Fully qualified name of the type
        // In the form "encloser+nested" for nested types.
        private Type            m_typeParent;       // Parent of this class (Assume Object)
        private Type[]          m_typeInterfaces;

        internal TypeAttributes m_iAttr;            // Define the Class Attributes
        internal ArrayList      m_listMethods;      // The list of methods...
        private int             m_constructorCount;
        private int             m_iTypeSize;
        private PackingSize     m_iPackingSize;
        private TypeBuilder     m_DeclaringType;
        private int             m_tkComType;
        private Type            m_underlyingSystemType; // set when user calls UnderlyingSystemType on TypeBuilder if TypeBuilder is an Enum

        //The bitwise not of our list of permissable attributes.  Used to verify that all of our attribute masks are valid.
        internal bool           m_isHiddenGlobalType;
        internal bool           m_isHiddenType;
        internal bool           m_hasBeenCreated;   // set to true if CreateType has been called.
        internal Type           m_runtimeType;

        private static Type     SystemArray = typeof(System.Array);
        private static Type     SystemEnum = typeof(System.Enum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\satellitecontractversionattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SatelliteContractVersionAttribute
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Specifies which version of a satellite assembly 
**          the ResourceManager should ask for.
**
** Date:  December 8, 2000
**
===========================================================*/

using System;

namespace System.Resources {
    
    /// <include file='doc\SatelliteContractVersionAttribute.uex' path='docs/doc[@for="SatelliteContractVersionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class SatelliteContractVersionAttribute : Attribute 
    {
        private String _version;

        /// <include file='doc\SatelliteContractVersionAttribute.uex' path='docs/doc[@for="SatelliteContractVersionAttribute.SatelliteContractVersionAttribute"]/*' />
        public SatelliteContractVersionAttribute(String version)
        {
            if (version == null)
                throw new ArgumentNullException("version");
            _version = version;
        }

        /// <include file='doc\SatelliteContractVersionAttribute.uex' path='docs/doc[@for="SatelliteContractVersionAttribute.Version"]/*' />
        public String Version {
            get { return _version; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\runtimeresourceset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  RuntimeResourceSet
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: CultureInfo-specific collection of resources.
**
** Date:  March 26, 1999
** 
===========================================================*/
namespace System.Resources {    
    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;

    // A RuntimeResourceSet stores all the resources defined in one 
    // particular CultureInfo, with some loading optimizations.
    //
    // It is expected that nearly all the runtime's users will be satisfied with the
    // default resource file format, and it will be more efficient than most simple
    // implementations.  Users who would consider creating their own ResourceSets and/or
    // ResourceReaders and ResourceWriters are people who have to interop with a 
    // legacy resource file format, are creating their own resource file format 
    // (using XML, for instance), or require doing resource lookups at runtime over 
    // the network.  This group will hopefully be small, but all the infrastructure 
    // should be in place to let these users write &; plug in their own tools.
    //
    // The Default Resource File Format
    //
    // The fundamental problems addressed by the resource file format are:
    // 
    // Versioning - A ResourceReader could in theory support many different 
    // file format revisions.
    // Storing intrinsic datatypes (ie, ints, Strings, DateTimes, etc) in a compact
    // format
    // Support for user-defined classes - Accomplished using Serialization
    // Resource lookups should not require loading an entire resource file - If you look up a resource, we only load the value for that resource, minimizing working set.
    // 
    // 
    // There are four sections to the default file format.  The first
    // is the Resource Manager header, which consists of a magic number
    // that identifies this as a Resource file, and a ResourceSet class name.
    // The class name is written here to allow users to provide their own 
    // implementation of a ResourceSet (and a matching ResourceReader) to 
    // control policy.  If objects greater than a certain size or matching a
    // certain naming scheme shouldn't be stored in memory, users can tweak that
    // with their own subclass of ResourceSet.
    // 
    // The second section in the system default file format is the 
    // RuntimeResourceSet specific header.  This contains a version number for
    // the .resources file, the number of resources in this file, the number of 
    // different types contained in the file, followed by a list of fully 
    // qualified type names.  After this, we include an array of hash values for
    // each resource name, then an array of virtual offsets into the name section
    // of the file.  The hashes allow us to do a binary search on an array of 
    // integers to find a resource name very quickly without doing many string
    // compares (except for once we find the real type, of course).  If a hash
    // matches, the index into the array of hash values is used as the index
    // into the name position array to find the name of the resource.  The type
    // table allows us to read multiple different classes from the same file, 
    // including user-defined types, in a more efficient way than using 
    // Serialization, at least when your .resources file contains a reasonable 
    // proportion of base data types such as Strings or ints.  We use 
    // Serialization for all the non-instrinsic types.
    // 
    // The third section of the file is the name section.  It contains a 
    // series of resource names, written out as byte-length prefixed little
    // endian Unicode strings (UTF-16).  After each name is a four byte virtual
    // offset into the data section of the file, pointing to the relevant 
    // string or serialized blob for this resource name.
    //
    // The fourth section in the file is the data section, which consists
    // of a type and a blob of bytes for each item in the file.  The type is 
    // an integer index into the type table.  The data is specific to that type,
    // but may be a number written in binary format, a String, or a serialized 
    // Object.
    // 
    // The system default file format is as follows:
    // 
    // 
    // System Default Resource File Format
    // What Type of Data
    // Resource Manager header
    // Magic Number (0xBEEFCACE) Int32
    // Resource Manager header version Int32
    // Num bytes to skip from here to get past this header Int32
    // Class name of IResourceReader to parse this file String
    // Class name of ResourceSet to parse this file String
    // RuntimeResourceReader header
    // RuntimeResourceReader Version number Int32
    // Number of resources in the file Int32
    // Number of types in the type table Int32
    // Padding bytes for 8-byte alignment (use PAD) Bytes (0-7)
    // Name of each type Set of Strings
    // Hash values for each resource name Int32 array, sorted
    // Virtual offset of each resource name Int32 array, coupled with hash values
    // RuntimeResourceReader Name Section
    // Name &; virtual offset of each resource Set of (UTF-16 String, Int32) pairs
    // RuntimeResourceReader Data Section
    // Type and Value of each resource Set of (Int32, blob of bytes) pairs
    // 
    // 
    // This implementation, when used with the default ResourceReader class,
    // loads only the strings that you look up for.  It can do string comparisons
    // without having to create a new String instance due to some memory mapped 
    // file optimizations in the ResourceReader and FastResourceComparer 
    // classes.  This keeps the memory we touch to a minimum when loading 
    // resources. 
    //
    // If you use a different IResourceReader class to read a file, or if you
    // do case-insensitive lookups (and the case-sensitive lookup fails) then
    // we will load all the names of each resource and each resource value.
    // This could probably use some optimization.
    // 
    // In addition, this supports object serialization in a similar fashion.
    // We build an array of class types contained in this file, and write it
    // to RuntimeResourceReader header section of the file.  Every resource
    // will contain its type (as an index into the array of classes) with the data
    // for that resource.  We will use the Runtime's serialization support for this.
    // 
    // All strings in the file format are written with BinaryReader and
    // BinaryWriter, which writes out the length of the String in bytes as an 
    // Int32 then the contents as Unicode chars encoded in UTF-8.  In the name
    // table though, each resource name is written in UTF-16 so we can do a
    // string compare byte by byte against the contents of the file, without
    // allocating objects.  Ideally we'd have a way of comparing UTF-8 bytes 
    // directly against a String object, but that may be a lot of work.
    // 
    // The offsets of each resource string are relative to the beginning 
    // of the Data section of the file.  This way, if a tool decided to add 
    // one resource to a file, it would only need to increment the number of 
    // resources, add the hash &; location of last byte in the name section
    // to the array of resource hashes and resource name positions (carefully
    // keeping these arrays sorted), add the name to the end of the name &; 
    // offset list, possibly add the type list of types types (and increase 
    // the number of items in the type table), and add the resource value at 
    // the end of the file.  The other offsets wouldn't need to be updated to 
    // reflect the longer header section.
    // 
    // Resource files are currently limited to 2 gigabytes due to these 
    // design parameters.  A future version may raise the limit to 4 gigabytes
    // by using unsigned integers, or may use negative numbers to load items 
    // out of an assembly manifest.  Also, we may try sectioning the resource names
    // into smaller chunks, each of size sqrt(n), would be substantially better for
    // resource files containing thousands of resources.
    // 
    internal sealed class RuntimeResourceSet : ResourceSet, IEnumerable
    {
        internal static int Version = 1;            // File format version number
        
        private Hashtable _table;
        // For our special load-on-demand reader, cache the cast.  The 
        // RuntimeResourceSet's implementation knows how to treat this reader specially.
        private ResourceReader _defaultReader;

        // This is a lookup table for case-sensitive lookups, and may be null.
        private Hashtable _caseInsensitiveTable;

        // If we're not using our custom reader, then enumerate through all
        // the resources once, adding them into the table.
        private bool _haveReadFromReader;
        
        internal RuntimeResourceSet(String fileName)
        {
            BCLDebug.Log("RESMGRFILEFORMAT", "RuntimeResourceSet .ctor(String)");
            _table = new Hashtable(FastResourceComparer.Default, FastResourceComparer.Default);
            Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            _defaultReader = new ResourceReader(stream, _table);
            Reader = _defaultReader;
        }

        internal RuntimeResourceSet(Stream stream)
        {
            BCLDebug.Log("RESMGRFILEFORMAT", "RuntimeResourceSet .ctor(Stream)");
            _table = new Hashtable(FastResourceComparer.Default, FastResourceComparer.Default);
            _defaultReader = new ResourceReader(stream, _table);
            Reader = _defaultReader;
        }
    
        internal RuntimeResourceSet(IResourceReader reader)
        {
            if (reader == null)
                throw new ArgumentNullException("reader", "Null IResourceReader is not allowed.");
            Reader = reader;
            // We special case the ResourceReader class.  It's sealed, so this is
            // guaranteed to be safe.  _defaultReader can safely be null.
            _defaultReader = reader as ResourceReader;
            BCLDebug.Log("RESMGRFILEFORMAT", "RuntimeResourceSet .ctor(IResourceReader)  defaultReader: "+(_defaultReader != null));
            if (_defaultReader == null)
                _table = new Hashtable(FastResourceComparer.Default, FastResourceComparer.Default);
            else
                _table = _defaultReader._table;
        }
    
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                lock(this) {
                    _table = null;
                    if (_defaultReader != null) {
                        _defaultReader.Close();
                        _defaultReader = null;
                    }
                    _caseInsensitiveTable = null;
                    // Set Reader to null to avoid a race in GetObject.
                    base.Dispose(disposing);
                }
            } 
            else {
                // Just to make sure we always clear these fields in the future...
                _table = null;
                _caseInsensitiveTable = null;
                _defaultReader = null;
                base.Dispose(disposing);
            }
        }

        public override IDictionaryEnumerator GetEnumerator()
        {
            return GetEnumeratorHelper();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumeratorHelper();
        }

        private IDictionaryEnumerator GetEnumeratorHelper()
        {
            Hashtable copyOfTable = _table;
            IResourceReader copyOfReader = Reader;
            Hashtable copyOfCITable = _caseInsensitiveTable;
            if (copyOfReader == null || copyOfTable == null)
                throw new InvalidOperationException("ResourceSet is closed");

            if (_haveReadFromReader && copyOfCITable != null)
                return copyOfCITable.GetEnumerator();
            return copyOfReader.GetEnumerator();
        }


        public override String GetString(String key)
        {
            // @TODO: Implement this method in terms of LoadString on the resource
            // set, instead of calling GetObject then casting to a String.
            Object o = GetObject(key, false);
            try {
                return (String) o;
            }
            catch (InvalidCastException) {
                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_ResourceNotString_Name"), key));
            }
        }

        public override String GetString(String key, bool ignoreCase)
        {
            // @TODO: Implement this method in terms of LoadString on the resource
            // set, instead of calling GetObject then casting to a String.
            Object o = GetObject(key, ignoreCase);
            try {
                return (String) o;
            }
            catch (InvalidCastException) {
                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_ResourceNotString_Name"), key));
            }
        }

        public override Object GetObject(String key)
        {
            return GetObject(key, false);
        }

        public override Object GetObject(String key, bool ignoreCase)
        {
            if (key==null)
                throw new ArgumentNullException("key");
            Hashtable copyOfTable = _table;
            if (Reader == null || copyOfTable == null)
                throw new InvalidOperationException("ResourceSet is closed");

            Object value = copyOfTable[key];
            if (value != null)
                return value;
            
            lock(this) {
                if (Reader == null)
                    throw new InvalidOperationException("ResourceSet is closed");
                
                if (_defaultReader != null) {
                    BCLDebug.Log("RESMGRFILEFORMAT", "Going down fast path in RuntimeResourceSet::GetObject");
                    
                    int pos = _defaultReader.FindPosForResource(key);
                    if (pos != -1) {
                        value = _defaultReader.LoadObject(pos);
                        // ResourceReader's Enumerator could also be filling in
                        // values in _table, hence this lock.
                        lock(_table) {
                            Object v2 = _table[key];
                            if (v2 == null)
                                _table[key] = value;
                            else
                                value = v2;
                        }
                        return value;
                    }
                    else if (!ignoreCase)
                        return null;
                }

                // At this point, we either don't have our default resource reader
                // or we haven't found the particular resource we're looking for
                // and may have to search for it in a case-insensitive way.
                if (!_haveReadFromReader) {
                    // If necessary, init our case insensitive hash table.
                    if (ignoreCase && _caseInsensitiveTable == null) {
                        _caseInsensitiveTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                    }
#if _DEBUG
                    //Console.WriteLine("RuntimeResourceSet::GetObject loading up data.  ignoreCase: "+ignoreCase);
                    BCLDebug.Perf(!ignoreCase, "Using case-insensitive lookups is bad perf-wise.  Consider capitalizing "+key+" correctly in your source");
#endif
                    IDictionaryEnumerator en = Reader.GetEnumerator();
                    while (en.MoveNext()) {
                        if (_defaultReader == null)
                            _table.Add(en.Key, en.Value);
                        if (ignoreCase)
                            _caseInsensitiveTable.Add(en.Key, en.Value);
                    }
                    // If we are doing a case-insensitive lookup, we don't want to
                    // close our default reader since we may still use it for
                    // case-sensitive lookups later.
                    if (!ignoreCase)
                        Reader.Close();
                    _haveReadFromReader = true;
                }
                Object obj = null;
                if (_defaultReader != null)
                    obj = _table[key];
                if (obj == null && ignoreCase)
                    obj = _caseInsensitiveTable[key];
                return obj;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\__fastresourcecomparer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FastResourceComparer
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: A collection of quick methods for comparing 
**          resource keys (strings)
**
** Date:   February 13, 2001
** 
===========================================================*/
namespace System.Resources {
    using System;
    using System.Collections;

    internal sealed class FastResourceComparer : IComparer, IHashCodeProvider
    {
        internal static readonly FastResourceComparer Default = new FastResourceComparer();

        // Implements IHashCodeProvider too, due to Hashtable requirements.
        public int GetHashCode(Object key)
        {
            String s = (String) key;
            return FastResourceComparer.GetHashCode(s);
        }

        // This hash function MUST be publically documented with the resource
        // file format, AND we may NEVER change this hash function's return value.
        public static int GetHashCode(String key)
        {
            // Never change this hash function.  We must standardize it so that 
            // others can read & write our .resources files.  Additionally, we
            // have a copy of it in InternalResGen as well.
            uint hash = 5381;
            // Don't use foreach on Strings - 5.3x slower than for loop.  7/6/2001
            for(int i=0; i<key.Length; i++)
                hash = ((hash << 5) + hash) ^ key[i];
            return (int) hash;
        }

        // Compares Strings quickly in a case-sensitive way using the default 
        // culture.
        public int Compare(Object a, Object b)
        {
            if (a == b) return 0;
            String sa = (String)a;
            String sb = (String)b;
            return String.CompareOrdinal(sa, sb);
        }

        // Input is one string to compare with, and a byte[] containing chars in 
        // little endian unicode.  Pass in the number of valid chars.
        public unsafe static int CompareOrdinal(String a, byte[] bytes, int bCharLength)
        {
            BCLDebug.Assert(a != null && bytes != null, "FastResourceComparer::CompareOrdinal must have non-null params");
            BCLDebug.Assert(bCharLength * 2 <= bytes.Length, "FastResourceComparer::CompareOrdinal - numChars is too big!");
            // This is a managed version of strcmp, but I can't take advantage
            // of a terminating 0, unlike strcmp in C.
            int i = 0;
            int r = 0;
            // Compare the min length # of characters, then return length diffs.
            int numChars = a.Length;
            if (numChars > bCharLength)
                numChars = bCharLength;
            if (bCharLength == 0)   // Can't use fixed on a 0-element array.
                return (a.Length == 0) ? 0 : -1;
            fixed(byte* pb = bytes) {
                char* b = (char*) pb;
                while (i < numChars && r == 0) {
                    r = a[i++] - *b++;
                }
            }
            if (r != 0) return r;
            return a.Length - bCharLength;
        }

        public unsafe static int CompareOrdinal(byte[] bytes, int aCharLength, String b)
        {
            return -CompareOrdinal(b, bytes, aCharLength);
        }

        public unsafe static int CompareOrdinal(String a, char* b, int bCharLength)
        {
            BCLDebug.Assert(a != null && b != null, "Null args not allowed.");
            BCLDebug.Assert(bCharLength >= 0, "bCharLength must be non-negative.");
            // I cannot use String::nativeComapreOrdinalWC here because that method
            // expects a 0-terminated String.  I have length-prefixed strings with no \0.
            int i = 0;
            int r = 0;
            // Compare the min length # of characters, then return length diffs.
            int numChars = a.Length;
            if (numChars > bCharLength)
                numChars = bCharLength;
            while (i < numChars && r == 0) {
                r = a[i++] - *b++;
            }
            if (r != 0) return r;
            return a.Length - bCharLength;
        }

        public unsafe static int CompareOrdinal(char* a, int aCharLength, String b)
        {
            return -CompareOrdinal(b, a, aCharLength);
        }

        // This method is to handle potentially misaligned data accesses.
        // The byte* must point to little endian Unicode characters.
        internal unsafe static int CompareOrdinal(byte* a, int byteLen, String b)
        {
            BCLDebug.Assert((byteLen & 1) == 0, "CompareOrdinal is expecting a UTF-16 string length, which must be even!");
            BCLDebug.Assert(a != null && b != null, "Null args not allowed.");
            BCLDebug.Assert(byteLen >= 0, "byteLen must be non-negative.");

            int r = 0;
            int i = 0;
            // Compare the min length # of characters, then return length diffs.
            int numChars = byteLen >> 1;
            if (numChars > b.Length)
                numChars = b.Length;
            while(i < numChars && r == 0) {
                // Must compare character by character, not byte by byte.
                char aCh = (char) (*a++ | (*a++ << 8));
                r = aCh - b[i++];
            }
            if (r != 0) return r;
            return byteLen - b.Length * 2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\resourcereader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ResourceReader
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Default way to read streams of resources on 
** demand.
**
** Date:   March 26, 1999   Rewritten February 13, 2001
** 
===========================================================*/
namespace System.Resources {
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Reflection;
    using System.Security.Permissions;
    using System.Security;

    // Provides the default implementation of IResourceReader, reading
    // .resources file from the system default binary format.  This class
    // can be treated as an enumerator once.
    // 
    // See the RuntimeResourceSet overview for details on the system 
    // default file format.
    // 

     // This class will not be marked serializable until we can handle serializing the backing store
    /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader"]/*' />
    public unsafe sealed class ResourceReader : IResourceReader
    {
        private BinaryReader _store;    // backing store we're reading from.
        private long _nameSectionOffset;  // Offset to name section of file.
        private long _dataSectionOffset;  // Offset to Data section of file.
        internal Hashtable _table;     // Holds the resource Name and Data

        // Note this class is tightly coupled with __UnmanagedMemoryStream.
        // At runtime when getting an embedded resource from an assembly, 
        // we're given an __UnmanagedMemoryStream referring to the mmap'ed portion
        // of the assembly.  The pointers here are pointers into that block of
        // memory controlled by the OS's loader.
        private int[] _nameHashes;    // hash values for all names.
        private int* _nameHashesPtr;  // In case we're using __UnmanagedMemoryStream
        private int[] _namePositions; // relative locations of names
        private int* _namePositionsPtr;  // If we're using __UnmanagedMemoryStream
        private Type[] _typeTable;    // Array of Types for resource values.
        private IFormatter _objFormatter; // Deserialization stuff.
        private int _numResources;    // Num of resources files, in case arrays aren't allocated.

        // We'll include a separate code path that uses UnmanagedMemoryStream to
        // avoid allocating String objects and the like.
        private __UnmanagedMemoryStream _ums;

        private bool[] _safeToDeserialize; // Whether to assert serialization permission

        // One of our goals is to make sure localizable Windows Forms apps
        // work in semi-trusted scenarios (ie, without serialization permission).
        // Unfortunate we're serializing out some complex types that currently
        // require a security check on deserialization.  We may fix this
        // in a next version, but for now just hard-code a list.
        // Hard-code in the assembly name (minus version) so people can't spoof us.
        private static readonly String[] TypesSafeForDeserialization = {
            "System.Drawing.Bitmap, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.Imaging.Metafile, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.Point, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.PointF, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.Size, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.SizeF, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.Font, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Drawing.Icon, System.Drawing, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
            "System.Windows.Forms.Cursor, System.Windows.Forms, Culture=neutral, PublicKeyToken=b77a5c561934e089",
            "System.Windows.Forms.ImageListStreamer, System.Windows.Forms, Culture=neutral, PublicKeyToken=b77a5c561934e089" };


        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.ResourceReader"]/*' />
        public ResourceReader(String fileName)
        {
            _table = new Hashtable(FastResourceComparer.Default, FastResourceComparer.Default);
            _store = new BinaryReader(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read), Encoding.UTF8);
            BCLDebug.Log("RESMGRFILEFORMAT", "ResourceReader .ctor(String).  UnmanagedMemoryStream: "+(_ums!=null));
            ReadResources();
        }
    
        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.ResourceReader1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public ResourceReader(Stream stream)
        {
            if (stream==null)
                throw new ArgumentNullException("stream");
            if (!stream.CanRead)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotReadable"));

            _table = new Hashtable(FastResourceComparer.Default, FastResourceComparer.Default);
            _store = new BinaryReader(stream, Encoding.UTF8);
            // We have a faster code path for reading resource files from an assembly.
            _ums = stream as __UnmanagedMemoryStream;
            BCLDebug.Log("RESMGRFILEFORMAT", "ResourceReader .ctor(Stream).  UnmanagedMemoryStream: "+(_ums!=null));
            ReadResources();
        }
    
        // This is the constructor the RuntimeResourceSet calls,
        // passing in the stream to read from and the RuntimeResourceSet's 
        // internal hash table (hash table of names with file offsets
        // and values, coupled to this ResourceReader).
        internal ResourceReader(Stream stream, Hashtable table)
        {
            if (stream == null)
                throw new ArgumentNullException("stream");
            if (table == null)
                throw new ArgumentNullException("table");
            if (!stream.CanRead)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotReadable"));

            _table = table;
            _store = new BinaryReader(stream, Encoding.UTF8);
            _ums = stream as __UnmanagedMemoryStream;

            BCLDebug.Log("RESMGRFILEFORMAT", "ResourceReader .ctor(Stream, Hashtable).  UnmanagedMemoryStream: "+(_ums!=null));
            ReadResources();
        }
        

        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.Close"]/*' />
        public unsafe void Close()
        {
            Dispose(true);
        }
        
        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.IDisposable.Dispose"]/*' />
        void IDisposable.Dispose()
        {
            Dispose(true);
        }

        private void Dispose(bool disposing)
        {
            if (_store != null) {
                _table = null;
                if (disposing) {
                    // Close the stream in a thread-safe way.  This fix means 
                    // that we may call Close n times, but that's safe.
                    BinaryReader copyOfStore = _store;
                    _store = null;
                    if (copyOfStore != null)
                        copyOfStore.Close();
                }
                _store = null;
                _namePositions = null;
                _nameHashes = null;
                _ums = null;
                _namePositionsPtr = null;
                _nameHashesPtr = null;
            }
        }
        
        private unsafe int GetNameHash(int index)
        {
            BCLDebug.Assert(index >=0 && index < _numResources, "Bad index into hash array.  index: "+index);
            BCLDebug.Assert((_ums == null && _nameHashes != null && _nameHashesPtr == null) || 
                            (_ums != null && _nameHashes == null && _nameHashesPtr != null), "Internal state mangled.");
            if (_ums == null)
                return _nameHashes[index];
            else
                return _nameHashesPtr[index];
        }

        private unsafe int GetNamePosition(int index)
        {
            BCLDebug.Assert(index >=0 && index < _numResources, "Bad index into name position array.  index: "+index);
            BCLDebug.Assert((_ums == null && _namePositions != null && _namePositionsPtr == null) || 
                            (_ums != null && _namePositions == null && _namePositionsPtr != null), "Internal state mangled.");
            int r;
            if (_ums == null)
                r = _namePositions[index];
            else
                r = _namePositionsPtr[index];
            if (r < 0 || r > _dataSectionOffset - _nameSectionOffset) {
                BCLDebug.Assert(false, "Corrupt .resources file!  NamePosition is outside of the name section!");
                throw new BadImageFormatException("Found a corrupted .resources file!  NamePosition for index "+index+" is outside of name section!  r: "+r.ToString("x"));
            }
            return r;
        }

        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <include file='doc\ResourceReader.uex' path='docs/doc[@for="ResourceReader.GetEnumerator"]/*' />
        public IDictionaryEnumerator GetEnumerator()
        {
            if (_table==null)
                throw new InvalidOperationException(Environment.GetResourceString("ResourceReaderIsClosed"));
            return new ResourceEnumerator(this);
        }

        // From a name, finds the associated virtual offset for the data.
        // This does a binary search through the names.
        internal int FindPosForResource(String name)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            int hash = FastResourceComparer.GetHashCode(name);
            BCLDebug.Log("RESMGRFILEFORMAT", "FindPosForResource for "+name+"  hash: "+hash.ToString("x"));
            // Binary search over the hashes.  Use the _namePositions array to 
            // determine where they exist in the underlying stream.
            int lo = 0;
            int hi = _numResources - 1;
            int index = -1;
            bool success = false;
            while (lo <= hi) {
                index = (lo + hi) >> 1;
                // Do NOT use subtraction here, since it will wrap for large
                // negative numbers. 
                //int c = _nameHashes[index].CompareTo(hash);
                int currentHash = GetNameHash(index);
                int c;
                if (currentHash == hash)
                    c = 0;
                else if (currentHash < hash)
                    c = -1;
                else
                    c = 1;
                //BCLDebug.Log("RESMGRFILEFORMAT", "  Probing index "+index+"  lo: "+lo+"  hi: "+hi+"  c: "+c);
                if (c == 0) {
                    success = true;
                    break;
                }
                if (c < 0)
                    lo = index + 1;
                else
                    hi = index - 1;
            }
            if (!success) {
#if RESOURCE_FILE_FORMAT_DEBUG
                lock(this) {
                    _store.BaseStream.Seek(_nameSectionOffset + GetNamePosition(index), SeekOrigin.Begin);
                    String lastReadString = _store.ReadString();
                }
                BCLDebug.Log("RESMGRFILEFORMAT", "FindPosForResource for "+name+" failed.  i: "+index+"  lo: "+lo+"  hi: "+hi+"  last read string: \""+lastReadString+"\"");
#endif
                return -1;
            }
            
            // index is the location in our hash array that corresponds with a 
            // value in the namePositions array.
            // There could be collisions in our hash function.  Check on both sides 
            // of index to find the range of hash values that are equal to the
            // target hash value.
            if (lo != index) {
                lo = index;
                while (lo > 0 && GetNameHash(lo - 1) == hash)
                    lo--;
            }
            if (hi != index) {
                hi = index;
                while (hi < _numResources && GetNameHash(hi + 1) == hash)
                    hi++;
            }

            lock(this) {
                for(int i = lo; i<=hi; i++) {
                    _store.BaseStream.Seek(_nameSectionOffset + GetNamePosition(i), SeekOrigin.Begin);
                    if (CompareStringEqualsName(name)) {
                        int dataPos = _store.ReadInt32();
                        BCLDebug.Assert(dataPos >= 0 || dataPos < _store.BaseStream.Length - _dataSectionOffset, "Data section relative offset is out of the bounds of the data section!  dataPos: "+dataPos);
                        return dataPos;
                    }
                }
            }
            BCLDebug.Log("RESMGRFILEFORMAT", "FindPosForResource for "+name+": Found a hash collision, HOWEVER, neither of these collided values equaled the given string.");
            return -1;
        }

        // This compares the String in the .resources file at the current position
        // with the string you pass in. 
        // Whoever calls this method should make sure that they take a lock
        // so no one else can cause us to seek in the stream.
        private unsafe bool CompareStringEqualsName(String name)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            int byteLen = Read7BitEncodedInt(_store);
            if (_ums != null) {
                //BCLDebug.Log("RESMGRFILEFORMAT", "CompareStringEqualsName using UnmanagedMemoryStream code path");
                byte* bytes = _ums.GetBytePtr();
                // Skip over the data in the Stream, positioning ourselves right after it.
                _ums.Seek(byteLen, SeekOrigin.Current);

                if (_ums.Position > _ums.Length)
                    throw new BadImageFormatException("Found a corrupted .resources file!  Resource name extends past the end of the file!");

                // On 64-bit machines, these char*'s may be misaligned.  Use a
                // byte-by-byte comparison instead.
                //return FastResourceComparer.CompareOrdinal((char*)bytes, byteLen/2, name) == 0;
                return FastResourceComparer.CompareOrdinal(bytes, byteLen, name) == 0;
            }
            else {
                // @TODO Perf: Make this fast
                byte[] bytes = new byte[byteLen];
                int numBytesToRead = byteLen;
                while(numBytesToRead > 0) {
                    int n = _store.Read(bytes, byteLen - numBytesToRead, numBytesToRead);
                    if (n == 0)
                        throw new EndOfStreamException("oops.  Hit EOF while trying to read a resource name from the name section.");
                    numBytesToRead -= n;
                }
                return FastResourceComparer.CompareOrdinal(bytes, byteLen/2, name) == 0;
            }
        }

        // @TODO: Ideally, Read7BitEncodedInt on BinaryReader would be public.
        private static int Read7BitEncodedInt(BinaryReader br) {
            // Read out an int 7 bits at a time.  The high bit
            // of the byte when on means to continue reading more bytes.
            int count = 0;
            int shift = 0;
            byte b;
            do {
                b = br.ReadByte();
                count |= (b & 0x7F) << shift;
                shift += 7;
            } while ((b & 0x80) != 0);
            return count;
        }

        // This is used in the enumerator.  The enumerator iterates from 0 to n
        // of our resources and this returns the resource name for a particular
        // index.  The parameter is NOT a virtual offset.
        private unsafe String AllocateStringForNameIndex(int index)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            byte[] bytes;
            lock (this) {
                long nameVA = GetNamePosition(index);
                _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
                // Can't use _store.ReadString, since it's using UTF-8!
                int byteLen = Read7BitEncodedInt(_store);
                // @TODO: See if we can clean this up in another version.

#if WIN32
                // Note: this code won't work on 64 bit machines because the char*
                // may not be 2-byte aligned.
                if (_ums != null) {
                    if (_ums.Position > _ums.Length - byteLen)
                        throw new BadImageFormatException("Found a corrupted .resources file!  String for name index "+index+" extends past the end of the file!");
                    
                    char* charPtr = (char*)_ums.GetBytePtr();
                    return new String(charPtr, 0, byteLen/2);
                }
#endif
            /*
              // @TODO: Consider this perf optimization for V1.1. Here's a hint - 
              // it works & it saves some memory.  -- BrianGru, 7/17/2001
            // Speed up enumerations of loose files by caching a byte[].
            // Cache ~50 chars worth (100 bytes) to handle most resource names.
            byte[] bytes;
            if (byteLen <= CachedByteArrayLength) {
                if (_cachedByteArray == null)
                    _cachedByteArray = new byte[CachedByteArrayLength];
                bytes = _cachedByteArray;
            }
            else {
                bytes = new byte[byteLen];
            }
            int n = _store.Read(bytes, 0, byteLen);
            BCLDebug.Assert(n == byteLen, "Oops, I need to use a blocking read.");
            // This will call an appropriate String constructor for little 
            // endian data, not allocating a temp char[].
            return Encoding.Unicode.GetString(bytes, 0, byteLen);
            */
                bytes = new byte[byteLen];
                int n = _store.Read(bytes, 0, byteLen);
                BCLDebug.Assert(n == byteLen, "Oops, I need to use a blocking read.");
            }
            // Unfortunately in V1 since we couldn't do a perf optimization in
            // time, this will allocate & copy into a temp char[] then copy data
            // back into a String.  Yes, it's wasteful.  
            // Uncomment both overloads of UnicodeEncoding::GetString()
            return Encoding.Unicode.GetString(bytes);
        }

        // This is used in the enumerator.  The enumerator iterates from 0 to n
        // of our resources and this returns the resource value for a particular
        // index.  The parameter is NOT a virtual offset.
        private Object GetValueForNameIndex(int index)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            long nameVA = GetNamePosition(index);
            lock(this) {
                _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
                //int skip = _store.ReadInt32();
                //_store.BaseStream.Seek(skip, SeekOrigin.Current);
                int skip = Read7BitEncodedInt(_store);
                BCLDebug.Log("RESMGRFILEFORMAT", "GetValueForNameIndex for index: "+index+"  skip (name length): "+skip);
                _store.BaseStream.Seek(skip, SeekOrigin.Current);
                int dataPos = _store.ReadInt32();
                BCLDebug.Log("RESMGRFILEFORMAT", "GetValueForNameIndex: dataPos: "+dataPos);
                return LoadObject(dataPos);
            }
        }

        // This takes a virtual offset into the data section and reads a String
        // from that location.
        internal String LoadString(int pos)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            lock(this) {
                _store.BaseStream.Seek(_dataSectionOffset+pos, SeekOrigin.Begin);
                int type = Read7BitEncodedInt(_store);
                if (_typeTable[type] != typeof(String))
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceNotString_Type", _typeTable[type].GetType().FullName));
                String s = _store.ReadString();
                BCLDebug.Log("RESMGRFILEFORMAT", "LoadString("+pos.ToString("x")+" returned "+s);
                return s;
            }
        }
    
        // This takes a virtual offset into the data section and reads an Object
        // from that location.
        // Anyone who calls LoadObject should make sure they take a lock so 
        // no one can cause us to do a seek in here.
        internal Object LoadObject(int pos)
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            _store.BaseStream.Seek(_dataSectionOffset+pos, SeekOrigin.Begin);
            int typeIndex = Read7BitEncodedInt(_store);
            if (typeIndex == -1)
                return null;
            Type type = _typeTable[typeIndex];
            BCLDebug.Log("RESMGRFILEFORMAT", "LoadObject type: "+type.Name+"  pos: 0x"+_store.BaseStream.Position.ToString("x"));
            // @TODO: Consider putting in logic to see if this type is a 
            // primitive or a value type first, so we can reach the 
            // deserialization code faster for arbitrary objects.
            if (type == typeof(String))
                return _store.ReadString();
            else if (type == typeof(Int32))
                return _store.ReadInt32();
            else if (type == typeof(Byte))
                return _store.ReadByte();
            else if (type == typeof(SByte))
                return _store.ReadSByte();
            else if (type == typeof(Int16))
                return _store.ReadInt16();
            else if (type == typeof(Int64))
                return _store.ReadInt64();
            else if (type == typeof(UInt16))
                return _store.ReadUInt16();
            else if (type == typeof(UInt32))
                return _store.ReadUInt32();
            else if (type == typeof(UInt64))
                return _store.ReadUInt64();
            else if (type == typeof(Single))
                return _store.ReadSingle();
            else if (type == typeof(Double))
                return _store.ReadDouble();
            else if (type == typeof(DateTime))
                return new DateTime(_store.ReadInt64());
            else if (type == typeof(TimeSpan))
                return new TimeSpan(_store.ReadInt64());
            else if (type == typeof(Decimal)) {
                int[] bits = new int[4];
                for(int i=0; i<bits.Length; i++)
                    bits[i] = _store.ReadInt32();
                return new Decimal(bits);
            }
            else {
                // For a few Windows Forms types, we must be able to deserialize
                // these apps in semi-trusted scenarios so localization will 
                // work.  We've verified these types are safe.
                if (_safeToDeserialize[typeIndex])
                    new SecurityPermission(SecurityPermissionFlag.SerializationFormatter).Assert();
                
                Object graph = _objFormatter.Deserialize(_store.BaseStream);
                
                // Ensure that the object we deserialized is exactly the same
                // type of object we thought we should be deserializing.  This
                // will help prevent hacked .resources files from using our
                // serialization permission assert to deserialize anything
                // via a hacked type ID.   -- Brian Grunkemeyer, 12/12/2001
                if (graph.GetType() != _typeTable[typeIndex])
                    throw new BadImageFormatException(Environment.GetResourceString("BadImageFormat_ResType&SerBlobMismatch", _typeTable[typeIndex].FullName, graph.GetType().FullName));
                return graph;
            }
        }

        // Reads in the header information for a .resources file.  Verifies some
        // of the assumptions about this resource set, and builds the class table
        // for the default resource file format.
        private void ReadResources()
        {
            BCLDebug.Assert(_store != null, "ResourceReader is closed!");
            BinaryFormatter bf = new BinaryFormatter(null, new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence));
            // Do partial binds so we can be tolerant of version number changes.
            bf.AssemblyFormat = FormatterAssemblyStyle.Simple;
            _objFormatter = bf;

            try {
                // Read ResourceManager header
                // Check for magic number
                int magicNum = _store.ReadInt32();
                if (magicNum != ResourceManager.MagicNumber)
                    throw new ArgumentException(Environment.GetResourceString("Resources_StreamNotValid"));
                // Assuming this is ResourceManager header V1 or greater, hopefully
                // after the version number there is a number of bytes to skip
                // to bypass the rest of the ResMgr header.
                int resMgrHeaderVersion = _store.ReadInt32();
                if (resMgrHeaderVersion > 1) {
                    int numBytesToSkip = _store.ReadInt32();
                    BCLDebug.Log("RESMGRFILEFORMAT", LogLevel.Status, "ReadResources: Unexpected ResMgr header version: {0}  Skipping ahead {1} bytes.", resMgrHeaderVersion, numBytesToSkip);
                    BCLDebug.Assert(numBytesToSkip >= 0, "numBytesToSkip in ResMgr header should be positive!");
                    _store.BaseStream.Seek(numBytesToSkip, SeekOrigin.Current);
                }
                else {
                    BCLDebug.Log("RESMGRFILEFORMAT", "ReadResources: Parsing ResMgr header v1.");
                    _store.ReadInt32();  // We don't care about numBytesToSkip.

                    // Read in type name for a suitable ResourceReader
                    // Note ResourceWriter & InternalResGen use different Strings.
                    String readerType = _store.ReadString();
                    if (!readerType.Equals(ResourceManager.ResReaderTypeName) && 
                        !readerType.Equals(typeof(ResourceReader).FullName) &&
                        !readerType.Equals(ResourceManager.ResReaderTypeNameInternal)) {
                        throw new NotSupportedException("This .resources file shouldn't be used with this reader.  Your resource reader type: "+readerType);
                    }

                    // Skip over type name for a suitable ResourceSet
                    _store.ReadString();
                }

                // Read RuntimeResourceSet header
                // Do file version check
                int version = _store.ReadInt32();
                if (version != RuntimeResourceSet.Version)
                    throw new ArgumentException(String.Format("Version conflict with ResourceManager .resources files!  Expected version: {0} but got: {1}", RuntimeResourceSet.Version, version));
            
                _numResources = _store.ReadInt32();
                BCLDebug.Log("RESMGRFILEFORMAT", "ReadResources: Expecting "+ _numResources+ " resources.");
#if _DEBUG      
                if (ResourceManager.DEBUG >= 4)
                    Console.WriteLine("ResourceReader::ReadResources - Reading in "+_numResources+" resources");
#endif

                // Read type names into type array.
                int numTypes = _store.ReadInt32();
                _typeTable = new Type[numTypes];
                for(int i=0; i<numTypes; i++) {
                    String typeName = _store.ReadString();
                    // Do partial binds to be tolerant of version number changes.
                    _typeTable[i] = Assembly.LoadTypeWithPartialName(typeName, false);
                    if (_typeTable[i] == null)
                        throw new TypeLoadException(Environment.GetResourceString("TypeLoad_PartialBindFailed", typeName));
                }

                // Initialize deserialization permission array
                InitSafeToDeserializeArray();

#if _DEBUG
                if (ResourceManager.DEBUG >= 5)
                    Console.WriteLine("ResourceReader::ReadResources - Reading in "+numTypes+" type table entries");
#endif

                // Prepare to read in the array of name hashes
                //  Note that the name hashes array is aligned to 8 bytes so 
                //  we can use pointers into it on 64 bit machines. (4 bytes 
                //  may be sufficient, but let's plan for the future)
                //  Skip over alignment stuff, if it's present.
                long pos = _store.BaseStream.Position;
                int alignBytes = ((int)pos) & 7;
                bool fileIsAligned = true;
                if (alignBytes != 0) {
                    // For backwards compatibility, don't require the "PAD" stuff
                    // in here, but we should definitely skip it if present.
                    for(int i=0; i<8 - alignBytes; i++) {
                        byte b = _store.ReadByte();
                        if (b != "PAD"[i % 3]) {
                            fileIsAligned = false;
                            break;
                        }
                    }
                    // If we weren't aligned, we shouldn't have skipped this data!
                    if (!fileIsAligned)
                        _store.BaseStream.Position = pos;
                    else {
                        BCLDebug.Assert((_store.BaseStream.Position & 7) == 0, "ResourceReader: Stream should be aligned on an 8 byte boundary now!");
                    }
                }
#if RESOURCE_FILE_FORMAT_DEBUG
                Console.WriteLine("ResourceReader: File alignment: "+fileIsAligned);
#endif
#if !WIN32
                // If the file wasn't aligned, we can't use the _ums code on IA64.
                // However, this should only be a problem for .resources files
                // that weren't rebuilt after ~August 11, 2001 when I introduced
                // the alignment code.  We can rip this check in the next 
                // version.        -- Brian Grunkemeyer, 8/8/2001
                if (!fileIsAligned)
                    _ums = null;
#endif

                // Read in the array of name hashes
#if RESOURCE_FILE_FORMAT_DEBUG
                //  Skip over "HASHES->"
                _store.BaseStream.Position += 8;
#endif

                if (_ums == null) {
                    _nameHashes = new int[_numResources];
                    for(int i=0; i<_numResources; i++)
                        _nameHashes[i] = _store.ReadInt32();
                }
                else {
                    _nameHashesPtr = (int*) _ums.GetBytePtr();
                    // Skip over the array of nameHashes.
                    _ums.Seek(4 * _numResources, SeekOrigin.Current);
                }

                // Read in the array of relative positions for all the names.
#if RESOURCE_FILE_FORMAT_DEBUG
                // Skip over "POS---->"
                _store.BaseStream.Position += 8;
#endif
                if (_ums == null) {
                    _namePositions = new int[_numResources];
                    for(int i=0; i<_numResources; i++)
                        _namePositions[i] = _store.ReadInt32();
                }
                else {
                    _namePositionsPtr = (int*) _ums.GetBytePtr();
                    // Skip over the array of namePositions.
                    _ums.Seek(4 * _numResources, SeekOrigin.Current);
                }

                // Read location of data section.
                _dataSectionOffset = _store.ReadInt32();

                // Store current location as start of name section
                _nameSectionOffset = _store.BaseStream.Position;
                BCLDebug.Log("RESMGRFILEFORMAT", String.Format("ReadResources: _nameOffset = 0x{0:x}  _dataOffset = 0x{1:x}", _nameSectionOffset, _dataSectionOffset));
            }
            catch (EndOfStreamException eof) {
                throw new ArgumentException("Stream is not a valid .resources file!  It was possibly truncated.", eof);
            }
        }

        private void InitSafeToDeserializeArray()
        {
            _safeToDeserialize = new bool[_typeTable.Length];
            for(int i=0; i<_typeTable.Length; i++) {
                Type t = _typeTable[i];
                String versionFreeName = StripVersionField(t.AssemblyQualifiedName);
                foreach(String safeType in TypesSafeForDeserialization) {
                    if (safeType.Equals(versionFreeName)) {
#if _DEBUG
                        if (ResourceManager.DEBUG >= 7)
                            Console.WriteLine("ResReader: Found a type-safe type to deserialize!  Type name: "+t.AssemblyQualifiedName);
#endif
                        _safeToDeserialize[i] = true;
                        continue;
                    }
                }
#if _DEBUG
                if (ResourceManager.DEBUG >= 7)
                    if (!_safeToDeserialize[i])
                        Console.WriteLine("ResReader: Found a type that wasn't safe to deserialize: "+t.AssemblyQualifiedName);
#endif
            }
        }
    
        internal static String StripVersionField(String typeName)
        {
            // An assembly qualified type name will look like this:
            // System.String, mscorlib, Version=1.0.3102.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
            // We want to remove the "Version=..., " from the string.
            int index = typeName.IndexOf("Version=");
            if (index == -1)
                return typeName;
            int nextPiece = typeName.IndexOf(',', index+1);
            if (nextPiece == -1) {
                // Assume we can trim the rest of the String, and correct for the
                // leading ", " before Version=.
                index -= 2;
                return typeName.Substring(0, index);
            }
            // Skip the ", " after Version=...
            nextPiece += 2;
            return typeName.Remove(index, nextPiece - index);
        }

        internal class ResourceEnumerator : IDictionaryEnumerator
        {
            private const int ENUM_DONE = Int32.MinValue;
            private const int ENUM_NOT_STARTED = -1;

            private ResourceReader _reader;
            private bool _currentIsValid;
            private int _currentName;

            internal ResourceEnumerator(ResourceReader reader)
            {
                _currentName = ENUM_NOT_STARTED;
                _reader = reader;
            }

            public virtual bool MoveNext()
            {
                if (_currentName == _reader._numResources - 1 || _currentName == ENUM_DONE) {
                    _currentIsValid = false;
                    _currentName = ENUM_DONE;
                    return false;
                }
                _currentIsValid = true;
                _currentName++;
                return true;
            }
        
            public virtual Object Key {
                get {
                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    if (!_currentIsValid) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    if (_reader._table==null) throw new InvalidOperationException(Environment.GetResourceString("ResourceReaderIsClosed"));
                    return _reader.AllocateStringForNameIndex(_currentName);
                }
            }
        
            public virtual Object Current {
                get {
                    return Entry;
                }
            }

            public virtual DictionaryEntry Entry {
                get {
                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    if (!_currentIsValid) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    if (_reader._table==null) throw new InvalidOperationException(Environment.GetResourceString("ResourceReaderIsClosed"));

                    String key = _reader.AllocateStringForNameIndex(_currentName);
                    Object value = _reader._table[key];
                    if (value == null) {
                        value = _reader.GetValueForNameIndex(_currentName);
                        lock(_reader._table) {
                            Object v2 = _reader._table[key];
                            if (v2 == null) 
                                _reader._table[key] = value;
                            else
                                value = v2;
                        }
                    }
                    return new DictionaryEntry(key, value);
                }
            }
    
            public virtual Object Value {
                get {
                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    if (!_currentIsValid) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    if (_reader._table==null) throw new InvalidOperationException(Environment.GetResourceString("ResourceReaderIsClosed"));
                    return _reader.GetValueForNameIndex(_currentName);
                }
            }

            public void Reset()
            {
                if (_reader._table==null) throw new InvalidOperationException(Environment.GetResourceString("ResourceReaderIsClosed"));
                _currentIsValid = false;
                _currentName = ENUM_NOT_STARTED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\resourceset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ResourceSet
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Culture-specific collection of resources.
**
** Date:  March 26, 1999
** 
===========================================================*/
namespace System.Resources {
    using System;
    using System.Collections;
    using System.IO;
    using System.Runtime.Remoting.Activation;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;

    // A ResourceSet stores all the resources defined in one particular CultureInfo.
    // 
    // The method used to load resources is straightforward - this class
    // enumerates over an IResourceReader, loading every name and value, and 
    // stores them in a hash table.  Custom IResourceReaders can be used.
    // 
    /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet"]/*' />
    [Serializable()]
    public class ResourceSet : IDisposable, IEnumerable
    {
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.Reader"]/*' />
        protected IResourceReader Reader;
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.Table"]/*' />
        protected Hashtable Table;

        private Hashtable _caseInsensitiveTable;  // For case-insensitive lookups.
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.ResourceSet"]/*' />
        protected ResourceSet()
        {
            // To not inconvenience people subclassing us, we should allocate a new
            // hashtable here just so that Table is set to something.
            Table = new Hashtable();
        }
        
        // Creates a ResourceSet using the system default ResourceReader
        // implementation.  Use this constructor to open & read from a file 
        // on disk.
        // 
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.ResourceSet1"]/*' />
        public ResourceSet(String fileName)
        {
            Reader = new ResourceReader(fileName);
            Table = new Hashtable();
            ReadResources();
        }
    
        // Creates a ResourceSet using the system default ResourceReader
        // implementation.  Use this constructor to read from an open stream 
        // of data.
        // 
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.ResourceSet2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public ResourceSet(Stream stream)
        {
            Reader = new ResourceReader(stream);
            Table = new Hashtable();
            ReadResources();
        }
    

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.ResourceSet3"]/*' />
        public ResourceSet(IResourceReader reader)
        {
            if (reader == null)
                throw new ArgumentNullException("reader");
            Reader = reader;
            Table = new Hashtable();
            ReadResources();
        }
    
        // Closes and releases any resources used by this ResourceSet, if any.
        // All calls to methods on the ResourceSet after a call to close may 
        // fail.  Close is guaranteed to be safely callable multiple times on a 
        // particular ResourceSet, and all subclasses must support these semantics.
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.Close"]/*' />
        public virtual void Close()
        {
            Dispose(true);
        }
        
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (disposing) {
                // Close the Reader in a thread-safe way.
                IResourceReader copyOfReader = Reader;
                Reader = null;
                if (copyOfReader != null)
                    copyOfReader.Close();
            }
            Reader = null;
            _caseInsensitiveTable = null;
            Table = null;
        }

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.Dispose1"]/*' />
        public void Dispose()
        {
            Dispose(true);
        }

        // Returns the preferred IResourceReader class for this kind of ResourceSet.
        // Subclasses of ResourceSet using their own Readers &; should override
        // GetDefaultReader and GetDefaultWriter.
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetDefaultReader"]/*' />
        public virtual Type GetDefaultReader()
        {
            return typeof(ResourceReader);
        }
    
        // Returns the preferred IResourceWriter class for this kind of ResourceSet.
        // Subclasses of ResourceSet using their own Readers &; should override
        // GetDefaultReader and GetDefaultWriter.
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetDefaultWriter"]/*' />
        public virtual Type GetDefaultWriter()
        {
            return typeof(ResourceWriter);
        }

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetEnumerator"]/*' />
        [ComVisible(false)]
        public virtual IDictionaryEnumerator GetEnumerator()
        {
            return GetEnumeratorHelper();
        }

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumeratorHelper();
        }

        private IDictionaryEnumerator GetEnumeratorHelper()
        {
            Hashtable copyOfTable = Table;  // Avoid a race with Dispose
            if (copyOfTable == null)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_ClosedResourceTable"));
            return copyOfTable.GetEnumerator();
        }

        // Look up a string value for a resource given its name.
        // 
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetString"]/*' />
        public virtual String GetString(String name)
        {
            Hashtable copyOfTable = Table;  // Avoid a race with Dispose
            if (copyOfTable == null)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_ClosedResourceTable"));
            if (name==null)
                throw new ArgumentNullException("name");
    
            try {
                return (String) copyOfTable[name];
            }
            catch (InvalidCastException) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceNotString_Name", name));
            }
        }

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetString2"]/*' />
        public virtual String GetString(String name, bool ignoreCase)
        {
            Hashtable copyOfTable = Table;  // Avoid a race with Dispose
            if (copyOfTable == null)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_ClosedResourceTable"));
            if (name==null)
                throw new ArgumentNullException("name");

            String s;
            try {
                s = (String) copyOfTable[name];
            }
            catch (InvalidCastException) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceNotString_Name", name));
            }
            if (s != null || !ignoreCase)
                return s;

            // Try doing a case-insensitive lookup.
            Hashtable caseTable = _caseInsensitiveTable;  // Avoid race with Close
            if (caseTable == null) {
                caseTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
#if _DEBUG
                //Console.WriteLine("ResourceSet::GetString loading up data.  ignoreCase: "+ignoreCase);
                BCLDebug.Perf(!ignoreCase, "Using case-insensitive lookups is bad perf-wise.  Consider capitalizing "+name+" correctly in your source");
#endif
                IDictionaryEnumerator en = copyOfTable.GetEnumerator();
                while (en.MoveNext()) {
                    caseTable.Add(en.Key, en.Value);
                }
                _caseInsensitiveTable = caseTable;
            }
            try {
                return (String) caseTable[name];
            }
            catch (InvalidCastException) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceNotString_Name", name));
            }
        }
        
        // Look up an object value for a resource given its name.
        // 
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetObject"]/*' />
        public virtual Object GetObject(String name)
        {
            Hashtable copyOfTable = Table;  // Avoid a race with Dispose
            if (copyOfTable == null)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_ClosedResourceTable"));
            if (name==null)
                throw new ArgumentNullException("name");
            
            return copyOfTable[name];
        }

        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.GetObject2"]/*' />
        public virtual Object GetObject(String name, bool ignoreCase)
        {
            Hashtable copyOfTable = Table;  // Avoid a race with Dispose
            if (copyOfTable == null)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_ClosedResourceTable"));
            if (name==null)
                throw new ArgumentNullException("name");
            
            Object obj = copyOfTable[name];
            if (obj != null || !ignoreCase)
                return obj;

            // Try doing a case-insensitive lookup.
            Hashtable caseTable = _caseInsensitiveTable;  // Avoid race with Close
            if (caseTable == null) {
                caseTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
#if _DEBUG
                //Console.WriteLine("ResourceSet::GetObject loading up case-insensitive data");
                BCLDebug.Perf(!ignoreCase, "Using case-insensitive lookups is bad perf-wise.  Consider capitalizing "+name+" correctly in your source");
#endif
                IDictionaryEnumerator en = copyOfTable.GetEnumerator();
                while (en.MoveNext()) {
                    caseTable.Add(en.Key, en.Value);
                }
                _caseInsensitiveTable = caseTable;
            }

            return caseTable[name];
        }
    
        /// <include file='doc\ResourceSet.uex' path='docs/doc[@for="ResourceSet.ReadResources"]/*' />
        protected virtual void ReadResources()
        {
            IDictionaryEnumerator en = Reader.GetEnumerator();
            while (en.MoveNext()) {
                Table.Add(en.Key, en.Value);
            }
            // While technically possible to close the Reader here, don't close it
            // to help with some WinRes lifetime issues.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\accessedthroughpropertyattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
namespace System.Runtime.CompilerServices 
{
	using System;

	/// <include file='doc\AccessedThroughPropertyAttribute.uex' path='docs/doc[@for="AccessedThroughPropertyAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Field)]
	public sealed class AccessedThroughPropertyAttribute : Attribute
	{
		private readonly string propertyName;

		/// <include file='doc\AccessedThroughPropertyAttribute.uex' path='docs/doc[@for="AccessedThroughPropertyAttribute.AccessedThroughPropertyAttribute"]/*' />
		public AccessedThroughPropertyAttribute(string propertyName)
		{
			this.propertyName = propertyName;
		}

		/// <include file='doc\AccessedThroughPropertyAttribute.uex' path='docs/doc[@for="AccessedThroughPropertyAttribute.PropertyName"]/*' />
		public string PropertyName 
		{
			get 
			{
				return propertyName;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\resourcewriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ResourceWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Default way to write strings to a CLR resource 
** file.
**
** Date:  March 26, 1999  Rewritten February 13, 2001
** 
===========================================================*/
namespace System.Resources {
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Globalization;

    // Generates a binary .resources file in the system default format 
    // from name and value pairs.  Create one with a unique file name,
    // call AddResource() at least once, then call Generate() to write
    // the .resources file to disk, then call Close() to close the file.
    // 
    // The resources generally aren't written out in the same order 
    // they were added.
    // 
    // See the RuntimeResourceSet overview for details on the system 
    // default file format.
    // 
    /// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter"]/*' />
    public sealed class ResourceWriter : IResourceWriter
    {
        // An initial size for our internal sorted list, to avoid extra resizes.
        private const int _ExpectedNumberOfResources = 1000;
        private const int AverageNameSize = 20 * 2;  // chars in little endian Unicode
        private const int AverageValueSize = 40;

    	private SortedList _resourceList;  // Sorted using FastResourceComparer
        private Stream _output;
        private Hashtable _caseInsensitiveDups;  // To avoid names varying by case
    	
    	/// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.ResourceWriter"]/*' />
    	public ResourceWriter(String fileName)
    	{
    		if (fileName==null)
    			throw new ArgumentNullException("fileName");
            _output = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None);
    		_resourceList = new SortedList(FastResourceComparer.Default, _ExpectedNumberOfResources);
            _caseInsensitiveDups = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
    	}
    
        /// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.ResourceWriter1"]/*' />
        public ResourceWriter(Stream stream)
        {
            if (stream==null)
                throw new ArgumentNullException("stream");
            if (!stream.CanWrite)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotWritable"));
            _output = stream;
    		_resourceList = new SortedList(FastResourceComparer.Default, _ExpectedNumberOfResources);
            _caseInsensitiveDups = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
        }
    
    
    	// Adds a string resource to the list of resources to be written to a file.
    	// They aren't written until Generate() is called.
    	// 
    	/// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.AddResource"]/*' />
    	public void AddResource(String name, String value)
    	{
    		if (name==null)
    			throw new ArgumentNullException("name");
            if (_resourceList == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceWriterSaved"));

            // Check for duplicate resources whose names vary only by case.
            _caseInsensitiveDups.Add(name, null);
    		_resourceList.Add(name, value);
    	}
    	
    	// Adds a resource of type Object to the list of resources to be 
    	// written to a file.  They aren't written until Generate() is called.
    	// 
    	/// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.AddResource1"]/*' />
    	public void AddResource(String name, Object value)
    	{
    		if (name==null)
    			throw new ArgumentNullException("name");
            if (_resourceList == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceWriterSaved"));

            // Check for duplicate resources whose names vary only by case.
            _caseInsensitiveDups.Add(name, null);
    		_resourceList.Add(name, value);
    	}
    
    	// Adds a named byte array as a resource to the list of resources to 
    	// be written to a file. They aren't written until Generate() is called.
    	// 
    	/// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.AddResource2"]/*' />
    	public void AddResource(String name, byte[] value)
    	{
            if (name==null)
    			throw new ArgumentNullException("name");
            if (_resourceList == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceWriterSaved"));

            // Check for duplicate resources whose names vary only by case.
            _caseInsensitiveDups.Add(name, null);
    		_resourceList.Add(name, value);
    	}
    	
        // Closes the output stream.
        /// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.Close"]/*' />
        public void Close()
        {
            Dispose(true);
        }

        private void Dispose(bool disposing)
        {
            if (disposing) {
                if (_resourceList != null) {
                    Generate();
                }
                if (_output != null) {
                    _output.Close();
                }
            }
            _output = null;
            _caseInsensitiveDups = null;
            // _resourceList is set to null by Generate.
        }

        /// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.Dispose"]/*' />
        public void Dispose()
        {
            Dispose(true);
        }

    	// After calling AddResource, Generate() writes out all resources to the 
        // output stream in the system default format.
    	// If an exception occurs during object serialization or during IO,
    	// the .resources file is closed and deleted, since it is most likely
    	// invalid.
    	/// <include file='doc\ResourceWriter.uex' path='docs/doc[@for="ResourceWriter.Generate"]/*' />
    	public void Generate()
    	{
            if (_resourceList == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ResourceWriterSaved"));
            try {
                BinaryWriter bw = new BinaryWriter(_output, Encoding.UTF8);
                Type[] types = new Type[20];
                int numTypes = 0;
    			
                // Write out the ResourceManager header
                // Write out magic number
                bw.Write(ResourceManager.MagicNumber);
    			
                // Write out ResourceManager header version number
                bw.Write(ResourceManager.HeaderVersionNumber);

                MemoryStream resMgrHeaderBlob = new MemoryStream(240);
                BinaryWriter resMgrHeaderPart = new BinaryWriter(resMgrHeaderBlob);

                // Write out class name of IResourceReader capable of handling 
                // this file.  Don't include the version number of mscorlib,
                // since we'd have to ignore it when reading it in.
                resMgrHeaderPart.Write(ResourceManager.ResReaderTypeNameInternal);

                // Write out class name of the ResourceSet class best suited to
                // handling this file.
    			resMgrHeaderPart.Write(ResourceManager.ResSetTypeName);
                resMgrHeaderPart.Flush();

                // Write number of bytes to skip over to get past ResMgr header
                bw.Write((int)resMgrHeaderBlob.Length);

                // Write the rest of the ResMgr header
                bw.Write(resMgrHeaderBlob.GetBuffer(), 0, (int)resMgrHeaderBlob.Length);
                // End ResourceManager header


                // Write out the RuntimeResourceSet header
                // Version number
                bw.Write(RuntimeResourceSet.Version);
    			
    			// number of resources
    			bw.Write(_resourceList.Count);
    			
    			// Store values in temporary streams to write at end of file.
                int[] nameHashes = new int[_resourceList.Count];
                int[] namePositions = new int[_resourceList.Count];
                int curNameNumber = 0;
                MemoryStream nameSection = new MemoryStream(_resourceList.Count * AverageNameSize);
                BinaryWriter names = new BinaryWriter(nameSection, Encoding.Unicode);
    			MemoryStream dataSection = new MemoryStream(_resourceList.Count * AverageValueSize);
                BinaryWriter data = new BinaryWriter(dataSection, Encoding.UTF8);
    			IFormatter objFormatter = new BinaryFormatter(null, new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence));

#if RESOURCE_FILE_FORMAT_DEBUG
                // Write NAMES right before the names section.
                names.Write(new byte[] { (byte) 'N', (byte) 'A', (byte) 'M', (byte) 'E', (byte) 'S', (byte) '-', (byte) '-', (byte) '>'});

                // Write DATA at the end of the name table section.
                data.Write(new byte[] { (byte) 'D', (byte) 'A', (byte) 'T', (byte) 'A', (byte) '-', (byte) '-', (byte)'-', (byte)'>'});
#endif

    			IDictionaryEnumerator items = _resourceList.GetEnumerator();
    			// Write resource name and position to the file, and the value
    			// to our temporary buffer.  Save Type as well.
    			while (items.MoveNext()) {
                    nameHashes[curNameNumber] = FastResourceComparer.GetHashCode((String)items.Key);
                    namePositions[curNameNumber++] = (int) names.Seek(0, SeekOrigin.Current);
    				names.Write((String) items.Key); // key
    			    names.Write((int)data.Seek(0, SeekOrigin.Current)); // virtual offset of value.
#if RESOURCE_FILE_FORMAT_DEBUG
                    names.Write((byte) '*');
#endif
    				Object value = items.Value;
    				
    				// Find type table index.  If not there, add new element.
                    // We will use -1 as the type for null objects
                    Type typeOfValue = (value == null) ? null : value.GetType();
                    if (value != null) {
                        int i = 0;
                        for(; i<numTypes; i++) {
                            if (types[i] == typeOfValue) {
                                Write7BitEncodedInt(data, i);
                                break;
                            }
                        }
                        if (i==numTypes) {
                            if (numTypes == types.Length) {
                                Type[] newTypes = new Type[numTypes * 2];
                                Array.Copy(types, newTypes, numTypes);
                                types = newTypes;
                            }
                            types[numTypes] = typeOfValue;
                            Write7BitEncodedInt(data, numTypes++);
                        }
                    }
                    else {
                        // -1 is the type for null.
                        Write7BitEncodedInt(data, -1);
                    }
    				
    				// Write out value
    				WriteValue(typeOfValue, value, data, objFormatter);

#if RESOURCE_FILE_FORMAT_DEBUG
                    data.Write(new byte[] { (byte) 'S', (byte) 'T', (byte) 'O', (byte) 'P'});
#endif
    			}
    
    			// At this point, the ResourceManager header has been written.
    			// Finish RuntimeResourceSet header
    			//   Write size & contents of class table
    			bw.Write(numTypes);
    			for(int i=0; i<numTypes; i++)
    				bw.Write(types[i].AssemblyQualifiedName);

                // Write out the name-related items for lookup.
                //  Note that the hash array and the namePositions array must
                //  be sorted in parallel.
                Array.Sort(nameHashes, namePositions);

                //  Prepare to write sorted name hashes (alignment fixup)
                //   Note: For 64-bit machines, these MUST be aligned on 4 byte 
                //   boundaries!  Pointers on IA64 must be aligned!  And we'll
                //   run faster on X86 machines too.
                bw.Flush();
                int alignBytes = ((int)bw.BaseStream.Position) & 7;
                if (alignBytes > 0) {
                    for(int i=0; i<8 - alignBytes; i++)
                        bw.Write("PAD"[i % 3]);
                }

                //  Write out sorted name hashes.
                //   Align to 8 bytes.
                BCLDebug.Assert((bw.BaseStream.Position & 7) == 0, "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");
#if RESOURCE_FILE_FORMAT_DEBUG
                bw.Write(new byte[] { (byte) 'H', (byte) 'A', (byte) 'S', (byte) 'H', (byte) 'E', (byte) 'S', (byte) '-', (byte) '>'} );
#endif
                foreach(int hash in nameHashes)
                    bw.Write(hash);
#if RESOURCE_FILE_FORMAT_DEBUG
                Console.Write("Name hashes: ");
                foreach(int hash in nameHashes)
                    Console.Write(hash.ToString("x")+"  ");
                Console.WriteLine();
#endif

                //  Write relative positions of all the names in the file.
                //   Note: this data is 4 byte aligned, occuring immediately 
                //   after the 8 byte aligned name hashes (whose length may 
                //   potentially be odd).
                BCLDebug.Assert((bw.BaseStream.Position & 3) == 0, "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");
#if RESOURCE_FILE_FORMAT_DEBUG
                bw.Write(new byte[] { (byte) 'P', (byte) 'O', (byte) 'S', (byte) '-', (byte) '-', (byte) '-', (byte) '-', (byte) '>' } );
#endif
                foreach(int pos in namePositions)
                    bw.Write(pos);
#if RESOURCE_FILE_FORMAT_DEBUG
                Console.Write("Name positions: ");
                foreach(int pos in namePositions)
                    Console.Write(pos.ToString("x")+"  ");
                Console.WriteLine();
#endif

                // Flush all BinaryWriters to MemoryStreams.
                bw.Flush();
                names.Flush();
                data.Flush();

                // Write offset to data section
                int startOfDataSection = (int) (bw.Seek(0, SeekOrigin.Current) + nameSection.Length);
                startOfDataSection += 4;  // We're writing an int to store this data, adding more bytes to the header
                BCLDebug.Log("RESMGRFILEFORMAT", "Generate: start of DataSection: 0x"+startOfDataSection.ToString("x")+"  nameSection length: "+nameSection.Length);
                bw.Write(startOfDataSection);

                // Write name section.
                bw.Write(nameSection.GetBuffer(), 0, (int) nameSection.Length);
                names.Close();

    			// Write data section.
                BCLDebug.Assert(startOfDataSection == bw.Seek(0, SeekOrigin.Current), "ResourceWriter::Generate - start of data section is wrong!");
                bw.Write(dataSection.GetBuffer(), 0, (int) dataSection.Length);
                data.Close();
    			bw.Flush();
    #if DEBUG
    		   if (ResourceManager.DEBUG >= 1)
    			   Console.WriteLine("Wrote out "+(resources.Length)+" resources.");
    #endif
    		}
    		catch (Exception) {
                _output.Close();
    			throw;
    		}
            // Indicate we've called Generate
            _resourceList = null;
    	}
    	
    
    	// WriteValue takes a value and writes it to stream.  It 
    	// can take some specific action based on the type, such as write out a compact
    	// version of the object if it's a type recognized by this ResourceWriter, or 
    	// use Serialization to write out the object using the objFormatter.
    	// For instance, the default implementation recognizes primitives such as Int32
    	// as special types and calls WriteInt32(int) with the value of the object.  This
    	// can be much more compact than serializing the same object.
    	// 
    	private void WriteValue(Type type, Object value, BinaryWriter writer, IFormatter objFormatter)
    	{
    		// For efficiency reasons, most of our primitive types will be explicitly
    		// recognized here.  Some value classes are also special cased here.
    		if (type == typeof(String))
    			writer.Write((String) value);
    		else if (type == typeof(Int32))
    			writer.Write((int)value);
    		else if (type == typeof(Byte))
    			writer.Write((byte)value);
    		else if (type == typeof(SByte))
    			writer.Write((sbyte)value);
    		else if (type == typeof(Int16))
    			writer.Write((short)value);
    		else if (type == typeof(Int64))
    			writer.Write((long)value);
    		else if (type == typeof(UInt16))
    			writer.Write((ushort)value);
    		else if (type == typeof(UInt32))
    			writer.Write((uint)value);
    		else if (type == typeof(UInt64))
    			writer.Write((ulong)value);
    		else if (type == typeof(Single))
    			writer.Write((float)value);
    		else if (type == typeof(Double))
    			writer.Write((double)value);
    		else if (type == typeof(DateTime))
    			writer.Write(((DateTime)value).Ticks);
    		else if (type == typeof(TimeSpan))
    			writer.Write(((TimeSpan)value).Ticks);
    		else if (type == typeof(Decimal)) {
    			int[] bits = Decimal.GetBits((Decimal)value);
                BCLDebug.Assert(bits.Length == 4, "ResourceReader::LoadObject assumes Decimal's GetBits method returns an array of 4 ints");
    			for(int i=0; i<bits.Length; i++)
    				writer.Write(bits[i]);
    		}
    		else if (type == null) {
                BCLDebug.Assert(value == null, "Type is null iff value is null");
#if RESOURCE_FILE_FORMAT_DEBUG
                write.WriteString("<null value>");
#endif
            }
            else
    			objFormatter.Serialize(writer.BaseStream, value);
    	}

        // @TODO: Ideally (maybe V2), Write7BitEncodedInt on BinaryWriter will
        // become public.
        private static void Write7BitEncodedInt(BinaryWriter store, int value) {
            // Write out an int 7 bits at a time.  The high bit of the byte,
            // when on, tells reader to continue reading more bytes.
            uint v = (uint) value;   // support negative numbers
            while (v >= 0x80) {
                store.Write((byte) (v | 0x80));
                v >>= 7;
            }
            store.Write((byte)v);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\callingconvention.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.CompilerServices 
{
    // Types used in Custom Modifier to specify calling conventions.
	/// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallConvCdecl"]/*' />
	public class CallConvCdecl
	{
	}
	
	/// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallConvStdcall"]/*' />
	public class CallConvStdcall
	{
	}
	
    /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallConvThiscall"]/*' />
    public class CallConvThiscall
	{
	}
	
	/// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallConvFastcall"]/*' />
	public class CallConvFastcall
	{
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\assemblyattributesgohere.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.CompilerServices {

    using System;

    // NOTE TO DEVELOPERS:  These classes are used by ALink (the assembly linker).
    // They're used for metadata tokens for making multi-module assemblies.
    // Do not randomly dink with these classes.  Talk to a metadata person
    // or Grant Richins (C# & ALink dev).

    /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHere"]/*' />
    internal sealed class AssemblyAttributesGoHere
    {
        /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHere.AssemblyAttributesGoHere"]/*' />
        internal AssemblyAttributesGoHere()
        {
        }
    }

    /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereS"]/*' />
    internal sealed class AssemblyAttributesGoHereS
    {
        /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereS.AssemblyAttributesGoHereS"]/*' />
        internal AssemblyAttributesGoHereS()
        {
        }
    }

    /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereM"]/*' />
    internal sealed class AssemblyAttributesGoHereM
    {
        /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereM.AssemblyAttributesGoHereM"]/*' />
        internal AssemblyAttributesGoHereM()
        {
        }
    }

    /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereSM"]/*' />
    internal sealed class AssemblyAttributesGoHereSM
    {
        /// <include file='doc\AssemblyAttributesGoHere.uex' path='docs/doc[@for="AssemblyAttributesGoHereSM.AssemblyAttributesGoHereSM"]/*' />
        internal AssemblyAttributesGoHereSM()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\compilerglobalscopeattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  CompilerGlobalScopeAttribute
**
** Author: mikemag
**
** Purpose: Attribute used to communicate to the VS7 debugger
**          that a class should be treated as if it has
**          global scope.
**
** Date:  Aug 09, 2000
** 
===========================================================*/
    

namespace System.Runtime.CompilerServices
{
    /// <include file='doc\CompilerGlobalScopeAttribute.uex' path='docs/doc[@for="CompilerGlobalScopeAttribute"]/*' />
	[Serializable, AttributeUsage(AttributeTargets.Class)]
    public class CompilerGlobalScopeAttribute : Attribute
	{
	   /// <include file='doc\CompilerGlobalScopeAttribute.uex' path='docs/doc[@for="CompilerGlobalScopeAttribute.CompilerGlobalScopeAttribute"]/*' />
	   public CompilerGlobalScopeAttribute () {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\compilationrelaxations.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace System.Runtime.CompilerServices 
{

	using System;

	/// <include file='doc\CompilationRelaxations.uex' path='docs/doc[@for="CompilationRelaxations"]/*' />
	[Serializable]
	enum CompilationRelaxations 
	{ 
		ImpreciseException 		= 0x0001, 
		ImpreciseFloat 			= 0x0002, 
		ImpreciseAssign 		= 0x0004 
	};
		
	/// <include file='doc\CompilationRelaxations.uex' path='docs/doc[@for="CompilationRelaxationsAttribute"]/*' />
	[Serializable, AttributeUsage(AttributeTargets.Module)]  
	public class CompilationRelaxationsAttribute : Attribute 
	{
		private int m_relaxations;		// The relaxations.
		
		/// <include file='doc\CompilationRelaxations.uex' path='docs/doc[@for="CompilationRelaxationsAttribute.CompilationRelaxationsAttribute"]/*' />
		public CompilationRelaxationsAttribute (
			int relaxations) 
		{ 
			m_relaxations = relaxations; 
		}
		
		/// <include file='doc\CompilationRelaxations.uex' path='docs/doc[@for="CompilationRelaxationsAttribute.CompilationRelaxations"]/*' />
		public int CompilationRelaxations
		{ 
			get 
			{ 
				return m_relaxations; 
			} 
		}
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resources\resourcemanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ResourceManager
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Default way to access String resources from 
** an assembly.
**
** Date:  March 26, 1999
** 
===========================================================*/
namespace System.Resources {    
    using System;
    using System.IO;
    using System.Globalization;
    using System.Collections;
    using System.Text;
    using System.Reflection;
    using System.Runtime.Remoting.Activation;
    using System.Security.Permissions;
    using System.Threading;

    // Resource Manager exposes an assembly's resources to an application for
    // the correct CultureInfo.  An example would be localizing text for a 
    // user-visible message.  Create a set of resource files listing a name 
    // for a message and its value, compile them using ResGen, put them in
    // an appropriate place (your assembly manifest(?)), then create a Resource 
    // Manager and query for the name of the message you want.  The Resource
    // Manager will use CultureInfo.CurrentUICulture to look
    // up a resource for your user's locale settings.
    // 
    // Users should ideally create a resource file for every culture, or
    // at least a meaningful subset.  The filenames will follow the naming 
    // scheme:
    // 
    // basename.culture name.resources
    // 
    // The base name can be the name of your application, or depending on 
    // the granularity desired, possibly the name of each class.  The culture 
    // name is determined from CultureInfo's Name property.  
    // An example file name may be MyApp.en-us.resources for
    // MyApp's US English resources.
    // 
    /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager"]/*' />
    [Serializable]
    public class ResourceManager
    {
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.BaseNameField"]/*' />
        protected String BaseNameField;
        // Sets is a many-to-one table of CultureInfos mapped to ResourceSets.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceSets"]/*' />
        // Don't synchronize ResourceSets - too fine-grained a lock to be effective
        protected Hashtable ResourceSets;
        private String moduleDir;      // For assembly-ignorant directory location
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.MainAssembly"]/*' />
        protected Assembly MainAssembly;   // Need the assembly manifest sometimes.
        private Type _locationInfo;    // For Assembly or type-based directory layout
        private Type _userResourceSet;  // Which ResourceSet instance to create
        private CultureInfo _neutralResourcesCulture;  // For perf optimizations.

        private bool _ignoreCase;   // Whether case matters in GetString & GetObject
        // @TODO: When we create a separate FileBasedResourceManager subclass,
        // UseManifest can be replaced with "false".
        private bool UseManifest;  // Use Assembly manifest, or grovel disk.

        // @TODO: When we create a separate FileBasedResourceManager subclass,
        // UseSatelliteAssem can be replaced with "true".
        private bool UseSatelliteAssem;  // Are all the .resources files in the 
                  // main assembly, or in satellite assemblies for each culture?
        private Assembly _callingAssembly;  // Assembly who created the ResMgr.

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.MagicNumber"]/*' />
        public static readonly int MagicNumber = unchecked((int)0xBEEFCACE);  // If only hex had a K...

        // Version number so ResMgr can get the ideal set of classes for you.
        // ResMgr header is:
        // 1) MagicNumber (little endian Int32)
        // 2) HeaderVersionNumber (little endian Int32)
        // 3) Num Bytes to skip past ResMgr header (little endian Int32)
        // 4) IResourceReader type name for this file (bytelength-prefixed UTF-8 String)
        // 5) ResourceSet type name for this file (bytelength-prefixed UTF8 String)
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.HeaderVersionNumber"]/*' />
        public static readonly int HeaderVersionNumber = 1;

        //
        //@Consider[BrianGru/JRoxe]: It would be better if we could use _neutralCulture instead of calling
        //CultureInfo.InvariantCulture everywhere, but we run into problems with the .cctor.  CultureInfo 
        //initializes assembly, which initializes ResourceManager, which tries to get a CultureInfo which isn't
        //there yet because CultureInfo's class initializer hasn't finished.  If we move SystemResMgr off of
        //Assembly (or at least make it an internal property) we should be able to circumvent this problem.
        //
        //      private static CultureInfo _neutralCulture = null;

        // This is our min required ResourceSet type.
        private static readonly Type _minResourceSet = typeof(ResourceSet);
        // These Strings are used to avoid using Reflection in CreateResourceSet.
        // The first set are used by ResourceWriter.  The second are used by
        // InternalResGen.
        internal static readonly String ResReaderTypeName = typeof(ResourceReader).AssemblyQualifiedName;
        internal static readonly String ResSetTypeName = typeof(RuntimeResourceSet).AssemblyQualifiedName;
        internal const String ResReaderTypeNameInternal = "System.Resources.ResourceReader, mscorlib";
        internal const String ResSetTypeNameInternal = "System.Resources.RuntimeResourceSet, mscorlib";
        internal const String ResFileExtension = ".resources";
        internal const int ResFileExtensionLength = 10;

        // My private debugging aid.  Set to 5 or 6 for verbose output.  Set to 3
        // for summary level information.
        internal static readonly int DEBUG = 0; //Making this const causes C# to consider all of the code that it guards unreachable.
    
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceManager"]/*' />
        protected ResourceManager() {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            _callingAssembly = Assembly.nGetExecutingAssembly(ref stackMark);
        }

        // Constructs a Resource Manager for files beginning with 
        // baseName in the directory specified by resourceDir
        // or in the current directory.  This Assembly-ignorant constructor is 
        // mostly useful for testing your own ResourceSet implementation.
        //
        // A good example of a baseName might be "Strings".  BaseName 
        // should not end in ".resources".
        //
        // Note: WFC uses this method at design time.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceManager1"]/*' />
        private ResourceManager(String baseName, String resourceDir, Type usingResourceSet) {

            //
            // @TODO: In V2, rip out all the file-based functionality into a 
            // (potentially internal) subclass of ResourceManager.  This will simplify
            // InternalGetResourceSet a lot.  We can also make several fields like UseManifest
            // private.  We'd do this work in V1, but there's a concern about lack 
            // of testing.
            //


            if (null==baseName)
                throw new ArgumentNullException("baseName");
            if (null==resourceDir)
                throw new ArgumentNullException("resourceDir");

            BaseNameField = baseName;

            moduleDir = resourceDir;
            if ((ResFileExtensionLength < baseName.Length) &&
                (0==String.Compare(baseName, baseName.Length-ResFileExtensionLength, ResFileExtension, 0, ResFileExtensionLength, true, CultureInfo.InvariantCulture)) &&
                (Object.ReferenceEquals(null, FindResourceFile(CultureInfo.InvariantCulture))))
                throw new ArgumentException(Environment.GetResourceString("Arg_ResMgrBaseName"));
            _userResourceSet = usingResourceSet;
            ResourceSets = new Hashtable();
            UseManifest = false;

#if _DEBUG
            if (DEBUG >= 3) {
            // Detect missing neutral locale resources.
            CultureInfo culture = CultureInfo.InvariantCulture;
            String defaultResPath = FindResourceFile(culture);
            if (defaultResPath==null || !File.Exists(defaultResPath)) {
                String defaultResName = GetResourceFileName(culture);
                String dir = moduleDir;
                if (defaultResPath!=null)
                    dir = Path.GetDirectoryName(defaultResPath);
                    Console.WriteLine("While constructing a ResourceManager, your application's neutral " + ResFileExtension + " file couldn't be found.  Expected to find a " + ResFileExtension + " file called \""+defaultResName+"\" in the directory \""+dir+"\".  However, this is optional, and if you're extremely careful, you can ignore this.");
            }
            else
                    Console.WriteLine("ResourceManager found default culture's " +  ResFileExtension + " file, "+defaultResPath);
            }
#endif
        }
    

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceManager2"]/*' />
        public ResourceManager(String baseName, Assembly assembly)
        {
            if (null==baseName)
                throw new ArgumentNullException("baseName");
            if (null==assembly)
                throw new ArgumentNullException("assembly");
    
            MainAssembly = assembly;
            _locationInfo = null;
            BaseNameField = baseName;

            CommonSatelliteAssemblyInit();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            _callingAssembly = Assembly.nGetExecutingAssembly(ref stackMark);
            // Special case for mscorlib - protect mscorlib's private resources.
            if (assembly == typeof(Object).Assembly && _callingAssembly != assembly)
                _callingAssembly = null;
        }

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceManager3"]/*' />
        public ResourceManager(String baseName, Assembly assembly, Type usingResourceSet)
        {
            if (null==baseName)
                throw new ArgumentNullException("baseName");
            if (null==assembly)
                throw new ArgumentNullException("assembly");
    
            MainAssembly = assembly;
            _locationInfo = null;
            BaseNameField = baseName;
    
            if (usingResourceSet != null && (usingResourceSet != _minResourceSet) && !(usingResourceSet.IsSubclassOf(_minResourceSet)))
                throw new ArgumentException(Environment.GetResourceString("Arg_ResMgrNotResSet"), "usingResourceSet");
            _userResourceSet = usingResourceSet;
            
            CommonSatelliteAssemblyInit();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            _callingAssembly = Assembly.nGetExecutingAssembly(ref stackMark);
            // Special case for mscorlib - protect mscorlib's private resources.
            if (assembly == typeof(Object).Assembly && _callingAssembly != assembly)
                _callingAssembly = null;
        }

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceManager4"]/*' />
        public ResourceManager(Type resourceSource)
        {
            if (null==resourceSource)
                throw new ArgumentNullException("resourceSource");
    
            _locationInfo = resourceSource;
            MainAssembly = _locationInfo.Assembly;
            BaseNameField = resourceSource.Name;
            
            CommonSatelliteAssemblyInit();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            _callingAssembly = Assembly.nGetExecutingAssembly(ref stackMark);
            // Special case for mscorlib - protect mscorlib's private resources.
            if (MainAssembly == typeof(Object).Assembly && _callingAssembly != MainAssembly)
                _callingAssembly = null;
        }

        // Trying to unify code as much as possible, even though having to do a
        // security check in each constructor prevents it.
        private void CommonSatelliteAssemblyInit()
        {
            UseManifest = true;
            UseSatelliteAssem = true;
            if ((ResFileExtensionLength < BaseNameField.Length) &&
                (0==String.Compare(BaseNameField, BaseNameField.Length-ResFileExtensionLength, ResFileExtension, 0, ResFileExtensionLength, true, CultureInfo.InvariantCulture)) &&
                (null==CaseInsensitiveManifestResourceStreamLookup(MainAssembly, BaseNameField + ResFileExtension)))
                throw new ArgumentException(Environment.GetResourceString("Arg_ResMgrBaseName"));
    
            ResourceSets = new Hashtable();

#if _DEBUG
            if (DEBUG >= 3) {
                // Detect missing neutral locale resources.
                String defaultResName = GetResourceFileName(CultureInfo.InvariantCulture);
                String outputResName = defaultResName;
                if (_locationInfo != null)
                    outputResName = _locationInfo.Namespace + Type.Delimiter + defaultResName;
                if (!MainAssemblyContainsResourceBlob(defaultResName)) {
                    Console.WriteLine("Your main assembly really should contain the neutral culture's resources.  Expected to find a resource blob in your assembly manifest called \""+outputResName+"\".  Check capitalization in your assembly manifest.  If you're extremely careful though, this is only optional, not a requirement.");
                }
                else {
                    Console.WriteLine("ResourceManager found default culture's " + ResFileExtension + " file, "+defaultResName);
                }
            }
#endif
        }

        // Gets the base name for the ResourceManager.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.BaseName"]/*' />
        public virtual String BaseName {
            get { return BaseNameField; }
        }
    
        // Whether we should ignore the capitalization of resources when calling
        // GetString or GetObject.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.IgnoreCase"]/*' />
        public virtual bool IgnoreCase {
            get { return _ignoreCase; }
            set { _ignoreCase = value; }
        }

        // Returns the Type of the ResourceSet the ResourceManager uses
        // to construct ResourceSets.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ResourceSetType"]/*' />
        public virtual Type ResourceSetType {
            get { return (_userResourceSet == null) ? typeof(RuntimeResourceSet) : _userResourceSet; }
        }
                               
        // Tells the ResourceManager to call Close on all ResourceSets and 
        // release all resources.  This will shrink your working set by
        // potentially a substantial amount in a running application.  Any
        // future resource lookups on this ResourceManager will be as 
        // expensive as the very first lookup, since it will need to search
        // for files and load resources again.
        // 
        // This may be useful in some complex threading scenarios, where 
        // creating a new ResourceManager isn't quite the correct behavior.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.ReleaseAllResources"]/*' />
        public virtual void ReleaseAllResources()
        {
            // Prevent ReleaseAllResources from closing the ResourceSet used in 
            // GetString and GetObject in a multi-threaded environment.
            lock(this) {
#if _DEBUG
                if (DEBUG >= 1)
                    Console.WriteLine("Calling ResourceManager::ReleaseAllResources");
#endif
                IDictionaryEnumerator setEnum = ResourceSets.GetEnumerator();
                while (setEnum.MoveNext())
                    ((ResourceSet)setEnum.Value).Close();
                ResourceSets = new Hashtable();
            }
        }

        // Returns whether or not the main assembly contains a particular resource
        // blob in it's assembly manifest.  Used to verify that the neutral 
        // Culture's .resources file is present in the main assembly
        private bool MainAssemblyContainsResourceBlob(String defaultResName)
        {
            String resName = defaultResName;
            if (_locationInfo != null)
                resName = _locationInfo.Namespace + Type.Delimiter + defaultResName;
            String[] blobs = MainAssembly.GetManifestResourceNames();
            foreach(String s in blobs)
                if (s.Equals(resName))
                    return true;
            return false;
        }

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.CreateFileBasedResourceManager"]/*' />
        public static ResourceManager CreateFileBasedResourceManager(String baseName, String resourceDir, Type usingResourceSet)
        {
            return new ResourceManager(baseName, resourceDir, usingResourceSet);
        }

        // Given a CultureInfo, it generates the path &; file name for 
        // the .resources file for that CultureInfo.  This method will grovel
        // the disk looking for the correct file name & path.  Uses CultureInfo's
        // Name property.  If the module directory was set in the ResourceManager 
        // constructor, we'll look there first.  If it couldn't be found in the module
        // diretory or the module dir wasn't provided, look in the current
        // directory.
        private String FindResourceFile(CultureInfo culture) {

            // In V2, when we create a __FileBasedResourceManager, move this method
            // to that class.  This is part of the assembly-ignorant implementation
            // that really doesn't belong on ResourceManager.

            String fileName = GetResourceFileName(culture);
    
            // If we have a moduleDir, check there first.  Get module fully 
            // qualified name, append path to that.
            if (moduleDir != null) {
    #if _DEBUG
                if (DEBUG >= 3)
                    Console.WriteLine("FindResourceFile: checking module dir: \""+moduleDir+'\"');
    #endif
                
                String path = Path.Combine(moduleDir, fileName);
                if (File.Exists(path)) {
    #if _DEBUG
                    if (DEBUG >= 3)
                        Console.WriteLine("Found resource file in module dir!  "+path);
    #endif
                    return path;
                }
            }
    
    #if _DEBUG
            if (DEBUG >= 3)
                Console.WriteLine("Couldn't find resource file in module dir, checking .\\"+fileName);
    #endif
    
            // look in .
            if (File.Exists(fileName))
                return fileName;
    
            return null;  // give up.
        }
    
        // Given a CultureInfo, GetResourceFileName generates the name for 
        // the binary file for the given CultureInfo.  This method uses 
        // CultureInfo's Name property as part of the file name for all cultures
        // other than the invariant culture.  This method does not touch the disk, 
        // and is used only to construct what a resource file name (suitable for
        // passing to the ResourceReader constructor) or a manifest resource blob
        // name should look like.
        // 
        // This method can be overriden to look for a different extension,
        // such as ".ResX", or a completely different format for naming files.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetResourceFileName"]/*' />
        protected virtual String GetResourceFileName(CultureInfo culture) {
            StringBuilder sb = new StringBuilder(255);
            sb.Append(BaseNameField);
            // If this is the neutral culture, don't append culture name.
            if (!culture.Equals(CultureInfo.InvariantCulture)) {  
                CultureInfo.VerifyCultureName(culture, true);
                sb.Append('.');
                sb.Append(culture.Name);
            }
            sb.Append(ResFileExtension);
            return sb.ToString();
        }
        
        // Looks up a set of resources for a particular CultureInfo.  This is
        // not useful for most users of the ResourceManager - call 
        // GetString() or GetObject() instead.  
        //
        // The parameters let you control whether the ResourceSet is created 
        // if it hasn't yet been loaded and if parent CultureInfos should be 
        // loaded as well for resource inheritance.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetResourceSet"]/*' />
        public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents) {
            if (null==culture)
                throw new ArgumentNullException("culture");

            // Do NOT touch the ResourceSets hashtable outside of the lock.  We
            // want to prevent having ReleaseAllResources close a ResourceSet that
            // we've just decided to return.

            lock(this) {
                return InternalGetResourceSet(culture, createIfNotExists, tryParents);
            }
        }

        // InternalGetResourceSet is a non-threadsafe method where all the logic
        // for getting a resource set lives.  Access to it is controlled by
        // threadsafe methods such as GetResourceSet, GetString, & GetObject.  
        // This will take a minimal number of locks.
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.InternalGetResourceSet"]/*' />
        protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents) {
            BCLDebug.Assert(culture != null, "culture != null");
    
#if _DEBUG
            if (DEBUG >= 3)
                Console.WriteLine("GetResourceSet("+culture.Name+" ["+culture.LCID+"], "+createIfNotExists+", "+tryParents+")");
#endif

            ResourceSet rs = (ResourceSet) ResourceSets[culture];       
            if (null!=rs)
                return rs;
    
            // InternalGetResourceSet will never be threadsafe.  However, it must
            // be protected against reentrancy from the SAME THREAD.  (ie, calling
            // GetSatelliteAssembly may send some window messages or trigger the
            // Assembly load event, which could fail then call back into the 
            // ResourceManager).  It's happened.
    
            Stream stream = null;
            String fileName = null;
            if (UseManifest) {
                fileName = GetResourceFileName(culture);
                // Ask assembly for resource stream named fileName.
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                Assembly satellite = null;
                if (UseSatelliteAssem) {
                    CultureInfo lookForCulture = culture;
                    if (_neutralResourcesCulture == null)
                        _neutralResourcesCulture = GetNeutralResourcesLanguage(MainAssembly);
                    // If our neutral resources were written in this culture,
                    // don't bother looking for a satellite assembly for it.
                    if (culture.Equals(_neutralResourcesCulture)) {
#if _DEBUG
                        if (DEBUG >= 4)
                            Console.WriteLine("ResMgr::InternalGetResourceSet - Your neutral resources are sufficient for this culture.  Skipping satellites & using neutral resources for: "+culture.Name);
#endif
                        // Update internal state.
                        lookForCulture = CultureInfo.InvariantCulture;
                        fileName = GetResourceFileName(lookForCulture);
                    }

                    // For neutral locale, look in the main assembly.
                    if (lookForCulture.Equals(CultureInfo.InvariantCulture))
                        satellite = MainAssembly;
                    else {
                        Version ver = GetSatelliteContractVersion(MainAssembly);
#if _DEBUG
                        if (DEBUG >= 5)
                            Console.WriteLine("ResMgr::GetResourceSet - calling GetSatAssem for culture: "+lookForCulture.Name+"  lcid: "+lookForCulture.LCID+"  version: "+ver);
#endif
                        // Look up the satellite assembly, but don't let problems
                        // like a partially signed satellite assembly stop us from
                        // doing fallback and displaying something to the user.
                        // Yet also somehow log this error for a developer.
                        try {
                            satellite = MainAssembly.InternalGetSatelliteAssembly(lookForCulture, ver, false);
                        }
                        catch (ThreadAbortException) {
                            // We don't want to care about these.
                            throw;
                        }
                        catch (Exception e) {
                            BCLDebug.Assert(false, "[This is an ignorable assert to catch satellite assembly build problems]"+Environment.NewLine+"GetSatelliteAssembly failed for culture "+lookForCulture.Name+" and version "+(ver==null ? MainAssembly.GetVersion().ToString() : ver.ToString())+" of assembly "+MainAssembly.nGetSimpleName()+"\r\nException: "+e);
                            // @TODO: Print something out to the event log?
                            satellite = null;
                        }

                        // Handle case in here where someone added a callback
                        // for assembly load events.  While no other threads
                        // have called into GetResourceSet, our own thread can!
                        // At that point, we could already have an RS in our 
                        // hash table, and we don't want to add it twice.
                        rs = (ResourceSet) ResourceSets[lookForCulture];       
                        if (null!=rs) {
#if _DEBUG
                            if (DEBUG >= 1)
                                Console.WriteLine("ResMgr::GetResourceSet - After loading a satellite assembly, we already have the resource set for culture \""+lookForCulture.Name+"\" ["+lookForCulture.LCID+"].  You must have had an assembly load callback that called into this instance of the ResourceManager!  Eeew.");
#endif
                            return rs;
                        }
                    }
                    // Look for a possibly-NameSpace-qualified resource file, ie,
                    // Microsoft.WFC.myApp.en-us.resources.
                    // (A null _locationInfo is legal)
                    if (satellite != null) {
                        // If we're looking in the main assembly AND if the main
                        // assembly was the person who created the ResourceManager,
                        // skip a security check for private manifest resources.
                        bool canSkipSecurityCheck = MainAssembly == satellite && _callingAssembly == MainAssembly;
                        stream = satellite.GetManifestResourceStream(_locationInfo, fileName, canSkipSecurityCheck, ref stackMark);
                        if (stream == null)
                            stream = CaseInsensitiveManifestResourceStreamLookup(satellite, fileName);
                    }

#if _DEBUG
                    if (DEBUG >= 3)
                        Console.WriteLine("ResMgr manifest resource lookup in satellite assembly for culture "+(lookForCulture.Equals(CultureInfo.InvariantCulture) ? "[neutral]" : lookForCulture.Name)+(stream==null ? " failed." : " succeeded.")+"  assembly name: "+(satellite==null ? "<null>" : satellite.nGetSimpleName()+"  assembly culture: "+satellite.GetLocale().Name+" ["+satellite.GetLocale().LCID+"]"));
#endif
                }
                else
                    stream = MainAssembly.GetManifestResourceStream(_locationInfo, fileName, _callingAssembly == MainAssembly, ref stackMark);
                
                if (stream==null && tryParents) {
                    // If we've hit top of the Culture tree, return.
                    if (culture.Equals(CultureInfo.InvariantCulture)) {
                        // Keep people from bothering me about resources problems
                        if (MainAssembly == typeof(Object).Assembly) {
                            // This would break CultureInfo & all our exceptions.
                            BCLDebug.Assert(false, "Couldn't get mscorlib" + ResFileExtension + " from mscorlib's assembly" + Environment.NewLine + Environment.NewLine + "Are you building the runtime on your machine?  Chances are the BCL directory didn't build correctly.  Type 'build -c' in the BCL directory.  If you get build errors, look at buildd.log.  If you then can't figure out what's wrong (and you aren't changing the assembly-related metadata code), ask a BCL dev.\n\nIf you did NOT build the runtime, you shouldn't be seeing this and you've found a bug.");
                            throw new ExecutionEngineException("mscorlib" + ResFileExtension + " couldn't be found!  Large parts of the BCL won't work!");
                        }
                        // We really don't think this should happen - we always
                        // expect the neutral locale's resources to be present.
                        throw new MissingManifestResourceException(Environment.GetResourceString("MissingManifestResource_NoNeutralAsm", fileName, MainAssembly.nGetSimpleName()) + Environment.NewLine + "baseName: "+BaseNameField+"  locationInfo: "+(_locationInfo==null ? "<null>" : _locationInfo.FullName)+"  resource file name: "+fileName+"  assembly: "+MainAssembly.FullName);
                    }
                    
                    CultureInfo parent = culture.Parent;
                        
                    // Recurse now.
                    rs = InternalGetResourceSet(parent, createIfNotExists, tryParents);
                    if (rs != null) {
                        BCLDebug.Assert(ResourceSets[culture] == null, "GetResourceSet recursed, found a RS, but a RS already exists for culture "+culture.Name+"!  Check for an assembly load callback that calls back into the ResourceManager on the same thread, but I thought I handled that case...");
                        ResourceSets.Add(culture, rs);
                    }
                    return rs;
                }
            } //UseManifest
            else {
                // Don't use Assembly manifest, but grovel on disk for a file.
                new System.Security.Permissions.FileIOPermission(System.Security.Permissions.PermissionState.Unrestricted).Assert();
                
                // Create new ResourceSet, if a file exists on disk for it.
                fileName = FindResourceFile(culture);
                if (fileName == null) {
                    if (tryParents) {
                        // If we've hit top of the Culture tree, return.
                        if (culture.Equals(CultureInfo.InvariantCulture)) {
                            // We really don't think this should happen - we always
                            // expect the neutral locale's resources to be present.

                            throw new MissingManifestResourceException(Environment.GetResourceString("MissingManifestResource_NoNeutralDisk") + Environment.NewLine + "baseName: "+BaseNameField+"  locationInfo: "+(_locationInfo==null ? "<null>" : _locationInfo.FullName)+"  fileName: "+GetResourceFileName(culture));
                        }
                        
                        CultureInfo parent = culture.Parent;
                        
                        // Recurse now.
                        rs = InternalGetResourceSet(parent, createIfNotExists, tryParents);
                        if (rs != null)
                            ResourceSets.Add(culture, rs);
                        return rs;
                    }
                }
                else {
                    rs = CreateResourceSet(fileName);
                        
                    // To speed up ResourceSet lookups in the future, store this
                    // culture with its parent culture's ResourceSet.
                    if (rs != null)
                        ResourceSets.Add(culture, rs);
                    return rs;
                }
            }

            if (createIfNotExists && stream!=null && rs==null) {
#if _DEBUG
                if (DEBUG >= 1)
                    Console.WriteLine("Creating new ResourceSet for culture "+((culture==CultureInfo.InvariantCulture) ? "[neutral]" : culture.ToString())+" from file "+fileName);
#endif
                rs = CreateResourceSet(stream);
                BCLDebug.Assert(ResourceSets[culture] == null, "At end of InternalGetResourceSet, we did all kinds of lookup stuff, created a new resource set, but when we go to add it, a RS already exists for culture \""+culture.Name+"\"! ResMgr bug or aggressive assembly load callback?");
                ResourceSets.Add(culture, rs);
            }
#if _DEBUG
            else {
                // Just for debugging - include debug spew saying we won't do anything.
                if (!createIfNotExists && stream!=null && rs==null) {

                    if (DEBUG >= 1)
                        Console.WriteLine("NOT creating new ResourceSet because createIfNotExists was false!  For culture "+((culture==CultureInfo.InvariantCulture) ? "[neutral]" : culture.ToString())+" from file "+fileName);
                }
            }
#endif
            return rs;
        }

        // Looks up a .resources file in the assembly manifest using 
        // case-insensitive lookup rules.  Yes, this is slow.  The metadata
        // dev lead refuses to make all manifest blob lookups case-insensitive,
        // even optionally case-insensitive.
        private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, String name)
        {
            StringBuilder sb = new StringBuilder();
            if(_locationInfo != null) {
                String nameSpace = _locationInfo.Namespace;
                if(nameSpace != null) {
                    sb.Append(nameSpace);
                    if(name != null) 
                        sb.Append(Type.Delimiter);
                }
            }
            sb.Append(name);
    
            String givenName = sb.ToString();
            CompareInfo comparer = CultureInfo.InvariantCulture.CompareInfo;
            String canonicalName = null;
            foreach(String existingName in satellite.GetManifestResourceNames()) {
                if (comparer.Compare(existingName, givenName, CompareOptions.IgnoreCase) == 0) {
                    if (canonicalName == null)
                        canonicalName = existingName;
                    else
                        throw new MissingManifestResourceException(String.Format(Environment.GetResourceString("MissingManifestResource_MultipleBlobs"), givenName, satellite.ToString()));
                }
            }

#if _DEBUG
            if (DEBUG >= 4) {
                if (canonicalName == null)
                    Console.WriteLine("Case-insensitive resource stream lookup failed for: "+givenName+" in assembly: "+satellite+"  canonical name: "+canonicalName);
                else
                    Console.WriteLine("Case-insensitive resource stream lookup succeeded for: "+canonicalName+" in assembly: "+satellite);
            }
#endif

            if (canonicalName == null)
                return null;
            // If we're looking in the main assembly AND if the main
            // assembly was the person who created the ResourceManager,
            // skip a security check for private manifest resources.
            bool canSkipSecurityCheck = MainAssembly == satellite && _callingAssembly == MainAssembly;
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            Stream s = satellite.GetManifestResourceStream(canonicalName, ref stackMark, canSkipSecurityCheck);
            // GetManifestResourceStream will return null if we don't have 
            // permission to read this stream from the assembly.  For example,
            // if the stream is private and we're trying to access it from another
            // assembly (ie, ResMgr in mscorlib accessing anything else), we 
            // require Reflection TypeInformation permission to be able to read 
            // this.  This meaning of private in satellite assemblies is a really
            // odd concept, and is orthogonal to the ResourceManager.  According
            // to Suzanne, we should not assume we can skip this security check,
            // which means satellites must always use public manifest resources
            // if you want to support semi-trusted code.  -- BrianGru, 4/12/2001
            BCLDebug.Correctness(s != null, "Could not access the manifest resource from your satellite.  Make "+canonicalName+" in assembly "+satellite.nGetSimpleName()+" public.");
            return s;
        }

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetSatelliteContractVersion"]/*' />
        protected static Version GetSatelliteContractVersion(Assembly a)
        {
            BCLDebug.Assert(a != null, "assembly != null");
            Object[] attrs = a.GetCustomAttributes(typeof(SatelliteContractVersionAttribute), false);
            if (attrs.Length == 0)
                return null;
            BCLDebug.Assert(attrs.Length == 1, "Cannot have multiple instances of SatelliteContractVersionAttribute on an assembly!");
            String v = ((SatelliteContractVersionAttribute)attrs[0]).Version;
            Version ver;
            try {
                ver = new Version(v);
            }
            catch(Exception e) {
                // Note we are prone to hitting infinite loops if mscorlib's
                // SatelliteContractVersionAttribute contains bogus values.
                // If this assert fires, please fix the build process for the
                // BCL directory.
                if (a == typeof(Object).Assembly) {
                    BCLDebug.Assert(false, "mscorlib's SatelliteContractVersionAttribute is a malformed version string!");
                    return null;
                }

                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_InvalidSatelliteContract_Asm_Ver"), a.ToString(), v), e);
            }
            return ver;
        }

        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetNeutralResourcesLanguage"]/*' />
        protected static CultureInfo GetNeutralResourcesLanguage(Assembly a)
        {
            BCLDebug.Assert(a != null, "assembly != null");
            Object[] attrs = a.GetCustomAttributes(typeof(NeutralResourcesLanguageAttribute), false);
            if (attrs.Length == 0) {
#if _DEBUG
                if (DEBUG >= 4) 
                    Console.WriteLine("Consider putting the NeutralResourcesLanguageAttribute on assembly "+a.FullName);
#endif
                BCLDebug.Perf(false, "Consider adding NeutralResourcesLanguageAttribute to assembly "+a.FullName);
                return CultureInfo.InvariantCulture;
            }
            BCLDebug.Assert(attrs.Length == 1, "Expected 0 or 1 NeutralResourcesLanguageAttribute on assembly "+a.FullName);
            NeutralResourcesLanguageAttribute attr = (NeutralResourcesLanguageAttribute) attrs[0];
            try {
                CultureInfo c = new CultureInfo(attr.CultureName);
                return c;
            }
            catch (ThreadAbortException) {
                // This can happen sometimes.  We don't want to care about 
                // shutdown & other peculiarities.  Just quit.
                throw;
            }
            catch (Exception e) {
                // Note we could go into infinite loops if mscorlib's 
                // NeutralResourcesLanguageAttribute is mangled.  If this assert
                // fires, please fix the build process for the BCL directory.
                if (a == typeof(Object).Assembly) {
                    BCLDebug.Assert(false, "mscorlib's NeutralResourcesLanguageAttribute is a malformed culture name! name: \""+attr.CultureName+"\"  Exception: "+e);
                    return CultureInfo.InvariantCulture;
                }
                
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_InvalidNeutralResourcesLanguage_Asm_Culture"), a.ToString(), attr.CultureName), e);
            }
        }

        // Constructs a new ResourceSet for a given file name.  The logic in
        // here avoids a ReflectionPermission check for our RuntimeResourceSet
        // for perf and working set reasons.
        private ResourceSet CreateResourceSet(String file)
        {
            if (_userResourceSet == null) {
                // Explicitly avoid CreateInstance if possible, because it
                // requires ReflectionPermission to call private & protected
                // constructors.  
                return new RuntimeResourceSet(file);
            }
            else {
                Object[] args = new Object[1];
                args[0] = file;
                try {
                    return (ResourceSet) Activator.CreateInstance(_userResourceSet,args);
                }
                catch (MissingMethodException e) {
                    throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_ResMgrBadResSet_Type"), _userResourceSet.AssemblyQualifiedName), e);
                }
            }
        }
        
        // Constructs a new ResourceSet for a given file name.  The logic in
        // here avoids a ReflectionPermission check for our RuntimeResourceSet
        // for perf and working set reasons.
        private ResourceSet CreateResourceSet(Stream store)
        {
            BCLDebug.Assert(store != null, "I need a Stream!");
            // Check to see if this is a Stream the ResourceManager understands,
            // and check for the correct resource reader type.
            if (store.CanSeek && store.Length > 4) {
                long startPos = store.Position;
                BinaryReader br = new BinaryReader(store);
                // Look for our magic number as a little endian Int32.
                int bytes = br.ReadInt32();
                if (bytes == MagicNumber) {
                    int resMgrHeaderVersion = br.ReadInt32();
                    String readerTypeName = null, resSetTypeName = null;
                    if (resMgrHeaderVersion == HeaderVersionNumber) {
                        br.ReadInt32();  // We don't want the number of bytes to skip.
                        readerTypeName = br.ReadString();
                        resSetTypeName = br.ReadString();
                    }
                    else if (resMgrHeaderVersion > HeaderVersionNumber) {
                        int numBytesToSkip = br.ReadInt32();
                        br.BaseStream.Seek(numBytesToSkip, SeekOrigin.Current);
                    }
                    else {  
                        // resMgrHeaderVersion is older than this ResMgr version.
                        // @TODO: In future versions, add in backwards compatibility
                        // support here.

                        throw new NotSupportedException(Environment.GetResourceString("NotSupported_ObsoleteResourcesFile", MainAssembly.nGetSimpleName()));
                    }
#if _DEBUG
                    if (DEBUG >= 5)
                        Console.WriteLine("CreateResourceSet: Reader type name is: "+readerTypeName+"  ResSet type name: "+resSetTypeName);
#endif

                    store.Position = startPos;
                    // Perf optimization - Don't use Reflection for our defaults.
                    // Note there are two different sets of strings here - the
                    // assembly qualified strings emitted by ResourceWriter, and
                    // the abbreviated ones emitted by InternalResGen.
                    if (CanUseDefaultResourceClasses(readerTypeName, resSetTypeName)) {
#if _DEBUG
                        if (DEBUG >= 6)
                            Console.WriteLine("CreateResourceSet: Using RuntimeResourceSet on fast code path!");
#endif
                        return new RuntimeResourceSet(store);
                    }
                    else {
                        Type readerType = Assembly.LoadTypeWithPartialName(readerTypeName, false);
                        if (readerType == null)
                            throw new TypeLoadException(Environment.GetResourceString("TypeLoad_PartialBindFailed", readerTypeName));
                        Object[] args = new Object[1];
                        args[0] = store;
                        IResourceReader reader = (IResourceReader) Activator.CreateInstance(readerType, args);
#if _DEBUG
                        if (DEBUG >= 5)
                            Console.WriteLine("CreateResourceSet: Made a reader using Reflection.  Type: "+reader.GetType().FullName);
#endif
                        args[0] = reader;
                        Type resSetType;
                        if (_userResourceSet == null) {
                            if (resSetTypeName == null)
                                resSetType = typeof(RuntimeResourceSet);
                            else
                                resSetType = RuntimeType.GetTypeInternal(resSetTypeName, true, false, false);
                        }
                        else
                            resSetType = _userResourceSet;
                        ResourceSet rs = (ResourceSet) Activator.CreateInstance(resSetType, 
                                                                                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, 
                                                                                null, 
                                                                                args, 
                                                                                null, 
                                                                                null);
                        return rs;
                    }
                }
                else
                    store.Position = startPos;
            }

#if _DEBUG
            if (DEBUG>=5)
                Console.WriteLine("ResMgr::CreateResourceSet going down the old (unseekable) file format path.");
#endif
            if (_userResourceSet == null) {
                // Explicitly avoid CreateInstance if possible, because it
                // requires ReflectionPermission to call private & protected
                // constructors.  
                return new RuntimeResourceSet(store);
            }
            else {
                Object[] args = new Object[1];
                args[0] = store;
                try {
                    return (ResourceSet) Activator.CreateInstance(_userResourceSet, args);
                }
                catch (MissingMethodException e) {
                    throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_ResMgrBadResSet_Type"), _userResourceSet.AssemblyQualifiedName), e);
                }
            }
        }
        
        // Perf optimization - Don't use Reflection for most cases with
        // our .resources files.  This makes our code run faster and we can
        // creating a ResourceReader via Reflection.  This would incur
        // a security check (since the link-time check on the constructor that
        // takes a String is turned into a full demand with a stack walk)
        // and causes partially trusted localized apps to fail.
        private bool CanUseDefaultResourceClasses(String readerTypeName, String resSetTypeName) {
            if (_userResourceSet != null)
                return false;

            // Ignore the actual version of the ResourceReader and 
            // RuntimeResourceSet classes.  Let those classes deal with
            // versioning themselves.

            if (readerTypeName != null) {
                if (!readerTypeName.Equals(ResReaderTypeName) && !readerTypeName.Equals(ResReaderTypeNameInternal)) {
                    // Strip assembly version number out of the picture.
                    String s1 = StripVersionField(readerTypeName);
                    String s2 = StripVersionField(ResReaderTypeName);
                    if (!s1.Equals(s2))
                        return false;
                }
            }

            if (resSetTypeName != null) {
                if (!resSetTypeName.Equals(ResSetTypeName) && !resSetTypeName.Equals(ResSetTypeNameInternal)) {
                    // Strip assembly version number out of the picture.
                    String s1 = StripVersionField(resSetTypeName);
                    String s2 = StripVersionField(ResSetTypeName);
                    if (!s1.Equals(s2))
                        return false;
                }
            }
            return true;
        }

        internal static String StripVersionField(String typeName)
        {
            // An assembly qualified type name will look like this:
            // System.String, mscorlib, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
            // We want to remove the "Version=..., " from the string.
            int index = typeName.IndexOf("Version=");
            if (index == -1)
                return typeName;
            int nextPiece = typeName.IndexOf(',', index+1);
            if (nextPiece == -1) {
                // Assume we can trim the rest of the String, and correct for the
                // leading ", " before Version=.
                if (index >= 2 && typeName[index - 2] == ',' && typeName [index - 1] == ' ')
                    index -= 2;
                else {
                    BCLDebug.Assert(false, "Malformed fully qualified assembly name!  Expected to see a \", \" before the Version=..., but didn't!");
                    return typeName;
                }
                return typeName.Substring(0, index);
            }
            // Skip the ", " after Version=...
            if (nextPiece + 1 < typeName.Length && typeName[nextPiece] == ',' && typeName[nextPiece+1] == ' ')
                nextPiece += 2;
            else {
                BCLDebug.Assert(false, "Malformed fully qualified assembly name!  Expected to see a \", \" after the Version=..., but didn't!");
                return typeName;
            }
            return typeName.Remove(index, nextPiece - index);
        }

        // Looks up a resource value for a particular name.  Looks in the 
        // current thread's CultureInfo, and if not found, all parent CultureInfos.
        // Returns null if the resource wasn't found.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetString"]/*' />
        public virtual String GetString(String name) {
            return GetString(name, (CultureInfo)null);
        }
        
        // Looks up a resource value for a particular name.  Looks in the 
        // specified CultureInfo, and if not found, all parent CultureInfos.
        // Returns null if the resource wasn't found.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetString1"]/*' />
        public virtual String GetString(String name, CultureInfo culture) {
            if (null==name)
                throw new ArgumentNullException("name");
            if (null==culture) {
                culture = CultureInfo.CurrentUICulture;
            }
            
            // Prevent ReleaseAllResources from closing the ResourceSet we get back
            // from InternalGetResourceSet.
            lock(this) {
                ResourceSet rs = InternalGetResourceSet(culture, true, true);
    
                if (rs != null) {
                    //Console.WriteLine("GetString: Normal lookup in locale "+culture.Name+" [0x"+Int32.Format(culture.LCID, "x")+"] for "+name);
                    String value = rs.GetString(name, _ignoreCase);
#if _DEBUG
                    if (DEBUG >= 5)
                        Console.WriteLine("GetString("+name+"): string was: "+(value==null ? "<null>" : '\"'+value+'\"'));
#endif
                    if (value != null)
                        return value;
                }
    
                // This is the CultureInfo hierarchy traversal code for resource 
                // lookups, similar but necessarily orthogonal to the ResourceSet 
                // lookup logic.
                ResourceSet last = null;
                while (!culture.Equals(CultureInfo.InvariantCulture) && !culture.Equals(_neutralResourcesCulture)) {
                    culture = culture.Parent;
#if _DEBUG
                    if (DEBUG >= 5)
                        Console.WriteLine("GetString: Parent lookup in locale "+culture.Name+" [0x"+culture.LCID.ToString("x")+"] for "+name);
#endif
                    rs = InternalGetResourceSet(culture, true, true);
                    if (rs == null)
                        break;
                    if (rs != last) {
                        String value = rs.GetString(name, _ignoreCase);
                        if (value!=null)
                            return value;
                        last = rs;
                    }
                }
            }
            return null;
        }
        
        
        // Looks up a resource value for a particular name.  Looks in the 
        // current thread's CultureInfo, and if not found, all parent CultureInfos.
        // Returns null if the resource wasn't found.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetObject"]/*' />
        public virtual Object GetObject(String name) {
            return GetObject(name, (CultureInfo)null);
        }
        
        // Looks up a resource value for a particular name.  Looks in the 
        // specified CultureInfo, and if not found, all parent CultureInfos.
        // Returns null if the resource wasn't found.
        // 
        /// <include file='doc\ResourceManager.uex' path='docs/doc[@for="ResourceManager.GetObject1"]/*' />
        public virtual Object GetObject(String name, CultureInfo culture) {
            if (null==name)
                throw new ArgumentNullException("name");
            if (null==culture) {
                culture = CultureInfo.CurrentUICulture;
            }
            
            // Prevent ReleaseAllResources from closing the ResourceSet we get back
            // from InternalGetResourceSet.
            lock(this) {
                ResourceSet rs = InternalGetResourceSet(culture, true, true);
    
                if (rs != null) {
                    Object value = rs.GetObject(name, _ignoreCase);
#if _DEBUG
                    if (DEBUG >= 5)
                        Console.WriteLine("GetObject: string was: "+(value==null ? "<null>" : value));
#endif
                    if (value != null)
                        return value;
                }
            
                // This is the CultureInfo hierarchy traversal code for resource 
                // lookups, similar but necessarily orthogonal to the ResourceSet 
                // lookup logic.
                ResourceSet last = null;
                while (!culture.Equals(CultureInfo.InvariantCulture) && !culture.Equals(_neutralResourcesCulture)) {
                    culture = culture.Parent;
#if _DEBUG
                    if (DEBUG >= 5)
                        Console.WriteLine("GetObject: Parent lookup in locale "+culture.Name+" [0x"+culture.LCID.ToString("x")+"] for "+name);
#endif
                    rs = InternalGetResourceSet(culture, true, true);
                    if (rs == null)
                        break;
                    if (rs != last) {
                        Object value = rs.GetObject(name, _ignoreCase);
                        if (value!=null)
                            return value;
                        last = rs;
                    }
                }
            }
            return null;
        }   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\datetimeconstantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices
{
    /// <include file='doc\DateTimeConstantAttribute.uex' path='docs/doc[@for="DateTimeConstantAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter, Inherited=false)]
    public sealed class DateTimeConstantAttribute : CustomConstantAttribute
    {
        /// <include file='doc\DateTimeConstantAttribute.uex' path='docs/doc[@for="DateTimeConstantAttribute.DateTimeConstantAttribute"]/*' />
        public DateTimeConstantAttribute(long ticks)
        {
            date = new System.DateTime(ticks);
        }

        /// <include file='doc\DateTimeConstantAttribute.uex' path='docs/doc[@for="DateTimeConstantAttribute.Value"]/*' />
        public override Object Value
        {
            get {
                return date;
            }
        }

        private System.DateTime date;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\customconstantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices
{
    /// <include file='doc\CustomConstantAttribute.uex' path='docs/doc[@for="CustomConstantAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter, Inherited=false)]
    public abstract class CustomConstantAttribute : Attribute
    {
        /// <include file='doc\CustomConstantAttribute.uex' path='docs/doc[@for="CustomConstantAttribute.Value"]/*' />
        public abstract Object Value { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\discardableattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.CompilerServices {

	using System;

    // Custom attribute to indicating a TypeDef is a discardable attribute
    /// <include file='doc\DiscardableAttribute.uex' path='docs/doc[@for="DiscardableAttribute"]/*' />
    public class DiscardableAttribute : Attribute
    {
    	/// <include file='doc\DiscardableAttribute.uex' path='docs/doc[@for="DiscardableAttribute.DiscardableAttribute"]/*' />
    	public DiscardableAttribute()
    	{
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\decimalconstantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices
{
    /// <include file='doc\DecimalConstantAttribute.uex' path='docs/doc[@for="DecimalConstantAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter, Inherited=false),CLSCompliant(false)]
    public sealed class DecimalConstantAttribute : Attribute
    {
        /// <include file='doc\DecimalConstantAttribute.uex' path='docs/doc[@for="DecimalConstantAttribute.DecimalConstantAttribute"]/*' />
        public DecimalConstantAttribute(
            byte scale,
            byte sign,
            uint hi,
            uint mid,
            uint low
        )
        {
            dec = new System.Decimal((int) low, (int)mid, (int)hi, (sign != 0), scale);
        }

        /// <include file='doc\DecimalConstantAttribute.uex' path='docs/doc[@for="DecimalConstantAttribute.Value"]/*' />
        public System.Decimal Value
        {
            get {
                return dec;
            }
        }

        private System.Decimal dec;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\indexernameattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices
{
    using System;

    /// <include file='doc\IndexerNameAttribute.uex' path='docs/doc[@for="IndexerNameAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Property, Inherited = true)]
    public sealed class IndexerNameAttribute: Attribute
    {
        /// <include file='doc\IndexerNameAttribute.uex' path='docs/doc[@for="IndexerNameAttribute.IndexerNameAttribute"]/*' />
        public IndexerNameAttribute(String indexerName)
        {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\isvolatile.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices 
{
    /// <include file='doc\IsVolatile.uex' path='docs/doc[@for="IsVolatile"]/*' />
    public sealed class IsVolatile 
    {
        // no instantiation, please!
        private IsVolatile() 
        {}  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\iunknownconstantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Runtime.InteropServices;

namespace System.Runtime.CompilerServices
{
    /// <include file='doc\IUnknownConstantAttribute.uex' path='docs/doc[@for="IUnknownConstantAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter, Inherited=false)]
    public sealed class IUnknownConstantAttribute : CustomConstantAttribute
    {
        /// <include file='doc\IUnknownConstantAttribute.uex' path='docs/doc[@for="IUnknownConstantAttribute.IUnknownConstantAttribute"]/*' />
        public IUnknownConstantAttribute()
        {
        }

        /// <include file='doc\IUnknownConstantAttribute.uex' path='docs/doc[@for="IUnknownConstantAttribute.Value"]/*' />
        public override Object Value
        {
            get 
			{
                return new UnknownWrapper(null);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\idispatchconstantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Runtime.InteropServices;

namespace System.Runtime.CompilerServices
{
    /// <include file='doc\IDispatchConstantAttribute.uex' path='docs/doc[@for="IDispatchConstantAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter, Inherited=false)]
    public sealed class IDispatchConstantAttribute : CustomConstantAttribute
    {
        /// <include file='doc\IDispatchConstantAttribute.uex' path='docs/doc[@for="IDispatchConstantAttribute.IDispatchConstantAttribute"]/*' />
        public IDispatchConstantAttribute()
        {
        }

        /// <include file='doc\IDispatchConstantAttribute.uex' path='docs/doc[@for="IDispatchConstantAttribute.Value"]/*' />
        public override Object Value
        {
            get 
			{
                return new DispatchWrapper(null);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\methodimplattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.CompilerServices {
    
	using System;
	
	
    // This Enum matchs the miImpl flags defined in corhdr.h. It is used to specify 
    // certain method properties.
	
	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions"]/*' />
	[Flags, Serializable]
	public enum MethodImplOptions
	{
    	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.Unmanaged"]/*' />
    	Unmanaged       =   System.Reflection.MethodImplAttributes.Unmanaged,
    	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.ForwardRef"]/*' />
    	ForwardRef	    =   System.Reflection.MethodImplAttributes.ForwardRef,
    	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.PreserveSig"]/*' />
    	PreserveSig	    =   System.Reflection.MethodImplAttributes.PreserveSig,
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.InternalCall"]/*' />
		InternalCall    =   System.Reflection.MethodImplAttributes.InternalCall,
        /// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.Synchronized"]/*' />
        Synchronized    =   System.Reflection.MethodImplAttributes.Synchronized,
        /// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplOptions.NoInlining"]/*' />
        NoInlining      =   System.Reflection.MethodImplAttributes.NoInlining,
	}

	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodCodeType"]/*' />
	[Flags, Serializable]
	public enum MethodCodeType
	{
	    /// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodCodeType.IL"]/*' />
	    IL              =   System.Reflection.MethodImplAttributes.IL,
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodCodeType.Native"]/*' />
		Native          =   System.Reflection.MethodImplAttributes.Native,
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodCodeType.OPTIL"]/*' />
        /// <internalonly/>
        OPTIL           =   System.Reflection.MethodImplAttributes.OPTIL,
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodCodeType.Runtime"]/*' />
		Runtime         =   System.Reflection.MethodImplAttributes.Runtime  
	}

    // Custom attribute to specify additional method properties.
	/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute"]/*' />
	[Serializable, AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor, Inherited = false)] 
	sealed public class MethodImplAttribute : Attribute  
	{ 
		internal MethodImplOptions  _val;
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute.MethodCodeType"]/*' />
		public   MethodCodeType	    MethodCodeType;
		
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute.MethodImplAttribute"]/*' />
		public MethodImplAttribute(MethodImplOptions methodImplOptions)
		{
			_val = methodImplOptions;
		}
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute.MethodImplAttribute1"]/*' />
		public MethodImplAttribute(short value)
		{
			_val = (MethodImplOptions)value;
		}
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute.MethodImplAttribute2"]/*' />
		public MethodImplAttribute()
		{
		}
		
		/// <include file='doc\MethodImplAttribute.uex' path='docs/doc[@for="MethodImplAttribute.Value"]/*' />
		public MethodImplOptions Value { get {return _val;} }	
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\requiredattributeattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace System.Runtime.CompilerServices 
{
    /// <include file='doc\RequiredAttributeAttribute.uex' path='docs/doc[@for="RequiredAttributeAttribute"]/*' />
    [Serializable, AttributeUsage (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface, 
                     AllowMultiple=false, Inherited=false)]
    public sealed class RequiredAttributeAttribute : Attribute 
    {
        private Type requiredContract;

        /// <include file='doc\RequiredAttributeAttribute.uex' path='docs/doc[@for="RequiredAttributeAttribute.RequiredAttributeAttribute"]/*' />
        public RequiredAttributeAttribute (Type requiredContract) 
        {
            this.requiredContract= requiredContract;
        }
        /// <include file='doc\RequiredAttributeAttribute.uex' path='docs/doc[@for="RequiredAttributeAttribute.RequiredContract"]/*' />
        public Type RequiredContract 
        {
            get { return this.requiredContract; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\callingconvention.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {

	using System;
    // Used for the CallingConvention named argument to the DllImport attribute
    /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention"]/*' />
	[Serializable]
	public enum CallingConvention
    {
        /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention.Winapi"]/*' />
        Winapi          = 1,
        /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention.Cdecl"]/*' />
        Cdecl           = 2,
        /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention.StdCall"]/*' />
        StdCall         = 3,
        /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention.ThisCall"]/*' />
        ThisCall        = 4,
        /// <include file='doc\CallingConvention.uex' path='docs/doc[@for="CallingConvention.FastCall"]/*' />
        FastCall        = 5,
    }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\attributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {

	using System;

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="DispIdAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Event, Inherited = false)] 
	public sealed class DispIdAttribute : Attribute
	{
		internal int _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DispIdAttribute.DispIdAttribute"]/*' />
		public DispIdAttribute(int dispId)
		{
			_val = dispId;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DispIdAttribute.Value"]/*' />
		public int Value { get {return _val;} }
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComInterfaceType"]/*' />
	[Serializable()]
	public enum ComInterfaceType 
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComInterfaceType.InterfaceIsDual"]/*' />
		InterfaceIsDual             = 0,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComInterfaceType.InterfaceIsIUnknown"]/*' />
		InterfaceIsIUnknown         = 1,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComInterfaceType.InterfaceIsIDispatch"]/*' />
		InterfaceIsIDispatch        = 2,
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceTypeAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Interface, Inherited = false)] 
	public sealed class InterfaceTypeAttribute : Attribute
	{
		internal ComInterfaceType _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceTypeAttribute.InterfaceTypeAttribute"]/*' />
		public InterfaceTypeAttribute(ComInterfaceType interfaceType)
		{
			_val = interfaceType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceTypeAttribute.InterfaceTypeAttribute1"]/*' />
		public InterfaceTypeAttribute(short interfaceType)
		{
			_val = (ComInterfaceType)interfaceType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceTypeAttribute.Value"]/*' />
		public ComInterfaceType Value { get {return _val;} }	
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceType"]/*' />
	[Serializable()]
	public enum ClassInterfaceType 
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceType.None"]/*' />
		None            = 0,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceType.AutoDispatch"]/*' />
		AutoDispatch    = 1,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceType.AutoDual"]/*' />
		AutoDual        = 2
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class, Inherited = false)] 
	public sealed class ClassInterfaceAttribute : Attribute
	{
		internal ClassInterfaceType _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceAttribute.ClassInterfaceAttribute"]/*' />
		public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType)
		{
			_val = classInterfaceType;
		
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceAttribute.ClassInterfaceAttribute1"]/*' />
		public ClassInterfaceAttribute(short classInterfaceType)
		{
			_val = (ClassInterfaceType)classInterfaceType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ClassInterfaceAttribute.Value"]/*' />
		public ClassInterfaceType Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComVisibleAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property, Inherited = false)] 
	public sealed class ComVisibleAttribute : Attribute
	{
		internal bool _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComVisibleAttribute.ComVisibleAttribute"]/*' />
		public ComVisibleAttribute(bool visibility)
		{
			_val = visibility;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComVisibleAttribute.Value"]/*' />
		public bool Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="LCIDConversionAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class LCIDConversionAttribute : Attribute
	{
		internal int _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="LCIDConversionAttribute.LCIDConversionAttribute"]/*' />
		public LCIDConversionAttribute(int lcid)
		{
			_val = lcid;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="LCIDConversionAttribute.Value"]/*' />
		public int Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComRegisterFunctionAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class ComRegisterFunctionAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComRegisterFunctionAttribute.ComRegisterFunctionAttribute"]/*' />
		public ComRegisterFunctionAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComUnregisterFunctionAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class ComUnregisterFunctionAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComUnregisterFunctionAttribute.ComUnregisterFunctionAttribute"]/*' />
		public ComUnregisterFunctionAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ProgIdAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Class, Inherited = false)] 
	public sealed class ProgIdAttribute : Attribute
	{
		internal String _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ProgIdAttribute.ProgIdAttribute"]/*' />
		public ProgIdAttribute(String progId)
		{
			_val = progId;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ProgIdAttribute.Value"]/*' />
		public String Value { get {return _val;} }	
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ImportedFromTypeLibAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Assembly, Inherited = false)] 
	public sealed class ImportedFromTypeLibAttribute : Attribute
	{
		internal String _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ImportedFromTypeLibAttribute.ImportedFromTypeLibAttribute"]/*' />
		public ImportedFromTypeLibAttribute(String tlbFile)
		{
			_val = tlbFile;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ImportedFromTypeLibAttribute.Value"]/*' />
		public String Value { get {return _val;} }
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplType"]/*' />
	[Serializable()]
	public enum IDispatchImplType
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplType.SystemDefinedImpl"]/*' />
		SystemDefinedImpl	= 0,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplType.InternalImpl"]/*' />
		InternalImpl		= 1,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplType.CompatibleImpl"]/*' />
		CompatibleImpl		= 2,
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly, Inherited = false)] 
	public sealed class IDispatchImplAttribute : Attribute
	{
		internal IDispatchImplType _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplAttribute.IDispatchImplAttribute"]/*' />
		public IDispatchImplAttribute(IDispatchImplType implType)
		{
			_val = implType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplAttribute.IDispatchImplAttribute1"]/*' />
		public IDispatchImplAttribute(short implType)
		{
			_val = (IDispatchImplType)implType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="IDispatchImplAttribute.Value"]/*' />
		public IDispatchImplType Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Class, Inherited = false)] 
	public sealed class ComSourceInterfacesAttribute : Attribute
	{
		internal String _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute"]/*' />
		public ComSourceInterfacesAttribute(String sourceInterfaces)
		{
			_val = sourceInterfaces;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute1"]/*' />
		public ComSourceInterfacesAttribute(Type sourceInterface)
		{
			_val = sourceInterface.ToString();
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute2"]/*' />
		public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2)
		{
			_val = sourceInterface1.ToString() + sourceInterface2.ToString();
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute3"]/*' />
		public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3)
		{
			_val = sourceInterface1.ToString() + sourceInterface2.ToString() + sourceInterface3.ToString();
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute4"]/*' />
		public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4)
		{
			_val = sourceInterface1.ToString() + sourceInterface2.ToString() + sourceInterface3.ToString() + sourceInterface4.ToString();
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComSourceInterfacesAttribute.Value"]/*' />
		public String Value { get {return _val;} }	
	}	 

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComConversionLossAttribute"]/*' />
	[AttributeUsage(AttributeTargets.All, Inherited = false)] 
	public sealed class ComConversionLossAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComConversionLossAttribute.ComConversionLossAttribute"]/*' />
		public ComConversionLossAttribute()
		{
		}
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags"]/*' />
	[Serializable(),Flags()]
	public enum TypeLibTypeFlags
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FAppObject"]/*' />
		FAppObject		= 0x0001,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FCanCreate"]/*' />
		FCanCreate		= 0x0002,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FLicensed"]/*' />
		FLicensed		= 0x0004,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FPreDeclId"]/*' />
		FPreDeclId		= 0x0008,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FHidden"]/*' />
		FHidden			= 0x0010,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FControl"]/*' />
		FControl		= 0x0020,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FDual"]/*' />
		FDual			= 0x0040,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FNonExtensible"]/*' />
		FNonExtensible	= 0x0080,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FOleAutomation"]/*' />
		FOleAutomation	= 0x0100,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FRestricted"]/*' />
		FRestricted		= 0x0200,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FAggregatable"]/*' />
		FAggregatable	= 0x0400,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FReplaceable"]/*' />
		FReplaceable	= 0x0800,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FDispatchable"]/*' />
		FDispatchable	= 0x1000,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeFlags.FReverseBind"]/*' />
		FReverseBind	= 0x2000,
	}
	
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags"]/*' />
	[Serializable(),Flags()]
	public enum TypeLibFuncFlags
	{	
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FRestricted"]/*' />
		FRestricted			= 0x0001,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FSource"]/*' />
		FSource				= 0x0002,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FBindable"]/*' />
		FBindable			= 0x0004,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FRequestEdit"]/*' />
		FRequestEdit		= 0x0008,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FDisplayBind"]/*' />
		FDisplayBind		= 0x0010,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FDefaultBind"]/*' />
		FDefaultBind		= 0x0020,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FHidden"]/*' />
		FHidden				= 0x0040,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FUsesGetLastError"]/*' />
		FUsesGetLastError	= 0x0080,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FDefaultCollelem"]/*' />
		FDefaultCollelem	= 0x0100,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FUiDefault"]/*' />
		FUiDefault			= 0x0200,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FNonBrowsable"]/*' />
		FNonBrowsable		= 0x0400,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FReplaceable"]/*' />
		FReplaceable		= 0x0800,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncFlags.FImmediateBind"]/*' />
		FImmediateBind		= 0x1000,
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags"]/*' />
	[Serializable(),Flags()]
	public enum TypeLibVarFlags
	{	
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FReadOnly"]/*' />
		FReadOnly			= 0x0001,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FSource"]/*' />
		FSource				= 0x0002,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FBindable"]/*' />
		FBindable			= 0x0004,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FRequestEdit"]/*' />
		FRequestEdit		= 0x0008,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FDisplayBind"]/*' />
		FDisplayBind		= 0x0010,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FDefaultBind"]/*' />
		FDefaultBind		= 0x0020,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FHidden"]/*' />
		FHidden				= 0x0040,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FRestricted"]/*' />
		FRestricted			= 0x0080,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FDefaultCollelem"]/*' />
		FDefaultCollelem	= 0x0100,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FUiDefault"]/*' />
		FUiDefault			= 0x0200,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FNonBrowsable"]/*' />
		FNonBrowsable		= 0x0400,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FReplaceable"]/*' />
		FReplaceable		= 0x0800,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarFlags.FImmediateBind"]/*' />
		FImmediateBind		= 0x1000,
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Enum | AttributeTargets.Struct, Inherited = false)]
	public sealed class  TypeLibTypeAttribute : Attribute
	{
		internal TypeLibTypeFlags _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeAttribute.TypeLibTypeAttribute"]/*' />
		public TypeLibTypeAttribute(TypeLibTypeFlags flags)
		{
			_val = flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeAttribute.TypeLibTypeAttribute1"]/*' />
		public TypeLibTypeAttribute(short flags)
		{
			_val = (TypeLibTypeFlags)flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibTypeAttribute.Value"]/*' />
		public TypeLibTypeFlags Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class TypeLibFuncAttribute : Attribute
	{
		internal TypeLibFuncFlags _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncAttribute.TypeLibFuncAttribute"]/*' />
		public TypeLibFuncAttribute(TypeLibFuncFlags flags)
		{
			_val = flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncAttribute.TypeLibFuncAttribute1"]/*' />
		public TypeLibFuncAttribute(short flags)
		{
			_val = (TypeLibFuncFlags)flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibFuncAttribute.Value"]/*' />
		public TypeLibFuncFlags Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Field, Inherited = false)] 
	public sealed class TypeLibVarAttribute : Attribute
	{
		internal TypeLibVarFlags _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarAttribute.TypeLibVarAttribute"]/*' />
		public TypeLibVarAttribute(TypeLibVarFlags flags)
		{
			_val = flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarAttribute.TypeLibVarAttribute1"]/*' />
		public TypeLibVarAttribute(short flags)
		{
			_val = (TypeLibVarFlags)flags;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVarAttribute.Value"]/*' />
		public TypeLibVarFlags Value { get {return _val;} }	
	}	

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum"]/*' />
	[Serializable]
	public enum VarEnum
	{	
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_EMPTY"]/*' />
		VT_EMPTY			= 0,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_NULL"]/*' />
		VT_NULL				= 1,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_I2"]/*' />
		VT_I2				= 2,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_I4"]/*' />
		VT_I4				= 3,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_R4"]/*' />
		VT_R4				= 4,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_R8"]/*' />
		VT_R8				= 5,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_CY"]/*' />
		VT_CY				= 6,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_DATE"]/*' />
		VT_DATE				= 7,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_BSTR"]/*' />
		VT_BSTR				= 8,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_DISPATCH"]/*' />
		VT_DISPATCH			= 9,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_ERROR"]/*' />
		VT_ERROR			= 10,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_BOOL"]/*' />
		VT_BOOL				= 11,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_VARIANT"]/*' />
		VT_VARIANT			= 12,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UNKNOWN"]/*' />
		VT_UNKNOWN			= 13,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_DECIMAL"]/*' />
		VT_DECIMAL			= 14,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_I1"]/*' />
		VT_I1				= 16,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UI1"]/*' />
		VT_UI1				= 17,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UI2"]/*' />
		VT_UI2				= 18,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UI4"]/*' />
		VT_UI4				= 19,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_I8"]/*' />
		VT_I8				= 20,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UI8"]/*' />
		VT_UI8				= 21,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_INT"]/*' />
		VT_INT				= 22,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_UINT"]/*' />
		VT_UINT				= 23,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_VOID"]/*' />
		VT_VOID				= 24,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_HRESULT"]/*' />
		VT_HRESULT			= 25,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_PTR"]/*' />
		VT_PTR				= 26,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_SAFEARRAY"]/*' />
		VT_SAFEARRAY		= 27,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_CARRAY"]/*' />
		VT_CARRAY			= 28,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_USERDEFINED"]/*' />
		VT_USERDEFINED		= 29,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_LPSTR"]/*' />
		VT_LPSTR			= 30,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_LPWSTR"]/*' />
		VT_LPWSTR			= 31,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_RECORD"]/*' />
		VT_RECORD			= 36,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_FILETIME"]/*' />
		VT_FILETIME			= 64,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_BLOB"]/*' />
		VT_BLOB				= 65,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_STREAM"]/*' />
		VT_STREAM			= 66,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_STORAGE"]/*' />
		VT_STORAGE			= 67,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_STREAMED_OBJECT"]/*' />
		VT_STREAMED_OBJECT	= 68,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_STORED_OBJECT"]/*' />
		VT_STORED_OBJECT	= 69,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_BLOB_OBJECT"]/*' />
		VT_BLOB_OBJECT		= 70,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_CF"]/*' />
		VT_CF				= 71,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_CLSID"]/*' />
		VT_CLSID			= 72,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_VECTOR"]/*' />
		VT_VECTOR			= 0x1000,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_ARRAY"]/*' />
		VT_ARRAY			= 0x2000,
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="VarEnum.VT_BYREF"]/*' />
		VT_BYREF			= 0x4000
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType"]/*' />
	[Serializable()]
	public enum UnmanagedType
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.Bool"]/*' />
		Bool			 = 0x2,			// 4 byte boolean value (true != 0, false == 0)

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.I1"]/*' />
		I1				 = 0x3,			// 1 byte signed value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.U1"]/*' />
		U1				 = 0x4,			// 1 byte unsigned value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.I2"]/*' />
		I2				 = 0x5,			// 2 byte signed value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.U2"]/*' />
		U2				 = 0x6,			// 2 byte unsigned value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.I4"]/*' />
		I4				 = 0x7,			// 4 byte signed value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.U4"]/*' />
		U4				 = 0x8,			// 4 byte unsigned value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.I8"]/*' />
		I8				 = 0x9,			// 8 byte signed value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.U8"]/*' />
		U8				 = 0xa,			// 8 byte unsigned value

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.R4"]/*' />
		R4				 = 0xb,			// 4 byte floating point

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.R8"]/*' />
		R8				 = 0xc,			// 8 byte floating point

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.Currency"]/*' />
		Currency		 = 0xf,			// A currency

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.BStr"]/*' />
		BStr			 = 0x13,		// OLE Unicode BSTR

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.LPStr"]/*' />
		LPStr			 = 0x14,		// Ptr to SBCS string

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.LPWStr"]/*' />
		LPWStr			 = 0x15,		// Ptr to Unicode string

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.LPTStr"]/*' />
		LPTStr			 = 0x16,		// Ptr to OS preferred (SBCS/Unicode) string

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.ByValTStr"]/*' />
		ByValTStr		 = 0x17,		// OS preferred (SBCS/Unicode) inline string (only valid in structs)

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.IUnknown"]/*' />
		IUnknown		 = 0x19,		// COM IUnknown pointer. 

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.IDispatch"]/*' />
		IDispatch		 = 0x1a,		// COM IDispatch pointer

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.Struct"]/*' />
		Struct			 = 0x1b,		// Structure

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.Interface"]/*' />
		Interface		 = 0x1c,		// COM interface

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.SafeArray"]/*' />
		SafeArray		 = 0x1d,		// OLE SafeArray

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.ByValArray"]/*' />
		ByValArray		 = 0x1e,		// Array of fixed size (only valid in structs)

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.SysInt"]/*' />
		SysInt			 = 0x1f,		// Hardware natural sized signed integer

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.SysUInt"]/*' />
		SysUInt			 = 0x20,		 

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.VBByRefStr"]/*' />
		VBByRefStr		 = 0x22,		 

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.AnsiBStr"]/*' />
		AnsiBStr		 = 0x23,		// OLE BSTR containing SBCS characters

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.TBStr"]/*' />
		TBStr			 = 0x24,		// Ptr to OS preferred (SBCS/Unicode) BSTR

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.VariantBool"]/*' />
		VariantBool		 = 0x25,		// OLE defined BOOLEAN (2 bytes, true == -1, false == 0)

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.FunctionPtr"]/*' />
		FunctionPtr		 = 0x26,		// Function pointer

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.AsAny"]/*' />
		AsAny			 = 0x28,		// Paired with Object type and does runtime marshalling determination

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.LPArray"]/*' />
		LPArray			 = 0x2a,		// C style array

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.LPStruct"]/*' />
		LPStruct		 = 0x2b,		// Pointer to a structure

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.CustomMarshaler"]/*' />
		CustomMarshaler	 = 0x2c,		

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="UnmanagedType.Error"]/*' />
		Error			 = 0x2d,		
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Field | AttributeTargets.ReturnValue, Inherited = false)] 
	public sealed class MarshalAsAttribute : Attribute	 
	{ 
		internal UnmanagedType _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.MarshalAsAttribute"]/*' />
		public MarshalAsAttribute(UnmanagedType unmanagedType)
		{
			_val = unmanagedType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.MarshalAsAttribute1"]/*' />
		public MarshalAsAttribute(short unmanagedType)
		{
			_val = (UnmanagedType)unmanagedType;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.Value"]/*' />
		public UnmanagedType Value { get {return _val;} }	

		// Fields used with SubType = SafeArray.
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.SafeArraySubType"]/*' />
		public VarEnum			  SafeArraySubType;
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.SafeArrayUserDefinedSubType"]/*' />
        public Type               SafeArrayUserDefinedSubType;

		// Fields used with SubType = ByValArray and LPArray.
		// Array size =	 parameter(PI) * PM + C
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.ArraySubType"]/*' />
		public UnmanagedType	  ArraySubType;	
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.SizeParamIndex"]/*' />
		public short			  SizeParamIndex;			// param index PI
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.SizeConst"]/*' />
		public int				  SizeConst;				// constant C

		// Fields used with SubType = CustomMarshaler
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.MarshalType"]/*' />
		public String			  MarshalType;				// Name of marshaler class
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.MarshalTypeRef"]/*' />
		public Type 			  MarshalTypeRef;			// Type of marshaler class
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="MarshalAsAttribute.MarshalCookie"]/*' />
		public String			  MarshalCookie;			// cookie to pass to marshaler
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComImportAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = false)] 
	public sealed class ComImportAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComImportAttribute.ComImportAttribute"]/*' />
		public ComImportAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="GuidAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Struct | AttributeTargets.Delegate, Inherited = false)] 
	public sealed class GuidAttribute : Attribute
	{
		internal String _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="GuidAttribute.GuidAttribute"]/*' />
		public GuidAttribute(String guid)
		{
			_val = guid;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="GuidAttribute.Value"]/*' />
		public String Value { get {return _val;} }	
	}	

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="PreserveSigAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class PreserveSigAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="PreserveSigAttribute.PreserveSigAttribute"]/*' />
		public PreserveSigAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="InAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)] 
	public sealed class InAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="InAttribute.InAttribute"]/*' />
		public InAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="OutAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)] 
	public sealed class OutAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="OutAttribute.OutAttribute"]/*' />
		public OutAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="OptionalAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)] 
	public sealed class OptionalAttribute : Attribute
	{
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="OptionalAttribute.OptionalAttribute"]/*' />
		public OptionalAttribute()
		{
		}
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Method, Inherited = false)] 
	public sealed class DllImportAttribute : Attribute
	{
		internal String _val;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.DllImportAttribute"]/*' />
		public DllImportAttribute(String dllName)
		{
			_val = dllName;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.Value"]/*' />
		public String Value { get {return _val;} }	

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.EntryPoint"]/*' />
		public String			  EntryPoint;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.CharSet"]/*' />
		public CharSet			  CharSet;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.SetLastError"]/*' />
		public bool				  SetLastError;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.ExactSpelling"]/*' />
		public bool				  ExactSpelling;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.PreserveSig"]/*' />
		public bool				  PreserveSig;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.CallingConvention"]/*' />
		public CallingConvention  CallingConvention;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.BestFitMapping"]/*' />
        public bool               BestFitMapping;
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="DllImportAttribute.ThrowOnUnmappableChar"]/*' />
        public bool               ThrowOnUnmappableChar;

	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)] 
	public sealed class StructLayoutAttribute : Attribute
	{
		internal LayoutKind _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.StructLayoutAttribute"]/*' />
		public StructLayoutAttribute(LayoutKind layoutKind)
		{
			_val = layoutKind;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.StructLayoutAttribute1"]/*' />
		public StructLayoutAttribute(short layoutKind)
		{
			_val = (LayoutKind)layoutKind;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.Value"]/*' />
		public LayoutKind Value { get {return _val;} }	
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.Pack"]/*' />
		public int				  Pack;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.Size"]/*' />
		public int 			  Size;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="StructLayoutAttribute.CharSet"]/*' />
		public CharSet			  CharSet;
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="FieldOffsetAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Field, Inherited = false)] 
	public sealed class FieldOffsetAttribute : Attribute
	{
		internal int _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="FieldOffsetAttribute.FieldOffsetAttribute"]/*' />
		public FieldOffsetAttribute(int offset)
		{
			_val = offset;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="FieldOffsetAttribute.Value"]/*' />
		public int Value { get {return _val;} }	
	}

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComAliasNameAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.ReturnValue, Inherited = false)] 
	public sealed class ComAliasNameAttribute : Attribute
	{
		internal String _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComAliasNameAttribute.ComAliasNameAttribute"]/*' />
		public ComAliasNameAttribute(String alias)
		{
			_val = alias;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ComAliasNameAttribute.Value"]/*' />
		public String Value { get {return _val;} }	
	}	 

	/// <include file='doc\Attributes.uex' path='docs/doc[@for="AutomationProxyAttribute"]/*' />
 	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Interface, Inherited = false)] 
	public sealed class AutomationProxyAttribute : Attribute
	{
		internal bool _val;
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="AutomationProxyAttribute.AutomationProxyAttribute"]/*' />
		public AutomationProxyAttribute(bool val)
		{
			_val = val;
		}
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="AutomationProxyAttribute.Value"]/*' />
		public bool Value { get {return _val;} }
	}

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrimaryInteropAssemblyAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = false)] 
    public sealed class PrimaryInteropAssemblyAttribute : Attribute
    {
        internal int _major;
        internal int _minor;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrimaryInteropAssemblyAttribute.PrimaryInteropAssemblyAttribute"]/*' />
        public PrimaryInteropAssemblyAttribute(int major, int minor)
        {
            _major = major;
            _minor = minor;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrimaryInteropAssemblyAttribute.MajorVersion"]/*' />
        public int MajorVersion { get {return _major;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrimaryInteropAssemblyAttribute.MinorVersion"]/*' />
        public int MinorVersion { get {return _minor;} }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="CoClassAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Interface, Inherited = false)] 
    public sealed class CoClassAttribute : Attribute
    {
        internal Type _CoClass;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="CoClassAttribute.CoClassAttribute"]/*' />
        public CoClassAttribute(Type coClass)
        {
            _CoClass = coClass;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="CoClassAttribute.CoClass"]/*' />
        public Type CoClass { get {return _CoClass;} }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Interface, Inherited = false)] 
    public sealed class ComEventInterfaceAttribute : Attribute
    {
        internal Type _SourceInterface;
        internal Type _EventProvider;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute.ComEventInterfaceAttribute"]/*' />
        public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider)
        {
            _SourceInterface = SourceInterface;
            _EventProvider = EventProvider;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute.SourceInterface"]/*' />
        public Type SourceInterface { get {return _SourceInterface;} }       
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute.EventProvider"]/*' />
        public Type EventProvider { get {return _EventProvider;} }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVersionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = false)] 
    public sealed class TypeLibVersionAttribute : Attribute
    {
        internal int _major;
        internal int _minor;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVersionAttribute.TypeLibVersionAttribute"]/*' />
        public TypeLibVersionAttribute(int major, int minor)
        {
            _major = major;
            _minor = minor;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVersionAttribute.MajorVersion"]/*' />
        public int MajorVersion { get {return _major;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TypeLibVersionAttribute.MinorVersion"]/*' />
        public int MinorVersion { get {return _minor;} }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = false)] 
    public sealed class ComCompatibleVersionAttribute : Attribute
    {
        internal int _major;
        internal int _minor;
        internal int _build;
        internal int _revision;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute.ComCompatibleVersionAttribute"]/*' />
        public ComCompatibleVersionAttribute(int major, int minor, int build, int revision)
        {
            _major = major;
            _minor = minor;
            _build = build;
            _revision = revision;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute.MajorVersion"]/*' />
        public int MajorVersion { get {return _major;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute.MinorVersion"]/*' />
        public int MinorVersion { get {return _minor;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute.BuildNumber"]/*' />
        public int BuildNumber { get {return _build;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComCompatibleVersionAttribute.RevisionNumber"]/*' />
        public int RevisionNumber { get {return _revision;} }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="BestFitMappingAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
    public sealed class BestFitMappingAttribute : Attribute
    {
        internal bool _bestFitMapping;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="BestFitMappingAttribute.BestFitMappingAttribute"]/*' />
        public BestFitMappingAttribute(bool BestFitMapping)
        {
            _bestFitMapping = BestFitMapping;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute.BestFitMapping"]/*' />
        public bool BestFitMapping { get {return _bestFitMapping;} }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ComEventInterfaceAttribute.ThrowOnUnmappableChar"]/*' />      
        public bool ThrowOnUnmappableChar;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\commembertype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\ComMemberType.uex' path='docs/doc[@for="ComMemberType"]/*' />
    [Serializable()] 
    public enum ComMemberType
    {
        /// <include file='doc\ComMemberType.uex' path='docs/doc[@for="ComMemberType.Method"]/*' />
        Method              = 0,
        /// <include file='doc\ComMemberType.uex' path='docs/doc[@for="ComMemberType.PropGet"]/*' />
        PropGet             = 1,
        /// <include file='doc\ComMemberType.uex' path='docs/doc[@for="ComMemberType.PropSet"]/*' />
        PropSet             = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\arraywithoffset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.CompilerServices;

    /// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset"]/*' />
    //[StructLayout(LayoutKind.Auto)]  //BUGBUG Uncomment for new compiler
    public struct ArrayWithOffset
    {
        //private ArrayWithOffset()
        //{
        //    throw new Exception();
        //}
    
        /// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset.ArrayWithOffset"]/*' />
        public ArrayWithOffset(Object array, int offset)
        {
            m_array  = array;
            m_offset = offset;
            // @COOLPORT: COOL requires all members be assigned to before calling
            // member functions.
            m_count  = 0;
            m_count  = CalculateCount();
        }
    
        /// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset.GetArray"]/*' />
        public Object GetArray()
        {
            return m_array;
        }
    
        /// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset.GetOffset"]/*' />
        public int GetOffset()
        {
            return m_offset;
        }
    
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_count + m_offset;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\ArrayWithOffset.uex' path='docs/doc[@for="ArrayWithOffset.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is ArrayWithOffset)) {
    			ArrayWithOffset that = (ArrayWithOffset) obj;
    			return that.m_array == m_array && that.m_offset == m_offset && that.m_count == m_count;
    		}
    		else
    			return false;
    	}
    	
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int CalculateCount();
    
        private Object m_array;
        private int    m_offset;
        private int    m_count;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\comexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: COMException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception class for all errors from COM Interop where we don't
** recognize the HResult.
**
** Date: March 24, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	using System.Runtime.InteropServices;
	using System;
	using System.Runtime.Serialization;
    // Exception for COM Interop errors where we don't recognize the HResult.
    // 
    /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException"]/*' />
    [Serializable()] public class COMException : ExternalException {
        /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.COMException"]/*' />
        public COMException() 
            : base(Environment.GetResourceString("Arg_COMException")) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.COMException1"]/*' />
        public COMException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.COMException2"]/*' />
        public COMException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
    	/// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.COMException3"]/*' />
    	public COMException(String message,int errorCode) 
            : base(message) {
    		SetErrorCode(errorCode);
        }
        
        /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.COMException4"]/*' />
        protected COMException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

        /// <include file='doc\COMException.uex' path='docs/doc[@for="COMException.ToString"]/*' />
        public override String ToString() {
            String message = Message;
            String s;
            String _className = GetType().ToString();
            s = _className + " (0x" + HResult.ToString("X8") + ")";

            if (!(message == null || message.Length <= 0)) {
                s = s + ": " + message;
            }

            Exception _innerException = InnerException;

            if (_innerException!=null) {
                s = s + " ---> " + _innerException.ToString();
            }


            if (StackTrace != null)
                s += Environment.NewLine + StackTrace;

            return s;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\compilerservices\runtimehelpers.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// RuntimeHelpers
//	This class defines a set of static methods that provide support for compilers.
//
// Author: darylo
// Date: April 2000
//
namespace System.Runtime.CompilerServices {

    using System;
    using System.Runtime.CompilerServices;
    /// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers"]/*' />
    [Serializable]
    public sealed class RuntimeHelpers
    {
        private RuntimeHelpers() {}

        /// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.InitializeArray"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void InitializeArray(Array array,RuntimeFieldHandle fldHandle);

        // GetObjectValue is intended to allow value classes to be manipulated as 'Object'
        // but have aliasing behavior of a value class.  The intent is that you would use
        // this function just before an assignment to a variable of type 'Object'.  If the
        // value being assigned is a mutable value class, then a shallow copy is returned 
        // (because value classes have copy semantics), but otherwise the object itself
        // is returned.  
        //
        // Note: VB calls this method when they're about to assign to an Object
        // or pass it as a parameter.  The goal is to make sure that boxed 
        // value types work identical to unboxed value types - ie, they get 
        // cloned when you pass them around, and are always passed by value.  
        // Of course, reference types are not cloned.  -- BrianGru  7/12/2001
        //
        /// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.GetObjectValue"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Object GetObjectValue(Object obj);

	    // RunClassConstructor causes the class constructor for the given type to be triggered
	    // in the current domain.  After this call returns, the class constructor is guaranteed to
	    // have at least been started by some thread.  In the absence of class constructor
        // deadlock conditions, the call is further guaranteed to have completed.
        //
        // This call will generate an exception if the specified class constructor threw an 
        // exception when it ran. 

        /// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.RunClassConstructor"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void RunClassConstructor(RuntimeTypeHandle type);
	
		/// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.GetHashCode"]/*' />
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int GetHashCode(Object o);
	
		/// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.Equals"]/*' />
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
        public new static extern bool Equals(Object o1, Object o2);
	
        /// <include file='doc\RuntimeHelpers.uex' path='docs/doc[@for="RuntimeHelpers.OffsetToStringData"]/*' />
        public static int OffsetToStringData
        {
            get {
                // Number of bytes from the address pointed to by a reference to
                // a String to the first 16-bit character in the String.  Skip 
                // over the MethodTable pointer, String capacity, & String 
                // length.  Of course, the String reference points to the memory 
                // after the sync block, so don't count that.  
                // This property allows C#'s fixed statement to work on Strings.
                // On 64 bit platforms, this should be 16.  -- BrianGru
#if WIN32
                return 12;
#else
                return 16;
#endif
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\currencywrapper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: CurrencyWrapper.
**
** Author: David Mortenson(dmortens)
**
** Purpose: Wrapper that is converted to a variant with VT_CURRENCY.
**
** Date: June 28, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
   
    using System;

    /// <include file='doc\CurrencyWrapper.uex' path='docs/doc[@for="CurrencyWrapper"]/*' />
    public sealed class CurrencyWrapper
    {
        /// <include file='doc\CurrencyWrapper.uex' path='docs/doc[@for="CurrencyWrapper.CurrencyWrapper"]/*' />
        public CurrencyWrapper(Decimal obj)
        {
            m_WrappedObject = obj;
        }

        /// <include file='doc\CurrencyWrapper.uex' path='docs/doc[@for="CurrencyWrapper.CurrencyWrapper1"]/*' />
        public CurrencyWrapper(Object obj)
        {            
            if (!(obj is Decimal))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDecimal"), "obj");
            m_WrappedObject = (Decimal)obj;
        }

        /// <include file='doc\CurrencyWrapper.uex' path='docs/doc[@for="CurrencyWrapper.WrappedObject"]/*' />
        public Decimal WrappedObject 
        {
            get 
            {
                return m_WrappedObject;
            }
        }

        private Decimal m_WrappedObject;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\charset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {
	using System;
    // Use this in P/Direct function prototypes to specify 
    // which character set to use when marshalling Strings.
    // Using Ansi will marshal the strings as 1 byte char*'s.
    // Using Unicode will marshal the strings as 2 byte wchar*'s.
    // Generally you probably want to use Auto, which does the
    // right thing 99% of the time.
    /// <include file='doc\CharSet.uex' path='docs/doc[@for="CharSet"]/*' />
    [Serializable] 
	public enum CharSet
    {
    	/// <include file='doc\CharSet.uex' path='docs/doc[@for="CharSet.None"]/*' />
    	None = 1,		// User didn't specify how to marshal strings.
    	/// <include file='doc\CharSet.uex' path='docs/doc[@for="CharSet.Ansi"]/*' />
    	Ansi = 2,		// Strings should be marshalled as ANSI 1 byte chars. 
    	/// <include file='doc\CharSet.uex' path='docs/doc[@for="CharSet.Unicode"]/*' />
    	Unicode = 3,    // Strings should be marshalled as Unicode 2 byte chars.
    	/// <include file='doc\CharSet.uex' path='docs/doc[@for="CharSet.Auto"]/*' />
    	Auto = 4,		// Marshal Strings in the right way for the target system. 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\errorwrapper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ErrorWrapper.
**
** Author: David Mortenson(dmortens)
**
** Purpose: Wrapper that is converted to a variant with VT_ERROR.
**
** Date: June 28, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
   
    using System;
    using System.Security.Permissions;

    /// <include file='doc\ErrorWrapper.uex' path='docs/doc[@for="ErrorWrapper"]/*' />
    public sealed class ErrorWrapper
    {
        /// <include file='doc\ErrorWrapper.uex' path='docs/doc[@for="ErrorWrapper.ErrorWrapper"]/*' />
        public ErrorWrapper(int errorCode)
        {
            m_ErrorCode = errorCode;
        }

        /// <include file='doc\ErrorWrapper.uex' path='docs/doc[@for="ErrorWrapper.ErrorWrapper2"]/*' />
        public ErrorWrapper(Object errorCode)
        {
            if (!(errorCode is int))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeInt32"), "errorCode");
            m_ErrorCode = (int)errorCode;
        }        

        /// <include file='doc\ErrorWrapper.uex' path='docs/doc[@for="ErrorWrapper.ErrorWrapper1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public ErrorWrapper(Exception e)
        {
            m_ErrorCode = Marshal.GetHRForException(e);
        }

        /// <include file='doc\ErrorWrapper.uex' path='docs/doc[@for="ErrorWrapper.ErrorCode"]/*' />
        public int ErrorCode 
        {
            get 
            {
                return m_ErrorCode;
            }
        }

        private int m_ErrorCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\extensibleclassfactory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ExtensibleClassFactory
**
** Author: Rudi Martin (rudim)
**
** Purpose: Methods used to customize the creation of managed objects that
**          extend from unmanaged objects.
**
** Date: May 27, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	using System.Runtime.InteropServices;
	using System.Runtime.Remoting;
	using System.Runtime.CompilerServices;

	using System;
    /// <include file='doc\ExtensibleClassFactory.uex' path='docs/doc[@for="ExtensibleClassFactory"]/*' />
    public sealed class ExtensibleClassFactory
    {
    
        // Prevent instantiation.
        private ExtensibleClassFactory() {}
    
        // Register a delegate that will be called whenever an instance of a managed
        // type that extends from an unmanaged type needs to allocate the aggregated
        // unmanaged object. This delegate is expected to allocate and aggregate the
        // unmanaged object and is called in place of a CoCreateInstance. This
        // routine must be called in the context of the static initializer for the
        // class for which the callbacks will be made. 
        // It is not legal to register this callback from a class that has any
        // parents that have already registered a callback.
        /// <include file='doc\ExtensibleClassFactory.uex' path='docs/doc[@for="ExtensibleClassFactory.RegisterObjectCreationCallback"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void RegisterObjectCreationCallback(ObjectCreationDelegate callback);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\externalexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ExternalException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception base class for all errors from Interop or Structured 
**          Exception Handling code.
**
** Date: March 24, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;
    // Base exception for COM Interop errors &; Structured Exception Handler
    // exceptions.
    // 
    /// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException"]/*' />
    [Serializable()] public class ExternalException : SystemException {
        /// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ExternalException"]/*' />
        public ExternalException() 
            : base(Environment.GetResourceString("Arg_ExternalException")) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ExternalException1"]/*' />
        public ExternalException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ExternalException2"]/*' />
        public ExternalException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.E_FAIL);
        }

		/// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ExternalException3"]/*' />
		public ExternalException(String message,int errorCode) 
            : base(message) {
    		SetErrorCode(errorCode);
        }

        /// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ExternalException4"]/*' />
        protected ExternalException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

		/// <include file='doc\ExternalException.uex' path='docs/doc[@for="ExternalException.ErrorCode"]/*' />
		public virtual int ErrorCode {
    		get { return HResult; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\handleref.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices {
    
	using System;

    /// <include file='doc\HandleRef.uex' path='docs/doc[@for="HandleRef"]/*' />
	//[StructLayout(LayoutKind.Auto)] //BUGBUG uncomment for new compiler
    public struct HandleRef
    {

        // ! Do not add or rearrange fields as the EE depends on this layout.
        //------------------------------------------------------------------
        internal Object m_wrapper;
        internal IntPtr m_handle;
        //------------------------------------------------------------------


        /// <include file='doc\HandleRef.uex' path='docs/doc[@for="HandleRef.HandleRef"]/*' />
        public HandleRef(Object wrapper, IntPtr handle)
        {
            m_wrapper = wrapper;
            m_handle  = handle;
        }

        /// <include file='doc\HandleRef.uex' path='docs/doc[@for="HandleRef.Wrapper"]/*' />
        public Object Wrapper {
            get {
                return m_wrapper;
            }
        }
    
        /// <include file='doc\HandleRef.uex' path='docs/doc[@for="HandleRef.Handle"]/*' />
        public IntPtr Handle {
            get {
                return m_handle;
            }
        }
    
    
        /// <include file='doc\HandleRef.uex' path='docs/doc[@for="HandleRef.operatorIntPtr"]/*' />
        public static explicit operator IntPtr(HandleRef value)
        {
            return value.m_handle;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\icustomadapter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ICustomAdapter
**
** Author: David Mortenson (dmortens)
**
** Purpose: This the base interface that custom adapters can chose to implement
**          when they want to expose the underlying object.
**
** Date: February 15, 2001
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	using System;

    /// <include file='doc\ICustomAdapter.uex' path='docs/doc[@for="ICustomAdapter"]/*' />
    public interface ICustomAdapter
    {		
        /// <include file='doc\ICustomAdapter.uex' path='docs/doc[@for="ICustomAdapter.GetUnderlyingObject"]/*' />
        [return:MarshalAs(UnmanagedType.IUnknown)] Object GetUnderlyingObject();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\dispatchwrapper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: DispatchWrapper.
**
** Author: David Mortenson(dmortens)
**
** Purpose: Wrapper that is converted to a variant with VT_DISPATCH.
**
** Date: June 28, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
   
    using System;

    /// <include file='doc\DispatchWrapper.uex' path='docs/doc[@for="DispatchWrapper"]/*' />
    public sealed class DispatchWrapper
    {
		/// <include file='doc\DispatchWrapper.uex' path='docs/doc[@for="DispatchWrapper.DispatchWrapper"]/*' />
		public DispatchWrapper(Object obj)
		{
            if (obj != null)
            {
                // Make sure this guy has an IDispatch
                IntPtr pdisp = Marshal.GetIDispatchForObject(obj);

                // If we got here without throwing an exception, the QI for IDispatch succeeded.
                Marshal.Release(pdisp);
            }
			m_WrappedObject = obj;
		}

        /// <include file='doc\DispatchWrapper.uex' path='docs/doc[@for="DispatchWrapper.WrappedObject"]/*' />
        public Object WrappedObject 
		{
			get 
			{
				return m_WrappedObject;
			}
        }

		private Object m_WrappedObject;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\icustomfactory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {

	using System;

    /// <include file='doc\ICustomFactory.uex' path='docs/doc[@for="ICustomFactory"]/*' />
    public interface ICustomFactory
    {
        /// <include file='doc\ICustomFactory.uex' path='docs/doc[@for="ICustomFactory.CreateInstance"]/*' />
        MarshalByRefObject CreateInstance(Type serverType);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\gchandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices {
    
	using System;
	using System.Security.Permissions;
	using System.Runtime.CompilerServices;

	// These are the types of handles used by the EE.  IMPORTANT: These must
	// match the definitions in ObjectHandle.h in the EE.
	/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandleType"]/*' />
	[Serializable]
	public enum GCHandleType
	{
		/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandleType.Weak"]/*' />
		Weak = 0,
		/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandleType.WeakTrackResurrection"]/*' />
		WeakTrackResurrection = 1,
		/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandleType.Normal"]/*' />
		Normal = 2,
		/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandleType.Pinned"]/*' />
		Pinned = 3
	}

    // This class allows you to create an opaque, GC handle to any 
    // managed object. A GC handle is used when an object reference must be
    // reachable from unmanaged memory.  There are 3 kinds of roots:
    // Normal - keeps the object from being collected.
    // Weak - allows object to be collected and handle contents will be zeroed.
    //          Weak references are zeroed before the finalizer runs, so if the
    //          object is resurrected in the finalizer the weak reference is
    //          still zeroed.
    // WeakTrackResurrection - Same as weak, but stays until after object is
    //          really gone.
    // Pinned - same as normal, but allows the address of the actual object
    //          to be taken.
    //
    /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle"]/*' />
	[System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    public struct GCHandle
    {
        // Allocate a handle storing the object and the type.
        internal GCHandle(Object value, GCHandleType type)
		{
			m_handle = InternalAlloc(value, type);

			// Record if the handle is pinned.
			if (type == GCHandleType.Pinned)
				m_handle |= 1;
		}  

		// Used in the conversion functions below.
		internal GCHandle(IntPtr handle)
		{
	        InternalCheckDomain((int) handle);
			m_handle = (int)handle;
		}

        // Creates a new GC handle for an object.
        //
        // value - The object that the GC handle is created for.
        // type - The type of GC handle to create.
        // 
        // returns a new GC handle that protects the object.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.Alloc"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static GCHandle Alloc(Object value)
        {
			return new GCHandle(value, GCHandleType.Normal);
        }

        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.Alloc1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static GCHandle Alloc(Object value, GCHandleType type)
        {
			return new GCHandle(value, type);
        }

        // Frees a GC handle.  The caller must provide synchronization to
        // prevent multiple threads from executing this simultaneously for
        // a given handle. If you modify this method please modify the 
        // __InternalFree also which is the internal without the linktime check.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.Free"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public void Free()
		{
			// Check if the handle was never initialized for was freed.
			if (m_handle == 0)
				throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

			// Free the handle.
			InternalFree(m_handle & ~0x1);
			m_handle = 0;
		}
		
		internal void __InternalFree()
		{
			// Check if the handle was never initialized for was freed.
			if (m_handle == 0)
				throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

			// Free the handle.
			InternalFree(m_handle & ~0x1);
			m_handle = 0;
		}

        // Target property - allows getting / updating of the handle's referent. If you modify this method

        // then modify the __InternalTarget too which is the internal method without the linktime check.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.Target"]/*' />
        public Object Target
        {
	        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get
            {
                // Check if the handle was never initialized or was freed.
				if (m_handle == 0)
					throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

                return InternalGet(m_handle & ~0x1);
            }
    
	        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            set
            {
                // Check if the handle was never initialized or was freed.
				if (m_handle == 0)
					throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

                InternalSet(m_handle & ~0x1, value, (m_handle & 0x1) != 0 /* isPinned */);
            }
        }
        
        internal Object __InternalTarget
        {
            get
            {
                // Check if the handle was never initialized or was freed.
				if (m_handle == 0)
					throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

                return InternalGet(m_handle & ~0x1);
            }
        }

        // Retrieve the address of an object in a Pinned handle.  This throws
        // an exception if the handle is any type other than Pinned.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.AddrOfPinnedObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr AddrOfPinnedObject()
		{
			// Check if the handle was not a pinned handle.
			if ((m_handle & 1) == 0)
			{
				// Check if the handle was never initialized for was freed.
				if (m_handle == 0)
					throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

				// You can only get the address of pinned handles.
				throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotPinned"));
			}

			// Get the address.
			return InternalAddrOfPinnedObject(m_handle & ~0x1);
		}

        // Determine whether this handle has been allocated or not.
		/// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.IsAllocated"]/*' />
		public bool IsAllocated
		{
			get
			{
				return m_handle != 0;
			}
		}

        // Used to create a GCHandle from an int.  This is intended to
        // be used with the reverse conversion.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.operatorGCHandle"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
    	public static explicit operator GCHandle(IntPtr value)
		{
            return new GCHandle(value);
        }

        // Used to get the internal integer representation of the handle out.
        /// <include file='doc\GcHandle.uex' path='docs/doc[@for="GCHandle.operatorIntPtr"]/*' />
        public static explicit operator IntPtr(GCHandle value)
        {
            return (IntPtr)value.m_handle;
        }

		// Internal native calls that this implementation uses.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal static extern int InternalAlloc(Object value, GCHandleType type);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalFree(int handle);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object InternalGet(int handle);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalSet(int handle, Object value, bool isPinned);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalCompareExchange(int handle, Object value, Object oldValue, bool isPinned);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal static extern IntPtr InternalAddrOfPinnedObject(int handle);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal static extern void InternalCheckDomain(int handle);


		// The actual integer handle value that the EE uses internally.
		private int m_handle;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\icustommarshaler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ICustomMarshaler
**
** Author: David Mortenson (dmortens)
**
** Purpose: This the base interface that must be implemented by all custom
**          marshalers.
**
** Date: August 19, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	using System;

    /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler"]/*' />
    public interface ICustomMarshaler
    {		
        /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler.MarshalNativeToManaged"]/*' />
        Object MarshalNativeToManaged( IntPtr pNativeData );

        /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler.MarshalManagedToNative"]/*' />
        IntPtr MarshalManagedToNative( Object ManagedObj );

        /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler.CleanUpNativeData"]/*' />
        void CleanUpNativeData( IntPtr pNativeData );

        /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler.CleanUpManagedData"]/*' />
        void CleanUpManagedData( Object ManagedObj );

        /// <include file='doc\ICustomMarshaler.uex' path='docs/doc[@for="ICustomMarshaler.GetNativeDataSize"]/*' />
        int GetNativeDataSize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\invalidolevarianttypeexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: InvalidOleVariantTypeException
**
** Purpose: The type of an OLE variant that was passed into the runtime is 
**			invalid.
**
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;
	using System.Runtime.Serialization;

    /// <include file='doc\InvalidOleVariantTypeException.uex' path='docs/doc[@for="InvalidOleVariantTypeException"]/*' />
    [Serializable] public class InvalidOleVariantTypeException : SystemException {
        /// <include file='doc\InvalidOleVariantTypeException.uex' path='docs/doc[@for="InvalidOleVariantTypeException.InvalidOleVariantTypeException"]/*' />
        public InvalidOleVariantTypeException() 
            : base(Environment.GetResourceString("Arg_InvalidOleVariantTypeException")) {
    		SetErrorCode(__HResults.COR_E_INVALIDOLEVARIANTTYPE);
        }
    
        /// <include file='doc\InvalidOleVariantTypeException.uex' path='docs/doc[@for="InvalidOleVariantTypeException.InvalidOleVariantTypeException1"]/*' />
        public InvalidOleVariantTypeException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDOLEVARIANTTYPE);
        }
    
        /// <include file='doc\InvalidOleVariantTypeException.uex' path='docs/doc[@for="InvalidOleVariantTypeException.InvalidOleVariantTypeException2"]/*' />
        public InvalidOleVariantTypeException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_INVALIDOLEVARIANTTYPE);
        }

        /// <include file='doc\InvalidOleVariantTypeException.uex' path='docs/doc[@for="InvalidOleVariantTypeException.InvalidOleVariantTypeException3"]/*' />
        protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\layoutkind.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System.Runtime.InteropServices {
	using System;
    // Used in the StructLayoutAttribute class
    /// <include file='doc\LayoutKind.uex' path='docs/doc[@for="LayoutKind"]/*' />
    [Serializable()] public enum LayoutKind
    {
        /// <include file='doc\LayoutKind.uex' path='docs/doc[@for="LayoutKind.Sequential"]/*' />
        Sequential		= 0, // 0x00000008,
        /// <include file='doc\LayoutKind.uex' path='docs/doc[@for="LayoutKind.Explicit"]/*' />
        Explicit		= 2, // 0x00000010,
        /// <include file='doc\LayoutKind.uex' path='docs/doc[@for="LayoutKind.Auto"]/*' />
        Auto			= 3, // 0x00000000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\itypelibconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ITypeLibConverter
**
** Author: David Mortenson(dmortens)
**
** Purpose: Methods used to convert a TypeLib to metadata and vice versa.
**
** Date: Dec 15, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;
    using System.Reflection;
    using System.Reflection.Emit;

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibImporterFlags"]/*' />
    [Serializable(),Flags()]
    public enum TypeLibImporterFlags 
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibImporterFlags.PrimaryInteropAssembly"]/*' />
        PrimaryInteropAssembly          = 0x00000001,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibImporterFlags.UnsafeInterfaces"]/*' />
        UnsafeInterfaces                = 0x00000002,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibImporterFlags.SafeArrayAsSystemArray"]/*' />
        SafeArrayAsSystemArray          = 0x00000004,
		TransformDispRetVals			= 0x00000008,
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibExporterFlags"]/*' />
    [Serializable(),Flags()]
    public enum TypeLibExporterFlags 
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="TypeLibExporterFlags.OnlyReferenceRegistered"]/*' />
        OnlyReferenceRegistered         = 0x00000001,
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ImporterEventKind"]/*' />
    [Serializable()] 
    public enum ImporterEventKind
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ImporterEventKind.NOTIF_TYPECONVERTED"]/*' />
        NOTIF_TYPECONVERTED = 0,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ImporterEventKind.NOTIF_CONVERTWARNING"]/*' />
        NOTIF_CONVERTWARNING = 1,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ImporterEventKind.ERROR_REFTOINVALIDTYPELIB"]/*' />
        ERROR_REFTOINVALIDTYPELIB = 2,
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ExporterEventKind"]/*' />
    [Serializable()] 
    public enum ExporterEventKind
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ExporterEventKind.NOTIF_TYPECONVERTED"]/*' />
        NOTIF_TYPECONVERTED = 0,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ExporterEventKind.NOTIF_CONVERTWARNING"]/*' />
        NOTIF_CONVERTWARNING = 1,
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ExporterEventKind.ERROR_REFTOINVALIDASSEMBLY"]/*' />
        ERROR_REFTOINVALIDASSEMBLY = 2
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibImporterNotifySink"]/*' />
    [GuidAttribute("F1C3BF76-C3E4-11d3-88E7-00902754C43A")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ITypeLibImporterNotifySink
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibImporterNotifySink.ReportEvent"]/*' />
        void ReportEvent(
                ImporterEventKind eventKind, 
                int eventCode,
                String eventMsg);
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibImporterNotifySink.ResolveRef"]/*' />
        Assembly ResolveRef(
                [MarshalAs(UnmanagedType.Interface)] Object typeLib);
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibExporterNotifySink"]/*' />
    [GuidAttribute("F1C3BF77-C3E4-11d3-88E7-00902754C43A")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ITypeLibExporterNotifySink 
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibExporterNotifySink.ReportEvent"]/*' />
        void ReportEvent(
                ExporterEventKind eventKind, 
                int eventCode,
                String eventMsg);

        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibExporterNotifySink.ResolveRef"]/*' />
        [return : MarshalAs(UnmanagedType.Interface)]
        Object ResolveRef(
                Assembly assembly);
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibConverter"]/*' />
    [GuidAttribute("F1C3BF78-C3E4-11d3-88E7-00902754C43A")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ITypeLibConverter
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibConverter.ConvertTypeLibToAssembly"]/*' />
        AssemblyBuilder ConvertTypeLibToAssembly(
                [MarshalAs(UnmanagedType.Interface)] Object typeLib, 
                String asmFileName,
                TypeLibImporterFlags flags, 
                ITypeLibImporterNotifySink notifySink,
                byte[] publicKey,
                StrongNameKeyPair keyPair,
                String asmNamespace,
                Version asmVersion);

        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibConverter.ConvertAssemblyToTypeLib"]/*' />
        [return : MarshalAs(UnmanagedType.Interface)] 
        Object ConvertAssemblyToTypeLib(
                Assembly assembly, 
                String typeLibName,
                TypeLibExporterFlags flags, 
                ITypeLibExporterNotifySink notifySink);

        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibConverter.GetPrimaryInteropAssembly"]/*' />
        bool GetPrimaryInteropAssembly(Guid g, Int32 major, Int32 minor, Int32 lcid, out String asmName, out String asmCodeBase);

        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibConverter.ConvertTypeLibToAssembly1"]/*' />
        AssemblyBuilder ConvertTypeLibToAssembly([MarshalAs(UnmanagedType.Interface)] Object typeLib, 
                                                String asmFileName,
                                                int flags,
                                                ITypeLibImporterNotifySink notifySink,
                                                byte[] publicKey,
                                                StrongNameKeyPair keyPair,
                                                bool unsafeInterfaces);
    }

    /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibExporterNameProvider"]/*' />
    [GuidAttribute("FA1F3615-ACB9-486d-9EAC-1BEF87E36B09")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ITypeLibExporterNameProvider
    {
        /// <include file='doc\ITypeLibConverter.uex' path='docs/doc[@for="ITypeLibExporterNameProvider.GetNames"]/*' />
        [return : MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)] 
        String[] GetNames(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\iregistrationservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: IRegistrationServices
**
** Author: David Mortenson(dmortens)
**
** Purpose: This interface provides services for registering and unregistering
**          a managed server for use by COM.
**
** Date: Nov 20, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="AssemblyRegistrationFlags"]/*' />
    [Flags()]
    public enum AssemblyRegistrationFlags
    {
        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="AssemblyRegistrationFlags.None"]/*' />
        None                    = 0x00000000,
        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="AssemblyRegistrationFlags.SetCodeBase"]/*' />
        SetCodeBase             = 0x00000001,
    }

    /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices"]/*' />
    [Guid("CCBD682C-73A5-4568-B8B0-C7007E11ABA2")]
    public interface IRegistrationServices
    {
        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.RegisterAssembly"]/*' />
        bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.UnregisterAssembly"]/*' />
        bool UnregisterAssembly(Assembly assembly);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.GetRegistrableTypesInAssembly"]/*' />
        Type[] GetRegistrableTypesInAssembly(Assembly assembly);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.GetProgIdForType"]/*' />
        String GetProgIdForType(Type type);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.RegisterTypeForComClients"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        void RegisterTypeForComClients(Type type, ref Guid g);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.GetManagedCategoryGuid"]/*' />
        Guid GetManagedCategoryGuid();

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.TypeRequiresRegistration"]/*' />
        bool TypeRequiresRegistration(Type type);

        /// <include file='doc\IRegistrationServices.uex' path='docs/doc[@for="IRegistrationServices.TypeRepresentsComType"]/*' />
        bool TypeRepresentsComType(Type type);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\invalidcomobjectexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: InvalidComObjectException
**
** Purpose: This exception is thrown when an invalid COM object is used. This
**			happens when a the __ComObject type is used directly without
**			having a backing class factory.
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\InvalidComObjectException.uex' path='docs/doc[@for="InvalidComObjectException"]/*' />
    [Serializable()] public class InvalidComObjectException : SystemException {
        /// <include file='doc\InvalidComObjectException.uex' path='docs/doc[@for="InvalidComObjectException.InvalidComObjectException"]/*' />
        public InvalidComObjectException() 
            : base(Environment.GetResourceString("Arg_InvalidComObjectException")) {
    		SetErrorCode(__HResults.COR_E_INVALIDCOMOBJECT);
        }
    
        /// <include file='doc\InvalidComObjectException.uex' path='docs/doc[@for="InvalidComObjectException.InvalidComObjectException1"]/*' />
        public InvalidComObjectException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDCOMOBJECT);
        }
    
        /// <include file='doc\InvalidComObjectException.uex' path='docs/doc[@for="InvalidComObjectException.InvalidComObjectException2"]/*' />
        public InvalidComObjectException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_INVALIDCOMOBJECT);
        }

        /// <include file='doc\InvalidComObjectException.uex' path='docs/doc[@for="InvalidComObjectException.InvalidComObjectException3"]/*' />
        protected InvalidComObjectException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\marshaldirectiveexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: MarshalDirectiveException
**
** Purpose: This exception is thrown when the marshaller encounters a signature
**          that has an invalid MarshalAs CA for a given argument or is not
**          supported.
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\MarshalDirectiveException.uex' path='docs/doc[@for="MarshalDirectiveException"]/*' />
    [Serializable()] public class MarshalDirectiveException : SystemException {
        /// <include file='doc\MarshalDirectiveException.uex' path='docs/doc[@for="MarshalDirectiveException.MarshalDirectiveException"]/*' />
        public MarshalDirectiveException() 
            : base(Environment.GetResourceString("Arg_MarshalDirectiveException")) {
    		SetErrorCode(__HResults.COR_E_MARSHALDIRECTIVE);
        }
    
        /// <include file='doc\MarshalDirectiveException.uex' path='docs/doc[@for="MarshalDirectiveException.MarshalDirectiveException1"]/*' />
        public MarshalDirectiveException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MARSHALDIRECTIVE);
        }
    
        /// <include file='doc\MarshalDirectiveException.uex' path='docs/doc[@for="MarshalDirectiveException.MarshalDirectiveException2"]/*' />
        public MarshalDirectiveException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MARSHALDIRECTIVE);
        }

        /// <include file='doc\MarshalDirectiveException.uex' path='docs/doc[@for="MarshalDirectiveException.MarshalDirectiveException3"]/*' />
        protected MarshalDirectiveException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\objectcreationdelegate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Delegate: ObjectCreationDelegate
**
** Author: Rudi Martin (rudim)
**
** Purpose: Delegate called to create a classic COM object as an alternative to
**          CoCreateInstance.
**
** Date: May 27, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    // Delegate called when a managed object wishes to instantiate its unmanaged
    // portion. The IUnknown of the managed object (the aggregator) is passed as a
    // parameter and the delegate should return the IUnknown of the unmanaged object
    // (the aggregatee). Both are passed as int's to avoid any marshalling.
    /// <include file='doc\ObjectCreationDelegate.uex' path='docs/doc[@for="ObjectCreationDelegate"]/*' />
    public delegate IntPtr ObjectCreationDelegate(IntPtr aggregator);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\pinvokemap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// PInvokeMap is an enum that defines the PInvoke attributes.  These
//	values are defined in CorHdr.h.
//
// Author: meichint
// Date: Sep 99
//
namespace System.Runtime.InteropServices {
	using System.Runtime.InteropServices;
	using System;
	// This Enum matchs the CorPinvokeMap defined in CorHdr.h
	/// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap"]/*' />
    [Serializable()] 
	internal enum PInvokeMap
    {
    	/// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.NoMangle"]/*' />
    	NoMangle			= 0x0001,	// Pinvoke is to use the member name as specified.
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CharSetMask"]/*' />
        CharSetMask			= 0x0006,	// Heuristic used in data type & name mapping.
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CharSetNotSpec"]/*' />
        CharSetNotSpec		= 0x0000,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CharSetAnsi"]/*' />
        CharSetAnsi			= 0x0002, 
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CharSetUnicode"]/*' />
        CharSetUnicode		= 0x0004,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CharSetAuto"]/*' />
        CharSetAuto			= 0x0006,
    
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.PinvokeOLE"]/*' />
        PinvokeOLE			= 0x0020,	// Heuristic: pinvoke will return hresult, with return value becoming the retval param. Not relevant for fields. 
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.SupportsLastError"]/*' />
        SupportsLastError	= 0x0040,	// Information about target function. Not relevant for fields.

        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.BestFitMask"]/*' />
        BestFitMask       = 0x0030,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.BestFitEnabled"]/*' />
        BestFitEnabled    = 0x0010,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.BestFitDisabled"]/*' />
        BestFitDisabled   = 0x0020,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.BestFitUseAsm"]/*' />
        BestFitUseAsm     = 0x0030,
    
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.ThrowOnUnmappableCharMask"]/*' />
        ThrowOnUnmappableCharMask       = 0x3000,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.ThrowOnUnmappableCharEnabled"]/*' />
        ThrowOnUnmappableCharEnabled    = 0x1000,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.ThrowOnUnmappableCharDisabled"]/*' />
        ThrowOnUnmappableCharDisabled   = 0x2000,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.ThrowOnUnmappableCharUseAsm"]/*' />
        ThrowOnUnmappableCharUseAsm     = 0x3000,
    
        // None of the calling convention flags is relevant for fields.
		/// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvMask"]/*' />
		CallConvMask		= 0x0700,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvWinapi"]/*' />
        CallConvWinapi		= 0x0100,	// Pinvoke will use native callconv appropriate to target windows platform.
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvCdecl"]/*' />
        CallConvCdecl		= 0x0200,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvStdcall"]/*' />
        CallConvStdcall		= 0x0300,
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvThiscall"]/*' />
        CallConvThiscall	= 0x0400,	// In M9, pinvoke will raise exception.
        /// <include file='doc\PInvokeMap.uex' path='docs/doc[@for="PInvokeMap.CallConvFastcall"]/*' />
        CallConvFastcall	= 0x0500,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\safearrayrankmismatchexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SafeArrayRankMismatchException
**
** Purpose: This exception is thrown when the runtime rank of a safe array
**			is different than the array rank specified in the metadata.
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\SafeArrayRankMismatchException.uex' path='docs/doc[@for="SafeArrayRankMismatchException"]/*' />
    [Serializable] public class SafeArrayRankMismatchException : SystemException {
        /// <include file='doc\SafeArrayRankMismatchException.uex' path='docs/doc[@for="SafeArrayRankMismatchException.SafeArrayRankMismatchException"]/*' />
        public SafeArrayRankMismatchException() 
            : base(Environment.GetResourceString("Arg_SafeArrayRankMismatchException")) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYRANKMISMATCH);
        }
    
        /// <include file='doc\SafeArrayRankMismatchException.uex' path='docs/doc[@for="SafeArrayRankMismatchException.SafeArrayRankMismatchException1"]/*' />
        public SafeArrayRankMismatchException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYRANKMISMATCH);
        }
    
        /// <include file='doc\SafeArrayRankMismatchException.uex' path='docs/doc[@for="SafeArrayRankMismatchException.SafeArrayRankMismatchException2"]/*' />
        public SafeArrayRankMismatchException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYRANKMISMATCH);
        }

        /// <include file='doc\SafeArrayRankMismatchException.uex' path='docs/doc[@for="SafeArrayRankMismatchException.SafeArrayRankMismatchException3"]/*' />
        protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\safearraytypemismatchexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SafeArrayTypeMismatchException
**
** Purpose: This exception is thrown when the runtime type of an array
**			is different than the safe array sub type specified in the 
**			metadata.
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\SafeArrayTypeMismatchException.uex' path='docs/doc[@for="SafeArrayTypeMismatchException"]/*' />
    [Serializable] public class SafeArrayTypeMismatchException : SystemException {
        /// <include file='doc\SafeArrayTypeMismatchException.uex' path='docs/doc[@for="SafeArrayTypeMismatchException.SafeArrayTypeMismatchException"]/*' />
        public SafeArrayTypeMismatchException() 
            : base(Environment.GetResourceString("Arg_SafeArrayTypeMismatchException")) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYTYPEMISMATCH);
        }
    
        /// <include file='doc\SafeArrayTypeMismatchException.uex' path='docs/doc[@for="SafeArrayTypeMismatchException.SafeArrayTypeMismatchException1"]/*' />
        public SafeArrayTypeMismatchException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYTYPEMISMATCH);
        }
    
        /// <include file='doc\SafeArrayTypeMismatchException.uex' path='docs/doc[@for="SafeArrayTypeMismatchException.SafeArrayTypeMismatchException2"]/*' />
        public SafeArrayTypeMismatchException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_SAFEARRAYTYPEMISMATCH);
        }

        /// <include file='doc\SafeArrayTypeMismatchException.uex' path='docs/doc[@for="SafeArrayTypeMismatchException.SafeArrayTypeMismatchException3"]/*' />
        protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\runtimeenvironment.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: DomainCreation
**
** Author: 
**
** Purpose: Runtime information
**          
** Date: March 3. 2001
**
=============================================================================*/

using System;
using System.Text;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Permissions;
using System.Reflection;

namespace System.Runtime.InteropServices {
    /// <include file='doc\RuntimeEnvironment.uex' path='docs/doc[@for="RuntimeEnvironment"]/*' />
    public class RuntimeEnvironment {

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetModuleFileName();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetDeveloperPath();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetHostBindingFile();

        [DllImport("mscoree.dll", CharSet=CharSet.Unicode, CallingConvention=CallingConvention.StdCall)]
        private static extern int GetCORVersion(StringBuilder sb, int BufferLength, ref int retLength);

        /// <include file='doc\RuntimeEnvironment.uex' path='docs/doc[@for="RuntimeEnvironment.FromGlobalAccessCache"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool FromGlobalAccessCache(Assembly a);
            
        /// <include file='doc\RuntimeEnvironment.uex' path='docs/doc[@for="RuntimeEnvironment.GetSystemVersion"]/*' />
        public static String GetSystemVersion()
        {
            StringBuilder s = new StringBuilder(256);
            int retLength = 0;
            if(GetCORVersion(s, 256, ref retLength) == 0)
                return s.ToString();
            else
                return null;
        }
        
        /// <include file='doc\RuntimeEnvironment.uex' path='docs/doc[@for="RuntimeEnvironment.GetRuntimeDirectory"]/*' />
        public static String GetRuntimeDirectory()
        {
            String dir = GetRuntimeDirectoryImpl();
            new FileIOPermission(FileIOPermissionAccess.PathDiscovery, dir).Demand();
            return dir;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetRuntimeDirectoryImpl();
        
        // Returns the system ConfigurationFile
        /// <include file='doc\RuntimeEnvironment.uex' path='docs/doc[@for="RuntimeEnvironment.SystemConfigurationFile"]/*' />
        public static String SystemConfigurationFile {
            get {
                StringBuilder sb = new StringBuilder(Path.MAX_PATH);
                sb.Append(GetRuntimeDirectory());
                sb.Append(AppDomainSetup.RuntimeConfigurationFile);
                String path = sb.ToString();
                
                // Do security check
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, path).Demand();

                return path;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\registrationservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: RegistrationServices
**
** Author: David Mortenson(dmortens)
**
** Purpose: This class provides services for registering and unregistering
**          a managed server for use by COM.
**
** Date: Jan 28, 2000
**
**
** Changed by Junfeng Zhang(juzhang)
**
** Change the way how to register and unregister a managed server
**
** Date: Jan 23, 2002
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using Microsoft.Win32;
    using System.Runtime.CompilerServices;
    using System.Globalization;

    /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices"]/*' />
    [Guid("475E398F-8AFA-43a7-A3BE-F4EF8D6787C9")]
    [ClassInterface(ClassInterfaceType.None)]
    public class RegistrationServices : IRegistrationServices
    {
        private const String strManagedCategoryGuid = "{62C8FE65-4EBB-45e7-B440-6E39B2CDBF29}";
        private const String strDocStringPrefix = "";
        private const String strManagedTypeThreadingModel = "Both";
        private const String strComponentCategorySubKey = "Component Categories";
        private const String strManagedCategoryDescription = ".NET Category";
        private const String strMsCorEEFileName = "mscoree.dll";
        private const String strRecordRootName = "Record";
                
        private static Guid s_ManagedCategoryGuid = new Guid(strManagedCategoryGuid);

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.RegisterAssembly"]/*' />
        public virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags)
        {
            // Validate the arguments.
            if (assembly == null)
                throw new ArgumentNullException("assembly");

            // Retrieve the assembly names.
            String strAsmName = assembly.FullName;
            if (strAsmName == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NoAsmName"));

            // Retrieve the assembly version
            String strAsmVersion = assembly.GetName().Version.ToString();
            
            // Retrieve the runtime version used to build the assembly.
            String strRuntimeVersion = assembly.ImageRuntimeVersion;

            // Retrieve the assembly codebase.
            String strAsmCodeBase = null;
            if ((flags & AssemblyRegistrationFlags.SetCodeBase) != 0)
            {
                strAsmCodeBase = assembly.CodeBase;
                if (strAsmCodeBase == null)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NoAsmCodeBase"));
            }

            // Go through all the registrable types in the assembly and register them.
            Type[] aTypes = GetRegistrableTypesInAssembly(assembly);
            int NumTypes = aTypes.Length;
            for (int cTypes = 0; cTypes < NumTypes; cTypes++)
            {
                if (aTypes[cTypes].IsValueType)
                    RegisterValueType(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase);
                else if (TypeRepresentsComType(aTypes[cTypes]))
                    RegisterComImportedType(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase, strRuntimeVersion);
                else
                    RegisterManagedType(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase, strRuntimeVersion);

                CallUserDefinedRegistrationMethod(aTypes[cTypes], true);
            }

            // If this assembly has the PIA attribute, then register it as a PIA.
            Object[] aPIAAttrs = assembly.GetCustomAttributes(typeof(PrimaryInteropAssemblyAttribute), false);
            int NumPIAAttrs = aPIAAttrs.Length;
            for (int cPIAAttrs = 0; cPIAAttrs < NumPIAAttrs; cPIAAttrs++)
                RegisterPrimaryInteropAssembly(assembly, strAsmCodeBase, (PrimaryInteropAssemblyAttribute)aPIAAttrs[cPIAAttrs]);

            // Return value indicating if we actually registered any types.
            if (aTypes.Length > 0 || NumPIAAttrs > 0)
                return true;
            else 
                return false;
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.UnregisterAssembly"]/*' />
        public virtual bool UnregisterAssembly(Assembly assembly)
        {
            bool bAllVersionsGone = true;;
            
            // Validate the arguments.
            if (assembly == null)
                throw new ArgumentNullException("assembly");

            // Retrieve the assembly version
            String strAsmVersion = assembly.GetName().Version.ToString();

            // Go through all the registrable types in the assembly and register them.
            Type[] aTypes = GetRegistrableTypesInAssembly(assembly);
            int NumTypes = aTypes.Length;
            for (int cTypes = 0; cTypes < NumTypes; cTypes++)
            {
                CallUserDefinedRegistrationMethod(aTypes[cTypes], false);

                if (aTypes[cTypes].IsValueType)
                {
                    if (!UnregisterValueType(aTypes[cTypes], strAsmVersion))
                        bAllVersionsGone = false;
                }
                else if (TypeRepresentsComType(aTypes[cTypes]))
                {
                    if (!UnregisterComImportedType(aTypes[cTypes], strAsmVersion))
                        bAllVersionsGone = false;
                }
                else
                {
                    if (!UnregisterManagedType(aTypes[cTypes], strAsmVersion))
                        bAllVersionsGone = false;
                }
            }

            // If this assembly has the PIA attribute, then unregister it as a PIA.
            Object[] aPIAAttrs = assembly.GetCustomAttributes(typeof(PrimaryInteropAssemblyAttribute), false);
            int NumPIAAttrs = aPIAAttrs.Length;
            if (bAllVersionsGone)
            {
                for (int cPIAAttrs = 0; cPIAAttrs < NumPIAAttrs; cPIAAttrs++)
                    UnregisterPrimaryInteropAssembly(assembly, (PrimaryInteropAssemblyAttribute)aPIAAttrs[cPIAAttrs]);
            }

            // Return value indicating if we actually un-registered any types.
            if (aTypes.Length > 0 || NumPIAAttrs > 0)
                return true;
            else 
                return false;
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.GetRegistrableTypesInAssembly"]/*' />
        public virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly)
        {
            // Validate the arguments.
            if (assembly == null)
                throw new ArgumentNullException("assembly");

            // Retrieve the list of types in the assembly.
            Type[] aTypes = assembly.GetExportedTypes();
            int NumTypes = aTypes.Length;

            // Create an array list that will be filled in.
            ArrayList TypeList = new ArrayList();

            // Register all the types that require registration.
            for (int cTypes = 0; cTypes < NumTypes; cTypes++)
            {
                Type CurrentType = aTypes[cTypes];
                if (TypeRequiresRegistration(CurrentType))
                    TypeList.Add(CurrentType);
            }

            // Copy the array list to an array and return it.
            Type[] RetArray = new Type[TypeList.Count];
            TypeList.CopyTo(RetArray);
            return RetArray;
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.GetProgIdForType"]/*' />
        public virtual String GetProgIdForType(Type type)
        {
            return Marshal.GenerateProgIdForType(type);
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.RegisterTypeForComClients"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public virtual void RegisterTypeForComClients(Type type, ref Guid g)
        {
            if (type == null)
                throw new ArgumentNullException("type");

            if(Thread.CurrentThread.ApartmentState == ApartmentState.Unknown)
            {
                Thread.CurrentThread.ApartmentState = ApartmentState.MTA;
            }
            
            // Call the native method to do CoRegisterClassObject
            RegisterTypeForComClientsNative(type, ref g);
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.GetManagedCategoryGuid"]/*' />
        public virtual Guid GetManagedCategoryGuid()
        {
            return s_ManagedCategoryGuid;
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.TypeRequiresRegistration"]/*' />
        public virtual bool TypeRequiresRegistration(Type type)
        {
            return TypeRequiresRegistrationHelper(type);
        }

        /// <include file='doc\RegistrationServices.uex' path='docs/doc[@for="RegistrationServices.TypeRepresentsComType"]/*' />
        public virtual bool TypeRepresentsComType(Type type)
        {
            // If the type is not a COM import, then it does not represent a COM type.
            if (!type.IsCOMObject)
                return false;

            // If it is marked as tdImport, then it represents a COM type directly.
            if (type.IsImport)
                return true;

            // If the type is derived from a tdImport class and has the same GUID as the
            // imported class, then it represents a COM type.
            Type baseComImportType = GetBaseComImportType(type);
            BCLDebug.Assert(baseComImportType != null, "baseComImportType != null");
            if (Marshal.GenerateGuidForType(type) == Marshal.GenerateGuidForType(baseComImportType))
                return true;

            return false;
        }

        private void RegisterValueType(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase)
        {
            // Retrieve some information that will be used during the registration process.
            String strRecordId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper() + "}";

            // Create the HKEY_CLASS_ROOT\Record key.
            RegistryKey RecordRootKey = Registry.ClassesRoot.CreateSubKey(strRecordRootName);

            // Create the HKEY_CLASS_ROOT\Record\<RecordID> key.
            RegistryKey RecordKey = RecordRootKey.CreateSubKey(strRecordId);

            // Create the HKCR\Record\<RecordId>\<version> key.
            RegistryKey RecordVersionKey = RecordKey.CreateSubKey(strAsmVersion);
            
            // Set the class value.
            RecordVersionKey.SetValue("Class", type.FullName);

            // Set the assembly value.
            RecordVersionKey.SetValue("Assembly", strAsmName);

            // Set the assembly code base value if a code base was specified.
            if (strAsmCodeBase != null)
                RecordVersionKey.SetValue("CodeBase", strAsmCodeBase);
            
            // Close the registry keys.
            RecordVersionKey.Close();
            RecordKey.Close();
            RecordRootKey.Close();
        }

        private void RegisterManagedType(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase, String strRuntimeVersion)
        {
            //
            // Retrieve some information that will be used during the registration process.
            //

            String strDocString = strDocStringPrefix + type.FullName;
            String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            String strProgId = GetProgIdForType(type);


            //
            // Write the actual type information in the registry.
            //

            if (strProgId != String.Empty)
            {
                // Create the HKEY_CLASS_ROOT\<wzProgId> key.
                RegistryKey TypeNameKey = Registry.ClassesRoot.CreateSubKey(strProgId);
                TypeNameKey.SetValue("", strDocString);

                // Create the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                RegistryKey ProgIdClsIdKey = TypeNameKey.CreateSubKey("CLSID");
                ProgIdClsIdKey.SetValue("", strClsId);
                ProgIdClsIdKey.Close();

                // Close HKEY_CLASS_ROOT\<wzProgId> key.
                TypeNameKey.Close();
            }

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
            RegistryKey ClsIdRootKey = Registry.ClassesRoot.CreateSubKey("CLSID");
            RegistryKey ClsIdKey = ClsIdRootKey.CreateSubKey(strClsId);
            ClsIdKey.SetValue("", strDocString);

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32 key.
            RegistryKey InProcServerKey = ClsIdKey.CreateSubKey("InprocServer32");
            InProcServerKey.SetValue("", strMsCorEEFileName);
            InProcServerKey.SetValue("ThreadingModel", strManagedTypeThreadingModel);
            InProcServerKey.SetValue("Class", type.FullName);
            InProcServerKey.SetValue("Assembly", strAsmName);
            InProcServerKey.SetValue("RuntimeVersion", strRuntimeVersion);
            if (strAsmCodeBase != null)
                InProcServerKey.SetValue("CodeBase", strAsmCodeBase);

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32\<Version> subkey
            RegistryKey VersionSubKey = InProcServerKey.CreateSubKey(strAsmVersion);
            VersionSubKey.SetValue("Class", type.FullName);
            VersionSubKey.SetValue("Assembly", strAsmName);
            VersionSubKey.SetValue("RuntimeVersion", strRuntimeVersion);
            if (strAsmCodeBase != null)
                VersionSubKey.SetValue("CodeBase", strAsmCodeBase);

            if (strProgId != String.Empty)
            {
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\ProdId key.
                RegistryKey ProgIdKey = ClsIdKey.CreateSubKey("ProgId");
                ProgIdKey.SetValue("", strProgId);
                ProgIdKey.Close();
            }

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\Implemented Categories\<Managed Category Guid> key.
            RegistryKey CategoryKey = ClsIdKey.CreateSubKey("Implemented Categories");
            RegistryKey ManagedCategoryKey = CategoryKey.CreateSubKey(strManagedCategoryGuid);
            ManagedCategoryKey.Close();
            CategoryKey.Close();


            //
            // Ensure that the managed category exists.
            //

            EnsureManagedCategoryExists();
            

            //
            // Close the opened registry keys.
            //

            VersionSubKey.Close();
            InProcServerKey.Close();
            ClsIdKey.Close();
            ClsIdRootKey.Close();
        } 
        
        private void RegisterComImportedType(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase, String strRuntimeVersion)
        {
            // Retrieve some information that will be used during the registration process.
            String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
            RegistryKey ClsIdRootKey = Registry.ClassesRoot.CreateSubKey("CLSID");
            RegistryKey ClsIdKey = ClsIdRootKey.CreateSubKey(strClsId);

            // Create the InProcServer32 key.
            RegistryKey InProcServerKey = ClsIdKey.CreateSubKey("InprocServer32");

            // Set the class value.
            InProcServerKey.SetValue("Class", type.FullName);

            // Set the assembly value.
            InProcServerKey.SetValue("Assembly", strAsmName);

            // Set the runtime version value.
            InProcServerKey.SetValue("RuntimeVersion", strRuntimeVersion);

            // Set the assembly code base value if a code base was specified.
            if (strAsmCodeBase != null)
                InProcServerKey.SetValue("CodeBase", strAsmCodeBase);

            // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32\<Version> subkey
            RegistryKey VersionSubKey = InProcServerKey.CreateSubKey(strAsmVersion);

            VersionSubKey.SetValue("Class", type.FullName);
            VersionSubKey.SetValue("Assembly", strAsmName);
            VersionSubKey.SetValue("RuntimeVersion", strRuntimeVersion);
            if (strAsmCodeBase != null)
                VersionSubKey.SetValue("CodeBase", strAsmCodeBase);

            // Close the registry keys.
            VersionSubKey.Close();
            InProcServerKey.Close();
            ClsIdKey.Close();
            ClsIdRootKey.Close();
        }

        private bool UnregisterValueType(Type type, String strAsmVersion)
        {
            // Try to open the HKEY_CLASS_ROOT\Record key.
            String strRecordId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            bool bAllVersionsGone = true;
            
            RegistryKey RecordRootKey = Registry.ClassesRoot.OpenSubKey(strRecordRootName, true);
            if (RecordRootKey != null)
            {
                // Open the HKEY_CLASS_ROOT\Record\{RecordId} key.
                RegistryKey RecordKey = RecordRootKey.OpenSubKey(strRecordId, true);
                if (RecordKey != null)
                {
                    // Delete the values we created.
                    RecordKey.DeleteValue("Assembly", false);
                    RecordKey.DeleteValue("Class", false);
                    RecordKey.DeleteValue("CodeBase", false);

                    RegistryKey VersionSubKey = RecordKey.OpenSubKey(strAsmVersion, true);
                    if (VersionSubKey != null)
                    {
                        // Delete the values we created.
                        VersionSubKey.DeleteValue("Assembly", false);
                        VersionSubKey.DeleteValue("Class", false);
                        VersionSubKey.DeleteValue("CodeBase", false);

                        // delete the version sub key if no value or subkeys under it
                        if ((VersionSubKey.SubKeyCount == 0) && (VersionSubKey.ValueCount == 0))
                            RecordKey.DeleteSubKey(strAsmVersion);

                        // close the key
                        VersionSubKey.Close();
                    }

                    // If there are sub keys left then there are versions left.
                    if (RecordKey.SubKeyCount != 0)
                        bAllVersionsGone = false;

                    // If there are no other values or subkeys then we can delete the HKEY_CLASS_ROOT\Record\{RecordId}.
                    if ((RecordKey.SubKeyCount == 0) && (RecordKey.ValueCount == 0))
                        RecordRootKey.DeleteSubKey(strRecordId);

                    // Close the key.
                    RecordKey.Close();
                }

                // If there are no other values or subkeys then we can delete the HKEY_CLASS_ROOT\Record.
                if ((RecordRootKey.SubKeyCount == 0) && (RecordRootKey.ValueCount == 0))
                    Registry.ClassesRoot.DeleteSubKey(strRecordRootName);

                // Close the key.
                RecordRootKey.Close();
            }
            
            return bAllVersionsGone;
        }

        // UnregisterManagedType
        //
        // Return :
        //      true:   All versions are gone.
        //      false:  Some versions are still left in registry
        private bool UnregisterManagedType(Type type, String strAsmVersion)
        {
            //
            // Create the CLSID string.
            //

            String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper() + "}";
            String strProgId = GetProgIdForType(type);
            bool bAllVersionsGone= true;


            //
            // Remove the entries under HKEY_CLASS_ROOT\CLSID\<CLSID> key.
            //

            RegistryKey ClsIdRootKey = Registry.ClassesRoot.OpenSubKey("CLSID", true);
            if (ClsIdRootKey != null)
            {
                RegistryKey ClsIdKey = ClsIdRootKey.OpenSubKey(strClsId, true);
                if (ClsIdKey != null)
                {
                    //
                    // Remove the entries in the HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32 key.
                    //

                    // Open the InProcServer32 key.
                    RegistryKey InProcServerKey = ClsIdKey.OpenSubKey("InprocServer32", true);
                    if (InProcServerKey != null)
                    {
                        //
                        // Remove the entries in HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32\<Version>
                        //
                        RegistryKey VersionSubKey = InProcServerKey.OpenSubKey(strAsmVersion, true);
                        if (VersionSubKey != null)
                        {
                            // Delete the values we created
                            VersionSubKey.DeleteValue("Assembly", false);
                            VersionSubKey.DeleteValue("Class", false);
                            VersionSubKey.DeleteValue("RuntimeVersion", false);
                            VersionSubKey.DeleteValue("CodeBase", false);

                            // If there are no other values or subkeys then we can delete the VersionSubKey.
                            if ((VersionSubKey.SubKeyCount == 0) && (VersionSubKey.ValueCount == 0))
                                InProcServerKey.DeleteSubKey(strAsmVersion);

                            // Close the key.
                            VersionSubKey.Close();
                        }

                        // If there are sub keys left then there are versions left.
                        if (InProcServerKey.SubKeyCount != 0)
                            bAllVersionsGone = false;

                        // If there are no versions left, then delete the threading model and default value.
                        if (bAllVersionsGone)
                        {
                            InProcServerKey.DeleteValue("", false);
                            InProcServerKey.DeleteValue("ThreadingModel", false);
                        }

                        InProcServerKey.DeleteValue("Assembly", false);
                        InProcServerKey.DeleteValue("Class", false);
                        InProcServerKey.DeleteValue("RuntimeVersion", false);
                        InProcServerKey.DeleteValue("CodeBase", false);

                        // If there are no other values or subkeys then we can delete the InProcServerKey.
                        if ((InProcServerKey.SubKeyCount == 0) && (InProcServerKey.ValueCount == 0))
                            ClsIdKey.DeleteSubKey("InprocServer32");
    
                        // Close the key.
                        InProcServerKey.Close();
                    }

                    // remove HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId
                    // and HKEY_CLASS_ROOT\CLSID\<CLSID>\Implemented Category
                    // only when all versions are removed
                    if (bAllVersionsGone)
                    {
                        // Delete the value we created.
                        ClsIdKey.DeleteValue("", false);

                        if (strProgId != String.Empty)
                        {
                            //
                            // Remove the entries in the HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId key.
                            //

                            RegistryKey ProgIdKey = ClsIdKey.OpenSubKey("ProgId", true);
                            if (ProgIdKey != null)
                            {
                                // Delete the value we created.
                                ProgIdKey.DeleteValue("", false);

                                // If there are no other values or subkeys then we can delete the ProgIdSubKey.
                                if ((ProgIdKey.SubKeyCount == 0) && (ProgIdKey.ValueCount == 0))
                                    ClsIdKey.DeleteSubKey("ProgId");
    
                                // Close the key.
                                ProgIdKey.Close();
                            }
                        }
            
        
                        //
                        // Remove entries in the  HKEY_CLASS_ROOT\CLSID\<CLSID>\Implemented Categories\<Managed Category Guid> key.
                        //
    
                        RegistryKey CategoryKey = ClsIdKey.OpenSubKey("Implemented Categories", true);
                        if (CategoryKey != null)
                        {
                            RegistryKey ManagedCategoryKey = CategoryKey.OpenSubKey(strManagedCategoryGuid, true);
                            if (ManagedCategoryKey != null)
                            {
                                // If there are no other values or subkeys then we can delete the ManagedCategoryKey.
                                if ((ManagedCategoryKey.SubKeyCount == 0) && (ManagedCategoryKey.ValueCount == 0))
                                    CategoryKey.DeleteSubKey(strManagedCategoryGuid);

                                // Close the key.
                                ManagedCategoryKey.Close();
                            }

                            // If there are no other values or subkeys then we can delete the CategoryKey.
                            if ((CategoryKey.SubKeyCount == 0) && (CategoryKey.ValueCount == 0))
                                ClsIdKey.DeleteSubKey("Implemented Categories");

                            // Close the key.
                            CategoryKey.Close();
                        }
                    }

                    // If there are no other values or subkeys then we can delete the ClsIdKey.
                    if ((ClsIdKey.SubKeyCount == 0) && (ClsIdKey.ValueCount == 0))
                    {
                        ClsIdRootKey.DeleteSubKey(strClsId);
                    }

                    // Close the key.
                    ClsIdKey.Close();
                }

                ClsIdRootKey.Close();
            }


            //
            // Remove the entries under HKEY_CLASS_ROOT\<wzProgId> key.
            //

            if (bAllVersionsGone)
            {
                if (strProgId != String.Empty)
                {
                    RegistryKey TypeNameKey = Registry.ClassesRoot.OpenSubKey(strProgId, true);
                    if (TypeNameKey != null)
                    {
                        // Delete the values we created.
                        TypeNameKey.DeleteValue("", false);


                        //
                        // Remove the entries in the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                        //

                        RegistryKey ProgIdClsIdKey = TypeNameKey.OpenSubKey("CLSID", true);
                        if (ProgIdClsIdKey != null)
                        {
                            // Delete the values we created.
                            ProgIdClsIdKey.DeleteValue("", false);

                            // If there are no other values or subkeys then we can delete the ProgIdClsIdKey.
                            if ((ProgIdClsIdKey.SubKeyCount == 0) && (ProgIdClsIdKey.ValueCount == 0))
                                TypeNameKey.DeleteSubKey("CLSID");

                            // Close the key.
                            ProgIdClsIdKey.Close();
                        }

                        // If there are no other values or subkeys then we can delete the TypeNameKey.
                        if ((TypeNameKey.SubKeyCount == 0) && (TypeNameKey.ValueCount == 0))
                            Registry.ClassesRoot.DeleteSubKey(strProgId);

                        // Close the key.
                        TypeNameKey.Close();
                    }
                }
            }

            return bAllVersionsGone;
       }

        // UnregisterComImportedType
        // Return:
        //      true:      All version information are gone.
        //      false:     There are still some version left in registry
        private bool UnregisterComImportedType(Type type, String strAsmVersion)
        {
            // Try to open the <CLSID> key.
            String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            bool bAllVersionsGone = true;
            
            RegistryKey ClsIdRootKey = Registry.ClassesRoot.OpenSubKey("CLSID", true);
            if (ClsIdRootKey != null)
            {
                RegistryKey ClsIdKey = ClsIdRootKey.OpenSubKey(strClsId, true);
                if (ClsIdKey != null)
                {
                    // Open the InProcServer32 key.
                    RegistryKey InProcServerKey = ClsIdKey.OpenSubKey("InprocServer32", true);
                    if (InProcServerKey != null)
                    {
                        // Delete the values we created.
                        InProcServerKey.DeleteValue("Assembly", false);
                        InProcServerKey.DeleteValue("Class", false);
                        InProcServerKey.DeleteValue("RuntimeVersion", false);
                        InProcServerKey.DeleteValue("CodeBase", false);
                        
                        // Remove the entries in HKEY_CLASS_ROOT\CLSID\<CLSID>\<Version>
                        RegistryKey VersionSubKey = InProcServerKey.OpenSubKey(strAsmVersion, true);
                        if (VersionSubKey != null)
                        {
                            // Delete the value we created
                            VersionSubKey.DeleteValue("Assembly", false);
                            VersionSubKey.DeleteValue("Class", false);
                            VersionSubKey.DeleteValue("RuntimeVersion", false);
                            VersionSubKey.DeleteValue("CodeBase", false);

                            // If there are no other values or subkeys then we can delete the VersionSubKey
                            if ((VersionSubKey.SubKeyCount == 0) && (VersionSubKey.ValueCount == 0))
                                InProcServerKey.DeleteSubKey(strAsmVersion);
                        }

                        // If there are sub keys left then there are versions left.
                        if (InProcServerKey.SubKeyCount != 0)
                            bAllVersionsGone = false;

                        // If there are no other values or subkeys then we can delete the InProcServerKey.
                        if ((InProcServerKey.SubKeyCount == 0) && (InProcServerKey.ValueCount == 0))
                            ClsIdKey.DeleteSubKey("InprocServer32");

                        // Close the key.
                        InProcServerKey.Close();
                    }

                    // If there are no other values or subkeys then we can delete the ClsIdKey.
                    if ((ClsIdKey.SubKeyCount == 0) && (ClsIdKey.ValueCount == 0))
                        Registry.ClassesRoot.OpenSubKey("CLSID", true).DeleteSubKey(strClsId);

                    // Close the ClsIdKey.
                    ClsIdKey.Close();
                }

                // Close the ClsIdRootKey.
                ClsIdRootKey.Close();
            }

            return bAllVersionsGone;
        }

        private void RegisterPrimaryInteropAssembly(Assembly assembly, String strAsmCodeBase, PrimaryInteropAssemblyAttribute attr)
        {
            // Validate that the PIA has a strong name.
            if (assembly.nGetPublicKey() == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_PIAMustBeStrongNamed"));

            String strTlbId = "{" + Marshal.GetTypeLibGuidForAssembly(assembly).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            String strVersion = attr.MajorVersion + "." + attr.MinorVersion;

            // Create the HKEY_CLASS_ROOT\TypeLib<TLBID> key.
            RegistryKey TypeLibRootKey = Registry.ClassesRoot.CreateSubKey("TypeLib");
            RegistryKey TypeLibKey = TypeLibRootKey.CreateSubKey(strTlbId);

            // Create the HKEY_CLASS_ROOT\TypeLib<TLBID>\<Major.Minor> key.
            RegistryKey VersionKey = TypeLibKey.CreateSubKey(strVersion);

            // Create the HKEY_CLASS_ROOT\TypeLib<TLBID>\PrimaryInteropAssembly key.
            VersionKey.SetValue("PrimaryInteropAssemblyName", assembly.FullName);
            if (strAsmCodeBase != null)
                VersionKey.SetValue("PrimaryInteropAssemblyCodeBase", strAsmCodeBase);

            // Close the registry keys.
            VersionKey.Close();
            TypeLibKey.Close();
            TypeLibRootKey.Close();
        }

        private void UnregisterPrimaryInteropAssembly(Assembly assembly, PrimaryInteropAssemblyAttribute attr)
        {
            String strTlbId = "{" + Marshal.GetTypeLibGuidForAssembly(assembly).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            String strVersion = attr.MajorVersion + "." + attr.MinorVersion;
                
            // Try to open the HKEY_CLASS_ROOT\TypeLib key.
            RegistryKey TypeLibRootKey = Registry.ClassesRoot.OpenSubKey("TypeLib", true);
            if (TypeLibRootKey != null)
            {
                // Try to open the HKEY_CLASS_ROOT\TypeLib\<TLBID> key.
                RegistryKey TypeLibKey = TypeLibRootKey.OpenSubKey(strTlbId);
                if (TypeLibKey != null)
                {
                    // Try to open the HKEY_CLASS_ROOT\TypeLib<TLBID>\<Major.Minor> key.
                    RegistryKey VersionKey = TypeLibKey.OpenSubKey(strVersion, true);
                    if (VersionKey != null)
                    {
                        // Delete the values we created.
                        VersionKey.DeleteValue("PrimaryInteropAssemblyName", false);
                        VersionKey.DeleteValue("PrimaryInteropAssemblyCodeBase", false);

                        // If there are no other values or subkeys then we can delete the VersionKey.
                        if ((VersionKey.SubKeyCount == 0) && (VersionKey.ValueCount == 0))
                            TypeLibKey.DeleteSubKey(strVersion);

                        // Close the key.
                        VersionKey.Close();
                    }

                    // If there are no other values or subkeys then we can delete the TypeLibKey.
                    if ((TypeLibKey.SubKeyCount == 0) && (TypeLibKey.ValueCount == 0))
                        TypeLibRootKey.DeleteSubKey(strTlbId);

                    // Close the TypeLibKey.
                    TypeLibKey.Close();
                }

                // Close the TypeLibRootKey.
                TypeLibRootKey.Close();
            }
        }

        private void EnsureManagedCategoryExists()
        {
            // Create the HKEY_CLASS_ROOT\Component Category key.
            RegistryKey CompCategoryKey = Registry.ClassesRoot.CreateSubKey(strComponentCategorySubKey);

            // Create the HKEY_CLASS_ROOT\Component Category\<Managed Category Guid> key.
            RegistryKey ManagedCategoryKey = CompCategoryKey.CreateSubKey(strManagedCategoryGuid);
            ManagedCategoryKey.SetValue("0", strManagedCategoryDescription);
            ManagedCategoryKey.Close();

            // Close the HKEY_CLASS_ROOT\Component Category key.
            CompCategoryKey.Close();
        }

        private void CallUserDefinedRegistrationMethod(Type type, bool bRegister)
        {
            bool bFunctionCalled = false;

            // Retrieve the attribute type to use to determine if a function is the requested user defined
            // registration function.
            Type RegFuncAttrType = null;
            if (bRegister)
                RegFuncAttrType = typeof(ComRegisterFunctionAttribute);
            else 
                RegFuncAttrType = typeof(ComUnregisterFunctionAttribute);

            for (Type currType = type; !bFunctionCalled && currType != null; currType = currType.BaseType)
            {
                // Retrieve all the methods.
                MethodInfo[] aMethods = currType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                int NumMethods = aMethods.Length;

                // Go through all the methods and check for the ComRegisterMethod custom attribute.
                for (int cMethods = 0; cMethods < NumMethods; cMethods++)
                {
                    MethodInfo CurrentMethod = aMethods[cMethods];

                    // Check to see if the method has the custom attribute.
                    if (CurrentMethod.GetCustomAttributes(RegFuncAttrType, true).Length != 0)
                    {
                        // Check to see if the method is static before we call it.
                        if (!CurrentMethod.IsStatic)
                        {
                            if (bRegister)
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_NonStaticComRegFunction"), CurrentMethod.Name, currType.Name));
                            else
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_NonStaticComUnRegFunction"), CurrentMethod.Name, currType.Name));
                        }

                        // Finally check that the signature is string ret void.
                        ParameterInfo[] aParams = CurrentMethod.GetParameters();
                        if (CurrentMethod.ReturnType != typeof(void) || 
                            aParams == null ||
                            aParams.Length != 1 || 
                            (aParams[0].ParameterType != typeof(String) && aParams[0].ParameterType != typeof(Type)))
                        {
                            if (bRegister)
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_InvalidComRegFunctionSig"), CurrentMethod.Name, currType.Name));
                            else
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_InvalidComUnRegFunctionSig"), CurrentMethod.Name, currType.Name));
                        }

                        // There can only be one register and one unregister function per type.
                        if (bFunctionCalled)
                        {
                            if (bRegister)
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_MultipleComRegFunctions"), currType.Name));
                            else
                                throw new InvalidOperationException(String.Format(Environment.GetResourceString("InvalidOperation_MultipleComUnRegFunctions"), currType.Name));
                        }

                        // The function is valid so set up the arguments to call it.
                        Object[] objs = new Object[1];
                        if (aParams[0].ParameterType == typeof(String))
                        {
                            // We are dealing with the string overload of the function.
                            objs[0] = "HKEY_CLASSES_ROOT\\CLSID\\{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
                        }
                        else
                        {
                            // We are dealing with the type overload of the function.
                            objs[0] = type;
                        }

                        // Invoke the COM register function.
                        CurrentMethod.Invoke(null, objs);

                        // Mark the function has having been called.
                        bFunctionCalled = true;
                    }
                }
            }
        }

        private Type GetBaseComImportType(Type type)
        {
            for (; type != null && !type.IsImport; type = type.BaseType);
            return type;
        }

        internal static bool TypeRequiresRegistrationHelper(Type type)
        {
            // If the type is not a class or a value class, then it does not get registered.
            if (!type.IsClass && !type.IsValueType)
                return false;

            // If the type is abstract then it does not get registered.
            if (type.IsAbstract)
                return false;

            // If the does not have a public default constructor then is not creatable from COM so 
            // it does not require registration unless it is a value class.
            if (!type.IsValueType && type.GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, new Type[0], null) == null)
                return false;

            // All other conditions are met so check to see if the type is visible from COM.
            return Marshal.IsTypeVisibleFromCom(type);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void RegisterTypeForComClientsNative(Type type, ref Guid g);
        
        [DllImport(Win32Native.KERNEL32, CharSet = CharSet.Auto)]
        private static extern IntPtr GetModuleHandle(String strLibrary);
        
        [DllImport(Win32Native.KERNEL32, CharSet = CharSet.Auto)]
        private static extern int GetModuleFileName(IntPtr BaseAddress, StringBuilder sbOutPath, int length);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\marshal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Marshal
**
** Author: David Mortenson (dmortens)
**
** Purpose: This class contains methods that are mainly used to marshal 
**          between unmanaged and managed types.
**
** Date: January 31, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.CompilerServices;
    using System.Runtime.Remoting.Proxies;
    using System.Globalization;
    using Win32Native = Microsoft.Win32.Win32Native;

    //========================================================================
    // All public methods, including PInvoke, are protected with linkchecks.  
    // Remove the default demands for all PInvoke methods with this global 
    // declaration on the class.
    //========================================================================

    /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal"]/*' />
    [SuppressUnmanagedCodeSecurityAttribute()]
    public sealed class Marshal
    { 
        //====================================================================
        // Defines used inside the Marshal class.
        //====================================================================
        private const int LMEM_FIXED = 0;
        private const int LMEM_MOVEABLE = 2;
        private static readonly IntPtr HIWORDMASK = unchecked(new IntPtr((long)0xffffffffffff0000L));
        private static Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

        // Win32 has the concept of Atoms, where a pointer can either be a pointer
        // or an int.  If it's less than 64K, this is guaranteed to NOT be a 
        // pointer since the bottom 64K bytes are reserved in a process' page table.
        // We should be careful about deallocating this stuff.  Extracted to
        // a function to avoid C# problems with lack of support for IntPtr.
        // We have 2 of these methods for slightly different semantics for NULL.
        private static bool IsWin32Atom(IntPtr ptr)
        {
            long lPtr = (long)ptr;
            return 0 == (lPtr & (long)HIWORDMASK);
        }

        private static bool IsNotWin32Atom(IntPtr ptr)
        {
            long lPtr = (long)ptr;
            return 0 != (lPtr & (long)HIWORDMASK);
        }

        //====================================================================
        // The default character size for the system.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.SystemDefaultCharSize"]/*' />
        public static readonly int SystemDefaultCharSize;

        //====================================================================
        // The max DBCS character size for the system.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.SystemMaxDBCSCharSize"]/*' />
        public static readonly int SystemMaxDBCSCharSize;


        //====================================================================
        // The name, title and description of the assembly that will contain 
        // the dynamically generated interop types. 
        //====================================================================
        private const String s_strConvertedTypeInfoAssemblyName   = "InteropDynamicTypes";
        private const String s_strConvertedTypeInfoAssemblyTitle  = "Interop Dynamic Types";
        private const String s_strConvertedTypeInfoAssemblyDesc   = "Type dynamically generated from ITypeInfo's";
        private const String s_strConvertedTypeInfoNameSpace      = "InteropDynamicTypes";


        //====================================================================
        // Class constructor.
        //====================================================================
        static Marshal() 
        {
            SystemDefaultCharSize = 3 - Win32Native.lstrlen(new sbyte [] {0x41, 0x41, 0, 0});
            SystemMaxDBCSCharSize = GetSystemMaxDBCSCharSize();
        }


        //====================================================================
        // Prevent instantiation
        //====================================================================
        private Marshal() {}  
        

        //====================================================================
        // Helper method to retrieve the system's maximum DBCS character size.
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetSystemMaxDBCSCharSize();

        //====================================================================
        // Memory allocation and dealocation.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.AllocHGlobal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr AllocHGlobal(IntPtr cb)
        {
            IntPtr pNewMem = Win32Native.LocalAlloc(LMEM_FIXED, cb);
            if (pNewMem == Win32Native.NULL) {
                throw new OutOfMemoryException();
            }
            return pNewMem;
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.AllocHGlobal1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr AllocHGlobal(int cb) 
        {
            return AllocHGlobal((IntPtr)cb);
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReAllocHGlobal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb)
        {
            IntPtr pNewMem = Win32Native.LocalReAlloc(pv, cb, LMEM_MOVEABLE);
            if (pNewMem == Win32Native.NULL) {
                throw new OutOfMemoryException();
            }
            return pNewMem;
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.FreeHGlobal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void FreeHGlobal(IntPtr hglobal)
        {
            if (IsNotWin32Atom(hglobal)) {
                if (Win32Native.NULL != Win32Native.LocalFree(hglobal)) {
                    ThrowExceptionForHR(GetHRForLastWin32Error());
                }
            }
        }


        //====================================================================
        // BSTR allocation and dealocation.
        //====================================================================      
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.AllocCoTaskMem"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr AllocCoTaskMem(int cb)
        {
            IntPtr pNewMem = Win32Native.CoTaskMemAlloc(cb);
            if (pNewMem == Win32Native.NULL) {
                throw new OutOfMemoryException();
            }
            return pNewMem;
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReAllocCoTaskMem"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb)
        {
            IntPtr pNewMem = Win32Native.CoTaskMemRealloc(pv, cb);
            if (pNewMem == Win32Native.NULL) {
                throw new OutOfMemoryException();
            }
            return pNewMem;
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.FreeCoTaskMem"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void FreeCoTaskMem(IntPtr ptr)
        {
            if (IsNotWin32Atom(ptr)) {
                Win32Native.CoTaskMemFree(ptr);
            }
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.FreeBSTR"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void FreeBSTR(IntPtr ptr)
        {
            if (IsNotWin32Atom(ptr)) {
                Win32Native.SysFreeString(ptr);
            }
        }


        //====================================================================
        // String convertions.
        //====================================================================          
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToHGlobalAnsi"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToHGlobalAnsi(String s)
        {
            if (s == null) {
                return Win32Native.NULL;
            } else {
                int nb = s.Length * SystemMaxDBCSCharSize;
                IntPtr len = new IntPtr(1 + nb);
                IntPtr hglobal = Win32Native.LocalAlloc(LMEM_FIXED, len);
                if (hglobal == Win32Native.NULL) {
                    throw new OutOfMemoryException();
                } else {
                    Win32Native.CopyMemoryAnsi(hglobal, s, len);
                    return hglobal;
                }
            }
        }    
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToCoTaskMemAnsi"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToCoTaskMemAnsi(String s)
        {
            if (s == null) {
                return Win32Native.NULL;
            } else {
                int nb = s.Length * SystemMaxDBCSCharSize;
                IntPtr hglobal = Win32Native.CoTaskMemAlloc(1 + nb);
                if (hglobal == Win32Native.NULL) {
                    throw new OutOfMemoryException();
                } else {
                    Win32Native.CopyMemoryAnsi(hglobal, s, new IntPtr(1 + nb));
                    return hglobal;
                }
            }
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringAnsi"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String PtrToStringAnsi(IntPtr ptr)
        {
            if (Win32Native.NULL == ptr) {
                return null;
            } else if (IsWin32Atom(ptr)) {
                return null;
            } else {
                int nb = Win32Native.lstrlenA(ptr);
                StringBuilder sb = new StringBuilder(nb);
                Win32Native.CopyMemoryAnsi(sb, ptr, new IntPtr(1+nb));
                return sb.ToString();
            }
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringAnsi1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern String PtrToStringAnsi(IntPtr ptr, int len);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringUni"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern String PtrToStringUni(IntPtr ptr, int len);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringAuto"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String PtrToStringAuto(IntPtr ptr, int len)
        {
            return (SystemDefaultCharSize == 1) ? PtrToStringAnsi(ptr, len) : PtrToStringUni(ptr, len);
        }    
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToHGlobalUni"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToHGlobalUni(String s)
        {
            if (s == null) {
                return Win32Native.NULL;
            } else {
                int nc = s.Length;
                IntPtr len = new IntPtr(2*(1+nc));
                IntPtr hglobal = Win32Native.LocalAlloc(LMEM_FIXED, len);
                if (hglobal == Win32Native.NULL) {
                    throw new OutOfMemoryException();
                } else {
                    Win32Native.CopyMemoryUni(hglobal, s, len);
                    return hglobal;
                }
            }
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToCoTaskMemUni"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToCoTaskMemUni(String s)
        {
            if (s == null) {
                return Win32Native.NULL;
            } else {
                int nc = s.Length;
                IntPtr hglobal = Win32Native.CoTaskMemAlloc(2*(1+nc));
                if (hglobal == Win32Native.NULL) {
                    throw new OutOfMemoryException();
                } else {
                    Win32Native.CopyMemoryUni(hglobal, s, new IntPtr(2*(1+nc)));
                    return hglobal;
                }
            }
        }
             
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringUni1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String PtrToStringUni(IntPtr ptr)
        {
            if (Win32Native.NULL == ptr) {
                return null;
            } else if (IsWin32Atom(ptr)) {
                return null;
            } else {
                int nc = Win32Native.lstrlenW(ptr);
                StringBuilder sb = new StringBuilder(nc);
                Win32Native.CopyMemoryUni(sb, ptr, new IntPtr(2*(1+nc)));
                return sb.ToString();
            }
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToHGlobalAuto"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToHGlobalAuto(String s)
        {
            return (SystemDefaultCharSize == 1) ? StringToHGlobalAnsi(s) : StringToHGlobalUni(s);
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToCoTaskMemAuto"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToCoTaskMemAuto(String s)
        {
            if (s == null) {
                return Win32Native.NULL;
            } else {
                int nc = s.Length;
                IntPtr hglobal = Win32Native.CoTaskMemAlloc((1+nc)*(SystemDefaultCharSize));
                if (hglobal == Win32Native.NULL) {
                    throw new OutOfMemoryException();
                } else {
                    Win32Native.lstrcpy(hglobal, s);
                    return hglobal;
                }
            }
        }    
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringAuto1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String PtrToStringAuto(IntPtr ptr)
        {
            if (Win32Native.NULL == ptr) {
                return null;
            } else if (IsWin32Atom(ptr)) {
                return null;
            } else {
                int nc = Win32Native.lstrlen(ptr);
                StringBuilder sb = new StringBuilder(nc);
                Win32Native.lstrcpy(sb, ptr);
                return sb.ToString();
            }
        }            

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StringToBSTR"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr StringToBSTR(String s)
        {
            if (s == null) 
                return Win32Native.NULL;

            IntPtr bstr = Win32Native.SysAllocStringLen(s, s.Length);
            if (bstr == Win32Native.NULL)
                throw new OutOfMemoryException();

            return bstr;
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStringBSTR"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String PtrToStringBSTR(IntPtr ptr)
        {
            return PtrToStringUni(ptr, Win32Native.SysStringLen(ptr));
        }

        
        //====================================================================
        // SizeOf()
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.SizeOf"]/*' />
        // TODO PORTING: For 64 bit port, Ati considered making SizeOf return an IntPtr instead of an Int.  Consider making that change AND updating ECALL method sig.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int SizeOf(Object structure);
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.SizeOf1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int SizeOf(Type t);    
    

        //====================================================================
        // OffsetOf()
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.OffsetOf"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr OffsetOf(Type t, String fieldName)
        {
            if (t == null)
                throw new ArgumentNullException("t");
            
            FieldInfo f = t.GetField(fieldName);
            if (f == null)
                throw new ArgumentException(Environment.GetResourceString("Argument_OffsetOfFieldNotFound", t.FullName), "fieldName");
                
            return OffsetOfHelper(f);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern IntPtr OffsetOfHelper(FieldInfo f);
        

        //====================================================================
        // UnsafeAddrOfPinnedArrayElement()
        //
        // IMPORTANT NOTICE: This method does not do any verification on the
        // array. It must be used with EXTREME CAUTION since passing in 
        // an array that is not pinned or in the fixed heap can cause 
        // unexpected results !
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.UnsafeAddrOfPinnedArrayElement"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
        

        //====================================================================
        // Copy blocks from COM+ arrays to native memory.
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int[]     source, int startIndex, int destination, int length);

        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(int[]     source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(char[]    source, int startIndex, int destination, int length);

        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy3"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(char[]    source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(short[]   source, int startIndex, int destination, int length);

        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy5"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(short[]   source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(long[]    source, int startIndex, int destination, int length);

        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy7"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(long[]    source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(float[]   source, int startIndex, int destination, int length);

        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy9"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(float[]   source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(double[]  source, int startIndex, int destination, int length);
        
        // @TODO PORTING: For 64 bit port, replace the above Copy method with this one and fix ECALL.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy11"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(double[]  source, int startIndex, IntPtr destination, int length) {
            Copy(source, startIndex, (int)destination, length);
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy12"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(byte[] source, int startIndex, IntPtr destination, int length)
        {
            CopyBytesToNative(source, startIndex, destination, length);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void CopyBytesToNative(byte[] source, int startIndex, IntPtr destination, int length);
    

        //====================================================================
        // Copy blocks from native memory to COM+ arrays
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, int[]     destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy14"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, int[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, char[]    destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy16"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, char[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, short[]   destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy18"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, short[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, long[]    destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy20"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, long[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, float[]   destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy21"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, float[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void Copy(int source, double[]  destination, int startIndex, int length);

        // TODO PORTING: For 64 bit port, replace the above method with this one and fix ECALL method sig.
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy23"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, double[]     destination, int startIndex, int length) {
            Copy((int)source, destination, startIndex, length);
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Copy24"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Copy(IntPtr source, byte[] destination, int startIndex, int length)
        {
            CopyBytesToManaged((int)source, destination, startIndex, length);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void CopyBytesToManaged(int source, byte[]   destination, int startIndex, int length);
        

        //====================================================================
        // Read from memory
        //====================================================================    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadByte"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RU1")]
        public static extern byte ReadByte([MarshalAs(UnmanagedType.AsAny), In] Object ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadByte1"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RU1")]
        public static extern byte ReadByte(IntPtr ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadByte2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static byte ReadByte(IntPtr ptr)
        {
            return ReadByte(ptr,0);
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt16"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI2")]
        public static extern short ReadInt16([MarshalAs(UnmanagedType.AsAny),In] Object ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt161"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI2")]
        public static extern short ReadInt16(IntPtr ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt162"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static short ReadInt16(IntPtr ptr)
        {
            return ReadInt16(ptr, 0);
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt32"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI4")]
        public static extern int ReadInt32([MarshalAs(UnmanagedType.AsAny),In] Object ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt321"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI4")]
        public static extern int ReadInt32(IntPtr ptr, int ofs);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt322"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static int ReadInt32(IntPtr ptr)
        {
            return ReadInt32(ptr,0);
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadIntPtr"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr ReadIntPtr([MarshalAs(UnmanagedType.AsAny),In] Object ptr, int ofs)
        {
            if (IntPtr.Size==4)
                return (IntPtr) ReadInt32(ptr, ofs);
            else
                return (IntPtr) ReadInt64(ptr, ofs);
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadIntPtr1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr ReadIntPtr(IntPtr ptr, int ofs)
        {
            if (IntPtr.Size==4)
                return (IntPtr) ReadInt32(ptr, ofs);
            else
                return (IntPtr) ReadInt64(ptr, ofs);
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadIntPtr2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr ReadIntPtr(IntPtr ptr)
        {
            if (IntPtr.Size==4)
                return (IntPtr) ReadInt32(ptr, 0);
            else
                return (IntPtr) ReadInt64(ptr, 0);
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt64"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI8")]
        public static extern long ReadInt64([MarshalAs(UnmanagedType.AsAny),In] Object ptr, int ofs);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt641"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_RI8")]
        public static extern long ReadInt64(IntPtr ptr, int ofs);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReadInt642"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static long ReadInt64(IntPtr ptr)
        {
            return ReadInt64(ptr,0);
        }
    
    
        //====================================================================
        // Write to memory
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteByte"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WU1")]
        public static extern void WriteByte(IntPtr ptr, int ofs, byte val);

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteByte1"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WU1")]
        public static extern void WriteByte([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, byte val);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteByte2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteByte(IntPtr ptr, byte val)
        {
            WriteByte(ptr, 0, val);
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt16"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI2")]
        public static extern void WriteInt16(IntPtr ptr, int ofs, short val);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt161"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI2")]
        public static extern void WriteInt16([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, short val);
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt162"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteInt16(IntPtr ptr, short val)
        {
            WriteInt16(ptr, 0, val);
        }    
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt163"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI2")]
        public static extern void WriteInt16(IntPtr ptr, int ofs, char val);
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt164"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI2")]
        public static extern void WriteInt16([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, char val);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt165"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteInt16(IntPtr ptr, char val)
        {
            WriteInt16(ptr, 0, val);
        }
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt32"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI4")]
        public static extern void WriteInt32(IntPtr ptr, int ofs, int val);
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt321"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI4")]
        public static extern void WriteInt32([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, int val);
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt322"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteInt32(IntPtr ptr, int val)
        {
            WriteInt32(ptr,0,val);
        }    
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteIntPtr"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val)
        {
            if (IntPtr.Size == 4)
                WriteInt32(ptr, ofs, (int)val);
            else
                WriteInt64(ptr, ofs, (long)val);
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteIntPtr1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteIntPtr([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, IntPtr val)
        {
            if (IntPtr.Size == 4)
                WriteInt32(ptr, ofs, (int)val);
            else
                WriteInt64(ptr, ofs, (long)val);            
        }
        
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteIntPtr2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteIntPtr(IntPtr ptr, IntPtr val)
        {
            if (IntPtr.Size == 4)
                WriteInt32(ptr, 0, (int)val);
            else
                WriteInt64(ptr, 0, (long)val);
        }

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt64"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI8")]
        public static extern void WriteInt64(IntPtr ptr, int ofs, long val);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt641"]/*' />
        [DllImport("mscoree.dll", EntryPoint="ND_WI8")]        
        public static extern void WriteInt64([MarshalAs(UnmanagedType.AsAny),In,Out] Object ptr, int ofs, long val);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.WriteInt642"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void WriteInt64(IntPtr ptr, long val)
        {
            WriteInt64(ptr, 0, val);
        }
    
    
        //====================================================================
        // GetLastWin32Error
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetLastWin32Error"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetLastWin32Error();
    

        //====================================================================
        // GetHRForLastWin32Error
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetHRForLastWin32Error"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static int GetHRForLastWin32Error()
        {
            return GetLastWin32Error() | unchecked((int)0x80070000);
        }


        //====================================================================
        // Prelink
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Prelink"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void Prelink(MethodInfo m);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PrelinkAll"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void PrelinkAll(Type c)
        {
            if (c == null)
                throw new ArgumentNullException("c");

            MethodInfo[] mi = c.GetMethods();
            if (mi != null) 
            {
                for (int i = 0; i < mi.Length; i++) 
                {
                    Prelink(mi[i]);
                }
            }
        }
    
        //====================================================================
        // NumParamBytes
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.NumParamBytes"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int NumParamBytes(MethodInfo m);
    
    
        //====================================================================
        // Win32 Exception stuff
        // These are mostly interesting for Structured exception handling,
        // but need to be exposed for all exceptions (not just SEHException).
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetExceptionPointers"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern /* struct _EXCEPTION_POINTERS* */ IntPtr GetExceptionPointers();

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetExceptionCode"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetExceptionCode();


        //====================================================================
        // Given an COM+ object that wraps an ITypeLib, return its name
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeLibName"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String GetTypeLibName(UCOMITypeLib pTLB)
        {
            String strTypeLibName = null;
            String strDocString = null;
            int dwHelpContext = 0;
            String strHelpFile = null;

            if (pTLB == null)
                throw new ArgumentNullException("pTLB");

            pTLB.GetDocumentation(-1, out strTypeLibName, out strDocString, out dwHelpContext, out strHelpFile);

            return strTypeLibName;
        }

        //====================================================================
        // Given an COM+ object that wraps an ITypeLib, return its guid
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeLibGuid"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Guid GetTypeLibGuid(UCOMITypeLib pTLB)
        {
            IntPtr pAttr = Win32Native.NULL;
            TYPELIBATTR Attr;
            Guid guid;

            if (pTLB == null)
                throw new ArgumentNullException("pTLB");

            // Get the GUID from the TypeLibAttr.
            try
            {
                pTLB.GetLibAttr(out pAttr);
                Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                guid = Attr.guid;
            }
            finally
            {
                if (pAttr != Win32Native.NULL)
                    pTLB.ReleaseTLibAttr(pAttr);
            }

            return guid;
        }


        //====================================================================
        // Given an COM+ object that wraps an ITypeLib, return its lcid
        //====================================================================
        // <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeLibGuid"]/*' />
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeLibLcid"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static int GetTypeLibLcid(UCOMITypeLib pTLB)
        {
            IntPtr pAttr = Win32Native.NULL;
            TYPELIBATTR Attr;
            int lcid = 0;

            if (pTLB == null)
                throw new ArgumentNullException("pTLB");

            // Get the GUID from the TypeLibAttr.
            try
            {
                pTLB.GetLibAttr(out pAttr);
                Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                lcid = Attr.lcid;
            }
            finally
            {
                if (pAttr != Win32Native.NULL)
                    pTLB.ReleaseTLibAttr(pAttr);
            }

            return lcid;
        }


        //====================================================================
        // Given a assembly, return the TLBID that will be generated for the
        // typelib exported from the assembly.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeLibGuidForAssembly"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Guid GetTypeLibGuidForAssembly(Assembly asm);


        //====================================================================
        // Given an COM+ object that wraps an ITypeInfo, return its name
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeInfoName"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String GetTypeInfoName(UCOMITypeInfo pTI)
        {
            String strTypeLibName = null;
            String strDocString = null;
            int dwHelpContext = 0;
            String strHelpFile = null;

            if (pTI == null)
                throw new ArgumentNullException("pTI");

            pTI.GetDocumentation(-1, out strTypeLibName, out strDocString, out dwHelpContext, out strHelpFile);

            return strTypeLibName;
        }


        //====================================================================
        // If a type with the specified GUID is loaded, this method will 
        // return the reflection type that represents it. Otherwise it returns
        // NULL.
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Type GetLoadedTypeForGUID(ref Guid guid);
        

        //====================================================================
        // map ITypeInfo* to Type
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypeForITypeInfo"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Type GetTypeForITypeInfo(IntPtr /* ITypeInfo* */ piTypeInfo)
        {
            UCOMITypeInfo pTI = null;
            UCOMITypeLib pTLB = null;
            IntPtr pAttr = Win32Native.NULL;
            TYPEATTR Attr;
            Type TypeObj = null;
            AssemblyBuilder AsmBldr = null;
            TypeLibConverter TlbConverter = null;
            int Index = 0;

            // If the input ITypeInfo is NULL then return NULL.
            if (piTypeInfo == Win32Native.NULL)
                return null;

            // Wrap the ITypeInfo in a COM+ object.
            pTI = (UCOMITypeInfo)GetObjectForIUnknown(piTypeInfo);

            // Check to see if a class exists with the specified GUID.
            try
            {
                pTI.GetTypeAttr(out pAttr);
                Attr = (TYPEATTR)Marshal.PtrToStructure(pAttr, typeof(TYPEATTR));
                TypeObj = GetLoadedTypeForGUID(ref Attr.guid);
            }
            finally
            {
                if (pAttr != Win32Native.NULL)
                    pTI.ReleaseTypeAttr(pAttr);
            }

            // If we managed to find the type based on the GUID then return it.
            if (TypeObj != null)
                return TypeObj;

            // There is no type with the specified GUID in the app domain so lets
            // try and convert the containing typelib.
            try 
            {
                pTI.GetContainingTypeLib(out pTLB, out Index);
            }
            catch(COMException)
            {
                pTLB = null;
            }

            // Check to see if we managed to get a containing typelib.
            if (pTLB != null)
            {
                // Get the assembly name from the typelib.
                AssemblyName AsmName = TypeLibConverter.GetAssemblyNameFromTypelib(pTLB, null, null, null, null);
                String AsmNameString = AsmName.FullName;

                // Check to see if the assembly that will contain the type already exists.
                Assembly[] aAssemblies = Thread.GetDomain().GetAssemblies();
                int NumAssemblies = aAssemblies.Length;
                for (int i = 0; i < NumAssemblies; i++)
                {
                    if (String.Compare(aAssemblies[i].FullName, 
                                       AsmNameString,false, CultureInfo.InvariantCulture) == 0)
                        AsmBldr = (AssemblyBuilder)aAssemblies[i];
                }

                // If we haven't imported the assembly yet then import it.
                if (AsmBldr == null)
                {
                    TlbConverter = new TypeLibConverter();
                    AsmBldr = TlbConverter.ConvertTypeLibToAssembly(pTLB, 
                        GetTypeLibName(pTLB) + ".dll", 0, new ImporterCallback(), null, null, null, null);
                }

                // Load the type object from the imported typelib.
                TypeObj = AsmBldr.GetTypeInternal(GetTypeLibName(pTLB) + "." + GetTypeInfoName(pTI), true, false, true);
            }
            else
            {
                // @TODO(DM): Investigate creating an __ComObject with a valid class factory.

                // If the ITypeInfo does not have a containing typelib then simply 
                // return Object as the type.
                TypeObj = typeof(Object);
            }

            return TypeObj;
        }
        
        //====================================================================
        // map Type to ITypeInfo*
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetITypeInfoForType"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr /* ITypeInfo* */ GetITypeInfoForType(Type t);
    

        //====================================================================
        // return the IUnknown* for an Object
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetIUnknownForObject"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr /* IUnknown* */ GetIUnknownForObject(Object o);
    

        //====================================================================
        // return the IDispatch* for an Object
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetIDispatchForObject"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr /* IDispatch */ GetIDispatchForObject(Object o);
    

        //====================================================================
        // return the IUnknown* representing the interface for the Object
        // Object o should support Type T
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetComInterfaceForObject"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr /* IUnknown* */ GetComInterfaceForObject(Object o, Type T);
    

        //====================================================================
        // return an Object for IUnknown
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetObjectForIUnknown"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Object GetObjectForIUnknown(IntPtr /* IUnknown* */ pUnk);
    
        
        //====================================================================
        // return an Object for IUnknown, using the Type T, 
        //  NOTE: 
        //  Type T should be either a COM imported Type or a sub-type of COM 
        //  imported Type
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetTypedObjectForIUnknown"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Object GetTypedObjectForIUnknown(IntPtr /* IUnknown* */ pUnk, Type t);
    

        //====================================================================
        // check if the object is classic COM component
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.IsComObject"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern bool IsComObject(Object o);
    

        //====================================================================
        // release the COM component and if the reference hits 0 zombie this object
        // further usage of this Object might throw an exception, 
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReleaseComObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static int ReleaseComObject(Object o)
        {
            __ComObject co = (__ComObject) o;
            return co.ReleaseSelf();
        }    

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nReleaseComObject(Object o);

        //====================================================================
        // This method retrieves data from the COM object.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetComObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Object GetComObjectData(Object obj, Object key)
        {
            __ComObject comObj = null;

            // Validate that the arguments aren't null.
            if (obj == null)
                throw new ArgumentNullException("obj");
            if (key == null)
                throw new ArgumentNullException("key");

            // Make sure the obj is an __ComObject.
            try
            {
                comObj = (__ComObject)obj;
            }
            catch (InvalidCastException)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_ObjNotComObject"), "obj");
            }

            // Retrieve the data from the __ComObject.
            return comObj.GetData(key);
        }


        //====================================================================
        // This method sets data on the COM object. The data can only be set 
        // once for a given key and cannot be removed. This function returns
        // true if the data has been added, false if the data could not be
        // added because there already was data for the specified key.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.SetComObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static bool SetComObjectData(Object obj, Object key, Object data)
        {
            __ComObject comObj = null;

            // Validate that the arguments aren't null. The data can validly be null.
            if (obj == null)
                throw new ArgumentNullException("obj");
            if (key == null)
                throw new ArgumentNullException("key");

            // Make sure the obj is an __ComObject.
            try
            {
                comObj = (__ComObject)obj;
            }
            catch (InvalidCastException)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_ObjNotComObject"), "obj");
            }

            // Retrieve the data from the __ComObject.
            return comObj.SetData(key, data);
        }


        //====================================================================
        // This method takes the given COM object and wraps it in an object
        // of the specified type. The type must be derived from __ComObject.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.CreateWrapperOfType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Object CreateWrapperOfType(Object o, Type t)
        {
            // Validate the arguments.
            if (t == null)
                throw new ArgumentNullException("t");
            if (!t.IsCOMObject)
                throw new ArgumentException(Environment.GetResourceString("Argument_TypeNotComObject"), "t");

            // Check for the null case.
            if (o == null)
                return null;

            // Make sure the object is a COM object.
            if (!o.GetType().IsCOMObject)
                throw new ArgumentException(Environment.GetResourceString("Argument_ObjNotComObject"), "o");

            // Check to see if the type of the object is the requested type.
            if (o.GetType() == t)
                return o;

            // Check to see if we already have a cached wrapper for this type.
            Object Wrapper = GetComObjectData(o, t);
            if (Wrapper == null)
            {
                // Create the wrapper for the specified type.
                Wrapper = InternalCreateWrapperOfType(o, t);

                // Attempt to cache the wrapper on the object.
                if (!SetComObjectData(o, t, Wrapper))
                {
                    // Another thead already cached the wrapper so use that one instead.
                    Wrapper = GetComObjectData(o, t);
                }
            }

            return Wrapper;
        }
        

        //====================================================================
        // Helper method called from CreateWrapperOfType.
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        private static extern Object InternalCreateWrapperOfType(Object o, Type t);


        //====================================================================
        // There may be a thread-based cache of COM components.  This service can
        // force the aggressive release of the current thread's cache.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ReleaseThreadCache"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void ReleaseThreadCache()
        {
            // @TODO(DM): Remove this if nobody is calling it.
        }
    
        
        //====================================================================
        // The hosting APIs allow a sophisticated host to schedule fibers
        // onto OS threads, so long as they notify the runtime of this
        // activity.  A fiber cookie can be redeemed for its managed Thread
        // object by calling the following service.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetThreadFromFiberCookie"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Thread GetThreadFromFiberCookie(int cookie)
        {
            return InternalGetThreadFromFiberCookie(cookie);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Thread InternalGetThreadFromFiberCookie(int cookie);


        //====================================================================
        // check if the type is visible from COM.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.IsTypeVisibleFromCom"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern bool IsTypeVisibleFromCom(Type t);


        //====================================================================
        // IUnknown Helpers
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.QueryInterface"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int /* HRESULT */ QueryInterface(IntPtr /* IUnknown */ pUnk, ref Guid iid, out IntPtr ppv);    

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.AddRef"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int /* ULONG */ AddRef(IntPtr /* IUnknown */ pUnk );
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.Release"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int /* ULONG */ Release(IntPtr /* IUnknown */ pUnk );
        
        
        //====================================================================
        // Marshals data from a structure class to a native memory block.
        // If the structure contains pointers to allocated blocks and
        // "fDeleteOld" is true, this routine will call DestroyStructure() first. 
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.StructureToPtr"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void StructureToPtr(Object structure, IntPtr ptr, bool fDeleteOld);
    

        //====================================================================
        // Marshals data from a native memory block to a preallocated structure class.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStructure"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void PtrToStructure(IntPtr ptr, Object structure)
        {
            PtrToStructureHelper(ptr, structure, false);
        }

        
        //====================================================================
        // Creates a new instance of "structuretype" and marshals data from a
        // native memory block to it.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.PtrToStructure1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Object PtrToStructure(IntPtr ptr, Type structureType)
        {
            if (ptr == Win32Native.NULL) return null;
            Object structure = Activator.CreateInstance(structureType, true);
            PtrToStructureHelper(ptr, structure, true);
            return structure;
        }
    

        //====================================================================
        // Helper function to copy a pointer into a preallocated structure.
        //====================================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void PtrToStructureHelper(IntPtr ptr, Object structure, bool allowValueClasses);


        //====================================================================
        // Freeds all substructures pointed to by the native memory block.
        // "structureclass" is used to provide layout information.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.DestroyStructure"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void DestroyStructure(IntPtr ptr, Type structuretype);
    
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetNativeVariantForObject"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void GetNativeVariantForObject(Object obj, /* VARIANT * */ IntPtr pDstNativeVariant);

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetObjectForNativeVariant"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Object GetObjectForNativeVariant(/* VARIANT * */ IntPtr pSrcNativeVariant );

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetObjectsForNativeVariants"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Object[] GetObjectsForNativeVariants(/* VARIANT * */ IntPtr aSrcNativeVariant, int cVars );


        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetStartComSlot"]/*' />
        /// <summary>
        /// <para>Returns the first valid COM slot that GetMethodInfoForSlot will work on
        /// This will be 3 for IUnknown based interfaces and 7 for IDispatch based interfaces. </para>
        /// </summary>
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetStartComSlot(Type t);

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetEndComSlot"]/*' />
        /// <summary>
        /// <para>Returns the last valid COM slot that GetMethodInfoForSlot will work on. </para>
        /// </summary>
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetEndComSlot(Type t);

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetMethodInfoForComSlot"]/*' />
        /// <summary>
        /// <para>Returns the MemberInfo that COM callers calling through the exposed 
        /// vtable on the given slot will be calling. The slot should take into account
        /// if the exposed interface is IUnknown based or IDispatch based.
        /// For classes, the lookup is done on the default interface that will be
        /// exposed for the class. </para>
        /// </summary>
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern MemberInfo GetMethodInfoForComSlot(Type t, int slot, ref ComMemberType memberType);

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetComSlotForMethodInfo"]/*' />
        /// <summary>
        /// <para>Returns the COM slot for a memeber info, taking into account whether 
        /// the exposed interface is IUnknown based or IDispatch based</para>
        /// </summary>
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetComSlotForMethodInfo(MemberInfo m);

        //====================================================================
        // Returns the HInstance for this module.  Returns -1 if the module 
        // doesn't have an HInstance.  In Memory (Dynamic) Modules won't have 
        // an HInstance.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetHINSTANCE"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr GetHINSTANCE(Module m)
        {
            if (m == null)
                throw new ArgumentNullException("m");
            return m.GetHINSTANCE();
        }    


        //====================================================================
        // Converts the HRESULT to a COM+ exception.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ThrowExceptionForHR"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void ThrowExceptionForHR(int errorCode)
        {
            ThrowExceptionForHR(errorCode, Win32Native.NULL);
        }
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ThrowExceptionForHR1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);


        //====================================================================
        // Converts the COM+ exception to an HRESULT. This function also sets
        // up an IErrorInfo for the exception.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetHRForException"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern int GetHRForException(Exception e);


        //====================================================================
        // This method generates a GUID for the specified type. If the type
        // has a GUID in the metadata then it is returned otherwise a stable
        // guid GUID is generated based on the fully qualified name of the 
        // type.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GenerateGuidForType"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern Guid GenerateGuidForType(Type type);


        //====================================================================
        // This method generates a PROGID for the specified type. If the type
        // has a PROGID in the metadata then it is returned otherwise a stable
        // guid PROGID is generated based on the fully qualified name of the 
        // type.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GenerateProgIdForType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static String GenerateProgIdForType(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            if (!RegistrationServices.TypeRequiresRegistrationHelper(type))
                throw new ArgumentException(Environment.GetResourceString("Argument_TypeMustBeComCreatable"), "type");
            if (type.IsImport)
                throw new ArgumentException(Environment.GetResourceString("Argument_TypeMustNotBeComImport"), "type");

            // Check to see if the type has a ProgIdAttribute set.
            Object[] aProgIdAttrs = type.GetCustomAttributes(typeof(ProgIdAttribute), true);

            // If there is no prog ID attribute then use the full name of the type as the prog id.
            if (aProgIdAttrs.Length == 0)
                return type.FullName;

            // If the CA value is null then set it to the empty string.
            String strProgId = ((ProgIdAttribute)aProgIdAttrs[0]).Value;
            if (strProgId == null)
                strProgId = String.Empty;

            // Use the user defined prog id.
            return strProgId;
        }


        //====================================================================
        // This method binds to the specified moniker.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.BindToMoniker"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Object BindToMoniker(String monikerName)
        {
            Object obj = null;
            UCOMIBindCtx bindctx = null;
            CreateBindCtx(0, out bindctx);

            UInt32 cbEaten;
            UCOMIMoniker pmoniker = null;
            MkParseDisplayName(bindctx, monikerName, out cbEaten, out pmoniker);

            BindMoniker(pmoniker, 0, ref IID_IUnknown, out obj);
            return obj;
        }


        //====================================================================
        // This method gets the currently running object.
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetActiveObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Object GetActiveObject(String progID)
        {
            Object obj = null;
            Guid clsid;

            // Call CLSIDFromProgIDEx first then fall back on CLSIDFromProgID if
            // CLSIDFromProgIDEx doesn't exist.
            try 
            {
                CLSIDFromProgIDEx(progID, out clsid);
            }
            catch(Exception) 
            {
                CLSIDFromProgID(progID, out clsid);
            }

            GetActiveObject(ref clsid, 0, out obj);
            return obj;
        }


        [DllImport(Microsoft.Win32.Win32Native.OLE32, PreserveSig = false)]
        private static extern void CLSIDFromProgIDEx([MarshalAs(UnmanagedType.LPWStr)] String progId, out Guid clsid);

        [DllImport(Microsoft.Win32.Win32Native.OLE32, PreserveSig = false)]
        private static extern void CLSIDFromProgID([MarshalAs(UnmanagedType.LPWStr)] String progId, out Guid clsid);

        [DllImport(Microsoft.Win32.Win32Native.OLE32, PreserveSig = false)]
        private static extern void CreateBindCtx(UInt32 reserved, out UCOMIBindCtx ppbc);

        [DllImport(Microsoft.Win32.Win32Native.OLE32, PreserveSig = false)]
        private static extern void MkParseDisplayName(UCOMIBindCtx pbc, [MarshalAs(UnmanagedType.LPWStr)] String szUserName, out UInt32 pchEaten, out UCOMIMoniker ppmk);

        [DllImport(Microsoft.Win32.Win32Native.OLE32, PreserveSig = false)]
        private static extern void BindMoniker(UCOMIMoniker pmk, UInt32 grfOpt, ref Guid iidResult, [MarshalAs(UnmanagedType.Interface)] out Object ppvResult);

        [DllImport(Microsoft.Win32.Win32Native.OLEAUT32, PreserveSig = false)]
        private static extern void GetActiveObject(ref Guid rclsid, UInt32 reserved, [MarshalAs(UnmanagedType.Interface)] out Object ppunk);


        private const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
        private const int FORMAT_MESSAGE_FROM_SYSTEM    = 0x00001000;
        private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;



        //====================================================================
        // This method is intended for compiler code generators rather
        // than applications. 
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetUnmanagedThunkForManagedMethodPtr"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);

        //====================================================================
        // This method is intended for compiler code generators rather
        // than applications. 
        //====================================================================
        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.GetManagedThunkForUnmanagedMethodPtr"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);

        //========================================================================
        // Private method called from EE upon use of license/ICF2 marshaling.
        //========================================================================

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void SwitchCCW(Object oldtp, Object newtp);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object _WrapIUnknownWithComObject(IntPtr i, Object owner);

        internal static byte[] GetDCOMBuffer(Object o)
        {
            int cb = _internalDCOMGetMarshalSize(o);

            if (cb == -1)
                throw new RemotingException(Environment.GetResourceString("Remoting_InteropError"));

            byte[] b = new byte[cb];

            if (!_internalDCOMMarshalObject(o, b, cb))
            {
                throw new RemotingException(Environment.GetResourceString("Remoting_InteropError"));
            }

            return b;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int _internalDCOMGetMarshalSize(Object o);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool _internalDCOMMarshalObject(Object o, byte[] b, int cb);



        //========================================================================
        // Private method called from EE upon use of license/ICF2 marshaling.
        //========================================================================
        private static RuntimeTypeHandle LoadLicenseManager()
        {
            Assembly me = Assembly.GetExecutingAssembly();

            byte [] msKey={0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89};
            //b77a5c561934e089
            AssemblyName name = new AssemblyName();
            name.Name = "System";
            name.CultureInfo = me.GetLocale();
            name.Version = me.GetVersion();
            name.SetPublicKeyToken(msKey);
            

            Type t= Assembly.Load(name).GetTypeInternal("System.ComponentModel.LicenseManager", false, false, true);

            return t.TypeHandle;
        }

        // also take an object param and register the object for this unk
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        internal static Object WrapIUnknownWithComObject(IntPtr punk, Object owner)
        {
            return Marshal._WrapIUnknownWithComObject(punk, owner);
        }

        // switch the wrappers
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        internal static void SwitchWrappers(RealProxy oldcp, RealProxy newcp)
        {
            Object oldtp = oldcp.GetTransparentProxy();
            Object newtp = newcp.GetTransparentProxy();

            int oldcontextId = RemotingServices.GetServerContextForProxy(oldtp);
            int newcontextId = RemotingServices.GetServerContextForProxy(newtp);

            //@todo this will be a problem, if they don't match
            // coz this means we are in differnt appdomains
            //DBG.Assert(oldcontextId == newcontextId, "context mismatch during reconnect");

            // switch the CCW from oldtp to new tp
            Marshal.SwitchCCW(oldtp, newtp);
        }  

        /// <include file='doc\Marshal.uex' path='docs/doc[@for="Marshal.ChangeWrapperHandleStrength"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void ChangeWrapperHandleStrength(Object otp, bool fIsWeak);
    }


    //========================================================================
    // Typelib importer callback implementation.
    //========================================================================
    internal class ImporterCallback : ITypeLibImporterNotifySink
    {
        public void ReportEvent(ImporterEventKind EventKind, int EventCode, String EventMsg)
        {
        }
        
        public Assembly ResolveRef(Object TypeLib)
        {
            try
            {
                // Create the TypeLibConverter.
                ITypeLibConverter TLBConv = new TypeLibConverter();

                // Convert the typelib.
                return TLBConv.ConvertTypeLibToAssembly(TypeLib,
                                                        Marshal.GetTypeLibName((UCOMITypeLib)TypeLib) + ".dll",
                                                        0,
                                                        new ImporterCallback(),
                                                        null,
                                                        null,
                                                        null,
                                                        null);
            }
            catch (Exception)
            {
                return null;
            }               
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomibindctx.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIBindCtx
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIBindCtx interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="BIND_OPTS"]/*' />
    [StructLayout(LayoutKind.Sequential)]
    [ComVisible(false)]
    public struct BIND_OPTS 
    {
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="BIND_OPTS.cbStruct"]/*' />
        public int cbStruct;
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="BIND_OPTS.grfFlags"]/*' />
        public int grfFlags;
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="BIND_OPTS.grfMode"]/*' />
        public int grfMode;
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="BIND_OPTS.dwTickCountDeadline"]/*' />
        public int dwTickCountDeadline;
    }

    /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx"]/*' />
    [Guid("0000000e-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIBindCtx 
    {
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.RegisterObjectBound"]/*' />
        void RegisterObjectBound([MarshalAs(UnmanagedType.Interface)] Object punk);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.RevokeObjectBound"]/*' />
        void RevokeObjectBound([MarshalAs(UnmanagedType.Interface)] Object punk);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.ReleaseBoundObjects"]/*' />
        void ReleaseBoundObjects();
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.SetBindOptions"]/*' />
        void SetBindOptions([In()] ref BIND_OPTS pbindopts);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.GetBindOptions"]/*' />
        void GetBindOptions(ref BIND_OPTS pbindopts);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.GetRunningObjectTable"]/*' />
        void GetRunningObjectTable(out UCOMIRunningObjectTable pprot);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.RegisterObjectParam"]/*' />
        void RegisterObjectParam([MarshalAs(UnmanagedType.LPWStr)] String pszKey, [MarshalAs(UnmanagedType.Interface)] Object punk);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.GetObjectParam"]/*' />
        void GetObjectParam([MarshalAs(UnmanagedType.LPWStr)] String pszKey, [MarshalAs(UnmanagedType.Interface)] out Object ppunk);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.EnumObjectParam"]/*' />
        void EnumObjectParam(out UCOMIEnumString ppenum);
        /// <include file='doc\UCOMIBindCtx.uex' path='docs/doc[@for="UCOMIBindCtx.RevokeObjectParam"]/*' />
        void RevokeObjectParam([MarshalAs(UnmanagedType.LPWStr)] String pszKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomiconnectionpointcontainer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIConnectionPointContainer
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIConnectionPointContainer interface definition.
**
** Date: June 22, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;

    /// <include file='doc\UCOMIConnectionPointContainer.uex' path='docs/doc[@for="UCOMIConnectionPointContainer"]/*' />
    [Guid("B196B284-BAB4-101A-B69C-00AA00341D07")]   
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIConnectionPointContainer
    {		
        /// <include file='doc\UCOMIConnectionPointContainer.uex' path='docs/doc[@for="UCOMIConnectionPointContainer.EnumConnectionPoints"]/*' />
        void EnumConnectionPoints(out UCOMIEnumConnectionPoints ppEnum);    	
        /// <include file='doc\UCOMIConnectionPointContainer.uex' path='docs/doc[@for="UCOMIConnectionPointContainer.FindConnectionPoint"]/*' />
        void FindConnectionPoint(ref Guid riid, out UCOMIConnectionPoint ppCP);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\sehexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SEHException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception class for all Structured Exception Handling code.
**
** Date: March 24, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	using System.Runtime.InteropServices;
	using System;
	using System.Runtime.Serialization;
    // Exception for Structured Exception Handler exceptions.
    // 
    /// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException"]/*' />
    [Serializable()] public class SEHException : ExternalException {
        /// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException.SEHException"]/*' />
        public SEHException() 
            : base() {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException.SEHException1"]/*' />
        public SEHException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException.SEHException2"]/*' />
        public SEHException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.E_FAIL);
        }
    	
        /// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException.SEHException3"]/*' />
        protected SEHException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    	// Exceptions can be resumable, meaning a filtered exception 
    	// handler can correct the problem that caused the exception,
    	// and the code will continue from the point that threw the 
    	// exception.
    	// 
    	// Resumable exceptions aren't implemented in this version,
    	// but this method exists and always returns false.
    	// 
    	/// <include file='doc\SEHException.uex' path='docs/doc[@for="SEHException.CanResume"]/*' />
    	public virtual bool CanResume()
    	{
    		return false;
    	}	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomiconnectionpoint.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIConnectionPoint
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIConnectionPoint interface definition.
**
** Date: June 22, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {
	
	using System;

    /// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint"]/*' />
    [Guid("B196B286-BAB4-101A-B69C-00AA00341D07")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIConnectionPoint
    {		
    	/// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint.GetConnectionInterface"]/*' />
    	void GetConnectionInterface(out Guid pIID);
    	/// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint.GetConnectionPointContainer"]/*' />
    	void GetConnectionPointContainer(out UCOMIConnectionPointContainer ppCPC);
    	/// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint.Advise"]/*' />
    	void Advise([MarshalAs(UnmanagedType.Interface)] Object pUnkSink, out int pdwCookie);
    	/// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint.Unadvise"]/*' />
    	void Unadvise(int dwCookie);
    	/// <include file='doc\UCOMIConnectionPoint.uex' path='docs/doc[@for="UCOMIConnectionPoint.EnumConnections"]/*' />
    	void EnumConnections(out UCOMIEnumConnections ppEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumconnectionpoints.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIEnumConnectionPoints
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIEnumConnectionPoints interface definition.
**
** Date: October 16, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
    
    using System;

    /// <include file='doc\UCOMIEnumConnectionPoints.uex' path='docs/doc[@for="UCOMIEnumConnectionPoints"]/*' />
    [Guid("B196B285-BAB4-101A-B69C-00AA00341D07")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIEnumConnectionPoints
    {       
        /// <include file='doc\UCOMIEnumConnectionPoints.uex' path='docs/doc[@for="UCOMIEnumConnectionPoints.Next"]/*' />
        [PreserveSig]
        int Next(int celt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0), Out] UCOMIConnectionPoint[] rgelt, out int pceltFetched);
        /// <include file='doc\UCOMIEnumConnectionPoints.uex' path='docs/doc[@for="UCOMIEnumConnectionPoints.Skip"]/*' />
        [PreserveSig]
        int Skip(int celt);
        /// <include file='doc\UCOMIEnumConnectionPoints.uex' path='docs/doc[@for="UCOMIEnumConnectionPoints.Reset"]/*' />
        [PreserveSig]
        int Reset();
        /// <include file='doc\UCOMIEnumConnectionPoints.uex' path='docs/doc[@for="UCOMIEnumConnectionPoints.Clone"]/*' />
        void Clone(out UCOMIEnumConnectionPoints ppenum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\typelibconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: TypeLibConverter
**
** Author: David Mortenson(dmortens)
**
** Purpose: Component that implements the ITypeLibConverter interface and
**          does the actual work of converting a typelib to metadata and
**          vice versa.
**
** Date: Jan 5, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
   
    using System;
    using System.Collections;
    using System.Threading;
    using System.Runtime.InteropServices.TCEAdapterGen;
    using System.IO;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Configuration.Assemblies;
    using Microsoft.Win32;
    using System.Runtime.CompilerServices;
    using System.Globalization;
    using System.Security.Permissions;
    using WORD = System.UInt16;
    using DWORD = System.UInt32;

    /// <include file='doc\TypeLibConverter.uex' path='docs/doc[@for="TypeLibConverter"]/*' />
    [Guid("F1C3BF79-C3E4-11d3-88E7-00902754C43A")]
    [ClassInterface(ClassInterfaceType.None)]
    public sealed class TypeLibConverter : ITypeLibConverter
    {
        private const String s_strTypeLibAssemblyTitlePrefix = "TypeLib ";
        private const String s_strTypeLibAssemblyDescPrefix = "Assembly generated from typelib ";
        private const int MAX_NAMESPACE_LENGTH = 1024;


        //
        // ITypeLibConverter interface.
        //

        /// <include file='doc\TypeLibConverter.uex' path='docs/doc[@for="TypeLibConverter.ConvertTypeLibToAssembly"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public AssemblyBuilder ConvertTypeLibToAssembly([MarshalAs(UnmanagedType.Interface)] Object typeLib, 
                                                        String asmFileName,
                                                        int flags,
                                                        ITypeLibImporterNotifySink notifySink,
                                                        byte[] publicKey,
                                                        StrongNameKeyPair keyPair,
                                                        bool unsafeInterfaces)
        {
            return ConvertTypeLibToAssembly(typeLib,
                                            asmFileName,
                                            (unsafeInterfaces
                                                ? TypeLibImporterFlags.UnsafeInterfaces
                                                : 0),
                                            notifySink,
                                            publicKey,
                                            keyPair,
                                            null,
                                            null);
        }




        /// <include file='doc\TypeLibConverter.uex' path='docs/doc[@for="TypeLibConverter.ConvertTypeLibToAssembly1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public AssemblyBuilder ConvertTypeLibToAssembly([MarshalAs(UnmanagedType.Interface)] Object typeLib, 
                                                        String asmFileName,
                                                        TypeLibImporterFlags flags, 
                                                        ITypeLibImporterNotifySink notifySink,
                                                        byte[] publicKey,
                                                        StrongNameKeyPair keyPair,
                                                        String asmNamespace,
                                                        Version asmVersion)
        {
            ArrayList eventItfInfoList = null;

            // Validate the arguments.
            if (typeLib == null)
                throw new ArgumentNullException("typeLib");
            if (asmFileName == null)
                throw new ArgumentNullException("asmFileName");         
            if (notifySink == null)
                throw new ArgumentNullException("notifySink");
            if (String.Empty.Equals(asmFileName))
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidFileName"), "asmFileName");
            if (asmFileName.Length > Path.MAX_PATH)
                throw new ArgumentException(Environment.GetResourceString("IO.PathTooLong"), asmFileName);
            if ((flags & TypeLibImporterFlags.PrimaryInteropAssembly) != 0 && publicKey == null && keyPair == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_PIAMustBeStrongNamed"));

            // Retrieve the assembly name from the typelib.
            AssemblyName asmName = GetAssemblyNameFromTypelib(typeLib, asmFileName, publicKey, keyPair, asmVersion);

            // Create the dynamic assembly that will contain the converted typelib types.
            AssemblyBuilder asmBldr = CreateAssemblyForTypeLib(typeLib, asmFileName, asmName, (flags & TypeLibImporterFlags.PrimaryInteropAssembly) != 0);

            // Define a dynamic module that will contain the contain the imported types.
            String strNonQualifiedAsmFileName = Path.GetFileName(asmFileName);
            ModuleBuilder modBldr = asmBldr.DefineDynamicModule(strNonQualifiedAsmFileName, strNonQualifiedAsmFileName);

            // If the namespace hasn't been specified, then use the assembly name.
            if (asmNamespace == null)
                asmNamespace = asmName.Name;

            // Create a type resolve handler that will also intercept resolve ref messages
            // on the sink interface to build up a list of referenced assemblies.
            TypeResolveHandler typeResolveHandler = new TypeResolveHandler(modBldr, notifySink);

            // Add a listener for the type resolve events.
            AppDomain currentDomain = Thread.GetDomain();
            ResolveEventHandler resolveHandler = new ResolveEventHandler(typeResolveHandler.ResolveEvent);
            ResolveEventHandler asmResolveHandler = new ResolveEventHandler(typeResolveHandler.ResolveAsmEvent);
            currentDomain.TypeResolve += resolveHandler;
            currentDomain.AssemblyResolve += asmResolveHandler;

            // Convert the types contained in the typelib into metadata and add them to the assembly.
            nConvertTypeLibToMetadata(typeLib, asmBldr, modBldr, asmNamespace, flags, typeResolveHandler, out eventItfInfoList);

            // Remove the listener for the type resolve events.
            currentDomain.TypeResolve -= resolveHandler;
            currentDomain.AssemblyResolve -= asmResolveHandler;

            // Update the COM types in the assembly.
            UpdateComTypesInAssembly(asmBldr, modBldr);

            // If there are any event sources then generate the TCE adapters.
            if (eventItfInfoList.Count > 0)
                new TCEAdapterGenerator().Process(modBldr, eventItfInfoList);

            // We have finished converting the typelib and now have a fully formed assembly.
            return asmBldr;
        }

        /// <include file='doc\TypeLibConverter.uex' path='docs/doc[@for="TypeLibConverter.ConvertAssemblyToTypeLib"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [return : MarshalAs(UnmanagedType.Interface)]
        public Object ConvertAssemblyToTypeLib(Assembly assembly, String strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink)
        {
            return nConvertAssemblyToTypeLib(assembly, strTypeLibName, flags, notifySink);
        }

        /// <include file='doc\TypeLibConverter.uex' path='docs/doc[@for="TypeLibConverter.GetPrimaryInteropAssembly"]/*' />
        public bool GetPrimaryInteropAssembly(Guid g, Int32 major, Int32 minor, Int32 lcid, out String asmName, out String asmCodeBase)
        {
            String strTlbId = "{" + g.ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
            String strVersion = major + "." + minor;

            // Set the two out values to null before we start.
            asmName = null;
            asmCodeBase = null;

            // Try to open the HKEY_CLASS_ROOT\TypeLib<TLBID> key.
            RegistryKey TypeLibKey = Registry.ClassesRoot.OpenSubKey("TypeLib", false).OpenSubKey(strTlbId);
            if (TypeLibKey != null)
            {
                // Try to open the HKEY_CLASS_ROOT\TypeLib<TLBID>\<Major.Minor> key.
                RegistryKey VersionKey = TypeLibKey.OpenSubKey(strVersion, false);
                if (VersionKey != null)
                {
                    // Attempt to retrieve the assembly name and codebase under the version key.
                    asmName = (String)VersionKey.GetValue("PrimaryInteropAssemblyName");
                    asmCodeBase = (String)VersionKey.GetValue("PrimaryInteropAssemblyCodeBase");

                    // Close the key.
                    VersionKey.Close();
                }

                // Close the key.
                TypeLibKey.Close();
            }

            // If the assembly name isn't null, then we found an PIA.
            return asmName != null;
        }


        //
        // Non native helper methods.
        //

        private static AssemblyBuilder CreateAssemblyForTypeLib(Object typeLib, String asmFileName, AssemblyName asmName, bool bPrimaryInteropAssembly)
        {
            // Retrieve the current app domain.
            AppDomain currentDomain = Thread.GetDomain();

            // Retrieve the directory from the assembly file name.
            String dir = null;
            if (asmFileName != null)
            {
                dir = Path.GetDirectoryName(asmFileName);
                if (String.Empty.Equals(dir))
                    dir = null;
            }

            // Create the dynamic assembly itself.
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            AssemblyBuilder asmBldr = currentDomain.InternalDefineDynamicAssembly(
                asmName, AssemblyBuilderAccess.RunAndSave,
                dir, null, null, null, null, ref stackMark);

            // Set the Guid custom attribute on the assembly.
            SetGuidAttributeOnAssembly(asmBldr, typeLib);

            // Set the imported from COM attribute on the assembly and return it.
            SetImportedFromTypeLibAttrOnAssembly(asmBldr, typeLib);

            // Set the version information on the typelib.
            SetVersionInformation(asmBldr, typeLib, asmName);

            // If we are generating a PIA, then set the PIA custom attribute.
            if (bPrimaryInteropAssembly)
                SetPIAAttributeOnAssembly(asmBldr, typeLib);

            return asmBldr;
        }

        internal static AssemblyName GetAssemblyNameFromTypelib(Object typeLib, String asmFileName, byte[] publicKey, StrongNameKeyPair keyPair, Version asmVersion)
        {
            // Extract the name of the typelib.
            TYPELIBATTR Attr;
            String strTypeLibName = null;
            String strDocString = null;
            int dwHelpContext = 0;
            String strHelpFile = null;
            UCOMITypeLib pTLB = (UCOMITypeLib)typeLib;
            pTLB.GetDocumentation(-1, out strTypeLibName, out strDocString, out dwHelpContext, out strHelpFile);

            // Retrieve the name to use for the assembly.
            if (asmFileName == null)
            {
                asmFileName = strTypeLibName;
            }
            else
            {
                BCLDebug.Assert(!String.Empty.Equals(asmFileName), "The assembly file name cannot be an empty string!");

                String strFileNameNoPath = Path.GetFileName(asmFileName);
                String strExtension = Path.GetExtension(asmFileName);

                // Validate that the extension is valid.
                bool bExtensionValid = ".dll".Equals(strExtension.ToLower(CultureInfo.InvariantCulture));

                // If the extension is not valid then tell the user and quit.
                if (!bExtensionValid)
                    throw new ArgumentException(Environment.GetResourceString("Arg_InvalidFileExtension"));

                // The assembly cannot contain the path nor the extension.
                asmFileName = strFileNameNoPath.Substring(0, strFileNameNoPath.Length - ".dll".Length);
            }

            // If the version information was not specified, then retrieve it from the typelib.
            if (asmVersion == null)
            {
                IntPtr pAttr = Win32Native.NULL;
                try
                {
                    pTLB.GetLibAttr(out pAttr);
                    Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                    asmVersion = new Version(Attr.wMajorVerNum, Attr.wMinorVerNum, 0, 0);
                }
                finally
                {
                    if (pAttr != Win32Native.NULL)
                        pTLB.ReleaseTLibAttr(pAttr);
                }
            }
            
            
            // Create the assembly name for the imported typelib's assembly.
            AssemblyName AsmName = new AssemblyName();
            AsmName.Init(
                asmFileName,
                publicKey,
                null,
                asmVersion,
                null,
                AssemblyHashAlgorithm.None,
                AssemblyVersionCompatibility.SameMachine,
                null,
                AssemblyNameFlags.None,
                keyPair,
                null);

            return AsmName;
        }

        private static void UpdateComTypesInAssembly(AssemblyBuilder asmBldr, ModuleBuilder modBldr)
        {
            // Retrieve the AssemblyBuilderData associated with the assembly builder.
            AssemblyBuilderData AsmBldrData = asmBldr.m_assemblyData;

            // Go through the types in the module and add them as public COM types.
            Type[] aTypes = modBldr.GetTypes();
            int NumTypes = aTypes.Length;
            for (int cTypes = 0; cTypes < NumTypes; cTypes++)
                AsmBldrData.AddPublicComType(aTypes[cTypes]);
        }


        private static void SetGuidAttributeOnAssembly(AssemblyBuilder asmBldr, Object typeLib)
        {
            // Retrieve the GuidAttribute constructor.
            Type []aConsParams = new Type[1] {typeof(String)};
            ConstructorInfo GuidAttrCons = typeof(GuidAttribute).GetConstructor(aConsParams);

            // Create an instance of the custom attribute builder.
            Object[] aArgs = new Object[1] {Marshal.GetTypeLibGuid((UCOMITypeLib)typeLib).ToString()};
            CustomAttributeBuilder GuidCABuilder = new CustomAttributeBuilder(GuidAttrCons, aArgs);

            // Set the GuidAttribute on the assembly builder.
            asmBldr.SetCustomAttribute(GuidCABuilder);
        }

        private static void SetImportedFromTypeLibAttrOnAssembly(AssemblyBuilder asmBldr, Object typeLib)
        {
            // Retrieve the ImportedFromTypeLibAttribute constructor.
            Type []aConsParams = new Type[1] {typeof(String)};
            ConstructorInfo ImpFromComAttrCons = typeof(ImportedFromTypeLibAttribute).GetConstructor(aConsParams);

            // Retrieve the name of the typelib.
            String strTypeLibName = Marshal.GetTypeLibName((UCOMITypeLib)typeLib);

            // Create an instance of the custom attribute builder.
            Object[] aArgs = new Object[1] {strTypeLibName};
            CustomAttributeBuilder ImpFromComCABuilder = new CustomAttributeBuilder(ImpFromComAttrCons, aArgs);

            // Set the ImportedFromTypeLibAttribute on the assembly builder.
            asmBldr.SetCustomAttribute(ImpFromComCABuilder);
        }

        private static void SetVersionInformation(AssemblyBuilder asmBldr, Object typeLib, AssemblyName asmName)
        {
            // Extract the name of the typelib.
            String strTypeLibName = null;
            String strDocString = null;
            int dwHelpContext = 0;
            String strHelpFile = null;
            UCOMITypeLib pTLB = (UCOMITypeLib)typeLib;
            pTLB.GetDocumentation(-1, out strTypeLibName, out strDocString, out dwHelpContext, out strHelpFile);

            // Generate the product name string from the named of the typelib.
            String strProductName = String.Format(Environment.GetResourceString("TypeLibConverter_ImportedTypeLibProductName"), strTypeLibName);

            // Set the OS version information.
            asmBldr.DefineVersionInfoResource(strProductName, asmName.Version.ToString(), null, null, null);
        }

        private static void SetPIAAttributeOnAssembly(AssemblyBuilder asmBldr, Object typeLib)
        {
            IntPtr pAttr = Win32Native.NULL;
            TYPELIBATTR Attr;
            UCOMITypeLib pTLB = (UCOMITypeLib)typeLib;
            int Major = 0;
            int Minor = 0;

            // Retrieve the PrimaryInteropAssemblyAttribute constructor.
            Type []aConsParams = new Type[2] {typeof(int), typeof(int)};
            ConstructorInfo PIAAttrCons = typeof(PrimaryInteropAssemblyAttribute).GetConstructor(aConsParams);

            // Retrieve the major and minor version from the typelib.
            try
            {
                pTLB.GetLibAttr(out pAttr);
                Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                Major = Attr.wMajorVerNum;
                Minor = Attr.wMinorVerNum;
            }
            finally
            {
                // Release the typelib attributes.
                if (pAttr != Win32Native.NULL)
                    pTLB.ReleaseTLibAttr(pAttr);
            }

            // Create an instance of the custom attribute builder.
            Object[] aArgs = new Object[2] {Major, Minor};
            CustomAttributeBuilder PIACABuilder = new CustomAttributeBuilder(PIAAttrCons, aArgs);

            // Set the PrimaryInteropAssemblyAttribute on the assembly builder.
            asmBldr.SetCustomAttribute(PIACABuilder);
        }


        //
        // Native helper methods.
        //

        [MethodImplAttribute(MethodImplOptions.InternalCall)] 
        private static extern void nConvertTypeLibToMetadata(Object typeLib, AssemblyBuilder asmBldr, ModuleBuilder modBldr, String nameSpace, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, out ArrayList eventItfInfoList);

        [MethodImplAttribute(MethodImplOptions.InternalCall)] 
        private static extern Object nConvertAssemblyToTypeLib(Assembly assembly, String strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);

        [DllImport(Microsoft.Win32.Win32Native.OLEAUT32, PreserveSig=false)] 
        private static extern void QueryPathOfRegTypeLib(ref Guid rclsid, WORD wVerMajor, WORD wVerMinor, DWORD lcid, [MarshalAs(UnmanagedType.BStr)] out String lpbstrPathName);


        //
        // Helper class called when a resolve type event is fired.
        //

        private class TypeResolveHandler : ITypeLibImporterNotifySink
        {
            public TypeResolveHandler(Module mod, ITypeLibImporterNotifySink userSink)
            {
                m_Module = mod;
                m_UserSink = userSink;
            }

            public void ReportEvent(ImporterEventKind eventKind, int eventCode, String eventMsg)
            {
                m_UserSink.ReportEvent(eventKind, eventCode, eventMsg);
            }

            public Assembly ResolveRef(Object typeLib)
            {
                // Call the user sink to resolve the reference.
                Assembly asm = m_UserSink.ResolveRef(typeLib);

                // Add the assembly to the list of assemblies.
                m_AsmList.Add(asm);

                // Return the resolved assembly.
                return asm;
            }

            public Assembly ResolveEvent(Object sender, ResolveEventArgs args)
            {
                // We need to load the type in the resolve event so that we will deal with
                // cases where we are trying to load the CoClass before the interface has 
                // been loaded.               
                try
                {
                    m_Module.InternalLoadInMemoryTypeByName(args.Name); 
                    return m_Module.Assembly;
                }
                catch (TypeLoadException e)
                {
                    if (e.ResourceId != System.__HResults.COR_E_TYPELOAD)  // type not found
                        throw;
                }

                foreach (Object asmObj in m_AsmList)
                {
                    Assembly asm = (Assembly)asmObj;

                    try
                    {
                        asm.GetTypeInternal(args.Name, true, false, false);
                        return asm;
                    }
                    catch (TypeLoadException e)
                    {
                        if (e._HResult != System.__HResults.COR_E_TYPELOAD)  // type not found
                            throw;
                    }
                }
                
                return null;
            }

            public Assembly ResolveAsmEvent(Object sender, ResolveEventArgs args)
            {
                foreach (Object asmObj in m_AsmList)
                {
                    Assembly asm = (Assembly)asmObj;
                    if (String.Compare(asm.FullName, args.Name, true, CultureInfo.InvariantCulture) == 0)
                        return asm;
                }

                return null;
            }

            private Module m_Module;
            private ITypeLibImporterNotifySink m_UserSink;
            private ArrayList m_AsmList = new ArrayList();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumerable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*==========================================================================
**
** Interface:  UCOMIEnumerable
**
** Author: David Mortenson (DMortens)
**
** Purpose: 
** This interface is redefined here since the original IEnumerable interface 
** has all its methods marked as ecall's since it is a managed standard 
** interface. This interface is used from within the runtime to make a call 
** on the COM server directly when it implements the IEnumerable interface.
**
** Date:  January 18, 2000
** 
==========================================================================*/
namespace System.Runtime.InteropServices {
    
    using System;
    using System.Collections;

    [Guid("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
    internal interface UCOMIEnumerable
    {
        [DispId(-4)]
        IEnumerator GetEnumerator();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumconnections.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIEnumConnections
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIEnumConnections interface definition.
**
** Date: October 16, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="CONNECTDATA"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct CONNECTDATA
    {   
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="CONNECTDATA.pUnk"]/*' />
        [MarshalAs(UnmanagedType.Interface)] 
        public Object pUnk;
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="CONNECTDATA.dwCookie"]/*' />
        public int dwCookie;
    }

    /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="UCOMIEnumConnections"]/*' />
    [Guid("B196B287-BAB4-101A-B69C-00AA00341D07")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIEnumConnections
    {
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="UCOMIEnumConnections.Next"]/*' />
        [PreserveSig]
        int Next(int celt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0), Out] CONNECTDATA[] rgelt, out int pceltFetched);
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="UCOMIEnumConnections.Skip"]/*' />
        [PreserveSig]
        int Skip(int celt);
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="UCOMIEnumConnections.Reset"]/*' />
        [PreserveSig]
        void Reset();
        /// <include file='doc\UCOMIEnumConnections.uex' path='docs/doc[@for="UCOMIEnumConnections.Clone"]/*' />
        void Clone(out UCOMIEnumConnections ppenum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*==========================================================================
**
** Interface:  UCOMIEnumerator
**
** Author: David Mortenson (DMortens)
**
** Purpose: 
** This interface is redefined here since the original IEnumerator interface 
** has all its methods marked as ecall's since it is a managed standard 
** interface. This interface is used from within the runtime to make a call 
** on the COM server directly when it implements the IEnumerator interface.
**
** Date:  January 18, 2000
** 
==========================================================================*/
namespace System.Runtime.InteropServices {

    using System;

    [Guid("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
    internal interface UCOMIEnumerator
    {
        bool MoveNext();
        Object Current {
            get; 
        }
        void Reset();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumstring.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIEnumString
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIEnumString interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIEnumString.uex' path='docs/doc[@for="UCOMIEnumString"]/*' />
    [Guid("00000101-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIEnumString 
    {
        /// <include file='doc\UCOMIEnumString.uex' path='docs/doc[@for="UCOMIEnumString.Next"]/*' />
        [PreserveSig]
        int Next(int celt, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPWStr, SizeParamIndex = 0), Out] String[] rgelt, out int pceltFetched);
        /// <include file='doc\UCOMIEnumString.uex' path='docs/doc[@for="UCOMIEnumString.Skip"]/*' />
        [PreserveSig]
        int Skip(int celt);
        /// <include file='doc\UCOMIEnumString.uex' path='docs/doc[@for="UCOMIEnumString.Reset"]/*' />
        [PreserveSig]
        int Reset();
        /// <include file='doc\UCOMIEnumString.uex' path='docs/doc[@for="UCOMIEnumString.Clone"]/*' />
        void Clone(out UCOMIEnumString ppenum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomiexpando.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*==========================================================================
**
** Interface:  UCOMIExpando
**
** Author: David Mortenson (DMortens)
**
** Purpose: 
** This interface is redefined here since the original IExpando interface 
** has all its methods marked as ecall's since it is a managed standard 
** interface. This interface is used from within the runtime to make a call 
** on the COM server directly when it implements the IExpando interface.
**
** Date:  January 18, 2000
** 
==========================================================================*/
namespace System.Runtime.InteropServices {
    
    using System;
    using System.Reflection;

    [Guid("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]    
    internal interface UCOMIExpando : UCOMIReflect
    {
        FieldInfo AddField(String name);
        PropertyInfo AddProperty(String name);
        MethodInfo AddMethod(String name, Delegate method);
        void RemoveMember(MemberInfo m);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienummoniker.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIEnumMoniker
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIEnumMoniker interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;
    using DWORD = System.UInt32;

    /// <include file='doc\UCOMIEnumMoniker.uex' path='docs/doc[@for="UCOMIEnumMoniker"]/*' />
    [Guid("00000102-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIEnumMoniker 
    {
        /// <include file='doc\UCOMIEnumMoniker.uex' path='docs/doc[@for="UCOMIEnumMoniker.Next"]/*' />
        [PreserveSig]
        int Next(int celt, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0), Out] UCOMIMoniker[] rgelt, out int pceltFetched);
        /// <include file='doc\UCOMIEnumMoniker.uex' path='docs/doc[@for="UCOMIEnumMoniker.Skip"]/*' />
        [PreserveSig]
        int Skip(int celt);
        /// <include file='doc\UCOMIEnumMoniker.uex' path='docs/doc[@for="UCOMIEnumMoniker.Reset"]/*' />
        [PreserveSig]
        int Reset();
        /// <include file='doc\UCOMIEnumMoniker.uex' path='docs/doc[@for="UCOMIEnumMoniker.Clone"]/*' />
        void Clone(out UCOMIEnumMoniker ppenum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomimoniker.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIMoniker
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIMoniker interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="FILETIME"]/*' />
    [StructLayout(LayoutKind.Sequential)]
    [ComVisible(false)]
    public struct FILETIME 
    {
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="FILETIME.dwLowDateTime"]/*' />
        public int dwLowDateTime; 
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="FILETIME.dwHighDateTime"]/*' />
        public int dwHighDateTime; 
    }

    /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker"]/*' />
    [Guid("0000000f-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIMoniker 
    {
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.GetClassID"]/*' />
        // IPersist portion
        void GetClassID(out Guid pClassID);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.IsDirty"]/*' />

        // IPersistStream portion
        [PreserveSig]
        int IsDirty();
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Load"]/*' />
        void Load(UCOMIStream pStm);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Save"]/*' />
        void Save(UCOMIStream pStm, [MarshalAs(UnmanagedType.Bool)] bool fClearDirty);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.GetSizeMax"]/*' />
        void GetSizeMax(out Int64 pcbSize);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.BindToObject"]/*' />

        // IMoniker portion
        void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, [In()] ref Guid riidResult, [MarshalAs(UnmanagedType.Interface)] out Object ppvResult);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.BindToStorage"]/*' />
        void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, [In()] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out Object ppvObj);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Reduce"]/*' />
        void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, ref UCOMIMoniker ppmkToLeft, out UCOMIMoniker ppmkReduced);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.ComposeWith"]/*' />
        void ComposeWith(UCOMIMoniker pmkRight, [MarshalAs(UnmanagedType.Bool)] bool fOnlyIfNotGeneric, out UCOMIMoniker ppmkComposite);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Enum"]/*' />
        void Enum([MarshalAs(UnmanagedType.Bool)] bool fForward, out UCOMIEnumMoniker ppenumMoniker);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.IsEqual"]/*' />
        void IsEqual(UCOMIMoniker pmkOtherMoniker);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Hash"]/*' />
        void Hash(out int pdwHash);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.IsRunning"]/*' />
        void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.GetTimeOfLastChange"]/*' />
        void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, out FILETIME pFileTime);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.Inverse"]/*' />
        void Inverse(out UCOMIMoniker ppmk);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.CommonPrefixWith"]/*' />
        void CommonPrefixWith(UCOMIMoniker pmkOther, out UCOMIMoniker ppmkPrefix);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.RelativePathTo"]/*' />
        void RelativePathTo(UCOMIMoniker pmkOther, out UCOMIMoniker ppmkRelPath);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.GetDisplayName"]/*' />
        void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, [MarshalAs(UnmanagedType.LPWStr)] out String ppszDisplayName);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.ParseDisplayName"]/*' />
        void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, [MarshalAs(UnmanagedType.LPWStr)] String pszDisplayName, out int pchEaten, out UCOMIMoniker ppmkOut);
        /// <include file='doc\UCOMIMoniker.uex' path='docs/doc[@for="UCOMIMoniker.IsSystemMoniker"]/*' />
        void IsSystemMoniker(out int pdwMksys);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomipersistfile.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIPersistFile
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIPersistFile interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;
    using DWORD = System.UInt32;

    /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile"]/*' />
    [Guid("0000010b-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIPersistFile
    {
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.GetClassID"]/*' />
        // IPersist portion
        void GetClassID(out Guid pClassID);

        // IPersistFile portion
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.IsDirty"]/*' />
        [PreserveSig]
        int IsDirty();
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.Load"]/*' />
        void Load([MarshalAs(UnmanagedType.LPWStr)] String pszFileName, int dwMode);
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.Save"]/*' />
        void Save([MarshalAs(UnmanagedType.LPWStr)] String pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fRemember);
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.SaveCompleted"]/*' />
        void SaveCompleted([MarshalAs(UnmanagedType.LPWStr)] String pszFileName);
        /// <include file='doc\UCOMIPersistFile.uex' path='docs/doc[@for="UCOMIPersistFile.GetCurFile"]/*' />
        void GetCurFile([MarshalAs(UnmanagedType.LPWStr)] out String ppszFileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomienumvariant.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIEnumVARIANT
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIEnumVARIANT interface definition.
**
** Date: June 22, 1999
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIEnumVARIANT.uex' path='docs/doc[@for="UCOMIEnumVARIANT"]/*' />
    [Guid("00020404-0000-0000-C000-000000000046")]   
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIEnumVARIANT
    {
        /// <include file='doc\UCOMIEnumVARIANT.uex' path='docs/doc[@for="UCOMIEnumVARIANT.Next"]/*' />
        [PreserveSig]
        int Next(int celt, int rgvar, int pceltFetched);

        /// <include file='doc\UCOMIEnumVARIANT.uex' path='docs/doc[@for="UCOMIEnumVARIANT.Skip"]/*' />
        [PreserveSig]
        int Skip(int celt);

        /// <include file='doc\UCOMIEnumVARIANT.uex' path='docs/doc[@for="UCOMIEnumVARIANT.Reset"]/*' />
        [PreserveSig]
        int Reset();

        /// <include file='doc\UCOMIEnumVARIANT.uex' path='docs/doc[@for="UCOMIEnumVARIANT.Clone"]/*' />
        void Clone(int ppenum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomirunningobjecttable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIRunningObjectTable
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIRunningObjectTable interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable"]/*' />
    [Guid("00000010-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIRunningObjectTable 
    {
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.Register"]/*' />
        void Register(int grfFlags, [MarshalAs(UnmanagedType.Interface)] Object punkObject, UCOMIMoniker pmkObjectName, out int pdwRegister);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.Revoke"]/*' />
        void Revoke(int dwRegister);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.IsRunning"]/*' />
        void IsRunning(UCOMIMoniker pmkObjectName);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.GetObject"]/*' />
        void GetObject(UCOMIMoniker pmkObjectName, [MarshalAs(UnmanagedType.Interface)] out Object ppunkObject);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.NoteChangeTime"]/*' />
        void NoteChangeTime(int dwRegister, ref FILETIME pfiletime);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.GetTimeOfLastChange"]/*' />
        void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, out FILETIME pfiletime);
        /// <include file='doc\UCOMIRunningObjectTable.uex' path='docs/doc[@for="UCOMIRunningObjectTable.EnumRunning"]/*' />
        void EnumRunning(out UCOMIEnumMoniker ppenumMoniker);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomireflect.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*==========================================================================
**
** Interface:  UCOMIReflect
**
** Author: David Mortenson (DMortens)
**
** Purpose: 
** This interface is redefined here since the original IReflect interface 
** has all its methods marked as ecall's since it is a managed standard 
** interface. This interface is used from within the runtime to make a call 
** on the COM server directly when it implements the IReflect interface.
**
** Date:  January 18, 2000
** 
==========================================================================*/
namespace System.Runtime.InteropServices {
    
    using System;
    using System.Reflection;
    using CultureInfo = System.Globalization.CultureInfo;

    [Guid("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]    
    internal interface UCOMIReflect
    {
        MethodInfo GetMethod(String name,BindingFlags bindingAttr,Binder binder,
                Type[] types,ParameterModifier[] modifiers);

        MethodInfo GetMethod(String name,BindingFlags bindingAttr);

        MethodInfo[] GetMethods(
                BindingFlags bindingAttr);

        FieldInfo GetField(
                String name,
                BindingFlags bindingAttr);

        FieldInfo[] GetFields(
                BindingFlags bindingAttr);

        PropertyInfo GetProperty(
                String name,
                BindingFlags bindingAttr);

        PropertyInfo GetProperty(
                String name,
                BindingFlags bindingAttr,
                Binder binder,	            
                Type returnType,
                Type[] types,
                ParameterModifier[] modifiers);

        PropertyInfo[] GetProperties(
                BindingFlags bindingAttr);

        MemberInfo[] GetMember(
                String name,
                BindingFlags bindingAttr);

        MemberInfo[] GetMembers(
                BindingFlags bindingAttr);

        Object InvokeMember(
                String name,
                BindingFlags invokeAttr,
                Binder binder,
                Object target,
                Object[] args,
                ParameterModifier[] modifiers,
                CultureInfo culture,
                String[] namedParameters);

        Type UnderlyingSystemType {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomitypecomp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMITypeComp
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMITypeComp interface definition.
**
** Date: October 17, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;
 
    /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND"]/*' />
    [ComVisible(false), Serializable]
    public enum DESCKIND
    {
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_NONE"]/*' />
        DESCKIND_NONE               = 0,
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_FUNCDESC"]/*' />
        DESCKIND_FUNCDESC           = DESCKIND_NONE + 1,
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_VARDESC"]/*' />
        DESCKIND_VARDESC            = DESCKIND_FUNCDESC + 1,
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_TYPECOMP"]/*' />
        DESCKIND_TYPECOMP           = DESCKIND_VARDESC + 1,
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_IMPLICITAPPOBJ"]/*' />
        DESCKIND_IMPLICITAPPOBJ     = DESCKIND_TYPECOMP + 1,
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="DESCKIND.DESCKIND_MAX"]/*' />
        DESCKIND_MAX                = DESCKIND_IMPLICITAPPOBJ + 1
    }

    /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="BINDPTR"]/*' />
    [StructLayout(LayoutKind.Explicit, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct BINDPTR
    {
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="BINDPTR.lpfuncdesc"]/*' />
        [FieldOffset(0)]
        public IntPtr lpfuncdesc;
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="BINDPTR.lpvardesc"]/*' />
        [FieldOffset(0)]
        public IntPtr lpvardesc;
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="BINDPTR.lptcomp"]/*' />
        [FieldOffset(0)]
        public IntPtr lptcomp;
    }

    /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="UCOMITypeComp"]/*' />
    [Guid("00020403-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMITypeComp
    {
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="UCOMITypeComp.Bind"]/*' />
        void Bind([MarshalAs(UnmanagedType.LPWStr)] String szName, int lHashVal, Int16 wFlags, out UCOMITypeInfo ppTInfo, out DESCKIND pDescKind, out BINDPTR pBindPtr);
        /// <include file='doc\UCOMITypeComp.uex' path='docs/doc[@for="UCOMITypeComp.BindType"]/*' />
        void BindType([MarshalAs(UnmanagedType.LPWStr)] String szName, int lHashVal, out UCOMITypeInfo ppTInfo, out UCOMITypeComp ppTComp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomistream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMIStream
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMIStream interface definition.
**
** Date: June 24, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct STATSTG
    {
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.pwcsName"]/*' />
        public String pwcsName;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.type"]/*' />
        public int type;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.cbSize"]/*' />
        public Int64 cbSize;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.mtime"]/*' />
        public FILETIME mtime;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.ctime"]/*' />
        public FILETIME ctime;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.atime"]/*' />
        public FILETIME atime;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.grfMode"]/*' />
        public int grfMode;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.grfLocksSupported"]/*' />
        public int grfLocksSupported;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.clsid"]/*' />
        public Guid clsid;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.grfStateBits"]/*' />
        public int grfStateBits;
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="STATSTG.reserved"]/*' />
        public int reserved;
    }

    /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream"]/*' />
    [Guid("0000000c-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMIStream
    {
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Read"]/*' />
        // ISequentialStream portion
        void Read([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1), Out] Byte[] pv, int cb,IntPtr pcbRead);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Write"]/*' />
        void Write([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] Byte[] pv, int cb, IntPtr pcbWritten);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Seek"]/*' />

        // IStream portion
        void Seek(Int64 dlibMove, int dwOrigin, IntPtr plibNewPosition);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.SetSize"]/*' />
        void SetSize(Int64 libNewSize);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.CopyTo"]/*' />
        void CopyTo(UCOMIStream pstm, Int64 cb, IntPtr pcbRead, IntPtr pcbWritten);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Commit"]/*' />
        void Commit(int grfCommitFlags);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Revert"]/*' />
        void Revert();
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.LockRegion"]/*' />
        void LockRegion(Int64 libOffset, Int64 cb, int dwLockType);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.UnlockRegion"]/*' />
        void UnlockRegion(Int64 libOffset, Int64 cb, int dwLockType);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Stat"]/*' />
        void Stat(out STATSTG pstatstg, int grfStatFlag);
        /// <include file='doc\UCOMIStream.uex' path='docs/doc[@for="UCOMIStream.Clone"]/*' />
        void Clone(out UCOMIStream ppstm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomitypelib.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMITypeLib
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMITypeLib interface definition.
**
** Date: January 12, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="SYSKIND"]/*' />
    [ComVisible(false), Serializable]
    public enum SYSKIND
    {
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="SYSKIND.SYS_WIN16"]/*' />
        SYS_WIN16	            = 0,
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="SYSKIND.SYS_WIN32"]/*' />
        SYS_WIN32	            = SYS_WIN16 + 1,
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="SYSKIND.SYS_MAC"]/*' />
        SYS_MAC	                = SYS_WIN32 + 1
    }

    /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="LIBFLAGS"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum LIBFLAGS : short
    {
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="LIBFLAGS.LIBFLAG_FRESTRICTED"]/*' />
        LIBFLAG_FRESTRICTED     = 0x1,
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="LIBFLAGS.LIBFLAG_FCONTROL"]/*' />
        LIBFLAG_FCONTROL        = 0x2,
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="LIBFLAGS.LIBFLAG_FHIDDEN"]/*' />
        LIBFLAG_FHIDDEN         = 0x4,
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="LIBFLAGS.LIBFLAG_FHASDISKIMAGE"]/*' />
        LIBFLAG_FHASDISKIMAGE   = 0x8
    }

    /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct TYPELIBATTR
    { 
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.guid"]/*' />
        public Guid guid;
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.lcid"]/*' />
        public int lcid;
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.syskind"]/*' />
        public SYSKIND syskind; 
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.wMajorVerNum"]/*' />
        public Int16 wMajorVerNum;
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.wMinorVerNum"]/*' />
        public Int16 wMinorVerNum;
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="TYPELIBATTR.wLibFlags"]/*' />
        public LIBFLAGS wLibFlags;
    }

    /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib"]/*' />
    [Guid("00020402-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMITypeLib
    {
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetTypeInfoCount"]/*' />
        [PreserveSig]
        int GetTypeInfoCount();
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetTypeInfo"]/*' />
        void GetTypeInfo(int index, out UCOMITypeInfo ppTI);
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetTypeInfoType"]/*' />
        void GetTypeInfoType(int index, out TYPEKIND pTKind);       
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetTypeInfoOfGuid"]/*' />
        void GetTypeInfoOfGuid(ref Guid guid, out UCOMITypeInfo ppTInfo);        
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetLibAttr"]/*' />
        void GetLibAttr(out IntPtr ppTLibAttr);        
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetTypeComp"]/*' />
        void GetTypeComp(out UCOMITypeComp ppTComp);        
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.GetDocumentation"]/*' />
        void GetDocumentation(int index, out String strName, out String strDocString, out int dwHelpContext, out String strHelpFile);
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.IsName"]/*' />
        [return : MarshalAs(UnmanagedType.Bool)] 
        bool IsName([MarshalAs(UnmanagedType.LPWStr)] String szNameBuf, int lHashVal);
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.FindName"]/*' />
        void FindName([MarshalAs(UnmanagedType.LPWStr)] String szNameBuf, int lHashVal, [MarshalAs(UnmanagedType.LPArray), Out] UCOMITypeInfo[] ppTInfo, [MarshalAs(UnmanagedType.LPArray), Out] int[] rgMemId, ref Int16 pcFound);
        /// <include file='doc\UCOMITypeLib.uex' path='docs/doc[@for="UCOMITypeLib.ReleaseTLibAttr"]/*' />
        [PreserveSig]
        void ReleaseTLibAttr(IntPtr pTLibAttr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\ucomitypeinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UCOMITypeInfo
**
** Author: David Mortenson (dmortens)
**
** Purpose: UCOMITypeInfo interface definition.
**
** Date: January 17, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {

    using System;

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND"]/*' />
    [ComVisible(false), Serializable]
    public enum TYPEKIND 
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_ENUM"]/*' />
        TKIND_ENUM      = 0,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_RECORD"]/*' />
        TKIND_RECORD    = TKIND_ENUM + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_MODULE"]/*' />
        TKIND_MODULE    = TKIND_RECORD + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_INTERFACE"]/*' />
        TKIND_INTERFACE = TKIND_MODULE + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_DISPATCH"]/*' />
        TKIND_DISPATCH  = TKIND_INTERFACE + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_COCLASS"]/*' />
        TKIND_COCLASS   = TKIND_DISPATCH + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_ALIAS"]/*' />
        TKIND_ALIAS     = TKIND_COCLASS + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_UNION"]/*' />
        TKIND_UNION     = TKIND_ALIAS + 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEKIND.TKIND_MAX"]/*' />
        TKIND_MAX       = TKIND_UNION + 1
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum TYPEFLAGS : short
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FAPPOBJECT"]/*' />
        TYPEFLAG_FAPPOBJECT         = 0x1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FCANCREATE"]/*' />
        TYPEFLAG_FCANCREATE         = 0x2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FLICENSED"]/*' />
        TYPEFLAG_FLICENSED          = 0x4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FPREDECLID"]/*' />
        TYPEFLAG_FPREDECLID         = 0x8,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FHIDDEN"]/*' />
        TYPEFLAG_FHIDDEN            = 0x10,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FCONTROL"]/*' />
        TYPEFLAG_FCONTROL           = 0x20,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FDUAL"]/*' />
        TYPEFLAG_FDUAL              = 0x40,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FNONEXTENSIBLE"]/*' />
        TYPEFLAG_FNONEXTENSIBLE     = 0x80,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FOLEAUTOMATION"]/*' />
        TYPEFLAG_FOLEAUTOMATION     = 0x100,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FRESTRICTED"]/*' />
        TYPEFLAG_FRESTRICTED        = 0x200,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FAGGREGATABLE"]/*' />
        TYPEFLAG_FAGGREGATABLE      = 0x400,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FREPLACEABLE"]/*' />
        TYPEFLAG_FREPLACEABLE       = 0x800,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FDISPATCHABLE"]/*' />
        TYPEFLAG_FDISPATCHABLE      = 0x1000,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FREVERSEBIND"]/*' />
        TYPEFLAG_FREVERSEBIND       = 0x2000,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEFLAGS.TYPEFLAG_FPROXY"]/*' />
        TYPEFLAG_FPROXY             = 0x4000
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IMPLTYPEFLAGS"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum IMPLTYPEFLAGS
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IMPLTYPEFLAGS.IMPLTYPEFLAG_FDEFAULT"]/*' />
        IMPLTYPEFLAG_FDEFAULT       = 0x1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IMPLTYPEFLAGS.IMPLTYPEFLAG_FSOURCE"]/*' />
        IMPLTYPEFLAG_FSOURCE        = 0x2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IMPLTYPEFLAGS.IMPLTYPEFLAG_FRESTRICTED"]/*' />
        IMPLTYPEFLAG_FRESTRICTED    = 0x4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IMPLTYPEFLAGS.IMPLTYPEFLAG_FDEFAULTVTABLE"]/*' />
        IMPLTYPEFLAG_FDEFAULTVTABLE = 0x8,
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct TYPEATTR
    { 
        // Constant used with the memid fields.
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.MEMBER_ID_NIL"]/*' />
        public const int MEMBER_ID_NIL = unchecked((int)0xFFFFFFFF); 

        // Actual fields of the TypeAttr struct.
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.guid"]/*' />
        public Guid guid;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.lcid"]/*' />
        public Int32 lcid;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.dwReserved"]/*' />
        public Int32 dwReserved;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.memidConstructor"]/*' />
        public Int32 memidConstructor;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.memidDestructor"]/*' />
        public Int32 memidDestructor;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.lpstrSchema"]/*' />
        public IntPtr lpstrSchema;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cbSizeInstance"]/*' />
        public Int32 cbSizeInstance;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.typekind"]/*' />
        public TYPEKIND typekind;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cFuncs"]/*' />
        public Int16 cFuncs;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cVars"]/*' />
        public Int16 cVars;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cImplTypes"]/*' />
        public Int16 cImplTypes;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cbSizeVft"]/*' />
        public Int16 cbSizeVft;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.cbAlignment"]/*' />
        public Int16 cbAlignment;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.wTypeFlags"]/*' />
        public TYPEFLAGS wTypeFlags;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.wMajorVerNum"]/*' />
        public Int16 wMajorVerNum;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.wMinorVerNum"]/*' />
        public Int16 wMinorVerNum;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.tdescAlias"]/*' />
        public TYPEDESC tdescAlias;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEATTR.idldescType"]/*' />
        public IDLDESC idldescType;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC"]/*' />
    [StructLayout(LayoutKind.Sequential)]
    [ComVisible(false)]
    public struct FUNCDESC
    { 
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.memid"]/*' />
        public int memid;                   //MEMBERID memid;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.lprgscode"]/*' />
        public IntPtr lprgscode;            // /* [size_is(cScodes)] */ SCODE RPC_FAR *lprgscode;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.lprgelemdescParam"]/*' />
        public IntPtr lprgelemdescParam;    // /* [size_is(cParams)] */ ELEMDESC __RPC_FAR *lprgelemdescParam;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.funckind"]/*' />
        public FUNCKIND	funckind;           //FUNCKIND funckind;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.invkind"]/*' />
        public INVOKEKIND invkind;          //INVOKEKIND invkind;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.callconv"]/*' />
        public CALLCONV	callconv;           //CALLCONV callconv;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.cParams"]/*' />
        public Int16 cParams;               //short cParams;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.cParamsOpt"]/*' />
        public Int16 cParamsOpt;            //short cParamsOpt;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.oVft"]/*' />
        public Int16 oVft;                  //short oVft;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.cScodes"]/*' />
        public Int16 cScodes;               //short cScodes;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.elemdescFunc"]/*' />
        public ELEMDESC	elemdescFunc;       //ELEMDESC elemdescFunc;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCDESC.wFuncFlags"]/*' />
        public Int16 wFuncFlags;            //WORD wFuncFlags;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum IDLFLAG : short 
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG.IDLFLAG_NONE"]/*' />
        IDLFLAG_NONE    = PARAMFLAG.PARAMFLAG_NONE,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG.IDLFLAG_FIN"]/*' />
        IDLFLAG_FIN     = PARAMFLAG.PARAMFLAG_FIN,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG.IDLFLAG_FOUT"]/*' />
        IDLFLAG_FOUT    = PARAMFLAG.PARAMFLAG_FOUT,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG.IDLFLAG_FLCID"]/*' />
        IDLFLAG_FLCID   = PARAMFLAG.PARAMFLAG_FLCID,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLFLAG.IDLFLAG_FRETVAL"]/*' />
        IDLFLAG_FRETVAL = PARAMFLAG.PARAMFLAG_FRETVAL
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLDESC"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct IDLDESC
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLDESC.dwReserved"]/*' />
        public int dwReserved;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="IDLDESC.wIDLFlags"]/*' />
        public IDLFLAG	wIDLFlags;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum PARAMFLAG :short 
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_NONE"]/*' />
        PARAMFLAG_NONE	= 0,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FIN"]/*' />
        PARAMFLAG_FIN	= 0x1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FOUT"]/*' />
        PARAMFLAG_FOUT	= 0x2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FLCID"]/*' />
        PARAMFLAG_FLCID	= 0x4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FRETVAL"]/*' />
        PARAMFLAG_FRETVAL = 0x8,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FOPT"]/*' />
        PARAMFLAG_FOPT	= 0x10,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FHASDEFAULT"]/*' />
        PARAMFLAG_FHASDEFAULT = 0x20,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMFLAG.PARAMFLAG_FHASCUSTDATA"]/*' />
        PARAMFLAG_FHASCUSTDATA = 0x40
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMDESC"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct PARAMDESC
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMDESC.lpVarValue"]/*' />
        public IntPtr lpVarValue;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="PARAMDESC.wParamFlags"]/*' />
        public PARAMFLAG wParamFlags;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEDESC"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct TYPEDESC
    { 
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEDESC.lpValue"]/*' />
        public IntPtr lpValue;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="TYPEDESC.vt"]/*' />
        public Int16 vt;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct ELEMDESC
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC.tdesc"]/*' />
        public TYPEDESC tdesc;

        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC.DESCUNION"]/*' />
        [System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit, CharSet=CharSet.Unicode)]
        [ComVisible(false)]
        public struct DESCUNION
        {
            /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC.DESCUNION.idldesc"]/*' />
            [FieldOffset(0)]
            public IDLDESC idldesc;
            /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC.DESCUNION.paramdesc"]/*' />
            [FieldOffset(0)]
            public PARAMDESC paramdesc;
        };
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="ELEMDESC.desc"]/*' />
        public DESCUNION desc;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct VARDESC
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.memid"]/*' />
        public int memid;                   
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.lpstrSchema"]/*' />
        public String lpstrSchema;

        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.DESCUNION"]/*' />
        [System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit, CharSet=CharSet.Unicode)]
        [ComVisible(false)]
        public struct DESCUNION
        {
            /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DESCUNION.oInst"]/*' />
            [FieldOffset(0)]
            public int oInst;
            /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DESCUNION.lpvarValue"]/*' />
            [FieldOffset(0)]
            public IntPtr lpvarValue;
        };

        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.elemdescVar"]/*' />
        public ELEMDESC elemdescVar;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.wVarFlags"]/*' />
        public short wVarFlags;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARDESC.varkind"]/*' />
        public VarEnum varkind;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DISPPARAMS"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct DISPPARAMS
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DISPPARAMS.rgvarg"]/*' />
        public IntPtr rgvarg;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DISPPARAMS.rgdispidNamedArgs"]/*' />
        public IntPtr rgdispidNamedArgs;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DISPPARAMS.cArgs"]/*' />
        public int cArgs;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="DISPPARAMS.cNamedArgs"]/*' />
        public int cNamedArgs;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO"]/*' />
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    [ComVisible(false)]
    public struct EXCEPINFO
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.wCode"]/*' />
        public Int16 wCode;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.wReserved"]/*' />
        public Int16 wReserved;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.bstrSource"]/*' />
        [MarshalAs(UnmanagedType.BStr)] public String bstrSource;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.bstrDescription"]/*' />
        [MarshalAs(UnmanagedType.BStr)] public String bstrDescription;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.bstrHelpFile"]/*' />
        [MarshalAs(UnmanagedType.BStr)] public String bstrHelpFile;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.dwHelpContext"]/*' />
        public int dwHelpContext;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.pvReserved"]/*' />
        public IntPtr pvReserved;
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="EXCEPINFO.pfnDeferredFillIn"]/*' />
        public IntPtr pfnDeferredFillIn;
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND"]/*' />
    [ComVisible(false), Serializable]
    public enum FUNCKIND : int
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND.FUNC_VIRTUAL"]/*' />
        FUNC_VIRTUAL = 0,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND.FUNC_PUREVIRTUAL"]/*' />
        FUNC_PUREVIRTUAL = 1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND.FUNC_NONVIRTUAL"]/*' />
        FUNC_NONVIRTUAL = 2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND.FUNC_STATIC"]/*' />
        FUNC_STATIC = 3,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCKIND.FUNC_DISPATCH"]/*' />
        FUNC_DISPATCH = 4
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="INVOKEKIND"]/*' />
    [ComVisible(false), Serializable]
    public enum INVOKEKIND : int
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="INVOKEKIND.INVOKE_FUNC"]/*' />
        INVOKE_FUNC = 0x1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="INVOKEKIND.INVOKE_PROPERTYGET"]/*' />
        INVOKE_PROPERTYGET = 0x2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="INVOKEKIND.INVOKE_PROPERTYPUT"]/*' />
        INVOKE_PROPERTYPUT = 0x4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="INVOKEKIND.INVOKE_PROPERTYPUTREF"]/*' />
        INVOKE_PROPERTYPUTREF = 0x8
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV"]/*' />
    [ComVisible(false), Serializable]
    public enum CALLCONV : int
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_CDECL"]/*' />
        CC_CDECL    =1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_MSCPASCAL"]/*' />
        CC_MSCPASCAL=2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_PASCAL"]/*' />
        CC_PASCAL   =CC_MSCPASCAL,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_MACPASCAL"]/*' />
        CC_MACPASCAL=3,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_STDCALL"]/*' />
        CC_STDCALL  =4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_RESERVED"]/*' />
        CC_RESERVED =5,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_SYSCALL"]/*' />
        CC_SYSCALL  =6,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_MPWCDECL"]/*' />
        CC_MPWCDECL =7,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_MPWPASCAL"]/*' />
        CC_MPWPASCAL=8,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="CALLCONV.CC_MAX"]/*' />
        CC_MAX      =9 
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum FUNCFLAGS : short
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FRESTRICTED"]/*' />
        FUNCFLAG_FRESTRICTED=       0x1,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FSOURCE"]/*' />
        FUNCFLAG_FSOURCE	=       0x2,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FBINDABLE"]/*' />
        FUNCFLAG_FBINDABLE	=       0x4,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FREQUESTEDIT"]/*' />
        FUNCFLAG_FREQUESTEDIT =     0x8,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FDISPLAYBIND"]/*' />
        FUNCFLAG_FDISPLAYBIND =     0x10,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FDEFAULTBIND"]/*' />
        FUNCFLAG_FDEFAULTBIND =     0x20,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FHIDDEN"]/*' />
        FUNCFLAG_FHIDDEN =          0x40,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FUSESGETLASTERROR"]/*' />
        FUNCFLAG_FUSESGETLASTERROR= 0x80,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FDEFAULTCOLLELEM"]/*' />
        FUNCFLAG_FDEFAULTCOLLELEM=  0x100,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FUIDEFAULT"]/*' />
        FUNCFLAG_FUIDEFAULT =       0x200,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FNONBROWSABLE"]/*' />
        FUNCFLAG_FNONBROWSABLE =    0x400,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FREPLACEABLE"]/*' />
        FUNCFLAG_FREPLACEABLE =     0x800,
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="FUNCFLAGS.FUNCFLAG_FIMMEDIATEBIND"]/*' />
        FUNCFLAG_FIMMEDIATEBIND =   0x1000
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS"]/*' />
    [ComVisible(false), Serializable,Flags()]
    public enum VARFLAGS : short
    {
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FREADONLY"]/*' />
    	VARFLAG_FREADONLY		=0x1,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FSOURCE"]/*' />
    	VARFLAG_FSOURCE                 	=0x2,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FBINDABLE"]/*' />
    	VARFLAG_FBINDABLE		=0x4,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FREQUESTEDIT"]/*' />
    	VARFLAG_FREQUESTEDIT	=0x8,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FDISPLAYBIND"]/*' />
    	VARFLAG_FDISPLAYBIND	=0x10,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FDEFAULTBIND"]/*' />
    	VARFLAG_FDEFAULTBIND	=0x20,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FHIDDEN"]/*' />
    	VARFLAG_FHIDDEN		=0x40,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FRESTRICTED"]/*' />
    	VARFLAG_FRESTRICTED	=0x80,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FDEFAULTCOLLELEM"]/*' />
    	VARFLAG_FDEFAULTCOLLELEM	=0x100,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FUIDEFAULT"]/*' />
    	VARFLAG_FUIDEFAULT                	=0x200,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FNONBROWSABLE"]/*' />
    	VARFLAG_FNONBROWSABLE       	=0x400,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FREPLACEABLE"]/*' />
    	VARFLAG_FREPLACEABLE	=0x800,
    	/// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="VARFLAGS.VARFLAG_FIMMEDIATEBIND"]/*' />
    	VARFLAG_FIMMEDIATEBIND	=0x1000
    }

    /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo"]/*' />
    [Guid("00020401-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    public interface UCOMITypeInfo
    {
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetTypeAttr"]/*' />
        void GetTypeAttr(out IntPtr ppTypeAttr);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetTypeComp"]/*' />
        void GetTypeComp(out UCOMITypeComp ppTComp);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetFuncDesc"]/*' />
        void GetFuncDesc(int index, out IntPtr ppFuncDesc);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetVarDesc"]/*' />
        void GetVarDesc(int index, out IntPtr ppVarDesc);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetNames"]/*' />
        void GetNames(int memid, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2), Out] String[] rgBstrNames, int cMaxNames, out int pcNames);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetRefTypeOfImplType"]/*' />
        void GetRefTypeOfImplType(int index, out int href);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetImplTypeFlags"]/*' />
        void GetImplTypeFlags(int index, out int pImplTypeFlags);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetIDsOfNames"]/*' />
        void GetIDsOfNames([MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPWStr, SizeParamIndex = 1), In] String[] rgszNames, int cNames, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1), Out] int[] pMemId);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.Invoke"]/*' />
        void Invoke([MarshalAs(UnmanagedType.IUnknown)] Object pvInstance, int memid, Int16 wFlags, ref DISPPARAMS pDispParams, out Object pVarResult, out EXCEPINFO pExcepInfo, out int puArgErr);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetDocumentation"]/*' />
        void GetDocumentation(int index, out String strName, out String strDocString, out int dwHelpContext, out String strHelpFile);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetDllEntry"]/*' />
        void GetDllEntry(int memid, INVOKEKIND invKind, out String pBstrDllName, out String pBstrName, out Int16 pwOrdinal);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetRefTypeInfo"]/*' />
        void GetRefTypeInfo(int hRef, out UCOMITypeInfo ppTI);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.AddressOfMember"]/*' />
        void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.CreateInstance"]/*' />
        void CreateInstance([MarshalAs(UnmanagedType.IUnknown)] Object pUnkOuter, ref Guid riid, [MarshalAs(UnmanagedType.IUnknown), Out] out Object ppvObj);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetMops"]/*' />
        void GetMops(int memid, out String pBstrMops);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.GetContainingTypeLib"]/*' />
        void GetContainingTypeLib(out UCOMITypeLib ppTLB, out int pIndex);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.ReleaseTypeAttr"]/*' />
        void ReleaseTypeAttr(IntPtr pTypeAttr);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.ReleaseFuncDesc"]/*' />
        void ReleaseFuncDesc(IntPtr pFuncDesc);
        /// <include file='doc\UCOMITypeInfo.uex' path='docs/doc[@for="UCOMITypeInfo.ReleaseVarDesc"]/*' />
        void ReleaseVarDesc(IntPtr pVarDesc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\expando\iexpando.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// IExpando is an interface which allows Objects implemeningt this interface 
//	support the ability to modify the object by adding and removing members, 
//	represented by MemberInfo objects.
//
// Author: darylo
// Date: March 98
//
// The IExpando Interface.
namespace System.Runtime.InteropServices.Expando {
    
	using System;
	using System.Reflection;

    /// <include file='doc\IExpando.uex' path='docs/doc[@for="IExpando"]/*' />
    [Guid("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]    
    public interface IExpando : IReflect
    {
    	// Add a new Field to the reflection object.  The field has
    	// name as its name.
        /// <include file='doc\IExpando.uex' path='docs/doc[@for="IExpando.AddField"]/*' />
        FieldInfo AddField(String name);

    	// Add a new Property to the reflection object.  The property has
    	// name as its name.
	    /// <include file='doc\IExpando.uex' path='docs/doc[@for="IExpando.AddProperty"]/*' />
	    PropertyInfo AddProperty(String name);

    	// Add a new Method to the reflection object.  The method has 
    	// name as its name and method is a delegate
    	// to the method.  
        /// <include file='doc\IExpando.uex' path='docs/doc[@for="IExpando.AddMethod"]/*' />
        MethodInfo AddMethod(String name, Delegate method);

    	// Removes the specified member.
        /// <include file='doc\IExpando.uex' path='docs/doc[@for="IExpando.RemoveMember"]/*' />
        void RemoveMember(MemberInfo m);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\unknownwrapper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: UnknownWrapper.
**
** Author: David Mortenson(dmortens)
**
** Purpose: Wrapper that is converted to a variant with VT_UNKNOWN.
**
** Date: June 28, 2000
**
=============================================================================*/

namespace System.Runtime.InteropServices {
   
    using System;

    /// <include file='doc\UnknownWrapper.uex' path='docs/doc[@for="UnknownWrapper"]/*' />
    public sealed class UnknownWrapper
    {
		/// <include file='doc\UnknownWrapper.uex' path='docs/doc[@for="UnknownWrapper.UnknownWrapper"]/*' />
		public UnknownWrapper(Object obj)
		{
			m_WrappedObject = obj;
		}

        /// <include file='doc\UnknownWrapper.uex' path='docs/doc[@for="UnknownWrapper.WrappedObject"]/*' />
        public Object WrappedObject 
		{
			get 
			{
				return m_WrappedObject;
			}
        }

		private Object m_WrappedObject;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\vtablecallsnotsupportedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: VTableCallsNotSupportedException
**
** Purpose: This exception is thrown when COM+ code attempts to call a VTable
**			method on a disp only COM interface.
**
=============================================================================*/

namespace System.Runtime.InteropServices {

	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\VTableCallsNotSupportedException.uex' path='docs/doc[@for="VTableCallsNotSupportedException"]/*' />
    [Obsolete("This exception is no longer thrown by the runtime and will be removed in the next breaking change")]
    [Serializable] public class VTableCallsNotSupportedException : SystemException {
        /// <include file='doc\VTableCallsNotSupportedException.uex' path='docs/doc[@for="VTableCallsNotSupportedException.VTableCallsNotSupportedException"]/*' />
        public VTableCallsNotSupportedException() 
            : base(Environment.GetResourceString("Arg_VTableCallsNotSupportedException")) {
    		SetErrorCode(__HResults.COR_E_VTABLECALLSNOTSUPPORTED);
        }
    
        /// <include file='doc\VTableCallsNotSupportedException.uex' path='docs/doc[@for="VTableCallsNotSupportedException.VTableCallsNotSupportedException1"]/*' />
        public VTableCallsNotSupportedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_VTABLECALLSNOTSUPPORTED);
        }
    
        /// <include file='doc\VTableCallsNotSupportedException.uex' path='docs/doc[@for="VTableCallsNotSupportedException.VTableCallsNotSupportedException2"]/*' />
        public VTableCallsNotSupportedException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_VTABLECALLSNOTSUPPORTED);
        }

        protected VTableCallsNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\eventitfinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {

    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;

    internal class EventItfInfo
    {
        public EventItfInfo(String strEventItfName,
                            String strSrcItfName,
                            String strEventProviderName,
                            Assembly asmImport,
                            Assembly asmSrcItf)
        {
            m_strEventItfName = strEventItfName;
            m_strSrcItfName = strSrcItfName;
            m_strEventProviderName = strEventProviderName;
            m_asmImport = asmImport;
            m_asmSrcItf = asmSrcItf;
        }
        
        public Type GetEventItfType()
        {
            return m_asmImport.GetTypeInternal(m_strEventItfName, true, false, true);
        }

        public Type GetSrcItfType()
        {
            return m_asmSrcItf.GetTypeInternal(m_strSrcItfName, true, false, true);
        }

        public String GetEventProviderName()
        {
            return m_strEventProviderName;
        }
        
        private String m_strEventItfName;
        private String m_strSrcItfName;
        private String m_strEventProviderName;
        private Assembly m_asmImport;
        private Assembly m_asmSrcItf;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\namespaceextractor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {

	using System;
	internal class NameSpaceExtractor
	{
		private static char NameSpaceSeperator = '.';
		
		public static String ExtractNameSpace(String FullyQualifiedTypeName)
		{
			int TypeNameStartPos = FullyQualifiedTypeName.LastIndexOf(NameSpaceSeperator);
			if (TypeNameStartPos == -1)
				return "";
			else
				return FullyQualifiedTypeName.Substring(0, TypeNameStartPos);
 		}
		
		public static String ExtractTypeName(String FullyQualifiedTypeName)
		{
			int TypeNameStartPos = FullyQualifiedTypeName.LastIndexOf(NameSpaceSeperator);
			if (TypeNameStartPos == -1)
				return FullyQualifiedTypeName;
			else
				return FullyQualifiedTypeName.Substring(TypeNameStartPos + 1);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\eventsource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {

    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;

    internal class EventSource
    {
        public EventSource(String strBaseClassName,
                           String strTCEClassName,
                           Assembly assembly)
        {
            m_strBaseClassName = strBaseClassName;
            m_strTCEClassName = strTCEClassName;
            m_assembly = assembly;
        }

        public void AddInterface(String strItfName)
        {
            m_SourceInterfaceList.Add(strItfName);
        }
        
        public String GetBaseTypeName()
        {
            return m_strBaseClassName;
        }
        
        public String GetTCETypeName()
        {
            return m_strTCEClassName;
        }
        
        public Type GetBaseType()
        {
            return m_assembly.GetTypeInternal(m_strBaseClassName, true, false, true);
        }
        
        public Type []GetInterfaceTypes()
        {
            int RealLength = 0;
            Type[] aTypes = new Type[m_SourceInterfaceList.Count];
            
            // Load the interfaces implemented by this event source.
            for (int cInterfaces = 0; cInterfaces < m_SourceInterfaceList.Count; cInterfaces++)
            {
                aTypes[cInterfaces] = m_assembly.GetTypeInternal((String)m_SourceInterfaceList[cInterfaces], false, false, true);
                
                if (aTypes[cInterfaces] != null)
                    RealLength++;
            }
            
            // If some interfaces failed to load then we need to compact the array so that
            // it only contains the ones that loaded successfully.
            if (RealLength != m_SourceInterfaceList.Count)
            {
                Type[] aNewTypes = new Type[RealLength];
                int cValidInterfaces = 0;
                for (int cInterfaces = 0; cInterfaces < m_SourceInterfaceList.Count; cInterfaces++)
                {
                    if (aTypes[cInterfaces] != null)
                        aNewTypes[cValidInterfaces++] = aTypes[cInterfaces];
                }
                aTypes = aNewTypes;     
            }
            
            return aTypes;
        }
        
        private String m_strBaseClassName;
        private String m_strTCEClassName;
        private ArrayList m_SourceInterfaceList = new ArrayList();
        private Assembly m_assembly;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\asyncresult.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: AsyncResult
**
** Purpose: Object to encapsulate the results of an async
**          operation
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
    using System.Threading;
    using System.Runtime.Remoting;
    using System;
    
    /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult"]/*' />
    public class AsyncResult : IAsyncResult, IMessageSink
    {
    
        internal AsyncResult(Message m)
        {
            m.GetAsyncBeginInfo(out _acbd, out _asyncState);
            _asyncDelegate = (Delegate) m.GetThisPtr();
        }

    
        // True if the asynchronous operation has been completed.
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.IsCompleted"]/*' />
        public virtual bool IsCompleted 
        {  
            get
            {
               return _isCompleted;
            }
        }
        // The delegate object on which the async call was invoked.
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.AsyncDelegate"]/*' />
        public virtual Object AsyncDelegate  
        {
            get
            {
                return _asyncDelegate;
            }
    
        }
        
        // The state object passed in via BeginInvoke.
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.AsyncState"]/*' />
        public virtual Object AsyncState
        {
            get
            {
                return _asyncState;
            }
    
        }
    
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.CompletedSynchronously"]/*' />
        public virtual bool CompletedSynchronously
        {
            get
            {
                return false;
            }
        }

        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.EndInvokeCalled"]/*' />
        public bool EndInvokeCalled
        {
            get
            {
                return _endInvokeCalled;
            }
            set
            {
                BCLDebug.Assert(!_endInvokeCalled && value,
                                "EndInvoke prevents multiple calls");

                _endInvokeCalled = value;
            }
        }
    
        private void FaultInWaitHandle()
        {
            lock(this) {
                if (_AsyncWaitHandle == null)
                {
                    _AsyncWaitHandle = new ManualResetEvent(false);
                }
            }
        }
    
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.AsyncWaitHandle"]/*' />
        public virtual WaitHandle AsyncWaitHandle
        {
            get
            {
                FaultInWaitHandle();
                return _AsyncWaitHandle;
            }
        }
    
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.SetMessageCtrl"]/*' />
        public virtual void SetMessageCtrl(IMessageCtrl mc)
        {
            _mc = mc;
        }
    
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.SyncProcessMessage"]/*' />
        public virtual IMessage     SyncProcessMessage(IMessage msg)
        {
            if (msg == null) 
            {
                _replyMsg = new ReturnMessage(new RemotingException(Environment.GetResourceString("Remoting_NullMessage")), new ErrorMessage());
            }
            else if (!(msg is IMethodReturnMessage))
            {
                _replyMsg = new ReturnMessage(new RemotingException(Environment.GetResourceString("Remoting_Message_BadType")), new ErrorMessage());
            }
            else
            {
                _replyMsg = msg;
            }

            _isCompleted = true;
            FaultInWaitHandle();

            // If profiling, we want to notify the profiler that the remoting code is
            // essentially done (other than returning up the callstack, which happens
            // after the result is saved and/or used so doesn't really count for anything.
            if (RemotingServices.CORProfilerTrackRemotingAsync())
                RemotingServices.CORProfilerRemotingClientInvocationFinished();

            _AsyncWaitHandle.Set();
            if (_acbd != null)
            {
                // NOTE: We are invoking user code here!
                _acbd(this);
            }
            return null;
        }
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.AsyncProcessMessage"]/*' />
        public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));
        }
    
        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.NextSink"]/*' />
        public IMessageSink NextSink
        {
            get
            {
                return null;
            }
        }

        /// <include file='doc\AsyncResult.uex' path='docs/doc[@for="AsyncResult.GetReplyMessage"]/*' />
        public virtual IMessage GetReplyMessage()      {return _replyMsg;}
    
        private IMessageCtrl          _mc;
        private AsyncCallback         _acbd;
        private IMessage              _replyMsg;
        private bool                  _isCompleted;
        private bool                  _endInvokeCalled;
        private ManualResetEvent      _AsyncWaitHandle;
        private Delegate              _asyncDelegate;
        private Object                _asyncState;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\eventproviderwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {
    using System.Runtime.InteropServices;
    using ubyte = System.Byte;
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;
    using System.Threading;
    
    internal class EventProviderWriter
    {
        private const BindingFlags DefaultLookup = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;
        
        public static readonly String GeneratedClassNamePostfix = "";
        
        public EventProviderWriter( ModuleBuilder OutputModule, String strDestTypeName, Type EventItfType, Type SrcItfType, Type SinkHelperType )
        {
            m_OutputModule = OutputModule;  
            m_strDestTypeName = strDestTypeName;
            m_EventItfType = EventItfType;
            m_SrcItfType = SrcItfType;
            m_SinkHelperType = SinkHelperType;
        }
        
        public Type Perform()
        {       
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "Writing event provider class " + m_strDestTypeName );
                        
            // Create the event provider class.
            TypeBuilder OutputTypeBuilder = m_OutputModule.DefineType(
                m_strDestTypeName,
                TypeAttributes.Sealed | TypeAttributes.NotPublic, 
                typeof(Object),
                new Type[]{m_EventItfType, typeof(IDisposable)}
                );

            // Create the event source field.
            FieldBuilder fbCPC = OutputTypeBuilder.DefineField( 
                "m_ConnectionPointContainer", 
                typeof(UCOMIConnectionPointContainer), 
                FieldAttributes.Private
                );
            
            // Create array of event sink helpers.
            FieldBuilder fbSinkHelper = OutputTypeBuilder.DefineField( 
                "m_aEventSinkHelpers", 
                typeof(ArrayList), 
                FieldAttributes.Private
                );
            
            // Define the connection point field.
            FieldBuilder fbEventCP = OutputTypeBuilder.DefineField( 
                "m_ConnectionPoint", 
                typeof(UCOMIConnectionPoint),
                FieldAttributes.Private
                );
            
            // Define the InitXXX method.
            MethodBuilder InitSrcItfMethodBuilder = 
                DefineInitSrcItfMethod( OutputTypeBuilder, m_SrcItfType, fbSinkHelper, fbEventCP, fbCPC );
                        
            // Process all the methods in the event interface.
            MethodInfo[] aMethods = m_SrcItfType.GetMethods();  
            for ( int cMethods = 0; cMethods < aMethods.Length; cMethods++ )
            {
                if ( m_SrcItfType == aMethods[cMethods].DeclaringType )
                {
                    if ( TCEAdapterGenerator.m_bVerbose ) {          
                        Console.Write( "    -> Processing event method " );             
                        Console.WriteLine(  aMethods[cMethods].Name );              
                    }               
                    
                    // Define the add_XXX method.
                    MethodBuilder AddEventMethodBuilder = DefineAddEventMethod( 
                        OutputTypeBuilder, aMethods[cMethods], m_SinkHelperType, fbSinkHelper, fbEventCP, InitSrcItfMethodBuilder );
                    
                    // Define the remove_XXX method.
                    MethodBuilder RemoveEventMethodBuilder = DefineRemoveEventMethod( 
                        OutputTypeBuilder, aMethods[cMethods], m_SinkHelperType, fbSinkHelper, fbEventCP );
                }
            }	
            
            // Define the constructor.
            DefineConstructor( OutputTypeBuilder, fbCPC );
            
            // Define the finalize method.
            MethodBuilder FinalizeMethod = DefineFinalizeMethod( OutputTypeBuilder, m_SinkHelperType, fbSinkHelper, fbEventCP );
            
            // Define the Dispose method.
            DefineDisposeMethod( OutputTypeBuilder, FinalizeMethod);

            return OutputTypeBuilder.CreateType();
        }
        
        private MethodBuilder DefineAddEventMethod( TypeBuilder OutputTypeBuilder, MethodInfo SrcItfMethod, Type SinkHelperClass, FieldBuilder fbSinkHelperArray, FieldBuilder fbEventCP, MethodBuilder mbInitSrcItf )
        {
            Type[] aParamTypes;
            
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "        *Defining add method" );
            
            // Find the delegate on the event sink helper.
            FieldInfo DelegateField = SinkHelperClass.GetField( "m_" + SrcItfMethod.Name + "Delegate" );
            BCLDebug.Assert(DelegateField != null, "Unable to find the field m_" + SrcItfMethod.Name + "Delegate on the sink helper");
            
            // Find the cookie on the event sink helper.
            FieldInfo CookieField = SinkHelperClass.GetField( "m_dwCookie" );
            BCLDebug.Assert(CookieField != null, "Unable to find the field m_dwCookie on the sink helper");
            
            // Retrieve the sink helper's constructor.
            ConstructorInfo SinkHelperCons = SinkHelperClass.GetConstructor(EventProviderWriter.DefaultLookup | BindingFlags.NonPublic, null, new Type[0], null );	
            BCLDebug.Assert(SinkHelperCons != null, "Unable to find the constructor for the sink helper");
            
            // Retrieve the IConnectionPoint.Advise method.
            MethodInfo CPAdviseMethod = typeof(UCOMIConnectionPoint).GetMethod( "Advise" );
            BCLDebug.Assert(CPAdviseMethod != null, "Unable to find the method ConnectionPoint.Advise");
           
            // Retrieve the ArrayList.Add method.
            aParamTypes = new Type[1];
            aParamTypes[0] = typeof(Object);
            MethodInfo ArrayListAddMethod = typeof(ArrayList).GetMethod( "Add", aParamTypes, null );
            BCLDebug.Assert(ArrayListAddMethod != null, "Unable to find the method ArrayList.Add");

            // Retrieve the Monitor.Enter() method.
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorEnterMethod = typeof(Monitor).GetMethod( "Enter", aParamTypes, null );
            BCLDebug.Assert(MonitorEnterMethod != null, "Unable to find the method Monitor.Enter()");
            
            // Retrieve the Monitor.Exit() method.
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorExitMethod = typeof(Monitor).GetMethod( "Exit", aParamTypes, null );
            BCLDebug.Assert(MonitorExitMethod != null, "Unable to find the method Monitor.Exit()");
            
            // Define the add_XXX method.
            Type[] parameterTypes;
            parameterTypes = new Type[1];
            parameterTypes[0] = DelegateField.FieldType;
            MethodBuilder Meth = OutputTypeBuilder.DefineMethod(
                "add_" + SrcItfMethod.Name,
                MethodAttributes.Public | MethodAttributes.Virtual,
                null,
                parameterTypes );
            
            ILGenerator il = Meth.GetILGenerator();
            
            // Define a label for the m_IFooEventsCP comparision.
            Label EventCPNonNullLabel = il.DefineLabel();
            
            // Declare the local variables.
            LocalBuilder ltSinkHelper = il.DeclareLocal( SinkHelperClass );
            LocalBuilder ltCookie = il.DeclareLocal( typeof(Int32) );

            // Generate the following code:
            //   Monitor.Enter(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorEnterMethod );

            // Generate the following code:
            //   try {
            il.BeginExceptionBlock();
            
            // Generate the following code:
            //   if ( m_IFooEventsCP != null ) goto EventCPNonNullLabel;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Brtrue, EventCPNonNullLabel );
            
            // Generate the following code:
            //   InitIFooEvents();
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, mbInitSrcItf );
            
            // Mark this as label to jump to if the CP is not null.
            il.MarkLabel( EventCPNonNullLabel );
            
            // Generate the following code:
            //   IFooEvents_SinkHelper SinkHelper = new IFooEvents_SinkHelper;  
            il.Emit( OpCodes.Newobj, SinkHelperCons );
            il.Emit( OpCodes.Stloc, ltSinkHelper );
            
            // Generate the following code:
            //   dwCookie = 0;
            il.Emit( OpCodes.Ldc_I4_0 );
            il.Emit( OpCodes.Stloc, ltCookie );
            
            // Generate the following code:
            //   m_IFooEventsCP.Advise( SinkHelper, dwCookie );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Ldloc, ltSinkHelper );
            il.Emit( OpCodes.Castclass, typeof(Object) );
            il.Emit( OpCodes.Ldloca, ltCookie );
            il.Emit( OpCodes.Callvirt, CPAdviseMethod );
            
            // Generate the following code:
            //   SinkHelper.m_dwCookie = dwCookie;
            il.Emit( OpCodes.Ldloc, ltSinkHelper );
            il.Emit( OpCodes.Ldloc, ltCookie );
            il.Emit( OpCodes.Stfld, CookieField );
            
            // Generate the following code:
            //   SinkHelper.m_FooDelegate = d;
            il.Emit( OpCodes.Ldloc, ltSinkHelper );
            il.Emit( OpCodes.Ldarg, (short)1 );
            il.Emit( OpCodes.Stfld, DelegateField );
            
            // Generate the following code:
            //   m_aIFooEventsHelpers.Add( SinkHelper );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelperArray );
            il.Emit( OpCodes.Ldloc, ltSinkHelper );
            il.Emit( OpCodes.Castclass, typeof(Object) );
            il.Emit( OpCodes.Callvirt, ArrayListAddMethod );
            il.Emit( OpCodes.Pop );
            
            // Generate the following code:
            //   } finally {
            il.BeginFinallyBlock();

            // Generate the following code:
            //   Monitor.Exit(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorExitMethod );

            // Generate the following code:
            //   }
            il.EndExceptionBlock();            

            // Generate the return opcode.
            il.Emit( OpCodes.Ret );
            
            return Meth;
        }
        
        private MethodBuilder DefineRemoveEventMethod( TypeBuilder OutputTypeBuilder, MethodInfo SrcItfMethod, Type SinkHelperClass, FieldBuilder fbSinkHelperArray, FieldBuilder fbEventCP )
        {
            Type[] aParamTypes;
            
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "        *Defining remove method" );
            
            // Find the delegate on the event sink helper.
            FieldInfo DelegateField = SinkHelperClass.GetField( "m_" + SrcItfMethod.Name + "Delegate" );
            BCLDebug.Assert(DelegateField != null, "Unable to find the field m_" + SrcItfMethod.Name + "Delegate on the sink helper");
            
            // Find the cookie on the event sink helper.
            FieldInfo CookieField = SinkHelperClass.GetField( "m_dwCookie" );
            BCLDebug.Assert(CookieField != null, "Unable to find the field m_dwCookie on the sink helper");
            
            // Retrieve the ArrayList.RemoveAt method.
            aParamTypes = new Type[1];
            aParamTypes[0] = typeof(Int32);
            MethodInfo ArrayListRemoveMethod = typeof(ArrayList).GetMethod( "RemoveAt", aParamTypes, null );
            BCLDebug.Assert(ArrayListRemoveMethod != null, "Unable to find the method ArrayList.RemoveAt()");
            
            // Retrieve the ArrayList.Item property get method.
            PropertyInfo ArrayListItemProperty = typeof(ArrayList).GetProperty( "Item" );
            BCLDebug.Assert(ArrayListItemProperty != null, "Unable to find the property ArrayList.Item");
            MethodInfo ArrayListItemGetMethod = ArrayListItemProperty.GetGetMethod();
            BCLDebug.Assert(ArrayListItemGetMethod != null, "Unable to find the get method for property ArrayList.Item");
            
            // Retrieve the ArrayList.Count property get method.
            PropertyInfo ArrayListSizeProperty = typeof(ArrayList).GetProperty( "Count" );
            BCLDebug.Assert(ArrayListSizeProperty != null, "Unable to find the property ArrayList.Count");
            MethodInfo ArrayListSizeGetMethod = ArrayListSizeProperty.GetGetMethod();
            BCLDebug.Assert(ArrayListSizeGetMethod != null, "Unable to find the get method for property ArrayList.Count");
            
            // Retrieve the Delegate.Equals() method.
            aParamTypes[0] = typeof(Delegate);
            MethodInfo DelegateEqualsMethod = typeof(Delegate).GetMethod( "Equals", aParamTypes, null );
            BCLDebug.Assert(DelegateEqualsMethod != null, "Unable to find the method Delegate.Equlals()");
            
            // Retrieve the Monitor.Enter() method.
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorEnterMethod = typeof(Monitor).GetMethod( "Enter", aParamTypes, null );
            BCLDebug.Assert(MonitorEnterMethod != null, "Unable to find the method Monitor.Enter()");
            
            // Retrieve the Monitor.Exit() method.
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorExitMethod = typeof(Monitor).GetMethod( "Exit", aParamTypes, null );
            BCLDebug.Assert(MonitorExitMethod != null, "Unable to find the method Monitor.Exit()");
            
            // Retrieve the ConnectionPoint.Unadvise() method.
            MethodInfo CPUnadviseMethod = typeof(UCOMIConnectionPoint).GetMethod( "Unadvise" );
            BCLDebug.Assert(CPUnadviseMethod != null, "Unable to find the method ConnectionPoint.Unadvise()");

            // Retrieve the Marshal.ReleaseComObject() method.
            MethodInfo ReleaseComObjectMethod = typeof(Marshal).GetMethod( "ReleaseComObject" );
            BCLDebug.Assert(ReleaseComObjectMethod != null, "Unable to find the method Marshal.ReleaseComObject()");
            
            // Define the remove_XXX method.
            Type[] parameterTypes;
            parameterTypes = new Type[1];
            parameterTypes[0] = DelegateField.FieldType;
            MethodBuilder Meth = OutputTypeBuilder.DefineMethod(
                "remove_" + SrcItfMethod.Name,
                MethodAttributes.Public | MethodAttributes.Virtual,
                null,
                parameterTypes );
            
            ILGenerator il = Meth.GetILGenerator();
            
            // Declare the local variables.
            LocalBuilder ltNumSinkHelpers = il.DeclareLocal( typeof(Int32) );
            LocalBuilder ltSinkHelperCounter = il.DeclareLocal( typeof(Int32) );
            LocalBuilder ltCurrSinkHelper = il.DeclareLocal( SinkHelperClass );		
            
            // Generate the labels for the for loop.
            Label ForBeginLabel = il.DefineLabel();
            Label ForEndLabel = il.DefineLabel();
            Label FalseIfLabel = il.DefineLabel();
            Label MonitorExitLabel = il.DefineLabel();
            
            // Generate the following code:
            //   Monitor.Enter(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorEnterMethod );

            // Generate the following code:
            //   try {
            il.BeginExceptionBlock();

            // Generate the following code:
            //   int NumEventHelpers = m_aIFooEventsHelpers.Count;
            //   int cEventHelpers = 0;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelperArray );
            il.Emit( OpCodes.Callvirt, ArrayListSizeGetMethod );
            il.Emit( OpCodes.Stloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Ldc_I4, 0 );
            il.Emit( OpCodes.Stloc, ltSinkHelperCounter );
            
            // Generate the following code:
            //   if ( 0 >= NumEventHelpers ) goto ForEndLabel;		
            il.Emit( OpCodes.Ldc_I4, 0 );
            il.Emit( OpCodes.Ldloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Bge, ForEndLabel );
            
            // Mark this as the beginning of the for loop's body.
            il.MarkLabel( ForBeginLabel );
            
            // Generate the following code:
            //   CurrentHelper = (IFooEvents_SinkHelper)m_aIFooEventsHelpers.Get( cEventHelpers );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelperArray );
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Callvirt, ArrayListItemGetMethod );
            il.Emit( OpCodes.Castclass, SinkHelperClass );
            il.Emit( OpCodes.Stloc, ltCurrSinkHelper );
            
            // Generate the following code:
            //   if ( CurrentHelper.m_FooDelegate )
            il.Emit( OpCodes.Ldloc, ltCurrSinkHelper );
            il.Emit( OpCodes.Ldfld, DelegateField );
            il.Emit( OpCodes.Ldnull );
            il.Emit( OpCodes.Beq, FalseIfLabel );
            
            // Generate the following code:
            //   if ( CurrentHelper.m_FooDelegate.Equals( d ) )
            il.Emit( OpCodes.Ldloc, ltCurrSinkHelper );
            il.Emit( OpCodes.Ldfld, DelegateField );
            il.Emit( OpCodes.Ldarg, (short)1 );
            il.Emit( OpCodes.Castclass, typeof(Object) );
            il.Emit( OpCodes.Callvirt, DelegateEqualsMethod );
            il.Emit( OpCodes.Ldc_I4, 0xff );
            il.Emit( OpCodes.And );
            il.Emit( OpCodes.Ldc_I4, 0 );
            il.Emit( OpCodes.Beq, FalseIfLabel );
            
            // Generate the following code:
            //   m_aIFooEventsHelpers.RemoveAt( cEventHelpers );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelperArray );
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Callvirt, ArrayListRemoveMethod );
            
            // Generate the following code:
            //   m_IFooEventsCP.Unadvise( CurrentHelper.m_dwCookie );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Ldloc, ltCurrSinkHelper );
            il.Emit( OpCodes.Ldfld, CookieField );
            il.Emit( OpCodes.Callvirt, CPUnadviseMethod );
            
            // Generate the following code:
            //   if ( NumEventHelpers > 1) break;
            il.Emit( OpCodes.Ldloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Ldc_I4, 1 );
            il.Emit( OpCodes.Bgt, ForEndLabel );
                       
            // Generate the following code:
            //   Marshal.ReleaseComObject(m_IFooEventsCP);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Call, ReleaseComObjectMethod );            
            il.Emit( OpCodes.Pop );

            // Generate the following code:
            //   m_IFooEventsCP = null;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldnull );
            il.Emit( OpCodes.Stfld, fbEventCP );
            
            // Generate the following code:
            //   m_aIFooEventsHelpers = null;      
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldnull );
            il.Emit( OpCodes.Stfld, fbSinkHelperArray );
            
            // Generate the following code:
            //   break;
            il.Emit( OpCodes.Br, ForEndLabel );
            
            // Mark this as the label to jump to when the if statement is false.
            il.MarkLabel( FalseIfLabel );       
            
            // Generate the following code:
            //   cEventHelpers++;
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Ldc_I4, 1 );
            il.Emit( OpCodes.Add );
            il.Emit( OpCodes.Stloc, ltSinkHelperCounter );
            
            // Generate the following code:
            //   if ( cEventHelpers < NumEventHelpers ) goto ForBeginLabel;
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Ldloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Blt, ForBeginLabel );
            
            // Mark this as the end of the for loop's body.
            il.MarkLabel( ForEndLabel );

            // Generate the following code:
            //   } finally {
            il.BeginFinallyBlock();

            // Generate the following code:
            //   Monitor.Exit(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorExitMethod );

            // Generate the following code:
            //   }
            il.EndExceptionBlock();            

            // Generate the return opcode.
            il.Emit( OpCodes.Ret );
            
            return Meth;
        }

        private MethodBuilder DefineInitSrcItfMethod( TypeBuilder OutputTypeBuilder, Type SourceInterface, FieldBuilder fbSinkHelperArray, FieldBuilder fbEventCP, FieldBuilder fbCPC )
        {
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "    *Defining InitSrcItf method" );	
            
            // Retrieve the constructor info for the array list's default constructor.
            ConstructorInfo DefaultArrayListCons = typeof(ArrayList).GetConstructor(EventProviderWriter.DefaultLookup, null, new Type[0], null );
            BCLDebug.Assert(DefaultArrayListCons != null, "Unable to find the constructor for class ArrayList");	
            
            // Temp byte array for Guid
            ubyte[] rgByteGuid = new ubyte[16];
            
            // Retrieve the constructor info for the Guid constructor.
            Type[] aParamTypes = new Type[1];
            aParamTypes[0] = typeof(Byte[]);
            ConstructorInfo ByteArrayGUIDCons = typeof(Guid).GetConstructor(EventProviderWriter.DefaultLookup, null, aParamTypes, null );
            BCLDebug.Assert(ByteArrayGUIDCons != null, "Unable to find the constructor for GUID that accepts a string as argument");	
            
            // Retrieve the IConnectionPointContainer.FindConnectionPoint() method.
            MethodInfo CPCFindCPMethod = typeof(UCOMIConnectionPointContainer).GetMethod( "FindConnectionPoint" );
            BCLDebug.Assert(CPCFindCPMethod != null, "Unable to find the method ConnectionPointContainer.FindConnectionPoint()");	
            
            // Define the Init method itself.
            MethodBuilder Meth = OutputTypeBuilder.DefineMethod(
                "Init", 
                MethodAttributes.Private, 
                null, 
                null );
            
            ILGenerator il = Meth.GetILGenerator();
            
            // Declare the local variables.
            LocalBuilder ltCP = il.DeclareLocal( typeof(UCOMIConnectionPoint) );
            LocalBuilder ltEvGuid = il.DeclareLocal( typeof(Guid) );
            LocalBuilder ltByteArrayGuid = il.DeclareLocal( typeof(Byte[]) );
            
            // Generate the following code:
            //   IConnectionPoint CP = NULL;
            il.Emit( OpCodes.Ldnull );
            il.Emit( OpCodes.Stloc, ltCP );
            
            // Get unsigned byte array for the GUID of the event interface.
            rgByteGuid = SourceInterface.GUID.ToByteArray();
            
            // Generate the following code:
            //  ubyte rgByteArray[] = new ubyte [16];
            il.Emit( OpCodes.Ldc_I4, 0x10 );
            il.Emit( OpCodes.Newarr, typeof(Byte) ); 
            il.Emit( OpCodes.Stloc, ltByteArrayGuid );
            
            // Generate the following code:
            //  rgByteArray[i] = rgByteGuid[i];
            for (int i = 0; i < 16; i++ )
            {
                il.Emit( OpCodes.Ldloc, ltByteArrayGuid );
                il.Emit( OpCodes.Ldc_I4, i );
                il.Emit( OpCodes.Ldc_I4, (int) (rgByteGuid[i]) );
                il.Emit( OpCodes.Stelem_I1);
            }
            
            // Generate the following code:
            //   EventItfGuid = Guid( ubyte b[] );          
            il.Emit( OpCodes.Ldloca, ltEvGuid );
            il.Emit( OpCodes.Ldloc, ltByteArrayGuid );
            il.Emit( OpCodes.Call, ByteArrayGUIDCons );
            
            // Generate the following code:
            //   m_ConnectionPointContainer.FindConnectionPoint( EventItfGuid, CP );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbCPC );
            il.Emit( OpCodes.Ldloca, ltEvGuid );
            il.Emit( OpCodes.Ldloca, ltCP );
            il.Emit( OpCodes.Callvirt, CPCFindCPMethod );
            
            // Generate the following code:
            //   m_ConnectionPoint = (UCOMIConnectionPoint)CP;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldloc, ltCP );
            il.Emit( OpCodes.Castclass, typeof(UCOMIConnectionPoint) );
            il.Emit( OpCodes.Stfld, fbEventCP );
            
            // Generate the following code:
            //   m_aEventSinkHelpers = new ArrayList;      
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Newobj, DefaultArrayListCons );
            il.Emit( OpCodes.Stfld, fbSinkHelperArray );   
            
            // Generate the return opcode.
            il.Emit( OpCodes.Ret );
            
            return Meth;
        }
        
        private void DefineConstructor( TypeBuilder OutputTypeBuilder, FieldBuilder fbCPC )
        {
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "    *Defining Constructor" );	
        
            // Retrieve the constructor info for the base class's constructor.
            ConstructorInfo DefaultBaseClsCons = typeof(Object).GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, new Type[0], null );
            BCLDebug.Assert(DefaultBaseClsCons != null, "Unable to find the object's public default constructor");
            
            // Define the default constructor.
            MethodAttributes ctorAttributes = MethodAttributes.SpecialName | (DefaultBaseClsCons.Attributes & MethodAttributes.MemberAccessMask);
            MethodBuilder Cons = OutputTypeBuilder.DefineMethod( 
                ".ctor", 
                ctorAttributes, 
                null, 
                new Type[]{typeof(Object)} );
            
            ILGenerator il = Cons.GetILGenerator();
            
            // Generate the call to the base class constructor.
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, DefaultBaseClsCons );
            
            // Generate the following code:
            //   m_ConnectionPointContainer = (IConnectionPointContainer)EventSource;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldarg, (short)1 );
            il.Emit( OpCodes.Castclass, typeof(UCOMIConnectionPointContainer) );
            il.Emit( OpCodes.Stfld, fbCPC );

            // Generate the return opcode.
            il.Emit( OpCodes.Ret );
        }
               
        private MethodBuilder DefineFinalizeMethod( TypeBuilder OutputTypeBuilder, Type SinkHelperClass, FieldBuilder fbSinkHelper, FieldBuilder fbEventCP )
        {
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "    *Defining Finalize method" );
            
            // Find the cookie on the event sink helper.
            FieldInfo CookieField = SinkHelperClass.GetField( "m_dwCookie" );
            BCLDebug.Assert(CookieField != null, "Unable to find the field m_dwCookie on the sink helper");	

            // Retrieve the ArrayList.Item property get method.
            PropertyInfo ArrayListItemProperty = typeof(ArrayList).GetProperty( "Item" );
            BCLDebug.Assert(ArrayListItemProperty != null, "Unable to find the property ArrayList.Item");	
            MethodInfo ArrayListItemGetMethod = ArrayListItemProperty.GetGetMethod();
            BCLDebug.Assert(ArrayListItemGetMethod != null, "Unable to find the get method for property ArrayList.Item");	
            
            // Retrieve the ArrayList.Count property get method.
            PropertyInfo ArrayListSizeProperty = typeof(ArrayList).GetProperty( "Count" );
            BCLDebug.Assert(ArrayListSizeProperty != null, "Unable to find the property ArrayList.Count");	
            MethodInfo ArrayListSizeGetMethod = ArrayListSizeProperty.GetGetMethod();
            BCLDebug.Assert(ArrayListSizeGetMethod != null, "Unable to find the get method for property ArrayList.Count");	
            
            // Retrieve the ConnectionPoint.Unadvise() method.
            MethodInfo CPUnadviseMethod = typeof(UCOMIConnectionPoint).GetMethod( "Unadvise" );
            BCLDebug.Assert(CPUnadviseMethod != null, "Unable to find the method ConnectionPoint.Unadvise()");	

            // Retrieve the Marshal.ReleaseComObject() method.
            MethodInfo ReleaseComObjectMethod = typeof(Marshal).GetMethod( "ReleaseComObject" );
            BCLDebug.Assert(ReleaseComObjectMethod != null, "Unable to find the method Marshal.ReleaseComObject()");

            // Retrieve the Monitor.Enter() method.
            Type[] aParamTypes = new Type[1];
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorEnterMethod = typeof(Monitor).GetMethod( "Enter", aParamTypes, null );
            BCLDebug.Assert(MonitorEnterMethod != null, "Unable to find the method Monitor.Enter()");
            
            // Retrieve the Monitor.Exit() method.
            aParamTypes[0] = typeof(Object);
            MethodInfo MonitorExitMethod = typeof(Monitor).GetMethod( "Exit", aParamTypes, null );
            BCLDebug.Assert(MonitorExitMethod != null, "Unable to find the method Monitor.Exit()");
                        
            // Define the Finalize method itself.
            MethodBuilder Meth = OutputTypeBuilder.DefineMethod( "Finalize", MethodAttributes.Public | MethodAttributes.Virtual, null, null );
            
            ILGenerator il = Meth.GetILGenerator();
            
            // Declare the local variables.
            LocalBuilder ltNumSinkHelpers = il.DeclareLocal( typeof(Int32) );
            LocalBuilder ltSinkHelperCounter = il.DeclareLocal( typeof(Int32) );
            LocalBuilder ltCurrSinkHelper = il.DeclareLocal( SinkHelperClass );		
                        
            // Generate the following code:
            //   Monitor.Enter(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorEnterMethod );

            // Generate the following code:
            //   try {
            il.BeginExceptionBlock();                      
            
            // Generate the labels.
            Label ForBeginLabel = il.DefineLabel();
            Label ReleaseComObjectLabel = il.DefineLabel();
            Label AfterReleaseComObjectLabel = il.DefineLabel();

            // Generate the following code:
            //   if ( m_IFooEventsCP == null ) goto AfterReleaseComObjectLabel;		
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Brfalse, AfterReleaseComObjectLabel );

            // Generate the following code:
            //   int NumEventHelpers = m_aIFooEventsHelpers.Count;
            //   int cEventHelpers = 0;
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelper );
            il.Emit( OpCodes.Callvirt, ArrayListSizeGetMethod );
            il.Emit( OpCodes.Stloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Ldc_I4, 0 );
            il.Emit( OpCodes.Stloc, ltSinkHelperCounter );
            
            // Generate the following code:
            //   if ( 0 >= NumEventHelpers ) goto ReleaseComObjectLabel;		
            il.Emit( OpCodes.Ldc_I4, 0 );
            il.Emit( OpCodes.Ldloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Bge, ReleaseComObjectLabel );
            
            // Mark this as the beginning of the for loop's body.
            il.MarkLabel( ForBeginLabel );
            
            // Generate the following code:
            //   CurrentHelper = (IFooEvents_SinkHelper)m_aIFooEventsHelpers.Get( cEventHelpers );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbSinkHelper );
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Callvirt, ArrayListItemGetMethod );
            il.Emit( OpCodes.Castclass, SinkHelperClass );
            il.Emit( OpCodes.Stloc, ltCurrSinkHelper );
            
            // Generate the following code:
            //   m_IFooEventsCP.Unadvise( CurrentHelper.m_dwCookie );
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Ldloc, ltCurrSinkHelper );
            il.Emit( OpCodes.Ldfld, CookieField );
            il.Emit( OpCodes.Callvirt, CPUnadviseMethod );
            
            // Generate the following code:
            //   cEventHelpers++;
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Ldc_I4, 1 );
            il.Emit( OpCodes.Add );
            il.Emit( OpCodes.Stloc, ltSinkHelperCounter );
            
            // Generate the following code:
            //   if ( cEventHelpers < NumEventHelpers ) goto ForBeginLabel;
            il.Emit( OpCodes.Ldloc, ltSinkHelperCounter );
            il.Emit( OpCodes.Ldloc, ltNumSinkHelpers );
            il.Emit( OpCodes.Blt, ForBeginLabel );
            
            // Mark this as the end of the for loop's body.
            il.MarkLabel( ReleaseComObjectLabel );           

            // Generate the following code:
            //   Marshal.ReleaseComObject(m_IFooEventsCP);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Ldfld, fbEventCP );
            il.Emit( OpCodes.Call, ReleaseComObjectMethod );            
            il.Emit( OpCodes.Pop );

            // Mark this as the end of the for loop's body.
            il.MarkLabel( AfterReleaseComObjectLabel );           

            // Generate the following code:
            //   } catch {
            il.BeginCatchBlock(typeof(System.Exception));
            il.Emit( OpCodes.Pop );

            // Generate the following code:
            //   } finally {
            il.BeginFinallyBlock();

            // Generate the following code:
            //   Monitor.Exit(this);
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, MonitorExitMethod );

            // Generate the following code:
            //   }
            il.EndExceptionBlock();            
            
            // Generate the return opcode.
            il.Emit( OpCodes.Ret );
            
            return Meth;			
        }   
        
        private void DefineDisposeMethod( TypeBuilder OutputTypeBuilder, MethodBuilder FinalizeMethod )
        {
            if ( TCEAdapterGenerator.m_bVerbose )
                Console.WriteLine( "    *Defining Finalize method" );
            
            // Retrieve the method info for GC.SuppressFinalize().
            MethodInfo SuppressFinalizeMethod = typeof(GC).GetMethod("SuppressFinalize");
            BCLDebug.Assert(SuppressFinalizeMethod != null, "Unable to find the GC.SuppressFinalize");	
            
            // Define the Finalize method itself.
            MethodBuilder Meth = OutputTypeBuilder.DefineMethod( "Dispose", MethodAttributes.Public | MethodAttributes.Virtual, null, null );
            
            ILGenerator il = Meth.GetILGenerator();
            
            // Generate the following code:
            //   Finalize()
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Callvirt, FinalizeMethod );
            
            // Generate the following code:
            //   GC.SuppressFinalize()
            il.Emit( OpCodes.Ldarg, (short)0 );
            il.Emit( OpCodes.Call, SuppressFinalizeMethod );	
            
            // Generate the return opcode.
            il.Emit( OpCodes.Ret );   
        }      

        private ModuleBuilder m_OutputModule;
        private String m_strDestTypeName;
        private Type m_EventItfType;
        private Type m_SrcItfType;
        private Type m_SinkHelperType;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\tceadaptergenerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {
    using System.Runtime.InteropServices;
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;
    using System.Threading;

    internal class TCEAdapterGenerator
    {   
        static internal bool m_bVerbose = false;
        
        public void Process(ModuleBuilder ModBldr, ArrayList EventItfList)
        {   
            // Store the input/output module.
            m_Module = ModBldr;
            
            // Generate the TCE adapters for all the event sources.
            int NumEvItfs = EventItfList.Count;
            for ( int cEventItfs = 0; cEventItfs < NumEvItfs; cEventItfs++ )
            {
                // Retrieve the event interface info.
                EventItfInfo CurrEventItf = (EventItfInfo)EventItfList[cEventItfs];

                // Retrieve the information from the event interface info.
                Type EventItfType = CurrEventItf.GetEventItfType();               
                Type SrcItfType = CurrEventItf.GetSrcItfType();
                String EventProviderName = CurrEventItf.GetEventProviderName();

                // Generate the sink interface helper.
                Type SinkHelperType = new EventSinkHelperWriter( m_Module, SrcItfType, EventItfType ).Perform();

                // Generate the event provider.
                new EventProviderWriter( m_Module, EventProviderName, EventItfType, SrcItfType, SinkHelperType ).Perform();
            }
        }
    
        internal static void SetClassInterfaceTypeToNone(TypeBuilder tb)
        {
            // Create the ClassInterface(ClassInterfaceType.None) CA builder if we haven't created it yet.
            if (s_NoClassItfCABuilder == null)
            {
                Monitor.Enter(typeof(TCEAdapterGenerator));
                if (s_NoClassItfCABuilder == null)
                {
                    Type []aConsParams = new Type[1];
                    aConsParams[0] = typeof(ClassInterfaceType);
                    ConstructorInfo Cons = typeof(ClassInterfaceAttribute).GetConstructor(aConsParams);

                    Object[] aArgs = new Object[1];
                    aArgs[0] = ClassInterfaceType.None;
                    s_NoClassItfCABuilder = new CustomAttributeBuilder(Cons, aArgs);
                }
                Monitor.Exit(typeof(TCEAdapterGenerator));
            }

            // Set the class interface type to none.
            tb.SetCustomAttribute(s_NoClassItfCABuilder);
        }

        internal static TypeBuilder DefineUniqueType(String strInitFullName, TypeAttributes attrs, Type BaseType, Type[] aInterfaceTypes, ModuleBuilder mb)
        {
            String strFullName = strInitFullName;
            int PostFix = 2;

            // Find the first unique name for the type.
            for (; mb.GetType(strFullName) != null; strFullName = strInitFullName + "_" + PostFix, PostFix++);

            // Define a type with the determined unique name.
            return mb.DefineType(strFullName, attrs, BaseType, aInterfaceTypes);
        }

        internal static void MakeTypeNonComVisible(TypeBuilder tb)
        {
            // Create the NonComVisible CA builder if we haven't created it yet.
            if (s_NonComVisibleCABuilder == null)
            {
                Monitor.Enter(typeof(TCEAdapterGenerator));
                if (s_NonComVisibleCABuilder == null)
                {
                    Type []aConsParams = new Type[1];
                    aConsParams[0] = typeof(Boolean);
                    ConstructorInfo Cons = typeof(ComVisibleAttribute).GetConstructor(aConsParams);

                    Object[] aArgs = new Object[1];
                    aArgs[0] = false;
                    s_NonComVisibleCABuilder = new CustomAttributeBuilder(Cons, aArgs);
                }
                Monitor.Exit(typeof(TCEAdapterGenerator));
            }

            // Make the type non com visible.
            tb.SetCustomAttribute(s_NonComVisibleCABuilder);
        }

        internal static void SetTypeGuid(TypeBuilder tb, Guid guid)
        {
            // Retrieve the String constructor of the GuidAttribute.
            Type []aConsParams = new Type[1];
            aConsParams[0] = typeof(String);
            ConstructorInfo Cons = typeof(GuidAttribute).GetConstructor(aConsParams);

            // Create the CA builder.
            Object[] aArgs = new Object[1];
            aArgs[0] = guid.ToString();
            CustomAttributeBuilder GuidCABuilder = new CustomAttributeBuilder(Cons, aArgs);

            // Set the guid on the type.
            tb.SetCustomAttribute(GuidCABuilder);
        }

        private ModuleBuilder m_Module = null;
        private Hashtable m_SrcItfToSrcItfInfoMap = new Hashtable();
        private static CustomAttributeBuilder s_NoClassItfCABuilder = null;
        private static CustomAttributeBuilder s_NonComVisibleCABuilder = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\interopservices\tceadaptergen\eventsinkhelperwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.InteropServices.TCEAdapterGen {
	using System.Runtime.InteropServices;
	using System;
	using System.Reflection;
	using System.Reflection.Emit;
	using System.Collections;
	internal class EventSinkHelperWriter
	{
        public static readonly String GeneratedTypeNamePostfix = "_SinkHelper";
		
		public EventSinkHelperWriter( ModuleBuilder OutputModule, Type InputType, Type EventItfType )
		{
			m_InputType = InputType;
			m_OutputModule = OutputModule;
            m_EventItfType = EventItfType;
		}
		
		public Type Perform()
		{
			if ( TCEAdapterGenerator.m_bVerbose )
				Console.WriteLine( "Writing event sink helper for interface " + m_InputType.Name );		
		
			// Create the output Type.
			Type[] aInterfaces = new Type[1];
			aInterfaces[0] = m_InputType;
			String strFullName = null;
            String strNameSpace = NameSpaceExtractor.ExtractNameSpace( m_EventItfType.FullName );
            if (strNameSpace != "")
                strFullName = strNameSpace  + ".";
			strFullName += m_InputType.Name + GeneratedTypeNamePostfix;
            TypeBuilder OutputTypeBuilder = TCEAdapterGenerator.DefineUniqueType( 
                                                             strFullName,
                                                             TypeAttributes.Sealed | TypeAttributes.Public, 
                                                             null,
                                                             aInterfaces,
                                                             m_OutputModule
                                                            );

            // Set the class interface to none.
            TCEAdapterGenerator.SetClassInterfaceTypeToNone(OutputTypeBuilder);

			// Retrieve the methods on the input interface.
			MethodInfo[] aMethods = m_InputType.GetMethods();  
    
			// Allocate an array to contain the delegate fields.
			FieldBuilder[] afbDelegates = new FieldBuilder[aMethods.Length];   
			// Process all the methods on the input interface.
			for ( int cMethods = 0; cMethods < aMethods.Length; cMethods++ )
			{
				if ( m_InputType == aMethods[cMethods].DeclaringType )
				{
					if ( TCEAdapterGenerator.m_bVerbose )
						Console.WriteLine( "    -> Processing event method " + aMethods[cMethods].Name );

					// Retrieve the delegate type from the add_XXX method.
                    MethodInfo AddMeth = m_EventItfType.GetMethod( "add_" + aMethods[cMethods].Name );
					ParameterInfo[] aParams = AddMeth.GetParameters();
					BCLDebug.Assert(aParams.Length == 1, "All event interface methods must take a single delegate derived type and have a void return type");	
                    Type DelegateCls = aParams[0].ParameterType;

					// Define the delegate instance field.
					afbDelegates[cMethods] = OutputTypeBuilder.DefineField( 
												  "m_" + aMethods[cMethods].Name + "Delegate", 
												  DelegateCls,
												  FieldAttributes.Public 
												 );
					
					// Define the event method itself.
					DefineEventMethod( OutputTypeBuilder, aMethods[cMethods], DelegateCls, afbDelegates[cMethods] );                
				}
			}

			// Create the cookie field.
			FieldBuilder fbCookie = OutputTypeBuilder.DefineField( 
												  "m_dwCookie", 
												  typeof(Int32), 
												  FieldAttributes.Public 
												 );
    
			// Define the constructor.      
			DefineConstructor( OutputTypeBuilder, fbCookie, afbDelegates );
    
			return OutputTypeBuilder.CreateType();
		}

		private void DefineEventMethod( TypeBuilder OutputTypeBuilder, MethodInfo Method, Type DelegateCls, FieldBuilder fbDelegate )
		{
			// Retrieve the method info for the invoke method on the delegate.
			MethodInfo DelegateInvokeMethod = DelegateCls.GetMethod( "Invoke" );
            BCLDebug.Assert(DelegateInvokeMethod != null, "Unable to find method Delegate.Invoke()");	
    
			// Retrieve the return type.
			Type ReturnType = Method.ReturnType;
        
			// Define the actual event method.
            ParameterInfo[] paramInfos = Method.GetParameters();
            Type[]          parameterTypes;
            if (paramInfos != null)
            {
                parameterTypes = new Type[paramInfos.Length];
                for (int i = 0; i < paramInfos.Length; i++)
                {
                    parameterTypes[i] = paramInfos[i].ParameterType;
                }
            }
            else
                parameterTypes = null;

			MethodAttributes attr = MethodAttributes.Public | MethodAttributes.Virtual;
			MethodBuilder Meth = OutputTypeBuilder.DefineMethod( Method.Name, 
                                                                 attr, 
                                                                 CallingConventions.Standard,
                                                                 ReturnType,
                                                                 parameterTypes);

			// We explicitly do not specify parameter name and attributes since this Type
			// is not meant to be exposed to the user. It is only used internally to do the
			// connection point to TCE mapping.
			
			ILGenerator il = Meth.GetILGenerator();
						
			// Create the exit branch.
			Label ExitLabel = il.DefineLabel();
		
			// Generate the code that verifies that the delegate is not null.
			il.Emit( OpCodes.Ldarg, (short)0 );
			il.Emit( OpCodes.Ldfld, fbDelegate );	
			il.Emit( OpCodes.Brfalse, ExitLabel );
							
			// The delegate is not NULL so we need to invoke it.
			il.Emit( OpCodes.Ldarg, (short)0 );
			il.Emit( OpCodes.Ldfld, fbDelegate );
		
			// Generate the code to load the arguments before we call invoke.
			ParameterInfo[] aParams = Method.GetParameters();
			for ( int cParams = 0; cParams < aParams.Length; cParams++ )
			{
				il.Emit( OpCodes.Ldarg, (short)(cParams + 1) );
			}
		
			// Generate a tail call to invoke. This will cause the callvirt to return 
			// directly to the caller of the current method instead of actually coming
			// back to the current method and returning. This will cause the value returned
			// from the call to the COM server to be returned to the caller of this method.
				
			il.Emit( OpCodes.Callvirt, DelegateInvokeMethod );
			il.Emit( OpCodes.Ret );
		
			// This is the label that will be jumped to if no delegate is present.
			il.MarkLabel( ExitLabel );
			
			// Place a dummy return value on the stack before we return.
			if ( ReturnType == typeof(void) )
			{
				// There is nothing to place on the stack.
			}
			else if ( ReturnType.IsPrimitive )
			{
				switch (System.Type.GetTypeCode(ReturnType)) 
				{
				    case TypeCode.Boolean:
				    case TypeCode.Char:
				    case TypeCode.Byte:
				    case TypeCode.SByte:
				    case TypeCode.Int16:
				    case TypeCode.UInt16:
				    case TypeCode.Int32:
				    case TypeCode.UInt32:
					    il.Emit( OpCodes.Ldc_I4_0 );
					    break;
					    
				    case TypeCode.Int64:
				    case TypeCode.UInt64:
					    il.Emit( OpCodes.Ldc_I4_0 );
					    il.Emit( OpCodes.Conv_I8 );
					    break;
					    
				    case TypeCode.Single:
					    il.Emit( OpCodes.Ldc_R4, 0 );
					    break;
				    
				    case TypeCode.Double:
					    il.Emit( OpCodes.Ldc_R4, 0 );
					    il.Emit( OpCodes.Conv_R8 );
					    break;
				    
				    default:
					    // "TypeCode" does not include IntPtr, so special case it.
					    if ( ReturnType == typeof(IntPtr) )
						    il.Emit( OpCodes.Ldc_I4_0 );
					    else
						    BCLDebug.Assert(false, "Unexpected type for Primitive type.");	
					    break;
				}
			}
			else if ( ReturnType.IsValueType )
			{
				// Allocate stack space for the return value type.  Zero-init.
				Meth.InitLocals = true;
				LocalBuilder ltRetVal = il.DeclareLocal( ReturnType );		
				
				// Load the value class on the stack.
				il.Emit( OpCodes.Ldloc_S, ltRetVal );
				
			}
			else
			{
				// The return type is a normal type.
				il.Emit( OpCodes.Ldnull );
			}
			
			il.Emit( OpCodes.Ret );
		
		}	
		
		private void DefineConstructor( TypeBuilder OutputTypeBuilder, FieldBuilder fbCookie, FieldBuilder[] afbDelegates )
		{
			// Retrieve the constructor info for the base classe's constructor.
			ConstructorInfo DefaultBaseClsCons = typeof(Object).GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, null, new Type[0], null );
            BCLDebug.Assert(DefaultBaseClsCons != null, "Unable to find the constructor for class " + m_InputType.Name);	
		
			// Define the default constructor.
			MethodBuilder Cons = OutputTypeBuilder.DefineMethod( ".ctor", 
                                                                 MethodAttributes.Assembly | MethodAttributes.SpecialName, 
                                                                 CallingConventions.Standard,
                                                                 null,
                                                                 null);

			ILGenerator il = Cons.GetILGenerator();
    
			// Generate the code to call the constructor of the base class.
			il.Emit( OpCodes.Ldarg, (short)0 );
			il.Emit( OpCodes.Call, DefaultBaseClsCons );
    
			// Generate the code to set the cookie field to 0.
			il.Emit( OpCodes.Ldarg, (short)0 );
			il.Emit( OpCodes.Ldc_I4, 0 );
			il.Emit( OpCodes.Stfld, fbCookie );
    
			// Generate the code to set all the delegates to NULL.
			for ( int cDelegates = 0; cDelegates < afbDelegates.Length; cDelegates++ )
			{
			    if (afbDelegates[cDelegates] != null)
				{
					il.Emit( OpCodes.Ldarg,(short)0 );
					il.Emit( OpCodes.Ldnull );
					il.Emit( OpCodes.Stfld, afbDelegates[cDelegates] );
				}
			}
    
			// Emit the return opcode.
			il.Emit( OpCodes.Ret );
    
		}

        private static CustomAttributeBuilder s_HasDefaultItfCABuilder = null;
		private Type m_InputType;  
        private Type m_EventItfType;
		private ModuleBuilder m_OutputModule;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\channelsinkstacks.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ChannelSinkStacks.cs
**
** Purpose: Defines the stack interfaces.
**
** Date:    October 21, 2000
**
===========================================================*/

using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Metadata;
using System.Security.Permissions;


namespace System.Runtime.Remoting.Channels {
        

     // interface for maintaining the sink stack
    //   The formatter sink MUST provide this object.
    //   No other sinks should have to check to see if this is null.
    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientChannelSinkStack"]/*' />
    public interface IClientChannelSinkStack : IClientResponseChannelSinkStack
    {
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientChannelSinkStack.Push"]/*' />
        // Push a sink to the stack (it will be called on the way back to get
        //   the response stream).
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void Push(IClientChannelSink sink, Object state);
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientChannelSinkStack.Pop"]/*' />

        // Retrieve state previously pushed by sink.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        Object Pop(IClientChannelSink sink);
        
    } // IChannelSinkStack

    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientResponseChannelSinkStack"]/*' />
    public interface IClientResponseChannelSinkStack
    {
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientResponseChannelSinkStack.AsyncProcessResponse"]/*' />
        // Call AsyncProcessResponse (on previous channel sink)
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientResponseChannelSinkStack.DispatchReplyMessage"]/*' />

        // Called by client formatter sink in AsyncProcessResponse once it has
        //   deserialized the response message.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void DispatchReplyMessage(IMessage msg);
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IClientResponseChannelSinkStack.DispatchException"]/*' />

        // If an exception happens on the async channel sink path, the
        //   sink should call this method with the exception.
         [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
       void DispatchException(Exception e);
     
    } // interface IClientResponseChannelSinkStack


    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ClientChannelSinkStack : IClientChannelSinkStack
    {
        private class SinkStack
        {
            public SinkStack PrevStack;
            
            public IClientChannelSink Sink;
            public Object State;
        }

        private SinkStack _stack = null;
        
        private IMessageSink _replySink = null;


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.ClientChannelSinkStack"]/*' />
        public ClientChannelSinkStack()
        {
        }

        // use this constructor when initiating an async call
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.ClientChannelSinkStack1"]/*' />
        public ClientChannelSinkStack(IMessageSink replySink)
        {
            _replySink = replySink;
        }
        
        
    
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.Push"]/*' />
        public void Push(IClientChannelSink sink, Object state)
        {
            SinkStack newStack = new SinkStack();
            newStack.PrevStack = _stack;
            newStack.Sink = sink;
            newStack.State = state;
            _stack = newStack;
        } // Push


        // retrieve state previously pushed by sink
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.Pop"]/*' />
        public Object Pop(IClientChannelSink sink)
        {
            if (_stack == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_PopOnEmptySinkStack"));
            }

            // find this sink on the stack
            do 
            {
                if (_stack.Sink == sink)
                    break;

                _stack = _stack.PrevStack;
            } while (_stack != null);

            if (_stack.Sink == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_PopFromSinkStackWithoutPush"));
            }

            Object state = _stack.State;
            _stack = _stack.PrevStack;

            return state;
        } // Pop


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(ITransportHeaders headers, Stream stream)
        {
            // If the reply sink is null, this is a one way message, so we're not
            //   going to process the reply path.
            if (_replySink != null)
            {
                if (_stack == null)
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Channel_CantCallAPRWhenStackEmpty"));
                }

                IClientChannelSink sink = _stack.Sink;
                Object state = _stack.State;
                _stack = _stack.PrevStack;
    
                sink.AsyncProcessResponse(this, state, headers, stream);
            }
        } // AsyncProcessResponse


        // Client formatter sink should call this in AysncProcessResponse once
        //   it has deserialized a message.
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.DispatchReplyMessage"]/*' />
        public void DispatchReplyMessage(IMessage msg)
        {
            if (_replySink != null)
                _replySink.SyncProcessMessage(msg);
        } // DispatchReplyMessage


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ClientChannelSinkStack.DispatchException"]/*' />
        public void DispatchException(Exception e)
        {
            DispatchReplyMessage(new ReturnMessage(e, null));
        } // DispatchException
        
    } // ClientChannelSinkStack





    // interface for maintaining the sink stack
    //   The transport sink MUST provide this object.
    //   No other sinks should have to check to see if this is null.
    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack"]/*' />
    public interface IServerChannelSinkStack : IServerResponseChannelSinkStack
    {
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack.Push"]/*' />
        // Push a sink to the stack (it will be called on the way back to get
        //   the response stream).
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void Push(IServerChannelSink sink, Object state);
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack.Pop"]/*' />

        // Retrieve state previously pushed by sink.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        Object Pop(IServerChannelSink sink);
        
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack.Store"]/*' />
        /// <internalonly/>

        // IMPORTANT: If a sink did a Push(), it must do a Pop()
        //   before calling GetResponseStream inside of ProcessMessage.
    
        // On the way back, if it is determined that a asynchronous processing is 
        //   needed, a sink should call Store() instead of Pop()
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void Store(IServerChannelSink sink, Object state);
        
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack.StoreAndDispatch"]/*' />
        /// <internalonly/>
        
        // Called by the server transport sink to complete the dispatch, if async
        //   processing is being used.        
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void StoreAndDispatch(IServerChannelSink sink, Object state);
        
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerChannelSinkStack.ServerCallback"]/*' />
        /// <internalonly/>
        
        // handles callback after message has been dispatched asynchronously
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void ServerCallback(IAsyncResult ar);
        
    } // IServerChannelSinkStack

    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerResponseChannelSinkStack"]/*' />
    public interface IServerResponseChannelSinkStack
    {
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerResponseChannelSinkStack.AsyncProcessResponse"]/*' />
        /// <internalonly/> 
        // Call AsyncProcessResponse (on previous channel sink)
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="IServerResponseChannelSinkStack.GetResponseStream"]/*' />

        // Call GetResponseStream (on previous channel sink)
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
    } // interface IServerResponseChannelSinkStack


    /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ServerChannelSinkStack : IServerChannelSinkStack
    {
        private class SinkStack
        {
            public SinkStack PrevStack;
            
            public IServerChannelSink Sink;
            public Object State;
        }

        private SinkStack _stack = null;
        private SinkStack _rememberedStack = null;

        // async callback support
        private IMessage   _asyncMsg = null;
        private MethodInfo _asyncEnd = null;
        private Object     _serverObject = null;
        private IMethodCallMessage   _msg = null;
        
    
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.Push"]/*' />
        public void Push(IServerChannelSink sink, Object state)
        {
            SinkStack newStack = new SinkStack();
            newStack.PrevStack = _stack;
            newStack.Sink = sink;
            newStack.State = state;
            _stack = newStack;
        } // Push


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.Pop"]/*' />
        public Object Pop(IServerChannelSink sink)
        {
            if (_stack == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_PopOnEmptySinkStack"));
            }
            
            // find this sink on the stack
            do 
            {
                if (_stack.Sink == sink)
                    break;

                _stack = _stack.PrevStack;
            } while (_stack != null);

            if (_stack.Sink == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_PopFromSinkStackWithoutPush"));
            }
            
            Object state = _stack.State;
            _stack = _stack.PrevStack;

            return state;
        } // Pop

        
        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.Store"]/*' />
        public void Store(IServerChannelSink sink, Object state)
        {
            if (_stack == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Channel_StoreOnEmptySinkStack"));
            }

            // find this sink on the stack
            do 
            {
                if (_stack.Sink == sink)
                    break;

                _stack = _stack.PrevStack;
            } while (_stack != null);

            if (_stack.Sink == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_StoreOnSinkStackWithoutPush"));
            }                            

            SinkStack remStack = new SinkStack();
            remStack.PrevStack = _rememberedStack;
            remStack.Sink = sink;
            remStack.State = state;
            _rememberedStack = remStack;

            Pop(sink);
        } // Store

        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.StoreAndDispatch"]/*' />
        public void StoreAndDispatch(IServerChannelSink sink, Object state)
        {
            Store(sink, state);
            FlipRememberedStack();
            CrossContextChannel.DoAsyncDispatch(_asyncMsg, null);
        } // Store

        // Reverses remebered stack so that return message may be dispatched.
        private void FlipRememberedStack()
        { 
            if (_stack != null)
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Channel_CantCallFRSWhenStackEmtpy"));
        
            while (_rememberedStack != null)
            {
                SinkStack newStack = new SinkStack();
                newStack.PrevStack = _stack;
                newStack.Sink = _rememberedStack.Sink;
                newStack.State = _rememberedStack.State;
                _stack = newStack;
                _rememberedStack = _rememberedStack.PrevStack;
            }
        } // FlipRememberedStack


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream)
        {
            if (_stack == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Channel_CantCallAPRWhenStackEmpty"));
            }
               
            IServerChannelSink sink = _stack.Sink;
            Object state = _stack.State;
            _stack = _stack.PrevStack;
    
            sink.AsyncProcessResponse(this, state, msg, headers, stream);
        } // AsyncProcessResponse


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.GetResponseStream"]/*' />
        public Stream GetResponseStream(IMessage msg, ITransportHeaders headers)
        {
            if (_stack == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Channel_CantCallGetResponseStreamWhenStackEmpty"));
            }
        
            // save state
            IServerChannelSink savedSink = _stack.Sink;
            Object savedState = _stack.State;
            
            _stack = _stack.PrevStack;
            Stream stream = savedSink.GetResponseStream(this, savedState, msg, headers);

            // restore state
            Push(savedSink, savedState);

            return stream;
        } // GetResponseStream


        // Server async message to dispatch
        internal IMessage AsyncMessage { set { _asyncMsg = value; } } 

        // Server async callback functionality
        internal MethodInfo AsyncEnd { set { _asyncEnd = value; } } 

        // Store server that is going to be called back
        internal Object ServerObject { set { _serverObject = value; } }

        // Store original pre-wrapped message
        internal IMethodCallMessage Message { set { _msg = value; } }


        /// <include file='doc\ChannelSinkStacks.uex' path='docs/doc[@for="ServerChannelSinkStack.ServerCallback"]/*' />
        public void ServerCallback(IAsyncResult ar)
        {
            if (_asyncEnd != null)
            {
                RemotingMethodCachedData asyncEndCache = (RemotingMethodCachedData)
                    InternalRemotingServices.GetReflectionCachedData(_asyncEnd);

                MethodInfo syncMI = (MethodInfo)_msg.MethodBase;
                RemotingMethodCachedData syncCache = (RemotingMethodCachedData)
                    InternalRemotingServices.GetReflectionCachedData(syncMI);
            
                ParameterInfo[] paramList = asyncEndCache.Parameters;

                // construct list to pass into End
                Object[] parameters = new Object[paramList.Length];
                parameters[paramList.Length - 1] = ar; // last parameter is the async result

                Object[] syncMsgArgs = _msg.Args;

                // copy out and ref parameters to the parameters list
                AsyncMessageHelper.GetOutArgs(syncCache.Parameters, syncMsgArgs, parameters);

                Object[] outArgs;
                
                StackBuilderSink s = new StackBuilderSink(_serverObject);
                Object returnValue =
                    s.PrivateProcessMessage(_asyncEnd,
                        System.Runtime.Remoting.Messaging.Message.CoerceArgs(_asyncEnd, parameters, paramList),
                        _serverObject,
                        0,
                        false,
                        out outArgs);   

                // The outArgs list is associated with the EndXXX method. We need to make sure
                //   it is sized properly for the out args of the XXX method.
                if (outArgs != null)                        
                    outArgs = ArgMapper.ExpandAsyncEndArgsToSyncArgs(syncCache, outArgs);
                    
                s.CopyNonByrefOutArgsFromOriginalArgs(syncCache, syncMsgArgs, ref outArgs);                

                IMessage retMessage = new ReturnMessage(
                    returnValue, outArgs, _msg.ArgCount, CallContext.GetLogicalCallContext(), _msg);

                AsyncProcessResponse(retMessage, null, null);
            }
            
        } // ServerCallback

        
    } // ServerChannelSinkStack


    // helper class for transforming sync message parameter lists into its
    //   async counterparts
    internal class AsyncMessageHelper
    {
        internal static void GetOutArgs(ParameterInfo[] syncParams, Object[] syncArgs, 
                                        Object[] endArgs)
        {
            int outCount = 0;

            for (int co = 0; co < syncParams.Length; co++)
            {
                if (syncParams[co].IsOut || syncParams[co].ParameterType.IsByRef)
                {
                    endArgs[outCount++] = syncArgs[co];
                }
            }
            
        } // GetOutArgs
    } // AsyncMessageHelper



    // This is an internal hack class to dispatch a synchronous call asynchronously
    //   on the server.
    internal class AsyncMethodCallMessageWrapper : MethodCallMessageWrapper
    {
        private IMethodCallMessage  _mcm;
        private MethodBase          _beginMethod;
        private AsyncCallback       _callback;
        private Object              _asyncState;
    
        internal AsyncMethodCallMessageWrapper(
            IMethodCallMessage msg, MethodBase beginMethod,
            AsyncCallback callback, Object asyncState) : base(msg)
        {
            _mcm = msg;
            _beginMethod = beginMethod;
            _callback = callback;
            _asyncState = asyncState;
        } // AsyncMethodCallMessageWrapper


        public override String MethodName { get { return _beginMethod.Name; } }

        public override Object[] Args 
        { 
            get 
            {
                Object[] baseArgs = _mcm.Args;
                Object[] newArgs = new Object[baseArgs.Length + 2];
                int co = 0;
                for (; co < baseArgs.Length; co++)
                {
                    newArgs[co] = baseArgs[co];
                }
                newArgs[co++] = _callback;
                newArgs[co] = _asyncState;
                return newArgs;
            }
        } // Args 

        public override Object MethodSignature 
        { 
            get 
            {
                Type[] baseMS = (Type[])_mcm.MethodSignature;
                if (baseMS == null)
                {
                    return null;
                }
                else
                {
                    Object[] newMS = new Object[baseMS.Length + 2];
                    int co = 0;
                    for (; co < baseMS.Length; co++)
                    {
                        newMS[co] = baseMS[co];
                    }
                    newMS[0] = typeof(IAsyncResult);
                    newMS[co++] = _callback;
                    newMS[co] = _asyncState;
                    return newMS;
                }
            }
        } // MethodSignature


        public override MethodBase MethodBase { get { return _beginMethod; } }
    
    } // AsyncMethodCallMessageWrapper



} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\callcontext.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Implementation of CallContext ... currently leverages off
// the LocalDataStore facility.
namespace System.Runtime.Remoting.Messaging{    

    using System.Threading;
    using System.Runtime.Remoting;
    using System.Security.Principal;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Security.Permissions;	
    // This class exposes the API for the users of call context. All methods
    // in CallContext are static and operate upon the call context in the Thread.
    // NOTE: CallContext is a specialized form of something that behaves like 
    // TLS for method calls. However, since the call objects may get serialized 
    // and deserialized along the path, it is tough to guarantee identity
    // preservation.
    // The LogicalCallContext class has all the actual functionality. We have
    // to use this scheme because Remoting message sinks etc do need to have
    // the distinction between the call context on the physical thread and 
    // the call context that the remoting message actually carries. In most cases
    // they will operate on the message's call context and hence the latter 
    // exposes the same set of methods as instance methods.

    // Only statics does not need to marked with the serializable attribute
    /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext"]/*' />
    [Serializable]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public sealed class CallContext
    {
        private CallContext()
        {
        }

        // Get the logical call context object for the current thread.
        internal static LogicalCallContext GetLogicalCallContext()
        {
            return Thread.CurrentThread.GetLogicalCallContext();
        }

        // Sets the given logical call context object on the thread.
        // Returns the previous one.
        internal static LogicalCallContext SetLogicalCallContext(
            LogicalCallContext callCtx)
        {
            return Thread.CurrentThread.SetLogicalCallContext(callCtx);
        }

        internal static LogicalCallContext SetLogicalCallContext(
            Thread currThread, LogicalCallContext callCtx)
        {
            return currThread.SetLogicalCallContext(callCtx);
        }

        internal static CallContextSecurityData SecurityData
        {
            get { return Thread.CurrentThread.GetLogicalCallContext().SecurityData; }
        }

        internal static CallContextRemotingData RemotingData
        {
            get { return Thread.CurrentThread.GetLogicalCallContext().RemotingData; }
        }


        /*=========================================================================
        ** Frees a named data slot.
        =========================================================================*/
        /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext.FreeNamedDataSlot"]/*' />
        public static void FreeNamedDataSlot(String name)
        {
            Thread.CurrentThread.GetLogicalCallContext().FreeNamedDataSlot(name);
            Thread.CurrentThread.GetIllogicalCallContext().FreeNamedDataSlot(name);
        }

        /*=========================================================================
        ** Get data on the logical call context
        =========================================================================*/
        private static Object LogicalGetData(String name)
        {
            LogicalCallContext lcc =  Thread.CurrentThread.GetLogicalCallContext();
            return lcc.GetData(name);              
        }

        /*=========================================================================
        ** Get data on the illogical call context
        =========================================================================*/
        private static Object IllogicalGetData(String name)
        {
            IllogicalCallContext ilcc =  Thread.CurrentThread.GetIllogicalCallContext();
            return ilcc.GetData(name);              
        }

        // For callContexts we intend to expose only name, value dictionary
        // type of behavior for now. We will re-consider if we need to expose
        // the other functions above for Beta-2.
        /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext.GetData"]/*' />
        public static Object GetData(String name)
        {
            Object o = LogicalGetData(name);
            if (o == null)
            {
                return IllogicalGetData(name);
            }
            else
            {
                return o;
            }
        }

        /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext.SetData"]/*' />
        public static void SetData(String name, Object data)
        {
            if (data is ILogicalThreadAffinative)
            {
                IllogicalCallContext ilcc =  Thread.CurrentThread.GetIllogicalCallContext();
                ilcc.FreeNamedDataSlot(name);
                LogicalCallContext lcc =  Thread.CurrentThread.GetLogicalCallContext();
                lcc.SetData(name, data);
            }
            else
            {
                LogicalCallContext lcc =  Thread.CurrentThread.GetLogicalCallContext();
                lcc.FreeNamedDataSlot(name);
                IllogicalCallContext ilcc =  Thread.CurrentThread.GetIllogicalCallContext();
                ilcc.SetData(name, data);
            }
        }


        /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext.GetHeaders"]/*' />
        public static Header[] GetHeaders()
        {
            LogicalCallContext lcc =  Thread.CurrentThread.GetLogicalCallContext();
            return lcc.InternalGetHeaders();
        } // GetHeaders

        /// <include file='doc\CallContext.uex' path='docs/doc[@for="CallContext.SetHeaders"]/*' />
        public static void SetHeaders(Header[] headers)
        {            
            LogicalCallContext lcc =  Thread.CurrentThread.GetLogicalCallContext();
            lcc.InternalSetHeaders(headers);
        } // SetHeaders
        
    } // class CallContext

    /// <include file='doc\CallContext.uex' path='docs/doc[@for="ILogicalThreadAffinative"]/*' />
    public interface ILogicalThreadAffinative
    {
    }

    internal class IllogicalCallContext
    {
        private Hashtable m_Datastore;

        private Hashtable Datastore
        {
            get 
            { 
                if (null == m_Datastore)
                {
                    // The local store has not yet been created for this thread.
                    m_Datastore = new Hashtable();
                }
                return m_Datastore;
            }
        }

        /*=========================================================================
        ** Frees a named data slot.
        =========================================================================*/
        public void FreeNamedDataSlot(String name)
        {
            Datastore.Remove(name);
        }

        public Object GetData(String name)
        {
            return Datastore[name];
        }

        public void SetData(String name, Object data)
        {
            Datastore[name] = data;
        }
    }

    // This class handles the actual call context functionality. It leverages on the
    // implementation of local data store ... except that the local store manager is
    // not static. That is to say, allocating a slot in one call context has no effect
    // on another call contexts. Different call contexts are entirely unrelated.

    /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext"]/*' />
    [Serializable]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public sealed class LogicalCallContext : ISerializable, ICloneable
    {
        // Private static data
        private static Type s_callContextType = typeof(LogicalCallContext);

        // Private member data
        private Hashtable m_Datastore;
        private CallContextRemotingData m_RemotingData = null; 
        private CallContextSecurityData m_SecurityData = null;

        // _sendHeaders is for Headers that should be sent out on the next call.
        // _recvHeaders are for Headers that came from a response.
        private Header[] _sendHeaders = null;
        private Header[] _recvHeaders = null;
        

        internal LogicalCallContext()
        {   
        }

        internal LogicalCallContext(SerializationInfo info, StreamingContext context)
        {
            SerializationInfoEnumerator e = info.GetEnumerator();
            while (e.MoveNext())
            {
                if (e.Name.Equals("__RemotingData"))
                {
                    m_RemotingData = (CallContextRemotingData) e.Value;
                }
                else if (e.Name.Equals("__SecurityData"))
                {
                    if (context.State == StreamingContextStates.CrossAppDomain)                        
                    {
                        m_SecurityData = (CallContextSecurityData) e.Value;
                    }
                    else
                    {
                        BCLDebug.Assert(false, "Security data should only be serialized in cross appdomain case.");
                    }
                }
                else
                {
                    Datastore[e.Name] = e.Value;    
                }

            }
        }

        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.GetObjectData"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException("info");
            info.SetType(s_callContextType);
            if (m_RemotingData != null)
            {
                info.AddValue("__RemotingData", m_RemotingData);
            }
            if (m_SecurityData != null)
            {
                if (context.State == StreamingContextStates.CrossAppDomain)
                {
                    info.AddValue("__SecurityData", m_SecurityData);
                }
            }
            if (HasUserData)
            {
                IDictionaryEnumerator de = m_Datastore.GetEnumerator();
                
                while (de.MoveNext())
                {
                    info.AddValue((String)de.Key, de.Value);
                }
            }

        }

        
        // ICloneable::Clone
        // Used to create a (somewhat lame) deep copy of the call context 
        // when an async call starts

        // FUTURE: This needs to be revisited ... ideally the call
        // context data should be deep-copied for each Async call ... may be
        // by providing the user with the option through new parameters to 
        // BeginInvoke & EndInvoke
        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.Clone"]/*' />
        public Object Clone()
        {
            LogicalCallContext lc = new LogicalCallContext();
            if (m_RemotingData != null)
                lc.m_RemotingData = (CallContextRemotingData)m_RemotingData.Clone();
            if (m_SecurityData != null)
                lc.m_SecurityData = (CallContextSecurityData)m_SecurityData.Clone();
            if (HasUserData)
            {
                IDictionaryEnumerator de = m_Datastore.GetEnumerator();
                
                while (de.MoveNext())
                {
                    lc.Datastore[(String)de.Key] = de.Value;  
                }
            }      
            return lc;
        }

        // Used to do a (limited) merge the call context from a returning async call
        internal void Merge(LogicalCallContext lc)
        {
            // we ignore the RemotingData & SecurityData 
            // and only merge the user sections of the two call contexts
            // the idea being that if the original call had any 
            // identity/remoting callID that should remain unchanged

            // If we have a non-null callContext and it is not the same
            // as the one on the current thread (can happen in x-context async)
            // and there is any userData in the callContext, do the merge
            if ((lc != null) && (this != lc) && lc.HasUserData)
            {
                IDictionaryEnumerator de = lc.Datastore.GetEnumerator();
                
                while (de.MoveNext())
                {
                    Datastore[(String)de.Key] = de.Value;  
                }                
            }
        }
        
        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.HasInfo"]/*' />
        public bool HasInfo
        {
            get 
            { 
                bool fInfo = false;

                // Set the flag to true if there is either remoting data, or
                // security data or user data
                if( 
                    (m_RemotingData != null &&  m_RemotingData.HasInfo) ||
                    (m_SecurityData != null &&  m_SecurityData.HasInfo) ||
                    HasUserData
                  )
                {
                    fInfo = true;
                }

                return fInfo;
            }
        }

        private bool HasUserData
        {
            get { return ((m_Datastore != null) && (m_Datastore.Count > 0));}
        }

        internal CallContextRemotingData RemotingData
        {
            get 
            {
                if (m_RemotingData == null)
                    m_RemotingData = new CallContextRemotingData();

                return m_RemotingData; 
            }
        }

        internal CallContextSecurityData SecurityData
        {
            get 
            {
                if (m_SecurityData == null)
                    m_SecurityData = new CallContextSecurityData();

                return m_SecurityData; 
            }
        }

        private Hashtable Datastore
        {
            get 
            { 
                if (null == m_Datastore)
                {
                    // The local store has not yet been created for this thread.
                    m_Datastore = new Hashtable();
                }
                return m_Datastore;
            }
        }

        // This is used for quick access to the current principal when going
        // between appdomains.
        internal IPrincipal Principal
        {
            get 
            { 
                // This MUST not fault in the security data object if it doesn't exist.
                if (m_SecurityData != null)
                    return m_SecurityData.Principal;

                return null;
            } // get

            set
            {
                SecurityData.Principal = value;
            } // set
        } // Principal

        /*=========================================================================
        ** Frees a named data slot.
        =========================================================================*/
        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.FreeNamedDataSlot"]/*' />
        public void FreeNamedDataSlot(String name)
        {
            Datastore.Remove(name);
        }

        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.GetData"]/*' />
        public Object GetData(String name)
        {
            return Datastore[name];
        }

        /// <include file='doc\CallContext.uex' path='docs/doc[@for="LogicalCallContext.SetData"]/*' />
        public void SetData(String name, Object data)
        {
            Datastore[name] = data;
        }

        private Header[] InternalGetOutgoingHeaders()
        {
            Header[] outgoingHeaders = _sendHeaders;
            _sendHeaders = null;
        
            // A new remote call is being made, so we null out the
            //   current received headers so these can't be confused
            //   with a response from the next call.
            _recvHeaders = null;

            return outgoingHeaders;
        } // InternalGetOutgoingHeaders


        internal void InternalSetHeaders(Header[] headers)
        {
            _sendHeaders = headers;
            _recvHeaders = null;
        } // InternalSetHeaders


        internal Header[] InternalGetHeaders()
        {
            // If _sendHeaders is currently set, we always want to return them.
            if (_sendHeaders != null)
                return _sendHeaders;

            // Either _recvHeaders is non-null and those are the ones we want to
            //   return, or there are no currently set headers, so we'll return
            //    null.
            return _recvHeaders;
        } // InternalGetHeaders


        // Takes outgoing headers and inserts them        
        internal void PropagateOutgoingHeadersToMessage(IMessage msg)
        {
            Header[] headers = InternalGetOutgoingHeaders();
        
            if (headers != null)
            {
                BCLDebug.Assert(msg != null, "Why is the message null?");
            
                IDictionary properties = msg.Properties;
                BCLDebug.Assert(properties != null, "Why are the properties null?");
        
                foreach (Header header in headers)
                {
                    // add header to the message dictionary
                    if (header != null)
                    {
                        // The header key is composed from its name and namespace.
                        
                        String name = GetPropertyKeyForHeader(header);

                        properties[name] = header;
                    }
                }
            }
        } // PropagateOutgoingHeadersToMessage

        // Retrieve key to use for header.
        internal static String GetPropertyKeyForHeader(Header header)
        {
            if (header == null)
                return null;

            if (header.HeaderNamespace != null)
                return header.Name + ", " + header.HeaderNamespace;
            else
                return header.Name;                
        } // GetPropertyKeyForHeader


        // Take headers out of message and stores them in call context
        internal void PropagateIncomingHeadersToCallContext(IMessage msg)
        {                  
            BCLDebug.Assert(msg != null, "Why is the message null?");

            // If it's an internal message, we can quickly tell if there are any
            //   headers.
            IInternalMessage iim = msg as IInternalMessage;
            if (iim != null)
            {
                if (!iim.HasProperties())
                {
                    // If there are no properties just return immediately.
                    return;
                }
            }
            
            IDictionary properties = msg.Properties;
            BCLDebug.Assert(properties != null, "Why are the properties null?");
            
            IDictionaryEnumerator e = (IDictionaryEnumerator) properties.GetEnumerator();

            // cycle through the properties to get a count of the headers
            int count = 0;
            while (e.MoveNext())
            {   
                String key = (String)e.Key;
                if (!key.StartsWith("__")) 
                {
                    // We don't want to have to check for special values, so we
                    //   blanketly state that header names can't start with
                    //   double underscore.
                    if (e.Value is Header)
                        count++;
                }
            }

            // If there are headers, create array and set it to the received header property
            Header[] headers = null;
            if (count > 0)
            {
                headers = new Header[count];

                count = 0;
                e.Reset();
                while (e.MoveNext())
                {   
                    String key = (String)e.Key;
                    if (!key.StartsWith("__")) 
                    {
                        Header header = e.Value as Header;
                        if (header != null)
                            headers[count++] = header;
                    }
                }                
            }   

            _recvHeaders = headers;
            _sendHeaders = null;
        } // PropagateIncomingHeadersToCallContext
        
    } // class LogicalCallContext

    

    [Serializable]   
    internal class CallContextSecurityData : ICloneable
    {
        // This is used for the special getter/setter for security related
        // info in the callContext.
        IPrincipal _principal;
        // Review: does this need any SecurityPermissions attrib etc?
        internal IPrincipal Principal
        {
            get {return _principal;}
            set {_principal = value;}
        }

        // Checks if there is any useful data to be serialized
        internal bool HasInfo
        {
            get
            {
                return (null != _principal);
            }
            
        }

        public Object Clone()
        {
            CallContextSecurityData sd = new CallContextSecurityData();
            sd._principal = _principal;
            return sd;
        }

    }

    [Serializable]    
    internal class CallContextRemotingData : ICloneable
    {
        // This is used for the special getter/setter for remoting related
        // info in the callContext.
        String _logicalCallID;

        internal String LogicalCallID
        {
            get  {return _logicalCallID;}
            set  {_logicalCallID = value;}
        }
        
        // Checks if there is any useful data to be serialized
        internal bool HasInfo
        {
            get
            {
                // Keep this updated if we add more stuff to remotingData!
                return (_logicalCallID!=null);
            }
        }

        public Object Clone()
        {
            CallContextRemotingData rd = new CallContextRemotingData();
            rd.LogicalCallID = LogicalCallID;
            return rd;
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\crossappdomainchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Remoting Infrastructure Sink for making calls across context
// boundaries. 
//
namespace System.Runtime.Remoting.Channels {
    using System;
    using System.Collections;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Security.Principal;
    using System.Text;
    using System.Threading;


    [Serializable]
    internal class CrossAppDomainChannel : IChannel, IChannelSender, IChannelReceiver
    {
        private const String _channelName = "XAPPDMN";
        private const String _channelURI = "XAPPDMN_URI";

    
        private static CrossAppDomainChannel gAppDomainChannel
        { 
            get { return Thread.GetDomain().RemotingData.ChannelServicesData.xadmessageSink; }
            set { Thread.GetDomain().RemotingData.ChannelServicesData.xadmessageSink = value; }
        }
        private static Object staticSyncObject = new Object();
        private static PermissionSet s_fullTrust = new PermissionSet(PermissionState.Unrestricted);

        internal static PermissionSet FullTrust 
        {  
            get { return s_fullTrust; }
        }
    
        internal static CrossAppDomainChannel AppDomainChannel
        {
            get
            {    
                if (gAppDomainChannel == null) 
                {                 
                    CrossAppDomainChannel tmpChnl = new CrossAppDomainChannel();
                    
                    lock (staticSyncObject)
                    {
                        if (gAppDomainChannel == null)
                        {
                            gAppDomainChannel = tmpChnl;
                        }
                    }
                }
                return gAppDomainChannel;
                
            }
        }
    
        internal static void RegisterChannel()
        {
            CrossAppDomainChannel adc = CrossAppDomainChannel.AppDomainChannel;
            ChannelServices.RegisterChannelInternal((IChannel)adc);
        }
        
        //
        // IChannel Methods
        //
        public virtual String ChannelName
        {
            get{ return _channelName; }
        }
    
        public virtual String ChannelURI
        {
            get{ return _channelURI; }
        }
    
        public virtual int ChannelPriority
        {
            get{ return 100;}
        }
    
        public String Parse(String url, out String objectURI)
        {
            objectURI = url;
            return null;
        }
    
        public virtual Object ChannelData
        {
            get 
            { 
                return new CrossAppDomainData(
                                    Context.DefaultContext.InternalContextID,
                                    Thread.GetDomain().GetId(),
                                    Identity.ProcessGuid); 
            }
        }

                                    
        public virtual IMessageSink CreateMessageSink(String url, Object data, 
                                                      out String objectURI)
        {
            // Set the out parameters
            objectURI = null;
            IMessageSink sink = null;
            
            // FUTURE: this url parsing part will be useful only when
            // we have wellknown x-appdomain objects (that use the appdomain
            // channel)
            if ((null != url) && (data == null))
            {
                if(url.StartsWith(_channelName))
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_AppDomains_NYI"));
                }
            }
            else
            {
                Message.DebugOut("XAPPDOMAIN::Creating sink for data \n");       
                CrossAppDomainData xadData = data as CrossAppDomainData;
                if (null != xadData)
                {
                    if (xadData.ProcessGuid.Equals(Identity.ProcessGuid))
                    {
                        int srvContextID = xadData.ContextID;
                        int srvDomainID = xadData.DomainID;
                        sink = CrossAppDomainSink.FindOrCreateSink(
                                        srvContextID,
                                        srvDomainID
                                        );
                    }
                }
            }
            return sink;
        }

        public virtual String[] GetUrlsForUri(String objectURI)
        {
            throw new NotSupportedException(
                Environment.GetResourceString(
                    "NotSupported_Method"));
            //FUTURE: this is useful only when x-appDomain well known 
            // objects are supported.        
            //return new String[]{_channelName + "://" + _channelURI + "/" + objectURI};
        }
        
        public virtual void StartListening(Object data)
        {
        
        }
        
        public virtual void StopListening(Object data)
        {
        
        }
        

        // NOTE: These properties should be ignored for this type of channel.
        public IServerChannelSinkProvider ServerSinkProvider { get { return null; } }
    }
    [Serializable]
    internal class CrossAppDomainData
    {
        int _ContextID; // default context in the server appDomain
        int _DomainID;  // server appDomain ID
        String _processGuid;    // idGuid for the process (shared static)
        
        internal virtual int ContextID {   get {return _ContextID;}}
        internal virtual int DomainID {     get {return _DomainID;}}
        internal virtual String ProcessGuid { get {return _processGuid;}}
        
        internal CrossAppDomainData(int ctxId, int domainID, String processGuid)
        {
            _ContextID = ctxId;
            _DomainID = domainID;
            _processGuid = processGuid;
        }

        internal bool IsFromThisProcess()
        {
            return Identity.ProcessGuid.Equals(_processGuid);
        }

        internal bool IsFromThisAppDomain()
        {
            return  IsFromThisProcess()  
                    &&
                    (Thread.GetDomain().GetId() == _DomainID);
        }
    }
   //    Implements the Message Sink provided by the X-AppDomain channel.
   //    We try to use one instance of the sink to make calls to all remote
   //    objects in another AppDomain from one AppDomain.
    internal class CrossAppDomainSink 
        : InternalSink, IMessageSink
    {
        internal const int GROW_BY = 0x8;
        internal static int[] _sinkKeys;
        internal static CrossAppDomainSink[] _sinks;
        private static Object staticSyncObject = new Object();
    
        // each sink stores the default ContextID of the server side domain
        // and the domain ID for the domain
        internal int _srvContextID;
        internal int _srvDomainID;
    
        internal CrossAppDomainSink(int srvContextID, int srvDomainID)
        {
            _srvContextID = srvContextID;
            _srvDomainID = srvDomainID;
            Message.DebugOut("### New Sink srvID = " + srvContextID + "\n");
        }
    
        // Note: this should be called from within a synch-block
        internal static void GrowArrays(int oldSize)
        {
            if (_sinks == null)
            {
                _sinks = new CrossAppDomainSink[GROW_BY];
                _sinkKeys = new int[GROW_BY];
            }
            else
            {
                CrossAppDomainSink[] tmpSinks = new CrossAppDomainSink[_sinks.Length + GROW_BY];
                int[] tmpKeys = new int[_sinkKeys.Length + GROW_BY];
                Array.Copy(_sinks, tmpSinks, _sinks.Length);
                Array.Copy(_sinkKeys, tmpKeys, _sinkKeys.Length);    
                _sinks = tmpSinks;
                _sinkKeys = tmpKeys;
            }
        }
        internal static CrossAppDomainSink FindOrCreateSink(
            int srvContextID, int srvDomainID)
        {
            lock(staticSyncObject) {        
                // Note: keep this in sync with DomainUnloaded below 
                int key = srvDomainID;
                if (_sinks == null)
                {
                    GrowArrays(0);
                }
                int i=0;
                while (_sinks[i] != null)
                {
                    if (_sinkKeys[i] == key)
                    {
                        return _sinks[i];
                    }
                    i++;
                    if (i == _sinks.Length)
                    {
                        // could not find a sink, also need to Grow the array.
                        GrowArrays(i);
                        break;
                    }
                }
                // At this point we need to create a new sink and cache
                // it at location "i"
                _sinks[i] = new CrossAppDomainSink(srvContextID, srvDomainID);
                _sinkKeys[i] = key;
                return _sinks[i];
            }
        }

        internal static void DomainUnloaded(Int32 domainID)
        {
            int key = domainID;
            lock(staticSyncObject) {        
                // Note: keep this in sync with FindOrCreateSink
                int i = 0;
                int remove = -1;
                while (_sinks[i] != null)
                {
                    if (_sinkKeys[i] == key)
                    {
                        BCLDebug.Assert(remove == -1, "multiple sinks?");
                        remove = i; 
                    }
                    i++;
                    if (i == _sinks.Length)
                    {
                        break;
                    }
                }
                // The sink to remove is at index 'remove'
                // We will move the last non-null entry to this location
                BCLDebug.Assert(remove != -1, "Bad domainId for unload?");
                _sinkKeys[remove] = _sinkKeys[i-1];
                _sinks[remove] = _sinks[i-1];
                _sinkKeys[i-1] = 0;
                _sinks[i-1] = null;
            }

        }


        internal byte[] DoDispatch(byte[] reqStmBuff, 
                                   SmuggledMethodCallMessage smuggledMcm,
                                   out SmuggledMethodReturnMessage smuggledMrm)
        {
            RemotingServices.LogRemotingStage(RemotingServices.SERVER_MSG_DESER);

            //*********************** DE-SERIALIZE REQ-MSG ********************

            IMessage desReqMsg = null;
            
            if (smuggledMcm != null)
            {
                ArrayList deserializedArgs = smuggledMcm.FixupForNewAppDomain();
                desReqMsg = new MethodCall(smuggledMcm, deserializedArgs);
            }
            else
            {
                MemoryStream reqStm = new MemoryStream(reqStmBuff);
                desReqMsg = CrossAppDomainSerializer.DeserializeMessage(reqStm);
            }

            // now we can delegate to the DispatchMessage to do the rest

            RemotingServices.LogRemotingStage(RemotingServices.SERVER_MSG_SINK_CHAIN);

            IMessage retMsg = ChannelServices.SyncDispatchMessage(desReqMsg);

            RemotingServices.LogRemotingStage(RemotingServices.SERVER_RET_SER);

            smuggledMrm = SmuggledMethodReturnMessage.SmuggleIfPossible(retMsg);
            if (smuggledMrm != null)
            {                
                return null;
            }
            else
            {                
                if (retMsg != null)
                {
                    // Null out the principal since we won't use it on the other side.
                    // This is handled inside of SmuggleIfPossible for method call
                    // messages.
                    LogicalCallContext callCtx = (LogicalCallContext)
                        retMsg.Properties[Message.CallContextKey];
                    if (callCtx != null)
                    {
                        if (callCtx.Principal != null)
                            callCtx.Principal = null;
                    }
	                return CrossAppDomainSerializer.SerializeMessage(retMsg).GetBuffer();
                }
            
                //*********************** SERIALIZE RET-MSG ********************
                return null;
            }
        } // DoDispatch



        internal byte[] DoTransitionDispatch(
            byte[] reqStmBuff,  
            SmuggledMethodCallMessage smuggledMcm,
            out SmuggledMethodReturnMessage smuggledMrm)
        {    
            // Note: To be safe w.r.t. the app domain leak code, this frame
            // should have no non-agile references in it.

            ContextTransitionFrame frame = new ContextTransitionFrame();

            // change to server domain                  
            Thread.CurrentThread.EnterContextInternal(
                                    null, 
                                    _srvContextID, 
                                    _srvDomainID, 
                                    ref frame);

            byte[] retBuff = null;
            smuggledMrm = null;
            try
            {
                Message.DebugOut("#### : changed to Server Domain :: "+ (Thread.CurrentContext.InternalContextID).ToString("X") );

                retBuff = DoDispatch(reqStmBuff, smuggledMcm, out smuggledMrm);
            }
            catch (Exception e)
            {
                // This will catch exceptions thrown by the infrastructure,
                // Serialization/Deserialization etc
                // Those thrown by the server are already taken care of 
                // and encoded in the retMsg .. so we don't come here for 
                // that case.

                // We are in another appDomain, so we can't simply throw 
                // the exception object across. The following marshals it
                // into a serialized return message. 
                IMessage retMsg = 
                    new ReturnMessage(e, new ErrorMessage());
                //*********************** SERIALIZE RET-MSG ******************
                retBuff = CrossAppDomainSerializer.SerializeMessage(retMsg).GetBuffer(); 
                retMsg = null;
            }
            finally
            {                
                RemotingServices.LogRemotingStage(RemotingServices.SERVER_RET_SEND);
                Thread.CurrentThread.ReturnToContext(ref frame);
                Message.DebugOut("#### : changed back to Client Domain " + (Thread.CurrentContext.InternalContextID).ToString("X"));
            }

            // System.Diagnostics.Debugger.Break();
            return retBuff;
        } // DoTransitionDispatch
        
        public virtual IMessage SyncProcessMessage(IMessage reqMsg) 
        {
            Message.DebugOut("\n::::::::::::::::::::::::: CrossAppDomain Channel: Sync call starting");
            IMessage errMsg = InternalSink.ValidateMessage(reqMsg);
            if (errMsg != null)
            {
                return errMsg;
            }
            

            // currentPrincipal is used to save the current principal. It should be
            //   restored on the reply message.
            IPrincipal currentPrincipal = null; 
                                      

            IMessage desRetMsg = null;

            try
            {                
                IMethodCallMessage mcmReqMsg = reqMsg as IMethodCallMessage;
                if (mcmReqMsg != null)
                {
                    LogicalCallContext lcc = mcmReqMsg.LogicalCallContext;
                    if (lcc != null)
                    {
                        currentPrincipal = lcc.Principal;
                        // If the principal is not serializable, we need to
                        //   null it out for the duration of the call.
                        if (currentPrincipal != null)
                        {
                            if (!currentPrincipal.GetType().IsSerializable)
                                lcc.Principal = null;
                        }
                    }
                }
            
                MemoryStream reqStm = null;
                SmuggledMethodCallMessage smuggledMcm = SmuggledMethodCallMessage.SmuggleIfPossible(reqMsg);

                if (smuggledMcm == null)
                {    
            
                    //*********************** SERIALIZE REQ-MSG ****************
                    // Deserialization of objects requires permissions that users 
                    // of remoting are not guaranteed to possess. Since remoting 
                    // can guarantee that it's users can't abuse deserialization 
                    // (since it won't allow them to pass in raw blobs of 
                    // serialized data), it should assert the permissions 
                    // necessary before calling the deserialization code. This 
                    // will terminate the security stackwalk caused when 
                    // serialization checks for the correct permissions at the 
                    // remoting stack frame so the check won't continue on to 
                    // the user and fail. [from RudiM]
                    // We will hold off from doing this for x-process channels
                    // until the big picture of distributed security is finalized.

                    RemotingServices.LogRemotingStage(RemotingServices.CLIENT_MSG_SER);
                    reqStm = CrossAppDomainSerializer.SerializeMessage(reqMsg);
                }
                                
                // Retrieve calling caller context here, where it is safe from the view
                // of app domain checking code
                LogicalCallContext oldCallCtx = CallContext.SetLogicalCallContext(null);

                // Call helper method here, to avoid confusion with stack frames & app domains
                MemoryStream retStm = null;
                byte[] responseBytes = null;
                SmuggledMethodReturnMessage smuggledMrm;
                RemotingServices.LogRemotingStage(RemotingServices.CLIENT_MSG_SEND);
                
                try
                {
                    if (smuggledMcm != null)
                        responseBytes = DoTransitionDispatch(null, smuggledMcm, out smuggledMrm);
                    else
                        responseBytes = DoTransitionDispatch(reqStm.GetBuffer(), null, out smuggledMrm);                                       
                }
                finally
                {
                    CallContext.SetLogicalCallContext(oldCallCtx);
                }

                if (smuggledMrm != null)
                {
                    ArrayList deserializedArgs = smuggledMrm.FixupForNewAppDomain();
                    desRetMsg = new MethodResponse((IMethodCallMessage)reqMsg, 
                                                   smuggledMrm,
                                                   deserializedArgs);
                }
                else
                {
                    if (responseBytes != null){
                        retStm = new MemoryStream(responseBytes);
                        
                        RemotingServices.LogRemotingStage(RemotingServices.CLIENT_RET_DESER);
                        Message.DebugOut("::::::::::::::::::::::::::: CrossAppDomain Channel: Sync call returning!!\n");
                        //*********************** DESERIALIZE RET-MSG **************
                        desRetMsg = CrossAppDomainSerializer.DeserializeMessage(retStm, reqMsg as IMethodCallMessage);
                    }
                }
            }
            catch(Exception e)
            {
                Message.DebugOut("Arrgh.. XAppDomainSink::throwing exception " + e + "\n");
                try
                {
                    desRetMsg = new ReturnMessage(e, (reqMsg as IMethodCallMessage));
                }
                catch(Exception )
                {
                    // Fatal Error .. can't do much here
                }
            }           

            // restore the principal if necessary.
            if (currentPrincipal != null)
            {
                IMethodReturnMessage mrmRetMsg = desRetMsg as IMethodReturnMessage;
                if (mrmRetMsg != null)
                {
                    LogicalCallContext lcc = mrmRetMsg.LogicalCallContext;
                    lcc.Principal = currentPrincipal;
                }
            }           

            RemotingServices.LogRemotingStage(RemotingServices.CLIENT_RET_SINK_CHAIN);
            return desRetMsg;                         
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            // This is the case where we take care of returning the calling
            // thread asap by using the ThreadPool for completing the call.
            
            // we use a more elaborate WorkItem and delegate the work to the thread pool
            ADAsyncWorkItem workItem = new ADAsyncWorkItem(reqMsg, 
                                        (IMessageSink)this, /* nextSink */
                                        replySink);

            WaitCallback threadFunc = new WaitCallback(workItem.FinishAsyncWork);
            ThreadPool.QueueUserWorkItem(threadFunc);
            
            return null;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                // We are a terminating sink for this chain
                return null;
            }
        }
 
    }

    /* package */
    internal class ADAsyncWorkItem 
    {
        // the replySink passed in to us in AsyncProcessMsg
        private IMessageSink _replySink;

        // the nextSink we have to call
        private IMessageSink _nextSink;
                
        private LogicalCallContext _callCtx;
        
        // the request msg passed in
        private IMessage _reqMsg;    
        
        internal ADAsyncWorkItem(IMessage reqMsg, IMessageSink nextSink, IMessageSink replySink)
        {
            _reqMsg = reqMsg;
            _nextSink = nextSink;
            _replySink = replySink;
            _callCtx = CallContext.GetLogicalCallContext();
        }
                    
        /* package */
        internal virtual void FinishAsyncWork(Object stateIgnored)
        {
            // install the call context that the calling thread actually had onto
            // the threadPool thread.
            LogicalCallContext threadPoolCallCtx = CallContext.SetLogicalCallContext(_callCtx);
      
            IMessage retMsg = _nextSink.SyncProcessMessage(_reqMsg);

            // send the reply back to the replySink we were provided with   
            // note: replySink may be null for one-way calls.
            if (_replySink != null)
            {
                _replySink.SyncProcessMessage(retMsg);
            }
            CallContext.SetLogicalCallContext(threadPoolCallCtx);          
        }    
    }

    
    internal class CrossAppDomainSerializer
    {
        internal static Header[] GetHeaders(IMessage reqMsg)
        {
            if (reqMsg == null) 
                throw new ArgumentNullException("reqMsg");

            IDictionary d = reqMsg.Properties;
            if (d.Count == 0)
            {
                return new Header[0];
            }
            Header[] ret = new Header[d.Count - 1];
            IDictionaryEnumerator e = d.GetEnumerator();
            int i = 0;
            while(e.MoveNext())
            {
                if (!e.Key.Equals("__Args") && !e.Key.Equals("__OutArgs"))
                {
                    Header h = new Header((String) e.Key, e.Value, false);
                    if (i == ret.Length)
                    {
                        Header[] newret= new Header[i+1];
                        Array.Copy(ret, newret, i);
                        ret = newret;
                    }
                    ret[i] = h;
                    i++;
                }
            }
            return ret;
    
        }

        internal static MemoryStream SerializeMessage(IMessage msg)
        {
            MemoryStream stm = new MemoryStream();
            RemotingSurrogateSelector ss = new RemotingSurrogateSelector();
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.SurrogateSelector = ss;
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);
            fmt.Serialize(stm, msg, null, false /* No Security check */);
    
            // Reset the stream so that Deserialize happens correctly
            stm.Position = 0;

            return stm;
        }

        // called from MessageSmuggler classes
        /*
        internal static MemoryStream SerializeMessageParts(ArrayList argsToSerialize, out Object[] smuggledArgs)
        {
            MemoryStream stm = new MemoryStream();
            
            BinaryFormatter fmt = new BinaryFormatter();       
            RemotingSurrogateSelector ss = new RemotingSurrogateSelector();
            fmt.SurrogateSelector = ss;            
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);
            fmt.Serialize(stm, argsToSerialize, null, false ); // No Security check
            
            smuggledArgs = fmt.CrossAppDomainArray;
            stm.Position = 0;
            return stm;
        } // SerializeMessageParts 
        */

        internal static MemoryStream SerializeMessageParts(ArrayList argsToSerialize)
        {
            MemoryStream stm = new MemoryStream();
            
            BinaryFormatter fmt = new BinaryFormatter();       
            RemotingSurrogateSelector ss = new RemotingSurrogateSelector();
            fmt.SurrogateSelector = ss;            
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);
            fmt.Serialize(stm, argsToSerialize, null, false /* No Security check */);
            
            stm.Position = 0;
            return stm;
        } // SerializeMessageParts 

        // called from MessageSmuggler classes
        internal static MemoryStream SerializeObject(Object obj)
        {
            MemoryStream stm = new MemoryStream();
            
            BinaryFormatter fmt = new BinaryFormatter();       
            RemotingSurrogateSelector ss = new RemotingSurrogateSelector();
            fmt.SurrogateSelector = ss;            
            fmt.Context = new StreamingContext(StreamingContextStates.Other);
            fmt.Serialize(stm, obj, null, false /* No Security check */);
            
            stm.Position = 0;
            return stm;
        } // SerializeMessageParts 
        
    
        internal static IMessage DeserializeMessage(MemoryStream stm)
        {
            return DeserializeMessage(stm, null);
        }

        internal static IMessage DeserializeMessage(
            MemoryStream stm, IMethodCallMessage reqMsg)
        {
            if (stm == null)
                throw new ArgumentNullException("stm");
            
            stm.Position = 0;
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.SurrogateSelector = null;
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);

            return (IMessage) fmt.Deserialize(stm, null, false /* No Security check */, reqMsg);
        }

        // called from MessageSmuggler classes
        /*
        internal static ArrayList DeserializeMessageParts(MemoryStream stm, Object[] args)
        {                       
            stm.Position = 0;
            
            BinaryFormatter fmt = new BinaryFormatter(); 
            fmt.CrossAppDomainArray = args;
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);
            return (ArrayList) fmt.Deserialize(stm, null, false); // No security check
        } // DeserializeMessageParts
        */

        internal static ArrayList DeserializeMessageParts(MemoryStream stm)
        {                       
            return (ArrayList) DeserializeObject(stm);

        } // DeserializeMessageParts


        internal static Object DeserializeObject(MemoryStream stm)
        {                       
            stm.Position = 0;
            
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.Context = new StreamingContext(StreamingContextStates.CrossAppDomain);
            return fmt.Deserialize(stm, null, false /* No Security check */);
        } // DeserializeMessageParts


        public static void DebugOutXMLStream(Stream stm, String tag)
        {
            long oldpos = stm.Position;
            stm.Position=0;
            StreamReader sr = new StreamReader(stm, Encoding.UTF8);
            String line;
            Console.WriteLine(Environment.NewLine + "    -----------" + tag + " OPEN-------------" + Environment.NewLine) ;
            while ((line = sr.ReadLine()) != null) 
            {
            Console.WriteLine(line);
            }
            Console.WriteLine(Environment.NewLine + "    -----------" + tag + " CLOSE------------" + Environment.NewLine) ;

            stm.Position = oldpos;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\contextproperty.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ContextProperty.cool
**
** A contextProperty is a name-value pair holding the property
** name and the object representing the property in a context.
** An array of these is returned by Context::GetContextProperties()
** 
** Author:  Manish Prabhu (MPrabhu)
**
** Date:    June 25, 1999
**
===========================================================*/

namespace System.Runtime.Remoting.Contexts {
    
    using System;
    using System.Threading;
    using System.Reflection;
    using System.Runtime.InteropServices;    
    using System.Runtime.Remoting.Activation;  
    using System.Security.Permissions;
    
    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextProperty"]/*' />
    /// <internalonly/>
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ContextProperty {
        internal String _name;           // property name
        internal Object _property;       // property object
    
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextProperty.Name"]/*' />
    /// <internalonly/>
        public virtual String Name {
            get {
                return _name;
            }
        }
    
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextProperty.Property"]/*' />
    /// <internalonly/>
        public virtual Object Property {
            get {
                return _property;
            }
        }
    
        /* can't create outside the package */
        internal ContextProperty(String name, Object prop)
        {
            _name = name;
            _property = prop;
        }
    }
    
    //  The IContextAttribute interface is implemented by attribute classes.
    //  The attributes contribute a property which resides in a context and
    //  enforces a specific policy for the objects created in that context.
    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextAttribute"]/*' />
    /// <internalonly/>
    public interface IContextAttribute
    {
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextAttribute.IsContextOK"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        bool IsContextOK(Context ctx, IConstructionCallMessage msg);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextAttribute.GetPropertiesForNewContext"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void GetPropertiesForNewContext(IConstructionCallMessage msg);
    }
    
   //   This interface is exposed by the property contributed to a context
   //   by an attribute. By default, it is also implemented by the ContextAttribute
   //   base class which every attribute class must extend from.
    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextProperty"]/*' />
    /// <internalonly/>
    public interface IContextProperty
    {
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextProperty.Name"]/*' />
    /// <internalonly/>
       //   This is the name under which the property will be added
       //   to the {name,property} table in a context.
        String Name 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get;
	}
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextProperty.IsNewContextOK"]/*' />
    /// <internalonly/>
       //   After forming the newCtx, we ask each property if it is happy
       //   with the context. We expect most implementations to say yes.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        bool IsNewContextOK(Context newCtx);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextProperty.Freeze"]/*' />
    /// <internalonly/>

        // New method. All properties are notified when the context
        // they are in is frozen.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void Freeze(Context newContext);
    }  

    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator"]/*' />
    /// <internalonly/>
    public interface IContextPropertyActivator
    {
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator.IsOKToActivate"]/*' />
    /// <internalonly/>
        // This method lets properties in the current context have a say in 
        // whether an activation may be done 'here' or not.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        bool IsOKToActivate(IConstructionCallMessage msg);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator.CollectFromClientContext"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void CollectFromClientContext(IConstructionCallMessage msg);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator.DeliverClientContextToServerContext"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        bool DeliverClientContextToServerContext(IConstructionCallMessage msg);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator.CollectFromServerContext"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        void CollectFromServerContext(IConstructionReturnMessage msg);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="IContextPropertyActivator.DeliverServerContextToClientContext"]/*' />
    /// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        bool DeliverServerContextToClientContext(IConstructionReturnMessage msg);
    }
    
    
   //   All context attribute classes must extend from this base class.
   //   This class provides the base implementations which the derived
   //   classes are free to over-ride. The base implementations provide
   //   the default answers to various questions.
     
    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute"]/*' />
    /// <internalonly/>
    [AttributeUsage(AttributeTargets.Class), Serializable]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ContextAttribute
        : Attribute, IContextAttribute, IContextProperty
    {
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.AttributeName"]/*' />
    /// <internalonly/>
        protected String AttributeName;
    
        // The derived class must call: base(name);
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.ContextAttribute"]/*' />
    /// <internalonly/>
        public ContextAttribute(String name)
        {
            AttributeName = name;
        }
        
        // IContextPropery::Name
        // Default implementation provides AttributeName as the property name.
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.Name"]/*' />
    /// <internalonly/>
        public virtual String Name { get {return AttributeName;} }

        // IContextProperty::IsNewContextOK
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.IsNewContextOK"]/*' />
    /// <internalonly/>
        public virtual bool IsNewContextOK(Context newCtx)
        {
            // This will be called before entering the newCtx
            // Default implementation says OK.
            return true;
        }    

        // IContextProperty::Freeze
        // Default implementation does nothing
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.Freeze"]/*' />
    /// <internalonly/>
        public virtual void Freeze(Context newContext)
        {
            BCLDebug.Log("ContextAttribute::ContextProperty::Freeze"+
                        " for context " + newContext );
        }
                
        // Object::Equals
        // Default implementation just compares the names
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.Equals"]/*' />
    /// <internalonly/>
        public override bool Equals(Object o)
        {
            IContextProperty prop = o as IContextProperty;
            return  (null != prop) && AttributeName.Equals(prop.Name);
        }

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.GetHashCode"]/*' />
    /// <internalonly/>
        public override int GetHashCode()
        {
            return this.AttributeName.GetHashCode();
        }

        // IContextAttribute::IsContextOK
        // Default calls Object::Equals on the property and does not
        // bother with the ctorMsg.
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.IsContextOK"]/*' />
    /// <internalonly/>
        public virtual bool IsContextOK(
            Context ctx, IConstructionCallMessage ctorMsg)
        {
            if (ctx == null) 
                throw new ArgumentNullException("ctx");
            if (ctorMsg == null) 
                throw new ArgumentNullException("ctorMsg");
                
            BCLDebug.Assert(ctorMsg.ActivationType.IsMarshalByRef, "Activation on a non MarshalByRef object");

            if (!ctorMsg.ActivationType.IsContextful)
            {
                return true;
            }

            Object prop = ctx.GetProperty(AttributeName);
            if ((prop!=null) && (Equals(prop)))
            {
                return true;
            }
            return false;
        }
        
        // IContextAttribute::GetPropertiesForNewContext
        // Default adds the attribute itself w/o regard to the current
        // list of properties
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="ContextAttribute.GetPropertiesForNewContext"]/*' />
    /// <internalonly/>
        public virtual void GetPropertiesForNewContext(
            IConstructionCallMessage ctorMsg)
        {
            if (ctorMsg == null)
                throw new ArgumentNullException("ctorMsg");
            ctorMsg.ContextProperties.Add((IContextProperty)this);
        }
    }

#if SIMPLEXAACTIVATION
    /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain"]/*' />
    /// <internalonly/>
        [AttributeUsage(AttributeTargets.Class)]
    public class new_appdomain : ContextAttribute
    {

        internal static int _domain_no = 0;

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.new_appdomain"]/*' />
    /// <internalonly/>
        public new_appdomain() : base("new_appdomain") {}

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.IsContextOK"]/*' />
    /// <internalonly/>
        public override bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            return false;
        }

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.GetPropertiesForNewContext"]/*' />
    /// <internalonly/>
        public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
        {
            ctorMsg.GetProperties()["__new_appdomain"] = true;
        }

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.DoSimpleXADActivation"]/*' />
    /// <internalonly/>
        public static IConstructionReturnMessage DoSimpleXADActivation(IConstructionCallMessage msg)
        {
            int domain_no = Interlocked.Increment(ref _domain_no);
            AppDomain ad = AppDomain.CreateDomain("AutoDomain #" + domain_no, null, null);

            activator a = (activator) (ad.CreateInstance(null, typeof(activator).FullName)).Unwrap();
            
//            a.LoadAssembly(Assembly.GetAssembly(msg.GetServerType()).GetName());
            return a.Activate(msg);
        }

        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.activator"]/*' />
    /// <internalonly/>
        public class activator : MarshalByRefObject, IActivator
        {
            /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.activator.Activate"]/*' />
        /// <internalonly/>
            public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
            {
                return RemotingServices.DoCrossContextActivation(msg);
            }

            /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="new_appdomain.activator.LoadAssembly"]/*' />
        /// <internalonly/>
            public void LoadAssembly(AssemblyName an)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                Assembly a = Assembly.InternalLoad(an, false, null, ref stackMark);
                if (a == null)
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_AssemblyLoadFailed"),
                            an));                                
                }
            }
        }
    }
    
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="MBR"]/*' />
    /// <internalonly/>
        [new_appdomain]
        public class MBR : MarshalByRefObject
        {
            /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="MBR.MyAppDomain"]/*' />
        /// <internalonly/>
            public String MyAppDomain()
            {
                return Thread.GetDomain().GetFriendlyName();
            }
        }
        
        /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="CB"]/*' />
    /// <internalonly/>
        [new_appdomain]
        public class CB : ContextBoundObject
        {
            /// <include file='doc\ContextProperty.uex' path='docs/doc[@for="CB.MyAppDomain"]/*' />
        /// <internalonly/>
            public String MyAppDomain()
            {
                return Thread.GetDomain().GetFriendlyName();
            }
        }
#endif        
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\clientsponsor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        ClientSponsor.cool
//
// Contents:    Agent for keeping Server Object's lifetime in sync with a client's lifetime
//
// History:     8/9/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ClientSponsor : MarshalByRefObject, ISponsor
    {
		private Hashtable sponsorTable = new Hashtable(10);
		private TimeSpan m_renewalTime = TimeSpan.FromMinutes(2);

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.ClientSponsor"]/*' />
		public ClientSponsor()
		{
		}

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.ClientSponsor1"]/*' />
		public ClientSponsor(TimeSpan renewalTime)
		{
			this.m_renewalTime = renewalTime;
		}

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.RenewalTime"]/*' />
		public TimeSpan RenewalTime
		{
			get{ return m_renewalTime;}
			set{ m_renewalTime = value;}
		}
			
		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.Register"]/*' />
		public bool Register(MarshalByRefObject obj)
		{
			BCLDebug.Trace("REMOTE", "ClientSponsor Register "+obj);
			ILease lease = (ILease)obj.GetLifetimeService();
			if (lease == null)
				return false;

			lease.Register(this);
			lock(sponsorTable)
			{
				sponsorTable[obj] = lease;
			}
			return true;
		}

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.Unregister"]/*' />
		public void Unregister(MarshalByRefObject obj)
		{
			BCLDebug.Trace("REMOTE", "ClientSponsor Unregister "+obj);

			ILease lease = null;
			lock(sponsorTable)
			{
				lease = (ILease)sponsorTable[obj];
			}
			if (lease != null)
				lease.Unregister(this);
		}

		// ISponsor method
		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.Renewal"]/*' />
		public TimeSpan Renewal(ILease lease)
		{
			BCLDebug.Trace("REMOTE", "ClientSponsor Renewal "+m_renewalTime);
			return m_renewalTime;
		}

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.Close"]/*' />
		public void Close()
		{
			BCLDebug.Trace("REMOTE","ClientSponsor Close");
			lock(sponsorTable)
			{
				IDictionaryEnumerator e = sponsorTable.GetEnumerator();
				while(e.MoveNext())
					((ILease)e.Value).Unregister(this);
				sponsorTable.Clear();
			}
		}

		// Don't create a lease on the sponsor
		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.InitializeLifetimeService"]/*' />
		public override Object InitializeLifetimeService()
		{
			return null;
		}

		/// <include file='doc\ClientSponsor.uex' path='docs/doc[@for="ClientSponsor.Finalize"]/*' />
        ~ClientSponsor()
		{
			BCLDebug.Trace("REMOTE","ClientSponsor Finalize");
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\channelservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//* File:    Channel.cs
//*
//* Author:  Tarun Anand (TarunA)
//*
//* Purpose: Defines the general purpose remoting proxy
//*
//* Date:    May 27, 1999
//*
namespace System.Runtime.Remoting.Channels {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;  
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;   
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata; 
    using System.Runtime.Remoting.Proxies;
    using System.Threading;
    using System.Security.Permissions;
    using System.Globalization;
 
    // ChannelServices
    
    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    internal struct Perf_Contexts {
        internal int cRemoteCalls;
        internal int cChannels;
    };
    
    /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices"]/*' />
    public sealed class ChannelServices
    {
        // This gets refreshed when a channel is registered/unregistered.
        private static Object[] s_currentChannelData = null;

        internal static Object[] CurrentChannelData
        {
            get 
            {
                if (s_currentChannelData == null)
                    RefreshChannelData();

                return s_currentChannelData; 
            }
        } // CurrentChannelData


        // hide the default constructor
        private ChannelServices()
        {
        }

        // list of registered channels and a lock to take when adding or removing channels
        private static Object s_channelLock = new Object();
        private static RegisteredChannelList s_registeredChannels = new RegisteredChannelList();
        
    
        // Private member variables        
        // These have all been converted to getters and setters to get the effect of
        // per-AppDomain statics (note: statics are per-AppDomain now, so these members
        // could just be declared as statics on ChannelServices).

        private static long remoteCalls
        { 
            get { return Thread.GetDomain().RemotingData.ChannelServicesData.remoteCalls; }
            set { Thread.GetDomain().RemotingData.ChannelServicesData.remoteCalls = value; }
        }
        
        private static IMessageSink xCtxChannel;
        

        [MethodImplAttribute(MethodImplOptions.InternalCall)]      
        static extern Perf_Contexts* GetPrivateContextsPerfCounters();
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]        
        static extern Perf_Contexts* GetGlobalContextsPerfCounters();
    
        unsafe private static Perf_Contexts *perf_Contexts = GetPrivateContextsPerfCounters(); 
        unsafe private static Perf_Contexts *perf_globalContexts = GetGlobalContextsPerfCounters(); 
    
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.RegisterChannel"]/*' />

        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterChannel(IChannel chnl)
        {
            RegisterChannelInternal(chnl);
        }

        unsafe internal static void RegisterChannelInternal(IChannel chnl)
        {
            // Validate arguments
            if(null == chnl)
            {
                throw new ArgumentNullException("chnl");
            }
        
            lock (s_channelLock)
            {
                String chnlName = chnl.ChannelName;

                RegisteredChannelList regChnlList = s_registeredChannels;
        
                // Check to make sure that the channel has not been registered
                if((chnlName == null) ||
                   (chnlName.Length == 0) ||
                   (-1 == regChnlList.FindChannelIndex(chnl.ChannelName)))
                {
                    RegisteredChannel[] oldList = regChnlList.RegisteredChannels;
                    RegisteredChannel[] newList = null;
                    if (oldList == null)
                    {                                            
                        newList = new RegisteredChannel[1];
                    }
                    else
                        newList = new RegisteredChannel[oldList.Length + 1];

                    if (newList.Length == 1)
                    {
                        // This is the first channel being registered.
                        //   (we know this since the x-appdmn channel can't be unregistered).
                        AppDomain.CurrentDomain.DomainUnload += new EventHandler(UnloadHandler);
                        
                        newList[0] = new RegisteredChannel(chnl);
                    }
                    else
                    {                                                    
                        // Add the interface to the array in priority order
                        int priority = chnl.ChannelPriority;
                        int current = 0;
        
                        // Find the place in the array to insert
                        while (current < oldList.Length)
                        {
                            RegisteredChannel oldChannel = oldList[current];
                            if (priority > oldChannel.Channel.ChannelPriority)
                            {
                                newList[current] = new RegisteredChannel(chnl);
                                break;
                            }
                            else
                            {
                                newList[current] = oldChannel;
                                current++;
                            }
                        }

                        if (current == oldList.Length)
                        {
                            // chnl has lower priority than all old channels, so we insert
                            //   it at the end of the list.
                            newList[oldList.Length] = new RegisteredChannel(chnl);
                        }
                        else
                        {
                            // finish copying rest of the old channels
                            while (current < oldList.Length)
                            {
                                newList[current + 1] = oldList[current];
                                current++;
                            }
                        }
                    }

                    if (perf_Contexts != null) {
                        perf_Contexts->cChannels++;
                    }
                    if (perf_globalContexts != null) {
                        perf_globalContexts->cChannels++;
                    }

                    s_registeredChannels = new RegisteredChannelList(newList);
                }
                else
                {
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_ChannelNameAlreadyRegistered"), chnl.ChannelName));
                }

                RefreshChannelData();
            } // lock (s_channelLock)
        } // RegisterChannelInternal
    
    
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.UnregisterChannel"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        unsafe public static void UnregisterChannel(IChannel chnl)
        {
            // we allow null to be passed in, so we can use this api to trigger the
            //   refresh of the channel data (in V.Next we will expose
            //   ChannelServices::RefreshChannelData as public).
            
            lock (s_channelLock)
            {
                if (chnl != null)
                {
                    RegisteredChannelList regChnlList = s_registeredChannels;
                
                    // Check to make sure that the channel has been registered
                    int matchingIdx = regChnlList.FindChannelIndex(chnl);
                    if(-1 == matchingIdx)
                    {
                        throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_ChannelNotRegistered"), chnl.ChannelName));
                    }

                    RegisteredChannel[] oldList = regChnlList.RegisteredChannels;
                    RegisteredChannel[] newList = null;
                    BCLDebug.Assert((oldList != null) && (oldList.Length != 0), "channel list should not be empty");

                    newList = new RegisteredChannel[oldList.Length - 1];

                    // Call stop listening on the channel if it is a receiver.
                    IChannelReceiver srvChannel = chnl as IChannelReceiver;
                    if (srvChannel != null)
                        srvChannel.StopListening(null);

                    int current = 0;
                    int oldPos = 0;
                    while (oldPos < oldList.Length)
                    {
                        if (oldPos == matchingIdx)
                        {
                            oldPos++;
                        }
                        else
                        {
                            newList[current] = oldList[oldPos];
                            current++;
                            oldPos++;
                        }
                    }
        
                    if (perf_Contexts != null) {
                        perf_Contexts->cChannels--;
                    }
                    if (perf_globalContexts != null) {
                        perf_globalContexts->cChannels--;
                    }

                    s_registeredChannels = new RegisteredChannelList(newList);
                } 

                RefreshChannelData();
            } // lock (s_channelLock)
        } // UnregisterChannel

    
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.RegisteredChannels"]/*' />
        public static IChannel[] RegisteredChannels
        {       
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get 
            {
                RegisteredChannelList regChnlList = s_registeredChannels;
                int count = regChnlList.Count;
            
                if (0 == count)
                {
                    return new IChannel[0];
                }
                else 
                {
                    // we hide the CrossAppDomainChannel, so the number of visible
                    //   channels is one less than the number of registered channels.
                    int visibleChannels = count - 1;

                    // Copy the array of visible channels into a new array
                    // and return
                    int co = 0;
                    IChannel[] temp = new IChannel[visibleChannels];
                    for (int i = 0; i < count; i++)
                    {
                        IChannel channel = regChnlList.GetChannel(i);
                        // add the channel to the array if it is not the CrossAppDomainChannel
                        if (!(channel is CrossAppDomainChannel))
                            temp[co++] = channel;
                    }
                    return temp;
                }
            }
        } // RegisteredChannels
        
        internal static IMessageSink CreateMessageSink(String url, Object data, out String objectURI) 
        {
            BCLDebug.Trace("REMOTE", "ChannelServices::CreateMessageSink for url " + url + "\n");
            IMessageSink msgSink = null;
            objectURI = null;

            RegisteredChannelList regChnlList = s_registeredChannels;
            int count = regChnlList.Count;
            
            for(int i = 0; i < count; i++)
            {
                if(regChnlList.IsSender(i))
                {
                    IChannelSender chnl = (IChannelSender)regChnlList.GetChannel(i);
                    msgSink = chnl.CreateMessageSink(url, data, out objectURI);
                    
                    if(msgSink != null)
                        break;
                }
            }
            
            // If the object uri has not been set, set it to the url as 
            // default value
            if(null == objectURI)
            {
                objectURI = url;
            }
            
            return msgSink;
        } // CreateMessageSink
    
        internal static IMessageSink CreateMessageSink(Object data)
        {
            String objectUri;
            return CreateMessageSink(null, data, out objectUri);
        } // CreateMessageSink
    
    
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.GetChannel"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static IChannel GetChannel(String name)
        {
            RegisteredChannelList regChnlList = s_registeredChannels;
        
            int matchingIdx = regChnlList.FindChannelIndex(name);
            if(0 <= matchingIdx)
            {
                return regChnlList.GetChannel(matchingIdx);
            }
            else
            {
                return null;
            }
        } // GetChannel
        
        
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.GetUrlsForObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static String[] GetUrlsForObject(MarshalByRefObject obj)
        {        
            if(null == obj)
            {
                return null;
            }

            RegisteredChannelList regChnlList = s_registeredChannels;
            int count = regChnlList.Count;
            
            Hashtable table = new Hashtable();
            bool fServer;
            Identity id = MarshalByRefObject.GetIdentity(obj, out fServer);

            if(null != id) 
            {
                String uri = id.ObjURI;

                if (null != uri)
                {
                    for(int i = 0; i < count; i++)
                    {
                        if(regChnlList.IsReceiver(i))
                        {
                            try
                            {
                                String[] urls = ((IChannelReceiver)regChnlList.GetChannel(i)).GetUrlsForUri(uri);
                                // Add the strings to the table
                                for(int j = 0; j < urls.Length; j++)
                                {
                                    table.Add(urls[j], urls[j]);
                                }
                            }
                            catch(NotSupportedException )
                            {
                                // We do not count the channels that do not 
                                // support this method
                            }
                        }
                    }
                }
            }            

            // copy url's into string array
            ICollection keys = table.Keys;
            String[] urlList = new String[keys.Count];
            int co = 0;
            foreach (String key in keys)
            {
                urlList[co++] = key;
            }
            return urlList;
        }

       // Find the channel message sink associated with a given proxy
        // FUTURE: In v1.x or v2, we should expose this as public.
        internal static IMessageSink GetChannelSinkForProxy(Object obj)
        {
            IMessageSink sink = null;
            if (RemotingServices.IsTransparentProxy(obj))
            {
                RealProxy rp = RemotingServices.GetRealProxy(obj);
                RemotingProxy remProxy = rp as RemotingProxy;
                if (null != remProxy)
                {
                    Identity idObj = remProxy.IdentityObject;
                    BCLDebug.Assert(null != idObj,"null != idObj");
                    sink = idObj.ChannelSink;
                    BCLDebug.Assert(null != sink,"null != sink");
                }
            }

            return sink;
        } // GetChannelSinkForProxy
        

        //  Get the message sink dictionary of properties for a given proxy
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.GetChannelSinkProperties"]/*' />

        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static IDictionary GetChannelSinkProperties(Object obj)
        {
            IMessageSink sink = GetChannelSinkForProxy(obj);
            IClientChannelSink chnlSink = sink as IClientChannelSink;
            if (null != chnlSink)
            {
                // collect dictionaries for all channel sinks and return
                //   aggregate dictionary
                ArrayList dictionaries = new ArrayList();

                do                
                { 
                    IDictionary dict = chnlSink.Properties;
                    if (dict != null)
                        dictionaries.Add(dict);
                
                    chnlSink = chnlSink.NextChannelSink;
                } while (chnlSink != null);
                
                return new AggregateDictionary(dictionaries);
            }
            else
            {
                IDictionary dict = sink as IDictionary;
                if(null != dict)    
                {
                    return dict;
                }
                else
                {
                    return null;
                }
            }
        } // GetChannelSinkProperties

    
        internal static IMessageSink GetCrossContextChannelSink()
        {
            if(null == xCtxChannel)
            {
                xCtxChannel = CrossContextChannel.MessageSink;
            }
    
            return xCtxChannel;
        } // GetCrossContextChannelSink
               
    
        // A few methods to count the number of calls made across appdomains,
        // processes and machines
        internal static long GetNumberOfRemoteCalls()
        {
            return remoteCalls;
        } // GetNumberOfRemoteCalls
    
        unsafe internal static void IncrementRemoteCalls(long cCalls)
        {
            remoteCalls += cCalls;
            if (perf_Contexts != null)
              perf_Contexts->cRemoteCalls += (int)cCalls;
            if (perf_globalContexts != null)
              perf_globalContexts->cRemoteCalls += (int)cCalls;
        } // IncrementRemoteCalls
        
        internal static void IncrementRemoteCalls()
        {
            IncrementRemoteCalls( 1 );
        } // IncrementRemoteCalls


        internal static void RefreshChannelData()
        {
            lock (s_channelLock)
            {
                s_currentChannelData = CollectChannelDataFromChannels();
            }
        } // RefreshChannelData

        private static Object[] CollectChannelDataFromChannels()
        {
            // Ensure that our native cross-context & cross-domain channels
            // are registered
            RemotingServices.RegisterWellKnownChannels();

            RegisteredChannelList regChnlList = s_registeredChannels;
            int count = regChnlList.Count;            

            // Compute the number of channels that implement IChannelReceiver
            int numChnls = regChnlList.ReceiverCount;

            // Allocate array for channel data
            Object[] data = new Object[numChnls];

            // we need to remove null entries
            int nonNullDataCount = 0;                        

            // Set the channel data, names and mime types
            for (int i = 0, j = 0; i < count; i++)
            {

                IChannel chnl = regChnlList.GetChannel(i);

                if (null == chnl)
                {
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_ChannelNotRegistered"), ""));
                }

                if (regChnlList.IsReceiver(i))
                {
                    BCLDebug.Trace("REMOTE", "Setting info for receiver " + j + "\n");
                    // Extract the data
                    Object channelData = ((IChannelReceiver)chnl).ChannelData;                    
                    data[j] = channelData;
                    if (channelData != null)
                        nonNullDataCount++;

                    // Increment the counter
                    j++;
                }
            }

            if (nonNullDataCount != numChnls)
            {
                // there were null entries, so remove them.
                Object[] nonNullData = new Object[nonNullDataCount];
                int nonNullCounter = 0;
                for (int co = 0; co < numChnls; co++)
                {
                    Object channelData = data[co];
                    if (channelData != null)
                        nonNullData[nonNullCounter++] = channelData;
                }

                data = nonNullData;
            }
            
            return data;
        } // CollectChannelDataFromChannels

        //--------------------------------------------------------------------
        //-----------------------  Dispatch Support   ------------------------
        //--------------------------------------------------------------------

        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.DispatchMessage"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static ServerProcessing DispatchMessage(
            IServerChannelSinkStack sinkStack,
            IMessage msg, 
            out IMessage replyMsg)
        {
            ServerProcessing processing = ServerProcessing.Complete;
            replyMsg = null;
            
            try
            {            
                if(null == msg)
                {
                    throw new ArgumentNullException("msg");
                }

                BCLDebug.Trace("REMOTE", "Dispatching for URI " + InternalSink.GetURI(msg));

                // we must switch to the target context of the object and call the context chains etc...
                // Currenly XContextChannel does exactly so. So this method is just a wrapper..
    
                // FUTURE: This dispatches MarshalByRef objects in the default context
                // Ideally, MarshalByRef objects should be dispatched in any context.
                
                // Make sure that incoming calls are counted as a remote call. This way it 
                // makes more sense on a server.
                IncrementRemoteCalls();
        
                // Check if the object has been disconnected or if it is 
                // a well known object then we have to create it lazily.
                ServerIdentity srvId = CheckDisconnectedOrCreateWellKnownObject(msg);

                // Make sure that this isn't an AppDomain object since we don't allow
                //   calls to the AppDomain from out of process (and x-process calls
                //   are always dispatched through this method)
                if (srvId.ServerType == typeof(System.AppDomain))
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_AppDomainsCantBeCalledRemotely"));
                }
                

                IMethodCallMessage mcm = msg as IMethodCallMessage;

                if (mcm == null)
                {
                    // It's a plain IMessage, so just check to make sure that the
                    //   target object implements IMessageSink and dispatch synchronously.

                    if (!typeof(IMessageSink).IsAssignableFrom(srvId.ServerType))
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_AppDomainsCantBeCalledRemotely"));
                    }

                    processing = ServerProcessing.Complete;
                    replyMsg = ChannelServices.GetCrossContextChannelSink().SyncProcessMessage(msg);
                }
                else
                {
                    // It's an IMethodCallMessage.
                
                    // Check if the method is one way. Dispatch one way calls in 
                    // an asynchronous manner
                    MethodInfo method = (MethodInfo)mcm.MethodBase;                                  
    
                    // X-process / X-machine calls should be to non-static
                    // public methods only! Non-public or static methods can't
                    // be called remotely.
                    if ((!method.IsPublic || method.IsStatic) && 
                          !RemotingServices.IsMethodAllowedRemotely(method))
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_NonPublicOrStaticCantBeCalledRemotely"));
                    }

                    RemotingMethodCachedData cache = (RemotingMethodCachedData)
                        InternalRemotingServices.GetReflectionCachedData(method);
                
                    /*
                        FUTURE:
                        Dispatching asynchronously was cut from v1. We should reactivate
                        the following code in v1.x or v2.
                    
                    // look for async method version               
                    MethodInfo begin;
                    MethodInfo end;
                    ServerChannelSinkStack serverSinkStack = sinkStack as ServerChannelSinkStack;
                    if ((sinkStack != null) &&
                        cache.GetAsyncMethodVersion(out begin, out end))
                    {
                        processing = ServerProcessing.Async;
                        IMessage asyncMsg = 
                            new AsyncMethodCallMessageWrapper(
                                (IMethodCallMessage)msg,
                                begin,
                                new AsyncCallback(sinkStack.ServerCallback), 
                                null);
                        serverSinkStack.AsyncMessage = asyncMsg;            
                        serverSinkStack.AsyncEnd = end;
                        serverSinkStack.Message = (IMethodCallMessage)msg;
                        asyncMsg.Properties["__SinkStack"] = sinkStack;
    
                        // We don't dispatch yet. That happens when the server transport sink
                        //   eventually calls sinkStack.StoreAndDispatch(...).
                    }
                    else
                    */
                    if(RemotingServices.IsOneWay(method))                    
                    {
                        processing = ServerProcessing.OneWay;
                        ChannelServices.GetCrossContextChannelSink().AsyncProcessMessage(msg, null);
                    }
                    else
                    {                    
                        // regular processing
                        processing = ServerProcessing.Complete;
                        replyMsg = ChannelServices.GetCrossContextChannelSink().SyncProcessMessage(msg);
                    }
                } // end of case for IMethodCallMessage
            }
            catch(Exception e)
            {
                if(processing != ServerProcessing.OneWay)
                {
                    try
                    {                    
                        IMethodCallMessage mcm = 
                            (IMethodCallMessage) ((msg!=null)?msg:new ErrorMessage());
                        replyMsg = (IMessage)new ReturnMessage(e, mcm);
                        if (msg != null)
                        {
                            ((ReturnMessage)replyMsg).SetLogicalCallContext(
                                    (LogicalCallContext)
                                        msg.Properties[Message.CallContextKey]);
                        }
                    }
                    catch(Exception )
                    {
                        // Fatal exception .. ignore
                    }
                }
            }               

            return processing;
        } // DispatchMessage
        
       // This method is used by the channel to dispatch the incoming messages
       // to the server side chain(s) based on the URI embedded in the message.
       // The URI uniquely identifies the receiving object.
       // 
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.SyncDispatchMessage"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static IMessage SyncDispatchMessage(IMessage msg)
        {            
            IMessage msgRet = null;
            bool fIsOneWay = false;
            
            try
            {            
                if(null == msg)
                {
                    throw new ArgumentNullException("msg");
                }



                // For ContextBoundObject's,
                // we must switch to the target context of the object and call the context chains etc...
                // Currenly XContextChannel does exactly so. So this method is just a wrapper..
    
                
                // Make sure that incoming calls are counted as a remote call. This way it 
                // makes more sense on a server.
                IncrementRemoteCalls();

                // FUTURE: transitionCall needs to implement IMethodMessage ..
                if (!(msg is TransitionCall))
                {
                    // Check if the object has been disconnected or if it is 
                    // a well known object then we have to create it lazily.
                    CheckDisconnectedOrCreateWellKnownObject(msg);

                    MethodBase method = ((IMethodMessage)msg).MethodBase;

                    // Check if the method is one way. Dispatch one way calls in 
                    // an asynchronous manner                    
                    fIsOneWay = RemotingServices.IsOneWay(method);
                }

                // FUTURE: for MBR objects we could skip the x-ctx channel sink
                IMessageSink nextSink = ChannelServices.GetCrossContextChannelSink();
                
                if(!fIsOneWay)
                {                    
                    msgRet = nextSink.SyncProcessMessage(msg);  
                }
                else
                {
                    nextSink.AsyncProcessMessage(msg, null);
                }
            }
            catch(Exception e)
            {
                if(!fIsOneWay)
                {
                    try
                    {                    
                        IMethodCallMessage mcm = 
                            (IMethodCallMessage) ((msg!=null)?msg:new ErrorMessage());
                        msgRet = (IMessage)new ReturnMessage(e, mcm);
                        if (msg!=null)
                        {
                            ((ReturnMessage)msgRet).SetLogicalCallContext(
                                mcm.LogicalCallContext);
                        }
                    }
                    catch(Exception )
                    {
                        // Fatal exception .. ignore
                    }
                }
            }               

            return msgRet;
        }

       // This method is used by the channel to dispatch the incoming messages
       // to the server side chain(s) based on the URI embedded in the message.
       // The URI uniquely identifies the receiving object.
       // 
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.AsyncDispatchMessage"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink)
        {
            IMessageCtrl ctrl = null;

            try
            {
                if(null == msg)
                {
                    throw new ArgumentNullException("msg");
                }
            
                // we must switch to the target context of the object and call the context chains etc...
                // Currenly XContextChannel does exactly so. So this method is just a wrapper..
    
                // Make sure that incoming calls are counted as a remote call. This way it 
                // makes more sense on a server.
                IncrementRemoteCalls();
                
                if (!(msg is TransitionCall))
                {
                    // Check if the object has been disconnected or if it is 
                    // a well known object then we have to create it lazily.
                    CheckDisconnectedOrCreateWellKnownObject(msg);    
                }
    
                // FUTURE: This dispatches MarshalByRef objects in the default context
                // Ideally, MarshalByRef objects should be dispatched in any context.
                ctrl = ChannelServices.GetCrossContextChannelSink().AsyncProcessMessage(msg, replySink);
            }
            catch(Exception e)
            {
                if(null != replySink)
                {
                    try
                    {
                        IMethodCallMessage mcm = (IMethodCallMessage)msg;
                        ReturnMessage retMsg = new ReturnMessage(e, (IMethodCallMessage)msg);
                        if (msg!=null)
                        {
                            retMsg.SetLogicalCallContext(mcm.LogicalCallContext);
                        }
                        replySink.SyncProcessMessage(retMsg);
                    }
                    catch(Exception )
                    {
                        // Fatal exception... ignore
                    }                    
                }
            }

            return ctrl;
        } // AsyncDispatchMessage


        // Creates a channel sink chain (adds special dispatch sink to the end of the chain)
        /// <include file='doc\ChannelServices.uex' path='docs/doc[@for="ChannelServices.CreateServerChannelSinkChain"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static IServerChannelSink CreateServerChannelSinkChain(
            IServerChannelSinkProvider provider, IChannelReceiver channel)
        {
            if (provider == null)
                return new DispatchChannelSink();       
            
            // add dispatch provider to end (first find last provider)
            IServerChannelSinkProvider lastProvider = provider;
            while (lastProvider.Next != null)
                lastProvider = lastProvider.Next;
            lastProvider.Next = new DispatchChannelSinkProvider();

            IServerChannelSink sinkChain = provider.CreateSink(channel);

            // remove dispatch provider from end
            lastProvider.Next = null;            

            return sinkChain;
        } // CreateServerChannelSinkChain
        
        

        // Check if the object has been disconnected or if it is 
        // a well known object then we have to create it lazily.
        internal static ServerIdentity CheckDisconnectedOrCreateWellKnownObject(IMessage msg)
        {
            ServerIdentity ident = InternalSink.GetServerIdentity(msg);
            
            BCLDebug.Trace("REMOTE", "Identity found = " + (ident == null ? "null" : "ServerIdentity"));

            // If the identity is null, then we should check whether the 
            // request if for a well known object. If yes, then we should 
            // create the well known object lazily and marshal it.
            if ((ident == null) || ident.IsRemoteDisconnected())
            {
                String uri = InternalSink.GetURI(msg);
                BCLDebug.Trace("REMOTE", "URI " + uri);
                if (uri != null)
                {
                    ServerIdentity newIdent = RemotingConfigHandler.CreateWellKnownObject(uri);
                    if (newIdent != null)
                    {
                        // The uri was a registered wellknown object.
                        ident = newIdent;
                        BCLDebug.Trace("REMOTE", "Identity created = " + (ident == null ? "null" : "ServerIdentity"));
                    }
                }  

            }


            if ((ident == null) || (ident.IsRemoteDisconnected()))
            {
                String uri = InternalSink.GetURI(msg);
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Disconnected"),uri));                
            }
            return ident;
        }
        
        // Channel Services AppDomain Unload Event Handler
        internal static void UnloadHandler(Object sender, EventArgs e)
        {
            StopListeningOnAllChannels();
        }

        private static void StopListeningOnAllChannels()
        {
            try
            {
                RegisteredChannelList regChnlList = s_registeredChannels;
                int count = regChnlList.Count;    
            
                for(int i = 0; i < count; i++)
                {
                    if(regChnlList.IsReceiver(i))
                    {
                        IChannelReceiver chnl = (IChannelReceiver)regChnlList.GetChannel(i);
                        chnl.StopListening(null);
                    }
                }
            }
            catch (Exception)
            {
                // Ignore ... appdomain is shutting down..
            }
        }




        //
        // INTERNAL PROFILER NOTIFICATION SERVICES
        //

        internal static void NotifyProfiler(IMessage msg, RemotingProfilerEvent profilerEvent)
        {
            switch (profilerEvent)
            {
            
            case RemotingProfilerEvent.ClientSend:
            {
                if (RemotingServices.CORProfilerTrackRemoting())
                {
                    Guid g;

                    RemotingServices.CORProfilerRemotingClientSendingMessage(out g, false);

                    if (RemotingServices.CORProfilerTrackRemotingCookie())
                        msg.Properties["CORProfilerCookie"] = g;
                }
                break;
            } // case RemotingProfilerEvent.ClientSend

            case RemotingProfilerEvent.ClientReceive:
            {
                if (RemotingServices.CORProfilerTrackRemoting())
                {
                    Guid g = Guid.Empty;

                    if (RemotingServices.CORProfilerTrackRemotingCookie())
                    {
                        Object obj = msg.Properties["CORProfilerCookie"];

                        if (obj != null)
                        {
                            g = (Guid) obj;
                        }
                    }

                    RemotingServices.CORProfilerRemotingClientReceivingReply(g, false);
                }
                break;
            } // case RemotingProfilerEvent.ClientReceive
            
            } // switch (event)
        } // NotifyProfiler        



        // This is a helper used by UrlObjRef's.
        // Finds an http channel and returns first url for this object.
        internal static String FindFirstHttpUrlForObject(String objectUri)
        {                    
            if (objectUri == null)
                return null;       

            RegisteredChannelList regChnlList = s_registeredChannels;
            int count = regChnlList.Count;    

            for (int i = 0; i < count; i++)
            {
                if(regChnlList.IsReceiver(i))
                {       
                    IChannelReceiver chnl = (IChannelReceiver)regChnlList.GetChannel(i);
                    String chnlType = chnl.GetType().FullName;
                    if ((String.CompareOrdinal(chnlType, "System.Runtime.Remoting.Channels.Http.HttpChannel") == 0) ||
                        (String.CompareOrdinal(chnlType, "System.Runtime.Remoting.Channels.Http.HttpServerChannel") == 0))
                    {                                            
                        String[] urls = chnl.GetUrlsForUri(objectUri);
                        if ((urls != null) && (urls.Length > 0))
                            return urls[0];
                    }
                }                               
            }      

            return null;
        } // FindFirstHttpUrlForObject


        //
        // DEBUG Helpers
        //   Note: These methods should be included even in retail builds so that 
        //     they can be called from the debugger.
        //

        internal static void DumpRegisteredChannels()
        {
            // To use from cordbg: 
            //   f System.Runtime.Remoting.Channels.ChannelServices::DumpRegisteredChannels

            RegisteredChannelList regChnlList = s_registeredChannels;
            int count = regChnlList.Count; 
        
            Console.Error.WriteLine("Registered Channels:");            
        
            for (int i = 0; i < count; i++)
            {
                IChannel chnl = regChnlList.GetChannel(i);
                Console.Error.WriteLine(chnl);
            }
        } // DumpRegisteredChannels


    } // class ChannelServices


    // used by ChannelServices.NotifyProfiler
	[Serializable]
    internal enum RemotingProfilerEvent
    {
        ClientSend,
        ClientReceive
    } // RemotingProfilerEvent

    
    
    
    internal class RegisteredChannel
    {
        // private member variables
        private IChannel channel;
        private byte flags;
        private static byte SENDER      = 0x1;
        private static byte RECEIVER    = 0x2;
    
        internal RegisteredChannel(IChannel chnl)
        {
            channel = chnl;
            flags = 0;
            if(chnl is IChannelSender)
            {
                flags |= SENDER;
            }
            if(chnl is IChannelReceiver)
            {
                flags |= RECEIVER;
            }
        }
    
        internal virtual IChannel Channel
        {
            get { return channel; }
        }
    
        internal virtual bool IsSender()
        {
            return ((flags & SENDER) != 0);
        }
    
        internal virtual bool IsReceiver()
        {
            return ((flags & RECEIVER) != 0);
        }
    }// class RegisteredChannel



    // This list should be considered immutable once created.
    //   Ideally, this class would encapsulate more functionality, but
    //   to help minimize the number of changes in the RTM tree, only
    //   a small amount of code has been moved here.
    internal class RegisteredChannelList
    {
        private RegisteredChannel[] _channels;

        internal RegisteredChannelList()
        {
            _channels = new RegisteredChannel[0];
        } // RegisteredChannelList

        internal RegisteredChannelList(RegisteredChannel[] channels)
        {
            _channels = channels;
        } // RegisteredChannelList

        internal RegisteredChannel[] RegisteredChannels
        {
            get { return _channels; }
        } // RegisteredChannels

        internal int Count
        {
            get 
            {
                if (_channels == null)
                    return 0;

                return _channels.Length;
            }
        } // Count

        internal IChannel GetChannel(int index)
        {                
            return _channels[index].Channel;
        } // GetChannel

        internal bool IsSender(int index)
        {
            return _channels[index].IsSender();
        } // IsSender

        internal bool IsReceiver(int index)
        {
            return _channels[index].IsReceiver();
        } // IsReceiver        

        internal int ReceiverCount
        {
            get 
            {
                if (_channels == null)
                    return 0;
                
                int total = 0;
                for (int i = 0; i < _channels.Length; i++)
                {
                    if (IsReceiver(i))
                        total++;
                }
                
                return total;
            }
        } // ReceiverCount
    
        internal int SenderCount
        {
            get 
            {
                if (_channels == null)
                    return 0;
                
                int total = 0;
                for (int i = 0; i < _channels.Length; i++)
                {
                    if (IsSender(i))
                        total++;
                }

                return total;
            }
        } // SenderCount
        

        internal int FindChannelIndex(IChannel channel)
        {
            Object chnlAsObject = (Object)channel;
        
            for (int i = 0; i < _channels.Length; i++)
            {
                if (chnlAsObject == (Object)GetChannel(i))
                    return i;                    
            }

            return -1;
        } // FindChannelIndex

        internal int FindChannelIndex(String name)
        {        
            for (int i = 0; i < _channels.Length; i++)
            {
                if(String.Compare(name, GetChannel(i).ChannelName, true, CultureInfo.InvariantCulture) == 0)
                    return i;                
            }

            return -1;
        } // FindChannelIndex
        
        
    } // class RegisteredChannelList
    



    internal class ChannelServicesData
    {        
        internal long remoteCalls = 0;
        internal CrossContextChannel xctxmessageSink = null;
        internal CrossAppDomainChannel xadmessageSink = null;
        internal bool fRegisterWellKnownChannels = false;
    }

   //
   // Terminator sink used for profiling so that we can intercept asynchronous
   // replies on the server side.
   //  
    
    /* package scope */
    internal class ServerAsyncReplyTerminatorSink : IMessageSink
    {
        internal IMessageSink _nextSink;

        internal ServerAsyncReplyTerminatorSink(IMessageSink nextSink)
        {
            BCLDebug.Assert(nextSink != null,
                            "null IMessageSink passed to ServerAsyncReplyTerminatorSink ctor.");
            _nextSink = nextSink;
        }

        public virtual IMessage SyncProcessMessage(IMessage replyMsg)
        {
            // If this class has been brought into the picture, then the following must be true.
            BCLDebug.Assert(RemotingServices.CORProfilerTrackRemoting(),
                            "CORProfilerTrackRemoting returned false, but we're in AsyncProcessMessage!");
            BCLDebug.Assert(RemotingServices.CORProfilerTrackRemotingAsync(),
                            "CORProfilerTrackRemoting returned false, but we're in AsyncProcessMessage!");

            Guid g;

            // Notify the profiler that we are receiving an async reply from the server-side
            RemotingServices.CORProfilerRemotingServerSendingReply(out g, true);

            // If GUID cookies are active, then we save it for the other end of the channel
            if (RemotingServices.CORProfilerTrackRemotingCookie())
                replyMsg.Properties["CORProfilerCookie"] = g;

            // Now that we've done the intercepting, pass the message on to the regular chain
            return _nextSink.SyncProcessMessage(replyMsg);
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage replyMsg, IMessageSink replySink)
        {
            // Since this class is only used for intercepting async replies, this function should
            // never get called. (Async replies are synchronous, ironically)
            BCLDebug.Assert(false, "ServerAsyncReplyTerminatorSink.AsyncProcessMessage called!");

            return null;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }
        }

        // Do I need a finalize here?
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\activationservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**  File:    ActivationServices.cool
**
**  Author(s):  
**              Tarun Anand     (TarunA)
**              Manish Prabhu   (MPrabhu)
**
**  Purpose:           
**
**  Date:    Jun 26, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Activation {

    using System;
    using System.Security;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Collections;
    using System.Reflection;
    using System.IO;
    using System.Runtime.Serialization;    
    using IList       = System.Collections.IList;
    using ArrayList  = System.Collections.ArrayList;
    using IEnumerator = System.Collections.IEnumerator;
    using System.Security.Permissions;

    // Implements various activation services
    internal sealed class ActivationServices
    {

        private static IActivator activator = null;     
        
        private static Hashtable _proxyTable = new Hashtable();
        private static Type proxyAttributeType = typeof(System.Runtime.Remoting.Proxies.ProxyAttribute); 
        private static ProxyAttribute _proxyAttribute = new ProxyAttribute();
        [ThreadStaticAttribute()]
        internal static ActivationAttributeStack _attributeStack;       

        internal const String ActivationServiceURI = "RemoteActivationService.rem";

        internal const String RemoteActivateKey = "Remote";
        internal const String PermissionKey = "Permission";
        internal const String ConnectKey = "Connect";

        // FUTURE: Moved all these statics to DomainSpecificRemotingData
        // class. We should move them back here when static become per-domain.
        // LocalActivator does the actual activation work. It also
        // acts as the global context attribute which is queried during
        // every activation.

        //1 private static LocalActivator  localActivator = null;

        // ActivationListener is the object that listens to incoming
        // activation requests. It delegates the incoming request to 
        // the local activator.
        //2 private static ActivationListener ActivationListener = null;

        //3 private static Object staticSyncObject = new Object();
        //4 private static bool bInitializing = false;

        // This gets called upon the first attempt to activate
        // anything that is ContextBound or MarshalByRef
        private static void Startup()
        {            
            DomainSpecificRemotingData remData = Thread.GetDomain().RemotingData;

            // wait on the lock if a)activation has not been initialized yet
            // or b) activation is being initialized by another thread!
            if ((!remData.ActivationInitialized) 
               || remData.InitializingActivation)
            {
                lock(remData.ConfigLock)
                {
                    remData.InitializingActivation = true;
                    // Ensure that some other thread did not complete
                    // the work while we were waiting on the lock.
                    if (!remData.ActivationInitialized)
                    {
                        // Startup the activation service
                        BCLDebug.Trace("REMOTE","Starting up activation service ",Thread.CurrentContext);

                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // NOTE: This should be the first step in Startup!
                        // Otherwise activation will recurse, when we try
                        // to create the ActivationListener (which is MarshalByRef)
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        remData.LocalActivator = new LocalActivator();

                        // Add the Lifetime service property to the appdomain.
                        // For now we are assuming that this is the only property
                        // If there are more properties, then an existing array
                        // will need to be expanded to add this property

                        // This is activated in RemotingServices.DomainSpecificRemotingData()
                        // IContextProperty[] contextProperties = new IContextProperty[1];
                        // contextProperties[0] = new System.Runtime.Remoting.LeaseLifeTimeServiceProperty();
                        // Thread.GetDomain().RemotingData.AppDomainContextProperties = contextProperties;

                        remData.ActivationListener = new ActivationListener();
                        remData.ActivationInitialized = true;

                    }
                    
                    remData.InitializingActivation = false;
                } //lock (remData)
            }
        }            
           
        private static void InitActivationServices()
        {
            // If activation services has not been loaded do it now and create 
            // the instace that will service the activation requests.
            if (null == activator)
            {
                activator = GetActivator();
                if (null == activator)
                {
                    Message.DebugOut("Fatal Error... Could not create activator\n");                
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_BadInternalState"), 
                            "Activation service failed to initialize"));
                }
            }
        }

        // Determine whether the current context is ok for the activation.  
        private static MarshalByRefObject IsCurrentContextOK(
            Type serverType, Object[] props, bool bNewObj)
        {
            BCLDebug.Assert(!serverType.IsInterface,"!serverType.IsInterface");

            MarshalByRefObject retObj = null;
            
            // Initialize activation services if needed.
            //   (we temporary null out the activation attributes in case
            //    InitActivationServices creates an MBR).
            InitActivationServices();
            
            // Obtain the method info which will create an instance 
            // of type RealProxy
            ProxyAttribute pa = GetProxyAttribute(serverType);
            BCLDebug.Assert(null != pa, "null != pa");

            if (Object.ReferenceEquals(pa, DefaultProxyAttribute))
                retObj = pa.CreateInstanceInternal(serverType);
            else
            {
                retObj = pa.CreateInstance(serverType);
                // We called a custom proxy attribute .. make sure it is 
                // returning a server of the correct type.
                if (retObj != null)
                {
                    // If a transparent proxy is returned we are fine.
                    // If not then the object's type MUST be compatible
                    // with the type we were requested to activate!
                    if (!RemotingServices.IsTransparentProxy(retObj) 
                        && !serverType.IsAssignableFrom(retObj.GetType()))
                    {
                        throw new RemotingException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Remoting_Activation_BadObject"),
                            serverType));
                    }
                }
            }
            BCLDebug.Assert(null != retObj, "null != retObj");
            return retObj;
        }

        private static MarshalByRefObject CreateObjectForCom(
            Type serverType, Object[] props, bool bNewObj)
        {
            BCLDebug.Assert(!serverType.IsInterface,"!serverType.IsInterface");

            MarshalByRefObject retObj = null;
            
            if (PeekActivationAttributes(serverType) != null)
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ActivForCom" ));

            // Initialize activation services if needed
            InitActivationServices();
                                               
            // Obtain the method info which will create an instance 
            // of type RealProxy
            ProxyAttribute pa = GetProxyAttribute(serverType);
            BCLDebug.Assert(null != pa, "null != pa");

            if(pa is ICustomFactory)
            {
                retObj = ((ICustomFactory)pa).CreateInstance(serverType);
            }
            else
            {
                retObj = (MarshalByRefObject)Activator.CreateInstance(serverType, true);
            }

            BCLDebug.Assert(null != retObj, "null != retObj");
            return retObj;
        }

        // For types with no proxy attribute, we take the default route of 
        // querying attributes if the current context is suitable for 
        // activation.
        private static bool IsCurrentContextOK(Type serverType, Object[] props, 
                                               ref ConstructorCallMessage ctorCallMsg)
        {
            //Get callSite attributes
            Object[] callSiteAttr = PeekActivationAttributes(serverType);

            // Clear from the attribute stack
            if (callSiteAttr != null)
            {
                PopActivationAttributes(serverType);
            }
            
            Object[] womAttr = new Object[1];
            womAttr[0] = GetGlobalAttribute();

            // Get the type context attributes
            Object[] typeAttr = GetContextAttributesForType(serverType);

            // Get the client context (current context)                                                             
            Context cliCtx = Thread.CurrentContext;

            // Create a ctorCallMsg with the reqd info 
            ctorCallMsg = 
                new ConstructorCallMessage(
                    callSiteAttr,
                    womAttr,
                    typeAttr,
                    serverType);

            // This is the activator that handles activation in *all* cases 
            // Based on whether what the activation attributes do.... other
            // activators may get chained ahead of this one and may take
            // over the activation process... (possibly) delegating to this
            // only in the last stage.
            // Note: currently, this does not get used in the same context (MBR)
            // scenarios ... because of the 2-step activation model of JIT.
            ctorCallMsg.Activator = new ConstructionLevelActivator();


            // Ask all attributes if they are happy with the current context
            // NOTE: if someone says no, we do not ask the rest of the attributes
            // This is why, womAttr (which is the global activation service
            // attribute) *must* be the first one we query.
            bool bCtxOK = QueryAttributesIfContextOK(cliCtx, 
                                                     ctorCallMsg,
                                                     womAttr);
            if (bCtxOK == true)
            {
                bCtxOK = QueryAttributesIfContextOK(cliCtx, 
                                                    ctorCallMsg,
                                                    callSiteAttr);
                if (bCtxOK == true)
                {
                    bCtxOK = QueryAttributesIfContextOK(cliCtx, 
                                                        ctorCallMsg,
                                                        typeAttr);
                }
            }

            return bCtxOK;
        }

    private static void CheckForInfrastructurePermission(Assembly asm)
    {
        // Make a security check to ensure that the context attribute
        // is from a trusted assembly!
        if (asm != RemotingServices.s_MscorlibAssembly)
        {
            CodeAccessSecurityEngine.CheckAssembly(
                asm, 
                RemotingServices.s_RemotingInfrastructurePermission);
        }
    }

        private static bool QueryAttributesIfContextOK(
            Context ctx, IConstructionCallMessage ctorMsg, Object[] attributes) 
        {       
            bool bCtxOK = true;
            if (attributes != null)
            {
                for (int i=0; i<attributes.Length; i++)
                {
                    // All the attributes, including callsite attributes should 
                    // expose IContextAttribute. If not, then we throw an 
                    // exception.
                    IContextAttribute attr = attributes[i] as IContextAttribute;
                    if(null != attr)
                    { 
                        Assembly asm = attr.GetType().Assembly; 
                        // Make a security check to ensure that the context attribute
                        // is from a trusted assembly!
                        CheckForInfrastructurePermission(asm);
                    
                        bCtxOK = attr.IsContextOK(ctx, ctorMsg);
                        if (bCtxOK == false)
                        {
                            break;
                        }
                    }                        
                    else
                    {
                        throw new RemotingException(
                                Environment.GetResourceString(
                                    "Remoting_Activation_BadAttribute"));
                    }
                }
            }
            return bCtxOK;
        }

        internal static void GetPropertiesFromAttributes(
            IConstructionCallMessage ctorMsg, Object[] attributes)
        {
            if (attributes != null)
            {
                for (int i=0; i<attributes.Length; i++)
                {
                    // All the attributes, including callsite attributes should 
                    // expose IContextAttribute. If not, then we throw an 
                    // exception.
                    IContextAttribute attr = attributes[i] as IContextAttribute;
                    if(null != attr) 
                    {         
                        Assembly asm = attr.GetType().Assembly; 
                        // Make a security check to ensure that the context attribute
                        // is from a trusted assembly!
                        CheckForInfrastructurePermission(asm);
                    
                        // We ask each attribute to contribute its properties.
                        // The attributes can examine the current list of properties
                        // from the ctorCallMsg and decide which properties to add.

                        // They can also tweak the Activator chain during this process
                        attr.GetPropertiesForNewContext(ctorMsg);
                    }
                    else
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Activation_BadAttribute"));
                    }
                }
            }
        }

        // Return the default implementation of the proxy attribute
        internal static ProxyAttribute DefaultProxyAttribute
        {
            get { return _proxyAttribute; }
        }

        // Iterate over the custom attributes of the class and see if it 
        // defines a ProxyAttribute. If one is not defined then return
        // the default proxy attribute defined by us.
        internal static ProxyAttribute GetProxyAttribute(Type serverType)
        {
            
            BCLDebug.Assert(    
                serverType.IsMarshalByRef,
                "type should be at least marshal-by-ref");

            if (!serverType.HasProxyAttribute)
                return DefaultProxyAttribute;
                    
            // Type has a non-default proxy attribute ... see if we have
            // it cached?
            ProxyAttribute pa = _proxyTable[serverType] as ProxyAttribute;

            if (pa == null)
            {   
                Object[] ca = Attribute.GetCustomAttributes(
                                            serverType, 
                                            proxyAttributeType, 
                                            true);
                if((null != ca) && (0 != ca.Length))
                {                    
                    if (!serverType.IsContextful)
                    {
                        throw new RemotingException(
                                    Environment.GetResourceString(
                                    "Remoting_Activation_MBR_ProxyAttribute"));
                    }
                    pa = ca[0] as ProxyAttribute;
                }
                BCLDebug.Assert(pa!=null, "expect proxy attribute");

                if(!_proxyTable.Contains(serverType))
                {
                    lock(_proxyTable)
                    {
                        if(!_proxyTable.Contains(serverType))
                        {
                            // Create a new entry
                            _proxyTable.Add(serverType, pa);
                        }
                    }                    
                }
            }

            return pa;
        }

        // Creates either an uninitialized object or a proxy depending on 
        // whether the current context is OK or not.
        internal static MarshalByRefObject CreateInstance(Type serverType)
        {
            // Use our activation implementation               
            MarshalByRefObject retObj = null;
            ConstructorCallMessage ctorCallMsg = null;
            bool bCtxOK = IsCurrentContextOK(serverType, null, ref ctorCallMsg);
            if (bCtxOK && !serverType.IsContextful)
            {
                // Marshal by ref case
                Message.DebugOut("Allocating blank marshal-by-ref object"); 
                // We create an uninitialized instance of the actual type and
                // let the regular jit-activation execute the constructor on it.
                retObj = RemotingServices.AllocateUninitializedObject(serverType);
            }
            else 
            {
                //  (context not OK) || (serverType is Contextful)
                // We always return a proxy and the jit-activation's attempt
                // to execute the constructor gets intercepted by the TP stub
                // and routed to RemotingServices.Activate() below.

                // if context *is* OK 
                // this is a contextBound type being activated for which 
                // we always create a proxy (proxies-everywhere!)

                // if context *is not* OK 
                // this could be a MarshalByRef or ContextBound type 
                // being activated outside this appDomain 
                // OR
                // this could be a ContextBound type being activated cross-ctx 

                RemotingProxy rp;
                // See if the object-type is configured for Connect (with a URL)
                retObj = (MarshalByRefObject)ConnectIfNecessary(ctorCallMsg);
                if (retObj == null)
                {
                    // not configured for connect, take the usual route of 
                    // creating a proxy
                    Message.DebugOut("Creating remoting proxy for " + 
                                 serverType.FullName + " in context " + 
                                 Thread.CurrentContext);  

                    rp = new RemotingProxy(serverType);

                    Message.DebugOut("Created remoting proxy\n");
                    retObj = (MarshalByRefObject)rp.GetTransparentProxy();
                }
                else
                {
                    Message.DebugOut("NewObj did a Connect!");
                    rp = (RemotingProxy)RemotingServices.GetRealProxy(retObj);                    
                }                    

                // Store the constructor call message in the proxy
                rp.ConstructorMessage = ctorCallMsg;

                if (!bCtxOK)
                {

                    // Chain in the context level activator now
                    ContextLevelActivator activator = new ContextLevelActivator();
                    activator.NextActivator = ctorCallMsg.Activator; 
                    ctorCallMsg.Activator = activator;
                }
                else
                {
                    // Set the flag to indicate that the activation
                    // will not be leaving the client context .. in this case
                    // the default construction level activator is enough
                    // to complete the activation process.
                    ctorCallMsg.ActivateInContext = true;
                }
            }

            return retObj;
        }

        //
        // NOTE: This is an internal method used by RemotingProxy to do Activation
        // 
        // Starts off the activation chain by sending the constructor call message to 
        // the activator or the client context sink chain. On return, a constructor
        // return message is made and the out parameters are propagated.
        //
        internal static IConstructionReturnMessage Activate(
            RemotingProxy remProxy, IConstructionCallMessage ctorMsg)
        {
            IConstructionReturnMessage ctorRetMsg = null;

            if (((ConstructorCallMessage)ctorMsg).ActivateInContext)
            {
                // The current context was approved for activation
                BCLDebug.Assert(
                    ctorMsg.Activator.Level == ActivatorLevel.Construction,
                    "activator level must ActivatorLevel.Construction!");

                // This has to be a ContextBound type (proxies-everywhere)
                BCLDebug.Assert(ctorMsg.ActivationType.IsContextful, 
                                "Inconsistent state during activation");

                // Ask the activator in the message to take over
                ctorRetMsg = ctorMsg.Activator.Activate(ctorMsg);

                if (ctorRetMsg.Exception != null)
                {
                    throw ctorRetMsg.Exception;
                }
            }
            else
            {
                // Client context was not approved for activation ...
                BCLDebug.Assert(
                    ctorMsg.Activator.Level >= ActivatorLevel.Context,
                    "activator level must be at least x-context!");

                // Check with ActivationServices if we did a "Connect" with
                // a remote server during IsContextOK
                BCLDebug.Assert(
                    ActivationServices.CheckIfConnected(remProxy, ctorMsg) == null,
                    "We shouldn't come through this path on a Connect.");                    

                // Client context was not approved for activation ...
                // This is the more elaborate (real) activation case i.e.
                // we have to go at least out of the client context to 
                // finish the work.

                // Prepare for the handoff to Activation Service

                // Ask various attributes to contribute properties
                // The attributes may chain in other activators into
                // the activation chain (to hijack/participate in
                // the activation process).
                ActivationServices.GetPropertiesFromAttributes(
                    (IConstructionCallMessage)ctorMsg, 
                    ctorMsg.CallSiteActivationAttributes);

                ActivationServices.GetPropertiesFromAttributes(
                    ctorMsg, 
                    ((ConstructorCallMessage)ctorMsg).GetWOMAttributes());

                ActivationServices.GetPropertiesFromAttributes(
                    (IConstructionCallMessage)ctorMsg, 
                ((ConstructorCallMessage)ctorMsg).GetTypeAttributes());       

                // Fetch the client context chain
                IMessageSink cliCtxChain = 
                Thread.CurrentContext.GetClientContextChain();

                // Ask the client context chain to take over from here.
                IMethodReturnMessage retMsg =  
                    (IMethodReturnMessage)
                        cliCtxChain.SyncProcessMessage(ctorMsg);

                // The return message may not be of type
                // IConstructionReturnMessage if an exception happens
                // in the sink chains.
                ctorRetMsg = retMsg as IConstructionReturnMessage;
                if (null == retMsg)
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Activation_Failed"));
                }
                else if (retMsg.Exception != null)
                {
                    throw retMsg.Exception;
                }

            }
            // Note: PropagateOutParameters is now handled by RealProxy
            // CallContext from retMsg should be already set by RealProxy
            BCLDebug.Assert(
                null != ctorRetMsg, 
                "Activate returning null ConstructorReturnMessage");
                
            return ctorRetMsg;
        }

        // This function is called by ActivationServices in case
        // the activation needs to be within the same appdomain. These
        // are only for ContextBound types.
        // It is also called to do satisfy remote incoming requests from
        // the activation services. These could be for both ContextBound
        // and MarshalByRef types.
        internal static IConstructionReturnMessage DoCrossContextActivation(
            IConstructionCallMessage reqMsg)
        {           
            bool bCtxBound = reqMsg.ActivationType.IsContextful;
            ContextTransitionFrame frame = new ContextTransitionFrame();
            if (bCtxBound)
            {
                // If the type is context bound, we need to create 
                // the appropriate context and activate the object inside
                // it.
                // FUTURE: FindOrCreateContext might be helpful here!

                // Create a new Context
                Context serverContext = new Context();              

                // FUTURE: must gather Server end properties also as per Spec!
                // This will become an issue if the client and server have
                // types with different custom attributes (and the server has
                // more attributes).
                
                ArrayList list = (ArrayList) reqMsg.ContextProperties;
                Assembly asm = null;
                for (int i=0; i<list.Count; i++)
                {
                    IContextProperty prop = list[i] as IContextProperty;
                    if (null == prop)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Activation_BadAttribute"));
                    }
                    asm = prop.GetType().Assembly; 
                    // Make a security check to ensure that the context property
                    // is from a trusted assembly!
                    CheckForInfrastructurePermission(asm);

                    // This ensures that we don't try to add duplicate
                    // attributes (eg. type attributes common on both client
                    // and server end)
                    if (serverContext.GetProperty(prop.Name) == null)
                    {
                        serverContext.SetProperty(prop);
                    }
                }
                // No more property changes to the server context from here.
                serverContext.Freeze();

                // (This seems like an overkill but that is how it is spec-ed)
                // Ask each of the properties in the context we formed from
                // if it is happy with the current context.
                for (int i=0; i<list.Count;i++)
                {
                    if (!((IContextProperty)list[i]).IsNewContextOK(
                        serverContext))
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Activation_PropertyUnhappy"));
                    }
                }

                // Change to server context
                Thread.CurrentThread.EnterContext(serverContext, ref frame);
            }

            // call the first sink in the server context chain
            // FUTURE: async activation calls need revisiting!
            IMethodReturnMessage retMsg =  (IMethodReturnMessage) 
                    Thread.CurrentContext.GetServerContextChain().SyncProcessMessage(reqMsg);

            // The return message may not be of type
            // IConstructionReturnMessage if an exception happens
            // in the sink chains.
            Exception e = null;
            IConstructionReturnMessage replyMsg = retMsg as IConstructionReturnMessage;
            if (null == replyMsg)
            {
                if (retMsg != null)
                {
                    e = retMsg.Exception;
                }
                else
                {
                    e = new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Activation_Failed"));

                }
                replyMsg = new ConstructorReturnMessage(e,null); 
                // We have created our own message ... transfer the callcontext
                // from the request message.
                ((ConstructorReturnMessage)replyMsg).SetLogicalCallContext(
                        (LogicalCallContext)
                        reqMsg.Properties[Message.CallContextKey]);
            }

            if (bCtxBound)
            {
                Thread.CurrentThread.ReturnToContext(ref frame);
            }

            return replyMsg;
        }

        internal static IConstructionReturnMessage DoServerContextActivation(
            IConstructionCallMessage reqMsg)
        {
            BCLDebug.Assert(reqMsg!=null, "NULL ctorReqMsg");
            Exception e=null;
            Type serverType = reqMsg.ActivationType;
            Object serverObj = ActivateWithMessage(
                                    serverType, 
                                    reqMsg, 
                                    null,
                                    out e);

            IConstructionReturnMessage replyMsg = 
                SetupConstructionReply(serverObj, reqMsg, e);

            BCLDebug.Assert(replyMsg!=null, "NULL ctorRetMsg");
            return replyMsg;
        }

        internal static IConstructionReturnMessage SetupConstructionReply(
            Object serverObj,
            IConstructionCallMessage ctorMsg,
            Exception e)
        {
            IConstructionReturnMessage replyMsg = null;
            if (e == null)
            {
                replyMsg =
                    new ConstructorReturnMessage(
                        (MarshalByRefObject)serverObj,
                        null,   // FUTURE: outArgs may not be null 
                                // if ctor-s with ref/out are supported
                        0,
                        (LogicalCallContext)
                            ctorMsg.Properties[Message.CallContextKey],
                        ctorMsg);
            }
            else
            {
                replyMsg = new ConstructorReturnMessage(e,null);
                // We have created our own message ... transfer the callcontext
                // from the request message.
                ((ConstructorReturnMessage)replyMsg).SetLogicalCallContext(
                        (LogicalCallContext)
                            ctorMsg.Properties[Message.CallContextKey]);

            }
            return replyMsg;
        }

        internal static Object ActivateWithMessage(
            Type serverType, IMessage msg, ServerIdentity srvIdToBind,
            out Exception e)
        {
            Object server = null;
            e = null;

            // Create a blank instance!
            server = RemotingServices.AllocateUninitializedObject(serverType);

            Object proxyForObject = null;
            if (serverType.IsContextful)
            {
                if (msg is ConstructorCallMessage)
                {
                    // If it is a strictly x-context activation then
                    // this pointer for the message is the TP that we
                    // returned to JIT in first phase of activation
                    proxyForObject = ((ConstructorCallMessage)msg).GetThisPtr();
                }
                else
                {
                    // we are out of the app-domain, so wrap this object now
                    proxyForObject = null;
                }

                // This associates the proxy with the real object and sets
                // up the proxy's native context, ID etc.
                proxyForObject = RemotingServices.Wrap(
                                        (ContextBoundObject)server,
                                        proxyForObject, 
                                        false);
                BCLDebug.Assert(
                    RemotingServices.IsTransparentProxy(proxyForObject),
                    "Wrapped object should be a transparent proxy");
            }
            else
            {
                // Since this is an MBR type, something really bad
                // happened if we are not in the default context
                if (Thread.CurrentContext != Context.DefaultContext)
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Activation_Failed"));
                }
                // Marshal-by-ref case we just return the naked object
                proxyForObject = server;
            }

            // Create the dispatcher which will help run the CTOR
            IMessageSink dispatcher = (IMessageSink)new StackBuilderSink(proxyForObject);

            // This call runs the CTOR on the object
            IMethodReturnMessage retMsg = (IMethodReturnMessage) 
                                        dispatcher.SyncProcessMessage(msg);

            if (retMsg.Exception == null)
            {
                if (serverType.IsContextful)
                {
                    // call wrap to finish the operation.
                    return RemotingServices.Wrap((ContextBoundObject)server);
                }
                else
                {
                    return server;
                }
            }
            else
            {
                e = retMsg.Exception;
                return null;
            }
        }

        public static MarshalByRefObject ConstructObject(IConstructionCallMessage ctorMsg)
        {
            Exception e = null;
            MarshalByRefObject o = 
                (MarshalByRefObject)
                    ActivateWithMessage(    
                        ctorMsg.ActivationType, 
                        ctorMsg, 
                        null, 
                        out e);

            if (e != null)
                throw e;
            return o;
        }

        internal static void StartListeningForRemoteRequests()
        {
            // Get the activation services set up.
            Startup();
            DomainSpecificRemotingData remData = Thread.GetDomain().RemotingData;
            if (!remData.ActivatorListening)
            {
                lock (remData.ConfigLock)
                {
                    if (!remData.ActivatorListening)
                    {
                        BCLDebug.Log("Registering remoting activator");

                        // Marshal the object so that it is ready to take remote
                        // calls. We have to create the objref because that is when
                        // the channels start listening for requests.
                        RemotingServices.MarshalInternal(
                            Thread.GetDomain().RemotingData.ActivationListener, 
                            ActivationServiceURI,
                            typeof(System.Runtime.Remoting.Activation.IActivator)); 
                            
                        ServerIdentity srvID = (ServerIdentity)
                            IdentityHolder.ResolveIdentity(ActivationServiceURI);

                        // Set Singleton to prevent lease from being created
                        srvID.SetSingletonObjectMode();
                        //DBG Console.WriteLine("Activator URI: = " + activatorURI);
                        remData.ActivatorListening = true;
                    }
                }
            }
        }

        // This returns the local activator
        internal static IActivator GetActivator()
        {
            DomainSpecificRemotingData remData = Thread.GetDomain().RemotingData;
            if (remData.LocalActivator == null)
            {
                Startup();
            }
            return (IActivator)remData.LocalActivator;
        }

        internal static void Initialize()
        {
            GetActivator();
        }

        // This returns the attribute that takes part in every activation
        // The local activator itself exposes that functionality
        internal static ContextAttribute GetGlobalAttribute()
        {
            DomainSpecificRemotingData remData = Thread.GetDomain().RemotingData;
            if (remData.LocalActivator == null)
            {
                Startup();
            }
            return (ContextAttribute)remData.LocalActivator;
        }
            
        // This function returns the array of custom attributes of
        // type "ContextAttribute" walking the entire class hierarchy
        // of the serverType
        // If duplicates are found the attribute on the more derived
        // type is kept.
        // The return array may be sparse and is terminated by a NULL.    
        internal static IContextAttribute[] GetContextAttributesForType(Type serverType)
        {
            if (!(typeof(ContextBoundObject).IsAssignableFrom(serverType)) ||
                serverType.IsCOMObject)
            {
                return new ContextAttribute[0];
            }

            Type currType = serverType;
            Object[] currAttr = null;
            int retSize = 8;
            IContextAttribute[] retAttr = new IContextAttribute[retSize];
            int numAttr = 0;
    
    
            // Obtain the custom attributes that implement 
            // IContextAttribute for this type
            currAttr = currType.GetCustomAttributes(
                                    typeof(IContextAttribute),
                                    true);  // recursively on the typeHierarchy
            Boolean bDupe;                             
            foreach (IContextAttribute attr in currAttr)
            {
                Type attrType = attr.GetType();
                bDupe = false;
                for (int i=0; i<numAttr; i++)
                {
                    if (attrType.Equals(retAttr[i].GetType()))
                    {
                        bDupe = true;
                        break;
                    }
                }

                if (!bDupe)
                { 
                    // We must add this attribute to our list
                    numAttr++;
                     
                    // Check if we have enough space to store it
                    // Leaving one spot for a NULL value!
                    if (numAttr > retSize-1)
                    {
                        IContextAttribute[] newAttr = new IContextAttribute[2*retSize];
                        Array.Copy(
                            retAttr,     // srcArray
                            0,          // srcIndex
                            newAttr,    // destArray
                            0,          // destIndex
                            retSize);   // lengthToCopy
                        retAttr = newAttr;
                        retSize = retSize*2;
                    }
                    retAttr[numAttr-1] = attr;
                }
            }
           
            IContextAttribute[] ctxAttr = new IContextAttribute[numAttr];
            Array.Copy(retAttr, ctxAttr, numAttr);
            return ctxAttr;
        }  
        
                
        // This is called during RS.IsContextOK to check if the new XXX() is configured
        // to do a direct connect, and if it is we Connect to the URL and return
        // the proxy. In the second stage, when the constructor executes on the proxy
        // we will make sure (in Activate) that there are no CTOR args.
        internal static Object ConnectIfNecessary(IConstructionCallMessage ctorMsg)
        {
            // If the type being instantiated is configured for Connect
            // we would have added its URL as the connect key during 
            // LocalActivator::IsContextOK

            // Look for the connect URL
            String objURL = (String) ctorMsg.Properties[ConnectKey];
            Object proxy = null;
            if (objURL != null)
            {   
                // Connect to the URL and return the proxy
                proxy = RemotingServices.Connect(
                                        ctorMsg.ActivationType,
                                        objURL);
            }

            // If the type is not setup for connecting we return null!
            return proxy;                                            
        }                                        

        // This is really used to distinguish between proxies for completely 
        // within AppDomain activations and the ones from "Connect" during
        // the second stage (RS::Activate)
        // For the former, we have to run constructor etc and for the latter
        // we have to check that there is no non-defaul CTOR.
        internal static Object CheckIfConnected(
            RemotingProxy proxy, IConstructionCallMessage ctorMsg)
        {
            // If we performed a connect, we must have put the URL as
            // the connectKey in the message.
            String objURL = (String)
                            ctorMsg.Properties[ConnectKey];
            Object tp = null;

            if (objURL != null)
            {   
                // We did perform a connect during IsContextOK 
                // Just get the TP from RP and return it.
                tp = (Object)proxy.GetTransparentProxy();
            } 
            // We return null if we do not recognize this proxy!
            return tp;                                            
        }

        internal static void PushActivationAttributes(Type serverType, Object[] attributes)
        {
            // There is one such object per thread
            if (_attributeStack == null)
            {            
                _attributeStack = new ActivationAttributeStack();
            }
            _attributeStack.Push(serverType, attributes);
        }

        internal static Object[] PeekActivationAttributes(Type serverType)
        {
            // We can get a peek w/o a prior Push (eg. activation starting
            // with NewObj)
            if (_attributeStack == null)
            {            
                return null;
            }
            return _attributeStack.Peek(serverType);
        }
        
        internal static void PopActivationAttributes(Type serverType)
        {
            BCLDebug.Assert(_attributeStack != null, "Pop w/o a prior Set()?");
            _attributeStack.Pop(serverType);
        }
        
    } // class ActivationServices    
    


    // This is the local activation helper and also the Attribute 
    // that gets queried about every activation
    internal class LocalActivator: ContextAttribute, IActivator
    {
        internal LocalActivator()
            : base(ActivationServices.ActivationServiceURI)
        {
        
        }

        // ---------------------------------------------------------------        
        // ContextAttribute functionality
        // ---------------------------------------------------------------        

        // IContextAttribute::IsContextOK
        // This will check if a type is configured for remote activation ... 
        // We return 'false' for IsContextOK if it is.
        public override bool IsContextOK(
            Context ctx, IConstructionCallMessage ctorMsg)
        {

            // If the app is not using config mechanism, we don't want
            // to intercept activation.
            if (RemotingConfigHandler.Info == null)
            {
                return true;
            }

            // check if this type is configured for connect 
            // (instead of remote activate)
            WellKnownClientTypeEntry wkte = 
                RemotingConfigHandler.IsWellKnownClientType(
                    ctorMsg.ActivationType);
            String typeURL = (wkte == null ? null : wkte.ObjectUrl);

            if (typeURL != null)
            {
                // this type does have a direct uri, we will try to connect 
                // to it during the activate call. Cache it in the message.
                ctorMsg.Properties[ActivationServices.ConnectKey] = typeURL;
                return false;
            }
            else
            {
                ActivatedClientTypeEntry acte = 
                    RemotingConfigHandler.IsRemotelyActivatedClientType(
                        ctorMsg.ActivationType);

                String appURL = null;

                if (acte == null)
                {
                    // This is the case where the config file had no entry for this type.
                    // We should check the callsite attributes for a URL
                    Object[] callsiteAttributes = ctorMsg.CallSiteActivationAttributes;
                    if(null != callsiteAttributes)
                    {
                        for(int i = 0; i < callsiteAttributes.Length; i++)
                        {
                            UrlAttribute attr = callsiteAttributes[i] as UrlAttribute;
                            if(null != attr)
                            {
                                appURL = attr.UrlValue; 
                            }
                        }
                    }
                        
                    if(appURL == null)
                    {
                        // We don't really care about intercepting the activation in this case.
                        return true;
                    }
                }
                else
                {
                    appURL = acte.ApplicationUrl;
                }

                // Generate the URL of the remote activator                    
                String activatorURL = null;
                if (!appURL.EndsWith("/"))
                    activatorURL = appURL + "/" + ActivationServices.ActivationServiceURI;
                else
                    activatorURL = appURL + ActivationServices.ActivationServiceURI;
                            
                // Mark a flag for remote activation 
                // (caching the url of the activation svc of the remote server)
                ctorMsg.Properties[ActivationServices.RemoteActivateKey] = activatorURL;
                return false;
            }
        }
                
        // IContextAttribute::GetPropertiesForNewContext
        public override void GetPropertiesForNewContext(
            IConstructionCallMessage ctorMsg)
        {            
            BCLDebug.Log("ActivationSvc:GlobalAttrib::GetPropForNewCtx");
            // This is called during RS::Activate .. when we are sure that
            // activation is at least x-context and this is a real activation
            // instead of a spoofed connect underneath the "new".
            BCLDebug.Assert(ctorMsg!=null, "ctorMsg null?");
            if (ctorMsg.Properties.Contains(ActivationServices.RemoteActivateKey))
            {
                // Means we did want to intercept activation!
                String remActivatorURL = (String)
                    ctorMsg.Properties[ActivationServices.RemoteActivateKey];
                
                AppDomainLevelActivator activator = 
                    new AppDomainLevelActivator(remActivatorURL);
                // Chain ourselves at the end of the AppDomainLevel activators
                BCLDebug.Assert(
                        ctorMsg.Activator != null, 
                        "Should have at least x-context activator");
                IActivator curr = ctorMsg.Activator;
                
                if (curr.Level < ActivatorLevel.AppDomain)
                {
                    // Common case .. .only x-context activator(s) in chain
                    activator.NextActivator = curr;
                    ctorMsg.Activator = activator;
                }
                else if (curr.NextActivator == null)
                {  
                    // Only one activator but not ContextLevel ...
                    // We go at the end of the chain 
                    curr.NextActivator = activator;
                }
                else
                {
                    // We will have to walk the chain till the end of the last
                    // AD activator and plug ourselves in.
                    while (curr.NextActivator.Level >= ActivatorLevel.AppDomain)
                    {                        
                        curr = curr.NextActivator;
                    }
                    BCLDebug.Assert(
                        curr.NextActivator.Level.Equals(ActivatorLevel.Context),
                        "bad ordering of activators!");
                    activator.NextActivator = curr.NextActivator;
                    curr.NextActivator = activator;
                }                                
            }
        }                     

        // ---------------------------------------------------------------        
        // IActivator functionality
        // ---------------------------------------------------------------        
        //IActivator::NextActivator
        public virtual IActivator NextActivator 
        {
            // We are a singleton internal infrastructure object.
            get { return null; }
            // Don't allow a set either.
            set { throw new InvalidOperationException();}
        }

        //IActivator::ActivatorLevel
        public virtual ActivatorLevel Level
        {
            get {return ActivatorLevel.AppDomain;}
        }
        
        private static MethodBase GetMethodBase(IConstructionCallMessage msg)
        {
            MethodBase mb = msg.MethodBase;
            if(null == mb)      
            {
                BCLDebug.Trace("REMOTE", "Method missing w/name ", msg.MethodName);
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_MethodMissing"),
                            msg.MethodName,
                            msg.TypeName));
            }
                    
            return mb;
        }

        //IActivator::Activate
        public virtual IConstructionReturnMessage Activate(
            IConstructionCallMessage ctorMsg)
        {
            // This is where the activation service hooks in to activation
            // requests. We get called as the activation message is recognized
            // by the ClientContextTerminatorSink & routed to us. 
            //
            // NOTE: This gets called for both purely within appDomain activation
            // and 'real' remote activation scenarios as the request goes out of
            // the client context.
            // It also gets called as an incoming remote call is routed to the
            // local activator by the remote activator object.
            //
            BCLDebug.Log("Activation Services:: new Activate()");
            if (ctorMsg == null)
            {
                throw new ArgumentNullException("ctorMsg");
            }
            
            // Check if we have marked this activation to go remote 
            if (ctorMsg.Properties.Contains(ActivationServices.RemoteActivateKey))
            {
                //DBG Console.WriteLine("Attempting remote activation!");
                                
                return DoRemoteActivation(ctorMsg);
            }
            else
            {                
                // We must be in either a pure cross context activation or
                // a remote incoming activation request (in which case we
                // already checked the permission to create an instance of
                // this type).
                if (ctorMsg.Properties.Contains(ActivationServices.PermissionKey))
                { 
                    Type activationType = ctorMsg.ActivationType;                    

                    // We are on the server end of a real remote activation
                    // Create a local attribute that contributes the context
                    // properties requested by the remote request
                    Object[] attr = null;
                    if (activationType.IsContextful)
                    {
                    IList cp = ctorMsg.ContextProperties;
                    if (cp != null && cp.Count > 0)
                    {
                        RemotePropertyHolderAttribute rph = new RemotePropertyHolderAttribute(cp);
                        attr = new Object[1];
                        attr[0] = rph;
                    }
                    }

                    MethodBase mb = GetMethodBase(ctorMsg); 
                    RemotingMethodCachedData methodCache = 
                                            InternalRemotingServices.GetReflectionCachedData(mb);
                    Object[] args = Message.CoerceArgs(ctorMsg, methodCache.Parameters);
                    
                    Object server = Activator.CreateInstance(
                        activationType, 
                        args,
                        attr);

                    // check to see if we need to do redirection
                    if (RemotingServices.IsClientProxy(server))
                    {
                        // The wellknown type is remoted so we must wrap the proxy
                        // with a local object.

                        // The redirection proxy masquerades as an object of the appropriate
                        // type, and forwards incoming messages to the actual proxy.
                        RedirectionProxy redirectedProxy = 
                            new RedirectionProxy((MarshalByRefObject)server, activationType);
                        RemotingServices.MarshalInternal(redirectedProxy, null, activationType);

                        server = redirectedProxy;
                    }                        
                     
                    return ActivationServices.SetupConstructionReply(
                        server, ctorMsg, null);
                }
                else
                {
                    BCLDebug.Log("Attempting X-Context activation!");
                    // delegate to the Activator in the message 
                    return ctorMsg.Activator.Activate(ctorMsg);
                }
            }
        }


        // This is called by the local activator during an outgoing activation
        // request.
        internal static IConstructionReturnMessage DoRemoteActivation(
            IConstructionCallMessage ctorMsg)
        {
            BCLDebug.Assert(ctorMsg != null, "Null ctorMsg");

            // FUTURE: we should attempt connect over the available channels!
            // (what about attempting over X-Context & X-AppDomain? If we know
            // for example that the activation is going x-context or x-appDomain
            // only it will be a good idea to have a uniform model for all these.

            // We should also maintain a cache or the remote activators we have
            // already connected to (or may be this is implicitly done for us by
            // the identity table.
            
            BCLDebug.Log("Attempting Connection to remote activation service");
            IActivator remActivator = null;
            String remActivatorURL = (String)
                ctorMsg.Properties[ActivationServices.RemoteActivateKey];
            try 
            {
                remActivator = (IActivator) 
                    RemotingServices.Connect(
                        typeof(System.Runtime.Remoting.Activation.IActivator),
                        remActivatorURL);
                                    
            }
            catch (Exception e)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Activation_ConnectFailed"),
                        e));
            }
            // Remove the remote activate key as its purpose is served.
            ctorMsg.Properties.Remove(ActivationServices.RemoteActivateKey);

            // Delegate the work to the remote activator
            return remActivator.Activate(ctorMsg);                        
        }
        
    }// class LocalActivator

    // This is the object that listens to activation requests
    internal class ActivationListener:MarshalByRefObject, IActivator
    {
        // Override lifetime services to make this object live forever...
        public override Object InitializeLifetimeService()
        {
           return null;
        }

        //IActivator::NextActivator
        public virtual IActivator NextActivator 
        {
            // We are a singleton internal infrastructure object.
            get { return null; }
            // Don't allow a set either.
            set { throw new InvalidOperationException();}
        }

        //IActivator::ActivatorLevel
        public virtual ActivatorLevel Level
        {
            get {return ActivatorLevel.AppDomain;}
        }
    
        //IActivator::Activate
        public virtual IConstructionReturnMessage Activate(
            IConstructionCallMessage ctorMsg)
        {
            BCLDebug.Log("ActivationListener: received new activation request!");
            if (ctorMsg == null || RemotingServices.IsTransparentProxy(ctorMsg))
            {
                throw new ArgumentNullException("ctorMsg");
            }
            
            // Add the permission key which distinguishes pure-cross context activation from
            // a remote request (both of which go through DoCrossContextActivation)
            ctorMsg.Properties[ActivationServices.PermissionKey] = "allowed";

            // Check to make sure that this activation type has been allowed.
            String activationTypeName = ctorMsg.ActivationTypeName;
            if (!RemotingConfigHandler.IsActivationAllowed(activationTypeName))
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Activation_PermissionDenied"),
                        ctorMsg.ActivationTypeName));
            }


            Type activationType = ctorMsg.ActivationType;
            if (activationType == null)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_BadType"),
                        ctorMsg.ActivationTypeName));
            }

            // Delegate to the local activator for further work
            return ActivationServices.GetActivator().Activate(ctorMsg);
        }        

        
    }   // class ActivationListener


    // This is a lightweight object to help with the activation
    // at the appDomain level ... it delegates its work to 
    // ActivationServices.LocalActivator ... which is a heavy 
    // object we can't afford to carry around in the ActivatorChain
    // (since it may get Serialized/Deserialized)
    // BUGBUG: These should be marked with the [Serializable()] 
    // attribute .. the latter shall be turned on during Beta-2!
    internal class AppDomainLevelActivator : IActivator
    {
        IActivator m_NextActivator;        

        // Do we need this?
        String m_RemActivatorURL;
        
        internal AppDomainLevelActivator(String remActivatorURL)
        {
            BCLDebug.Assert(remActivatorURL!=null,"Bad activator URL");
            m_RemActivatorURL = remActivatorURL;
        }

        internal AppDomainLevelActivator(SerializationInfo info, StreamingContext context) {
            if (info==null)
            {
                throw new ArgumentNullException("info");
            }
            m_NextActivator = (IActivator) info.GetValue("m_NextActivator",typeof(IActivator));
        }

        //IActivator::NextActivator
        public virtual IActivator NextActivator 
        {            
            get { return m_NextActivator; }
            set { m_NextActivator = value; }
        }

        //IActivator::ActivatorLevel
        public virtual ActivatorLevel Level
        {
            get { return ActivatorLevel.AppDomain; }
        }

        //IActivator::Activate
        public virtual IConstructionReturnMessage Activate(
            IConstructionCallMessage ctorMsg)
        {
            // This function will get invoked when the ClientContextTerminator sink
            // notices that an activation request message is passed to it ... it
            // will route the message to the Activator present inside the ctorMsg
            // (which happens to be us in this case!)

            // remove ourselves from the Activator chain
            ctorMsg.Activator = m_NextActivator;
            return ActivationServices.GetActivator().Activate(ctorMsg);            
        }
    }

    // This is a lightweight object to help with the activation
    // at the context level ...     
    [Serializable]
    internal class ContextLevelActivator : IActivator
    {                
        IActivator m_NextActivator;
        internal ContextLevelActivator()
        {
            m_NextActivator = null;
        }
        
        internal ContextLevelActivator(SerializationInfo info, StreamingContext context) 
        {
            if (info==null)
            {
                throw new ArgumentNullException("info");
            }
            m_NextActivator = (IActivator) info.GetValue("m_NextActivator",typeof(IActivator));
        }

        //IActivator::NextActivator
        public virtual IActivator NextActivator 
        {            
            get { return m_NextActivator; }
            set { m_NextActivator = value; }
        }

        //IActivator::ActivatorLevel
        public virtual ActivatorLevel Level
        {
            get { return ActivatorLevel.Context; }
        }

        //IActivator::Activate
        public virtual IConstructionReturnMessage Activate(
            IConstructionCallMessage ctorMsg)
        {
            // remove ourselves from the Activator chain
            ctorMsg.Activator = ctorMsg.Activator.NextActivator;
            
            // Delegate to remoting services to do the hard work.
            // This will create a context, enter it, run through
            // the context sink chain & then delegate to the nex
            // activator inside the ctorMsg (quite likely to be 
            // the default ConstructionLevelActivator)
            return ActivationServices.DoCrossContextActivation(ctorMsg);
        }        
    }

    // This is a lightweight object to help with the activation
    // at the appDomain level ... it delegates its work to 
    // ActivationServices.LocalActivator ... which is a heavy 
    // object we can't afford to carry around in the ActivatorChain
    // (since it may get Serialized/Deserialized)
    [Serializable]
    internal class ConstructionLevelActivator : IActivator
    {                
        internal ConstructionLevelActivator()
        {
        
        }


        //IActivator::NextActivator
        public virtual IActivator NextActivator 
        {            
            // The construction level activator is a terminating activator
            get { return null; }
            // Throw if someone attempts a set
            set { throw new InvalidOperationException(); }
        }

        //IActivator::ActivatorLevel
        public virtual ActivatorLevel Level
        {
            get { return ActivatorLevel.Construction; }
        }

        //IActivator::Activate
        public virtual IConstructionReturnMessage Activate(
            IConstructionCallMessage ctorMsg)
        {
            // This function will get invoked when the ClientContextTerminator sink
            // notices that an activation request message is passed to it ... it
            // will route the message to the Activator present inside the ctorMsg
            // (which happens to be us in this case!)

            // remove ourselves from the Activator chain
            ctorMsg.Activator = ctorMsg.Activator.NextActivator;
            return ActivationServices.DoServerContextActivation(ctorMsg);            
        }
    }

    // This acts as a pseudo call site attribute and transfers 
    // the context properties carried in from a remote activation request
    // to the server side activation 
    internal class RemotePropertyHolderAttribute : IContextAttribute
    {
        IList _cp;      // incoming list of context properties
        internal RemotePropertyHolderAttribute(IList cp)
        {
            _cp = cp;
            BCLDebug.Assert(cp != null && cp.Count > 0,"Bad _cp?");
        }
        public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            // The fact that we got instantiated means some remote activation
            // has contributed non-default context properties to the ctorMsg
            return false;
        }


        // properties are collected in order from callsite, wom & type 
        // attributes ... so we get a first shot at adding properties
        public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
        {
            for (int i=0; i<_cp.Count; i++)
            {
                // Just cycle through the list and add the properties to 
                // the construction message.
                // We will throw at a later stage if any of these do not
                // implement IContextProperty
                ctorMsg.ContextProperties.Add(_cp[i]);
            }
        }
    }

    // Note: One instance of this class is setup per thread that comes to
    // managed remoting for activation of MBR types. All access to methods
    // is by design single-threaded. (Each thread is working on its own object).

    // In the case of Activator.CreateInstance ... that API does the Push &
    // Remoting does a Pop() as soon as it has picked up the attributes from
    // the threadStatic. The CreateInstance API itself does a Pop() too in 
    // a try-finally. (So this does not work very well if the infrastructure 
    // creates an instance of the same MBR type as the outer type being created.
    // However, to minimize code churn this is the least risky fix we can do.
    // The full fix would be to pass activationAttributes into the VM through
    // reflection code and have the VM pass them over to remoting which will
    // then hand them over to managed remoting helpers. This will also involve
    // adding attributes as an additional parameter to 
    // ProxyAttribute.CreateInstance() public method.

    internal class ActivationAttributeStack
    {
        Object[] activationTypes;
        Object[] activationAttributes;
        int freeIndex;
        internal ActivationAttributeStack()
        {
            activationTypes = new Object[4];
            activationAttributes = new Object[4];
            freeIndex = 0;
        }

        internal void Push(Type typ, Object[] attr)
        {
            BCLDebug.Assert(typ!=null, "typ != null");                    
            BCLDebug.Assert(attr!=null, "attr != null");        

            if (freeIndex == activationTypes.Length)
            {
                // Need to grow our arrays ... this will be exceedingly rare
                Object[] newTypes = new Object[activationTypes.Length * 2];
                Object[] newAttr = new Object[activationAttributes.Length * 2];
                BCLDebug.Assert(newAttr.Length == newTypes.Length,"These should be in sync!");
                Array.Copy(activationTypes, newTypes, activationTypes.Length);
                Array.Copy(activationAttributes, newAttr, activationAttributes.Length);    
                activationTypes = newTypes;
                activationAttributes = newAttr;
            }
            activationTypes[freeIndex] = typ;
            activationAttributes[freeIndex] = attr;
            freeIndex++;
        }

        internal Object[] Peek(Type typ)
        {
            BCLDebug.Assert(typ!=null, "typ != null");
            if (freeIndex == 0 || activationTypes[freeIndex-1] != typ)
            {
                return null;
            }
            return (Object[])activationAttributes[freeIndex-1];
        }

        // Note: Read the comments above .. you can have 2 pops for the same 
        // push. We also count on infrastructure code not activating 
        // the same type as the caller causing a recursive activation.
        internal void Pop(Type typ)
        {
            BCLDebug.Assert(typ!=null, "typ != null");
            if (freeIndex != 0 && activationTypes[freeIndex-1] == typ)
            {                
                freeIndex--;
                // Clear the popped entry
                activationTypes[freeIndex] = null;
                activationAttributes[freeIndex] = null;
            }
        }
    }
}//namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\context.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:     Context.cs
**
** Author:  Manish Prabhu (MPrabhu)
**
** Purpose: Remoting Context core implementation.
**
** Date:    Feb 16, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Contexts {
    
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;
    //  CallBacks provide a facility to request execution of some code
    //  in another context.
    //  CrossContextDelegate type is defined for context call backs. 
    //  Each context has a CallBackObject which can be used to perform
    //  callbacks on the context. The delegate used to request a callback
    //  through the CallBackObject must be of CrossContextDelegate type.
    /// <include file='doc\Context.uex' path='docs/doc[@for="CrossContextDelegate"]/*' />
    /// <internalonly/>
    public delegate void CrossContextDelegate();
    
    /// <include file='doc\Context.uex' path='docs/doc[@for="Context"]/*' />
    /// <internalonly/>
    // deliberately not [serializable]
    //[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class Context
    {
        // flags to mark the state of the context object
        // marks the context as the default context
        internal const int CTX_DEFAULT_CONTEXT   = 0x00000001;
        
        // marks the context as frozen
        internal const int CTX_FROZEN                = 0x00000002;
        
        // Tells the context channel that the context has properties 
        // that use the threadPool themselves.
        // In that case, the channel does not itself use threadPool.
        // This is OFF by default
        internal const int CTX_THREADPOOL_AWARE = 0x00000004;
    
        private const int GROW_BY                        = 0x8;
        private const int STATICS_BUCKET_SIZE           = 0x8;
        
        private IContextProperty[] _ctxProps;    // array of name-value pairs of properties        
        private DynamicPropertyHolder _dphCtx;  // Support for Dynamic Sinks
        private LocalDataStore _localDataStore;
        private IMessageSink _serverContextChain;   
        private IMessageSink _clientContextChain;
        private AppDomain _appDomain;       // AppDomain property of the context
        private Object[] _ctxStatics;       // Holder for context statics

        //**********************
        // This needs to be the first NON-OBJECT field!
        private IntPtr _internalContext; // address of the VM context object!
        //**********************

        // at this point we just differentiate contexts based on context ID
        private int _ctxID;
        private int _ctxFlags;
        private int _numCtxProps;   // current count of properties

        // Context statics stuff
        private int _ctxStaticsCurrentBucket;
        private int _ctxStaticsFreeIndex;

        // Support for dynamic properties.
        private static DynamicPropertyHolder _dphGlobal = new DynamicPropertyHolder();
    
        // Support for Context Local Storage
        private static LocalDataStoreMgr _localDataStoreMgr = new LocalDataStoreMgr();

        // ContextID counter (for public context id)        
        private static int _ctxIDCounter = 0; 
        // FUTURE: ensure that managed contexts created from VM get this!
        // may need to call the .ctor using pMD->Invoke.


        // This function is merely here to avoid compiler warnings.
#if _DEBUG
        private void NeverCallThis()
        {
            BCLDebug.Assert(false,"NeverCallThis");
            _internalContext = new IntPtr(RemotingServices.TrashMemory);
            _appDomain = null;
        }
#endif

        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.Context"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public Context()
            : this(0)
        {
        }
        
        private Context(int flags) {
                                            
            _ctxFlags = flags;
            if ((_ctxFlags & CTX_DEFAULT_CONTEXT) != 0)
            {
                _ctxID = 0;     // ID 0 == default context
            }
            else
            {
                _ctxID = Interlocked.Increment(ref _ctxIDCounter);
            }
            
            // This call will set up the cycles between the VM & managed context
            // It will also set the managed context's AppDomain property to 
            // the current AppDomain.
            SetupInternalContext((_ctxFlags&CTX_DEFAULT_CONTEXT) == CTX_DEFAULT_CONTEXT);
            
            // Every context inherits the appdomain level properties
            // Get the properties for the appdomain and add it to
            // this context.
            DomainSpecificRemotingData data = Thread.GetDomain().RemotingData;
            if(null != data)
            {
                IContextProperty[] ctxProps = data.AppDomainContextProperties;
                if(null != ctxProps)
                {
                    for(int i = 0; i < ctxProps.Length; i++)
                    {
                        SetProperty(ctxProps[i]);
                    }
                }                                    
            }
            
            // Freeze the default context now
            if ((_ctxFlags & CTX_DEFAULT_CONTEXT) != 0)
            {
                this.Freeze();
            }
            
            Message.DebugOut("Creating Context with ID " + _ctxID + " and flags " + flags + " " + Environment.NewLine);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void SetupInternalContext(bool bDefault);

        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.Finalize"]/*' />
	/// <internalonly/>
        ~Context()
        {
            // We clean up the backing objects only for the non-default
            // contexts. For default contexts these are cleaned up during
            // AppDomain shutdown.
            if ((_ctxFlags & CTX_DEFAULT_CONTEXT) == 0)
            {
                CleanupInternalContext();
            }
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void CleanupInternalContext();
            
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.ContextID"]/*' />
	/// <internalonly/>
        public virtual Int32 ContextID 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get 
            {
                return _ctxID;
            }
        }

        internal virtual Int32 InternalContextID
        {
            get 
            {
                return _internalContext.ToInt32();
            }
        }
    
        internal virtual AppDomain AppDomain
        {
            get {return _appDomain;}
        }

        internal bool IsDefaultContext
        {
            get { return _ctxID == 0; }
        }

        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.DefaultContext"]/*' />
	/// <internalonly/>
        public static Context DefaultContext 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get 
            {
                return Thread.GetDomain().GetDefaultContext();
            }
        }

        internal static Context CreateDefaultContext()
        {
            return new Context(CTX_DEFAULT_CONTEXT);
        }
        
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.GetProperty"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public virtual IContextProperty GetProperty(String name)
        {
            if (_ctxProps == null || name == null)
            {
                return null;
            }
            IContextProperty prop = null;
            for (int i=0; i<_numCtxProps; i++)
            {
                if (_ctxProps[i].Name.Equals(name))
                {
                    prop = _ctxProps[i];
                    break;
                }
            }
            return prop;
        }
    
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.SetProperty"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public virtual void SetProperty(IContextProperty prop)
        {
            // We do not let people add properties to the default context.
            /* We allow appdomain level properties to be added to the default context
            if ((_ctxFlags & CTX_DEFAULT_CONTEXT) != 0)
            {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_AddContextFrozen"));
            }
            */
            
            if (prop == null || prop.Name == null)
            {
                throw new ArgumentNullException((prop==null) ? "prop" : "property name");
            }
    
            if ((_ctxFlags & CTX_FROZEN) != 0)
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString("InvalidOperation_AddContextFrozen"));
            }
    
            lock (this)
            {
                // Check if we have a property by this name
                CheckPropertyNameClash(prop.Name, _ctxProps, _numCtxProps);
                
                // check if we need to grow the array.
                if (_ctxProps == null || _numCtxProps == _ctxProps.Length)    
                {
                    _ctxProps = GrowPropertiesArray(_ctxProps);
                }
                // now add the property
                _ctxProps[_numCtxProps++] = prop;
            }
        }
    
        internal virtual void  InternalFreeze()
        {
            _ctxFlags |= CTX_FROZEN;
            // From this point on attempts to add properties will throw
            // So we don't need to take a lock.
            for (int i=0; i<_numCtxProps; i++)
            {
                _ctxProps[i].Freeze(this);
            }
            
        }
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.Freeze"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public virtual void Freeze()
        {
            lock(this) {
                if ((_ctxFlags & CTX_FROZEN) != 0)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_ContextAlreadyFrozen"));
                }
                InternalFreeze();
            }
        }
    
        internal virtual void SetThreadPoolAware()
        {
            // Cannot turn off ThreadPool support for the default context
            BCLDebug.Assert(
                (_ctxFlags & CTX_DEFAULT_CONTEXT) == 0,
                "This operation is not allowed on the default context!");
            _ctxFlags |= CTX_THREADPOOL_AWARE;
        }
    
        internal virtual bool IsThreadPoolAware 
        {
            get { return (_ctxFlags & CTX_THREADPOOL_AWARE) == CTX_THREADPOOL_AWARE;}
        }
        
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.ContextProperties"]/*' />
	/// <internalonly/>
        public virtual IContextProperty[] ContextProperties
        {
            // we return a copy of the current set of properties
            // the user may iterate from 0 to array.length on it.
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get 
            {
                if (_ctxProps == null)
                {
                    return null;
                }   
                lock (this)
                {         
                    IContextProperty[] retProps = new IContextProperty[_numCtxProps];
                    Array.Copy(_ctxProps, retProps, _numCtxProps);
                    return retProps;
                }
            }
        }
    
        internal static void CheckPropertyNameClash(String name, IContextProperty[] props, int count)
        {
            for (int i=0; i<count; i++)
            {
                if (props[i].Name.Equals(name))
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_DuplicatePropertyName"));
                }
            }        
        }
    
        internal static IContextProperty[] GrowPropertiesArray(IContextProperty[] props)
        {
            // grow the array of IContextProperty objects
            int newSize = (props != null ? props.Length : 0)  + GROW_BY;
            IContextProperty[] newProps = new IContextProperty[newSize];
            if (props != null)
            {
                // Copy existing properties over.
                Array.Copy(props, newProps, props.Length);
            }
            return newProps;
        }
            
        internal virtual IMessageSink GetServerContextChain()
        {
            if (_serverContextChain == null) 
            {
                // a bare chain would have just this one sink.
                IMessageSink newServerContextChain = ServerContextTerminatorSink.MessageSink;
    
                // now loop over properties to add some real sinks.
                Object prop = null;
                int iSink = _numCtxProps;
                while (iSink-- > 0) 
                {
                    // see if this property wants to contribute a ServerContextSink
                    // we have to start chaining in the reverse order
                    prop = _ctxProps[iSink];
                    IContributeServerContextSink sink = prop as IContributeServerContextSink;
                    if (null != sink )
                    {
                        // yes, chain the sink ahead of the chain of sinks constructed so far.
                        newServerContextChain = sink.GetServerContextSink( newServerContextChain);
                        if (newServerContextChain == null)
                        {
                            throw new RemotingException( 
                                Environment.GetResourceString(
                                    "Remoting_Contexts_BadProperty"));
                        }
                    }
                }
                lock (this)
                {  
                    if (_serverContextChain == null)
                    {
                        _serverContextChain = newServerContextChain;
                    }
                }
            }
            return _serverContextChain;
        }
    
        internal virtual IMessageSink GetClientContextChain()
        {
            Message.DebugOut("Context::GetClientContextChain: IN _ctxID =" + _ctxID + Environment.NewLine);
            if (_clientContextChain == null)
            {
                Message.DebugOut("Context::GetClientContextChain: _clientContextChain == null, creating chain" + Environment.NewLine);
                // a bare chain would have just this one sink.
                IMessageSink newClientContextChain = ClientContextTerminatorSink.MessageSink;
    
                // now loop over properties to add some real sinks.
                // Note that for the client chain we go through the properties 
                // in the reverse order as compared to the server chain. 
                // Thus if a lock was taken as the last action of an incoming
                // call, it is released as the first action of an outgoing call.                
                Object prop = null;
                int iSink = 0;
                while (iSink < _numCtxProps) 
                {
                    Message.DebugOut("Context::GetClientContextChain: checking property " + 
                                     _ctxProps[iSink].Name + Environment.NewLine);
                    // see if this property wants to contribute a ClientContextSink
                    // we have to start chaining in the reverse order
                    prop = _ctxProps[iSink];
                    IContributeClientContextSink sink = prop as IContributeClientContextSink;
                    if (null != sink)
                    {
                        Message.DebugOut("Context::GetClientContextChain: calling GetClientContextSink on " + 
                                         _ctxProps[iSink].Name + Environment.NewLine);
                        // yes, chain the sink ahead of the chain of sinks constructed so far.
                        newClientContextChain = sink.GetClientContextSink(newClientContextChain);
                        if (newClientContextChain == null)
                        {
                            throw new RemotingException( 
                                Environment.GetResourceString(
                                    "Remoting_Contexts_BadProperty"));
                        }
                    }
                    iSink++;
                }
                // now check if we raced and set appropriately
                lock (this)
                {
                    if (_clientContextChain==null)
                    {
                        _clientContextChain = newClientContextChain;
                    }
                    // else the chain we created should get GC-ed.
                }            
            }
            return _clientContextChain;        
        }
    
        internal virtual IMessageSink CreateServerObjectChain(MarshalByRefObject serverObj)
        {
            // a bare chain would just be the dispatcher sink       
            IMessageSink serverObjectChain = new ServerObjectTerminatorSink(serverObj);
            
            // now loop over properties to add some real sinks.
            Object prop = null;
            int iSink = _numCtxProps;
            while (iSink-- > 0) 
            {
                // see if this property wants to contribute a ServerObjectSink
                // we have to start chaining in the reverse order
                prop = _ctxProps[iSink];
                IContributeObjectSink sink = prop as IContributeObjectSink;
                if (null != sink)
                {
                    // yes, chain the sink ahead of the chain of sinks constructed so far.
                    serverObjectChain =  sink.GetObjectSink( serverObj, serverObjectChain);
                    if (serverObjectChain == null)
                    {
                            throw new RemotingException( 
                                Environment.GetResourceString(
                                    "Remoting_Contexts_BadProperty"));
                    }
                }
            }
            return serverObjectChain;
        }
    
        internal virtual IMessageSink CreateEnvoyChain(MarshalByRefObject objectOrProxy)
        {
            // a bare chain would just be the dispatcher sink
            IMessageSink envoyChain = EnvoyTerminatorSink.MessageSink;
            
            // now loop over properties to add some real sinks.
            // Note: the sinks in the envoy chain should be in mirror image
            // order relative to sinks on the server side
            Object prop = null;
            int iSink = 0;
            
            MarshalByRefObject exposedObj = objectOrProxy;
        
            while (iSink < _numCtxProps) 
            {
                // see if this property wants to contribute a ClientContextSink
                // we have to start chaining in the reverse order
                prop = _ctxProps[iSink];
                IContributeEnvoySink sink = prop as IContributeEnvoySink; 
                if (null != sink)
                {
                    // yes, chain the sink ahead of the chain of sinks constructed so far.
                    envoyChain = sink.GetEnvoySink(exposedObj, envoyChain);
                    if (envoyChain == null)
                    {
                        throw new RemotingException( 
                            Environment.GetResourceString(
                                "Remoting_Contexts_BadProperty"));
                    }
                }
                iSink++;
            }
            return envoyChain;
        }
    

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~ Activation Support ~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        internal IMessage NotifyActivatorProperties(
            IMessage msg, bool bServerSide)
        {
            BCLDebug.Assert( (msg is IConstructionCallMessage) 
                                || (msg is IConstructionReturnMessage),
                            "Bad activation msg type");
            BCLDebug.Assert( !((msg is IConstructionCallMessage) && 
                                (msg is IConstructionReturnMessage)),
                            "Activation message cannot be both call & return type");
                                                        
            BCLDebug.Assert((_ctxFlags & CTX_FROZEN) == CTX_FROZEN,
                            "ServerContext not frozen during activation!");


            // Any exception thrown by the notifications is caught and 
            // folded into a return message to return to the caller.
            IMessage errMsg = null;

            try
            {
                // Since the context is frozen the properties array is in 
                // effect read-only! 
                int iProp = _numCtxProps;            
                Object prop = null;
                
                while (iProp-- != 0) 
                {
                    // see if this property is interested in Activation
                    prop = _ctxProps[iProp];
                    IContextPropertyActivator activator = prop as IContextPropertyActivator; 
                    if (null != activator)
                    {
                        // yes, notify as appropriate
                        IConstructionCallMessage ccm = msg as IConstructionCallMessage;
                        if (null != ccm)
                        {
                            // IConsructionCallMessage on its way forward
                            if (!bServerSide)
                            {
                                // activation starting at client side
                                activator.CollectFromClientContext(ccm);                       
                            }
                            else
                            {
                                // activation starting at server side
                                // REVIEW: bool return ignored??
                                activator.DeliverClientContextToServerContext(ccm);
                            }
                        }
                        else
                        {
                            // IConstructionReturnMessage on its way back
                            if (bServerSide)
                            {
                                // activation returning from server side
                                activator.CollectFromServerContext((IConstructionReturnMessage)msg);
                            }
                            else
                            {
                                // activation back at client side
                                // REVIEW: bool return ignored??
                                activator.DeliverServerContextToClientContext((IConstructionReturnMessage)msg);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                IMethodCallMessage mcm = null;
                if (msg is IConstructionCallMessage)
                {
                    mcm = (IMethodCallMessage) msg;
                }
                else
                {
                    mcm = new ErrorMessage();
                }
                errMsg = new ReturnMessage(e, mcm);
                if (msg != null)
                {
                    ((ReturnMessage)errMsg).SetLogicalCallContext(
                            (LogicalCallContext)
                            msg.Properties[Message.CallContextKey]);
                }
            }
            return errMsg;
        }
    
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.ToString"]/*' />
	/// <internalonly/>
        public override String ToString()
        {
            return    "ContextID: " + _ctxID;
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~ Transition Support ~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        // This is the simple cross-context call back function invoke on
        // the context to do a call-back in.
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.DoCallBack"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public void DoCallBack(CrossContextDelegate deleg)
        {
            /*DBG Console.WriteLine("public DoCallBack: targetCtx: " 
            + Int32.Format(this.InternalContextID,"x")); DBG*/
                
            if (deleg == null)
            {
                throw new ArgumentNullException("deleg");
            }

            if ((_ctxFlags & CTX_FROZEN) == 0)
            {
                throw new RemotingException( 
                    Environment.GetResourceString(
                        "Remoting_Contexts_ContextNotFrozenForCallBack"));
            }

            Context currCtx = Thread.CurrentContext;
            if (currCtx == this)
            {
                // We are already in the target context, just execute deleg
                // NOTE: If in the future we decide to leave the context
                // and reenter it for this case we will need to change 
                // Context::RequestCallBack method in VM also!
                deleg();
            }
            else
            {                               
                // We pass 0 for target domain ID for x-context case.
                currCtx.DoCallBackGeneric(this.InternalContextID, deleg);
                GC.KeepAlive(this);
            }
        }

        // This is called when EE needs to do a transition and execute some
        // code. Before calling, EE determines if this is a x-domain case.              
        // targetDomainID will be 0 if it is a simple x-context call.
        //@TODO 64bit: privateData should be an intPtr
        internal static void DoCallBackFromEE(
            int targetCtxID, int privateData, int targetDomainID)
        {
            BCLDebug.Assert(targetCtxID != 0, "Bad transition context");
                
            /*DBG Console.WriteLine("private DoCallBackFromEE: targetCtx: " 
            + Int32.Format(targetCtxID,"x") 
            + " PvtData: " + Int32.Format(privateData,"x"));DBG*/

            if (targetDomainID == 0)
            {
                CallBackHelper cb = new CallBackHelper(
                                            privateData,
                                            true /*fromEE*/,
                                            targetDomainID); 
                CrossContextDelegate ctxDel = new CrossContextDelegate(cb.Func);
                Thread.CurrentContext.DoCallBackGeneric(targetCtxID, ctxDel);                                                                     
            }
            else
            {
                // for x-appdomain calls, we can't pass a delegate since that 
                //   would require us to deserialize it on the other side which
                //   is not allowed for non-public methods.
                TransitionCall msgCall = new TransitionCall(targetCtxID, privateData, targetDomainID);           
            
                Message.PropagateCallContextFromThreadToMessage(msgCall);
                //DBG Console.WriteLine("CallBackGeneric starting!");
                IMessage retMsg = Thread.CurrentContext.GetClientContextChain().SyncProcessMessage(msgCall); 
                Message.PropagateCallContextFromMessageToThread(retMsg);
            
                IMethodReturnMessage msg = retMsg as IMethodReturnMessage;
                if (null != msg)
                {
                    if (msg.Exception != null)
                        throw msg.Exception;
                }
            }
        } // DoCallBackFromEE

                // This is called by both the call back functions above.
        internal void DoCallBackGeneric(
            int targetCtxID, CrossContextDelegate deleg)
        {               
            TransitionCall msgCall = new TransitionCall(targetCtxID, deleg);           
            
            Message.PropagateCallContextFromThreadToMessage(msgCall);
            //DBG Console.WriteLine("CallBackGeneric starting!");
            IMessage retMsg = this.GetClientContextChain().SyncProcessMessage(msgCall); 
            Message.PropagateCallContextFromMessageToThread(retMsg);
            
            IMethodReturnMessage msg = retMsg as IMethodReturnMessage;
            if (null != msg)
            {
                if (msg.Exception != null)
                    throw msg.Exception;
            }
            //DBG Console.WriteLine("CallBackGeneric finished!");
        }
        
        // This is the E-Call that we route the EE-CallBack request to
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void ExecuteCallBackInEE(int privateData);        

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~ Context Local Store  ~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        private LocalDataStore MyLocalStore 
        {
            get 
            { 
                if (_localDataStore == null)
                {
                    // It's OK to lock the manager here because it is going to lock
                    // itself anyway.
                    lock (_localDataStoreMgr)
                    {
                        if (_localDataStore == null)
                        {
                            // The local store has not yet been created for this thread.
                            _localDataStore = _localDataStoreMgr.CreateLocalDataStore();
                        }
                    }
                }
                return _localDataStore;                
            }
        }
        
        //  All of these are exact shadows of corresponding ThreadLocalStore
        //  APIs.
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.AllocateDataSlot"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static LocalDataStoreSlot AllocateDataSlot()
        {
            return _localDataStoreMgr.AllocateDataSlot();            
        }
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.AllocateNamedDataSlot"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static LocalDataStoreSlot AllocateNamedDataSlot(String name)
        {
            return _localDataStoreMgr.AllocateNamedDataSlot(name);            
        }
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.GetNamedDataSlot"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static LocalDataStoreSlot GetNamedDataSlot(String name)
        {
            return _localDataStoreMgr.GetNamedDataSlot(name);            
        }
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.FreeNamedDataSlot"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static void FreeNamedDataSlot(String name)
        {
            _localDataStoreMgr.FreeNamedDataSlot(name);            
        }
        
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.SetData"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static void SetData(LocalDataStoreSlot slot, Object data)
        {
                        Thread.CurrentContext.MyLocalStore.SetData(slot, data);                    
        }
        
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.GetData"]/*' />
	/// <internalonly/>
       [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static Object GetData(LocalDataStoreSlot slot)
        {
            return Thread.CurrentContext.MyLocalStore.GetData(slot);              
        }
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~ Context Statics ~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        private int ReserveSlot()
        {
            // This will be called with the context crst held so we 
            // don't take a lock here)
            if (_ctxStatics == null)
            {
                // allocate the first bucket
                _ctxStatics = new Object[STATICS_BUCKET_SIZE];
                // set next bucket field to null
                _ctxStatics[0] = null;
                _ctxStaticsFreeIndex = 1;
                _ctxStaticsCurrentBucket = 0;
            }

            // See if we have to allocate a new bucket
            if (_ctxStaticsFreeIndex == STATICS_BUCKET_SIZE)
            {
                Object[] newBucket = new Object[STATICS_BUCKET_SIZE];

                // walk the chain to locate the last bucket
                Object[] bucket = _ctxStatics;
                while (bucket[0] != null)
                {
                    bucket = (Object[]) bucket[0];
                }
                // chain in the new bucket
                bucket[0] = newBucket;
                _ctxStaticsFreeIndex = 1;
                _ctxStaticsCurrentBucket++;
            }

            // bucket# in highWord, index in lowWord
            return _ctxStaticsFreeIndex++|_ctxStaticsCurrentBucket<<16;
        }
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~ End Context Statics ~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~ Dynamic Sink Support  ~~~~~~~~~~~~~~~~~~~~
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       //   This allows people to register a property implementing IContributeDynamicSink
       //   with the remoting service. Based on the obj and ctx parameters, the property
       //   is asked to contribute a sink that is placed at some location in the path of 
       //   remoting calls.
       //   The property may be unregistered, which implies that the sink will be dropped
       //   for subsequent remoting calls.
       //   If multiple properties are registered, their sinks may be called in an
       //   arbitrary order which may change between calls.
       //   
        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.RegisterDynamicProperty"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx)
        {
            bool fRegistered = false;

            if (prop == null || prop.Name == null || !(prop is IContributeDynamicSink))
            {
                throw new ArgumentNullException("prop");
            }
            if (obj != null && ctx != null)
            {
                // Exactly one of these is allowed to be non-null.
                throw new ArgumentException(Environment.GetResourceString("Argument_NonNullObjAndCtx"));
            }
            if (obj != null)
            {
                // ctx is ignored and must be null.
                fRegistered = IdentityHolder.AddDynamicProperty(obj, prop);                
            }
            else
            {
                // ctx may or may not be null
                fRegistered = Context.AddDynamicProperty(ctx, prop);
            }

            return fRegistered;
        }

        /// <include file='doc\Context.uex' path='docs/doc[@for="Context.UnregisterDynamicProperty"]/*' />
	/// <internalonly/>
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static bool UnregisterDynamicProperty(String name, ContextBoundObject obj, Context ctx)
        {
            bool fUnregister = false;

            // name, obj, ctx arguments should be exactly the same as a previous
            // RegisterDynamicProperty call
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (obj != null && ctx != null)
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_NonNullObjAndCtx"));
            }
            if (obj != null)
            {
                // ctx is ignored and must be null.
                fUnregister = IdentityHolder.RemoveDynamicProperty(obj, name);
            }
            else
            {
                // ctx may or may not be null
                fUnregister = Context.RemoveDynamicProperty(ctx, name);
            }

            return fUnregister;
        }

        /*
         *  Support for dynamic sinks at context level
         *
         */        
        internal static bool AddDynamicProperty(Context ctx, IDynamicProperty prop)
        {
            // Check if we have a property by this name
            if (ctx != null)
            {
                return ctx.AddPerContextDynamicProperty(prop);
            }
            else
            {
                // We have to add a sink that should fire for all contexts
                return AddGlobalDynamicProperty(prop);
            }
        }
    
        private bool AddPerContextDynamicProperty(IDynamicProperty prop)
        {
            if (_dphCtx == null)
            {
                DynamicPropertyHolder dph = new DynamicPropertyHolder();
                lock (this)
                {
                    if (_dphCtx == null)
                    {
                        _dphCtx = dph;
                    }
                }
            }
            return _dphCtx.AddDynamicProperty(prop);
        }
        
        private static bool AddGlobalDynamicProperty(IDynamicProperty prop)
        {
            return _dphGlobal.AddDynamicProperty(prop);
        }
        
        internal static bool RemoveDynamicProperty(Context ctx, String name)
        {
            if (ctx != null)
            {
                return ctx.RemovePerContextDynamicProperty(name);
            }
            else
            {
                // We have to remove a global property
                return RemoveGlobalDynamicProperty(name);                        
            }
        }
    
        private bool RemovePerContextDynamicProperty(String name)
        {
            // We have to remove a property for this context
            if (_dphCtx == null)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_Contexts_NoProperty"),
                        name
                        ));
            }
            return _dphCtx.RemoveDynamicProperty(name);
        }
    
        private static bool RemoveGlobalDynamicProperty(String name)
        {
            return _dphGlobal.RemoveDynamicProperty(name);
        }
    
        /*
         *  Returns an array of context specific dynamic properties
         *  registered for this context. The number of such properties
         *  is designated by length of the returned array.
         */
        internal virtual IDynamicProperty[] PerContextDynamicProperties
        {
            get 
            {
                if (_dphCtx == null)
                {
                    return null;
                }   
                else
                {
                    return _dphCtx.DynamicProperties;
                }
            }
        }
    
        /*
         *  Returns an array of global dynamic properties
         *  registered (for all contexts). The number of such properties
         *  is designated by length of the returned array.
         */    
        internal static  IDynamicProperty[] GlobalDynamicProperties
        {
            get
            {
                lock(typeof(Context)) 
                {
                    return _dphGlobal.DynamicProperties;                
                }            
            }
        }
        
        internal static ArrayWithSize GlobalDynamicSinks
        {
            get 
            {
                return _dphGlobal.DynamicSinks;
            }
        }
    
        internal virtual ArrayWithSize DynamicSinks
        {
            get
            {
                if (_dphCtx == null)
                {
                    return null;
                }
                else
                {
                    return _dphCtx.DynamicSinks;
                }
            }
        }    

        internal virtual bool NotifyDynamicSinks(
            IMessage msg,
            bool bCliSide, 
            bool bStart, 
            bool bAsync,
            bool bNotifyGlobals)
        {
            bool bHasDynamicSinks = false;
        
            if (bNotifyGlobals && (_dphGlobal.DynamicProperties != null))
            {
                ArrayWithSize globalSinks = GlobalDynamicSinks;
                if (globalSinks != null)
                {
                    DynamicPropertyHolder.NotifyDynamicSinks(
                                    msg, 
                                    globalSinks, 
                                    bCliSide,
                                    bStart,
                                    bAsync);
                    bHasDynamicSinks = true;
                }
            }
            
            ArrayWithSize perCtxSinks = DynamicSinks;
            if (perCtxSinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                    msg, 
                                    perCtxSinks, 
                                    bCliSide,
                                    bStart,
                                    bAsync);
                bHasDynamicSinks = true;
            }

            return bHasDynamicSinks;
        } // NotifyDynamicSinks
        
        //******************** END: Dynamic Sink Support ********************        
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //~~~~~~~~~~~~~~~~~~~ More Transition Support ~~~~~~~~~~~~~~~~~~~
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // This class is used as the backing object that implements a delegate
    // function to be used for internal call-backs. The delegate type must
    // be CrossContextDelegate (void Func(void) below) since we are using 
    // the DoCallBackGeneric also as the underlying mechanism for the 
    // exposed cross-context callbacks.
    [Serializable]
    internal class CallBackHelper
    {
        // Some flag definitions
        internal const int RequestedFromEE = 0x00000001;   // callBack from EE
        internal const int XDomainTransition= 0x00000100;  // going x-domain

        internal bool IsEERequested 
        { 
            get {return (_flags&RequestedFromEE)==RequestedFromEE;} 
            set {if (value) {_flags |= RequestedFromEE;}}                   
        }
            
        internal bool IsCrossDomain
        {
            get {return (_flags&XDomainTransition)==XDomainTransition;} 
            set {if (value) {_flags |= XDomainTransition;}}                 
        }
        
        int _flags;     
        int _privateData;

        internal CallBackHelper(int privateData, bool bFromEE, int targetDomainID)
        {
            this.IsEERequested = bFromEE;
            this.IsCrossDomain = (targetDomainID!=0);
            _privateData = privateData;
        }

        internal void Func()
        {
            /*DBG Console.WriteLine("DelegHelper::Func CTX:" 
            + Int32.Format(Thread.CurrentContext.InternalContextID,"x")
            +Environment.NewLine + "DMN: " + Int32.Format(Thread.GetDomainIDInternal(),"x")); DBG*/
            if (IsEERequested)
            {
                //DBG Console.WriteLine("Executing EE callback ");
                
                // EE requested this call back, call EE with its private data
                Context.ExecuteCallBackInEE(_privateData);
                
                //DBG Console.WriteLine("Execute CallBackInEE returned: " + Int32.Format(_retVal,"x"));
            }                       
            else
            {                       
                //DBG Console.WriteLine("Executing non-EE internal callback");
            }                       
        }
    }       // class CallBackHelper

    // this is used to declare a frame on the stack to track context transtions
    internal struct ContextTransitionFrame 
    {
        Int32 _vfptr;
        Int32 _next;
        Int32 _ehHandlerNext;
        Int32 _ehHandler;
        Int32 _returnContext;
        Int32 _returnLogicalCallContext;
        Int32 _returnIllogicalCallContext;
        Int32 _win32context;

#if _DEBUG
        internal Int32 NeverCallThis()
        {
            BCLDebug.Assert(false,"NeverCallThis");
            _returnLogicalCallContext = _returnIllogicalCallContext = _vfptr = _next = _returnContext = _ehHandlerNext = _ehHandler = RemotingServices.TrashMemory;
            return _returnLogicalCallContext + _returnIllogicalCallContext + _vfptr + _next + _returnContext + _ehHandlerNext + _ehHandler;
        }
#endif
    }

}       //nameSpace Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\configuration.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    Configuration.cs
**
** Author:  Tarun Anand (TarunA)
**
** Purpose: Classes used for reading and storing configuration
**
** Date:    Sep 30, 2000
**
===========================================================*/
namespace System.Runtime.Remoting {

    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Contexts;    
    using System.Runtime.Remoting.Lifetime;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Threading;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;

    
    /// <include file='doc\Configuration.uex' path='docs/doc[@for="WellKnownObjectMode"]/*' />
    [Serializable]
    public enum WellKnownObjectMode
    {
        /// <include file='doc\Configuration.uex' path='docs/doc[@for="WellKnownObjectMode.Singleton"]/*' />
        Singleton   = 1,
        /// <include file='doc\Configuration.uex' path='docs/doc[@for="WellKnownObjectMode.SingleCall"]/*' />
        SingleCall  = 2
    }

    // This is the class that plays the role of per-appDomain statics
    // till we have the real functionality.
    internal class DomainSpecificRemotingData
    {
        const int  ACTIVATION_INITIALIZING  = 0x00000001;
        const int  ACTIVATION_INITIALIZED   = 0x00000002;        
        const int  ACTIVATOR_LISTENING      = 0x00000004;
        
        LocalActivator _LocalActivator;
        ActivationListener _ActivationListener;       
        IContextProperty[]  _appDomainProperties;
        int _flags;
        Object _ConfigLock;
        ChannelServicesData _ChannelServicesData;
                LeaseManager _LeaseManager;
        ReaderWriterLock _IDTableLock;

        internal DomainSpecificRemotingData()
        {            
            _flags = 0;
            _ConfigLock = new Object();
            _ChannelServicesData = new ChannelServicesData();
            _IDTableLock = new ReaderWriterLock();

            // Add the Lifetime service property to the appdomain.
            // For now we are assuming that this is the only property
            // If there are more properties, then an existing array
                        // will need to be expanded to add this property
                        // The property needs to be added here so that the default context
                        // for an appdomain has lifetime services activated

            _appDomainProperties = new IContextProperty[1];
            _appDomainProperties[0] = new System.Runtime.Remoting.Lifetime.LeaseLifeTimeServiceProperty();
        }

        internal LeaseManager LeaseManager
        {
            get 
            { 
                return _LeaseManager; 
            }
            set 
            {  
                _LeaseManager = value; 
            }
        }
                

        // This lock object is exposed for various objects that need to synchronize
        // there configuration behavior.
        internal Object ConfigLock
        {
            get { return _ConfigLock; }
        }

        // This is the rwlock used by the uri table functions
        internal ReaderWriterLock IDTableLock
        {
            get { return _IDTableLock; }
        }


        internal Hashtable URITable
        {
            get
            {   
                return IdentityHolder.URITable;
            }
        }

        internal LocalActivator LocalActivator
        {
            get{return _LocalActivator;}
            set{_LocalActivator=value;}
        }

        internal ActivationListener ActivationListener
        {
            get {return _ActivationListener;}
            set {_ActivationListener=value;}
        }

        // access to InitializingActivation, ActivationInitialized
        // and ActivatorListening should be guarded by ConfigLock
        // by the caller.
        internal bool InitializingActivation
        {
            get {return (_flags & ACTIVATION_INITIALIZING) == ACTIVATION_INITIALIZING;}
            set 
            {
                if (value == true)
                {
                    _flags = _flags | ACTIVATION_INITIALIZING;
                }
                else
                {
                    _flags = _flags & ~ACTIVATION_INITIALIZING;
                }
            }
        }

        internal bool ActivationInitialized
        {
            get {return (_flags & ACTIVATION_INITIALIZED) == ACTIVATION_INITIALIZED;}
            set 
            {
                if (value == true)
                {
                    _flags = _flags | ACTIVATION_INITIALIZED;
                }
                else
                {
                    _flags = _flags & ~ACTIVATION_INITIALIZED;
                }
            }

        }

        internal bool ActivatorListening
        {
            get {return (_flags & ACTIVATOR_LISTENING) == ACTIVATOR_LISTENING;}
            set 
            {
                if (value == true)
                {
                    _flags = _flags | ACTIVATOR_LISTENING;
                }
                else
                {
                    _flags = _flags & ~ACTIVATOR_LISTENING;
                }
            }

        }
        
        
        internal IContextProperty[] AppDomainContextProperties
        {
            get { return _appDomainProperties; }
            set { _appDomainProperties = value; }
        } 

        internal ChannelServicesData ChannelServicesData
        {
            get 
            {
                return _ChannelServicesData;
            }
        }
    } // class DomainSpecificRemotingData




    //------------------------------------------------------------------    
    //--------------------- Remoting Configuration ---------------------    
    //------------------------------------------------------------------    
    internal sealed class RemotingConfigHandler
    {
        static String _applicationName;
        static CustomErrorsModes _errorMode = CustomErrorsModes.RemoteOnly;
        static bool _errorsModeSet = false;
        static bool _bMachineConfigLoaded = false;
        static bool _bUrlObjRefMode = false;

        static Queue _delayLoadChannelConfigQueue = new Queue(); // queue of channels we might be able to use
        

        // All functions of RemotingConfigHandler operate upon the config
        // data stored on a per appDomain basis 
        public static RemotingConfigInfo Info = new RemotingConfigInfo();

        private const String _machineConfigFilename = "machine.config";
        

        internal static String ApplicationName
        {
            get
            {
                if (_applicationName == null)
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Config_NoAppName"));
                }
                return _applicationName;
            }

            set
            {
                if (_applicationName != null)
                {
                    throw new RemotingException(
                        String.Format(
                        Environment.GetResourceString("Remoting_Config_AppNameSet"),
                         _applicationName));
                }
                
                _applicationName = value;

                // get rid of any starting or trailing slashes
                char[] slash = new char[]{'/'};
                if (_applicationName.StartsWith("/"))
                    _applicationName = _applicationName.TrimStart(slash);
                if (_applicationName.EndsWith("/"))
                    _applicationName = _applicationName.TrimEnd(slash);
            }
        }

        internal static bool HasApplicationNameBeenSet()
        {
            return _applicationName != null;
        }

        internal static bool UrlObjRefMode
        {
            get { return _bUrlObjRefMode; }
        }
        
        internal static CustomErrorsModes  CustomErrorsMode 
        {
           get { 
                return _errorMode; 
           }
           set
           {
                if (_errorsModeSet)                
                    throw new RemotingException(Environment.GetResourceString("Remoting_Config_ErrorsModeSet"));                        
                
                _errorsModeSet = true;               
                _errorMode = value;
           }
           
        }
        
        internal static IMessageSink FindDelayLoadChannelForCreateMessageSink(
            String url, Object data, out String objectURI)
        {
            LoadMachineConfigIfNecessary();
        
            objectURI = null;
            IMessageSink msgSink = null;
        
            foreach (DelayLoadClientChannelEntry entry in _delayLoadChannelConfigQueue)
            {
                IChannelSender channel = entry.Channel;

                // if the channel is null, that means it has already been registered.
                if (channel != null)
                {
                    msgSink = channel.CreateMessageSink(url, data, out objectURI);
                    if (msgSink != null)
                    {
                        entry.RegisterChannel();
                        return msgSink;
                    }
                }
            }

            return null;
        } // FindChannelForCreateMessageSink



        internal static void LoadMachineConfigIfNecessary()
        {                    
            // Load the machine.config file if we haven't already
            if (!_bMachineConfigLoaded)
            {
                lock (Info)
                {
                    if (!_bMachineConfigLoaded)
                    {
                        
                        String machineDirectory = System.Security.Util.Config.MachineDirectory;                        
                        String longFileName = machineDirectory 
                                            + _machineConfigFilename;
                        new FileIOPermission(FileIOPermissionAccess.Read, longFileName).Assert();

                        RemotingXmlConfigFileData configData =
                            LoadConfigurationFromXmlFile(
                                longFileName);

                        if (configData != null)
                            ConfigureRemoting(configData);
                        
                        _bMachineConfigLoaded = true;
                    }
                }
            }
        } // LoadMachineConfigIfNecessary
                

        internal static void DoConfiguration(String filename)
        {        
            LoadMachineConfigIfNecessary();
        
            // load specified config file
            RemotingXmlConfigFileData configData = LoadConfigurationFromXmlFile(filename);

            // Configure remoting based on data loaded from the config file.
            // By design, we do nothing if no remoting config information was
            // present in the file.
            if (configData != null)
                ConfigureRemoting(configData);
        }
        
        private static RemotingXmlConfigFileData LoadConfigurationFromXmlFile(String filename)
        {
            try
            {
                if (filename != null)
                    return RemotingXmlConfigFileParser.ParseConfigFile(filename);
                else
                    return null;
            }
            catch (Exception e)
            {
                Exception inner =  e.InnerException as FileNotFoundException;
                if (inner != null)
                {
                    // if the file is missing, this gives a clearer message
                    e = inner;
                }
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Config_ReadFailure"),
                        filename,
                        e));
            }
        } // LoadConfigurationFromXmlFile       


        private static void ConfigureRemoting(RemotingXmlConfigFileData configData)
        {
            try
            {
                String appName = configData.ApplicationName;
                if (appName != null)
                    ApplicationName = appName;
                
                if (configData.CustomErrors != null)
                    _errorMode = configData.CustomErrors.Mode;
                
                // configure channels
                ConfigureChannels(configData);
            
                // configure lifetime
                if (configData.Lifetime != null)
                {
                    if (configData.Lifetime.IsLeaseTimeSet)
                        LifetimeServices.LeaseTime = configData.Lifetime.LeaseTime;
                    if (configData.Lifetime.IsRenewOnCallTimeSet)
                        LifetimeServices.RenewOnCallTime = configData.Lifetime.RenewOnCallTime;
                    if (configData.Lifetime.IsSponsorshipTimeoutSet)    
                        LifetimeServices.SponsorshipTimeout = configData.Lifetime.SponsorshipTimeout;
                    if (configData.Lifetime.IsLeaseManagerPollTimeSet)
                        LifetimeServices.LeaseManagerPollTime = configData.Lifetime.LeaseManagerPollTime;
                }

                _bUrlObjRefMode = configData.UrlObjRefMode;

                // configure other entries
                Info.StoreRemoteAppEntries(configData);
                Info.StoreActivatedExports(configData);
                Info.StoreInteropEntries(configData);
                Info.StoreWellKnownExports(configData);

                // start up activation listener if there are any activated objects exposed
                if (configData.ServerActivatedEntries.Count > 0)
                    ActivationServices.StartListeningForRemoteRequests();                
            }
            catch (Exception e)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Config_ConfigurationFailure"),                        
                        e));
            }
        } // ConfigureRemoting
        

        // configures channels loaded from remoting config file.
        private static void ConfigureChannels(RemotingXmlConfigFileData configData)
        {
            // Register our x-context & x-AD channels first
            RemotingServices.RegisterWellKnownChannels();
            
            foreach (RemotingXmlConfigFileData.ChannelEntry entry in configData.ChannelEntries)
            {
                if (!entry.DelayLoad)
                {
                    IChannel chnl = CreateChannelFromConfigEntry(entry);
                    ChannelServices.RegisterChannel(chnl);
                }
                else
                    _delayLoadChannelConfigQueue.Enqueue(new DelayLoadClientChannelEntry(entry));
            }
        } //  ConfigureChannels


        internal static IChannel CreateChannelFromConfigEntry(
            RemotingXmlConfigFileData.ChannelEntry entry)
        {       
            Type type = RemotingConfigInfo.LoadType(entry.TypeName, entry.AssemblyName);
            
            bool isServerChannel = typeof(IChannelReceiver).IsAssignableFrom(type);
            bool isClientChannel = typeof(IChannelSender).IsAssignableFrom(type);

            IClientChannelSinkProvider clientProviderChain = null;
            IServerChannelSinkProvider serverProviderChain = null;

            if (entry.ClientSinkProviders.Count > 0)
                clientProviderChain = CreateClientChannelSinkProviderChain(entry.ClientSinkProviders);
            if (entry.ServerSinkProviders.Count > 0)
                serverProviderChain = CreateServerChannelSinkProviderChain(entry.ServerSinkProviders);

            // construct argument list
            Object[] args;
            
            if (isServerChannel && isClientChannel)
            {
                args = new Object[3];
                args[0] = entry.Properties;
                args[1] = clientProviderChain;
                args[2] = serverProviderChain;
            }
            else
            if (isServerChannel)
            {
                args = new Object[2];
                args[0] = entry.Properties;
                args[1] = serverProviderChain;
            }
            else
            if (isClientChannel)
            {
                args = new Object[2];
                args[0] = entry.Properties;
                args[1] = clientProviderChain;
            }
            else
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_Config_InvalidChannelType"), 
                    type.FullName));
            }

            IChannel channel = null;

            try
            {
                channel = (IChannel)Activator.CreateInstance(type, 
                                                        BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, 
                                                        null, 
                                                        args, 
                                                        null, 
                                                        null);

            }
            catch (MissingMethodException)
            {
                String ctor = null;
                
                if (isServerChannel && isClientChannel)
                    ctor = "MyChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider)";
                else
                if (isServerChannel)
                    ctor = "MyChannel(IDictionary properties, IServerChannelSinkProvider serverSinkProvider)";
                else
                if (isClientChannel)
                    ctor = "MyChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider)";
                
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_Config_ChannelMissingCtor"),
                    type.FullName, ctor));
            }
            
            return channel;
        } //  CreateChannelFromEntry


        // create a client sink provider chain
        private static IClientChannelSinkProvider CreateClientChannelSinkProviderChain(ArrayList entries)
        {   
            IClientChannelSinkProvider chain = null;
            IClientChannelSinkProvider current = null;
            
            foreach (RemotingXmlConfigFileData.SinkProviderEntry entry in entries)
            {
                if (chain == null)
                {
                    chain = (IClientChannelSinkProvider)CreateChannelSinkProvider(entry, false);
                    current = chain;
                }
                else
                {
                    current.Next = (IClientChannelSinkProvider)CreateChannelSinkProvider(entry, false);
                    current = current.Next;
                }
            }

            return chain;
        } // CreateClientChannelSinkProviderChain


        // create a client sink provider chain
        private static IServerChannelSinkProvider CreateServerChannelSinkProviderChain(ArrayList entries)
        {   
            IServerChannelSinkProvider chain = null;
            IServerChannelSinkProvider current = null;
            
            foreach (RemotingXmlConfigFileData.SinkProviderEntry entry in entries)
            {
                if (chain == null)
                {
                    chain = (IServerChannelSinkProvider)CreateChannelSinkProvider(entry, true);
                    current = chain;
                }
                else
                {
                    current.Next = (IServerChannelSinkProvider)CreateChannelSinkProvider(entry, true);
                    current = current.Next;
                }
            }

            return chain;
        } // CreateServerChannelSinkProviderChain
            

        // create a sink provider from the config file data
        private static Object CreateChannelSinkProvider(RemotingXmlConfigFileData.SinkProviderEntry entry,
                                                        bool bServer)
        {
            Object sinkProvider = null;

            Type type = RemotingConfigInfo.LoadType(entry.TypeName, entry.AssemblyName);            

            if (bServer)
            {
                // make sure this is a client provider                
                if (!typeof(IServerChannelSinkProvider).IsAssignableFrom(type))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString("Remoting_Config_InvalidSinkProviderType"),
                            type.FullName,
                            "IServerChannelSinkProvider"));
                }
            }
            else
            {
                // make sure this is a server provider
                if (!typeof(IClientChannelSinkProvider).IsAssignableFrom(type))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString("Remoting_Config_InvalidSinkProviderType"),
                            type.FullName,
                            "IClientChannelSinkProvider"));
                }
            }

            // check to see if something labelled as a formatter is a formatter
            if (entry.IsFormatter)
            {
                if ((bServer && !typeof(IServerFormatterSinkProvider).IsAssignableFrom(type)) ||
                    (!bServer && !typeof(IClientFormatterSinkProvider).IsAssignableFrom(type)))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString("Remoting_Config_SinkProviderNotFormatter"),
                            type.FullName));
                }
            }                        
            
            // setup the argument list and call the constructor
            Object[] args = new Object[2];
            args[0] = entry.Properties;
            args[1] = entry.ProviderData;

            try
            {
                sinkProvider = Activator.CreateInstance(type, 
                                                        BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, 
                                                        null, 
                                                        args, 
                                                        null, 
                                                        null);
            }
            catch (MissingMethodException)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_Config_SinkProviderMissingCtor"),
                        type.FullName, 
                        "MySinkProvider(IDictionary properties, ICollection providerData)"));
            }

            return sinkProvider;
        } // CreateChannelSinkProvider
        
        // This is used at the client end to check if an activation needs
        // to go remote.
        internal static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType)
        {
            RemotingTypeCachedData cache = (RemotingTypeCachedData)
                InternalRemotingServices.GetReflectionCachedData(svrType);
        
            String assemblyName = cache.SimpleAssemblyName;
            ActivatedClientTypeEntry entry = Info.QueryRemoteActivate(svrType.FullName, assemblyName);

            if (entry == null)
            {
                entry = Info.QueryRemoteActivate(svrType.Name, assemblyName);
            }
            return entry;
        } // IsRemotelyActivatedClientType

        
        // This is used at the client end to check if an activation needs
        // to go remote.
        internal static ActivatedClientTypeEntry IsRemotelyActivatedClientType(String typeName, String assemblyName)
        {
            return Info.QueryRemoteActivate(typeName, assemblyName);
        }


        // This is used at the client end to check if a "new Foo" needs to
        // happen via a Connect() under the covers.
        internal static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType)
        {
            RemotingTypeCachedData cache = (RemotingTypeCachedData)
                InternalRemotingServices.GetReflectionCachedData(svrType);
        
            String assemblyName = cache.SimpleAssemblyName;
            WellKnownClientTypeEntry wke = Info.QueryConnect(svrType.FullName, assemblyName);
            if (wke == null)
            {
                wke= Info.QueryConnect(svrType.Name, assemblyName);
            }
            return wke;
        }

        // This is used at the client end to check if a "new Foo" needs to
        // happen via a Connect() under the covers.
        internal static WellKnownClientTypeEntry IsWellKnownClientType(String typeName, 
                                                                       String assemblyName)
        {
            return Info.QueryConnect(typeName, assemblyName);
        }

        // This is used at the server end to check if a type being activated
        // is explicitly allowed by the server.
        internal static bool IsActivationAllowed(Type svrType)
        {
            if (svrType == null)
                return false;

            RemotingTypeCachedData cache = (RemotingTypeCachedData)
                InternalRemotingServices.GetReflectionCachedData(svrType);
        
            String assemblyName = cache.SimpleAssemblyName;

            return Info.ActivationAllowed(svrType.FullName, assemblyName);
        } // IsActivationAllowed


        // This is the flavor that we call from the activation listener
        // code path. This ensures that we don't load a type before checking
        // that it is configured for remote activation
        internal static bool IsActivationAllowed(String svrTypeName)
        {
            if (svrTypeName == null)
            {
                return false;
            }
            String typeName;
            String asmName;

            int index = svrTypeName.IndexOf(',');
            if (index == -1 || index == svrTypeName.Length-1)
            {
                // We expect at least a "type, asm" format
                return false;
            }

            typeName = svrTypeName.Substring(0, index);
            asmName = svrTypeName.Substring(index+1).Trim();
            if (asmName == null)
            {
                return false;
            }

            index = asmName.IndexOf(',');
            if (index != -1)
            {
                // strip off the version info
                asmName = asmName.Substring(0,index);
            }
            return Info.ActivationAllowed(typeName, asmName);
        }


        // Used at server end to obtain attributes that configuration says to use for
        //   activation.
        internal static IContextAttribute[] GetContextAttributesForServerActivatedType(Type type)
        {
            // FUTURE: Use this in V.Next when/if allow specification of ContextAttributes
            //   in config files.
            return Info.GetContextAttributesForServerActivatedType(type);
        }



        // helper for Configuration::RegisterActivatedServiceType
        internal static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry)
        {   
            Info.AddActivatedType(entry.TypeName, entry.AssemblyName, 
                                  entry.ContextAttributes);
        } // RegisterActivatedServiceType

        
        // helper for Configuration::RegisterWellKnownServiceType
        internal static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry)
        {
            BCLDebug.Trace("REMOTE", "Adding well known service type for " + entry.ObjectUri);
            // FUTURE: Add support ContextAttributes.
            String serverType = entry.TypeName;
            String asmName = entry.AssemblyName;
            String URI = entry.ObjectUri;
            WellKnownObjectMode mode = entry.Mode;
            
            lock (Info)
            {            
                // We make an entry in our config tables so as to keep
                // both the file-based and programmatic config in sync.
                Info.AddWellKnownEntry(entry);
            }
        } // RegisterWellKnownServiceType


        // helper for Configuration::RegisterActivatedClientType
        internal static void RegisterActivatedClientType(ActivatedClientTypeEntry entry)
        {
            Info.AddActivatedClientType(entry);
        }

        // helper for Configuration::RegisterWellKnownClientType
        internal static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry)
        {
            Info.AddWellKnownClientType(entry);
        } 

        //helper for Configuration::GetServerTypeForUri
        internal static Type GetServerTypeForUri(String URI)
        {
            URI = Identity.RemoveAppNameOrAppGuidIfNecessary(URI);
            return Info.GetServerTypeForUri(URI);
        }
        
        // helper for Configuration::GetRegisteredActivatedServiceTypes
        internal static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes()
        {
            return Info.GetRegisteredActivatedServiceTypes();
        } // GetRegisteredActivatedServiceTypes

        // helper for Configuration::GetRegisteredWellKnownServiceTypes
        internal static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes()
        {
            return Info.GetRegisteredWellKnownServiceTypes();
        } // GetRegisteredWellKnownServiceTypes

        // helper for Configuration::GetRegisteredActivatedClientTypes
        internal static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes()
        {
            return Info.GetRegisteredActivatedClientTypes();
        } // GetRegisteredActivatedClientTypes

        // helper for Configuration::GetRegisteredWellKnownClientTypes
        internal static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes()
        {
            return Info.GetRegisteredWellKnownClientTypes();
        } // GetRegisteredWellKnownClientTypes
        

        // helper for creating well known objects on demand
        internal static ServerIdentity CreateWellKnownObject(String uri)
        {
            uri = Identity.RemoveAppNameOrAppGuidIfNecessary(uri);
            return Info.StartupWellKnownObject(uri);
        }
        

        internal class RemotingConfigInfo
        {
            Hashtable _exportableClasses; // list of objects that can be client-activated
                                          // (this should be a StringTable since we only use the key,
                                          //  but that type was removed from the BCL :( )
            Hashtable _remoteTypeInfo;
            Hashtable _remoteAppInfo;
            Hashtable _wellKnownExportInfo; //well known exports indexed by object URI in lower-case            
          
            static char[] SepSpace = {' '};
            static char[] SepPound = {'#'};
            static char[] SepSemiColon = {';'};
            static char[] SepEquals = {'='};

            private static Object s_wkoStartLock = new Object();
            private static PermissionSet s_fullTrust = new PermissionSet(PermissionState.Unrestricted);

            internal RemotingConfigInfo()
            {
                // FUTURE: delay create these for perf!
                _remoteTypeInfo = Hashtable.Synchronized(new Hashtable());

                _exportableClasses = Hashtable.Synchronized(new Hashtable());

                _remoteAppInfo = Hashtable.Synchronized(new Hashtable());
                _wellKnownExportInfo = Hashtable.Synchronized(new Hashtable());
            }


            // encodes type name and assembly name into one string for purposes of
            //   indexing in lists and hash tables
            private String EncodeTypeAndAssemblyNames(String typeName, String assemblyName)
            {
                return typeName + ", " + assemblyName.ToLower(CultureInfo.InvariantCulture);
            }
            

            //
            // XML Configuration Helper Functions
            //

            internal void StoreActivatedExports(RemotingXmlConfigFileData configData)
            {
                foreach (RemotingXmlConfigFileData.TypeEntry entry in configData.ServerActivatedEntries)
                {
                    ActivatedServiceTypeEntry aste =
                        new ActivatedServiceTypeEntry(entry.TypeName, entry.AssemblyName);
                    aste.ContextAttributes = 
                        CreateContextAttributesFromConfigEntries(entry.ContextAttributes);
                
                    RemotingConfiguration.RegisterActivatedServiceType(aste);
                }
            } // StoreActivatedExports

            internal void StoreInteropEntries(RemotingXmlConfigFileData configData)
            {
                // process interop xml element entries
                foreach (RemotingXmlConfigFileData.InteropXmlElementEntry entry in
                         configData.InteropXmlElementEntries)
                {
                    Type type = RuntimeType.GetTypeInternal(entry.UrtTypeName + ", " + entry.UrtAssemblyName, false, false, false);
                    SoapServices.RegisterInteropXmlElement(entry.XmlElementName,
                                                           entry.XmlElementNamespace,
                                                           type);
                }

                // process interop xml type entries
                foreach (RemotingXmlConfigFileData.InteropXmlTypeEntry entry in
                         configData.InteropXmlTypeEntries)
                {
                    Type type = RuntimeType.GetTypeInternal(entry.UrtTypeName + ", " + entry.UrtAssemblyName, false, false, false);
                    SoapServices.RegisterInteropXmlType(entry.XmlTypeName,
                                                        entry.XmlTypeNamespace,
                                                        type);
                }

                // process preload entries
                foreach (RemotingXmlConfigFileData.PreLoadEntry entry in configData.PreLoadEntries)
                {
                    if (entry.TypeName != null)
                    {
                        Type type = RuntimeType.GetTypeInternal(entry.TypeName + ", " + entry.AssemblyName, false, false, false);
                        SoapServices.PreLoad(type);
                    }
                    else
                    {
                        Assembly assembly = Assembly.Load(entry.AssemblyName);
                        SoapServices.PreLoad(assembly);
                    }
                }
            } // StoreInteropEntries

            internal void StoreRemoteAppEntries(RemotingXmlConfigFileData configData)
            {
                char[] slash = new char[]{'/'};
            
                // add each remote app to the table
                foreach (RemotingXmlConfigFileData.RemoteAppEntry remApp in configData.RemoteAppEntries)
                {
                    // form complete application uri by combining specified uri with app-name
                    //  (make sure appUri ends with slash, and that app name doesn't start,
                    //   with one. then make sure that the combined form has no trailing slashes).
                    String appUri = remApp.AppUri;
                    if ((appUri != null) && !appUri.EndsWith("/"))
                        appUri = appUri.TrimEnd(slash);
                        
                    // add each client activated type for this remote app
                    foreach (RemotingXmlConfigFileData.TypeEntry cae in remApp.ActivatedObjects)
                    {
                        ActivatedClientTypeEntry acte = 
                            new ActivatedClientTypeEntry(cae.TypeName, cae.AssemblyName, 
                                                         appUri);
                        acte.ContextAttributes = 
                            CreateContextAttributesFromConfigEntries(cae.ContextAttributes);
                   
                        RemotingConfiguration.RegisterActivatedClientType(acte);
                    }

                    // add each well known object for this remote app
                    foreach (RemotingXmlConfigFileData.ClientWellKnownEntry cwke in remApp.WellKnownObjects)
                    {                    
                        WellKnownClientTypeEntry wke = 
                            new WellKnownClientTypeEntry(cwke.TypeName, cwke.AssemblyName, 
                                                         cwke.Url);
                        wke.ApplicationUrl = appUri;
                        
                        RemotingConfiguration.RegisterWellKnownClientType(wke);
                    }          
                }
            } // StoreRemoteAppEntries            

            internal void StoreWellKnownExports(RemotingXmlConfigFileData configData)
            {
                // FUTURE: Add support for context attributes.
            
                foreach (RemotingXmlConfigFileData.ServerWellKnownEntry entry in configData.ServerWellKnownEntries)
                {
                    WellKnownServiceTypeEntry wke = 
                        new WellKnownServiceTypeEntry(
                            entry.TypeName, entry.AssemblyName, entry.ObjectURI, 
                            entry.ObjectMode);
                    wke.ContextAttributes = null;
                
                    // Register the well known entry but do not startup the object
                    RemotingConfigHandler.RegisterWellKnownServiceType(wke);
                }
            } // StoreWellKnownExports
            

            // helper functions for above configuration helpers

            static IContextAttribute[] CreateContextAttributesFromConfigEntries(ArrayList contextAttributes)
            {
                // create context attribute entry list
                int numAttrs = contextAttributes.Count;
                if (numAttrs == 0)
                    return null;
                
                IContextAttribute[] attrs = new IContextAttribute[numAttrs];

                int co = 0;
                foreach (RemotingXmlConfigFileData.ContextAttributeEntry cae in contextAttributes)
                {
                    Assembly asm = Assembly.Load(cae.AssemblyName);  

                    IContextAttribute attr = null;
                    Hashtable properties = cae.Properties;                    
                    if ((properties != null) && (properties.Count > 0))
                    {
                        Object[] args = new Object[1];
                        args[0] = properties;

                        // We explicitly allow the ability to create internal
                        // only attributes
                        attr = (IContextAttribute)
                            Activator.CreateInstance(
                                asm.GetTypeInternal(cae.TypeName, false, false, false), 
                                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, 
                                null, 
                                args, 
                                null, 
                                null);
                    }
                    else
                    {
                        attr = (IContextAttribute)
                            Activator.CreateInstance(
                                asm.GetTypeInternal(cae.TypeName, false, false, false), 
                                true);
                    }
                    
                    attrs[co++] = attr; 
                }

                return attrs;
            } // CreateContextAttributesFromConfigEntries

            //
            // end of XML configuration helper functions
            //

            internal bool ActivationAllowed(String typeName, String assemblyName)
            {
                // the assembly name is stored in lower-case to let it be case-insensitive
                return _exportableClasses.ContainsKey(EncodeTypeAndAssemblyNames(typeName, assemblyName));
            }

            // retrieve list of attributes to use when initializing this type
            internal IContextAttribute[] GetContextAttributesForServerActivatedType(Type type)
            {
                RemotingTypeCachedData cache = (RemotingTypeCachedData)
                    InternalRemotingServices.GetReflectionCachedData(type);
        
                String assemblyName = cache.SimpleAssemblyName;           
                String typeName = type.Name;
            
                ActivatedServiceTypeEntry activatedType = (ActivatedServiceTypeEntry)
                    _exportableClasses[EncodeTypeAndAssemblyNames(typeName, assemblyName)];
                if (activatedType == null)
                    return null;
                    
                return activatedType.ContextAttributes;
            } // GetContextAttributesForServerActivatedType
           
            internal ActivatedClientTypeEntry QueryRemoteActivate(String typeName, String assemblyName)
            {
                String index = EncodeTypeAndAssemblyNames(typeName, assemblyName);
            
                ActivatedClientTypeEntry typeEntry = _remoteTypeInfo[index] as ActivatedClientTypeEntry;
                if (typeEntry == null)
                    return null;         

                if (typeEntry.GetRemoteAppEntry() == null)
                {
                    RemoteAppEntry appEntry = (RemoteAppEntry)
                                            _remoteAppInfo[typeEntry.ApplicationUrl];
                    if (appEntry == null)
                    {
                        throw new RemotingException(
                         String.Format(
                            Environment.GetResourceString(
                                "Remoting_Activation_MissingRemoteAppEntry"),
                            typeEntry.ApplicationUrl));                            
                    }
                    typeEntry.CacheRemoteAppEntry(appEntry);
                }
                return typeEntry;
            }

            internal WellKnownClientTypeEntry QueryConnect(String typeName, String assemblyName)
            {
                String index = EncodeTypeAndAssemblyNames(typeName, assemblyName);
                
                WellKnownClientTypeEntry typeEntry = _remoteTypeInfo[index] as WellKnownClientTypeEntry;
                if (typeEntry == null)
                    return null;
                    
                return typeEntry;
            }       
          
            //
            // helper functions to retrieve registered types
            //


            internal ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes()
            {
                ActivatedServiceTypeEntry[] entries =
                    new ActivatedServiceTypeEntry[_exportableClasses.Count];

                int co = 0;
                foreach (DictionaryEntry dictEntry in _exportableClasses)
                {
                    entries[co++] = (ActivatedServiceTypeEntry)dictEntry.Value;
                }
                    
                return entries;
            } // GetRegisteredActivatedServiceTypes


            internal WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes()
            {
                WellKnownServiceTypeEntry[] entries =
                    new WellKnownServiceTypeEntry[_wellKnownExportInfo.Count];

                int co = 0;
                foreach (DictionaryEntry dictEntry in _wellKnownExportInfo)
                {
                    WellKnownServiceTypeEntry entry = (WellKnownServiceTypeEntry)dictEntry.Value;
                    
                    WellKnownServiceTypeEntry wkste =
                        new WellKnownServiceTypeEntry(
                            entry.TypeName, entry.AssemblyName,
                            entry.ObjectUri, entry.Mode);

                    wkste.ContextAttributes = entry.ContextAttributes;
                    
                    entries[co++] = wkste;
                }
                    
                return entries;
            } // GetRegisteredWellKnownServiceTypes


            internal ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes()
            {
                // count number of well known client types
                int count = 0;
                foreach (DictionaryEntry dictEntry in _remoteTypeInfo)
                {
                    ActivatedClientTypeEntry entry = dictEntry.Value as ActivatedClientTypeEntry;                
                    if (entry != null)
                        count++;
                }
                            
                ActivatedClientTypeEntry[] entries =
                    new ActivatedClientTypeEntry[count];

                int co = 0;
                foreach (DictionaryEntry dictEntry in _remoteTypeInfo)
                {
                    ActivatedClientTypeEntry entry = dictEntry.Value as ActivatedClientTypeEntry;

                    if (entry != null)
                    {
                        // retrieve application url
                        String appUrl = null;
                        RemoteAppEntry remApp = entry.GetRemoteAppEntry();
                        if (remApp != null)
                            appUrl = remApp.GetAppURI();  
                    
                        ActivatedClientTypeEntry wkcte =
                            new ActivatedClientTypeEntry(entry.TypeName, 
                                entry.AssemblyName, appUrl);
                        
                        // Fetch the context attributes
                        wkcte.ContextAttributes = entry.ContextAttributes;

                        entries[co++] = wkcte;
                    }
                    
                }
                   
                return entries;
            } // GetRegisteredActivatedClientTypes
            

            internal WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes()
            {
                // count number of well known client types
                int count = 0;
                foreach (DictionaryEntry dictEntry in _remoteTypeInfo)
                {
                    WellKnownClientTypeEntry entry = dictEntry.Value as WellKnownClientTypeEntry;                
                    if (entry != null)
                        count++;
                }
                            
                WellKnownClientTypeEntry[] entries =
                    new WellKnownClientTypeEntry[count];

                int co = 0;
                foreach (DictionaryEntry dictEntry in _remoteTypeInfo)
                {
                    WellKnownClientTypeEntry entry = dictEntry.Value as WellKnownClientTypeEntry;

                    if (entry != null)
                    {                    
                        WellKnownClientTypeEntry wkcte =
                            new WellKnownClientTypeEntry(entry.TypeName, 
                                entry.AssemblyName, entry.ObjectUrl);

                        // see if there is an associated app
                        RemoteAppEntry remApp = entry.GetRemoteAppEntry();
                        if (remApp != null)
                            wkcte.ApplicationUrl = remApp.GetAppURI();                             

                        entries[co++] = wkcte;
                    }
                    
                }
                   
                return entries;
            } // GetRegisteredWellKnownClientTypes


            //
            // end of helper functions to retrieve registered types
            //

            internal void AddActivatedType(String typeName, String assemblyName,
                                           IContextAttribute[] contextAttributes)
            {
                if (typeName == null)
                    throw new ArgumentNullException("typeName");
                if (assemblyName == null)
                    throw new ArgumentNullException("assemblyName");

                if (CheckForRedirectedClientType(typeName, assemblyName))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Config_CantUseRedirectedTypeForWellKnownService"),
                            typeName, assemblyName));
                }                                

                ActivatedServiceTypeEntry aste =  
                    new ActivatedServiceTypeEntry(typeName, assemblyName);
                aste.ContextAttributes = contextAttributes;
            
                //   The assembly name is stored in lowercase to let it be case-insensitive.
                String key = EncodeTypeAndAssemblyNames(typeName, assemblyName);
                _exportableClasses.Add(key, aste);
            } // AddActivatedType


            // determines if either a wellknown or activated service type entry
            //   is associated with the given type name and assembly name
            private bool CheckForServiceEntryWithType(String typeName, String asmName)
            {  
                return
                    CheckForWellKnownServiceEntryWithType(typeName, asmName) ||
                    ActivationAllowed(typeName, asmName);                 
            } // CheckForServiceEntryWithType

            private bool CheckForWellKnownServiceEntryWithType(String typeName, String asmName)
            {
                foreach (DictionaryEntry entry in _wellKnownExportInfo)
                {
                    WellKnownServiceTypeEntry svc = 
                        (WellKnownServiceTypeEntry)entry.Value;
                    if (typeName == svc.TypeName)
                    {
                        bool match = false;
                        
                        // need to ignore version while checking
                        if (asmName == svc.AssemblyName)
                            match = true;
                        else
                        {
                            // only well known service entry can have version info
                            if (String.Compare(svc.AssemblyName, 0, asmName, 0, asmName.Length, true, CultureInfo.InvariantCulture) == 0)
                            {
                                // if asmName != svc.AssemblyName and svc.AssemblyName
                                //   starts with asmName we know that svc.AssemblyName is
                                //   longer. If the next character is a comma, then the
                                //   assembly names match except for version numbers
                                //   which is ok.
                                if (svc.AssemblyName[asmName.Length] == ',')
                                    match = true;
                            }
                        }

                        // We were trying to redirect
                        if (match)
                            return true;
                    }
                }

                return false;
            } // CheckForWellKnownServiceEntryOfType


            // returns true if activation for the type has been redirected.
            private bool CheckForRedirectedClientType(String typeName, String asmName)
            {
                // if asmName has version information, remove it.
                int index = asmName.IndexOf(",");
                if (index != -1)
                    asmName = asmName.Substring(0, index);

                return 
                    (QueryRemoteActivate(typeName, asmName) != null) ||
                    (QueryConnect(typeName, asmName) != null);
            } // CheckForRedirectedClientType
            

            internal void AddActivatedClientType(ActivatedClientTypeEntry entry)
            {
                if (CheckForRedirectedClientType(entry.TypeName, entry.AssemblyName))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Config_TypeAlreadyRedirected"),
                            entry.TypeName, entry.AssemblyName));
                }                 

                if (CheckForServiceEntryWithType(entry.TypeName, entry.AssemblyName))
                {
                   throw new RemotingException(
                       String.Format(
                           Environment.GetResourceString(
                               "Remoting_Config_CantRedirectActivationOfWellKnownService"),
                           entry.TypeName, entry.AssemblyName));
                }
            
                String appUrl = entry.ApplicationUrl;
                RemoteAppEntry appEntry = (RemoteAppEntry)_remoteAppInfo[appUrl];
                if (appEntry == null)
                {
                    appEntry = new RemoteAppEntry(appUrl, appUrl);
                    _remoteAppInfo.Add(appUrl, appEntry);
                }
                    
                if (appEntry != null)
                {
                    entry.CacheRemoteAppEntry(appEntry);
                }
                    
                String index = EncodeTypeAndAssemblyNames(entry.TypeName, entry.AssemblyName);
                _remoteTypeInfo.Add(index, entry);
            } // AddActivatedClientType


            internal void AddWellKnownClientType(WellKnownClientTypeEntry entry)
            {
                if (CheckForRedirectedClientType(entry.TypeName, entry.AssemblyName))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Config_TypeAlreadyRedirected"),
                            entry.TypeName, entry.AssemblyName));
                }    

                if (CheckForServiceEntryWithType(entry.TypeName, entry.AssemblyName))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Config_CantRedirectActivationOfWellKnownService"),
                            entry.TypeName, entry.AssemblyName));
                }
            
            
                String appUrl = entry.ApplicationUrl;

                RemoteAppEntry appEntry = null;
                if (appUrl != null)
                {
                    appEntry = (RemoteAppEntry)_remoteAppInfo[appUrl];
                    if (appEntry == null)
                    {
                        appEntry = new RemoteAppEntry(appUrl, appUrl);
                        _remoteAppInfo.Add(appUrl, appEntry);
                    }
                }
            
                if (appEntry != null)
                    entry.CacheRemoteAppEntry(appEntry);

                String index = EncodeTypeAndAssemblyNames(entry.TypeName, entry.AssemblyName);
                _remoteTypeInfo.Add(index, entry);
            } // AddWellKnownClientType
            
            

            // This is to add programmatically registered well known objects
            // so that we keep all this data in one place
            internal void AddWellKnownEntry(WellKnownServiceTypeEntry entry)
            {
                AddWellKnownEntry(entry, true);                
            }

            internal void AddWellKnownEntry(WellKnownServiceTypeEntry entry, bool fReplace)
            {
                if (CheckForRedirectedClientType(entry.TypeName, entry.AssemblyName))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Config_CantUseRedirectedTypeForWellKnownService"),
                            entry.TypeName, entry.AssemblyName));
                }
            
                String key = entry.ObjectUri.ToLower(CultureInfo.InvariantCulture);
                
                if (fReplace)
                {
                    // Registering a well known object twice replaces the old one, so
                    //   we null out the old entry in the identity table after adding
                    //   this one. The identity will be recreated the next time someone
                    //   asks for this object.
                    _wellKnownExportInfo[key] = entry;

                    IdentityHolder.RemoveIdentity(entry.ObjectUri);
                }
                else
                {
                    _wellKnownExportInfo.Add(key, entry);
                }

            }

            //This API exposes a way to get server type information wiihout booting the object
            internal Type GetServerTypeForUri(String URI)
            {
                BCLDebug.Assert(null != URI, "null != URI");

                Type serverType = null;
                String uriLower = URI.ToLower(CultureInfo.InvariantCulture);

                WellKnownServiceTypeEntry entry = 
                        (WellKnownServiceTypeEntry)_wellKnownExportInfo[uriLower];

                if(entry != null)
                {
                    serverType = LoadType(entry.TypeName, entry.AssemblyName);
                }

                return serverType;
            }
            
            internal ServerIdentity StartupWellKnownObject(String URI)
            {
                BCLDebug.Assert(null != URI, "null != URI");
                
                String uriLower = URI.ToLower(CultureInfo.InvariantCulture);
                ServerIdentity ident = null;

                WellKnownServiceTypeEntry entry = 
                    (WellKnownServiceTypeEntry)_wellKnownExportInfo[uriLower];
                if (entry != null)
                {
                    ident = StartupWellKnownObject(
                        entry.AssemblyName,
                        entry.TypeName,
                        entry.ObjectUri,
                        entry.Mode);

                    entry.SetConfigured();
                }

                return ident;
            }

            internal ServerIdentity StartupWellKnownObject(
                String asmName, String svrTypeName, String URI, 
                WellKnownObjectMode mode)
            {
                return StartupWellKnownObject(asmName, svrTypeName, URI, mode, false);
            }            

            internal ServerIdentity StartupWellKnownObject(
                String asmName, String svrTypeName, String URI, 
                WellKnownObjectMode mode,
                bool fReplace)
            {
                lock (s_wkoStartLock)
                {                
                    MarshalByRefObject obj = null;
                    ServerIdentity srvID = null;

                    // attempt to load the type                
                    Type serverType = LoadType(svrTypeName, asmName);
                    
                    // make sure the well known object derives from MarshalByRefObject
                    if(!serverType.IsMarshalByRef)
                    {   
                        throw new RemotingException(
                            String.Format(Environment.GetResourceString("Remoting_WellKnown_MustBeMBR"),
                            svrTypeName));                         
                    }

                    // make sure that no one beat us to creating
                    // the well known object
                    srvID = (ServerIdentity)IdentityHolder.ResolveIdentity(URI);
                    if ((srvID != null) && srvID.IsRemoteDisconnected())
                    {
                        IdentityHolder.RemoveIdentity(URI);
                        srvID = null;
                    }
                                        
                    if (srvID == null)
                    {    
                        //WellKnown type instances need to be created under full trust
                        //since the permission set might have been restricted by the channel 
                        //pipeline.           
                        //This assert is protected by Infrastructure link demands.
                        s_fullTrust.Assert();                
                        try {                    
                            obj = (MarshalByRefObject)Activator.CreateInstance(serverType, true);
                                                 
                            if (RemotingServices.IsClientProxy(obj))
                            {
                                // The wellknown type is remoted so we must wrap the proxy
                                // with a local object.

                                // The redirection proxy masquerades as an object of the appropriate
                                // type, and forwards incoming messages to the actual proxy.
                                RedirectionProxy redirectedProxy = new RedirectionProxy(obj, serverType);
                                redirectedProxy.ObjectMode = mode;
                                RemotingServices.MarshalInternal(redirectedProxy, URI, serverType);

                                srvID = (ServerIdentity)IdentityHolder.ResolveIdentity(URI);
                                BCLDebug.Assert(null != srvID, "null != srvID");

                                // The redirection proxy handles SingleCall versus Singleton,
                                // so we always set its mode to Singleton.
                                srvID.SetSingletonObjectMode();
                            }
                            else
                            if (serverType.IsCOMObject && (mode == WellKnownObjectMode.Singleton))
                            {
                                // Singleton COM objects are wrapped, so that they will be
                                //   recreated when an RPC server not available is thrown
                                //   if dllhost.exe is killed.
                                ComRedirectionProxy comRedirectedProxy = new ComRedirectionProxy(obj, serverType);
                                RemotingServices.MarshalInternal(comRedirectedProxy, URI, serverType);

                                srvID = (ServerIdentity)IdentityHolder.ResolveIdentity(URI);
                                BCLDebug.Assert(null != srvID, "null != srvID");

                                // Only singleton COM objects are redirected this way.
                                srvID.SetSingletonObjectMode();
                            }
                            else
                            {
                                // make sure the object didn't Marshal itself.
                                String tempUri = RemotingServices.GetObjectUri(obj);
                                if (tempUri != null)
                                {
                                    throw new RemotingException(
                                        String.Format(
                                            Environment.GetResourceString(
                                                "Remoting_WellKnown_CtorCantMarshal"),
                                            URI));
                                }
                        
                                RemotingServices.MarshalInternal(obj, URI, serverType);

                                srvID = (ServerIdentity)IdentityHolder.ResolveIdentity(URI);
                                BCLDebug.Assert(null != srvID, "null != srvID");

                                if (mode == WellKnownObjectMode.SingleCall)
                                {
                                    // We need to set a special flag in the serverId
                                    // so that every dispatch to this type creates 
                                    // a new instance of the server object
                                    srvID.SetSingleCallObjectMode();
                                }
                                else
                                {
                                    srvID.SetSingletonObjectMode();
                                }
                            }
                        }
                        catch
                        {
                            throw;
                        }
                        finally {
                            SecurityPermission.RevertAssert();
                        }

                    }
                    
                    BCLDebug.Assert(null != srvID, "null != srvID");
                    return srvID;
                }
            } // StartupWellKnownObject

            internal static Type LoadType(String typeName, String assemblyName)
            {
                Assembly asm = null;                                               
                // All the LoadType callers have been protected by 
                // Infrastructure LinkDemand, it is safe to assert
                // this permission. 
                // Assembly.Load demands FileIO when the target 
                // assembly is the same as the executable running.
                new FileIOPermission(PermissionState.Unrestricted).Assert();
                try {                    
                    asm = Assembly.Load(assemblyName);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                    
                if (asm == null)
                {
                    throw new RemotingException(
                        String.Format(Environment.GetResourceString("Remoting_AssemblyLoadFailed"),
                        assemblyName));                    
                }

                Type type = asm.GetTypeInternal(typeName, false, false, false);
                if (type == null)
                {
                    throw new RemotingException(
                        String.Format(Environment.GetResourceString("Remoting_BadType"),
                        typeName + ", " + assemblyName));     
                }

                return type;
            } // LoadType


            
        }// class RemotingConfigInfo        
    } // class RemotingConfigHandler



    internal class DelayLoadClientChannelEntry
    {
        private RemotingXmlConfigFileData.ChannelEntry _entry;
        private IChannelSender _channel;
        private bool _bRegistered;

        internal DelayLoadClientChannelEntry(RemotingXmlConfigFileData.ChannelEntry entry)
        {
            _entry = entry;
            _channel = null;      
            _bRegistered = false;
        }

        internal IChannelSender Channel
        {
            get
            {
                // If this method returns null, that means the channel has already been registered.
        
                // NOTE: Access to delay load client entries is synchronized at a higher level.
                if (_channel == null)
                {
                    if (!_bRegistered)
                    {
                        _channel = (IChannelSender)RemotingConfigHandler.CreateChannelFromConfigEntry(_entry);
                        _entry = null;
                    }
                }

                return _channel;
            } // get
        } // Channel

        internal void RegisterChannel()
        {
            BCLDebug.Assert(_channel != null, "channel shouldn't be null");
        
            // NOTE: Access to delay load client entries is synchronized at a higher level.
            ChannelServices.RegisterChannel(_channel);
            _bRegistered = true;
            _channel = null;
        } // RegisterChannel
        
    } // class DelayLoadChannelEntry

    

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\crosscontextchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Remoting Infrastructure Sink for making calls across context
// boundaries. 
//
namespace System.Runtime.Remoting.Channels {

    using System;
    using System.Collections;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Serialization;
    
    /* package scope */
    // deliberately not [serializable]
    internal class CrossContextChannel : InternalSink, IMessageSink 
    {
        private const String _channelName = "XCTX";
        private const int _channelCapability = 0; 
        private const String _channelURI = "XCTX_URI";
    
        private static CrossContextChannel messageSink
        { 
            get { return Thread.GetDomain().RemotingData.ChannelServicesData.xctxmessageSink; }
            set { Thread.GetDomain().RemotingData.ChannelServicesData.xctxmessageSink = value; }
        }

        private static Object staticSyncObject = new Object();

        [Serializable]
        internal class CrossContextData
        {
            private String _processGuid;
    
            internal CrossContextData(String processGuid)
            {
                _processGuid = processGuid;
            }
    
            internal virtual String ProcessGuid 
            { 
                get 
                {
                    Message.DebugOut("CrossContextChannelData::Getting ProcessGuid \n");
                    return _processGuid;
                } 
                set 
                { 
                    Message.DebugOut("CrossContextChannelData::Setting ProcessGuid \n");
                    _processGuid = value;                
                    Message.DebugOut("CrossContextChannelData::Set ProcessGuid complete\n");
                }
            }

         }
            
    
        internal static IMessageSink MessageSink 
        {
            get 
            {   
                if (messageSink == null) 
                {                
                    CrossContextChannel tmpSink = new CrossContextChannel();
                    
                    lock (staticSyncObject)
                    {
                        if (messageSink == null)
                        {
                            messageSink = tmpSink;
                        }
                    }
                    //Interlocked.CompareExchange(out messageSink, tmpSink, null);
                }
                return messageSink;
            }
        }
    
        public virtual IMessage     SyncProcessMessage(IMessage reqMsg) 
        {
            IMessage replyMsg = null;
            try
            {
                Message.DebugOut("\n::::::::::::::::::::::::: CrossContext Channel: Sync call starting");
                IMessage errMsg = ValidateMessage(reqMsg);
                if (errMsg != null)
                {
                    return errMsg;
                }

                ServerIdentity srvID = GetServerIdentity(reqMsg);
                Message.DebugOut("Got Server identity \n");
                BCLDebug.Assert(null != srvID,"null != srvID");
                
                
                BCLDebug.Assert(null != srvID.ServerContext, "null != srvID.ServerContext");
                
                bool fEnteredContext = false;               
                ContextTransitionFrame frame = new ContextTransitionFrame();
                try
                {
#if DEBUG
                    Context savedContext = Thread.CurrentThread.GetCurrentContext;
#endif
                    Context srvCtx = srvID.ServerContext;
                    Thread.CurrentThread.EnterContext(srvCtx, ref frame);
                    fEnteredContext = true;
#if DEBUG
                    Message.DebugOut(" ::::: Switched from: " + savedContext + " to " + srvCtx);
#endif
                    // If profiling of remoting is active, must tell the profiler that we have received
                    // a message.
                    if (RemotingServices.CORProfilerTrackRemoting())
                    {
                        Guid g = Guid.Empty;

                        if (RemotingServices.CORProfilerTrackRemotingCookie())
                        {
                            Object obj = reqMsg.Properties["CORProfilerCookie"];

                            if (obj != null)
                            {
                                g = (Guid) obj;
                            }
                        }

                        RemotingServices.CORProfilerRemotingServerReceivingMessage(g, false);
                    }
    
                    Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: passing to ServerContextChain");
                    
                    // Server side notifications for dynamic sinks are done
                    // in the x-context channel ... this is to maintain 
                    // symmetry of the point of notification between 
                    // the client and server context
                    srvCtx.NotifyDynamicSinks(
                                reqMsg,
                                false,  // bCliSide
                                true,   // bStart
                                false,  // bAsync
                                true);  // bNotifyGlobals

                    replyMsg = srvCtx.GetServerContextChain().SyncProcessMessage(reqMsg);
                    srvCtx.NotifyDynamicSinks(
                                replyMsg,
                                false,  // bCliSide
                                false,  // bStart
                                false,  // bAsync
                                true);  // bNotifyGlobals
            
                    Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: back from ServerContextChain");

                    // If profiling of remoting is active, must tell the profiler that we are sending a
                    // reply message.
                    if (RemotingServices.CORProfilerTrackRemoting())
                    {
                        Guid g;

                        RemotingServices.CORProfilerRemotingServerSendingReply(out g, false);

                        if (RemotingServices.CORProfilerTrackRemotingCookie())
                        {
                            replyMsg.Properties["CORProfilerCookie"] = g;
                        }
                    }
                }
                finally
                {
                    if(fEnteredContext)
                    {
#if DEBUG                
                        Message.DebugOut(" ::::: switching from: " + Thread.CurrentContext + " to " + savedContext);
#endif
                        Thread.CurrentThread.ReturnToContext(ref frame);
                    }
                }

            }
            catch(Exception e)
            {
                Message.DebugOut("Arrgh.. XCTXSink::throwing exception " + e + "\n");
                replyMsg = new ReturnMessage(e, (IMethodCallMessage)reqMsg);
                if (reqMsg!=null)
                {
                    ((ReturnMessage)replyMsg).SetLogicalCallContext(
                            (LogicalCallContext)
                            reqMsg.Properties[Message.CallContextKey]);
                }
            }
                
            Message.DebugOut("::::::::::::::::::::::::::: CrossContext Channel: Sync call returning!!\n");                         
            return replyMsg;
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            Message.DebugOut("::::::::::::::::::::::::::: CrossContext Channel: Async call starting!!\n");
            // One way Async notifications may potentially pass a null reply sink.
            IMessage errMsg = ValidateMessage(reqMsg);
            IMessageCtrl msgCtrl=null;
            
            if (errMsg != null)
            {
                if (replySink!=null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {
                ServerIdentity srvID = GetServerIdentity(reqMsg);
                AsyncWorkItem workItem = null;
                
                // If active, notify the profiler that an asynchronous remoting message was received.
                if (RemotingServices.CORProfilerTrackRemotingAsync())
                {
                    Guid g = Guid.Empty;

                    if (RemotingServices.CORProfilerTrackRemotingCookie())
                    {
                        Object obj = reqMsg.Properties["CORProfilerCookie"];

                        if (obj != null)
                        {
                            g = (Guid) obj;
                        }
                    }

                    RemotingServices.CORProfilerRemotingServerReceivingMessage(g, true);

                    // Only wrap the replySink if the call wants a reply
                    if (replySink != null)
                    {
                        // Now wrap the reply sink in our own so that we can notify the profiler of
                        // when the reply is sent.  Upon invocation, it will notify the profiler
                        // then pass control on to the replySink passed in above.
                        IMessageSink profSink = new ServerAsyncReplyTerminatorSink(replySink);

                        // Replace the reply sink with our own
                        replySink = profSink;
                    }
                }

                Context srvCtx = srvID.ServerContext;
                if (srvCtx.IsThreadPoolAware)
                {
                    // this is the case when we do not queue the work item since the 
                    // server context claims to be doing its own threading.

                    Context oldCtx = Thread.CurrentContext;                     
                    // change to server object context
                    ContextTransitionFrame frame = new ContextTransitionFrame();
                    srvCtx = srvID.ServerContext;
                    Thread.CurrentThread.EnterContext(srvCtx, ref frame);

                    // we use the work item just as our replySink in this case
                    if (replySink != null)
                    {
                         workItem = new AsyncWorkItem(replySink, oldCtx); 
                    }

                    Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: passing to ServerContextChain");

                    srvCtx.NotifyDynamicSinks(
                                reqMsg,
                                false,  // bCliSide
                                true,   // bStart
                                true,   // bAsync
                                true);  // bNotifyGlobals

                    // call the server context chain
                    msgCtrl = 
                        srvCtx.GetServerContextChain().AsyncProcessMessage(
                            reqMsg, 
                            (IMessageSink)workItem);

                    // Note: for async calls, we will do the return notification
                    // for dynamic properties only when the async call 
                    // completes (i.e. when the replySink gets called) 

                    Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: back from ServerContextChain");

                    // chain back to the dispatch thread context
                    Thread.CurrentThread.ReturnToContext(ref frame);
    
                }
                else
                {
                    // This is the case where we take care of returning the calling
                    // thread asap by using the ThreadPool for completing the call.
                    
                    // we use a more elaborate WorkItem and delegate the work to the thread pool
                    workItem = new AsyncWorkItem(reqMsg, 
                                                replySink, 
                                                Thread.CurrentContext, 
                                                srvID);
    
                    WaitCallback threadFunc = new WaitCallback(workItem.FinishAsyncWork);
                    // Note: Dynamic sinks are notified in the threadFunc
                    ThreadPool.QueueUserWorkItem(threadFunc);
                    
                    msgCtrl = null;
                }
            }
    
            Message.DebugOut("::::::::::::::::::::::::::: CrossContext Channel: Async call returning!!\n");
            return msgCtrl;
        } // AsyncProcessMessage


        internal static IMessageCtrl DoAsyncDispatch(IMessage reqMsg, IMessageSink replySink)
        {
            ServerIdentity srvID = GetServerIdentity(reqMsg);
            AsyncWorkItem workItem = null;
            
            // If active, notify the profiler that an asynchronous remoting message was received.
            if (RemotingServices.CORProfilerTrackRemotingAsync())
            {
                Guid g = Guid.Empty;

                if (RemotingServices.CORProfilerTrackRemotingCookie())
                {
                    Object obj = reqMsg.Properties["CORProfilerCookie"];
                    if (obj != null)
                        g = (Guid) obj;
                }

                RemotingServices.CORProfilerRemotingServerReceivingMessage(g, true);

                // Only wrap the replySink if the call wants a reply
                if (replySink != null)
                {
                    // Now wrap the reply sink in our own so that we can notify the profiler of
                    // when the reply is sent.  Upon invocation, it will notify the profiler
                    // then pass control on to the replySink passed in above.
                    IMessageSink profSink = 
                        new ServerAsyncReplyTerminatorSink(replySink);

                    // Replace the reply sink with our own
                    replySink = profSink;
                }
            }

            Context srvCtx = srvID.ServerContext;
            
            //if (srvCtx.IsThreadPoolAware)
            //{
                // this is the case when we do not queue the work item since the 
                // server context claims to be doing its own threading.

                Context oldCtx = Thread.CurrentContext;                     
                // change to server object context
                ContextTransitionFrame frame = new ContextTransitionFrame();
                Thread.CurrentThread.EnterContext(srvID.ServerContext, ref frame);

                // we use the work item just as our replySink in this case
                if (replySink != null)
                {
                     workItem = new AsyncWorkItem(replySink, oldCtx); 
                }
                Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: passing to ServerContextChain");
                // call the server context chain
                IMessageCtrl msgCtrl = 
                    srvID.ServerContext.GetServerContextChain().AsyncProcessMessage(reqMsg, (IMessageSink)workItem);
                Message.DebugOut("::::::::::::::::::::::::: CrossContext Channel: back from ServerContextChain");
                // chain back to the dispatch thread context
                Thread.CurrentThread.ReturnToContext(ref frame);
    
            //}

            return msgCtrl;
        } // DoDispatch


        
    
        public IMessageSink NextSink
        {
            get
            {
                // We are a terminating sink for this chain.
                return null;
            }
        }
  }
    
    /* package */
    internal class AsyncWorkItem : IMessageSink
    {
        // the replySink passed in to us in AsyncProcessMsg
        private IMessageSink _replySink;
        
        // the server identity we are calling
        private ServerIdentity _srvID;
        
        // the original context of the thread calling AsyncProcessMsg
        private Context _oldCtx;

        private LogicalCallContext _callCtx;
        
        // the request msg passed in
        private IMessage _reqMsg;    
        
        internal AsyncWorkItem(IMessageSink replySink, Context oldCtx)
           
            : this(null, replySink, oldCtx, null) {
        }
    
        internal AsyncWorkItem(IMessage reqMsg, IMessageSink replySink, Context oldCtx, ServerIdentity srvID)
        {
            _reqMsg = reqMsg;
            _replySink = replySink;
            _oldCtx = oldCtx;
            _callCtx = CallContext.GetLogicalCallContext();
            _srvID = srvID;
        }
        
        public virtual IMessage     SyncProcessMessage(IMessage msg)
        {
            // This gets called when the called object finishes the AsyncWork...

            // This is called irrespective of whether we delegated the initial
            // work to a thread pool thread or not. Quite likely it will be 
            // called on a user thread (i.e. a thread different from the 
            // forward call thread)
        
            // we just switch back to the old context before calling 
            // the next replySink
            IMessage retMsg = null;
            if (_replySink != null)
            {
                // This assert covers the common case (ThreadPool)
                // and checks that the reply thread for the async call 
                // indeed emerges from the server context.
                BCLDebug.Assert(
                    (_srvID == null)
                    || (_srvID.ServerContext == Thread.CurrentContext),
                    "Thread expected to be in the server context!");

                // Call the dynamic sinks to notify that the async call
                // has completed
                Thread.CurrentContext.NotifyDynamicSinks(
                    msg,    // this is the async reply
                    false,  // bCliSide
                    false,  // bStart
                    true,   // bAsync
                    true);  // bNotifyGlobals

                ContextTransitionFrame frame = new ContextTransitionFrame();
                Thread.CurrentThread.EnterContext(_oldCtx, ref frame);
                retMsg = _replySink.SyncProcessMessage(msg);
                Thread.CurrentThread.ReturnToContext(ref frame);
            }
            return retMsg;
        }
        
        public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            // Can't call the reply sink asynchronously!
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));
        }
    
        public IMessageSink NextSink
        {
            get
            {
                return _replySink;
            }
        }    
    
        /* package */
        internal virtual void FinishAsyncWork(Object stateIgnored)
        {
            // set to the server context
            ContextTransitionFrame frame = new ContextTransitionFrame();
            Context srvCtx = _srvID.ServerContext;
            Thread.CurrentThread.EnterContext(srvCtx, ref frame);

            LogicalCallContext threadPoolCallCtx = 
                CallContext.SetLogicalCallContext(_callCtx);

            // Call the server context chain Async. We provide workItem as our
            // replySink ... this will cause the replySink.ProcessMessage 
            // to switch back to the context of the original caller thread.
    
            // Call the dynamic sinks to notify that the async call
            // is starting
            srvCtx.NotifyDynamicSinks(
                _reqMsg,
                false,  // bCliSide
                true,   // bStart
                true,   // bAsync
                true);  // bNotifyGlobals

            // FUTURE: we should hook up this MsgCtrl with the one we will
            // return to the original caller and coordinate cancels etc.        
            IMessageCtrl ctrl = 
               srvCtx.GetServerContextChain().AsyncProcessMessage(
                    _reqMsg, 
                    (IMessageSink)this);

            // change back to the old context        
            CallContext.SetLogicalCallContext(threadPoolCallCtx);
            Thread.CurrentThread.ReturnToContext(ref frame);
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\headerhandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: HeaderHandler
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The delegate used to process headers on the stream
** during deserialization.
**
** Date:  August 9, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
	using System.Runtime.Remoting;
    //Define the required delegate
    /// <include file='doc\HeaderHandler.uex' path='docs/doc[@for="HeaderHandler"]/*' />
    public delegate Object HeaderHandler(Header[] headers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\header.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    Header.cool
**
** Author:  Matt Smith (MattSmit)
**
** Purpose: Defines the out-of-band data for a call
**
**
** Date:    April 19, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging{
	using System.Runtime.Remoting;
	using System;
    /// <include file='doc\Header.uex' path='docs/doc[@for="Header"]/*' />
    [Serializable]
    public class Header
    {
        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.Header"]/*' />
        public Header (String _Name, Object _Value)
        
            : this(_Name, _Value, true) {
        }
        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.Header1"]/*' />
        public Header (String _Name, Object _Value, bool _MustUnderstand)
        {
            Name = _Name;
            Value = _Value;
            MustUnderstand = _MustUnderstand;
        }

        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.Header2"]/*' />
        public Header (String _Name, Object _Value, bool _MustUnderstand, String _HeaderNamespace)
        {
            Name = _Name;
            Value = _Value;
            MustUnderstand = _MustUnderstand;
            HeaderNamespace = _HeaderNamespace;
        }

        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.Name"]/*' />
        public String    Name;
        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.Value"]/*' />
        public Object    Value;
        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.MustUnderstand"]/*' />
        public bool   MustUnderstand;

        /// <include file='doc\Header.uex' path='docs/doc[@for="Header.HeaderNamespace"]/*' />
        public String HeaderNamespace;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\enterpriseserviceshelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ComponentServices.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose ComponentServices
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.Runtime.Remoting.Services {   
    using System;
	using System.Reflection;
	using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
	using System.Text;
	using System.Runtime.Serialization;
	using System.Runtime.CompilerServices;
	using System.Security.Permissions;
	using System.Runtime.InteropServices;

	//---------------------------------------------------------\\
	//---------------------------------------------------------\\
	//	internal sealed class ComponentServices				   \\
	//---------------------------------------------------------\\
	//---------------------------------------------------------\\
	
	/// <include file='doc\EnterpriseServicesHelper.uex' path='docs/doc[@for="EnterpriseServicesHelper"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	public sealed class EnterpriseServicesHelper 
	{
	
		/// <include file='doc\EnterpriseServicesHelper.uex' path='docs/doc[@for="EnterpriseServicesHelper.WrapIUnknownWithComObject"]/*' />
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
		// also take an object param and register the object for this unk
		public static Object WrapIUnknownWithComObject(IntPtr punk)
		{
			return Marshal._WrapIUnknownWithComObject(punk, null);
		}		

		/// <include file='doc\EnterpriseServicesHelper.uex' path='docs/doc[@for="EnterpriseServicesHelper.CreateConstructionReturnMessage"]/*' />
		public static IConstructionReturnMessage CreateConstructionReturnMessage(
															IConstructionCallMessage ctorMsg, 
															MarshalByRefObject retObj)
		{
			
            IConstructionReturnMessage ctorRetMsg = null;
            
            // Create the return message
            ctorRetMsg = new ConstructorReturnMessage(retObj, null, 0, null, ctorMsg);

            // NOTE: WE ALLOW ONLY DEFAULT CTORs on SERVICEDCOMPONENTS

            return ctorRetMsg;
		}		

			// switch the wrappers
		/// <include file='doc\EnterpriseServicesHelper.uex' path='docs/doc[@for="EnterpriseServicesHelper.SwitchWrappers"]/*' />
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
		public static void SwitchWrappers(RealProxy oldcp, RealProxy newcp)
		{
			Object oldtp = oldcp.GetTransparentProxy();
			Object newtp = newcp.GetTransparentProxy();

			int oldcontextId = RemotingServices.GetServerContextForProxy(oldtp);
			int newcontextId = RemotingServices.GetServerContextForProxy(newtp);

			// switch the CCW from oldtp to new tp
			Marshal.SwitchCCW(oldtp, newtp);
		}                		
	        
    };


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\dynamicpropertyholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  
//   DynamicPropertyHolder manages the dynamically registered properties
//   and the sinks contributed by them. Dynamic properties may be registered
//   to contribute sinks on a per-object basis (on the proxy or server side)
//   or on a per-Context basis (in both the client and server contexts). 
//
//   See also: RemotingServices.RegisterDynamicSink() API
//

namespace System.Runtime.Remoting.Contexts {
    using System.Runtime.Remoting;   
    using System.Runtime.Remoting.Messaging;
    using System;
    using System.Collections;
    internal class DynamicPropertyHolder
    {
        private const int GROW_BY                        = 0x8;
    
        private IDynamicProperty[] _props;
        private int _numProps;
        private IDynamicMessageSink[] _sinks;
            
        internal virtual bool AddDynamicProperty(IDynamicProperty prop)
        {
            lock(this) {
                // We have to add a sink specific to the given context
                CheckPropertyNameClash(prop.Name, _props, _numProps);
        
                // check if we need to grow the array.
                bool bGrow=false;
                if (_props == null || _numProps == _props.Length)    
                {
                    _props = GrowPropertiesArray(_props);
                    bGrow = true;
                }
                // now add the property
                _props[_numProps++] = prop;
                
                // we need to grow the sinks if we grew the props array or we had thrown 
                // away the sinks array due to a recent removal!
                if (bGrow)
                {
                    _sinks = GrowDynamicSinksArray(_sinks);
                }
        
                if (_sinks == null)
                {
                    // Some property got unregistered -- we need to recreate
                    // the list of sinks.
                    _sinks = new IDynamicMessageSink[_props.Length];
                    for (int i=0; i<_numProps; i++)
                    {
                        _sinks[i] = 
                                ((IContributeDynamicSink)_props[i]).GetDynamicSink();
                    }                
                }
                else
                {
                    // append the Sink to the existing array of Sinks
                    _sinks[_numProps-1] = 
                                        ((IContributeDynamicSink)prop).GetDynamicSink();
                }
                
                return true;
        
            }
        }
    
        internal virtual bool RemoveDynamicProperty(String name)
        {
            lock(this) {
                // We have to remove a property for a specific context
                for (int i=0; i<_numProps; i++)
                {
                    if (_props[i].Name.Equals(name))
                    {
                        _props[i] = _props[_numProps-1];
                        _numProps--;
                        // throw away the dynamic sink list                    
                        _sinks = null;
                        return true;
                    }
                }
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString("Remoting_Contexts_NoProperty"),
                        name));
            }
        }
    
        internal virtual IDynamicProperty[] DynamicProperties
        {
            get 
            {
                if (_props == null)
                {
                    return null;
                }   
                lock (this)
                {         
                    IDynamicProperty[] retProps = new IDynamicProperty[_numProps];
                    Array.Copy(_props, retProps, _numProps);
                    return retProps;
                }
            }
        }
            
        // We have to do this ArrayWithSize thing instead of 
        // separately providing the Array and a Count ... since they
        // may not be in synch with multiple threads changing things
        // We do not want to provide a copy of the array for each
        // call for perf reasons. Besides this is used internally anyways.
        internal virtual ArrayWithSize DynamicSinks
        {
            get
            {
                if (_numProps == 0)
                {
                    return null;
                }
                lock (this)
                {
                    if (_sinks == null)
                    {
                        // Some property got unregistered -- we need to recreate
                        // the list of sinks.
                        _sinks = new IDynamicMessageSink[_numProps+GROW_BY];
                        for (int i=0; i<_numProps; i++)
                        {
                            _sinks[i] = 
                                    ((IContributeDynamicSink)_props[i]).GetDynamicSink();
                        }                
                    }
                }
                return new ArrayWithSize(_sinks, _numProps);
            }
        }
    
        private static IDynamicMessageSink[] GrowDynamicSinksArray(IDynamicMessageSink[] sinks)
        {
            // grow the array
            int newSize = (sinks != null ? sinks.Length : 0)  + GROW_BY;
            IDynamicMessageSink[] newSinks = new IDynamicMessageSink[newSize];
            if (sinks != null)
            {
                // Copy existing properties over
                // Initial size should be chosen so that this rarely happens
                Array.Copy(sinks, newSinks, sinks.Length);
            }
            return newSinks;
        }
    
        internal static void NotifyDynamicSinks(IMessage msg, 
            ArrayWithSize dynSinks, bool bCliSide, bool bStart, bool bAsync)
        {
            for (int i=0; i<dynSinks.Count; i++)
            {
                if (bStart == true)
                {
                    dynSinks.Sinks[i].ProcessMessageStart(msg, bCliSide, bAsync);
                }
                else
                {
                    dynSinks.Sinks[i].ProcessMessageFinish(msg, bCliSide, bAsync);
                }                    
            }
        }    
    
        internal static void CheckPropertyNameClash(String name, IDynamicProperty[] props, int count)
        {
            for (int i=0; i<count; i++)
            {
                if (props[i].Name.Equals(name))
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_DuplicatePropertyName"));
                }
            }        
        }

        internal static IDynamicProperty[] GrowPropertiesArray(IDynamicProperty[] props)
        {
            // grow the array of IContextProperty objects
            int newSize = (props != null ? props.Length : 0)  + GROW_BY;
            IDynamicProperty[] newProps = new IDynamicProperty[newSize];
            if (props != null)
            {
                // Copy existing properties over.
                Array.Copy(props, newProps, props.Length);
            }
            return newProps;
        }

    } //class DynamicPropertyHolder
    
    // Used to return a reference to an array and the current fill size
    // in cases where it is not thread safe to provide this info as two
    // separate properties. This is for internal use only.
    internal class ArrayWithSize
    {
        internal IDynamicMessageSink[] Sinks;
        internal int Count;
        internal ArrayWithSize(IDynamicMessageSink[] sinks, int count)
        {
            Sinks = sinks;
            Count = count;
        }
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\dispatchchannelsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File: DispatchChannelSink.cs

using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;


namespace System.Runtime.Remoting.Channels
{
    internal class DispatchChannelSinkProvider : IServerChannelSinkProvider
    {    
        internal DispatchChannelSinkProvider()
        {
        } // DispatchChannelSinkProvider

        public void GetChannelData(IChannelDataStore channelData)
        {
        }

        public IServerChannelSink CreateSink(IChannelReceiver channel)
        {
            return new DispatchChannelSink();
        }

        public IServerChannelSinkProvider Next
        {
            get { return null; }
            set { throw new NotSupportedException(); }
        }
    } // class DispatchChannelSinkProvider


    internal class DispatchChannelSink : IServerChannelSink
    {
       
        internal DispatchChannelSink()
        {
        } // DispatchChannelSink
        
   
        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders,
            out Stream responseStream)
        {
            if (requestMsg == null)
            {
                throw new ArgumentNullException(
                    "requestMsg", 
                    Environment.GetResourceString("Remoting_Channel_DispatchSinkMessageMissing"));
            }

            // check arguments
            if (requestStream != null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Channel_DispatchSinkWantsNullRequestStream"));
            }

            responseHeaders = null;
            responseStream = null;
            return ChannelServices.DispatchMessage(sinkStack, requestMsg, out responseMsg);                
        } // ProcessMessage
           

        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)                 
        {
            // We never push ourselves to the sink stack, so this won't be called.
            throw new NotSupportedException();            
        } // AsyncProcessResponse


        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            // We never push ourselves to the sink stack, so this won't be called.
            throw new NotSupportedException(); 
        } // GetResponseStream


        public IServerChannelSink NextChannelSink
        {
            get { return null; }
        }


        public IDictionary Properties
        {
            get { return null; }
        } 
         
        
    } // class DispatchChannelSink


} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\iactivator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IActivator.cool
**
** Author(s):   Tarun Anand    (TarunA)
**
** Purpose: Defines the interface provided by activation services
**          
**
** Date:    Jun 26, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Activation {

    using System;
    using System.Runtime.Remoting.Messaging;
    using System.Collections;
    using System.Security.Permissions;
    
    /// <include file='doc\IActivator.uex' path='docs/doc[@for="IActivator"]/*' />
    public interface IActivator
    {
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IActivator.NextActivator"]/*' />
        // return the next activator in the chain
        IActivator NextActivator 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get; 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    set;
	}
        
           /// <include file='doc\IActivator.uex' path='docs/doc[@for="IActivator.Activate"]/*' />
        // New method for activators.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        IConstructionReturnMessage Activate(IConstructionCallMessage msg);     
           /// <include file='doc\IActivator.uex' path='docs/doc[@for="IActivator.Level"]/*' />

           // Returns the level at which this activator is active ..
           // Should return one of the ActivatorLevels below
        ActivatorLevel Level 
	    { 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get;
	    }

           
    }

    /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel"]/*' />
	[Serializable]
    public enum ActivatorLevel
    {
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel.Construction"]/*' />
        Construction = 4,
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel.Context"]/*' />
        Context = 8,
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel.AppDomain"]/*' />
        AppDomain = 12,
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel.Process"]/*' />
        Process = 16,
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="ActivatorLevel.Machine"]/*' />
        Machine = 20
    }

    /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage"]/*' />
    public interface IConstructionCallMessage : IMethodCallMessage
    {
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage.Activator"]/*' />
        IActivator Activator                   
        { 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    set;
	}
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage.CallSiteActivationAttributes"]/*' />
        Object[] CallSiteActivationAttributes  
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	     get;
	}
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage.ActivationTypeName"]/*' />
        String ActivationTypeName               
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get;
        }
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage.ActivationType"]/*' />
        Type ActivationType                     
        { 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	    get;
        }
        /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionCallMessage.ContextProperties"]/*' />
        IList ContextProperties                
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
	     get;
        }
    }
    
    /// <include file='doc\IActivator.uex' path='docs/doc[@for="IConstructionReturnMessage"]/*' />
    public interface IConstructionReturnMessage : IMethodReturnMessage
    {
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\icontributeenvoysink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  The IContributeEnvoySink interface is implemented by properties
//  in the ServerContext that contribute sinks to the serverContext
//  and serverObject chains. The sinks contributed through this 
//  interface are expected to act as Envoys for the corresponding
//  property sinks in the ServerContext and ServerObject chains.
//
namespace System.Runtime.Remoting.Contexts {

    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;
    using System;
    /// <include file='doc\IContributeEnvoySink.uex' path='docs/doc[@for="IContributeEnvoySink"]/*' />
    /// <internalonly/>
    public interface IContributeEnvoySink
    {
        /// <include file='doc\IContributeEnvoySink.uex' path='docs/doc[@for="IContributeEnvoySink.GetEnvoySink"]/*' />
	/// <internalonly/>
        //  Chain your message sink in front of the chain formed thus far and 
        //  return the composite sink chain. This method is used when creating
        //  the sink chain for X-Context cases. The server object is provided
        //  for the interest of object-specific 
        // 
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\icontributeclientcontextsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  The IContributeClientContextSink interface is implemented by 
//  context properties in a Context that wish to contribute 
//  an interception sink at the context boundary on the client end 
//  of a remoting call.
//
namespace System.Runtime.Remoting.Contexts {
    
    using System;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;
    /// <include file='doc\IContributeClientContextSink.uex' path='docs/doc[@for="IContributeClientContextSink"]/*' />
    /// <internalonly/>
    public interface IContributeClientContextSink
    {
        /// <include file='doc\IContributeClientContextSink.uex' path='docs/doc[@for="IContributeClientContextSink.GetClientContextSink"]/*' />
	/// <internalonly/>
        // Chain your message sink in front of the chain formed thus far and 
        // return the composite sink chain.
        // 
       
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IMessageSink GetClientContextSink(IMessageSink nextSink);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\icontributeobjectsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  The IContributeObjectSink interface is implemented by 
//  context properties in a Context that wish to contribute 
//  an object specific interception sink on the server end of 
//  a remoting call.
//
namespace System.Runtime.Remoting.Contexts {

    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Messaging;   
    using System.Security.Permissions;
    using System;
    /// <include file='doc\IContributeObjectSink.uex' path='docs/doc[@for="IContributeObjectSink"]/*' />
    /// <internalonly/>
    public interface IContributeObjectSink
    {
        /// <include file='doc\IContributeObjectSink.uex' path='docs/doc[@for="IContributeObjectSink.GetObjectSink"]/*' />
	/// <internalonly/>
        // Chain your message sink in front of the chain formed thus far and 
        // return the composite sink chain.
        // 
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IMessageSink GetObjectSink(MarshalByRefObject obj, 
                                          IMessageSink nextSink);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\icontributeservercontextsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  The IContributeServerContextSink interface is implemented by 
//  context properties in a Context that wish to contribute 
//  an interception sink at the context boundary on the server end 
//  of a remoting call.
//
namespace System.Runtime.Remoting.Contexts {

    using System;
    using System.Runtime.Remoting.Messaging;    
    using System.Security.Permissions;
    /// <include file='doc\IContributeServerContextSink.uex' path='docs/doc[@for="IContributeServerContextSink"]/*' />
    /// <internalonly/>
    public interface IContributeServerContextSink
    {
        /// <include file='doc\IContributeServerContextSink.uex' path='docs/doc[@for="IContributeServerContextSink.GetServerContextSink"]/*' />
	/// <internalonly/>
        // Chain your message sink in front of the chain formed thus far and 
        // return the composite sink chain.
        // 
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IMessageSink GetServerContextSink(IMessageSink nextSink);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\icontributedynamicsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//   The IContributeDynamicSink interface is implemented by properties
//   that are registered at run-time through the RemotingServices.
//   RegisterDynamicProperty API. These properties can contribute sinks
//   that are notified when remoting calls start/finish. 
//
//   See also RemotingServices.RegisterDynamicProperty API.
//
namespace System.Runtime.Remoting.Contexts {
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;
    using System;
    /// <include file='doc\IContributeDynamicSink.uex' path='docs/doc[@for="IContributeDynamicSink"]/*' />
    /// <internalonly/>
    public interface IContributeDynamicSink
    {
        /// <include file='doc\IContributeDynamicSink.uex' path='docs/doc[@for="IContributeDynamicSink.GetDynamicSink"]/*' />
	/// <internalonly/>
       //   Returns the message sink that will be notified of call start/finish events
       //   through the IDynamicMessageSink interface.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IDynamicMessageSink GetDynamicSink();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\ichannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IChannel.cool
**
** Author:  Tarun Anand (TarunA)
**          Caleb Doise (calebd)
**
** Purpose: Defines the interfaces implemented by channels
**
** Date:    May 27, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Channels {
    using System.Collections;
    using System.IO;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Security.Permissions;
    using System;
    using System.Globalization;
    
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannel"]/*' />
    public interface IChannel
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannel.ChannelPriority"]/*' />
        int ChannelPriority 
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
    	    get; 
	}
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannel.ChannelName"]/*' />
        String ChannelName
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
	    get; 
        }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannel.Parse"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        String Parse(String url, out String objectURI);
    }
    
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelSender"]/*' />
    public interface IChannelSender : IChannel
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelSender.CreateMessageSink"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        IMessageSink CreateMessageSink(String url, Object remoteChannelData, out String objectURI);
    } // interface IChannelSender
    
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiver"]/*' />
    public interface IChannelReceiver : IChannel
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiver.ChannelData"]/*' />
        Object ChannelData 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
	    get;
	}
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiver.GetUrlsForUri"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        String[] GetUrlsForUri(String objectURI);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiver.StartListening"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        void StartListening(Object data);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiver.StopListening"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        void StopListening(Object data);
    } // interface IChannelReceiver 


    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiverHook"]/*' />
    public interface IChannelReceiverHook
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiverHook.ChannelScheme"]/*' />
        String ChannelScheme
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
            get;
	}

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiverHook.WantsToListen"]/*' />
        bool WantsToListen
        { 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
	    get;
        }

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiverHook.ChannelSinkChain"]/*' />
        IServerChannelSink ChannelSinkChain
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 	
	     get;
        }

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelReceiverHook.AddHookChannelUri"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        void AddHookChannelUri(String channelUri);
        
    } // interface IChannelReceiverHook

    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSinkProvider"]/*' />
    public interface IClientChannelSinkProvider
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSinkProvider.CreateSink"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
        IClientChannelSink CreateSink(IChannelSender channel, String url, Object remoteChannelData);

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSinkProvider.Next"]/*' />
        IClientChannelSinkProvider Next 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 
	     get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	      set; 
        }
    } // interface IClientChannelSinkProvider


    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSinkProvider"]/*' />
    public interface IServerChannelSinkProvider
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSinkProvider.GetChannelData"]/*' />
        // The sink provider should also chain this call to the next provider in the chain.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void GetChannelData(IChannelDataStore channelData);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSinkProvider.CreateSink"]/*' />
        
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IServerChannelSink CreateSink(IChannelReceiver channel);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSinkProvider.Next"]/*' />

        IServerChannelSinkProvider Next
	{ 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
            set;
	}
    } // interface IServerChannelSinkProvider


    // This has the same exact functionality as IClientChannelSinkProvider.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientFormatterSinkProvider"]/*' />
    public interface IClientFormatterSinkProvider : IClientChannelSinkProvider
    {
    } // interface IClientFormatterSinkProvider


    // This has the same exact functionality as IServerChannelSinkProvider.
    // There may be multiple formatter sinks. If there are more than one, then one
    // formatter sink may decide to delegate the formatting responsibilities to the next
    // one.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerFormatterSinkProvider"]/*' />
    public interface IServerFormatterSinkProvider : IServerChannelSinkProvider
    {
    } // interface IServerFormatterSinkProvider



    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink"]/*' />
    public interface IClientChannelSink : IChannelSinkBase
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink.ProcessMessage"]/*' />
        // Parameters:
        //   msg - it's the "IMethodCallMessage"
        //   requestHeaders - headers to add to the outgoing message heading to server
        //   requestStream - stream headed towards the transport sink
        //   responseHeaders - headers that server returned
        //   responseStream - stream coming back from the transport sink
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void ProcessMessage(IMessage msg,
                            ITransportHeaders requestHeaders, Stream requestStream,
                            out ITransportHeaders responseHeaders, out Stream responseStream);
                            
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink.AsyncProcessRequest"]/*' />
        // Parameters: (for async calls, the transport sink is responsible for doing the write
        //     and read asynchronously)
        //   sinkStack - channel sinks who called this one
        //   msg - it's the "IMessage" msg
        //   headers - headers to add to the outgoing message heading to server
        //   stream - stream headed towards the transport sink
        // Returns:
        //   IAsyncResult for this call.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg,
                                 ITransportHeaders headers, Stream stream);
                                 
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink.AsyncProcessResponse"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, Object state,
                                  ITransportHeaders headers, Stream stream);
                                  
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink.GetRequestStream"]/*' />
        // Parameters:
        //   msg - it's the "IMethodCallMessage"
        //   headers - headers to add to the outgoing message heading to server
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientChannelSink.NextChannelSink"]/*' />


        // the next channel sink in the chain
        IClientChannelSink NextChannelSink
        { 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	}
        
    } // IClientChannelSink
    


    /// <include file='doc\IChannel.uex' path='docs/doc[@for="ServerProcessing"]/*' />
    [Serializable]
    public enum ServerProcessing
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ServerProcessing.Complete"]/*' />
        Complete, // server synchronously processed message
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ServerProcessing.OneWay"]/*' />
        OneWay,   // message dispatched and no response should be sent
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ServerProcessing.Async"]/*' />
        Async     // the call was dispatched asynchronously
                  //   (sink should store data on stack for later processing)
    } // ServerProcessing


    // Used for security sink and transport sinks.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSink"]/*' />
    public interface IServerChannelSink : IChannelSinkBase
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSink.ProcessMessage"]/*' />
        // Parameters:
        //   sinkStack - channel sinks who called this one
        //   requestMsg - deserialized request message or null if the stream hasn't been deserialized
        //   requestHeaders - headers retrieved from the incoming message from client
        //   requestStream - stream to process and pass onto towards the deserialization sink.
        //   responseMsg - response message
        //   responseHeaders - headers to add to return message heading to client
        //   responseStream - stream heading back towards the transport sink
        // Returns:
        //   Provides information about how message was processed.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
                                        IMessage requestMsg,
                                        ITransportHeaders requestHeaders, Stream requestStream,
                                        out IMessage responseMsg, out ITransportHeaders responseHeaders,
                                        out Stream responseStream);
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSink.AsyncProcessResponse"]/*' />

        // Parameters: (for async calls)
        //   sinkStack - sink stack (leading back to the server transport sink)
        //   headers - headers to add to return message heading to client
        //   stream - stream heading back towards the transport sink
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                  IMessage msg, ITransportHeaders headers, Stream stream);                   
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSink.GetResponseStream"]/*' />

        // Parameters:
        //   sinkStack - sink stack (leading back to the server transport sink)  
        //   state - state that had been pushed to the stack by this sink
        //   msg - it's the "IMethodCallMessage"
        //   headers - headers to put in response message to client 
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                 IMessage msg, ITransportHeaders headers);                               
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IServerChannelSink.NextChannelSink"]/*' />


        // the next channel sink in the chain
        IServerChannelSink NextChannelSink 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     get;
        }

    } // interface IServerChannelSink


    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelSinkBase"]/*' />
    public interface IChannelSinkBase
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelSinkBase.Properties"]/*' />
        // This returns a dictionary through which properties on the sink may be retrieved
        // or configured. If a property is not present in this sink, it should delegate the
        // the property get or set to the next sink in the chain.
        IDictionary Properties 
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     get;
	}  
    }



    // Client formatter sinks are both a message sink and a channel sink.
    // They initially transform the message into a stream.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IClientFormatterSink"]/*' />
    public interface IClientFormatterSink : IMessageSink, IClientChannelSink
    {
    } // interface IClientFormatterSink




    // Channels wishing to use the channel sink architecture must implement this interface
    //   on their ChannelData object.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelDataStore"]/*' />
    public interface IChannelDataStore
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelDataStore.ChannelUris"]/*' />
        String[] ChannelUris 
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 			
	     get;
	}
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="IChannelDataStore.this"]/*' />
    
        Object this[Object key] 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     set;
	}
    } // interface IChannelDataStore


    // Used to store channel data for our remoting channels
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="ChannelDataStore"]/*' />
    [Serializable,
    SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)
    ]
    public class ChannelDataStore : IChannelDataStore
    {
        String[]           _channelURIs;  // list of channel uri's that map to this channel
        
        DictionaryEntry[]  _extraData;    // sink data

        // private constructor for shallow clone    
        private ChannelDataStore(String[] channelUrls, DictionaryEntry[] extraData)
        {
            _channelURIs = channelUrls;
            _extraData = extraData;
        }

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ChannelDataStore.ChannelDataStore"]/*' />
        public ChannelDataStore(String[] channelURIs)
        {
            _channelURIs = channelURIs;
            _extraData = null;
        }

        internal ChannelDataStore InternalShallowCopy()
        {
            return new ChannelDataStore(_channelURIs, _extraData);
        }


        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ChannelDataStore.ChannelUris"]/*' />
        public String[] ChannelUris
        {
            get { return _channelURIs; }
            set { _channelURIs = value; }
        }

        // implementation of IChannelDataStore
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ChannelDataStore.this"]/*' />
        public Object this[Object key]
        {
            get 
            {
                // look for matching key in extra data list
                foreach (DictionaryEntry entry in _extraData)
                {
                    if (entry.Key.Equals(key))
                        return entry.Value;                    
                }

                // entry not found
                return null;
            } // get

            set
            {
                if (_extraData == null)
                {
                    _extraData = new DictionaryEntry[1];
                    _extraData[0] = new DictionaryEntry(key, value);
                }
                else
                {
                    int length =_extraData.Length;
                    DictionaryEntry[] newList = new DictionaryEntry[length + 1];
                    int co = 0;
                    for (; co < length; co++)
                        newList[co] = _extraData[co];
                    newList[co] = new DictionaryEntry(key, value); // set last value
                    _extraData = newList;
                }
            } // set
        } // Object this[Object key]
        
    } // class ChannelDataStore




    /// <include file='doc\IChannel.uex' path='docs/doc[@for="ITransportHeaders"]/*' />
    public interface ITransportHeaders
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ITransportHeaders.this"]/*' />
        // Should add headers in order, and remove them if somebody tries to set
        //   it to null.
        Object this[Object key]
	{ 
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    set;
	}
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="ITransportHeaders.GetEnumerator"]/*' />

        // This is required to handback an enumerator which iterates over all entries
        //   in the headers.
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IEnumerator GetEnumerator();
    } // interface ITransportHeaders


    // TransportHeaders is used to store a collection of headers that is used in the channel sinks.
    // The header list preserves order, and keeps headers in the order that they were originally
    // added. You can use the foreach statement to iterate over the contents of the header list 
    // which contains objects of type DictionaryEntry. Keys are required to be strings, and
    // comparisons are done on a case-insensitive basis.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="TransportHeaders"]/*' />
    [Serializable,    
    SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
    public class TransportHeaders : ITransportHeaders
    {
        private ArrayList _headerList; // array of type DictionaryEntry
    
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="TransportHeaders.TransportHeaders"]/*' />
        public TransportHeaders()
        {
            // The default capacity is larger than we'll typically need so start off at 6.
            _headerList = new ArrayList(6);
        } // TransportHeaders


        // dictionary like interface
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="TransportHeaders.this"]/*' />
        public Object this[Object key]
        {
            get 
            {
                String strKey = (String)key;
                
                // look for matching key in header list
                foreach (DictionaryEntry entry in _headerList)
                {
                    if (String.Compare((String)entry.Key, strKey, true, CultureInfo.InvariantCulture) == 0)
                        return entry.Value;                    
                }

                // entry not found
                return null;
            } // get

            set
            {
                if (key == null)
                    return;

                String strKey = (String)key;

                // remove this entry if it's already in the list
                int co = _headerList.Count - 1;
                while (co >= 0)
                {                
                    String headerKey = (String)((DictionaryEntry)_headerList[co]).Key;
                    if (String.Compare(headerKey, strKey, true, CultureInfo.InvariantCulture) == 0)
                    {
                        _headerList.RemoveAt(co);
                        break;
                    }
                    co--;
                }

                // otherwise, add this entry
                if (value != null)
                {
                    _headerList.Add(new DictionaryEntry(key, value));
                }
            } // set
        } // Object this[Object key]


        /// <include file='doc\IChannel.uex' path='docs/doc[@for="TransportHeaders.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() 
        {
            return _headerList.GetEnumerator(); 
        } // GetEnumerator
        
    } // TransportHeaders



    // All sink providers must have a constructor that accepts a hashtable and 
    //   an ArrayList of these structures if they want to be used from a config file.
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="SinkProviderData"]/*' />
    public class SinkProviderData
    {
        private String _name;
        private Hashtable _properties = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
        private ArrayList _children = new ArrayList();

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="SinkProviderData.SinkProviderData"]/*' />
        public SinkProviderData(String name) 
        {
            _name = name;
        }

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="SinkProviderData.Name"]/*' />
        public String Name { get { return _name; } }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="SinkProviderData.Properties"]/*' />
        public IDictionary Properties { get { return _properties; } }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="SinkProviderData.Children"]/*' />
        public IList Children { get { return _children; } }
    } // class SinkProviderData





    // Base implementation for channel sinks that want to supply properties.
    // The derived class only needs to implement the Keys property and this[].
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelSinkWithProperties"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]
    public abstract class BaseChannelSinkWithProperties : BaseChannelObjectWithProperties
    {       
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelSinkWithProperties.BaseChannelSinkWithProperties"]/*' />
        protected BaseChannelSinkWithProperties() : base()
        {
        }    
    } // class BaseChannelSinkWithProperties


    // This provides a base implementation of a channel that wants
    // to provide a dictionary interface. It handles the complexity
    // of asking a channel sink chain for their properties.
    // Once the channel constructs its sink chain (usually only applicable
    // for server channels) it should set the SinksWithProperties property.
    // The properties only get chained for channel sinks when the users asks
    // for the "Properties" dictionary. If you just go through the dictionary interface
    // you'll only get the channel specific properties.
    // The derived class only needs to implement the Keys property and this[].
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelWithProperties"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]
    public abstract class BaseChannelWithProperties : BaseChannelObjectWithProperties
    {    
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelWithProperties.SinksWithProperties"]/*' />
        protected IChannelSinkBase SinksWithProperties = null;

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelWithProperties.BaseChannelWithProperties"]/*' />
        protected BaseChannelWithProperties() : base()
        {
        }

        // This is overridden so that server channels can expose the properties
        //   of their channel sinks through a flat dictionary interface.
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelWithProperties.Properties"]/*' />
        public override IDictionary Properties 
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
            get
            {
                // collect dictionaries for all channel sinks and return
                //   aggregate dictionary
                ArrayList dictionaries = new ArrayList();

                // add the channel itself
                dictionaries.Add(this);

                if (SinksWithProperties != null)
                {
                    IServerChannelSink srvSink = SinksWithProperties as IServerChannelSink;
                    if (srvSink != null)
                    {
                        while (srvSink != null)
                        {
                            IDictionary dict = srvSink.Properties;
                            if (dict != null)
                                dictionaries.Add(dict);

                            srvSink = srvSink.NextChannelSink;
                        }
                    }
                    else
                    {
                        // we know it's a client channel sink
                        IClientChannelSink chnlSink = (IClientChannelSink)SinksWithProperties;                        
                        
                        while (chnlSink != null)
                        {
                            IDictionary dict = chnlSink.Properties;
                            if (dict != null)
                                dictionaries.Add(dict);

                            chnlSink = chnlSink.NextChannelSink;
                        }
                    }                    
                }

                // return a dictionary that spans all dictionaries provided
                return new AggregateDictionary(dictionaries);
            }
        } 

    } // class BaseChannelWithProperties

    





    // Base implementation for channel sinks that want to supply properties.
    // The derived class only needs to implement the Keys property and this[].
    /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]
    public abstract class BaseChannelObjectWithProperties : IDictionary
    {
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.BaseChannelObjectWithProperties"]/*' />
        public BaseChannelObjectWithProperties()
        {
        }   

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Properties"]/*' />
        public virtual IDictionary Properties { 
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
            get { return this; } 
        }

        // 
        // IDictionary implementation        
        //

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.this"]/*' />
        public virtual Object this[Object key]
        {
            get { return null; }            
            set { throw new NotImplementedException(); } 
        } // Object this[Object key]

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Keys"]/*' />
        public virtual ICollection Keys { get { return null; } }
        
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Values"]/*' />
        public virtual ICollection Values
        {
            get
            {
                ICollection keys = Keys;
                if (keys == null)
                    return null;

                ArrayList values = new ArrayList();
                foreach (Object key in keys)
                {
                    values.Add(this[key]);
                }                

                return values;
            }
        }       

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Contains"]/*' />
        public virtual bool Contains(Object key) 
        {
            if (key == null)
                return false;

            ICollection keySet = Keys;
            if (keySet == null)
                return false;

            String keyStr = key as String;
        
            foreach (Object someKey in keySet)
            {
                if (keyStr != null)
                {
                    String someKeyStr = someKey as String;
                    if (someKeyStr != null)
                    {
                        // compare the key strings case-insensitively
                        if (String.Compare(keyStr, someKeyStr, true, CultureInfo.InvariantCulture) == 0)
                            return true;

                        continue;
                    }
                }                
            
                if (key.Equals(someKey))
                    return true;
            }

            return false;
        } // Contains

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.IsReadOnly"]/*' />
        public virtual bool IsReadOnly { get { return false; } }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.IsFixedSize"]/*' />
        public virtual bool IsFixedSize { get { return true; } } 

        // The following three methods should never be implemented because
        // they don't apply to the way IDictionary is being used in this case
        // (plus, IsFixedSize returns true.)
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Add"]/*' />
        public virtual void Add(Object key, Object value) { throw new NotSupportedException(); }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Clear"]/*' />
        public virtual void Clear() { throw new NotSupportedException(); }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Remove"]/*' />
        public virtual void Remove(Object key) { throw new NotSupportedException(); }
        
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        } // GetEnumerator
                            

        //
        // end of IDictionary implementation 
        //

        //
        // ICollection implementation 
        //

         //ICollection

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.CopyTo"]/*' />
        public virtual void CopyTo(Array array, int index) { throw new NotSupportedException(); }

        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.Count"]/*' />
        public virtual int Count 
        {
            get 
            {
                ICollection keySet = Keys;
                if (keySet == null)
                    return 0;
                    
                return keySet.Count; 
            }
        } // Count
        
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.SyncRoot"]/*' />
        public virtual Object SyncRoot { get { return this; } }
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.IsSynchronized"]/*' />
        public virtual bool IsSynchronized { get { return false; } }

        //
        // end of ICollection implementation
        //

        //IEnumerable
        /// <include file='doc\IChannel.uex' path='docs/doc[@for="BaseChannelObjectWithProperties.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        }
    
    } // class BaseChannelObjectWithProperties



    // an enumerator based off of a key set
    internal class DictionaryEnumeratorByKeys : IDictionaryEnumerator
    {
        IDictionary _properties;
        IEnumerator _keyEnum;
    
        public DictionaryEnumeratorByKeys(IDictionary properties)
        {
            _properties = properties;
            _keyEnum = properties.Keys.GetEnumerator();
        } // PropertyEnumeratorByKeys

        public bool MoveNext() { return _keyEnum.MoveNext(); }        
        public void Reset() { _keyEnum.Reset(); }        
        public Object Current { get { return Entry; } }

        public DictionaryEntry Entry { get { return new DictionaryEntry(Key, Value); } }
        
        public Object Key { get { return _keyEnum.Current; } }
        public Object Value { get { return _properties[Key]; } }       
        
    } // DictionaryEnumeratorByKeys


    // combines multiple dictionaries into one
    //   (used for channel sink properties
    internal class AggregateDictionary : IDictionary
    {
        private ICollection _dictionaries;
            
        public AggregateDictionary(ICollection dictionaries)
        { 
            _dictionaries = dictionaries;
        } // AggregateDictionary  

        // 
        // IDictionary implementation        
        //

        public virtual Object this[Object key]
        {
            get 
            {
                foreach (IDictionary dict in _dictionaries)
                {
                    if (dict.Contains(key))
                        return dict[key];
                }
            
                return null; 
            }
                
            set
            {
                foreach (IDictionary dict in _dictionaries)
                {
                    if (dict.Contains(key))
                        dict[key] = value;
                }
            } 
        } // Object this[Object key]

        public virtual ICollection Keys 
        {
            get
            {
                ArrayList keys = new ArrayList();
                // add keys from every dictionary
                foreach (IDictionary dict in _dictionaries)
                {
                    ICollection dictKeys = dict.Keys;
                    if (dictKeys != null)
                    {
                        foreach (Object key in dictKeys)
                        {
                            keys.Add(key);
                        }
                    }
                }

                return keys;
            }
        } // Keys
        
        public virtual ICollection Values
        {
            get
            {
                ArrayList values = new ArrayList();
                // add values from every dictionary
                foreach (IDictionary dict in _dictionaries)
                {
                    ICollection dictValues = dict.Values;
                    if (dictValues != null)
                    {
                        foreach (Object value in dictValues)
                        {
                            values.Add(value);
                        }
                    }
                }

                return values;
            }
        } // Values

        public virtual bool Contains(Object key) 
        {
            foreach (IDictionary dict in _dictionaries)
            {
                if (dict.Contains(key))
                    return true;
            }
            
            return false; 
        } // Contains

        public virtual bool IsReadOnly { get { return false; } }
        public virtual bool IsFixedSize { get { return true; } } 

        // The following three methods should never be implemented because
        // they don't apply to the way IDictionary is being used in this case
        // (plus, IsFixedSize returns true.)
        public virtual void Add(Object key, Object value) { throw new NotSupportedException(); }
        public virtual void Clear() { throw new NotSupportedException(); }
        public virtual void Remove(Object key) { throw new NotSupportedException(); }
        
        public virtual IDictionaryEnumerator GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        } // GetEnumerator
                            

        //
        // end of IDictionary implementation 
        //

        //
        // ICollection implementation 
        //

        //ICollection

        public virtual void CopyTo(Array array, int index) { throw new NotSupportedException(); }

        public virtual int Count 
        {
            get 
            {
                int count = 0;
            
                foreach (IDictionary dict in _dictionaries)
                {
                    count += dict.Count;
                }

                return count;
            }
        } // Count
        
        public virtual Object SyncRoot { get { return this; } }
        public virtual bool IsSynchronized { get { return false; } }

        //
        // end of ICollection implementation
        //

        //IEnumerable
        IEnumerator IEnumerable.GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        }
    
    } // class AggregateDictionary


    
} // namespace System.Runtime.Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\identity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Remoting {
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Lifetime;
    using System.Security.Cryptography;
    using System.Threading;
    using System;
    //  Identity is the base class for remoting identities. An instance of Identity (or a derived class)
    //  is associated with each instance of a remoted object. Likewise, an instance of Identity is
    //  associated with each instance of a remoting proxy.
    //
    using System.Collections;
    internal class Identity {
        // We use a Guid to create a URI from. Each time a new URI is needed we increment
        // the sequence number and append it to the statically inited Guid.
        // private static readonly Guid IDGuid = Guid.NewGuid();

        internal static String ProcessIDGuid
        {
            get
            {
                return SharedStatics.Remoting_Identity_IDGuid;
            }
        }

        // We need the original and the configured one because we have to compare
        //   both when looking at a uri since something might be marshalled before
        //   the id is set.
        private static String s_originalAppDomainGuid = Guid.NewGuid().ToString().Replace('-', '_');
        private static String s_configuredAppDomainGuid = null;

        internal static String AppDomainUniqueId
        {
            get
            {
                if (s_configuredAppDomainGuid != null)
                    return s_configuredAppDomainGuid;
                else
                    return s_originalAppDomainGuid;
            } // get

            set
            {
                lock (s_originalAppDomainGuid)
                {
                    if (s_configuredAppDomainGuid != null)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Config_AppIdAlreadySet"));
                    }

                    s_configuredAppDomainGuid = value;
                    s_configuredAppDomainGuidString = "/" + s_configuredAppDomainGuid + "/";
                    s_IDGuidString = s_configuredAppDomainGuidString;
                }
            } // set
        } // AppDomainGuid

        private static String s_originalAppDomainGuidString = "/" + s_originalAppDomainGuid.ToLower(CultureInfo.InvariantCulture) + "/";
        private static String s_configuredAppDomainGuidString = null;

        private static String s_IDGuidString = "/" + s_originalAppDomainGuid.ToLower(CultureInfo.InvariantCulture) + "/";

        // Used to get random numbers 
        private static RNGCryptoServiceProvider s_rng = new RNGCryptoServiceProvider();


        internal static String IDGuidString
        {
            get { return s_IDGuidString; }
        }


        internal static String RemoveAppNameOrAppGuidIfNecessary(String uri)
        {
            // uri is assumed to be in lower-case at this point

            // If the uri starts with either, "/<appname>/" or "/<appdomainguid>/" we
            //   should strip that off.

            // We only need to look further if the uri starts with a "/".
            if ((uri == null) || (uri.Length <= 1) || (uri[0] != '/'))
                return uri;

            // compare to process guid (guid string already has slash at beginnning and end)
            String guidStr;
            if (s_configuredAppDomainGuidString != null)
            {
                guidStr = s_configuredAppDomainGuidString;
                if (uri.Length > guidStr.Length)
                {
                    if (StringStartsWith(uri, guidStr))
                    {
                        // remove "/<appdomainguid>/"
                        return uri.Substring(guidStr.Length);
                    }
                }
            }

            // always need to check original guid as well in case the object with this
            //   uri was marshalled before we changed the app domain id
            guidStr = s_originalAppDomainGuidString;
            if (uri.Length > guidStr.Length)
            {
                if (StringStartsWith(uri, guidStr))
                {
                    // remove "/<appdomainguid>/"
                    return uri.Substring(guidStr.Length);
                }
            }

            // compare to application name (application name will never have slashes)
            String appName = RemotingConfiguration.ApplicationName;
            if (appName != null)
            {
                // add +2 to appName length for surrounding slashes
                if (uri.Length > (appName.Length + 2))
                {
                    if (String.Compare(uri, 1, appName, 0, appName.Length, true, CultureInfo.InvariantCulture) == 0)
                    {
                        // now, make sure there is a slash after "/<appname>" in uri
                        if (uri[appName.Length + 1] == '/')
                        {
                            // remove "/<appname>/"
                            return uri.Substring(appName.Length + 2);
                        }
                    }
                }
            }

            // it didn't start with "/<appname>/" or "/<processguid>/", so just remove the
            //   first slash and return.
            uri = uri.Substring(1);
            return uri;
        } // RemoveAppNameOrAppGuidIfNecessary


        private static bool StringStartsWith(String s1, String prefix)
        {
            // String.StartsWith uses String.Compare instead of String.CompareOrdinal,
            //   so we provide our own implementation of StartsWith.

            if (s1.Length < prefix.Length)
                return false;

            return (String.CompareOrdinal(s1, 0, prefix, 0, prefix.Length) == 0);
        } // StringStartsWith



        // DISCONNECTED_FULL denotes that the object is disconnected
        // from both local & remote (x-appdomain & higher) clients

        // DISCONNECTED_REM denotes that the object is disconnected
        // from remote (x-appdomain & higher) clients ... however
        // x-context proxies continue to work as expected.

        protected const int IDFLG_DISCONNECTED_FULL= 0x00000001;
        protected const int IDFLG_DISCONNECTED_REM = 0x00000002;
        protected const int IDFLG_IN_IDTABLE       = 0x00000004;

        protected const int IDFLG_CONTEXT_BOUND    = 0x00000010;
        protected const int IDFLG_WELLKNOWN        = 0x00000100;
        protected const int IDFLG_SERVER_SINGLECALL= 0x00000200;
        protected const int IDFLG_SERVER_SINGLETON = 0x00000400;

        internal int _flags;

        internal Object _tpOrObject;
        protected String _ObjURI;
        protected String _URL;

        // These have to be "Object" to use Interlocked operations
        internal Object _objRef;
        internal Object _channelSink;

        // Remoting proxy has this field too, we use the latter only for
        // ContextBoundObject identities.
        internal Object _envoyChain;

        // This manages the dynamically registered sinks for the proxy.
        internal DynamicPropertyHolder _dph;

        // Lease for object
        internal Lease _lease;

        internal static String ProcessGuid {get {return ProcessIDGuid;}}

        private static int GetNextSeqNum()
        {
            return SharedStatics.Remoting_Identity_GetNextSeqNum();
        }

        private static Byte[] GetRandomBytes()
        {
            // PERF? In a situation where objects need URIs at a very fast
            // rate, we will end up creating too many of these tiny byte-arrays
            // causing pressure on GC!
            // One option would be to have a buff in the managed thread class
            // and use that to get a chunk of random bytes consuming 
            // 18 bytes at a time. 
            // This would avoid the need to have a lock across threads.
            Byte[] randomBytes = new byte[18];
            s_rng.GetBytes(randomBytes);
            return randomBytes;
        }

        // Constructs a new identity using the given the URI. This is used for
        // creating client side identities.
        //
        //
        internal Identity(String objURI, String URL)
        {
            BCLDebug.Assert(objURI!=null,"objURI should not be null here");
            if (URL != null)
            {
                _flags |= IDFLG_WELLKNOWN;
                _URL = URL;
            }
            SetOrCreateURI(objURI, true /*calling from ID ctor*/);
        }

        // Constructs a new identity. This is used for creating server side
        // identities. The URI for server side identities is lazily generated
        // during the first call to Marshal because if we associate a URI with the
        // object at the time of creation then you cannot call Marshal with a
        // URI of your own choice.
        //
        //
        internal Identity(bool bContextBound)
        {
            if(bContextBound)
                _flags |= IDFLG_CONTEXT_BOUND;
        }

        internal bool IsContextBound {
            get  {
                return (_flags&IDFLG_CONTEXT_BOUND) == IDFLG_CONTEXT_BOUND;
            }
        }

        internal bool IsWellKnown()
        {
            return (_flags&IDFLG_WELLKNOWN) == IDFLG_WELLKNOWN;
        }

        internal void SetInIDTable()
        {
            while(true) {
                int currentFlags = _flags;
                int newFlags = _flags | IDFLG_IN_IDTABLE;
                if(currentFlags == Interlocked.CompareExchange(ref _flags, newFlags, currentFlags))
                    break;
            }
        }

        internal void ResetInIDTable(bool bResetURI)
        {
            BCLDebug.Assert(IdentityHolder.IsWriterLockHeld(), "IDTable should be write-locked");
            while(true) {
                int currentFlags = _flags;
                int newFlags = _flags & (~IDFLG_IN_IDTABLE);
                if(currentFlags == Interlocked.CompareExchange(ref _flags, newFlags, currentFlags))
                    break;
            }
            // bResetURI is true for the external API call to Disconnect, it is
            // false otherwise. Thus when a user Disconnects an object 
            // its URI will get reset but if lifetime service times it out 
            // it will not clear out the URIs
            if (bResetURI)
            {
                ((ObjRef)_objRef).URI = null;
                _ObjURI = null;
            }
        }

        internal bool IsInIDTable()
        {
            return((_flags & IDFLG_IN_IDTABLE) == IDFLG_IN_IDTABLE);
        }

        internal void SetFullyDisconnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");

            while(true) {
                int currentFlags = _flags;
                int newFlags = _flags | IDFLG_DISCONNECTED_FULL | IDFLG_DISCONNECTED_REM;
                if(currentFlags == Interlocked.CompareExchange(ref _flags, newFlags, currentFlags))
                    break;
            }
        }

        internal void SetFullyConnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");
            BCLDebug.Assert(
                (_ObjURI != null),
                "Object must be assigned a URI to be fully connected!");

            while(true) {
                int currentFlags = _flags;
                int newFlags = _flags & (~(IDFLG_DISCONNECTED_FULL | IDFLG_DISCONNECTED_REM));
                if(currentFlags == Interlocked.CompareExchange(ref _flags, newFlags, currentFlags))
                    break;
            }
        }

        internal bool IsFullyDisconnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");
            return (_flags&IDFLG_DISCONNECTED_FULL) == IDFLG_DISCONNECTED_FULL;
        }

        internal void SetRemoteDisconnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");

            while(true) {
                int currentFlags = _flags;
                int newFlags = _flags | IDFLG_DISCONNECTED_REM;
                if(currentFlags == Interlocked.CompareExchange(ref _flags, newFlags, currentFlags))
                    break;
            }
        }

        internal bool IsRemoteDisconnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");
            return (_flags&IDFLG_DISCONNECTED_REM) == IDFLG_DISCONNECTED_REM;
        }

        internal bool IsDisconnected()
        {
            BCLDebug.Assert(
                this is ServerIdentity,
                "should be setting these flags for srvIDs only!");
            return (IsFullyDisconnected() || IsRemoteDisconnected());
        }

        // Get the URI
        internal String URI
        {
            get
            {
                if(IsWellKnown())
                {
                    return _URL;
                }
                else
                {
                    return _ObjURI;
                }
            }
        }

        internal String ObjURI
        {
            get { return _ObjURI; }
        }

        internal MarshalByRefObject TPOrObject
        {
            get
            {
                return (MarshalByRefObject) _tpOrObject;
            }
        }

       //   Set the transparentProxy field protecting against races. The returned transparent
       //   proxy could be different than the one the caller is attempting to set.
       //
        internal Object  RaceSetTransparentProxy(Object tpObj)
        {
            if (_tpOrObject == null)
                Interlocked.CompareExchange(ref _tpOrObject, tpObj, null);
            return _tpOrObject;
        }

        // Get the ObjRef.
        internal ObjRef ObjectRef
        {
            get
            {
                return (ObjRef) _objRef;
            }
        }

       //   Set the objRef field protecting against races. The returned objRef
       //   could be different than the one the caller is attempting to set.
       //
        internal ObjRef  RaceSetObjRef(ObjRef objRefGiven)
        {
            if (_objRef == null)
            {
                Interlocked.CompareExchange(ref _objRef, objRefGiven, null);
            }
            return (ObjRef) _objRef;
        }


        // Get the ChannelSink.
        internal IMessageSink ChannelSink
        {
            get { return (IMessageSink) _channelSink;}
        }

       //   Set the channelSink field protecting against races. The returned
       //   channelSink proxy could be different than the one the caller is
       //   attempting to set.
       //
        internal IMessageSink  RaceSetChannelSink(IMessageSink channelSink)
        {
            if (_channelSink == null)
            {
                Interlocked.CompareExchange(
                                        ref _channelSink,
                                        channelSink,
                                        null);
            }
            return (IMessageSink) _channelSink;
        }

        // Get/Set the Envoy Sink chain..
        internal IMessageSink EnvoyChain
        {
            get
            {
                return (IMessageSink)_envoyChain;
            }
        }

        // Get/Set Lease
        internal Lease Lease
        {
            get
            {
                return _lease;
            }
            set
            {
                _lease = value;
            }
        }


       //   Set the channelSink field protecting against races. The returned
       //   channelSink proxy could be different than the one the caller is
       //   attempting to set.
       //
        internal IMessageSink RaceSetEnvoyChain(
                    IMessageSink envoyChain)
        {
            if (_envoyChain == null)
            {
                Interlocked.CompareExchange(
                                ref _envoyChain,
                                envoyChain,
                                null);
            }
            return (IMessageSink) _envoyChain;
        }

        // A URI is lazily generated for the identity based on a GUID.
        // Well known objects supply their own URI
        internal void SetOrCreateURI(String uri)
        {
            SetOrCreateURI(uri, false);
        }

        internal void SetOrCreateURI(String uri, bool bIdCtor)
        {
            if(bIdCtor == false)
            {
                // This method is called either from the ID Constructor or
                // with a writeLock on the ID Table
                BCLDebug.Assert(IdentityHolder.IsWriterLockHeld(), "IDTable should be write-locked");
                if (null != _ObjURI) {
                    throw new RemotingException(
                        Environment.GetResourceString("Remoting_SetObjectUriForMarshal__UriExists"));
                }
            }

            if(null == uri)
            {
                // We insert the tick count, so that the uri is not 100% predictable.
                // (i.e. perhaps we should consider using a random number as well)
                String random = System.Convert.ToBase64String(GetRandomBytes());
                // Need to replace the '/' with '_' since '/' is not a valid uri char
                _ObjURI = IDGuidString + random.Replace('/',  '_') + "_" + GetNextSeqNum() + ".rem";
            }
            else
            {
                if (this is ServerIdentity)
                    _ObjURI = IDGuidString + uri;
                else
                    _ObjURI = uri;
            }
        } // SetOrCreateURI

        // This is used by ThreadAffinity/Synchronization contexts
        // (Shares the seqNum space with URIs)
        internal static String GetNewLogicalCallID()
        {
            return IDGuidString + GetNextSeqNum();
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        internal virtual void AssertValid()
        {
            if (URI != null)
            {
                Identity resolvedIdentity = IdentityHolder.ResolveIdentity(URI);
                BCLDebug.Assert(
                    (resolvedIdentity == null) || (resolvedIdentity == this),
                    "Server ID mismatch with URI");
            }
        }

        internal bool AddProxySideDynamicProperty(IDynamicProperty prop)
        {
            lock(this)
            {
                if (_dph == null)
                {
                    DynamicPropertyHolder dph = new DynamicPropertyHolder();
                    lock(this)
                    {
                        if (_dph == null)
                        {
                            _dph = dph;
                        }
                    }
                }
                return _dph.AddDynamicProperty(prop);
            }
        }

        internal bool RemoveProxySideDynamicProperty(String name)
        {
            lock(this)
            {
                if (_dph == null)
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString("Remoting_Contexts_NoProperty"),
                            name));
                }
                return _dph.RemoveDynamicProperty(name);
            }
        }

        /*
        *   Returns an array of context specific dynamic properties
        *   registered for this context. The number of such properties
        *   is designated by length of the returned array.
        */
        internal IDynamicProperty[] ProxySideDynamicProperties
        {
            get
            {
                if (_dph == null)
                {
                    return null;
                }
                else
                {
                    return _dph.DynamicProperties;
                }
            }
        }
            
        internal ArrayWithSize ProxySideDynamicSinks
        {
            get
            {
                if (_dph == null)
                {
                    return null;
                }
                else
                {
                    return _dph.DynamicSinks;
                }
            }
        }

    #if _DEBUG
        public override String ToString()
        {
            return ("IDENTITY: " + " URI = " + _ObjURI);
        }
    #endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\ilease.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        ILease.cool
//
// Contents:    Interface for Lease
//
// History:     1/5/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;
    using System.Security.Permissions;

    /// <include file='doc\ILease.uex' path='docs/doc[@for="ILease"]/*' />
    public interface ILease
    {
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.Register"]/*' />
		
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		void Register(ISponsor obj, TimeSpan renewalTime);
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.Register1"]/*' />
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		void Register(ISponsor obj);
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.Unregister"]/*' />
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		void Unregister(ISponsor obj);
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.Renew"]/*' />
		[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		TimeSpan Renew(TimeSpan renewalTime);
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.RenewOnCallTime"]/*' />
		
		TimeSpan RenewOnCallTime 
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 				
		    get;
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    set;
		}
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.SponsorshipTimeout"]/*' />
		TimeSpan SponsorshipTimeout
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    get;
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    set;
		}
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.InitialLeaseTime"]/*' />
		TimeSpan InitialLeaseTime
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    get;
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    set;
		}
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.CurrentLeaseTime"]/*' />
		TimeSpan CurrentLeaseTime 
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    get;
		}		
		/// <include file='doc\ILease.uex' path='docs/doc[@for="ILease.CurrentState"]/*' />
		LeaseState CurrentState 
	        {
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
		    get;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\imessagectrl.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IMessageCtrl.cool
**
** Author:  Matt Smith
**
** Purpose: Defines the message sink control interface for
**          async calls
**
** Date:    Jun 8, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
	using System.Runtime.Remoting;
	using System.Security.Permissions;
	using System;
    /// <include file='doc\IMessageCtrl.uex' path='docs/doc[@for="IMessageCtrl"]/*' />
    public interface IMessageCtrl
    {
        /// <include file='doc\IMessageCtrl.uex' path='docs/doc[@for="IMessageCtrl.Cancel"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void Cancel(int msToCancel);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\iinternalmessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IInternalMessage.cool
**
** Author(s):   Tarun Anand    (TarunA)
**
** Purpose: Defines an interface that allows kitchen sink data to be 
**          set and retrieved from the various kinds of message objects.
**          
**
** Date:    Oct 12, 1999
**
===========================================================*/

namespace System.Runtime.Remoting.Messaging {
	using System.Runtime.Remoting;
	using System.Security.Permissions;
	using System;
    // Change this back to internal when the classes implementing this interface
    // are also made internal TarunA 12/16/99
    internal interface IInternalMessage
    {
        ServerIdentity ServerIdentityObject
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     set; 
	}
        Identity IdentityObject
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	     set;
	}
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void SetURI(String uri);     
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 			
        void SetCallContext(LogicalCallContext callContext);

        // The following should return true, if the property object hasn't
        //   been created.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        bool HasProperties();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\imessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IMessage.cool
**
** Author:  Matt Smith
**
** Purpose: Defines the message object interface
**
** Date:    Apr 10, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
    using System;
    using IDictionary = System.Collections.IDictionary;
    using System.Security.Permissions;
    
    /// <include file='doc\IMessage.uex' path='docs/doc[@for="IMessage"]/*' />
    public interface IMessage
    {
        /// <include file='doc\IMessage.uex' path='docs/doc[@for="IMessage.Properties"]/*' />
        IDictionary Properties     
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\idynamicmessagesink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//   IDynamicMessageSink is implemented by message sinks provided by
//   dynamically registered properties. These sinks are provided notifications
//   of call-start and call-finish with flags indicating whether 
//   the call is currently on the client-side or server-side (this is useful
//   for the context level sinks).
//
//
namespace System.Runtime.Remoting.Contexts{
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;
    using System;
    /// <include file='doc\IDynamicMessageSink.uex' path='docs/doc[@for="IDynamicProperty"]/*' />
    /// <internalonly/>
    public interface IDynamicProperty
    {
        /// <include file='doc\IDynamicMessageSink.uex' path='docs/doc[@for="IDynamicProperty.Name"]/*' />
	/// <internalonly/>
        String Name 
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	}
    }

    /// <include file='doc\IDynamicMessageSink.uex' path='docs/doc[@for="IDynamicMessageSink"]/*' />
    /// <internalonly/>
    public interface IDynamicMessageSink
    {
        /// <include file='doc\IDynamicMessageSink.uex' path='docs/doc[@for="IDynamicMessageSink.ProcessMessageStart"]/*' />
	/// <internalonly/>
       //   Indicates that a call is starting. 
       //   The booleans tell if we are on the client side or the server side, 
       //   and if the call is using AsyncProcessMessage
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync);
        /// <include file='doc\IDynamicMessageSink.uex' path='docs/doc[@for="IDynamicMessageSink.ProcessMessageFinish"]/*' />
	/// <internalonly/>
       //   Indicates that a call is returning.
       //   The booleans tell if we are on the client side or the server side, 
       //   and if the call is using AsyncProcessMessage
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\imethodmessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IMethodCallMessage.cool
**
** Author:  Matt Smith
**
** Purpose: Defines the message object interface
**
** Date:    Apr 10, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
    using System;
    using System.Reflection;
    using System.Security.Permissions;
    using IList = System.Collections.IList;
    
    /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage"]/*' />
    public interface IMethodMessage : IMessage
    {
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.Uri"]/*' />
        String Uri                      
        {
             [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]      
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.MethodName"]/*' />
        String MethodName               
        {
             [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]      
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.TypeName"]/*' />
        String TypeName     
        {
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
        get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.MethodSignature"]/*' />
        Object MethodSignature
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
            get; 
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.ArgCount"]/*' />
       
        int ArgCount
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
            get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.GetArgName"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
        String GetArgName(int index);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.GetArg"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
        Object GetArg(int argNum);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.Args"]/*' />
        Object[] Args
        {
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
         get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.HasVarArgs"]/*' />

        bool HasVarArgs
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.LogicalCallContext"]/*' />
        LogicalCallContext LogicalCallContext
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]   
            get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodMessage.MethodBase"]/*' />

        // This is never actually put on the wire, it is
        // simply used to cache the method base after it's
        // looked up once.
        MethodBase MethodBase           
        {
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
         get;
        }
    }
    
    /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodCallMessage"]/*' />
    public interface IMethodCallMessage : IMethodMessage
    {
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodCallMessage.InArgCount"]/*' />
        int InArgCount
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]   
            get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodCallMessage.GetInArgName"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]   
        String GetInArgName(int index);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodCallMessage.GetInArg"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]   
        Object GetInArg(int argNum);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodCallMessage.InArgs"]/*' />
        Object[] InArgs
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]   
            get;
        }
    }

    /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage"]/*' />
    public interface IMethodReturnMessage : IMethodMessage
    {
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.OutArgCount"]/*' />
        int OutArgCount                
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.GetOutArgName"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
        String GetOutArgName(int index);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.GetOutArg"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
        Object GetOutArg(int argNum);
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.OutArgs"]/*' />
        Object[]  OutArgs         
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.Exception"]/*' />
        
        Exception Exception        
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
             get;
        }
        /// <include file='doc\IMethodMessage.uex' path='docs/doc[@for="IMethodReturnMessage.ReturnValue"]/*' />
        Object    ReturnValue 
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]       
             get;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\imessagesink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    IMessageSink.cool
**
** Author:  Matt Smith
**
** Purpose: Defines the message sink interface
**
** Date:    Apr 10, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
	using System.Runtime.Remoting;
	using System.Security.Permissions;
	using System;
    /// <include file='doc\IMessageSink.uex' path='docs/doc[@for="IMessageSink"]/*' />
    public interface IMessageSink
    {
        /// <include file='doc\IMessageSink.uex' path='docs/doc[@for="IMessageSink.SyncProcessMessage"]/*' />
    
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        IMessage     SyncProcessMessage(IMessage msg);
        /// <include file='doc\IMessageSink.uex' path='docs/doc[@for="IMessageSink.AsyncProcessMessage"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 			
        IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
        /// <include file='doc\IMessageSink.uex' path='docs/doc[@for="IMessageSink.NextSink"]/*' />
        // Retrieves the next message sink held by this sink.
        IMessageSink NextSink 
	{ 
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\identityholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Remoting {
    using System.Globalization;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Reflection;
    using System;
    //  IdentityHolder maintains a lookup service for remoting identities. The methods
    //  provided by it are used during calls to Wrap, UnWrap, Marshal, Unmarshal etc.
    //
    using System.Collections;

    // This is just a internal struct to hold the various flags
    // that get passed for different flavors of idtable operations
    // just so that we do not have too many separate boolean parameters
    // all over the place (eg. xxxIdentity(id,uri, true, false, true);)
    internal struct IdOps
    {
        internal const int None           = 0x00000000;
        internal const int GenerateURI         = 0x00000001;
        internal const int StrongIdentity    = 0x00000002;

        internal static bool bGenerateURI(int flags)
        {
            return (flags&GenerateURI)!=0;
        }

        internal static bool bStrongIdentity(int flags)
        {
            return (flags&StrongIdentity)!=0;
        }
    }

    // Internal enum to specify options for SetIdentity
	[Serializable]
    internal enum DuplicateIdentityOption
    {
        Unique,      // -throw an exception if there is already an identity in the table
        UseExisting, // -if there is already an identity in the table, then use that one.
                     //    (could happen in a Connect race, but we don't care which identity we get)
    } // enum DuplicateIdentityOption
    
    
    internal sealed class IdentityHolder
    {
        // private static Timer CleanupTimer = null;
        // private const  int CleanupInterval = 60000;           // 1 minute.

        // private static Object staticSyncObject = new Object();
        private static int SetIDCount=0;
        private const int CleanUpCountInterval = 0x40;
        private const int INFINITE = 0x7fffffff;

        private static Hashtable _URITable = new Hashtable();
        private static Context _cachedDefaultContext = null;

           
        internal static Hashtable URITable 
        {
            get { return _URITable; }
        } 

        internal static Context DefaultContext
        {
            get
            {
                if (_cachedDefaultContext == null)
                {
                    _cachedDefaultContext = Thread.GetDomain().GetDefaultContext();
                }
                return _cachedDefaultContext;
            }
        }

        // NOTE!!!: This must be used to convert any uri into something that can
        //   be used as a key in the URITable!!!
        private static String MakeURIKey(String uri) 
        { 
            return Identity.RemoveAppNameOrAppGuidIfNecessary(
                uri.ToLower(CultureInfo.InvariantCulture)); 
        }       
        

        private static ReaderWriterLock TableLock 
        {
            get { return Thread.GetDomain().RemotingData.IDTableLock;}
        }


        internal static bool IsWriterLockHeld()
        {
            return TableLock.IsWriterLockHeld;
        }

        internal static bool IsReaderLockHeld()
        {
            return TableLock.IsReaderLockHeld;
        }

        //  Cycles through the table periodically and cleans up expired entries.
        //
        private static void CleanupIdentities(Object state)
        {
            // FUTURE:: come up with a better way to do this
            BCLDebug.Assert(
                Thread.GetDomain().RemotingData.IDTableLock.IsWriterLockHeld,
                "ID Table being cleaned up without taking a lock!");

            IDictionaryEnumerator e = URITable.GetEnumerator();
            ArrayList removeList = new ArrayList();
            while (e.MoveNext())
            {
                Object o = e.Value;
                WeakReference wr = o as WeakReference;
                if ((null != wr) && (null == wr.Target))
                {
                    removeList.Add(e.Key);
                }
            }
            
            foreach (String key in removeList)
            {
                URITable.Remove(key);
            }
        }

        internal static void FlushIdentityTable()
        {
            TableLock.AcquireWriterLock(INFINITE);
            CleanupIdentities(null);
            TableLock.ReleaseWriterLock();
        }	

        private IdentityHolder() {          // this is a singleton object. Can't construct it.
        }


        //  Looks up the identity corresponding to a URI.
        //
        internal static Identity ResolveIdentity(String URI)
        {
            if (URI == null)
                throw new ArgumentNullException("URI");
        
            Identity id;
            try
            {
                TableLock.AcquireReaderLock(INFINITE);
                Message.DebugOut("ResolveIdentity:: URI: " + URI + "\n");       
                Message.DebugOut("ResolveIdentity:: table.count: " + URITable.Count + "\n");
                //Console.WriteLine("\n ResolveID: URI = " + URI);
                // This may be called both in the client process and the server process (loopback case).
                id = ResolveReference(URITable[MakeURIKey(URI)]);
            }
            finally
            {
                TableLock.ReleaseReaderLock();
            }
            return id;
        } // ResolveIdentity


        // If the identity isn't found, this version will just return
        //   null instead of asserting (this version doesn't need to
        //   take a lock).
        internal static Identity CasualResolveIdentity(String uri)
        {
            if (uri == null)
                return null;

            Identity id = CasualResolveReference(URITable[MakeURIKey(uri)]);
            if(id == null)
            {
                // Check if this a well-known object which needs to be faulted in
                id = RemotingConfigHandler.CreateWellKnownObject(uri);                
            }

            return id;
        } // CasualResolveIdentity
        

        private static Identity ResolveReference(Object o)
        {
            BCLDebug.Assert(
                TableLock.IsReaderLockHeld || TableLock.IsWriterLockHeld ,
                "Should have locked the ID Table!");
            WeakReference wr = o as WeakReference;    
            if (null != wr)
            {
                return((Identity) wr.Target);
            }
            else
            {
                return((Identity) o);
            }
        } // ResolveReference

        private static Identity CasualResolveReference(Object o)
        {
            WeakReference wr = o as WeakReference;    
            if (null != wr)
            {
                return((Identity) wr.Target);
            }
            else
            {
                return((Identity) o);
            }
        } // CasualResolveReference

       //
       //
        // This is typically called when we need to create/establish
        // an identity for a serverObject.               
        internal static ServerIdentity FindOrCreateServerIdentity(
            MarshalByRefObject obj,  String objURI, int flags) 
        {
            Message.DebugOut("Entered FindOrCreateServerIdentity \n");
                    
            ServerIdentity srvID = null;
            bool bLock = false;

            try
            {
                bool fServer;
                srvID = (ServerIdentity) MarshalByRefObject.GetIdentity(obj, out fServer);

                if (srvID == null)
                {
                    // Create a new server identity and add it to the
                    // table. IdentityHolder will take care of races
                    Context serverCtx = null;
                    
                    if (obj is ContextBoundObject)
                    {
                        serverCtx = Thread.CurrentContext;
                    }
                    else
                    {
                        serverCtx = DefaultContext;
                    }
                    BCLDebug.Assert(null != serverCtx, "null != serverCtx");

                    ServerIdentity serverID = new ServerIdentity(obj, serverCtx);

                    // Set the identity depending on whether we have the server or proxy
                    if(fServer)
                    {
                        srvID = obj.__RaceSetServerIdentity(serverID);
                        BCLDebug.Assert(srvID == MarshalByRefObject.GetIdentity(obj), "Bad ID state!" );             
                    }
                    else
                    {
                        RealProxy rp = null;
                        rp = RemotingServices.GetRealProxy(obj);
                        BCLDebug.Assert(null != rp, "null != rp");

                        rp.IdentityObject = serverID;
                        srvID = (ServerIdentity) rp.IdentityObject;
                    }

                    Message.DebugOut("Created ServerIdentity \n");
                }

                // Check that we are asked to create the identity for the same
                // URI as the one already associated with the server object.
                // It is an error to associate two URIs with the same server 
                // object
                /*
                // GopalK: Try eliminating the test because it is also done by GetOrCreateIdentity
                if ((null != objURI) && (null != srvID.ObjURI))
                {
                    if (string.Compare(objURI, srvID.ObjURI, true, CultureInfo.InvariantCulture) == 0) // case-insensitive compare
                    {
                        Message.DebugOut("Trying to associate a URI with identity again .. throwing execption \n");
                        throw new RemotingException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Remoting_ResetURI"),
                                srvID.ObjURI, objURI));
                    }
                }
                */

                // NOTE: for purely x-context cases we never execute this ...
                // the server ID is not put in the ID table. 
                if ( IdOps.bStrongIdentity(flags) )
                {

                    TableLock.AcquireWriterLock(INFINITE);
                    bLock = true;

                    // It is possible that we are marshaling out of this app-domain
                    // for the first time. We need to do two things
                    // (1) If there is no URI associated with the identity then go ahead 
                    // and generate one.
                    // (2) Add the identity to the URI -> Identity map if not already present
                    // (For purely x-context cases we don't need the URI)   
                    // (3) If the object ref is null, then this object hasn't been
                    // marshalled yet.
                    // (4) if id was created through SetObjectUriForMarshal, it would be
                    // in the ID table
                    if ((srvID.ObjURI == null) ||
                       (srvID.IsInIDTable() == false))
                    {
                        // we are marshalling a server object, so there should not be a
                        //   a different identity at this location.
                        SetIdentity(srvID, objURI, DuplicateIdentityOption.Unique);
                    }

                    // If the object is marked as disconnect, mark it as connected
                    if(srvID.IsDisconnected())
                            srvID.SetFullyConnected();
                }
            }
            finally
            {
                if (bLock)
                {
                    TableLock.ReleaseWriterLock();
                }
            }

            Message.DebugOut("Leaving FindOrCreateServerIdentity \n");
            BCLDebug.Assert(null != srvID,"null != srvID");
            return srvID;                
        }

        //
        //
        // This is typically called when we are unmarshaling an objectref
        // in order to create a client side identity for a remote server
        // object.
        internal static Identity FindOrCreateIdentity(
            String objURI, String URL, ObjRef objectRef)
        {
            Identity idObj = null;
            bool bLock = false;

            BCLDebug.Assert(null != objURI,"null != objURI");

            try
            {                
                bool bWellKnown = (URL != null);

                // Lookup the object in the identity table
                // for well-known objects we user the URL
                // as the hash-key (instead of just the objUri)
                idObj = ResolveIdentity(bWellKnown ? URL : objURI);
                if (bWellKnown &&
                    (idObj != null) &&
                    (idObj is ServerIdentity))
                {
                    // We are trying to do a connect to a server wellknown object.
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_WellKnown_CantDirectlyConnect"),
                            URL));                            
                }
                     
                if (null == idObj)
                {
                    // There is no entry for this uri in the IdTable.
                    Message.DebugOut("RemotingService::FindOrCreateIdentity: Creating Identity\n");

                    // This identity is being encountered for the first time.
                    // We have to do the following things
                    // (1) Create an identity object for the proxy
                    // (2) Add the identity to the identity table
                    // (3) Create a proxy for the object represented by the objref      
                    
                    // Create a new identity
                    // GopalK: Identity should get only one string that is used for everything
                    idObj = new Identity(objURI, URL);                         

                    // Add it to the identity table
                    TableLock.AcquireWriterLock(INFINITE);
                    bLock = true; 

                    // SetIdentity will give the correct Id if we raced
                    // between the ResolveIdentity call above and now.
                    //   (we are unmarshaling, and the server should guarantee
                    //    that the uri is unique, so we will use an existing identity
                    //    in case of a race)
                    idObj = SetIdentity(idObj, null, DuplicateIdentityOption.UseExisting);

                    idObj.RaceSetObjRef(objectRef);
                }
                else
                {
                    Message.DebugOut("RemotingService::FindOrCreateIdentity: Found Identity!\n");
                }
            }
            finally
            {
                if (bLock)
                {
                    TableLock.ReleaseWriterLock();
                }                
            }
            BCLDebug.Assert(null != idObj,"null != idObj");
            return idObj;                
        }


        //  Creates an identity entry. 
        //  This is used by Unmarshal and Marshal to generate the URI to identity 
        //  mapping
        //  
        //
        private static Identity SetIdentity(
            Identity idObj, String URI, DuplicateIdentityOption duplicateOption)
        {
            // NOTE: This function assumes that a lock has been taken 
            // by the calling function
            // idObj could be for a transparent proxy or a server object        
            Message.DebugOut("SetIdentity:: domainid: " + Thread.GetDomainIDInternal() + "\n");
            BCLDebug.Assert(null != idObj,"null != idObj");
            
            // WriterLock must already be taken when SetIdentity is called!
            BCLDebug.Assert(
                TableLock.IsWriterLockHeld,
                "Should have write-locked the ID Table!");

            // flag to denote that the id being set is a ServerIdentity
            bool bServerIDSet = idObj is ServerIdentity;
                
            if (null == idObj.URI)
            {
                // No URI has been associated with this identity. It must be a 
                // server identity getting marshaled out of the app domain for 
                // the first time.
                BCLDebug.Assert(bServerIDSet,"idObj should be ServerIdentity");

                // Set the URI on the idObj (generating one if needed)
                idObj.SetOrCreateURI(URI);

                // If objectref is non-null make sure both have same URIs
                // (the URI in the objectRef could have potentially been reset
                // in a past external call to Disconnect()
                if (idObj.ObjectRef != null)
                {
                    idObj.ObjectRef.URI = idObj.URI;
                }
                Message.DebugOut("SetIdentity: Generated URI " + URI + " for identity");
            }

            // If we have come this far then there is no URI to identity
            // mapping present. Go ahead and create one.

            // ID should have a URI by now.
            BCLDebug.Assert(null != idObj.URI,"null != idObj.URI");

            // See if this identity is already present in the Uri table
            String uriKey = MakeURIKey(idObj.URI);
            Object o = URITable[uriKey];

            // flag to denote that the id found in the table is a ServerIdentity
            bool bServerID;
            if (null != o)
            {
                // We found an identity (or a WeakRef to one) for the URI provided
                WeakReference wr = o as WeakReference;
                Identity idInTable = null;
                if (wr != null)
                {
                    // The object we found is a weak referece to an identity
                    
                    // This could be an identity for a client side
                    // proxy 
                    // OR
                    // a server identity which has been weakened since its life
                    // is over.
                    idInTable = (Identity) wr.Target;

                    bServerID = idInTable is ServerIdentity;

                    // If we find a weakRef for a ServerId we will be converting
                    // it to a strong one before releasing the IdTable lock.
                    BCLDebug.Assert(
                        (idInTable == null)||
                        (!bServerID || idInTable.IsRemoteDisconnected()),
                        "Expect to find WeakRef only for remotely disconnected ids");
                    // We could find a weakRef to a client ID that does not 
                    // match the idObj .. but that is a handled race case 
                    // during Unmarshaling .. SetIdentity() will return the ID
                    // from the table to the caller.
                }
                else
                {
                    // We found a non-weak (strong) Identity for the URI
                    idInTable = (Identity) o;
                    bServerID = idInTable is ServerIdentity;

                    //We dont put strong refs to client "Identity"s in the table                    
                    BCLDebug.Assert(
                        bServerID, 
                        "Found client side strong ID in the table");
                }

                if ((idInTable != null) && (idInTable != idObj))
                {
                    // We are trying to add another identity for the same URI
                    switch (duplicateOption)
                    {
                    
                    case DuplicateIdentityOption.Unique:
                    {
                        
                        String tempURI = idObj.URI;  

                        // Throw an exception to indicate the error since this could
                        // be caused by a user trying to marshal two objects with the same
                        // URI
                        throw new RemotingException(
                            String.Format(Environment.GetResourceString("Remoting_URIClash"),
                                tempURI));
                    } // case DuplicateIdentityOption.Unique
                    
                    case DuplicateIdentityOption.UseExisting:
                    {
                        // This would be a case where our thread lost the race
                        // we will return the one found in the table
                        idObj = idInTable;
                        break;
                    } // case DuplicateIdentityOption.UseExisting:
                    
                    default:
                    {
                        BCLDebug.Assert(false, "Invalid DuplicateIdentityOption");
                        break;
                    }
                    
                    } // switch (duplicateOption)
                    
                }
                else
                if (wr!=null)
                {                   
                    // We come here if we found a weakRef in the table but
                    // the target object had been cleaned up 
                    // OR
                    // If there was a weakRef in the table and the target
                    // object matches the idObj just passed in
                    
                    // Strengthen the entry if it a ServerIdentity.
                    if (bServerID)
                    {                       
                        URITable[uriKey] = idObj;
                    }
                    else
                    {
                        // For client IDs associate the table entry
                        // with the one passed in.
                        // (If target was null we would set it ... 
                        // if was non-null then it matches idObj anyway)
                        wr.Target = idObj;  
                    }
                }
            }
            else
            {
                // We did not find an identity entry for the URI
                Object addMe = null;
                if (bServerIDSet)
                {
                    addMe = idObj;
                }
                else
                {
                    addMe = new WeakReference(idObj);
                }                    
                
                // Add the entry into the table
                URITable.Add(uriKey, addMe);
                idObj.SetInIDTable();
                
                // After every fixed number of set-id calls we run through
                // the table and cleanup if needed.             
                SetIDCount++;
                if (SetIDCount % CleanUpCountInterval == 0)
                {
                    // This should be called with the write lock held!
                    //   (which is why we assert that at the beginning of this
                    //    method)
                    CleanupIdentities(null);
                }

            }
            
            Message.DebugOut("SetIdentity:: Identity::URI: " + idObj.URI + "\n");       
            return idObj;
        }

         //  Convert table entry to a weak reference
         //
        /*
        internal static void WeakenIdentity(String URI)
        {
            BCLDebug.Assert(URI!=null, "Null URI");
            BCLDebug.Trace("REMOTE", 
                "IdentityHolder.WeakenIdentity ",URI, " for context ", Thread.CurrentContext);         
            
            String uriKey = MakeURIKey(URI);
            try
            {
                TableLock.AcquireWriterLock(INFINITE);
                Object oRef = URITable[uriKey];
                WeakReference wr = oRef as WeakReference;
                if (null == wr)
                {                    
                    // Make the id a weakRef if it isn't already.
                    BCLDebug.Assert(
                       oRef != null &&  (oRef is ServerIdentity), 
                       "Invaild URI given to WeakenIdentity");
                       
                    URITable[uriKey] = new WeakReference(oRef);
                }
            }
            finally
            {
                TableLock.ReleaseWriterLock();
            }
        }
        */

        internal static void RemoveIdentity(String uri)
        {
            RemoveIdentity(uri, true);
        }
        
        internal static void RemoveIdentity(String uri, bool bResetURI)
        {
            BCLDebug.Assert(uri!=null, "Null URI");
            BCLDebug.Trace("REMOTE",
                "IdentityHolder.WeakenIdentity ",uri, " for context ", Thread.CurrentContext);

            Identity id;
            String uriKey = MakeURIKey(uri);
            try
            {
                TableLock.AcquireWriterLock(INFINITE);
                Object oRef = URITable[uriKey];
                WeakReference wr = oRef as WeakReference;
                if (null != wr)
                {
                    id = (Identity) wr.Target;
                    wr.Target = null;
                }
                else
                {
                    id = (Identity) oRef;
                }

                if(id != null)
                {
                    URITable.Remove(uriKey);
                    // Mark the ID as not present in the ID Table
                    // This will clear its URI & objRef fields
                    id.ResetInIDTable(bResetURI);
                }
            }
            finally
            {
                TableLock.ReleaseWriterLock();
            }
        } // RemoveIdentity


        // Support for dynamically registered property sinks
        internal static bool AddDynamicProperty(MarshalByRefObject obj, IDynamicProperty prop)
        {
            if (RemotingServices.IsObjectOutOfContext(obj))
            {
                // We have to add a proxy side property, get the identity
                RealProxy rp = RemotingServices.GetRealProxy(obj);
                return rp.IdentityObject.AddProxySideDynamicProperty(prop);            
            }
            else
            {
                MarshalByRefObject realObj = 
                    (MarshalByRefObject)
                        RemotingServices.AlwaysUnwrap((ContextBoundObject)obj);
                // This is a real object. See if we have an identity for it
                ServerIdentity srvID = (ServerIdentity)MarshalByRefObject.GetIdentity(realObj);
                if (srvID != null)
                {
                    return srvID.AddServerSideDynamicProperty(prop);
                }
                else
                {
                    // identity not found, we can't set a sink for this object.
                    throw new RemotingException(
                       Environment.GetResourceString("Remoting_NoIdentityEntry"));

                }                        
            }
        }

        internal static bool RemoveDynamicProperty(MarshalByRefObject obj, String name)
        {
            if (RemotingServices.IsObjectOutOfContext(obj))
            {
                // We have to add a proxy side property, get the identity
                RealProxy rp = RemotingServices.GetRealProxy(obj);
                return rp.IdentityObject.RemoveProxySideDynamicProperty(name);            
            }
            else
            {

                MarshalByRefObject realObj = 
                    (MarshalByRefObject)
                        RemotingServices.AlwaysUnwrap((ContextBoundObject)obj);
                        
                // This is a real object. See if we have an identity for it
                ServerIdentity srvID = (ServerIdentity)MarshalByRefObject.GetIdentity(realObj);
                if (srvID != null)
                {
                    return srvID.RemoveServerSideDynamicProperty(name);
                }
                else
                {
                    // identity not found, we can't set a sink for this object.
                    throw new RemotingException(
                       Environment.GetResourceString("Remoting_NoIdentityEntry"));
                }
            }
        }


        //
        // DEBUG Helpers
        //   Note: These methods should be included even in retail builds so that 
        //     they can be called from the debugger.
        //

        internal static void DumpIdentities()
        {
            // We don't want to take locks. This will only be called from the debugger.
            // To use from cordbg: 
            //   f System.Runtime.Remoting.IdentityHolder::DumpIdentities
        
            Console.Error.WriteLine("Identity Table:");
        
            foreach (DictionaryEntry entry in _URITable)
            {
                Object obj = entry.Value;
            
                Identity id = null;
                if (obj is WeakReference)
                    id = ((WeakReference)obj).Target as Identity;
                else
                    id = obj as Identity;
                
                if (id != null)
                {
                    String uri = id.URI;

                    ServerIdentity srvId = id as ServerIdentity;
                    if (srvId != null)
                    {
                        Console.Error.WriteLine("server: " + srvId.ServerType + "; uri = <" + uri + ">");
                    }
                    else    
                    {
                        Console.Error.WriteLine("client: uri = <" + uri + ">");
                    }
                }
            }
        } // DumpIdentities


        internal static Identity DumpIdentity(String idUri)
        {   
            // We don't want to take locks. This will only be called from the debugger.
            // To use from cordbg: 
            //   newstr "object-uri"
            //   f System.Runtime.Remoting.IdentityHolder::DumpIdentity $result
        
            Object obj = _URITable[MakeURIKey(idUri)];

            Identity id = null;
            if (obj is WeakReference)
                id = ((WeakReference)obj).Target as Identity;
            else
                id = obj as Identity;
                
            if (id != null)
            {
                Console.Error.WriteLine("Identity: " + idUri);
            
                String uri = id.URI;

                ServerIdentity srvId = id as ServerIdentity;
                if (srvId != null)
                {
                    Console.Error.WriteLine("\tserver: " + srvId.ServerType + "; uri = <" + uri + ">");
                }
                else    
                {
                    Console.Error.WriteLine("\tclient: uri = <" + uri + ">");
                }                          
            }
            else
            {
                Console.Error.WriteLine("No identity found: " + idUri);
            }


            return id;
        } // DumpIdentity


        internal static void DumpAppInfo()
        {
            // To use from cordbg: 
            //   f System.Runtime.Remoting.IdentityHolder::DumpAppInfo
        
            Console.Error.WriteLine("Process ID: " + Identity.ProcessGuid);
            Console.Error.WriteLine("AppDomain ID: " + RemotingConfiguration.ApplicationId);
            Console.Error.WriteLine("Application Name: " + RemotingConfiguration.ApplicationName);
        } // DumpAppInfo


    } // class IdentityHolder

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\iremotingformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IRemotingFormatter;
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The interface for all formatters.
**
** Date:  April 22, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {

	using System;
	using System.IO;
	using System.Runtime.Serialization;
    /// <include file='doc\IRemotingFormatter.uex' path='docs/doc[@for="IRemotingFormatter"]/*' />
    public interface IRemotingFormatter : IFormatter {
        /// <include file='doc\IRemotingFormatter.uex' path='docs/doc[@for="IRemotingFormatter.Deserialize"]/*' />
    
        // Begin the process of deserialization.  For purposes of serialization,
        // this will probably rely on a stream that has been connected to the 
        // formatter through other means.  
        //
        Object Deserialize(Stream serializationStream, HeaderHandler handler);
        /// <include file='doc\IRemotingFormatter.uex' path='docs/doc[@for="IRemotingFormatter.Serialize"]/*' />
    
        // Start the process of serialization.  The object graph commencing at 
        // graph will be serialized to the appropriate backing store.
        void Serialize(Stream serializationStream, Object graph, Header[] headers);
        
    }


    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\isponsor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        ISponsor.cool
//
// Contents:    Interface for Sponsors
//
// History:     1/5/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;
    using System.Security.Permissions;

    /// <include file='doc\ISponsor.uex' path='docs/doc[@for="ISponsor"]/*' />
    public interface ISponsor
    {
		/// <include file='doc\ISponsor.uex' path='docs/doc[@for="ISponsor.Renewal"]/*' />
	        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
		TimeSpan Renewal(ILease lease);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\leasestate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        LeaseState.cool
//
// Contents:    Lease States
//
// History:     1/5/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;

  /// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState"]/*' />
  [Serializable]
  public enum LeaseState
    {
		/// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState.Null"]/*' />
		Null = 0,
		/// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState.Initial"]/*' />
		Initial = 1,
		/// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState.Active"]/*' />
		Active = 2,
		/// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState.Renewing"]/*' />
		Renewing = 3,
		/// <include file='doc\LeaseState.uex' path='docs/doc[@for="LeaseState.Expired"]/*' />
		Expired = 4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\lease.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        Lease.cool
//
// Contents:    Lease class
//
// History:     1/5/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Threading;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Proxies;

    /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease"]/*' />
    internal class Lease : MarshalByRefObject, ILease
    {
        internal int id = 0;
        
        // Lease Time
        internal DateTime leaseTime;
        internal TimeSpan initialLeaseTime;
        
        // Renewal Policies
        internal TimeSpan renewOnCallTime;
        internal TimeSpan sponsorshipTimeout;
        internal Boolean isInfinite = false;

        // Sponsors
        internal Hashtable sponsorTable;
        internal int sponsorCallThread;

        // Links to leasemanager and managed object
        internal LeaseManager leaseManager;
        internal MarshalByRefObject managedObject;

        // State
        internal LeaseState state;

        internal static int nextId = 0;        


        internal Lease(TimeSpan initialLeaseTime,
                       TimeSpan renewOnCallTime,                       
                       TimeSpan sponsorshipTimeout,
                       MarshalByRefObject managedObject
                      )
        {
            id = nextId++;
            BCLDebug.Trace("REMOTE", "Lease Constructor ",managedObject," initialLeaseTime "+initialLeaseTime+" renewOnCall "+renewOnCallTime+" sponsorshipTimeout ",sponsorshipTimeout);

            // Set Policy            
            this.renewOnCallTime = renewOnCallTime;
            this.sponsorshipTimeout = sponsorshipTimeout;
            this.initialLeaseTime = initialLeaseTime;
            this.managedObject = managedObject;

            //Add lease to leaseManager
            leaseManager = LeaseManager.GetLeaseManager();

            // Initialize tables
            sponsorTable = new Hashtable(10);
            state = LeaseState.Initial;
        }

        internal void ActivateLease()
        {
            // Set leaseTime
            leaseTime = DateTime.UtcNow.Add(initialLeaseTime);
            state = LeaseState.Active;
            leaseManager.ActivateLease(this);
        }

        private int GetNextId()
        {
            int localId = 0;
            lock(typeof(Lease))
            {
                localId = nextId++;
            }
            return localId;
        }

        internal int GetId()
        {
            return id;
        }

        // Override MarshalByRefObject InitializeLifetimeService
        // Don't want a lease on a lease therefore returns null
        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.InitializeLifetimeService"]/*' />
        public override Object InitializeLifetimeService()
        {
            BCLDebug.Trace("REMOTE", "Lease ",id," InitializeLifetimeService, lease Marshalled");
            return null;
        }

        // ILease Property and Methods

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.RenewOnCallTime"]/*' />
        public TimeSpan RenewOnCallTime
        {
            get { return renewOnCallTime; }
            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
            set
            {
                if (state == LeaseState.Initial)
                {
                    renewOnCallTime = value;
                    BCLDebug.Trace("REMOTE", "Lease Set RenewOnCallProperty ",managedObject," "+renewOnCallTime);
                }
                else
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_InitialStateRenewOnCall"), ((Enum)state).ToString()));                    
            }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.SponsorshipTimeout"]/*' />
        public TimeSpan SponsorshipTimeout
        {
            get { return sponsorshipTimeout; }
            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
            set
            {
                if (state == LeaseState.Initial)
                {
                    sponsorshipTimeout = value;
                    BCLDebug.Trace("REMOTE", "Lease Set SponsorshipTimeout Property ",managedObject," "+sponsorshipTimeout);                    
                }
                else
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_InitialStateSponsorshipTimeout"), ((Enum)state).ToString()));                                        
            }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.InitialLeaseTime"]/*' />
        public TimeSpan InitialLeaseTime
        {
            get { return initialLeaseTime; }

            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
            set
            {
                if (state == LeaseState.Initial)
                {
                    initialLeaseTime = value;
                    if (TimeSpan.Zero.CompareTo(value) >= 0)
                        state = LeaseState.Null;
                    BCLDebug.Trace("REMOTE", "Lease Set InitialLeaseTime Property ",managedObject,"  "+InitialLeaseTime+", current state "+((Enum)state).ToString());                                                            
                }
                else
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_InitialStateInitialLeaseTime"), ((Enum)state).ToString()));                                                            
            }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.CurrentLeaseTime"]/*' />
        public TimeSpan CurrentLeaseTime
        {
            get { return leaseTime.Subtract(DateTime.UtcNow); }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.CurrentState"]/*' />
        public LeaseState CurrentState
        {
            get { return state;}
        }        


        internal MarshalByRefObject ManagedObject
        {
            get { return managedObject; }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.Register"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public void Register(ISponsor obj)
        {
            Register(obj, TimeSpan.Zero);
        }
        
        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.Register1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public void Register(ISponsor obj, TimeSpan renewalTime)
        {
            lock(this)
            {
                BCLDebug.Trace("REMOTE", "Lease "+id+" Register Sponsor  renewalTime ",renewalTime," state ",((Enum)state).ToString());
                if (state == LeaseState.Expired || sponsorshipTimeout == TimeSpan.Zero)
                    return;

                Object sponsorId = GetSponsorId(obj);
                lock(sponsorTable)
                {
                    if (renewalTime > TimeSpan.Zero)
                        AddTime(renewalTime);
                    if (!sponsorTable.ContainsKey(sponsorId))
                    {
                        // Place in tables
                        sponsorTable[sponsorId] = new SponsorStateInfo(renewalTime, SponsorState.Initial);
                    }
                }
            }
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.Unregister"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public void Unregister(ISponsor sponsor)
        {
            lock(this)
            {
                BCLDebug.Trace("REMOTE", "Lease",id," Unregister  state ",((Enum)state).ToString());
                if (state == LeaseState.Expired)
                    return;

                Object sponsorId = GetSponsorId(sponsor);
                lock(sponsorTable)
                {
                    if (sponsorId != null)
                    {
                        leaseManager.DeleteSponsor(sponsorId);                
                        SponsorStateInfo sponsorStateInfo = (SponsorStateInfo)sponsorTable[sponsorId];
                        sponsorTable.Remove(sponsorId);
                    }
                }
            }
        }

        // Get the local representative of the sponsor to prevent a remote access when placing
        // in a hash table.
        private Object GetSponsorId(ISponsor obj)
        {
            Object sponsorId = null;
            if (obj != null)
            {
                if (RemotingServices.IsTransparentProxy(obj))
                    sponsorId = RemotingServices.GetRealProxy(obj);
                else
                    sponsorId = obj;
            }
            return sponsorId;
        }

        // Convert from the local representative of the sponsor to either the MarshalByRefObject or local object
        private ISponsor GetSponsorFromId(Object sponsorId)
        {
            Object sponsor = null;
            RealProxy rp = sponsorId as RealProxy;
            if (null != rp)
                sponsor = rp.GetTransparentProxy();
            else
                sponsor = sponsorId;
            return (ISponsor)sponsor;
        }
        
        /// <include file='doc\Lease.uex' path='docs/doc[@for="Lease.Renew"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public TimeSpan Renew(TimeSpan renewalTime)
        {
            return RenewInternal(renewalTime);
        }

        // We will call this internally within the server domain
        internal TimeSpan RenewInternal(TimeSpan renewalTime)
        {
            lock(this)
            {
                BCLDebug.Trace("REMOTE","Lease ",id," Renew ",renewalTime," state ",((Enum)state).ToString());
                if (state == LeaseState.Expired)
                    return TimeSpan.Zero;
                AddTime(renewalTime);
                return leaseTime.Subtract(DateTime.UtcNow);
            }
        }

        // Used for a lease which has been created, but will not be used
        internal void Remove()
        {
            BCLDebug.Trace("REMOTE","Lease ",id," Remove state ",((Enum)state).ToString());
            if (state == LeaseState.Expired)
                return;
            state = LeaseState.Expired;            
            leaseManager.DeleteLease(this);
        }

        internal void Cancel()
        {
            lock(this)
            {                        
                BCLDebug.Trace("REMOTE","Lease ",id," Cancel Managed Object ",managedObject," state ",((Enum)state).ToString());

                if (state == LeaseState.Expired)
                    return;

                Remove();
                // Disconnect the object ... 
                // We use the internal version of Disconnect passing "false"
                // for the bResetURI flag. This allows the object to keep its 
                // old URI in case its lease gets reactivated later.
                RemotingServices.Disconnect(managedObject, false);

                // Disconnect the lease for the object.
                RemotingServices.Disconnect(this);
            }
        }



#if _DEBUG
        ~Lease()
        {
            BCLDebug.Trace("REMOTE","Lease ",id," Finalize");
        }
#endif

        internal void RenewOnCall()
        {
            lock(this)
            {
                //BCLDebug.Trace("REMOTE","Lease ",id," RenewOnCall state ",((Enum)state).ToString());
                if (state == LeaseState.Initial || state == LeaseState.Expired)
                    return;            
                AddTime(renewOnCallTime);
            }
        }

        internal void LeaseExpired(DateTime now)
        {
            lock(this)
            {
                BCLDebug.Trace("REMOTE","Lease ",id," LeaseExpired state ",((Enum)state).ToString());
                if (state == LeaseState.Expired)
                    return;

                // There is a small window between the time the leaseManager
                // thread examines all the leases and tests for expiry and 
                // when an indivisual lease is locked for expiry. The object 
                // could get marshal-ed in this time which would reset its lease
                // Therefore we check again to see if we should indeed proceed
                // with the expire code (using the same value of 'now' as used
                // by the leaseManager thread)
                if (leaseTime.CompareTo(now) < 0)
                    ProcessNextSponsor();
            }
        }

        internal delegate TimeSpan AsyncRenewal(ILease lease);
        
        internal void SponsorCall(ISponsor sponsor)
        {
            BCLDebug.Trace("REMOTE","Lease ",id," SponsorCall state ",((Enum)state).ToString());
            bool exceptionOccurred = false;
            if (state == LeaseState.Expired)
                return;

            lock(sponsorTable)
            {
                try
                {
                    Object sponsorId = GetSponsorId(sponsor);            
                    sponsorCallThread = Thread.CurrentThread.GetHashCode();
                    AsyncRenewal ar = new AsyncRenewal(sponsor.Renewal);
                    SponsorStateInfo sponsorStateInfo = (SponsorStateInfo)sponsorTable[sponsorId];            
                    sponsorStateInfo.sponsorState = SponsorState.Waiting;

                    // The first parameter should be the lease we are trying to renew.
                    IAsyncResult iar = ar.BeginInvoke(this, new AsyncCallback(this.SponsorCallback), null);
                    if ((sponsorStateInfo.sponsorState == SponsorState.Waiting) && (state != LeaseState.Expired))
                    {
                        //   Even if we get here, the operation could still complete before
                        //   we call the the line below. This seems to be a race.
                        
                        // Sponsor could have completed before statement is reached, so only execute
                        // if the sponsor state is still waiting
                        leaseManager.RegisterSponsorCall(this, sponsorId, sponsorshipTimeout);
                    }
                    sponsorCallThread = 0;
                }catch(Exception)
                {
                    // Sponsor not avaiable
                    exceptionOccurred = true;

                    sponsorCallThread = 0;
                }
            }

            if (exceptionOccurred)
            {
                BCLDebug.Trace("REMOTE","Lease ",id," SponsorCall Sponsor Exception ");
                Unregister(sponsor);
                ProcessNextSponsor();
            }
        }

        internal void SponsorTimeout(Object sponsorId)
        {
            lock (this)
            {
                if (!sponsorTable.ContainsKey(sponsorId))
                    return;
                lock(sponsorTable)
                {
                    SponsorStateInfo sponsorStateInfo = (SponsorStateInfo)sponsorTable[sponsorId];
                    BCLDebug.Trace("REMOTE","Lease ",id," SponsorTimeout  sponsorState ",((Enum)sponsorStateInfo.sponsorState).ToString());
                    if (sponsorStateInfo.sponsorState == SponsorState.Waiting)
                    {
                        Unregister(GetSponsorFromId(sponsorId));
                        ProcessNextSponsor();
                    }
                }
            }
        }

        private void ProcessNextSponsor()
        {
            BCLDebug.Trace("REMOTE","Lease ",id," ProcessNextSponsor");

            Object largestSponsor = null;
            TimeSpan largestRenewalTime = TimeSpan.Zero;
            
            
            lock(sponsorTable)
            {
                IDictionaryEnumerator e = sponsorTable.GetEnumerator();
                // Find sponsor with largest previous renewal value
                while(e.MoveNext())
                {
                    Object sponsorId = e.Key;
                    SponsorStateInfo sponsorStateInfo = (SponsorStateInfo)e.Value;
                    if ((sponsorStateInfo.sponsorState == SponsorState.Initial) && (largestRenewalTime == TimeSpan.Zero))
                    {
                        largestRenewalTime = sponsorStateInfo.renewalTime;
                        largestSponsor = sponsorId;                        
                    }
                    else if (sponsorStateInfo.renewalTime > largestRenewalTime)
                    {
                        largestRenewalTime = sponsorStateInfo.renewalTime;
                        largestSponsor = sponsorId;
                    }
                }
            }

            if (largestSponsor != null)
                SponsorCall(GetSponsorFromId(largestSponsor));
            else
            {
                // No more sponsors to try, Cancel
                BCLDebug.Trace("REMOTE","Lease ",id," ProcessNextSponsor no more sponsors");                
                Cancel();
            }
        }


        // This gets called when we explicitly transfer the call back from the 
        // called function to a threadpool thread.
        internal void SponsorCallback(Object obj)
        {
            SponsorCallback((IAsyncResult)obj);
        }

        // On another thread
        internal void SponsorCallback(IAsyncResult iar)
        {
            BCLDebug.Trace("REMOTE","Lease ",id," SponsorCallback IAsyncResult ",iar," state ",((Enum)state).ToString());
            if (state == LeaseState.Expired)
            {
                return;
            }

            int thisThread = Thread.CurrentThread.GetHashCode();
            if (thisThread == sponsorCallThread)
            {
                // Looks like something went wrong and the thread that
                // did the AsyncRenewal::BeginInvoke is executing the callback
                // We will queue the work to the thread pool (otherwise there
                // is a possibility of stack overflow if all sponsors are down)
                WaitCallback threadFunc = new WaitCallback(this.SponsorCallback);
                ThreadPool.QueueUserWorkItem(threadFunc, iar);
                return;
            }

            AsyncResult asyncResult = (AsyncResult)iar;
            AsyncRenewal ar = (AsyncRenewal)asyncResult.AsyncDelegate;
            ISponsor sponsor = (ISponsor)ar.Target;
            SponsorStateInfo sponsorStateInfo = null;
            if (iar.IsCompleted)
            {
                // Sponsor came back with renewal
                BCLDebug.Trace("REMOTE","Lease ",id," SponsorCallback sponsor completed");
                bool exceptionOccurred = false;
                TimeSpan renewalTime = TimeSpan.Zero;
                try
                {
                    renewalTime = (TimeSpan)ar.EndInvoke(iar);
                }catch(Exception)
                {
                    // Sponsor not avaiable
                    exceptionOccurred = true;
                }
                if (exceptionOccurred)
                {
                    BCLDebug.Trace("REMOTE","Lease ",id," SponsorCallback Sponsor Exception ");
                    Unregister(sponsor);
                    ProcessNextSponsor();
                }
                else
                {
                    Object sponsorId = GetSponsorId(sponsor);
                    lock(sponsorTable)
                    {
                        if (sponsorTable.ContainsKey(sponsorId))
                        {
                            sponsorStateInfo = (SponsorStateInfo)sponsorTable[sponsorId];
                            sponsorStateInfo.sponsorState = SponsorState.Completed;
                            sponsorStateInfo.renewalTime = renewalTime;
                        }
                        else
                        {
                            // Sponsor was deleted, possibly from a sponsor time out
                        }
                    }

                    if (sponsorStateInfo == null)
                    {
                        // Sponsor was deleted
                        ProcessNextSponsor();
                    }
                    else if (sponsorStateInfo.renewalTime == TimeSpan.Zero)
                    {
                        BCLDebug.Trace("REMOTE","Lease ",id," SponsorCallback sponsor did not renew ");                                            
                        Unregister(sponsor);
                        ProcessNextSponsor();
                    }
                    else
                        Renew(sponsorStateInfo.renewalTime);
                }
            }
            else
            {
                // Sponsor timed out
                // Note time outs should be handled by the LeaseManager
                BCLDebug.Trace("REMOTE","Lease ",id," SponsorCallback sponsor did not complete, timed out");
                Unregister(sponsor);                    
                ProcessNextSponsor();
            }
        }

        

        private void AddTime(TimeSpan renewalSpan)
        {
            if (state == LeaseState.Expired)
                return;

            DateTime now = DateTime.UtcNow;
            DateTime oldLeaseTime = leaseTime;
            DateTime renewTime = now.Add(renewalSpan);
            if (leaseTime.CompareTo(renewTime) < 0)
            {
                leaseManager.ChangedLeaseTime(this, renewTime);
                leaseTime = renewTime;
                state = LeaseState.Active;
            }
            //BCLDebug.Trace("REMOTE","Lease ",id," AddTime renewalSpan ",renewalSpan," current Time ",now," old leaseTime ",oldLeaseTime," new leaseTime ",leaseTime," state ",((Enum)state).ToString());            
        }



        [Serializable]
        internal enum SponsorState
        {
            Initial = 0,
            Waiting = 1,
            Completed = 2
        }

        internal sealed class SponsorStateInfo
        {
            internal TimeSpan renewalTime;
            internal SponsorState sponsorState;

            internal SponsorStateInfo(TimeSpan renewalTime, SponsorState sponsorState)
            {
                this.renewalTime = renewalTime;
                this.sponsorState = sponsorState;
            }
        }
    }

    /// <include file='doc\Lease.uex' path='docs/doc[@for="LeaseSink"]/*' />
    internal class LeaseSink : IMessageSink
    {
        Lease lease = null;
        IMessageSink nextSink = null;

        /// <include file='doc\Lease.uex' path='docs/doc[@for="LeaseSink.LeaseSink"]/*' />
        public LeaseSink(Lease lease, IMessageSink nextSink)
        {
            this.lease = lease;
            this.nextSink = nextSink;
        }
        
        //IMessageSink methods
        /// <include file='doc\Lease.uex' path='docs/doc[@for="LeaseSink.SyncProcessMessage"]/*' />
        public IMessage SyncProcessMessage(IMessage msg)
        {
            //BCLDebug.Trace("REMOTE","Lease ",id," SyncProcessMessage");
            lease.RenewOnCall();
            return nextSink.SyncProcessMessage(msg);
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="LeaseSink.AsyncProcessMessage"]/*' />
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            //BCLDebug.Trace("REMOTE","Lease ",id," AsyncProcessMessage");
            lease.RenewOnCall();
            return nextSink.AsyncProcessMessage(msg, replySink);        
        }

        /// <include file='doc\Lease.uex' path='docs/doc[@for="LeaseSink.NextSink"]/*' />
        public IMessageSink NextSink
        {
            get
            {
                //BCLDebug.Trace("REMOTE","Lease ",id," NextSink");        
                return nextSink;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\lifetimeservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        LifetimeServices.cool
//
// Contents:    Used to obtain a lease (Temporary RemoteServices will be evenually used)
//
// History:     1/5/00   pdejong        Created

//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime

{
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;

    //   access needs to be restricted    
    /// <include file='doc\LifetimeServices.uex' path='docs/doc[@for="LifetimeServices"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public sealed class LifetimeServices
        {   
            // Set once boolean
            private static bool isLeaseTime = false;
            private static bool isRenewOnCallTime = false;
            private static bool isSponsorshipTimeout = false;
        
            // Default values
            private static TimeSpan m_leaseTime = TimeSpan.FromMinutes(5);
            private static TimeSpan m_renewOnCallTime = TimeSpan.FromMinutes(2);
            private static TimeSpan m_sponsorshipTimeout = TimeSpan.FromMinutes(2);
            private static TimeSpan m_pollTime = TimeSpan.FromMilliseconds(10000);
            // Testing values
            //private static TimeSpan m_leaseTime = TimeSpan.FromSeconds(20);
            //private static TimeSpan m_renewOnCallTime = TimeSpan.FromSeconds(20);
            //private static TimeSpan m_sponsorshipTimeout = TimeSpan.FromSeconds(20);
            //private static TimeSpan m_pollTime = TimeSpan.FromMilliseconds(10000);        
        
            // Initial Lease Time span for appdomain
            /// <include file='doc\LifetimeServices.uex' path='docs/doc[@for="LifetimeServices.LeaseTime"]/*' />
            public static TimeSpan LeaseTime
            {
                get{ return m_leaseTime; }

                [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
                set
                    {
                        lock(typeof(LifetimeServices))
                            {
                                if (isLeaseTime)
                                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_SetOnce"), "LeaseTime"));


                                m_leaseTime = value;
                                isLeaseTime = true;
                            }
                    }

            }

            // Initial renew on call time span for appdomain
            /// <include file='doc\LifetimeServices.uex' path='docs/doc[@for="LifetimeServices.RenewOnCallTime"]/*' />
            public static TimeSpan RenewOnCallTime

            {
                get{ return m_renewOnCallTime; }
                [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
                set
                    {
                        lock(typeof(LifetimeServices))
                            {
                                if (isRenewOnCallTime)
                                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_SetOnce"), "RenewOnCallTime"));                        


                                m_renewOnCallTime = value;
                                isRenewOnCallTime = true;
                            }
                    }

            }


            // Initial sponsorshiptimeout for appdomain
            /// <include file='doc\LifetimeServices.uex' path='docs/doc[@for="LifetimeServices.SponsorshipTimeout"]/*' />
            public static TimeSpan SponsorshipTimeout

            {
                get{ return m_sponsorshipTimeout; }
                [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
                set
                    {
                        lock(typeof(LifetimeServices))
                            {
                                if (isSponsorshipTimeout)
                                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_SetOnce"), "SponsorshipTimeout"));                        
                                m_sponsorshipTimeout = value;
                                isSponsorshipTimeout = true;
                            }
                    }

            }


            // Initial sponsorshiptimeout for appdomain
            /// <include file='doc\LifetimeServices.uex' path='docs/doc[@for="LifetimeServices.LeaseManagerPollTime"]/*' />
            public static TimeSpan LeaseManagerPollTime

            {
                get{ return m_pollTime; }
                [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
                set
                    {
                        lock(typeof(LifetimeServices))
                            {
                                m_pollTime = value;
                                if (LeaseManager.IsInitialized())
                                    LeaseManager.GetLeaseManager().ChangePollTime(m_pollTime);
                            }
                    }

            }

        

            internal static ILease GetLeaseInitial(MarshalByRefObject obj)

            {
                ILease lease = null;
                LeaseManager leaseManager = LeaseManager.GetLeaseManager(LeaseManagerPollTime);
                lease = (ILease)leaseManager.GetLease(obj);
                if (lease == null)
                    lease = CreateLease(obj);
                return lease;

            }


            internal static ILease GetLease(MarshalByRefObject obj)

            {
                ILease lease = null;
                LeaseManager leaseManager = LeaseManager.GetLeaseManager(LeaseManagerPollTime);
                lease = (ILease)leaseManager.GetLease(obj);
                return lease;            

            }

        


            //internal static ILease CreateLease(MarshalByRefObject obj, IMessageSink nextSink)

            internal static ILease CreateLease(MarshalByRefObject obj)        

            {
                return CreateLease(LeaseTime, RenewOnCallTime, SponsorshipTimeout, obj);

            }


            internal static ILease CreateLease(TimeSpan leaseTime,
                                               TimeSpan renewOnCallTime,                       
                                               TimeSpan sponsorshipTimeout,
                                               MarshalByRefObject obj
                                               )

            {
                // Will create leaseManager if not already created.
                LeaseManager.GetLeaseManager(LeaseManagerPollTime);            
                return (ILease)(new Lease(leaseTime, renewOnCallTime, sponsorshipTimeout, obj));

            }

        }


    [Serializable]
    internal class LeaseLifeTimeServiceProperty : IContextProperty, IContributeObjectSink    

    {

        public String Name

        {
            get {return "LeaseLifeTimeServiceProperty";}

        }


        public bool IsNewContextOK(Context newCtx)

        {
            return true;

        }


        public void Freeze(Context newContext)

        {

        }


        // Initiates the creation of a lease

        // Creates a sink for invoking a renew on call when an object is created.

        public IMessageSink GetObjectSink(MarshalByRefObject obj, 
                                          IMessageSink nextSink)

        {
            bool fServer;
            ServerIdentity identity = (ServerIdentity)MarshalByRefObject.GetIdentity(obj, out fServer);
            BCLDebug.Assert(identity != null, "[LifetimeServices.GetObjectSink] identity != null");

            // NOTE: Single Call objects do not have a lease associated with it because they last 
            // only for the duration of the call. 
            // Singleton objects on the other hand do have leases associated with them and they can 
            // be garbage collected.
            if (identity.IsSingleCall())
            {
                BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, no lease SingleCall",obj,", NextSink "+nextSink);                
                return nextSink;
            }
    


            // Create lease. InitializeLifetimeService is a virtual method which can be overridded so that a lease with
            // object specific properties can be created.
            Object leaseObj = obj.InitializeLifetimeService();


            BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, return from InitializeLifetimeService obj ",obj,", lease ",leaseObj);


            // InitializeLifetimeService can return a lease in one of conditions:
            // 1) the lease has a null state which specifies that no lease is to be created.
            // 2) the lease has an initial state which specifies that InitializeLifeTimeService has created a new lease.
            // 3) the lease has another state which indicates that the lease has already been created and registered.


            if (leaseObj == null)
                {
                    BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, no lease ",obj,", NextSink "+nextSink);
                    return nextSink;
                }

            if (!(leaseObj is System.Runtime.Remoting.Lifetime.ILease))
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_Lifetime_ILeaseReturn"), leaseObj));

            ILease ilease = (ILease)leaseObj;
    
            if (ilease.InitialLeaseTime.CompareTo(TimeSpan.Zero) <= 0)
                {
                    // No lease
                    {
                        BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, no lease because InitialLeaseTime is Zero ",obj);
                        if (ilease is System.Runtime.Remoting.Lifetime.Lease)
                            {
                                ((Lease)ilease).Remove();
                            }
                        return nextSink;
                    }
                }


            Lease lease = null;
            lock(identity)
                {
                    if (identity.Lease != null)
                        {
                            // Lease already exists for object, object is being marsalled again
                            BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, Lease already exists for object ",obj);                    
                            lease = (Lease)identity.Lease;
                            lease.Renew(lease.InitialLeaseTime); // Reset initial lease time
                        }
                    else
                        {
                            // New lease
                            if (!(ilease is System.Runtime.Remoting.Lifetime.Lease))
                                {
                                    // InitializeLifetimeService created its own ILease object
                                    // Need to create a System.Runtime.Remoting.Lease object
                                    BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, New Lease, lease not of type Lease  ",obj);                                            
                                    lease = (Lease)LifetimeServices.GetLeaseInitial(obj);
                                    if (lease.CurrentState == LeaseState.Initial)
                                        {
                                            lease.InitialLeaseTime = ilease.InitialLeaseTime;
                                            lease.RenewOnCallTime = ilease.RenewOnCallTime;
                                            lease.SponsorshipTimeout = ilease.SponsorshipTimeout;
                                        }
                                }
                            else
                                {
                                    // An object of Type Lease was created
                                    BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, New Lease, lease is type Lease  ",obj);                                                                    
                                    lease = (Lease)ilease;
                                }

                            // Put lease in active state
                            // Creation phase of lease is over, properties can no longer be set on lease.
                            identity.Lease = lease; // Place lease into identity for object
                            // If the object has been marshaled activate 
                            // the lease
                            if (identity.ObjectRef != null)
                            {
                                lease.ActivateLease();
                            }
                        }
                }


            if (lease.RenewOnCallTime > TimeSpan.Zero)
                {
                    // RenewOnCall create sink
                    BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, lease created ",obj);                
                    return new LeaseSink(lease, nextSink);
                }
            else
                {
                    // No RenewOnCall so no sink created
                    BCLDebug.Trace("REMOTE", "LeaseLifeTimeServiceProperty.GetObjectSink, No RenewOnCall so no sink created ",obj);                                
                    return nextSink;
                }

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\leasemanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// File:        LeaseManager.cool
//
// Contents:    Administers the leases in an appdomain
//
// History:     1/5/00   pdejong        Created
//
//+----------------------------------------------------------------------------

namespace System.Runtime.Remoting.Lifetime
{
    using System;
    using System.Collections;
    using System.Threading;

    /// <include file='doc\LeaseManager.uex' path='docs/doc[@for="LeaseManager"]/*' />
    internal class LeaseManager
    {

        // Lease Lists
        private Hashtable leaseToTimeTable = new Hashtable();

        // Async Sponsor Calls
        //private SortedList sponsorCallList = new SortedList();
        private Hashtable sponsorTable = new Hashtable();


        // LeaseTimeAnalyzer thread
        private TimeSpan pollTime;
        AutoResetEvent waitHandle;
        TimerCallback leaseTimeAnalyzerDelegate;
        private volatile Timer leaseTimer;


        internal static bool IsInitialized()
        {
            DomainSpecificRemotingData remotingData = Thread.GetDomain().RemotingData;
            LeaseManager leaseManager = remotingData.LeaseManager;
            return leaseManager != null;
        }

        internal static LeaseManager GetLeaseManager(TimeSpan pollTime)
        {
            DomainSpecificRemotingData remotingData = Thread.GetDomain().RemotingData;
            LeaseManager leaseManager = remotingData.LeaseManager;
            if (leaseManager == null)
            {
                lock (remotingData)
                {
                    if (remotingData.LeaseManager == null)
                    {
                        remotingData.LeaseManager = new LeaseManager(pollTime);
                    }
                    leaseManager = remotingData.LeaseManager;
                }
            }
            return leaseManager;
        }

        internal static LeaseManager GetLeaseManager()
        {
            DomainSpecificRemotingData remotingData = Thread.GetDomain().RemotingData;
            LeaseManager leaseManager = remotingData.LeaseManager;          
            BCLDebug.Assert(leaseManager != null, "[LeaseManager.GetLeaseManager()]leaseManager !=null");
            return leaseManager;
        }


        private LeaseManager(TimeSpan pollTime)
        {
            BCLDebug.Trace("REMOTE","LeaseManager Constructor");            
            this.pollTime = pollTime;

            leaseTimeAnalyzerDelegate = new TimerCallback(this.LeaseTimeAnalyzer);
            waitHandle = new AutoResetEvent(false);
            // We need to create a Timer with Infinite dueTime to ensure that
            // leaseTimeAnalyzerDelegate doesnt get invoked before leaseTimer is initialized
            // Once initialized we can change it to the appropriate dueTime
            leaseTimer = new Timer(leaseTimeAnalyzerDelegate, null, Timeout.Infinite, Timeout.Infinite);
            leaseTimer.Change((int)pollTime.TotalMilliseconds, Timeout.Infinite);
        }


        internal void ChangePollTime(TimeSpan pollTime)
        {
            BCLDebug.Trace("REMOTE","LeaseManager ChangePollTime ", pollTime);
            this.pollTime = pollTime;
        }


        internal void ActivateLease(Lease lease)
        {
            BCLDebug.Trace("REMOTE","LeaseManager AddLease ",lease.id," ",lease.managedObject);
            lock(leaseToTimeTable)
            {
                leaseToTimeTable[lease] = lease.leaseTime;
            }
        }       

        internal void DeleteLease(Lease lease)
        {
            BCLDebug.Trace("REMOTE","LeaseManager DeleteLease ",lease.id);
            lock(leaseToTimeTable)
            {
                leaseToTimeTable.Remove(lease);
            }
        }

        // We won't get all the leases, only the ones which haven't expired.
        internal Lease[] GetLeases()
        {
            Lease[] leases = new Lease[leaseToTimeTable.Count];         
            lock(leaseToTimeTable)
            {
                IDictionaryEnumerator e = leaseToTimeTable.GetEnumerator();
                for (int i=0; e.MoveNext(); i++)
                {
                    leases[i] = (Lease)e.Key;
                }
            }
            DumpLeases(leases);                         
            return leases;
        }

        [System.Diagnostics.Conditional("_LOGGING")]
        internal void DumpLeases(Lease[] leases)
        {
            for (int i=0; i<leases.Length; i++)
            {
                BCLDebug.Trace("REMOTE","LeaseManager DumpLease ",leases[i].managedObject);                                         
            }
        }


        internal ILease GetLease(MarshalByRefObject obj)
        {
            BCLDebug.Trace("REMOTE","LeaseManager GetLease ",obj);
            bool fServer = true;
            Identity idObj = MarshalByRefObject.GetIdentity(obj, out fServer);
            if (idObj == null)
                return null;
            else
                return idObj.Lease;
        }

        internal void ChangedLeaseTime(Lease lease, DateTime newTime)
        {
            BCLDebug.Trace("REMOTE","LeaseManager ChangedLeaseTime ",lease.id," ",lease.managedObject," newTime ",newTime," currentTime ", DateTime.UtcNow);
            lock(leaseToTimeTable)
            {
                leaseToTimeTable[lease] = newTime;
            }
        }

        internal class SponsorInfo
        {
            internal Lease lease;
            internal Object sponsorId;
            internal DateTime sponsorWaitTime;

            internal SponsorInfo(Lease lease, Object sponsorId, DateTime sponsorWaitTime)
            {
                this.lease = lease;
                this.sponsorId = sponsorId;
                this.sponsorWaitTime = sponsorWaitTime;
            }
        }

        internal void RegisterSponsorCall(Lease lease, Object sponsorId, TimeSpan sponsorshipTimeOut)
        {
            BCLDebug.Trace("REMOTE","LeaseManager RegisterSponsorCall Lease ",lease," sponsorshipTimeOut ",sponsorshipTimeOut);

            lock(sponsorTable)
            {
                DateTime sponsorWaitTime = DateTime.UtcNow.Add(sponsorshipTimeOut);
                sponsorTable[sponsorId] = new SponsorInfo(lease, sponsorId, sponsorWaitTime);
            }
        }

        internal void DeleteSponsor(Object sponsorId)
        {
            lock(sponsorTable)
            {
                sponsorTable.Remove(sponsorId);
            }
        }

        ArrayList tempObjects = new ArrayList(10);

        // Thread Loop
        private void LeaseTimeAnalyzer(Object state)
        {
            //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer Entry ",state);

            // Find expired leases
            DateTime now = DateTime.UtcNow;
            lock(leaseToTimeTable)
            {
                IDictionaryEnumerator e = leaseToTimeTable.GetEnumerator();

                while (e.MoveNext())
                {
                    DateTime time = (DateTime)e.Value;
                    Lease lease = (Lease)e.Key;
                    //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer lease ",lease.id, " lease time ", time, " now ", now);
                    if (time.CompareTo(now) < 0)
                    {
                        // lease expired
                        tempObjects.Add(lease);
                    }
                }
                for (int i=0; i<tempObjects.Count; i++)
                {
                    Lease lease = (Lease)tempObjects[i];
                    //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer lease Expired remove from leaseToTimeTable ",lease.id);
                    leaseToTimeTable.Remove(lease);
                }

            }

            // Need to run this without lock on leaseToTimeTable to avoid deadlock
            for (int i=0; i<tempObjects.Count; i++)
            {
                Lease lease = (Lease)tempObjects[i];
                //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer lease Expired ",lease.id);
                if (lease != null) // Lease could be deleted if there is more then one reference to the lease
                    lease.LeaseExpired(now);
            }

            tempObjects.Clear();                

            lock(sponsorTable)
            {
                IDictionaryEnumerator e = sponsorTable.GetEnumerator();

                while (e.MoveNext())
                {
                    // Check for SponshipTimeOuts
                    Object sponsorId = e.Key;
                    SponsorInfo sponsorInfo = (SponsorInfo)e.Value;
                    //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer sponsor time ", sponsorInfo.sponsorWaitTime, " now ", now);					
                    if (sponsorInfo.sponsorWaitTime.CompareTo(now) < 0)
                    {
                        // Sponsortimeout expired expired
                        tempObjects.Add(sponsorInfo);
                    }
                }

                // Process the timed out sponsors
                for (int i=0; i<tempObjects.Count; i++)
                {
                    SponsorInfo sponsorInfo = (SponsorInfo)tempObjects[i];
                    //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer sponsor Expired remove from spansorTable", sponsorInfo.sponsorId);					
                    sponsorTable.Remove(sponsorInfo.sponsorId);
                }
            }

            // Process the timed out sponsors
            // Need to run this without lock on sponsorTable to avoid deadlock
            for (int i=0; i<tempObjects.Count; i++)
            {
                SponsorInfo sponsorInfo = (SponsorInfo)tempObjects[i];
                //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer sponsor Expired ", sponsorInfo.sponsorId);					
                if (sponsorInfo != null && sponsorInfo.lease != null){
                    sponsorInfo.lease.SponsorTimeout(sponsorInfo.sponsorId);
                    tempObjects[i] = null;
                }
            }

            tempObjects.Clear();
            leaseTimer.Change((int)pollTime.TotalMilliseconds, Timeout.Infinite);

            //BCLDebug.Trace("REMOTE","LeaseManager LeaseTimeAnalyzer Exit");
        }

        ~LeaseManager()
        {
            if (leaseTimer != null)
            {
                leaseTimer.Dispose();
                leaseTimer = null;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\messagesmuggler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       MessageSmuggler.cs
//
//  Summary:    Implements objects necessary to smuggle messages across 
//              AppDomains and determine when it's possible.
//
//==========================================================================

using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Proxies;


namespace System.Runtime.Remoting.Messaging
{

    internal class MessageSmuggler
    {
        private static bool CanSmuggleObjectDirectly(Object obj)
        {
            if ((obj is String) ||
                (obj.GetType() == typeof(void)) ||
                obj.GetType().IsPrimitive)
            {
                return true;
            }

            return false;
        } // CanSmuggleObjectDirectly


        protected static Object[] FixupArgs(Object[] args, ref ArrayList argsToSerialize)
        {            
            Object[] newArgs = new Object[args.Length];

            int total = args.Length;
            for (int co = 0; co < total; co++)
            {
                newArgs[co] = FixupArg(args[co], ref argsToSerialize);
            }

            return newArgs;
        } // FixupArgs


        protected static Object FixupArg(Object arg, ref ArrayList argsToSerialize)
        {
            // This method examines an argument and sees if it can be smuggled in some form.
            //   If it can directly be smuggled (i.e. it is a primitive or string), we
            //   just return the same object. If it's a marshal by ref object, we
            //   see if we can smuggle the obj ref. If it's a primitive or string array,
            //   we can smuggle a cloned copy of the array. In all other cases,
            //   we add it to the list of args we want serialized, and return a
            //   placeholder element (SerializedArg).
        
            if (arg == null)
                return null;

            int index;

            // IMPORTANT!!! This should be done first because CanSmuggleObjectDirectly
            //   calls GetType() and that would slow this down.
            MarshalByRefObject mbo = arg as MarshalByRefObject;
            if (mbo != null)
            {                
                // We can only try to smuggle objref's for actual CLR objects
                //   or for RemotingProxy's.
                if (!RemotingServices.IsTransparentProxy(mbo) ||
                    RemotingServices.GetRealProxy(mbo) is RemotingProxy)
                {                
                    ObjRef objRef = RemotingServices.MarshalInternal(mbo,null,null);
                    if (objRef.CanSmuggle())
                    {
                        ObjRef smugObjRef = objRef.CreateSmuggleableCopy();
                        smugObjRef.SetMarshaledObject();
                        return new SmuggledObjRef(smugObjRef);
                    }
                }

                // Add this arg to list of one's to serialize and return a placeholder
                //   since we couldn't smuggle the objref.
                if (argsToSerialize == null)
                    argsToSerialize = new ArrayList();
                index = argsToSerialize.Count;
                argsToSerialize.Add(arg);
                return new SerializedArg(index);
            }

            if (CanSmuggleObjectDirectly(arg))
                return arg;

            // if this is a primitive array, we can just make a copy.
            //   (IMPORTANT: We can directly use this copy from the
            //    other app domain, there is no reason to make another
            //    copy once we are on the other side)
            Array array = arg as Array;
            if (array != null)
            {
                Type elementType = array.GetType().GetElementType();
                if (elementType.IsPrimitive || (elementType == typeof(String)))
                    return array.Clone();
            }


            // Add this arg to list of one's to serialize and return a placeholder.
            if (argsToSerialize == null)
                argsToSerialize = new ArrayList();
            index = argsToSerialize.Count;
            argsToSerialize.Add(arg);
            return new SerializedArg(index);
        } // FixupArg


        protected static Object[] UndoFixupArgs(Object[] args, ArrayList deserializedArgs)
        {
            Object[] newArgs = new Object[args.Length];
            int total = args.Length;
            for (int co = 0; co < total; co++)
            {
                newArgs[co] = UndoFixupArg(args[co], deserializedArgs);
            }

            return newArgs;
        } // UndoFixupArgs


        protected static Object UndoFixupArg(Object arg, ArrayList deserializedArgs)
        {
            SmuggledObjRef smuggledObjRef = arg as SmuggledObjRef;
            if (smuggledObjRef != null)
            {
                // We call GetRealObject here ... that covers any
                // special unmarshaling we need to do for _ComObject
                return smuggledObjRef.ObjRef.GetRealObjectHelper();
            }

            SerializedArg serializedArg = arg as SerializedArg;
            if (serializedArg != null)
            {
                return deserializedArgs[serializedArg.Index];
            }
            
            return arg;
        } // UndoFixupArg


        // returns number of entries added to argsToSerialize
        protected static int StoreUserPropertiesForMethodMessage(
            IMethodMessage msg, 
            ref ArrayList argsToSerialize)
        {
            IDictionary properties = msg.Properties;
            MessageDictionary dict = properties as MessageDictionary;
            if (dict != null)
            {
                if (dict.HasUserData())
                {
                    int co = 0;
                    foreach (DictionaryEntry entry in dict.InternalDictionary)
                    {
                        if (argsToSerialize == null)
                            argsToSerialize = new ArrayList();
                        argsToSerialize.Add(entry);
                        co++;
                    }

                    return co;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                // FUTURE: Exclude special headers such as __Uri, as those
                //   are also transferred through other means.
                int co = 0;
                foreach (DictionaryEntry entry in properties)
                {
                    if (argsToSerialize == null)
                        argsToSerialize = new ArrayList();
                    argsToSerialize.Add(entry);
                    co++;
                }

                return co;
            }
        } // StoreUserPropertiesForMethodMessage


        //
        // Helper classes used to smuggle transformed arguments
        //

        protected class SerializedArg
        {
            private int _index;

            public SerializedArg(int index)
            {
                _index = index;
            }

            public int Index { get { return _index; } }
        }

        //
        // end of Helper classes used to smuggle transformed arguments
        //                
    
    } // class MessageSmuggler



    // stores an object reference
    internal class SmuggledObjRef
    {
        ObjRef _objRef;

        public SmuggledObjRef(ObjRef objRef)
        {
            _objRef = objRef;
        }            

        public ObjRef ObjRef { get { return _objRef; } }
    } // SmuggledObjRef

    



    internal class SmuggledMethodCallMessage : MessageSmuggler
    {
        private String   _uri;
        private String   _methodName;
        private String   _typeName;
        private Object[] _args;

        private byte[] _serializedArgs = null;
        private Object[] _serializerSmuggledArgs = null;

        // other things that might need to go through serializer
        private SerializedArg _methodSignature = null;
        private Object        _callContext = null; // either a call id string or a SerializedArg pointing to CallContext object

        private int _propertyCount = 0; // <n> = # of user properties in dictionary
                                        //   note: first <n> entries in _deserializedArgs will be the property entries
               

        // always use this helper method to create
        internal static SmuggledMethodCallMessage SmuggleIfPossible(IMessage msg)
        {        
            IMethodCallMessage mcm = msg as IMethodCallMessage;
            if (mcm == null)
                return null;        

            return new SmuggledMethodCallMessage(mcm);
        }       

        // hide default constructor
        private SmuggledMethodCallMessage(){}

        private SmuggledMethodCallMessage(IMethodCallMessage mcm)
        {
            _uri = mcm.Uri;
            _methodName = mcm.MethodName;
            _typeName = mcm.TypeName;

            ArrayList argsToSerialize = null; 
            
            IInternalMessage iim = mcm as IInternalMessage;

            // user properties (everything but special entries)
            if ((iim == null) || iim.HasProperties())
                _propertyCount = StoreUserPropertiesForMethodMessage(mcm, ref argsToSerialize);

            // handle method signature
            if (RemotingServices.IsMethodOverloaded(mcm))
            {
                if (argsToSerialize == null)
                    argsToSerialize = new ArrayList();
                _methodSignature = new SerializedArg(argsToSerialize.Count);
                argsToSerialize.Add(mcm.MethodSignature);
            }

            // handle call context
            LogicalCallContext lcc = mcm.LogicalCallContext;
            if (lcc == null)
            {
                _callContext = null;
            }
            else
            if (lcc.HasInfo)
            {
                if (argsToSerialize == null)
                    argsToSerialize = new ArrayList();
                _callContext = new SerializedArg(argsToSerialize.Count);
                argsToSerialize.Add(lcc);
            }
            else
            {
                // just smuggle the call id string
                _callContext = lcc.RemotingData.LogicalCallID;
            }
            
            _args = FixupArgs(mcm.Args, ref argsToSerialize);

            if (argsToSerialize != null)
            {
                //MemoryStream argStm = CrossAppDomainSerializer.SerializeMessageParts(argsToSerialize, out _serializerSmuggledArgs);
                MemoryStream argStm = CrossAppDomainSerializer.SerializeMessageParts(argsToSerialize);
                _serializedArgs = argStm.GetBuffer();
            }      
           
        } // SmuggledMethodCallMessage


        // returns a list of the deserialized arguments
        internal ArrayList FixupForNewAppDomain()
        {   
            ArrayList deserializedArgs = null;
        
            if (_serializedArgs != null)
            {
                deserializedArgs =
                    CrossAppDomainSerializer.DeserializeMessageParts(
                        new MemoryStream(_serializedArgs));
                //deserializedArgs =
                //    CrossAppDomainSerializer.DeserializeMessageParts(
                //        new MemoryStream(_serializedArgs), _serializerSmuggledArgs);
                _serializedArgs = null;
            }                   

            return deserializedArgs;
        } // FixupForNewAppDomain

        
        internal String Uri { get { return _uri; } }
        internal String MethodName { get { return _methodName; } }
        internal String TypeName { get { return _typeName; } }

        internal Object[] GetMethodSignature(ArrayList deserializedArgs)
        {
            if (_methodSignature != null)                    
                return (Object[])deserializedArgs[_methodSignature.Index]; 
            else
               return null;
        }
        
        internal Object[] GetArgs(ArrayList deserializedArgs)
        {
            return UndoFixupArgs(_args, deserializedArgs);
        } // GetArgs 

        internal LogicalCallContext GetCallContext(ArrayList deserializedArgs)
        {
            if (_callContext == null)
            {
                return null;
            }
            if (_callContext is String)
            {
                LogicalCallContext callContext = new LogicalCallContext();
                callContext.RemotingData.LogicalCallID = (String)_callContext;
                return callContext;
            }
            else
                return (LogicalCallContext)deserializedArgs[((SerializedArg)_callContext).Index];
        }

        internal int MessagePropertyCount
        {
            get { return _propertyCount; }
        }        

        internal void PopulateMessageProperties(IDictionary dict, ArrayList deserializedArgs)
        {
            for (int co = 0; co < _propertyCount; co++)
            {
                DictionaryEntry de = (DictionaryEntry)deserializedArgs[co];
                dict[de.Key] = de.Value;
            }
        }
        
    } // class SmuggledMethodCallMessage



    internal class SmuggledMethodReturnMessage : MessageSmuggler
    {
        private Object[]  _args;
        private Object    _returnValue;

        private byte[] _serializedArgs = null;
        private Object[] _serializerSmuggledArgs = null;

        // other things that might need to go through serializer
        private SerializedArg _exception = null;
        private Object        _callContext = null; // either a call id string or a SerializedArg pointing to CallContext object

        private int _propertyCount; // <n> = # of user properties in dictionary
                                    //   note: first <n> entries in _deserializedArgs will be the property entries
       
        // only gets created inside of FixupForNewAppDomain
        private ArrayList _deserializedArgs = null;


        // always use this helper method to create
        internal static SmuggledMethodReturnMessage SmuggleIfPossible(IMessage msg)
        {        
            IMethodReturnMessage mrm = msg as IMethodReturnMessage;
            if (mrm == null)
                return null;

            return new SmuggledMethodReturnMessage(mrm);
        }       

        // hide default constructor
        private SmuggledMethodReturnMessage(){}

        private SmuggledMethodReturnMessage(IMethodReturnMessage mrm)
        {           
            ArrayList argsToSerialize = null;
            
            ReturnMessage retMsg = mrm as ReturnMessage;

            // user properties (everything but special entries)
            if ((retMsg == null) || retMsg.HasProperties())
                _propertyCount = StoreUserPropertiesForMethodMessage(mrm, ref argsToSerialize);

            // handle exception
            Exception excep = mrm.Exception;
            if (excep != null)
            {
                if (argsToSerialize == null)
                    argsToSerialize = new ArrayList();
                _exception = new SerializedArg(argsToSerialize.Count);
                argsToSerialize.Add(excep);
            }

            // handle call context
            LogicalCallContext lcc = mrm.LogicalCallContext;
            if (lcc == null)
            {
                _callContext = null;
            }
            else
            if (lcc.HasInfo)
            {
                if (lcc.Principal != null)
                    lcc.Principal = null;
            
                if (argsToSerialize == null)
                    argsToSerialize = new ArrayList();
                _callContext = new SerializedArg(argsToSerialize.Count);
                argsToSerialize.Add(lcc);
            }
            else
            {
                // just smuggle the call id string
                _callContext = lcc.RemotingData.LogicalCallID;
            }
            
            _returnValue = FixupArg(mrm.ReturnValue, ref argsToSerialize);
            _args = FixupArgs(mrm.Args, ref argsToSerialize);

            if (argsToSerialize != null)
            {
                MemoryStream argStm = CrossAppDomainSerializer.SerializeMessageParts(argsToSerialize);
                //MemoryStream argStm = CrossAppDomainSerializer.SerializeMessageParts(argsToSerialize, out _serializerSmuggledArgs);
                _serializedArgs = argStm.GetBuffer();
            }          

        } // SmuggledMethodReturnMessage


        internal ArrayList FixupForNewAppDomain()
        {                
            ArrayList deserializedArgs = null;
        
            if (_serializedArgs != null)
            {
                deserializedArgs =
                    CrossAppDomainSerializer.DeserializeMessageParts(
                        new MemoryStream(_serializedArgs));
                //deserializedArgs =
                //    CrossAppDomainSerializer.DeserializeMessageParts(
                //        new MemoryStream(_serializedArgs), _serializerSmuggledArgs);
                _serializedArgs = null;
            }       

            return deserializedArgs;
        } // FixupForNewAppDomain
                
        internal Object GetReturnValue(ArrayList deserializedArgs)
        {
            return UndoFixupArg(_returnValue, deserializedArgs);
        } // GetReturnValue
         
        internal Object[] GetArgs(ArrayList deserializedArgs)
        {
            Object[] obj = UndoFixupArgs(_args, deserializedArgs);
            return obj;
        } // GetArgs     

        internal Exception GetException(ArrayList deserializedArgs)
        {
            if (_exception != null)
                return (Exception)deserializedArgs[_exception.Index]; 
            else
                return null;
        } // Exception
        
        internal LogicalCallContext GetCallContext(ArrayList deserializedArgs)
        {
            if (_callContext == null)
            {
                return null;
            }
            if (_callContext is String)
            {
                LogicalCallContext callContext = new LogicalCallContext();
                callContext.RemotingData.LogicalCallID = (String)_callContext;
                return callContext;
            }
            else
                return (LogicalCallContext)deserializedArgs[((SerializedArg)_callContext).Index];
        }

        internal int MessagePropertyCount
        {
            get { return _propertyCount; }
        }   
        
        internal void PopulateMessageProperties(IDictionary dict, ArrayList deserializedArgs)
        {
            for (int co = 0; co < _propertyCount; co++)
            {
                DictionaryEntry de = (DictionaryEntry)deserializedArgs[co];
                dict[de.Key] = de.Value;
            }
        }
        
    } // class SmuggledMethodReturnMessage


} // namespace System.Runtime.Remoting.Messaging
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\objecthandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ObjectHandle
**
** Author: 
**
** ObjectHandle wraps object references. A Handle allows a 
** marshal by value object to be returned through an 
** indirection allowing the caller to control when the
** object is loaded into their domain.
**
** Date:  January 24, 2000
** 
===========================================================*/

namespace System.Runtime.Remoting{

    using System;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Lifetime;

    /// <include file='doc\ObjectHandle.uex' path='docs/doc[@for="ObjectHandle"]/*' />
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public class ObjectHandle: MarshalByRefObject, IObjectHandle 
    {
        private Object WrappedObject;
        
        private ObjectHandle()
        {
        }

        /// <include file='doc\ObjectHandle.uex' path='docs/doc[@for="ObjectHandle.ObjectHandle"]/*' />
        public ObjectHandle(Object o)
        {
            WrappedObject = o;
        }

        /// <include file='doc\ObjectHandle.uex' path='docs/doc[@for="ObjectHandle.Unwrap"]/*' />
        public Object Unwrap()
        {
            return WrappedObject;
        }

        // ObjectHandle has a finite lifetime. For now the default
        // lifetime is being used, this can be changed in this method to
        // specify a custom lifetime.
        /// <include file='doc\ObjectHandle.uex' path='docs/doc[@for="ObjectHandle.InitializeLifetimeService"]/*' />
        public override Object InitializeLifetimeService()
        {
            BCLDebug.Trace("REMOTE", "ObjectHandle.InitializeLifetimeService");
            ILease lease = (ILease)base.InitializeLifetimeService();            
            return lease;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\onewayattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    OneWayAttribute.cool
**
** Attribute for marking methods as one way
** 
** Author:  Matt Smith (mattsmit)
**
** Date:    Nov 8, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
	using System.Runtime.Remoting;
	using System;
    /// <include file='doc\OneWayAttribute.uex' path='docs/doc[@for="OneWayAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method)]       // bInherited
    public class OneWayAttribute : Attribute
    {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\objref.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ObjRef.cool
**
** Author:  Tarun Anand (TarunA)
**
** Purpose: Defines the marshaled object reference class and related 
**          classes
**
**
** Date:    April 19, 1999
**
===========================================================*/
namespace System.Runtime.Remoting {

    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Security.Permissions;	
    using Win32Native = Microsoft.Win32.Win32Native;

    
    //** Purpose: Interface for providing type information. Users can use this
    //**          interface to provide custom type information which is carried
    //**          along with the ObjRef.
    /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IRemotingTypeInfo"]/*' />
    public interface IRemotingTypeInfo
    {
        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IRemotingTypeInfo.TypeName"]/*' />
        // Return the fully qualified type name 
        String TypeName 
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    set;
	}
        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IRemotingTypeInfo.CanCastTo"]/*' />

        // Check whether the given type can be cast to the type this
        // interface represents
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        bool CanCastTo(Type fromType, Object o);    
    }

    //** Purpose: Interface for providing channel information. Users can use this
    //**          interface to provide custom channel information which is carried
    //**          along with the ObjRef.
    /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IChannelInfo"]/*' />
    public interface IChannelInfo
    {
        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IChannelInfo.ChannelData"]/*' />
        // Get/Set the channel data for each channel 
        Object[] ChannelData
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    set;
        }                      
    }

    //** Purpose: Interface for providing envoy information. Users can use this
    //**          interface to provide custom envoy information which is carried
    //**          along with the ObjRef.
    /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IEnvoyInfo"]/*' />
    public interface IEnvoyInfo
    {
        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="IEnvoyInfo.EnvoySinks"]/*' />
        // Get/Set the envoy sinks 
        IMessageSink EnvoySinks
	{
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 			    
	    get;
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
	    set;
	}
    }

	

    [Serializable]
    internal class TypeInfo : IRemotingTypeInfo
    {   
        private String              serverType;
        private String[]            serverHierarchy;
        private String[]            interfacesImplemented;

        // Return the fully qualified type name 
        public virtual String TypeName
        {
            get { return serverType;}
            set { serverType = value;}
        }

        // Check whether the given type can be cast to the type this
        // interface represents
        public virtual bool CanCastTo(Type castType, Object o)
        {
            if (null != castType)
            {
                // check for System.Object and MBRO since those aren't included in the
                //   heirarchy
                if ((castType == typeof(MarshalByRefObject)) ||
                    (castType == typeof(System.Object)))
                {
                    return true;
                }
                else
                if (castType.IsInterface)
                { 
                    if (interfacesImplemented != null)
                        return CanCastTo(castType, InterfacesImplemented);
                    else
                        return false;
                }
                else
                if (castType.IsMarshalByRef)                
                {
                    if (CompareTypes(castType, serverType))
                        return true;
                
                    if ((serverHierarchy != null) && CanCastTo(castType, ServerHierarchy))
                        return true;
                }
            }

            return false;
        }

        internal static String GetQualifiedTypeName(Type type)
        {
            if (type == null)
                return null;
                
            return RemotingServices.GetDefaultQualifiedTypeName(type);
        }

        internal static bool ParseTypeAndAssembly(String typeAndAssembly, out String typeName, out String assemName)
        {
            if (typeAndAssembly == null)
            {
                typeName = null;
                assemName = null;
                return false;
            }
            
            int index = typeAndAssembly.IndexOf(',');
            if (index == -1)
            {
                typeName = typeAndAssembly;
                assemName = null;
                return true;
            }

            // type name is everything up to the first comma
            typeName = typeAndAssembly.Substring(0, index); 

            // assembly name is the rest
            assemName = typeAndAssembly.Substring(index + 1).Trim();
                        
            return true;
        } // ParseTypeAndAssembly
        

        internal TypeInfo(Type typeOfObj)
        {
            ServerType = GetQualifiedTypeName(typeOfObj);        

            // Compute the length of the server hierarchy
            Type currType = typeOfObj.BaseType;
            // typeOfObj is the root of all classes, but not included in the hierarachy.
            Message.DebugOut("RemotingServices::TypeInfo: Determining length of server heirarchy\n");
            int hierarchyLen = 0;
            while ((currType != typeof(MarshalByRefObject)) && 
                   (currType != null))
            {
                currType = currType.BaseType;
                hierarchyLen++;
            }

            // Allocate an array big enough to store the hierarchy            
            Message.DebugOut("RemotingServices::TypeInfo: Determined length of server heirarchy\n");
            String[] serverHierarchy = null;
            if (hierarchyLen > 0)
            {
                serverHierarchy = new String[hierarchyLen]; 
            
                currType = typeOfObj.BaseType;
                for (int i = 0; i < hierarchyLen; i++)
                {
                    serverHierarchy[i] = GetQualifiedTypeName(currType);
                    currType = currType.BaseType;
                }
            }

            this.ServerHierarchy = serverHierarchy;

            Message.DebugOut("RemotingServices::TypeInfo: Getting implemented interfaces\n");
            // Set the interfaces implemented
            Type[] interfaces = typeOfObj.GetInterfaces();
            String[] interfaceNames = null;
            if (interfaces.Length > 0)
            {
                interfaceNames = new String[interfaces.Length];
                for (int i = 0; i < interfaceNames.Length; i++)
                {
                    interfaceNames[i] = GetQualifiedTypeName(interfaces[i]);
                }
            }

            this.InterfacesImplemented = interfaceNames;
        } // TypeInfo

        internal virtual String ServerType 
        {
            get { return serverType; }
            set { serverType = value; }
        }

        private String[] ServerHierarchy
        {
            get { return serverHierarchy;}
            set { serverHierarchy = value;}
        }

        private String[] InterfacesImplemented
        {
            get { return interfacesImplemented;}
            set { interfacesImplemented = value;}
        }

        private bool CompareTypes(Type type1, String type2)
        {
            Type type = RemotingServices.InternalGetTypeFromQualifiedTypeName(type2);

            return type1 == type;
        }

        private bool CanCastTo(Type castType, String[] types)
        {
            bool fCastOK = false;

            // Run through the type names and see if there is a 
            // matching type
            
            if (null != castType)
            {
                for (int i = 0; i < types.Length; i++)
                {
                    if (CompareTypes(castType,types[i]))
                    {
                        fCastOK = true;
                        break;
                    }
                }
            }

            Message.DebugOut("CanCastTo returning " + fCastOK + " for type " + castType.FullName + "\n");
            return fCastOK;
        }
    }

    [Serializable]
    internal class DynamicTypeInfo : TypeInfo
    {
        internal DynamicTypeInfo(Type typeOfObj) : base(typeOfObj)
        {
        }
        public override bool CanCastTo(Type castType, Object o)
        {
            // @FUTURE: cache the results of the following call
            // so we can avoid a round trip every time
            return((MarshalByRefObject)o).IsInstanceOfType(castType);
        }
    }

    [Serializable]
    internal class ChannelInfo : IChannelInfo
    {
        private Object[]     channelData;

        internal ChannelInfo()
        {
            ChannelData = ChannelServices.CurrentChannelData;
        }

        public virtual Object[] ChannelData
        {
            get { return channelData; }
            set { channelData = value; }
        }             

    }

    [Serializable]
    internal class EnvoyInfo : IEnvoyInfo
    {
        private IMessageSink envoySinks;

        internal static IEnvoyInfo CreateEnvoyInfo(ServerIdentity serverID)
        {
            IEnvoyInfo info = null;
            if (null != serverID)
            {
                // Set the envoy sink chain
                if (serverID.EnvoyChain == null)
                {
                    // FUTURE: This could be called in the wrong context because
                    // we can marshal a proxy!!
                    serverID.RaceSetEnvoyChain(
                        serverID.ServerContext.CreateEnvoyChain(
                            serverID.TPOrObject));
                }

                // Create an envoy info object only if necessary
                IMessageSink sink = serverID.EnvoyChain as EnvoyTerminatorSink;
                if(null == sink)
                {
                    // The chain consists of more than a terminator sink
                    // Go ahead and create an envoy info structure, otherwise
                    // a null is returned and we recreate the terminator sink
                    // on the other side, automatically.
                    info = new EnvoyInfo(serverID.EnvoyChain);
                }
            }

            return info;
        }

        private EnvoyInfo(IMessageSink sinks)
        {
            BCLDebug.Assert(null != sinks, "null != sinks");
            EnvoySinks = sinks;
        }

        public virtual IMessageSink EnvoySinks
        {
            get { return envoySinks;}
            set { envoySinks = value;}
        }
    }

    /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef"]/*' />
    [Serializable]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ObjRef : IObjectReference, ISerializable
    {
        // This flag is used to distinguish between the case where
        // an actual object was marshaled as compared to the case
        // where someone wants to pass the ObjRef itself to a remote call
        internal const int FLG_MARSHALED_OBJECT  = 0x00000001;

        // This flag is used to mark a wellknown objRef (i.e. result
        // of marshaling a proxy that was obtained through a Connect call)
        internal const int FLG_WELLKNOWN_OBJREF  = 0x00000002;

        // This flag is used for a lightweight Object Reference. It is sent to those clients
        // which are not interested in receiving a full-fledged ObjRef. An example
        // of such a client will be a mobile device with hard memory and processing
        // constraints. 
        // NOTE: In this case ALL the fields EXCEPT the uri/flags field are NULL.
        internal const int FLG_LITE_OBJREF       = 0x00000004;

        internal const int FLG_PROXY_ATTRIBUTE   = 0x00000008;
        //
        //If you change the fields here, you must all change them in 
        //RemotingSurrogate::GetObjectData
        //
        internal String                 uri;
        internal IRemotingTypeInfo      typeInfo;
        internal IEnvoyInfo             envoyInfo;
        internal IChannelInfo           channelInfo;
        internal int                    objrefFlags;

        // Static fields
        private static Type orType = typeof(ObjRef);


        // shallow copy constructor used for smuggling.
        private ObjRef(ObjRef o)
        {
            BCLDebug.Assert(o.GetType() == typeof(ObjRef), "this should be just an ObjRef");

            uri = o.uri;
            typeInfo = o.typeInfo;
            envoyInfo = o.envoyInfo;
            channelInfo = o.channelInfo;
            objrefFlags = o.objrefFlags;
        } // ObjRef

		/// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.ObjRef1"]/*' />
		public ObjRef(MarshalByRefObject o, Type requestedType)
		{
			bool fServer;
			Identity id = MarshalByRefObject.GetIdentity(o, out fServer);
			Init(id, requestedType);
		}

		/// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.ObjRef2"]/*' />
		protected ObjRef(SerializationInfo info, StreamingContext context) 
        {
            String url = null; // an objref lite url
            bool bFoundFIsMarshalled = false;
        
        	SerializationInfoEnumerator e = info.GetEnumerator();
            while (e.MoveNext())
            {
                if (e.Name.Equals("uri"))
                {
                    uri = (String) e.Value;
                }
                else if (e.Name.Equals("typeInfo"))
                {
                    typeInfo = (IRemotingTypeInfo) e.Value;
                }
                else if (e.Name.Equals("envoyInfo"))
                {
                    envoyInfo = (IEnvoyInfo) e.Value;
                }
                else if (e.Name.Equals("channelInfo"))
                {
                    channelInfo = (IChannelInfo) e.Value;
                }
                else if (e.Name.Equals("objrefFlags"))
                {
                	Object o = e.Value;
                	if(o.GetType() == typeof(String))
                	{
                		objrefFlags = ((IConvertible)o).ToInt32(null);
                	}
                	else
                	{
                    	objrefFlags = (int)o;
                    }
                }
                else if (e.Name.Equals("fIsMarshalled"))
                {
                    int value;
                    Object o = e.Value;
                    if(o.GetType() == typeof(String))
                		value = ((IConvertible)o).ToInt32(null);
                	else
                    	value = (int)o;

                    if (value == 0)
                        bFoundFIsMarshalled = true;                                        
				}            
				else if (e.Name.Equals("url"))
				{
				    url = (String)e.Value;
				}
            }

            if (!bFoundFIsMarshalled)
            {
                // This ObjRef was not passed as a parameter, so we need to unmarshal it.
                objrefFlags |= FLG_MARSHALED_OBJECT; 
            }
            else
                objrefFlags &= ~FLG_MARSHALED_OBJECT;

            // If only url is present, then it is an ObjRefLite.
            if (url != null)
            {
                uri = url;
                objrefFlags |= FLG_LITE_OBJREF;
            }
            
        } // ObjRef .ctor
        
		
        internal bool CanSmuggle()
        {
            // make sure this isn't a derived class or an ObjRefLite
            if ((this.GetType() != typeof(ObjRef)) || IsObjRefLite())
                return false;
            
            Type typeOfTypeInfo = null;
            if (typeInfo != null)
                typeOfTypeInfo = typeInfo.GetType();

            Type typeOfChannelInfo = null;
            if (channelInfo != null)
                typeOfChannelInfo = channelInfo.GetType();
            
            if (((typeOfTypeInfo == null) ||
                 (typeOfTypeInfo == typeof(TypeInfo)) ||
                 (typeOfTypeInfo == typeof(DynamicTypeInfo))) &&
                (envoyInfo == null) &&
                ((typeOfChannelInfo == null) ||
                 (typeOfChannelInfo == typeof(ChannelInfo))))
            {
                if (channelInfo != null)
                {
                    foreach (Object channelData in channelInfo.ChannelData)

                    {
                        // Only consider CrossAppDomainData smuggleable.
                        if (!(channelData is CrossAppDomainData))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }
            else
            {
                return false;
            }
        } // CanSmuggle

        internal ObjRef CreateSmuggleableCopy()
        {
            BCLDebug.Assert(CanSmuggle(), "Caller should have made sure that CanSmuggle() was true first.");

            return new ObjRef(this);
        } // CreateSmuggleableCopy
        

		/// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.GetObjectData"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
	{
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            info.SetType(orType);

            if(!IsObjRefLite())
            {
                info.AddValue("uri", uri, typeof(String));
                info.AddValue("objrefFlags", (int) objrefFlags);
                info.AddValue("typeInfo", typeInfo, typeof(IRemotingTypeInfo));
                info.AddValue("envoyInfo", envoyInfo, typeof(IEnvoyInfo));
                info.AddValue("channelInfo", GetChannelInfoHelper(), typeof(IChannelInfo));
            }
            else
            {
                info.AddValue("url", uri, typeof(String));
            }
	} // GetObjectDataHelper


        // This method retrieves the channel info object to be serialized.
        // It does special checking to see if a channel url needs to be bashed
        // (currently used for switching "http://..." url to "https://...".
        private IChannelInfo GetChannelInfoHelper()
        {
            ChannelInfo oldChannelInfo = channelInfo as ChannelInfo;
            if (oldChannelInfo == null)
                return channelInfo;

            Object[] oldChannelData = oldChannelInfo.ChannelData;
            if (oldChannelData == null)
                return oldChannelInfo;

            // This will work for the IIS scenario since the machine name + application name
            //   will differentiate the url. If we generalize this mechanism in the future,
            //   we should only bash the url if the ObjRef is from the current appdomain.
            String[] bashInfo = (String[])CallContext.GetData("__bashChannelUrl");
            if (bashInfo == null)
                return oldChannelInfo;

            String urlToBash = bashInfo[0];
            String replacementUrl = bashInfo[1];

            // Copy channel info and go bash urls.
            ChannelInfo newChInfo = new ChannelInfo();
            newChInfo.ChannelData = new Object[oldChannelData.Length];
            for (int co = 0; co < oldChannelData.Length; co++)
            {
                newChInfo.ChannelData[co] = oldChannelData[co];

                // see if this is one of the ones that we need to bash
                ChannelDataStore channelDataStore = newChInfo.ChannelData[co] as ChannelDataStore;
                if (channelDataStore != null)
                {
                    String[] urls = channelDataStore.ChannelUris;
                    if ((urls != null) && (urls.Length == 1) && urls[0].Equals(urlToBash))
                    {
                        // We want to bash just the url, so we do a shallow copy
                        // and replace the url array with the replacementUrl.
                        ChannelDataStore newChannelDataStore = channelDataStore.InternalShallowCopy();
                        newChannelDataStore.ChannelUris = new String[1];
                        newChannelDataStore.ChannelUris[0] = replacementUrl;

                        newChInfo.ChannelData[co] = newChannelDataStore;
                    }
                }
            }                      

            return newChInfo;
        } // GetChannelInfoHelper
            
		
		
        // Note: The uri will be either objURI (for normal marshals) or
        // it will be the URL if a wellknown object's proxy is marshaled
        // Basically we will take whatever the URI getter on Identity gives us

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.URI"]/*' />
        public virtual String URI 
        {
            get { return uri;}
            set { uri = value;}
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.TypeInfo"]/*' />
        public virtual IRemotingTypeInfo TypeInfo 
        {
            get { return typeInfo;}
            set { typeInfo = value;}
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.EnvoyInfo"]/*' />
        public virtual IEnvoyInfo EnvoyInfo
        {
            get { return envoyInfo;}
            set { envoyInfo = value;}
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.ChannelInfo"]/*' />
        public virtual IChannelInfo ChannelInfo 
        {
            get { return channelInfo;}
            set { channelInfo = value;}
        }


        // This is called when doing fix-ups during deserialization
        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.GetRealObject"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual Object GetRealObject(StreamingContext context)
        {
            return GetRealObjectHelper();
        }
        // This is the common helper called by serialization / smuggling 
        internal Object GetRealObjectHelper()

        {
            // Check if we are a result of serialiazing an MBR object
            // or if someone wanted to pass an ObjRef itself 
            if (!IsMarshaledObject())
            {
                BCLDebug.Trace("REMOTE", "ObjRef.GetRealObject: Returning *this*\n");                
                return this;
            }
            else
            {
                // Check if this is a lightweight objref
                if(IsObjRefLite())
                {
                    BCLDebug.Assert(null != uri, "null != uri");
                    
                    // transform the url, if this is a local object (we know it is local
                    //   if we find the current application id in the url)
                    int index = uri.IndexOf(RemotingConfiguration.ApplicationId);

                    // we need to be past 0, since we have to back up a space and pick up
                    //   a slash.
                    if (index > 0)
                        uri = uri.Substring(index - 1);                   
                }
            
                // In the general case, 'this' is the 
                // objref of an activated object

                // It may also be a well known object ref ... which came by
                // because someone did a Connect(URL) and then passed the proxy
                // over to a remote method call.

                // The below call handles both cases.
                bool fRefine = !(GetType() == typeof(ObjRef));
                Object ret = RemotingServices.Unmarshal(this, fRefine);

                // Check for COMObject & do some special custom marshaling
                ret = GetCustomMarshaledCOMObject(ret);

                return ret;
            }

        }

        private Object GetCustomMarshaledCOMObject(Object ret)
        {
            // Some special work we need to do for __COMObject 
            // (Note that we use typeInfo to detect this case instead of
            // calling GetType on 'ret' so as to not refine the proxy)
            DynamicTypeInfo dt = this.TypeInfo as DynamicTypeInfo;
            if (dt != null)
            {
                // This is a COMObject type ... we do the special work 
                // only if it is from the same process but another appDomain
                // We rely on the x-appDomain channel data in the objRef
                // to provide us with the answers.
                Object ret1 = null;
                IntPtr pUnk = Win32Native.NULL;
                if (IsFromThisProcess() && !IsFromThisAppDomain())
                {
                    try
                    {
                    	bool fIsURTAggregated;
                        pUnk = ((__ComObject)ret).GetIUnknown(out fIsURTAggregated);
                        if (pUnk != Win32Native.NULL && !fIsURTAggregated)
                        {
                            // The RCW for an IUnk is per-domain. This call
                            // gets (or creates) the RCW for this pUnk for
                            // the current domain.
                            String srvTypeName = TypeInfo.TypeName;
                            String typeName = null;
                            String assemName = null;

                            System.Runtime.Remoting.TypeInfo.ParseTypeAndAssembly(srvTypeName, out typeName, out assemName);
                            BCLDebug.Assert((null != typeName) && (null != assemName), "non-null values expected");

                            Assembly asm = FormatterServices.LoadAssemblyFromStringNoThrow(assemName);
                            if (asm==null) {
                                BCLDebug.Trace("REMOTE", "ObjRef.GetCustomMarshaledCOMObject. AssemblyName is: ", assemName, " but we can't load it.");
                                throw new RemotingException(String.Format(Environment.GetResourceString("Serialization_AssemblyNotFound"), assemName));
                            }

                            Type serverType = asm.GetTypeInternal(typeName, false, false, true);                            
                            BCLDebug.Assert(serverType!=null, "bad objRef!");

                            ret1 = InteropServices.Marshal.GetTypedObjectForIUnknown(pUnk, serverType);
                            if (ret1 != null)
                            {
                                ret = ret1;
                            }    
                        }                                
                    }
                    finally
                    {
                        if (pUnk != Win32Native.NULL)
                        {
                            InteropServices.Marshal.Release(pUnk);
                        }                            
                    }                        
                }
            }
            return ret;
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.ObjRef"]/*' />
        public ObjRef()
        {
            objrefFlags = 0x0;
        }

        internal bool IsMarshaledObject()
        {
            return (objrefFlags & FLG_MARSHALED_OBJECT) == FLG_MARSHALED_OBJECT;
        }

        internal void SetMarshaledObject()
        {
            objrefFlags |= FLG_MARSHALED_OBJECT;
        }

        internal bool IsWellKnown()
        {
            return (objrefFlags & FLG_WELLKNOWN_OBJREF) == FLG_WELLKNOWN_OBJREF;
        }

        internal void SetWellKnown()
        {
            objrefFlags |= FLG_WELLKNOWN_OBJREF;
        }

        internal bool HasProxyAttribute()
        {
            return (objrefFlags & FLG_PROXY_ATTRIBUTE) == FLG_PROXY_ATTRIBUTE;
        }

        internal void SetHasProxyAttribute()
        {
            objrefFlags |= FLG_PROXY_ATTRIBUTE;
        }

        internal bool IsObjRefLite()
        {
            return (objrefFlags & FLG_LITE_OBJREF) == FLG_LITE_OBJREF;
        }

        internal void SetObjRefLite()
        {
            objrefFlags |= FLG_LITE_OBJREF;
        }

        private CrossAppDomainData GetAppDomainChannelData()
        {
            BCLDebug.Assert(
                ObjRef.IsWellFormed(this), 
                "ObjRef.IsWellFormed()");

            // Look at the ChannelData part to find CrossAppDomainData
            int i=0;
            CrossAppDomainData xadData = null;
            while (i<ChannelInfo.ChannelData.Length)
            {
                xadData = ChannelInfo.ChannelData[i] as CrossAppDomainData;
                if (null != xadData)
                {
                    return xadData;
                }
                i++;
            }

            // AdData could be null for user-created objRefs.
            return null;
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.IsFromThisProcess"]/*' />
        public bool IsFromThisProcess()
        {
	        //Wellknown objects may or may not be in the same process
	        //Hence return false;
            if (IsWellKnown())
                return false;

            CrossAppDomainData xadData = GetAppDomainChannelData();
            if (xadData != null)
            {
                return xadData.IsFromThisProcess();
            }
            return false;
        }

        /// <include file='doc\ObjRef.uex' path='docs/doc[@for="ObjRef.IsFromThisAppDomain"]/*' />
        public bool IsFromThisAppDomain()
        {
            CrossAppDomainData xadData = GetAppDomainChannelData();
            if (xadData != null)
            {
                return xadData.IsFromThisAppDomain();
            }
            return false;
        }

        // returns the internal context ID for the server context if
        // it is from the same process && the appDomain of the server
        // is still valid. If the objRef is from this process, the domain
        // id found in the objref is always returned.
        internal int GetServerContext(out int domainId)
        {
            int contextId = 0;
            domainId = 0;
            if (IsFromThisProcess())
            {
                CrossAppDomainData xadData = GetAppDomainChannelData();
                BCLDebug.Assert(xadData != null, "bad objRef?");
                domainId = xadData.DomainID;
                if (AppDomain.IsDomainIdValid(xadData.DomainID))
                {
                    contextId = xadData.ContextID;
                }
            }
            return contextId;
        }

       //
       //
        internal void Init(Identity idObj, Type requestedType)
        {        
            Message.DebugOut("RemotingServices::FillObjRef: IN");
            BCLDebug.Assert(idObj != null,"idObj != null");

            // Set the URI of the object to be marshaled            
            URI = idObj.URI;

            // Figure out the type 
            MarshalByRefObject obj = idObj.TPOrObject;
            BCLDebug.Assert(null != obj, "Identity not setup correctly");

            // Get the type of the object
            Type serverType = null;
            if(!RemotingServices.IsTransparentProxy(obj))
            {
                serverType = obj.GetType();
            }
            else
            {
                serverType = RemotingServices.GetRealProxy(obj).GetProxiedType();
            }

            Type typeOfObj = (null == requestedType ? serverType : requestedType);

            // Make sure that the server and requested types are compatible
            //  (except for objects that implement IMessageSink, since we 
            //   just hand off the message instead of invoking the proxy)
            if ((null != requestedType) &&
                !requestedType.IsAssignableFrom(serverType) &&
                (!typeof(IMessageSink).IsAssignableFrom(serverType)))
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_InvalidRequestedType"), 
                        requestedType.ToString())); ;
            }

            // Create the type info
            if(serverType.IsCOMObject)
            {
                // __ComObjects need dynamic TypeInfo
                DynamicTypeInfo dt = new DynamicTypeInfo(typeOfObj);
                TypeInfo = (IRemotingTypeInfo) dt;
            }
            else
            {
                RemotingTypeCachedData cache = (RemotingTypeCachedData)
                    InternalRemotingServices.GetReflectionCachedData(typeOfObj);
            
                TypeInfo = (IRemotingTypeInfo)cache.TypeInfo;
            }
    
            if (!idObj.IsWellKnown())
            {
                // Create the envoy info
                EnvoyInfo = System.Runtime.Remoting.EnvoyInfo.CreateEnvoyInfo(idObj as ServerIdentity);

                // Create the channel info 
                ChannelInfo = (IChannelInfo)new ChannelInfo();

                if (serverType.HasProxyAttribute)
                {
                    SetHasProxyAttribute();
                }
            }
            else
            {
                SetWellKnown();
            }

            // See if we should and can use a url obj ref?
            if (ShouldUseUrlObjRef())
            {
                if (IsWellKnown())
                {
                    // full uri already supplied.
                    SetObjRefLite();
                }
                else
                {
                    String httpUri = ChannelServices.FindFirstHttpUrlForObject(URI);
                    if (httpUri != null)
                    {
                        URI = httpUri;
                        SetObjRefLite();
                    }
                }
            }
        } // Init


        // determines if a particular type should use a url obj ref
        internal static bool ShouldUseUrlObjRef()
        {
            return RemotingConfigHandler.UrlObjRefMode;
        } // ShouldUseUrlObjRef
        

        // Check whether the objref is well formed
        internal static bool IsWellFormed(ObjRef objectRef)
        {
            // We skip the wellformed check for wellKnown, 
            // objref-lite and custom objrefs
            bool wellFormed = true;
            if ((null == objectRef) ||
                (null == objectRef.URI) ||
                (!(objectRef.IsWellKnown()  || objectRef.IsObjRefLite() ||
                   objectRef.GetType() != orType)
                    && (null == objectRef.ChannelInfo)))
            {
                wellFormed = false;
            }

            return wellFormed;
        }
    } // ObjRef 
   
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\proxyattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ProxyAttribute.cool
**
** Author:  Tarun Anand (TarunA)
**
** Purpose: Defines the attribute that is used on types which
**          need custom proxies.
**
** Date:    Sep 30, 2000
**
===========================================================*/
namespace System.Runtime.Remoting.Proxies {
        
    using System.Reflection;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Contexts;
    using System.Security.Permissions;

    // Attribute for types that need custom proxies
    /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]
    public class ProxyAttribute : Attribute , IContextAttribute
    {
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.ProxyAttribute"]/*' />
        public ProxyAttribute()
        {
            // Default constructor
        }
        
        // Default implementation of CreateInstance uses our activation services to create an instance
        // of the transparent proxy or an uninitialized marshalbyrefobject and returns it.
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.CreateInstance"]/*' />

        public virtual MarshalByRefObject CreateInstance(Type serverType)
        {
            if (!serverType.IsContextful)
            {
                throw new RemotingException(                     
                    Environment.GetResourceString(
                        "Remoting_Activation_MBR_ProxyAttribute"));
            }
            if (serverType.IsAbstract)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Acc_CreateAbst"));
            }
            return CreateInstanceInternal(serverType);
        }

        internal MarshalByRefObject CreateInstanceInternal(Type serverType)
        {
            return ActivationServices.CreateInstance(serverType);
        }

        // Default implementation of CreateProxy creates an instance of our
        // remoting proxy
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.CreateProxy"]/*' />

        public virtual RealProxy CreateProxy(ObjRef objRef, 
                                             Type serverType,  
                                             Object serverObject, 
                                             Context serverContext)
        {
            RemotingProxy rp =  new RemotingProxy(serverType);    

            // If this is a serverID, set the native context field in the TP
            if (null != serverContext)
            {
                RealProxy.SetStubData(rp, serverContext.InternalContextID);
            }
                
            // Set the flag indicating that the fields of the proxy
            // have been initialized
            rp.Initialized = true;
    
            // Sanity check
            Type t = serverType;
            if (!t.IsContextful && 
                !t.IsMarshalByRef && 
                (null != serverContext))
            {
                throw new RemotingException(                     
                    Environment.GetResourceString(
                        "Remoting_Activation_MBR_ProxyAttribute"));
            }

            return rp;
        }

        // implementation of interface IContextAttribute
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.IsContextOK"]/*' />
        public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            // always happy...
            return true;
        }
        
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.GetPropertiesForNewContext"]/*' />
        public void GetPropertiesForNewContext(IConstructionCallMessage msg)
        {
            // chill.. do nothing.
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**  File:    RemotingAttributes.cs
** 
**  Purpose: Custom attributes for modifying remoting interactions.
**
**  Date:    Oct 5, 2000
**
===========================================================*/

namespace System.Runtime.Remoting.Metadata
{
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Reflection;
    using System.Threading;

    // This is the data we store in MemberInfo.CachedData, mainly to cache custom
    //   attributes.
    internal class RemotingCachedData 
    {
        protected Object  RI;  // reflection structure on which this data structure is stored

        private SoapAttribute _soapAttr = null; // Soap related attributes derive from SoapAttribute
        
    
        internal RemotingCachedData(Object ri)
        {
            RI = ri;
        } // RemotingCachedData


        // Retrieve SOAP attribute info for _mi (or create for caching if not specified)
        internal SoapAttribute GetSoapAttribute()
        {
            if (_soapAttr == null)
            {
                lock (this)
                {
                    if (_soapAttr == null)
                    {
                        SoapAttribute tempSoapAttr = null;
                    
                        ICustomAttributeProvider cap = (ICustomAttributeProvider)RI;
                        
                        if (RI is Type)
                        {
                            Object[] attrs = cap.GetCustomAttributes(typeof(SoapTypeAttribute), true);
                            if ((attrs != null) && (attrs.Length != 0))
                                tempSoapAttr = (SoapAttribute)attrs[0];
                            else
                                tempSoapAttr = new SoapTypeAttribute();
                        }
                        else
                        if (RI is MethodBase)
                        {
                            Object[] attrs = cap.GetCustomAttributes(typeof(SoapMethodAttribute), true);
                            if ((attrs != null) && (attrs.Length != 0))
                                tempSoapAttr = (SoapAttribute)attrs[0];
                            else
                                tempSoapAttr = new SoapMethodAttribute();
                        }
                        else
                        if (RI is FieldInfo)
                        {
                            Object[] attrs = cap.GetCustomAttributes(typeof(SoapFieldAttribute), false);
                            if ((attrs != null) && (attrs.Length != 0))
                                tempSoapAttr = (SoapAttribute)attrs[0];
                            else
                                tempSoapAttr = new SoapFieldAttribute();
                        }
                        else
                        if (RI is ParameterInfo)
                        {
                            Object[] attrs = cap.GetCustomAttributes(typeof(SoapParameterAttribute), true);
                            if ((attrs != null) && (attrs.Length != 0))
                                tempSoapAttr = (SoapParameterAttribute)attrs[0];
                            else
                                tempSoapAttr = new SoapParameterAttribute();
                        }

                        // IMPORTANT: This has to be done for certain values to be automatically
                        //   generated in the attribute.
                        tempSoapAttr.SetReflectInfo(RI);

                        _soapAttr = tempSoapAttr;
                    } // if (_soapAttr == null)
                } // lock (this)
            }
            
            return _soapAttr;
        } // GetSoapAttribute
        
        
    } // class RemotingCachedData



    internal class RemotingTypeCachedData : RemotingCachedData
    {

        private class LastCalledMethodClass
        {
            public String      methodName;
            public MethodBase  MB;
        }

        private LastCalledMethodClass _lastMethodCalled; // cache for last method that was called
        private TypeInfo _typeInfo; // type info to be used for ObjRef's of this type
        private String _qualifiedTypeName;
        private String _simpleAssemblyName; // (no strong name, version, etc.)


        internal RemotingTypeCachedData(Object ri) : base(ri)
        {
            _lastMethodCalled = null;
        }

        internal MethodBase GetLastCalledMethod(String newMeth)
        {
            LastCalledMethodClass lastMeth = _lastMethodCalled;                        
            if (lastMeth == null)
                return null;

            String methodName = lastMeth.methodName;
            MethodBase mbToReturn = lastMeth.MB;

            if (mbToReturn==null || methodName==null)
                return null;

            if (methodName.Equals(newMeth))
                return mbToReturn;

            return null;
        } // GetLastCalledMethod

        internal void SetLastCalledMethod(String newMethName, MethodBase newMB)
        {
            LastCalledMethodClass lastMeth = new LastCalledMethodClass();           
            lastMeth.methodName = newMethName;
            lastMeth.MB = newMB;

            _lastMethodCalled = lastMeth;
        } // SetLastCalledMethod


        // Retrieve TypeInfo object to be used in ObjRef.
        internal TypeInfo TypeInfo
        {
            get
            {   
                if (_typeInfo == null)
                    _typeInfo = new TypeInfo((Type)RI);
                    
                return _typeInfo;
            }
        } // TypeInfo


        internal String QualifiedTypeName
        {
            get
            {
                if (_qualifiedTypeName == null)
                    _qualifiedTypeName = RemotingServices.DetermineDefaultQualifiedTypeName((Type)RI);

                return _qualifiedTypeName;
            }
        } // QualifiedTypeName


        internal String SimpleAssemblyName
        {
            get
            {
                if (_simpleAssemblyName == null)
                    _simpleAssemblyName = ((Type)RI).Module.Assembly.nGetSimpleName();

                return _simpleAssemblyName;
            }
        } // SimpleAssemblyName
        
        
    } // class RemotingTypeCachedData

    

    internal class RemotingMethodCachedData : RemotingCachedData
    {
        ParameterInfo[] _parameters = null; // list of parameters (cached because reflection always
                                            //   generates a new copy of this array)

        [Flags, Serializable]
        private enum MethodCacheFlags
        {
            None                 = 0x00,
            CheckedOneWay        = 0x01, // Have we checked for OneWay attribute?
            IsOneWay             = 0x02, // Is the OneWay attribute present?
            CheckedOverloaded    = 0x04, // Have we checked to see if this method is overloaded
            IsOverloaded         = 0x08, // Is the method overloaded?
            CheckedForAsync      = 0x10, // Have we looked for async versions of this method?
            CheckedForReturnType = 0x20, // Have we looked for the return type?
        }

        MethodCacheFlags flags;   

        // Names
        String _typeAndAssemblyName = null;
        String _methodName = null;
        Type _returnType = null; // null if return type is void or .ctor

        // parameter maps                                    
        int[] _inRefArgMap = null;     // parameter map of input and ref parameters
        int[] _outRefArgMap = null;    // parameter map of output and ref parameters
        int[] _outOnlyArgMap = null;   // parameter map of only output parameters
        int[] _nonRefOutArgMap = null; // parameter map of non byref parameters marked with [In, Out] (or [Out])

        int[] _marshalRequestMap = null;  // map of parameters that should be marshaled in
        int[] _marshalResponseMap = null; // map of parameters that should be marshaled out


        RemotingAsyncMethodCachedData _asyncMethodData = null; // information about async method versions
        
        
        internal RemotingMethodCachedData(Object ri) : base(ri)
        {
        }

        internal String TypeAndAssemblyName
        {
            get
            {
                if (_typeAndAssemblyName == null)
                    UpdateNames();
                return _typeAndAssemblyName;
            }
        } // TypeAndAssemblyName

        internal String MethodName
        {
            get
            {
                if (_methodName == null)
                    UpdateNames();
                return _methodName;
            }
        } // MethodName

        private void UpdateNames()
        {
            MethodBase mb = (MethodBase)RI;
            _methodName = mb.Name;
            _typeAndAssemblyName = RemotingServices.GetDefaultQualifiedTypeName(mb.DeclaringType);       
        } // UpdateNames
        
        internal ParameterInfo[] Parameters
        {
            get
            {
                if (_parameters == null)
                    _parameters = ((MethodBase)RI).GetParameters();
                return _parameters;
            }
        } // Parameters


        // contains index of all normal parameters and parameters marked as ref
        internal int[] InRefArgMap
        {
            get
            {
                if (_inRefArgMap == null)
                    GetArgMaps();
                return _inRefArgMap;
            }
        } // InRefArgMap

        // contains index of all parameters marked as out or ref
        internal int[] OutRefArgMap
        {
            get 
            {
                if (_outRefArgMap == null)
                    GetArgMaps();
                return _outRefArgMap;
            }
        } // OutRefArgMap

        // contains index of parameters marked as out
        internal int[] OutOnlyArgMap
        {
            get
            {
                if (_outOnlyArgMap == null)
                    GetArgMaps();
                return _outOnlyArgMap;
            }
        } // OutOnlyArgMap

        // contains index of non byref parameters marked with [In, Out]
        internal int[] NonRefOutArgMap
        {
            get
            {
                if (_nonRefOutArgMap == null)
                    GetArgMaps();
                return _nonRefOutArgMap;
            }
        } // NonRefOutArgMap

        // contains index of parameters that should be marshalled for a request        
        internal int[] MarshalRequestArgMap
        {
            get
            {
                if (_marshalRequestMap == null)
                    GetArgMaps();
                return _marshalRequestMap;
            }
        } // MarshalRequestMap

        // contains index of parameters that should be marshalled for a response
        internal int[] MarshalResponseArgMap
        {
            get
            {
                if (_marshalResponseMap == null)
                    GetArgMaps();
                return _marshalResponseMap;
            }
        } // MarshalResponseArgMap


        private void GetArgMaps()
        {
            lock (this)
            {
                if (_inRefArgMap == null)
                {
                    ArgMapper.GetParameterMaps(Parameters,
                        out _inRefArgMap, out _outRefArgMap, out _outOnlyArgMap, 
                        out _nonRefOutArgMap,
                        out _marshalRequestMap, out _marshalResponseMap);
                }
            }
        } // GetArgMaps
                        

        internal bool IsOneWayMethod()
        {
            // We are not protecting against a race
            // If there is a race while setting flags
            // we will have to compute the result again, 
            // but we will always return the correct result
            // 
            if ((flags & MethodCacheFlags.CheckedOneWay) == 0)
            {
                MethodCacheFlags isOneWay = MethodCacheFlags.CheckedOneWay;
                Object[] attrs = 
                    ((ICustomAttributeProvider)RI).GetCustomAttributes(typeof(OneWayAttribute), true);
                    
                if ((attrs != null) && (attrs.Length > 0))
                    isOneWay |= MethodCacheFlags.IsOneWay;
                
                flags |= isOneWay;
                return (isOneWay & MethodCacheFlags.IsOneWay) != 0;
            }
            return (flags & MethodCacheFlags.IsOneWay) != 0;
        } // IsOneWayMethod


        internal bool IsOverloaded()
        {
            // We are not protecting against a race
            // If there is a race while setting flags
            // we will have to compute the result again, 
            // but we will always return the correct result
            // 
            if ((flags & MethodCacheFlags.CheckedOverloaded) == 0)
            {
                MethodCacheFlags isOverloaded = MethodCacheFlags.CheckedOverloaded;
                MethodBase mb = (MethodBase)RI;

                if (mb.IsOverloaded) 
                    isOverloaded |= MethodCacheFlags.IsOverloaded;
                flags |= isOverloaded;
                return (isOverloaded & MethodCacheFlags.IsOverloaded) != 0;
            }
            return (flags & MethodCacheFlags.IsOverloaded) != 0;
        } // IsOverloaded


        // This will return the return type of the method, or null
        // if the return type is void or this is a .ctor.
        internal Type ReturnType
        {
            get
            {
                if ((flags & MethodCacheFlags.CheckedForReturnType) == 0)
                {
                    MethodInfo mi = RI as MethodInfo;
                    if (mi != null)
                    {
                        Type returnType = mi.ReturnType;
                        if (returnType != typeof(void))
                            _returnType = returnType;
                    }
                
                    flags |= MethodCacheFlags.CheckedForReturnType;
                }
               
                return _returnType;
            } // get
        } // ReturnType


        internal bool GetAsyncMethodVersion(out MethodInfo begin, out MethodInfo end)
        {
            // synchronization doesn't matter (methods always return same value)
            if ((flags & MethodCacheFlags.CheckedForAsync) == 0)
            {
                // look for async versions of this method

                // FUTURE: In V.Next, there should be an attribute to indicate that
                //   async processing is desired.
                
                if (RemotingServices.FindAsyncMethodVersion((MethodInfo)RI, out begin, out end))
                {
                    RemotingAsyncMethodCachedData async = new RemotingAsyncMethodCachedData();
                    async.BeginMethodInfo = begin;
                    async.EndMethodInfo = end;
                    _asyncMethodData = async;
                }
                else
                {
                    _asyncMethodData = null;
                }
                
                flags |= MethodCacheFlags.CheckedForAsync;
            }   

            if (_asyncMethodData != null)
            {
                begin = _asyncMethodData.BeginMethodInfo;
                end = _asyncMethodData.EndMethodInfo;
                return true;
            }
            else
            {
                // there are no async versions of this method
                begin = null;
                end = null;
                return false;           
            }
        } // GetAsyncMethodVersion



        //
        // STORAGE CLASSES
        //

        // possibly created by RemotingMethodCachedData if a method has special information
        // correlating it to its async versions.
        private class RemotingAsyncMethodCachedData
        {
            public MethodInfo BeginMethodInfo;
            public MethodInfo EndMethodInfo;
        } // class RemotingAsyncMethodCachedData

        
    } // class RemotingMethodCachedData



    //
    // SOAP ATTRIBUTES
    // 

    // Options for use with SoapOptionAttribute (combine with OR to get any combination)
    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption"]/*' />
    [Flags, Serializable]
    public enum SoapOption
    {
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.None"]/*' />
        None = 0x0,
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.AlwaysIncludeTypes"]/*' />
        AlwaysIncludeTypes = 0x1, // xsi:type always included on SOAP elements
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.XsdString"]/*' />
        XsdString = 0x2, // xsi:type always included on SOAP elements    
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.EmbedAll"]/*' />
        EmbedAll = 0x4, // Soap will be generated without references
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.Option1"]/*' />
        /// <internalonly/>
        Option1 = 0x8, // Option for temporary interop conditions, the use will change over time
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapOption.Option2"]/*' />
        /// <internalonly/>
        Option2 = 0x10, // Option for temporary interop conditions, the use will change over time
    } // SoapOption

    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="XmlFieldOrderOption"]/*' />
    /// <internalonly/>
    [Serializable]
    public enum XmlFieldOrderOption
    {
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="XmlFieldOrderOption.All"]/*' />
        All,
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="XmlFieldOrderOption.Sequence"]/*' />
        Sequence,
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="XmlFieldOrderOption.Choice"]/*' />
        Choice
    } // XmlFieldOrderOption 

    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Enum)]
    public sealed class SoapTypeAttribute : SoapAttribute
    {    
        // Used to track which values have been explicitly set. Information needed
        // by SoapServices.
        [Flags, Serializable]
        private enum ExplicitlySet
        {
            None = 0x0,
            XmlElementName = 0x1,
            XmlNamespace = 0x2,
            XmlTypeName = 0x4,
            XmlTypeNamespace = 0x8
        }

        private ExplicitlySet _explicitlySet = ExplicitlySet.None;        
    
        private SoapOption           _SoapOptions = SoapOption.None;
        private String               _XmlElementName = null;
        private String               _XmlTypeName = null;
        private String               _XmlTypeNamespace = null;
        private XmlFieldOrderOption  _XmlFieldOrder = XmlFieldOrderOption.All;


        // Returns true if this attribute specifies interop xml element values.
        internal bool IsInteropXmlElement()
        {
            return (_explicitlySet & (ExplicitlySet.XmlElementName | ExplicitlySet.XmlNamespace)) != 0;
        } // IsInteropXmlElement       

        internal bool IsInteropXmlType()
        {
            return (_explicitlySet & (ExplicitlySet.XmlTypeName | ExplicitlySet.XmlTypeNamespace)) != 0;
        } // IsInteropXmlType
        

        
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.SoapOptions"]/*' />
        public SoapOption SoapOptions
        {
            get { return _SoapOptions; }
            set { _SoapOptions = value; }
        } // SoapOptions

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.XmlElementName"]/*' />
        public String XmlElementName
        {
            get 
            {
                // generate this if it hasn't been set yet
                if ((_XmlElementName == null) && (ReflectInfo != null))
                    _XmlElementName = ((Type)ReflectInfo).Name;
                return _XmlElementName; 
            }
            
            set 
            {
                _XmlElementName = value; 
                _explicitlySet |= ExplicitlySet.XmlElementName;
            }
        } // XmlElementName

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.XmlNamespace"]/*' />
        public override String XmlNamespace
        {
            get 
            {
                // generate this if it hasn't been set
                if ((ProtXmlNamespace == null) && (ReflectInfo != null))
                {
                    ProtXmlNamespace = XmlTypeNamespace;
                }
                return ProtXmlNamespace;
            }
            
            set 
            { 
                ProtXmlNamespace = value; 
                _explicitlySet |= ExplicitlySet.XmlNamespace;
            }
        } // XmlNamespace

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.XmlTypeName"]/*' />
        public String XmlTypeName // value for xml type name (this should always be valid)
        {
            get 
            { 
                // generate this if it hasn't been set yet
                if ((_XmlTypeName == null) && (ReflectInfo != null))
                    _XmlTypeName = ((Type)ReflectInfo).Name;
                return _XmlTypeName; 
            }
            
            set 
            {
                _XmlTypeName = value; 
                _explicitlySet |= ExplicitlySet.XmlTypeName;
            }
        } // XmlTypeName

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.XmlTypeNamespace"]/*' />
        public String XmlTypeNamespace // value for xml type namespace (this should always be valid)
        {
            get 
            {
                // generate this if it hasn't been set yet
                if ((_XmlTypeNamespace == null) && (ReflectInfo != null))
                {
                    _XmlTypeNamespace = 
                        XmlNamespaceEncoder.GetXmlNamespaceForTypeNamespace((Type)ReflectInfo, null);
                }
                return _XmlTypeNamespace; 
            }
            
            set 
            { 
                _XmlTypeNamespace = value; 
                _explicitlySet |= ExplicitlySet.XmlTypeNamespace;
            }
        } // XmlTypeNamespace

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.XmlFieldOrder"]/*' />
        /// <internalonly/>
        public XmlFieldOrderOption XmlFieldOrder
        {
            get { return _XmlFieldOrder; }
            set { _XmlFieldOrder = value; }
        } // XmlFieldOrder

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapTypeAttribute.UseAttribute"]/*' />
        public override bool UseAttribute
        {
            get { return false; }
            set { throw new RemotingException(
                                Environment.GetResourceString("Remoting_Attribute_UseAttributeNotsettable")); }
        } // UseAttribute
        
    } // class SoapTypeAttribute


    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class SoapMethodAttribute : SoapAttribute
    {       
        private String _SoapAction = null;

        private String _responseXmlElementName = null;
        private String _responseXmlNamespace = null;
        private String _returnXmlElementName = null;

        private bool _bSoapActionExplicitySet = false; // Needed by SoapServices to determine if
                                                       // SoapAction was actually set (otherwise,
                                                       // accessing it will return a generated
                                                       // value)    

        internal bool SoapActionExplicitySet { get { return _bSoapActionExplicitySet; } }

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.SoapAction"]/*' />
        public String SoapAction // SoapAction value to place in protocol headers.
        {
            get 
            {
                // generate this if it hasn't been set
                if (_SoapAction == null)
                {
                    _SoapAction = XmlTypeNamespaceOfDeclaringType + "#" +
                        ((MemberInfo)ReflectInfo).Name; // This will be the method name.
                }
                return _SoapAction; 
            }
                
            set 
            {
                _SoapAction = value; 
                _bSoapActionExplicitySet = true;
            }
        }

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.UseAttribute"]/*' />
        public override bool UseAttribute
        {
            get { return false; }
            set { throw new RemotingException(
                                Environment.GetResourceString("Remoting_Attribute_UseAttributeNotsettable")); }
        }

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.XmlNamespace"]/*' />
        public override String XmlNamespace
        {
            get 
            {
                // generate this if it hasn't been set
                if (ProtXmlNamespace == null)
                {
                    ProtXmlNamespace = XmlTypeNamespaceOfDeclaringType;
                }
                return ProtXmlNamespace;
            }
            
            set { ProtXmlNamespace = value; }
        } // XmlNamespace


        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.ResponseXmlElementName"]/*' />
        public String ResponseXmlElementName
        {
            get 
            {
                // generate this if it hasn't been set yet
                if ((_responseXmlElementName == null) && (ReflectInfo != null))                
                    _responseXmlElementName = ((MemberInfo)ReflectInfo).Name + "Response";
                return _responseXmlElementName; 
            }
            
            set { _responseXmlElementName = value; }
        } // ResponseXmlElementName
        

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.ResponseXmlNamespace"]/*' />
        public String ResponseXmlNamespace
        {
            get 
            {
                // generate this if it hasn't been set
                if (_responseXmlNamespace == null)
                    _responseXmlNamespace = XmlNamespace;
                return _responseXmlNamespace;
            }
            
            set { _responseXmlNamespace = value; }
        } // ResponseXmlNamespace


        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapMethodAttribute.ReturnXmlElementName"]/*' />
        public String ReturnXmlElementName
        {
            get 
            {
                // generate this if it hasn't been set yet
                if (_returnXmlElementName == null)                
                    _returnXmlElementName = "return";
                return _returnXmlElementName; 
            }
            
            set { _returnXmlElementName = value; }
        } // ReturnXmlElementName


        private String XmlTypeNamespaceOfDeclaringType 
        { 
            get 
            { 
                if (ReflectInfo != null)
                {
                    Type declaringType = ((MemberInfo)ReflectInfo).DeclaringType;
                    return XmlNamespaceEncoder.GetXmlNamespaceForType(declaringType, null);
                }
                else
                    return null;
            }
        } // XmlTypeNamespaceOfDeclaringType

    } // class SoapMethodAttribute


    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapFieldAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Field)]
    public sealed class SoapFieldAttribute : SoapAttribute
    {
        // Used to track which values have been explicitly set. Information needed
        // by SoapServices.
        [Flags, Serializable]
        private enum ExplicitlySet
        {
            None = 0x0,
            XmlElementName = 0x1
        }

        private ExplicitlySet _explicitlySet = ExplicitlySet.None;
    

        private String _xmlElementName = null;  
        private int _order; // order in which fields should be serialized 
                            //  (if Sequence is specified on containing type's SoapTypeAttribute


        // Returns true if this attribute specifies interop xml element values.
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapFieldAttribute.IsInteropXmlElement"]/*' />
        public bool IsInteropXmlElement()
        {
            return (_explicitlySet & ExplicitlySet.XmlElementName) != 0;
        } // GetInteropXmlElement        


        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapFieldAttribute.XmlElementName"]/*' />
        public String XmlElementName
        {
            get 
            {
                // generate this if it hasn't been set yet
                if ((_xmlElementName == null) && (ReflectInfo != null))                
                    _xmlElementName = ((FieldInfo)ReflectInfo).Name;
                return _xmlElementName; 
            }
            
            set 
            {
                _xmlElementName = value; 
                _explicitlySet |= ExplicitlySet.XmlElementName;
            }
        } // XmlElementName


        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapFieldAttribute.Order"]/*' />
        /// <internalonly/>
        public int Order
        {
            get { return _order; }
            set { _order = value; }
        }
        
    } // class SoapFieldAttribute


    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapParameterAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Parameter)]
    public sealed class SoapParameterAttribute : SoapAttribute
    {
    } // SoapParameterAttribute



    // Not actually used as an attribute (just the base for the rest of them)
    /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute"]/*' />
    public class SoapAttribute : Attribute
    {
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute.ProtXmlNamespace"]/*' />
        /// <internalonly/>
        protected String  ProtXmlNamespace = null;
        private   bool    _bUseAttribute = false;
        private   bool    _bEmbedded = false;
        
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute.ReflectInfo"]/*' />
        /// <internalonly/>
        protected Object  ReflectInfo = null; // Reflection structure on which this attribute was defined

        // IMPORTANT: The caching mechanism is required to set this value before
        //   handing back a SoapAttribute, so that certain values can be automatically
        //   generated.
        internal void SetReflectInfo(Object info)
        {
            ReflectInfo = info;
        }

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute.XmlNamespace"]/*' />
        public virtual String XmlNamespace // If this returns null, then this shouldn't be namespace qualified.
        {
            get { return ProtXmlNamespace; }
            set { ProtXmlNamespace = value; }
        }
            
        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute.UseAttribute"]/*' />
        public virtual bool UseAttribute 
        {
            get { return _bUseAttribute; }
            set { _bUseAttribute = value; }
        }

        /// <include file='doc\RemotingAttributes.uex' path='docs/doc[@for="SoapAttribute.Embedded"]/*' />
        public virtual bool Embedded // Determines if type should be nested when serializing for SOAP.
        {
            get { return _bEmbedded; }
            set { _bEmbedded = value; }
        }
        
    } // class SoapAttribute


    //
    // END OF SOAP ATTRIBUTES
    //

} // namespace System.Runtime.Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: RemotingException
**
** Author: Matt Smith
**
** Purpose: Exception class for remoting 
**
** Date: July 15, 1999
**
=============================================================================*/

namespace System.Runtime.Remoting
{
	using System.Runtime.Remoting;
	using System;
	using System.Runtime.Serialization;
	// The Exception thrown when something has gone
	// wrong during remoting
	// 
	/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingException"]/*' />
	[Serializable()]
	public class RemotingException : SystemException {

		private static String _nullMessage = Environment.GetResourceString("Remoting_Default");

		// Creates a new RemotingException with its message 
		// string set to a default message.
		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingException.RemotingException"]/*' />
		public RemotingException() 
				: base(_nullMessage) {
			SetErrorCode(__HResults.COR_E_REMOTING);
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingException.RemotingException1"]/*' />
		public RemotingException(String message) 
				: base(message) {
			SetErrorCode(__HResults.COR_E_REMOTING);
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingException.RemotingException2"]/*' />

		public RemotingException(String message, Exception InnerException) 
				: base(message, InnerException) {
			SetErrorCode(__HResults.COR_E_REMOTING);
		}	

        /// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingException.RemotingException3"]/*' />
        protected RemotingException(SerializationInfo info, StreamingContext context) : base(info, context) {}
	}




	// The Exception thrown when something has gone
	// wrong on the server during remoting. This exception is thrown
	// on the client.
	// 
	/// <include file='doc\RemotingException.uex' path='docs/doc[@for="ServerException"]/*' />
	[Serializable()]
	public class ServerException : SystemException {
		private static String _nullMessage = Environment.GetResourceString("Remoting_Default");
		// Creates a new ServerException with its message 
		// string set to a default message.
		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="ServerException.ServerException"]/*' />
		public ServerException()
				: base(_nullMessage) {
			SetErrorCode(__HResults.COR_E_SERVER);			
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="ServerException.ServerException1"]/*' />
		public ServerException(String message) 
				: base(message) {
			SetErrorCode(__HResults.COR_E_SERVER);
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="ServerException.ServerException2"]/*' />

		public ServerException(String message, Exception InnerException) 
				: base(message, InnerException) {
			SetErrorCode(__HResults.COR_E_SERVER);
		}	

		internal ServerException(SerializationInfo info, StreamingContext context) : base(info, context) {}
	}


	/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingTimeoutException"]/*' />
	[Serializable()]
	public class RemotingTimeoutException : RemotingException {

		private static String _nullMessage = Environment.GetResourceString("Remoting_Default");

		// Creates a new RemotingException with its message 
		// string set to a default message.
		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingTimeoutException.RemotingTimeoutException"]/*' />
		public RemotingTimeoutException() : base(_nullMessage) 
		{
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingTimeoutException.RemotingTimeoutException1"]/*' />
		public RemotingTimeoutException(String message) : base(message) {
			SetErrorCode(__HResults.COR_E_REMOTING);
		}

		/// <include file='doc\RemotingException.uex' path='docs/doc[@for="RemotingTimeoutException.RemotingTimeoutException2"]/*' />

		public RemotingTimeoutException(String message, Exception InnerException) 
            : base(message, InnerException) 
        {
            SetErrorCode(__HResults.COR_E_REMOTING);
        }

        internal RemotingTimeoutException(SerializationInfo info, StreamingContext context) : base(info, context) {}
        
    } // RemotingTimeoutException

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\redirectionproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File: RedirectionProxy.cs

using System;
using System.Runtime.InteropServices;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Proxies;


namespace System.Runtime.Remoting
{

    internal class RedirectionProxy : MarshalByRefObject, IMessageSink
    {
        private MarshalByRefObject _proxy;
        private RealProxy _realProxy;
        private Type _serverType;
        private WellKnownObjectMode _objectMode;

        internal RedirectionProxy(MarshalByRefObject proxy, Type serverType)
        {
            _proxy = proxy;
            _realProxy = RemotingServices.GetRealProxy(_proxy);
            _serverType = serverType;
            _objectMode = WellKnownObjectMode.Singleton;
        } // RedirectionProxy


        public WellKnownObjectMode ObjectMode 
        {
            set { _objectMode = value; }
        } // ObjectMode        
    
        public virtual IMessage SyncProcessMessage(IMessage msg)
        {        
            IMessage replyMsg = null;
            
            try
            {
                msg.Properties["__Uri"] = _realProxy.IdentityObject.URI;     

                if (_objectMode == WellKnownObjectMode.Singleton)
                {
                    replyMsg = _realProxy.Invoke(msg);
                }
                else
                {
                    // This is a single call object, so we need to create
                    // a new instance.
                    MarshalByRefObject obj = (MarshalByRefObject)Activator.CreateInstance(_serverType, true);
                    BCLDebug.Assert(RemotingServices.IsTransparentProxy(obj), "expecting a proxy");
                  
                    RealProxy rp = RemotingServices.GetRealProxy(obj);
                    replyMsg = rp.Invoke(msg);
                }                
            }
            catch (Exception e)
            {
                replyMsg = new ReturnMessage(e, msg as IMethodCallMessage);
            }

            return replyMsg;
        } // SyncProcessMessage
        
        
        public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {        
            // FUTURE: Implement the async version asynchronously. However, 
            //   since this is currently only used for forwarding server
            //   messages, the async version will not be called.

            IMessage replyMsg = null;

            replyMsg = SyncProcessMessage(msg);

            if (replySink != null)
                replySink.SyncProcessMessage(replyMsg);
            
            return null;
        } // AsyncProcessMessage
        
        public IMessageSink NextSink { get { return null; } }
    
    } // class RedirectionProxy



    // This is only to be used for wellknown Singleton COM objects.
    internal class ComRedirectionProxy : MarshalByRefObject, IMessageSink
    {
        private MarshalByRefObject _comObject;
        private Type _serverType;

        internal ComRedirectionProxy(MarshalByRefObject comObject, Type serverType)
        {
            BCLDebug.Assert(serverType.IsCOMObject, "This must be a COM object type.");

            _comObject = comObject;
            _serverType = serverType;
        } // ComRedirectionProxy

    
        public virtual IMessage SyncProcessMessage(IMessage msg)
        {    
            IMethodCallMessage mcmReqMsg = (IMethodCallMessage)msg;       
            IMethodReturnMessage replyMsg = null;

            replyMsg = RemotingServices.ExecuteMessage(_comObject, mcmReqMsg);
            
            if (replyMsg != null)
            {
                // If an "RPC server not available" (HRESULT=0x800706BA) COM
                //   exception is thrown, we will try to recreate the object once.
                const int RPC_S_SERVER_UNAVAILABLE = unchecked((int)0x800706BA);
                const int RPC_S_CALL_FAILED_DNE    = unchecked((int)0x800706BF);
                COMException comException = replyMsg.Exception as COMException;
                if ((comException != null) && 
                    ((comException._HResult == RPC_S_SERVER_UNAVAILABLE) || 
                     (comException._HResult == RPC_S_CALL_FAILED_DNE)))
                {                
                    _comObject = (MarshalByRefObject)Activator.CreateInstance(_serverType, true);

                    replyMsg = RemotingServices.ExecuteMessage(_comObject, mcmReqMsg);
                }                    
            }
            
            return replyMsg;
        } // SyncProcessMessage
        
        
        public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {        
            // FUTURE: Implement the async version asynchronously. However, 
            //   since this is currently only used for forwarding server
            //   messages, the async version will not be called.

            IMessage replyMsg = null;

            replyMsg = SyncProcessMessage(msg);

            if (replySink != null)
                replySink.SyncProcessMessage(replyMsg);
            
            return null;
        } // AsyncProcessMessage
        
        public IMessageSink NextSink { get { return null; } }
    
    } // class ComRedirectionProxy
    

} // namespace System.Runtime.Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingconfigparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**  File:    RemotingConfigParser.cs
** 
**  Purpose: Parse remoting configuration files.
**
**  Date:    Aug 11, 2000
**
===========================================================*/

using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Globalization;


namespace System.Runtime.Remoting.Activation {    
   

    internal class RemotingXmlConfigFileData
    {
        // debug settings
        internal static bool LoadTypes = false; // indicates whether we should attempt to load types in config files

    
        //
        // configuration entry storage classes (in alphabetical order)
        //   There is one class for each type of entry in a remoting config file.
        //  

        internal class ChannelEntry
        {
            internal String TypeName;
            internal String AssemblyName;
            internal Hashtable Properties;
            internal bool DelayLoad = false;
            internal ArrayList ClientSinkProviders = new ArrayList();
            internal ArrayList ServerSinkProviders = new ArrayList();

            internal ChannelEntry(String typeName, String assemblyName, Hashtable properties)
            {
                TypeName = typeName;
                AssemblyName = assemblyName;
                Properties = properties;
            } // ChannelEntry
        } // class ChannelEntry


        internal class ClientWellKnownEntry
        {
            internal String TypeName;
            internal String AssemblyName;
            internal String Url;

            internal ClientWellKnownEntry(String typeName, String assemName, String url)
            {
                TypeName = typeName;
                AssemblyName = assemName;
                Url = url;
            }
        } // class ClientWellKnownEntry
        

        internal class ContextAttributeEntry
        {
            internal String TypeName;
            internal String AssemblyName;
            internal Hashtable Properties;

            internal ContextAttributeEntry(String typeName, String assemName, Hashtable properties)
            {
                TypeName = typeName;
                AssemblyName = assemName;
                Properties = properties;
            }
        } // class ContextAttributeEntry

        
        internal class InteropXmlElementEntry
        {
            internal String XmlElementName;
            internal String XmlElementNamespace;
            internal String UrtTypeName;
            internal String UrtAssemblyName;

            internal InteropXmlElementEntry(String xmlElementName, String xmlElementNamespace,
                                            String urtTypeName, String urtAssemblyName)
            {
                XmlElementName = xmlElementName;
                XmlElementNamespace = xmlElementNamespace;
                UrtTypeName = urtTypeName;
                UrtAssemblyName = urtAssemblyName;
            }
        } // class InteropXmlElementEntry
                
        internal class CustomErrorsEntry {
            internal CustomErrorsModes Mode;
            
            internal CustomErrorsEntry(CustomErrorsModes mode) {
                Mode = mode;    
            }
        }

        internal class InteropXmlTypeEntry
        {
            internal String XmlTypeName;
            internal String XmlTypeNamespace;
            internal String UrtTypeName;
            internal String UrtAssemblyName;

            internal InteropXmlTypeEntry(String xmlTypeName, String xmlTypeNamespace,
                                         String urtTypeName, String urtAssemblyName)
            {
                XmlTypeName = xmlTypeName;
                XmlTypeNamespace = xmlTypeNamespace;
                UrtTypeName = urtTypeName;
                UrtAssemblyName = urtAssemblyName;
            }
        } // class InteropXmlTypeEntry
        

        internal class LifetimeEntry
        {
            // If any of these are false, then the corresponding property wasn't specified
            //   in the config file.
            internal bool IsLeaseTimeSet = false;
            internal bool IsRenewOnCallTimeSet = false;
            internal bool IsSponsorshipTimeoutSet = false;
            internal bool IsLeaseManagerPollTimeSet = false;
        
            private TimeSpan _leaseTime;
            private TimeSpan _renewOnCallTime;
            private TimeSpan _sponsorshipTimeout;
            private TimeSpan _leaseManagerPollTime;
        
            internal TimeSpan LeaseTime {
                get 
                {
                    BCLDebug.Assert(IsLeaseTimeSet == true, "LeaseTime not set");
                    return _leaseTime;
                }
                set 
                { 
                    _leaseTime = value;
                    IsLeaseTimeSet = true;
                }
            }
            
            internal TimeSpan RenewOnCallTime {
                get 
                {
                    BCLDebug.Assert(IsRenewOnCallTimeSet == true, "RenewOnCallTime not set");
                    return _renewOnCallTime;
                }
                set 
                { 
                    _renewOnCallTime = value;
                    IsRenewOnCallTimeSet = true;
                }
            }    
            
            internal TimeSpan SponsorshipTimeout {
                get 
                {
                    BCLDebug.Assert(IsSponsorshipTimeoutSet == true, "SponsorShipTimeout not set");
                    return _sponsorshipTimeout;
                }
                set 
                { 
                    _sponsorshipTimeout = value;
                    IsSponsorshipTimeoutSet = true;
                }
            }
            
            internal TimeSpan LeaseManagerPollTime {
                get 
                {
                    BCLDebug.Assert(IsLeaseManagerPollTimeSet == true, "LeaseManagerPollTime not set");
                    return _leaseManagerPollTime;
                }
                set 
                { 
                    _leaseManagerPollTime = value;
                    IsLeaseManagerPollTimeSet = true;
                }
            }
            
        } // class LifetimeEntry


        internal class PreLoadEntry
        {
            // If TypeName is null, then all types in the assembly specified
            //   should be preloaded.
        
            internal String TypeName;
            internal String AssemblyName;

            public PreLoadEntry(String typeName, String assemblyName)
            {
                TypeName = typeName;
                AssemblyName = assemblyName;
            }
        } // class PreLoadEntry


        internal class RemoteAppEntry
        {
            internal String AppUri;

            internal ArrayList WellKnownObjects = new ArrayList();
            internal ArrayList ActivatedObjects = new ArrayList();
            
            internal RemoteAppEntry(String appUri)
            { 
                AppUri = appUri;
            }

            internal void AddWellKnownEntry(String typeName, String assemName, String url)
            {
                ClientWellKnownEntry cwke = new ClientWellKnownEntry(typeName, assemName, url);
                WellKnownObjects.Add(cwke);
            }   

            internal void AddActivatedEntry(String typeName, String assemName,
                                            ArrayList contextAttributes)
            {
                TypeEntry te = new TypeEntry(typeName, assemName, contextAttributes);
                ActivatedObjects.Add(te);
            }
                                                         
        } // class RemoteAppEntry

            
        internal class ServerWellKnownEntry : TypeEntry
        {
            internal String ObjectURI;
            internal WellKnownObjectMode ObjectMode;
            
            internal ServerWellKnownEntry(
                String typeName, String assemName, ArrayList contextAttributes,
                String objURI, WellKnownObjectMode objMode) :
                    base(typeName, assemName, contextAttributes)
            {
                ObjectURI = objURI;
                ObjectMode = objMode;     
            }
        } // class ServerWellKnownEntry


        internal class SinkProviderEntry
        {
            internal String TypeName;
            internal String AssemblyName;
            internal Hashtable Properties;
            internal ArrayList ProviderData = new ArrayList(); // array of SinkProviderData structures
            internal bool IsFormatter; // Is this a formatter sink provider?

            internal SinkProviderEntry(String typeName, String assemName, Hashtable properties,
                                       bool isFormatter)
            {
                TypeName = typeName;
                AssemblyName = assemName;
                Properties = properties;
                IsFormatter = isFormatter;
            }
        } // class SinkProviderEntry


        internal class TypeEntry
        {
            internal String TypeName;
            internal String AssemblyName;
            internal ArrayList ContextAttributes;
            
            internal TypeEntry(String typeName, String assemName,
                               ArrayList contextAttributes)
            {
                TypeName = typeName;
                AssemblyName = assemName;
                ContextAttributes = contextAttributes;
            }
        } // class TypeEntry


        //
        // end of configuration entry storage classes
        //


        //
        // configuration data access
        //

        internal String ApplicationName = null;  // application name
        internal LifetimeEntry Lifetime = null;  // corresponds to top-level lifetime element
        internal bool UrlObjRefMode = RemotingConfigHandler.UrlObjRefMode;  // should url obj ref's be used?
        internal CustomErrorsEntry CustomErrors = null;
    
        internal ArrayList ChannelEntries = new ArrayList();
        internal ArrayList InteropXmlElementEntries = new ArrayList();
        internal ArrayList InteropXmlTypeEntries = new ArrayList();
        internal ArrayList PreLoadEntries = new ArrayList();
        internal ArrayList RemoteAppEntries = new ArrayList();
        internal ArrayList ServerActivatedEntries = new ArrayList();
        internal ArrayList ServerWellKnownEntries = new ArrayList();

        
        //
        // end of configuration data access
        //

        
        //
        // modify configuration data (for multiple entry entities)
        //

        internal void AddInteropXmlElementEntry(String xmlElementName, String xmlElementNamespace,
                                                String urtTypeName, String urtAssemblyName)
        {
            TryToLoadTypeIfApplicable(urtTypeName, urtAssemblyName);
            InteropXmlElementEntry ixee = new InteropXmlElementEntry(
                xmlElementName, xmlElementNamespace, urtTypeName, urtAssemblyName);
            InteropXmlElementEntries.Add(ixee);
        }

        internal void AddInteropXmlTypeEntry(String xmlTypeName, String xmlTypeNamespace,
                                             String urtTypeName, String urtAssemblyName)
        {
            TryToLoadTypeIfApplicable(urtTypeName, urtAssemblyName);
            InteropXmlTypeEntry ixte = new InteropXmlTypeEntry(xmlTypeName, xmlTypeNamespace,
                                                               urtTypeName, urtAssemblyName);
            InteropXmlTypeEntries.Add(ixte);
        }

        internal void AddPreLoadEntry(String typeName, String assemblyName)
        {
            TryToLoadTypeIfApplicable(typeName, assemblyName);
            PreLoadEntry ple = new PreLoadEntry(typeName, assemblyName);
            PreLoadEntries.Add(ple);                                                
        }

        internal RemoteAppEntry AddRemoteAppEntry(String appUri)
        {
            RemoteAppEntry rae = new RemoteAppEntry(appUri);
            RemoteAppEntries.Add(rae);
            return rae;
        }

        internal void AddServerActivatedEntry(String typeName, String assemName,
                                              ArrayList contextAttributes)
        {
            TryToLoadTypeIfApplicable(typeName, assemName);
            TypeEntry te = new TypeEntry(typeName, assemName, contextAttributes);
            ServerActivatedEntries.Add(te);
        } 

        internal ServerWellKnownEntry AddServerWellKnownEntry(String typeName, String assemName,
            ArrayList contextAttributes, String objURI, WellKnownObjectMode objMode)
        {
            TryToLoadTypeIfApplicable(typeName, assemName);
            ServerWellKnownEntry swke = new ServerWellKnownEntry(typeName, assemName,
                contextAttributes, objURI, objMode);
            ServerWellKnownEntries.Add(swke);
            return swke;
        }    
        

        // debug settings helper
        private void TryToLoadTypeIfApplicable(String typeName, String assemblyName)
        {
            if (!LoadTypes)
                return;
        
            Assembly asm = Assembly.Load(assemblyName);
            if (asm == null)
            {
                throw new RemotingException(
                    String.Format(Environment.GetResourceString("Remoting_AssemblyLoadFailed"),
                    assemblyName));                    
            }

            Type type = asm.GetTypeInternal(typeName, false, false, false);
            if (type == null)
            {
                throw new RemotingException(
                    String.Format(Environment.GetResourceString("Remoting_BadType"),
                    typeName));     
            }
        }        
    
    } // RemotingXmlConfigFileData




    internal class RemotingXmlConfigFileParser
    {
        // template arrays
        private static Hashtable _channelTemplates = CreateSyncCaseInsensitiveHashtable();
        private static Hashtable _clientChannelSinkTemplates = CreateSyncCaseInsensitiveHashtable();
        private static Hashtable _serverChannelSinkTemplates = CreateSyncCaseInsensitiveHashtable();

        
        private static Hashtable CreateSyncCaseInsensitiveHashtable()
        {
            return Hashtable.Synchronized(CreateCaseInsensitiveHashtable());
        }

        private static Hashtable CreateCaseInsensitiveHashtable()
        {
            return new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
        }


        public static RemotingXmlConfigFileData ParseConfigFile(String filename)
        {
            RemotingXmlConfigFileData configData = new RemotingXmlConfigFileData();
        
            ConfigTreeParser parser = new ConfigTreeParser();
            ConfigNode rootNode = parser.Parse(filename, "/configuration/system.runtime.remoting");

            // check to see if this file has a system.runtime.remoting section
            if (rootNode == null)
                return null;

            // process attributes
            foreach (DictionaryEntry entry in rootNode.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "version":
                {
                    // we ignore the version attribute because this may be used
                    //   by the configuration system
                    break;
                }                
                    
                default: break;                
                } // switch
            } // foreach

            ConfigNode appNode = null;       // "application" node
            ConfigNode channelsNode = null;  // "channels" node
            ConfigNode providerNode = null;  // "channelSinkProviders" node
            ConfigNode debugNode = null;     // "debug" node
            ConfigNode customErrorsNode = null;     // "customErrors" node
            
            foreach (ConfigNode node in rootNode.Children)
            {
                switch (node.Name)
                {
                
                case "application":
                {
                    // there can only be one application node in a config file
                    if (appNode != null)
                        ReportUniqueSectionError(rootNode, appNode, configData);

                    appNode = node;
                    break;
                } // case "application"
                
                case "channels":
                {
                    if (channelsNode != null)
                        ReportUniqueSectionError(rootNode, channelsNode, configData);
                
                    channelsNode = node;
                    break;
                } // case "channels"

                case "channelSinkProviders":
                {
                    if (providerNode != null)
                        ReportUniqueSectionError(rootNode, providerNode, configData);
                
                    providerNode = node;
                    break;
                } // case "channelSinkProviders"

                case "debug":
                {
                    if (debugNode != null)
                        ReportUniqueSectionError(rootNode, debugNode, configData);
                
                    debugNode = node;
                    break;
                } // case "debug"
    
                case "customErrors":
                {
                    if (customErrorsNode != null)
                        ReportUniqueSectionError(rootNode, customErrorsNode, configData);
                
                    customErrorsNode = node;
                    break;
                }// case "customErrors"
                
                default: break;
                } // switch
            } // foreach


            if (debugNode != null)
                ProcessDebugNode(debugNode, configData);

            if (providerNode != null)
                ProcessChannelSinkProviderTemplates(providerNode, configData);

            if (channelsNode != null)
                ProcessChannelTemplates(channelsNode, configData);

            if (appNode != null)
                ProcessApplicationNode(appNode, configData);
                
            if (customErrorsNode != null)
                ProcessCustomErrorsNode(customErrorsNode, configData);                

            return configData;
        } // ParseConfigFile


        private static void ReportError(String errorStr, RemotingXmlConfigFileData configData)
        {
            // NOTE: In the future, this might log all errors to the configData object
            //   instead of throwing immediately.
        
            throw new RemotingException(errorStr);
        } // ReportError

        // means section must be unique
        private static void ReportUniqueSectionError(ConfigNode parent, ConfigNode child,
                                                     RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_NodeMustBeUnique"),
                    child.Name, parent.Name),
                configData);
        } // ReportUniqueSectionError

        private static void ReportUnknownAttributeError(ConfigNode node, String attributeName,
                                                        RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_UnknownAttribute"),
                    node.Name, attributeName),
                configData);
        } // ReportUnknownAttributeError

        private static void ReportUnknownValueError(ConfigNode node, String value,
                                                        RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_UnknownValue"),
                    node.Name, value),
                configData);
        } // ReportUnknownValueError
        
        private static void ReportUnknownChildError(ConfigNode parent, ConfigNode child,
                                                    RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_UnknownSection"),
                    child.Name, parent.Name),
                configData);
        } // ReportUnknownChildError

        private static void ReportMissingAttributeError(ConfigNode node, String attributeName,
                                                        RemotingXmlConfigFileData configData)
        {
            ReportMissingAttributeError(node.Name, attributeName, configData);
        } // ReportMissingAttributeError

        private static void ReportMissingAttributeError(String nodeDescription, String attributeName,
                                                        RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_RequiredXmlAttribute"),
                    nodeDescription, attributeName),
                configData);
        } // ReportMissingAttributeError

        private static void ReportMissingTypeAttributeError(ConfigNode node, String attributeName,
                                                            RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_MissingTypeAttribute"),
                    node.Name, attributeName),
                configData);
        } // ReportMissingAttributeError

        private static void ReportMissingXmlTypeAttributeError(ConfigNode node, String attributeName,
                                                               RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_MissingXmlTypeAttribute"),
                    node.Name, attributeName),
                configData);
        } // ReportMissingAttributeError

        private static void ReportInvalidTimeFormatError(String time,
                                                         RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_InvalidTimeFormat"),
                    time),
                configData);
        } // ReportInvalidTypeFormatError

        // If nodes can be represented as a template, only a template version
        //   can have an 'id' attribute
        private static void ReportNonTemplateIdAttributeError(ConfigNode node, 
                                                              RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_NonTemplateIdAttribute"),
                    node.Name),
                configData);
        } // ReportNonTemplateIdAttributeError

        private static void ReportTemplateCannotReferenceTemplateError(
            ConfigNode node, 
            RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_TemplateCannotReferenceTemplate"),
                    node.Name),
                configData);
        } // ReportTemplateCannotReferenceTemplateError

        private static void ReportUnableToResolveTemplateReferenceError(
            ConfigNode node, String referenceName, 
            RemotingXmlConfigFileData configData)
        {
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_UnableToResolveTemplate"),
                    node.Name, referenceName),
                configData);
        } // ReportUnableToResolveTemplateReferenceError

        private static void ReportAssemblyVersionInfoPresent(
            String assemName, String entryDescription,
            RemotingXmlConfigFileData configData)
        {
            // for some entries, version information is not allowed in the assembly name
            ReportError(
                String.Format(
                    Environment.GetResourceString("Remoting_Config_VersionPresent"),
                    assemName, entryDescription),
                configData);
        } // ReportAssemblyVersionInfoPresent
       

        private static void ProcessDebugNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "loadTypes":
                    RemotingXmlConfigFileData.LoadTypes = 
                        Convert.ToBoolean((String)entry.Value);
                    break;
                    
                default: break;                
                } // switch
            } // foreach

        } // ProcessDebugNode
        

        private static void ProcessApplicationNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                if (key.Equals("name"))
                    configData.ApplicationName = (String)entry.Value;
            }
        
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "channels": ProcessChannelsNode(childNode, configData); break;
                case "client": ProcessClientNode(childNode, configData); break;                                       
                case "lifetime": ProcessLifetimeNode(node, childNode, configData); break;
                case "service": ProcessServiceNode(childNode, configData); break;
                case "soapInterop": ProcessSoapInteropNode(childNode, configData); break;         

                default: break;
                } // switch
            } // foreach
        } // ProcessApplicationNode


        private static void ProcessCustomErrorsNode(ConfigNode node, RemotingXmlConfigFileData configData) {
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                if (key.Equals("mode")){
                    string value = (string)entry.Value;
                    CustomErrorsModes mode = CustomErrorsModes.On;
                     
                    if (String.Compare(value, "on", true, CultureInfo.InvariantCulture) == 0)                                        
                        mode = CustomErrorsModes.On; 
                    else if (String.Compare(value, "off", true, CultureInfo.InvariantCulture) == 0)
                        mode = CustomErrorsModes.Off; 
                    else if (String.Compare(value, "remoteonly", true, CultureInfo.InvariantCulture) == 0)
                        mode = CustomErrorsModes.RemoteOnly; 
                    else
                        ReportUnknownValueError(node, value, configData);
                   
                    configData.CustomErrors = new RemotingXmlConfigFileData.CustomErrorsEntry(mode);
                }                                                        
            }
            
        }

        private static void ProcessLifetimeNode(ConfigNode parentNode, ConfigNode node, RemotingXmlConfigFileData configData)
        {
            if (configData.Lifetime != null)
                ReportUniqueSectionError(node, parentNode, configData);
        
            configData.Lifetime = new RemotingXmlConfigFileData.LifetimeEntry();

            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                
                case "leaseTime": 
                    configData.Lifetime.LeaseTime = ParseTime((String)entry.Value, configData);
                    break;
                    
                case "sponsorshipTimeout":
                    configData.Lifetime.SponsorshipTimeout = ParseTime((String)entry.Value, configData);
                    break;

                case "renewOnCallTime":
                    configData.Lifetime.RenewOnCallTime = ParseTime((String)entry.Value, configData);
                    break;

                case "leaseManagerPollTime":
                    configData.Lifetime.LeaseManagerPollTime = ParseTime((String)entry.Value, configData);
                    break;

                default: break;
                
                } // switch
            } // foreach

        } // ProcessLifetimeNode


        // appears under "application"
        private static void ProcessServiceNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "wellknown": ProcessServiceWellKnownNode(childNode, configData); break;
                case "activated": ProcessServiceActivatedNode(childNode, configData); break;

                default: break;
                } // switch
            } // foreach
        } // ProcessServiceNode


        // appears under "application"
        private static void ProcessClientNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String remoteAppUri = null;

            // process attributes
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "url": remoteAppUri = (String)entry.Value; break;

                case "displayName": break; // displayName is ignored (used by config utility for labelling the application)

                default: break;
                } // switch
            } // foreach attribute

            RemotingXmlConfigFileData.RemoteAppEntry remoteApp =
                configData.AddRemoteAppEntry(remoteAppUri);            

            // process child nodes
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "wellknown": ProcessClientWellKnownNode(childNode, configData, remoteApp); break;
                case "activated": ProcessClientActivatedNode(childNode, configData, remoteApp); break;

                default: break;
                } // switch
            } // foreach child node


            // if there are any activated entries, we require a remote app url.
            if ((remoteApp.ActivatedObjects.Count > 0) && (remoteAppUri == null))
                ReportMissingAttributeError(node, "url", configData);
        } // ProcessClientNode


        // appears under "application"
        private static void ProcessSoapInteropNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            // process attributes
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "urlObjRef":
                {
                    configData.UrlObjRefMode = Convert.ToBoolean(entry.Value);
                    break;
                }
                
                default: break;
                } // switch
            } // foreach attribute
        
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "preLoad": ProcessPreLoadNode(childNode, configData); break;
                case "interopXmlElement": ProcessInteropXmlElementNode(childNode, configData); break;
                case "interopXmlType": ProcessInteropXmlTypeNode(childNode, configData); break;

                default: break;
                } // switch
            }
        } // ProcessSoapInteropNode


        // appears under "application"
        private static void ProcessChannelsNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            foreach (ConfigNode childNode in node.Children)
            {
                if (childNode.Name.Equals("channel"))
                {
                    RemotingXmlConfigFileData.ChannelEntry channelEntry =
                        ProcessChannelsChannelNode(childNode, configData, false);
                    configData.ChannelEntries.Add(channelEntry);
                }
            } // foreach
        } // ProcessInteropNode


        // appears under "application/service"
        private static void ProcessServiceWellKnownNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String typeName = null;
            String assemName = null;
            ArrayList contextAttributes = new ArrayList();
            
            String objectURI = null;
            
            WellKnownObjectMode objectMode = WellKnownObjectMode.Singleton;
            bool objectModeFound = false;

            // examine attributes
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "displayName": break; // displayName is ignored (used by config utility for labelling the application)
                
                case "mode":
                {
                    String value = (String)entry.Value;
                    objectModeFound = true;
                    if (String.CompareOrdinal(value, "Singleton") == 0)
                        objectMode = WellKnownObjectMode.Singleton;
                    else
                    if (String.CompareOrdinal(value, "SingleCall") == 0)
                        objectMode = WellKnownObjectMode.SingleCall;
                    else
                        objectModeFound = false;
                    break;
                } // case "mode"

                case "objectUri": objectURI = (String)entry.Value; break;

                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type"


                default: break;
                } // switch
            } // foreach

            // examine child nodes
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "contextAttribute":
                {
                    contextAttributes.Add(ProcessContextAttributeNode(childNode, configData));
                    break;
                } // case "contextAttribute"

                case "lifetime":
                {
                    // FUTURE: Add support for this.
                     break;
                } // case "lifetime"


                default: break;

                } // switch
            } // foreach child node
            

            // check for errors
            if (!objectModeFound)
            {
                ReportError(
                    Environment.GetResourceString("Remoting_Config_MissingWellKnownModeAttribute"),
                    configData);
            }                   
            
            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);


            // objectURI defaults to typeName if not specified
            if (objectURI == null)
                objectURI = typeName + ".soap";

            configData.AddServerWellKnownEntry(typeName, assemName, contextAttributes,
                objectURI, objectMode);
        } // ProcessServiceWellKnownNode


        // appears under "application/service"
        private static void ProcessServiceActivatedNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String typeName = null;
            String assemName = null;
            ArrayList contextAttributes = new ArrayList();
        
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                default: break;
                } // switch
            } // foreach attribute


            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "contextAttribute":
                {
                    contextAttributes.Add(ProcessContextAttributeNode(childNode, configData));
                    break;
                } // case "contextattribute"

                case "lifetime":
                {
                    // FUTURE: Add support for this.
                    break;
                } // case "lifetime"

                default: break;

                } // switch
            } // foreach child node

            // check for errors 
            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);

            if (CheckAssemblyNameForVersionInfo(assemName))
                ReportAssemblyVersionInfoPresent(assemName, "service activated", configData);
            
            configData.AddServerActivatedEntry(typeName, assemName, contextAttributes);
        } // ProcessServiceActivatedNode


        // appears under "application/client"
        private static void ProcessClientWellKnownNode(ConfigNode node, RemotingXmlConfigFileData configData,
            RemotingXmlConfigFileData.RemoteAppEntry remoteApp)
        {
            String typeName = null;
            String assemName = null;
            String url = null;

            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {                
                case "displayName": break; // displayName is ignored (used by config utility for labelling the application)
                
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                case "url": url = (String)entry.Value; break;

                default: break;
                } // switch
            } // foreach

            // check for errors    
            if (url == null)
                ReportMissingAttributeError("WellKnown client", "url", configData);

            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);

            if (CheckAssemblyNameForVersionInfo(assemName))
                ReportAssemblyVersionInfoPresent(assemName, "client wellknown", configData);

            remoteApp.AddWellKnownEntry(typeName, assemName, url);
        } // ProcessClientWellKnownNode


        // appears under "application/client"
        private static void ProcessClientActivatedNode(ConfigNode node, RemotingXmlConfigFileData configData,
            RemotingXmlConfigFileData.RemoteAppEntry remoteApp)
        {
            String typeName = null;
            String assemName = null;
            ArrayList contextAttributes = new ArrayList();
        
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                default: break;
                } // switch
            } // foreach

            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "contextAttribute":
                {
                    contextAttributes.Add(ProcessContextAttributeNode(childNode, configData));
                    break;
                } // case "contextAttribute"

                default: break;
                } // switch
            } // foreach child node

            // check for errors
            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);

            if (CheckAssemblyNameForVersionInfo(assemName))
                ReportAssemblyVersionInfoPresent(assemName, "client activated", configData);
            
            remoteApp.AddActivatedEntry(typeName, assemName, contextAttributes);
        } // ProcessClientActivatedNode


        private static void ProcessInteropXmlElementNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String xmlElementName = null;
            String xmlElementNamespace = null;
            String urtTypeName = null;
            String urtAssemName = null;
        
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "xml":
                {
                    ParseType((String)entry.Value, out xmlElementName, out xmlElementNamespace);
                    break;
                }
                
                case "clr":
                {
                    ParseType((String)entry.Value, out urtTypeName, out urtAssemName);
                    break;
                } // case "clr" 

                default: break;
                } // switch
            } // foreach

            // check for errors   
            if ((xmlElementName == null) || (xmlElementNamespace == null))
                ReportMissingXmlTypeAttributeError(node, "xml", configData);

            if ((urtTypeName == null) || (urtAssemName == null))
                ReportMissingTypeAttributeError(node, "clr", configData);
            
            configData.AddInteropXmlElementEntry(xmlElementName, xmlElementNamespace,
                                                 urtTypeName, urtAssemName);
        } // ProcessInteropNode


        private static void ProcessInteropXmlTypeNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String xmlTypeName = null;
            String xmlTypeNamespace = null;
            String urtTypeName = null;
            String urtAssemName = null;
        
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String key = entry.Key.ToString();
                switch (key)
                {
                case "xml":
                {
                    ParseType((String)entry.Value, out xmlTypeName, out xmlTypeNamespace);
                    break;
                }
                
                case "clr":
                {
                    ParseType((String)entry.Value, out urtTypeName, out urtAssemName);
                    break;
                } // case "type" 

                default: break;
                } // switch
            } // foreach

            // check for errors   
            if ((xmlTypeName == null) || (xmlTypeNamespace == null))
                ReportMissingXmlTypeAttributeError(node, "xml", configData);

            if ((urtTypeName == null) || (urtAssemName == null))
                ReportMissingTypeAttributeError(node, "clr", configData);
            
            configData.AddInteropXmlTypeEntry(xmlTypeName, xmlTypeNamespace,
                                              urtTypeName, urtAssemName);
        } // ProcessInteropNode


        private static void ProcessPreLoadNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String typeName = null;
            String assemblyName = null;
        
            foreach (DictionaryEntry entry in node.Attributes)
            {   
                String key = entry.Key.ToString();
                switch (key)
                {
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemblyName);
                    break;
                }
                
                case "assembly":
                {   
                    assemblyName = (String)entry.Value;
                    break;
                } // case "type" 

                default: break;
                } // switch
            } // foreach

            // check for errors   
            if (assemblyName == null)
            {
                ReportError(
                    Environment.GetResourceString("Remoting_Config_PreloadRequiresTypeOrAssembly"),
                    configData);
            }
            
            configData.AddPreLoadEntry(typeName, assemblyName);
        } // ProcessPreLoadNode



        private static RemotingXmlConfigFileData.ContextAttributeEntry
        ProcessContextAttributeNode(ConfigNode node, RemotingXmlConfigFileData configData)
        {
            String typeName = null;
            String assemName = null;
            Hashtable properties = CreateCaseInsensitiveHashtable();

            // examine attributes
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String lowercaseKey = ((String)entry.Key).ToLower(CultureInfo.InvariantCulture);
                switch (lowercaseKey)
                {
                
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                default:
                    properties[lowercaseKey] = entry.Value;
                    break;
                } // switch
            } // foreach attribute

            // check for errors        
            if ((typeName == null) || (assemName == null))
                 ReportMissingTypeAttributeError(node, "type", configData);

            RemotingXmlConfigFileData.ContextAttributeEntry attributeEntry =
                new RemotingXmlConfigFileData.ContextAttributeEntry(
                    typeName, assemName, properties);

            return attributeEntry;          
        } // ProcessContextAttributeNode
        

        // appears under "application/client"
        private static RemotingXmlConfigFileData.ChannelEntry
        ProcessChannelsChannelNode(ConfigNode node, RemotingXmlConfigFileData configData,
                                   bool isTemplate)
        {
            String id = null;
            String typeName = null;
            String assemName = null;
            Hashtable properties = CreateCaseInsensitiveHashtable();

            bool delayLoad = false;
            
            RemotingXmlConfigFileData.ChannelEntry channelTemplate = null;

            // examine attributes
            foreach (DictionaryEntry entry in node.Attributes)
            {
                String keyStr = (String)entry.Key;
                switch (keyStr)
                {
                case "displayName": break; // displayName is ignored (used by config utility for labelling the application)
                
                case "id":
                {
                    if (!isTemplate)
                    {
                        ReportNonTemplateIdAttributeError(node, configData);
                    }
                    else
                        id = ((String)entry.Value).ToLower(CultureInfo.InvariantCulture);

                    break;
                } // case "id"
                
                case "ref":
                {
                    if (isTemplate)
                    {
                        ReportTemplateCannotReferenceTemplateError(node, configData);
                    }
                    else
                    {
                        channelTemplate =
                            (RemotingXmlConfigFileData.ChannelEntry)_channelTemplates[entry.Value];
                        if (channelTemplate == null)
                        {
                            ReportUnableToResolveTemplateReferenceError(
                                node, entry.Value.ToString(), configData);
                        }
                        else
                        {
                            // load template data
                            typeName = channelTemplate.TypeName;
                            assemName = channelTemplate.AssemblyName;

                            foreach (DictionaryEntry param in channelTemplate.Properties)
                            {
                                properties[param.Key] = param.Value;
                            }
                        }
                    }

                    break;
                } // case "ref"
                
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                case "delayLoadAsClientChannel":
                {
                    delayLoad = Convert.ToBoolean((String)entry.Value);
                    break;
                } // case "delayLoadAsClientChannel"

                default:
                    properties[keyStr] = entry.Value;
                    break;
                } // switch
            } // foreach attribute

            // check for errors        
            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);          

            RemotingXmlConfigFileData.ChannelEntry channelEntry =
                new RemotingXmlConfigFileData.ChannelEntry(typeName, assemName, properties);

            channelEntry.DelayLoad = delayLoad;                                                            


            // look for sink providers
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "clientProviders": 
                    ProcessSinkProviderNodes(childNode, channelEntry, configData, false); 
                    break;
                case "serverProviders": 
                    ProcessSinkProviderNodes(childNode, channelEntry, configData, true);
                    break;

                 default: break;
                } // switch              
            } // foreach

            // if we reference a template and didn't specify any sink providers, we
            //   should copy over the providers from the template
            if (channelTemplate != null)
            {                
                // FUTURE: consider cloning the data structures so
                //   that the template can't be corrupted.
                if (channelEntry.ClientSinkProviders.Count == 0)
                {
                    channelEntry.ClientSinkProviders = channelTemplate.ClientSinkProviders;
                }
                if (channelEntry.ServerSinkProviders.Count == 0)
                {
                    channelEntry.ServerSinkProviders = channelTemplate.ServerSinkProviders;
                }
            }
            

            if (isTemplate)
            {
                _channelTemplates[id] = channelEntry;
                return null;
            }
            else
            {
                return channelEntry;
            }
        } // ProcessChannelsChannelNode





        //
        // process sink provider data
        //

        private static void ProcessSinkProviderNodes(ConfigNode node,
            RemotingXmlConfigFileData.ChannelEntry channelEntry, RemotingXmlConfigFileData configData,
            bool isServer)
        {
            // look for sink providers
            foreach (ConfigNode childNode in node.Children)
            {
                RemotingXmlConfigFileData.SinkProviderEntry entry = 
                    ProcessSinkProviderNode(childNode, configData, false, isServer);
                if (isServer)
                    channelEntry.ServerSinkProviders.Add(entry);
                else
                    channelEntry.ClientSinkProviders.Add(entry);
            } // foreach
            
        } // ProcessSinkProviderNodes


        private static RemotingXmlConfigFileData.SinkProviderEntry 
        ProcessSinkProviderNode(ConfigNode node, RemotingXmlConfigFileData configData,
                                bool isTemplate, bool isServer)
        {
            bool isFormatter = false;

            // Make sure the node is a "formatter" or "provider".
            String nodeName = node.Name;
            if (nodeName.Equals("formatter"))
                isFormatter = true;
            else
            if (nodeName.Equals("provider"))
                isFormatter = false;
            else
            {
                ReportError(
                    Environment.GetResourceString("Remoting_Config_ProviderNeedsElementName"),
                    configData);                    
            }

            String id = null;
            String typeName = null;
            String assemName = null;
            Hashtable properties = CreateCaseInsensitiveHashtable();

            RemotingXmlConfigFileData.SinkProviderEntry template = null;


            foreach (DictionaryEntry entry in node.Attributes)
            {
                String keyStr = (String)entry.Key;
                switch (keyStr)
                {
                case "id":
                {
                    if (!isTemplate)
                    {
                        // only templates can have the id attribute
                        ReportNonTemplateIdAttributeError(node, configData);
                    }
                    else
                        id = (String)entry.Value;

                    break;
                } // case "id"

                case "ref":
                {
                    if (isTemplate)
                    {
                        ReportTemplateCannotReferenceTemplateError(node, configData);
                    }
                    else
                    {
                        if (isServer)
                        {
                            template = (RemotingXmlConfigFileData.SinkProviderEntry)
                                _serverChannelSinkTemplates[entry.Value];
                        }
                        else
                        {
                            template = (RemotingXmlConfigFileData.SinkProviderEntry)
                                _clientChannelSinkTemplates[entry.Value];
                        }
                        
                        if (template == null)
                        {
                            ReportUnableToResolveTemplateReferenceError(
                                node, entry.Value.ToString(), configData);
                        }
                        else
                        {
                            // load template data
                            typeName = template.TypeName;
                            assemName = template.AssemblyName;

                            foreach (DictionaryEntry param in template.Properties)
                            {
                                properties[param.Key] = param.Value;
                            }
                        }
                    }

                    break;
                } // case "ref"
                
                case "type":
                {
                    ParseType((String)entry.Value, out typeName, out assemName);
                    break;
                } // case "type" 

                default:
                    properties[keyStr] = entry.Value;
                    break;
                } // switch
            } // foreach attribute

            // check for errors        
            if ((typeName == null) || (assemName == null))
                ReportMissingTypeAttributeError(node, "type", configData);

            RemotingXmlConfigFileData.SinkProviderEntry sinkProviderEntry = 
                new RemotingXmlConfigFileData.SinkProviderEntry(typeName, assemName, properties,
                                                                isFormatter);

            // start storing sink data
            foreach (ConfigNode childNode in node.Children)
            {
                SinkProviderData providerData = 
                    ProcessSinkProviderData(childNode, configData);
                sinkProviderEntry.ProviderData.Add(providerData);
            } // foreach


            // if we reference a template and didn't specify any provider data, we
            //   should copy over the provider data from the template
            if (template != null)
            {   
                // FUTURE: consider cloning the data structures so
                //   that the template can't be corrupted.
                if (sinkProviderEntry.ProviderData.Count == 0)
                {
                    sinkProviderEntry.ProviderData = template.ProviderData;   
                }
            }


            if (isTemplate)
            {
                if (isServer)
                    _serverChannelSinkTemplates[id] = sinkProviderEntry;
                else
                    _clientChannelSinkTemplates[id] = sinkProviderEntry;
                return null;
            }
            else
            {
                return sinkProviderEntry;
            }
        } // ProcessSinkProviderNode
        

        // providerData will already contain an object with the same name as the config node
        private static SinkProviderData ProcessSinkProviderData(ConfigNode node, 
            RemotingXmlConfigFileData configData)
        {
            SinkProviderData providerData = new SinkProviderData(node.Name);

            foreach (ConfigNode childNode in node.Children)
            {
                SinkProviderData childData = ProcessSinkProviderData(childNode, configData);
                providerData.Children.Add(childData);               
            }

            foreach (DictionaryEntry entry in node.Attributes)
            {
                providerData.Properties[entry.Key] = entry.Value;
            }
            
            return providerData;            
        } // ProcessSinkProviderData



        //
        // process template nodes
        //

        private static void ProcessChannelTemplates(ConfigNode node, RemotingXmlConfigFileData configData)
        {
        
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "channel": ProcessChannelsChannelNode(childNode, configData, true); break;

                default: break;
                } // switch
            }
        } // ProcessChannelTemplates


        private static void ProcessChannelSinkProviderTemplates(ConfigNode node, RemotingXmlConfigFileData configData)        
        {
        
            foreach (ConfigNode childNode in node.Children)
            {
                switch (childNode.Name)
                {
                case "clientProviders": ProcessChannelProviderTemplates(childNode, configData, false); break;
                case "serverProviders": ProcessChannelProviderTemplates(childNode, configData, true); break;

                default: break;
                }
            }
        } // ProcessChannelSinkProviderTemplates


        private static void ProcessChannelProviderTemplates(ConfigNode node, RemotingXmlConfigFileData configData,
                                                            bool isServer)        
        {
            foreach (ConfigNode childNode in node.Children)
            {
                ProcessSinkProviderNode(childNode, configData, true, isServer);
            }
        } // ProcessClientProviderTemplates


     

        //
        // helper functions for processing and parsing data
        //

        private static void ParseType(String typeAssem, out String typeName, out String assemName)
        {
            String value = typeAssem;
            int index = value.IndexOf(",");

            // comma must be present, and can't be last character
            if ((index >= 0) && (index < (value.Length - 1)))
            {
                typeName = value.Substring(0, index).Trim();
                assemName = value.Substring(index + 1).Trim();
            }
            else
            {
                typeName = null;
                assemName = null;
            }
        } // ParseType

        // assembly names aren't supposed to have version information in some places
        //   so we use this method to make sure that only an assembly name is
        //   specified.
        private static bool CheckAssemblyNameForVersionInfo(String assemName)
        {
            if (assemName == null)
                return false;

            // if the assembly name has a comma, we know that version information is present
            int index = assemName.IndexOf(',');
            return (index != -1);
        } // CheckAssemblyNameForVersionInfo


        private static TimeSpan ParseTime(String time, RemotingXmlConfigFileData configData)
        {
            // time formats, e.g.
            //   10D -> 10 days
            //   10H -> 10 hours
            //   10M -> 10 minutes
            //   10S -> 10 seconds
            //   10MS -> 10 milliseconds
            //   10 -> default is seconds: 10 seconds

            String specifiedTime = time;

            String metric = "s"; // default is seconds
            int metricLength = 0;

            char lastChar = ' ';
            if (time.Length > 0)
                lastChar = time[time.Length - 1];

            TimeSpan span = TimeSpan.FromSeconds(0);         
            
            try
            {                                              
                if (!Char.IsDigit(lastChar))
                {
                    if (time.Length == 0)
                        ReportInvalidTimeFormatError(specifiedTime, configData);

                    time = time.ToLower(CultureInfo.InvariantCulture);

                    metricLength = 1;
                    if (time.EndsWith("ms"))
                        metricLength = 2;
                    metric = time.Substring(time.Length - metricLength, metricLength);
                }   
                
                int value = Int32.Parse(time.Substring(0, time.Length - metricLength));   
     
                switch (metric)
                {
                    case "d": span = TimeSpan.FromDays(value); break;
                    case "h": span = TimeSpan.FromHours(value); break;
                    case "m": span = TimeSpan.FromMinutes(value); break;
                    case "s": span = TimeSpan.FromSeconds(value); break;
                    case "ms": span = TimeSpan.FromMilliseconds(value); break;

                    default:
                    {
                        ReportInvalidTimeFormatError(specifiedTime, configData);
                        break;
                    }
                } // switch
                
            } 
            catch (Exception)
            {
                ReportInvalidTimeFormatError(specifiedTime, configData);
            }

            return span;
        } // ParseTime


    } // class RemotingXmlConfigFileParser



} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingconfiguration.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemotingConfiguration.cs
**
** Purpose: Classes for interfacing with remoting configuration 
**            settings
**
** Date:    November 11, 2000
**
===========================================================*/

using System;
using System.Security;
using System.Security.Permissions;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Contexts;
using StackCrawlMark = System.Threading.StackCrawlMark;


namespace System.Runtime.Remoting 
{
    // Configuration - provides static methods interfacing with
    //   configuration settings.
    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration"]/*' />
    public class RemotingConfiguration
    {
        private static bool s_ListeningForActivationRequests = false;

        // This class only contains statics, so hide the worthless constructor
        private RemotingConfiguration()
        {
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.Configure"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void Configure(String filename)       
        {           
            RemotingConfigHandler.DoConfiguration(filename);
            
            // Set a flag in the VM to mark that remoting is configured
            // This will enable us to decide if activation for MBR
            // objects should go through the managed codepath
            RemotingServices.InternalSetRemoteActivationConfigured();

        } // Configure

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.ApplicationName"]/*' />
        public static String ApplicationName
        {
            get 
            {
                if (!RemotingConfigHandler.HasApplicationNameBeenSet())
                    return null;
                else
                    return RemotingConfigHandler.ApplicationName;
            }

            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
            set
            {
                RemotingConfigHandler.ApplicationName = value;
            }
        } // ApplicationName


        // The application id is prepended to object uri's.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.ApplicationId"]/*' />
        public static String ApplicationId
        {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get { return Identity.AppDomainUniqueId; }
        } // ApplicationId

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.ProcessId"]/*' />
        public static String ProcessId
        {
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get { return Identity.ProcessGuid;}
        }
         
        internal static CustomErrorsModes CustomErrorsMode 
        {
            get { return RemotingConfigHandler.CustomErrorsMode; }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.CustomErrorsEnabled"]/*' />
        public static bool CustomErrorsEnabled(bool isLocalRequest) 
        {
            switch (CustomErrorsMode) 
            {
                case CustomErrorsModes.Off:
                    return false;

                case CustomErrorsModes.On:
                    return true;

                case CustomErrorsModes.RemoteOnly:
                    return(!isLocalRequest);

                default:
                    return true;
            }
        }              
              
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterActivatedServiceType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterActivatedServiceType(Type type)
        {
            ActivatedServiceTypeEntry entry = new ActivatedServiceTypeEntry(type);
            RemotingConfiguration.RegisterActivatedServiceType(entry);
        } // RegisterActivatedServiceType


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterActivatedServiceType1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry)
        {
            RemotingConfigHandler.RegisterActivatedServiceType(entry);

            // make sure we're listening for activation requests
            //  (all registrations for activated service types will come through here)
            if (!s_ListeningForActivationRequests)
            {
                s_ListeningForActivationRequests = true;
                ActivationServices.StartListeningForRemoteRequests();
            }
        } // RegisterActivatedServiceType


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterWellKnownServiceType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterWellKnownServiceType(
            Type type, String objectUri, WellKnownObjectMode mode)
        {
            WellKnownServiceTypeEntry wke = 
                new WellKnownServiceTypeEntry(type, objectUri, mode);        
            RemotingConfiguration.RegisterWellKnownServiceType(wke); 
        } // RegisterWellKnownServiceType



        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterWellKnownServiceType1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry)
        {
            RemotingConfigHandler.RegisterWellKnownServiceType(entry);    
        } // RegisterWellKnownServiceType


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterActivatedClientType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterActivatedClientType(Type type, String appUrl)
        {
            ActivatedClientTypeEntry acte = 
                new ActivatedClientTypeEntry(type, appUrl);
            RemotingConfiguration.RegisterActivatedClientType(acte);
        } // RegisterActivatedClientType



        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterActivatedClientType1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterActivatedClientType(ActivatedClientTypeEntry entry)
        {
            RemotingConfigHandler.RegisterActivatedClientType(entry);

            // all registrations for activated client types will come through here
            RemotingServices.InternalSetRemoteActivationConfigured();
        } // RegisterActivatedClientType




        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterWellKnownClientType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterWellKnownClientType(Type type, String objectUrl)
        {
            WellKnownClientTypeEntry wke = new WellKnownClientTypeEntry(type, objectUrl);
            RemotingConfiguration.RegisterWellKnownClientType(wke);
        } // RegisterWellKnownClientType



        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.RegisterWellKnownClientType1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry)
        {
            RemotingConfigHandler.RegisterWellKnownClientType(entry);

            // all registrations for wellknown client types will come through here
            RemotingServices.InternalSetRemoteActivationConfigured();
        } // RegisterWellKnownClientType


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.GetRegisteredActivatedServiceTypes"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes()
        {
            return RemotingConfigHandler.GetRegisteredActivatedServiceTypes();
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.GetRegisteredWellKnownServiceTypes"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes()
        {
            return RemotingConfigHandler.GetRegisteredWellKnownServiceTypes();
        }


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.GetRegisteredActivatedClientTypes"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes()
        {
            return RemotingConfigHandler.GetRegisteredActivatedClientTypes();
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.GetRegisteredWellKnownClientTypes"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes()
        {
            return RemotingConfigHandler.GetRegisteredWellKnownClientTypes();
        }
        
        
        // This is used at the client end to check if an activation needs
        // to go remote.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.IsRemotelyActivatedClientType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType)
        {
            return RemotingConfigHandler.IsRemotelyActivatedClientType(svrType);
        }

        // This is used at the client end to check if an activation needs
        // to go remote.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.IsRemotelyActivatedClientType1"]/*' />

        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(String typeName, String assemblyName)
        {
            return RemotingConfigHandler.IsRemotelyActivatedClientType(typeName, assemblyName);
        }


        // This is used at the client end to check if a "new Foo" needs to
        // happen via a Connect() under the covers.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.IsWellKnownClientType"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType)
        {
            return RemotingConfigHandler.IsWellKnownClientType(svrType);
        }

        // This is used at the client end to check if a "new Foo" needs to
        // happen via a Connect() under the covers.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.IsWellKnownClientType1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static WellKnownClientTypeEntry IsWellKnownClientType(String typeName, 
                                                                       String assemblyName)
        {
            return RemotingConfigHandler.IsWellKnownClientType(typeName, assemblyName);
        }

        // This is used at the server end to check if a type being activated
        // is explicitly allowed by the server.
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="RemotingConfiguration.IsActivationAllowed"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static bool IsActivationAllowed(Type svrType)
        {
            return RemotingConfigHandler.IsActivationAllowed(svrType);        
        }

    } // class Configuration



    //
    // The following classes are used to register and retrieve remoted type information
    //

    // Base class for all configuration entries
    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="TypeEntry"]/*' />
    public class TypeEntry
    {
        String _typeName;
        String _assemblyName;
        RemoteAppEntry _cachedRemoteAppEntry = null;

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="TypeEntry.TypeEntry"]/*' />
        protected TypeEntry()
        {
            // Forbid creation of this class by outside users...
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.TypeName"]/*' />
        public String TypeName { get { return _typeName; } set {_typeName = value;} }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.AssemblyName"]/*' />
        public String AssemblyName { get { return _assemblyName; } set {_assemblyName = value;} }
        
        internal void CacheRemoteAppEntry(RemoteAppEntry entry) {_cachedRemoteAppEntry = entry;}
        internal RemoteAppEntry GetRemoteAppEntry() { return _cachedRemoteAppEntry;}

    }

    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry"]/*' />
    public class ActivatedClientTypeEntry : TypeEntry
    {
        String _appUrl;  // url of application to activate the type in

        // optional data
        IContextAttribute[] _contextAttributes = null;
        

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ActivatedClientTypeEntry"]/*' />
        public ActivatedClientTypeEntry(String typeName, String assemblyName, String appUrl)
        {
            if (typeName == null)
                throw new ArgumentNullException("typeName");
            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");
            if (appUrl == null)
                throw new ArgumentNullException("appUrl");
        
            TypeName = typeName;
            AssemblyName = assemblyName;
            _appUrl = appUrl;
        } // ActivatedClientTypeEntry

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ActivatedClientTypeEntry1"]/*' />
        public ActivatedClientTypeEntry(Type type, String appUrl)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            if (appUrl == null)
                throw new ArgumentNullException("appUrl");
        
            TypeName = type.FullName;
            AssemblyName = type.Module.Assembly.nGetSimpleName();
            _appUrl = appUrl;
        } // ActivatedClientTypeEntry

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ApplicationUrl"]/*' />
        public String ApplicationUrl { get { return _appUrl; } }
        
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ObjectType"]/*' />
        public Type ObjectType
        {
            get {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                bool isAssemblyLoading = false;
                return RuntimeType.GetTypeImpl(TypeName + ", " + AssemblyName, false, false,
                                               ref stackMark, ref isAssemblyLoading);
            }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ContextAttributes"]/*' />
        public IContextAttribute[] ContextAttributes
        {
            get { return _contextAttributes; }
            set { _contextAttributes = value; }
        }


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedClientTypeEntry.ToString"]/*' />
        public override String ToString()
        {
            return "type='" + TypeName + ", " + AssemblyName + "'; appUrl=" + _appUrl;
        }        
        
    } // class ActivatedClientTypeEntry


    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry"]/*' />
    public class ActivatedServiceTypeEntry : TypeEntry
    {
        // optional data
        IContextAttribute[] _contextAttributes = null;
        

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry.ActivatedServiceTypeEntry"]/*' />
        public ActivatedServiceTypeEntry(String typeName, String assemblyName)
        {
            if (typeName == null)
                throw new ArgumentNullException("typeName");
            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");
            TypeName = typeName;
            AssemblyName = assemblyName;
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry.ActivatedServiceTypeEntry1"]/*' />
        public ActivatedServiceTypeEntry(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            TypeName = type.FullName;
            AssemblyName = type.Module.Assembly.nGetSimpleName();
        }
        
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry.ObjectType"]/*' />
        public Type ObjectType
        {
            get {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                bool isAssemblyLoading = false;
                return RuntimeType.GetTypeImpl(TypeName + ", " + AssemblyName, false, false,
                                               ref stackMark, ref isAssemblyLoading);
            }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry.ContextAttributes"]/*' />
        public IContextAttribute[] ContextAttributes
        {
            get { return _contextAttributes; }
            set { _contextAttributes = value; }
        }


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="ActivatedServiceTypeEntry.ToString"]/*' />
        public override String ToString()
        {
            return "type='" + TypeName + ", " + AssemblyName + "'";
        }
        
    } // class ActivatedServiceTypeEntry


    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry"]/*' />
    public class WellKnownClientTypeEntry : TypeEntry
    {   
        String _objectUrl; 

        // optional data
        String _appUrl = null; // url of application to associate this object with
        

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.WellKnownClientTypeEntry"]/*' />
        public WellKnownClientTypeEntry(String typeName, String assemblyName, String objectUrl)
        {
            if (typeName == null)
                throw new ArgumentNullException("typeName");
            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");
            if (objectUrl == null)
                throw new ArgumentNullException("objectUrl");
        
            TypeName = typeName;
            AssemblyName = assemblyName;
            _objectUrl = objectUrl;
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.WellKnownClientTypeEntry1"]/*' />
        public WellKnownClientTypeEntry(Type type, String objectUrl)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            if (objectUrl == null)
                throw new ArgumentNullException("objectUrl");
        
            TypeName = type.FullName;
            AssemblyName = type.Module.Assembly.nGetSimpleName();
            _objectUrl = objectUrl;
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.ObjectUrl"]/*' />
        public String ObjectUrl { get { return _objectUrl; } }
        
        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.ObjectType"]/*' />
        public Type ObjectType
        {
            get {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                bool isAssemblyLoading = false;
                return RuntimeType.GetTypeImpl(TypeName + ", " + AssemblyName, false, false,
                                               ref stackMark, ref isAssemblyLoading);
            }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.ApplicationUrl"]/*' />
        public String ApplicationUrl
        {
            get { return _appUrl; }
            set { _appUrl = value; }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownClientTypeEntry.ToString"]/*' />
        public override String ToString()
        {
            String str = "type='" + TypeName + ", " + AssemblyName + "'; url=" + _objectUrl;
            if (_appUrl != null)
                str += "; appUrl=" + _appUrl;
            return str;
        }
        
    } // class WellKnownClientTypeEntry


    /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry"]/*' />
    public class WellKnownServiceTypeEntry : TypeEntry
    {
        String _objectUri;
        WellKnownObjectMode _mode;

        // optional data
        IContextAttribute[] _contextAttributes = null;

        // private data
        private ObjRef _cachedObjRef;
        private bool _bConfigured;

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.WellKnownServiceTypeEntry"]/*' />
        public WellKnownServiceTypeEntry(String typeName, String assemblyName, String objectUri,
                                         WellKnownObjectMode mode)
        {
            if (typeName == null)
                throw new ArgumentNullException("typeName");
            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");
            if (objectUri == null)
                throw new ArgumentNullException("objectUri");
        
            TypeName = typeName;
            AssemblyName = assemblyName;
            _objectUri = objectUri;
            _mode = mode;
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.WellKnownServiceTypeEntry1"]/*' />
        public WellKnownServiceTypeEntry(Type type, String objectUri, WellKnownObjectMode mode)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            if (objectUri == null)
                throw new ArgumentNullException("objectUri");
        
            TypeName = type.FullName;
            AssemblyName = type.Module.Assembly.nGetSimpleName();
            _objectUri = objectUri;
            _mode = mode;
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.ObjectUri"]/*' />
        public String ObjectUri { get { return _objectUri; } }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.Mode"]/*' />
        public WellKnownObjectMode Mode { get { return _mode; } }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.ObjectType"]/*' />
        public Type ObjectType
        {
            get {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                bool isAssemblyLoading = false;
                return RuntimeType.GetTypeImpl(TypeName + ", " + AssemblyName, false, false,
                                               ref stackMark, ref isAssemblyLoading);
            }
        }

        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.ContextAttributes"]/*' />
        public IContextAttribute[] ContextAttributes
        {
            get { return _contextAttributes; }
            set { _contextAttributes = value; }
        }


        /// <include file='doc\RemotingConfiguration.uex' path='docs/doc[@for="WellKnownServiceTypeEntry.ToString"]/*' />
        public override String ToString()
        {
            return "type='" + TypeName + ", " + AssemblyName + "'; objectUri=" + _objectUri + 
                "; mode=" + _mode.ToString();
        }

        internal void CacheObjRef(ObjRef objectRef) { _cachedObjRef = objectRef; }
        internal void SetConfigured() { _bConfigured = true; }
        internal bool IsConfigured() { return _bConfigured; }        
    } // class WellKnownServiceTypeEntry

    internal class RemoteAppEntry
    {
        String _remoteAppName;
        String _remoteAppURI;
        internal RemoteAppEntry(String appName, String appURI)
        {
            BCLDebug.Assert(appURI != null, "Bad remote app URI");
            _remoteAppName = appName;
            _remoteAppURI = appURI;
        }
        internal String GetAppName() { return _remoteAppName;}
        internal String GetAppURI() { return _remoteAppURI;}
    } // class RemoteAppEntry

    internal enum CustomErrorsModes {
        On,
        Off,
        RemoteOnly
    }

} // namespace System.Runtime.Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\realproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RealProxy.cs
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines the base class from which proxy should
**          derive
**
** Date:    Feb 16, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Proxies {
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;   
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Services;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;
    using System.Threading;


    // NOTE: Keep this in sync with unmanaged enum definition in Remoting.h
    [Serializable]
    internal enum CallType
    {
        InvalidCall     = 0x0,
        MethodCall      = 0x1,
        ConstructorCall = 0x2
    };

    [Flags]
    internal enum RealProxyFlags
    {
        None                = 0x0,
        RemotingProxy       = 0x1,
        Initialized         = 0x2
    };

    // NOTE: Keep this in sync with unmanaged struct "messageData" in Remoting.h
    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    internal struct MessageData
    {
        internal IntPtr      pFrame;
        internal int         iFlags;
        internal IntPtr      pMethodDesc;
        internal IntPtr      pDelegateMD;
        internal IntPtr      pSig;
    };

        

    /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]
    abstract public class RealProxy 
    {
        // ************* NOTE ******
        // Object.h has unmanaged structure which maps this layout
        // if you add/remove/change fields make sure to update the structure
        // in object.h also
        
        // Private members
        private Object _tp;

        private Object _identity;

        private MarshalByRefObject _serverObject;

        private RealProxyFlags _flags;


        // Static members
        private static IntPtr _defaultStub      = GetDefaultStub();

        private static int _defaultStubValue    = -1;

        private static Object _defaultStubData  = _defaultStubValue;


        // Constructor
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.RealProxy"]/*' />
        protected RealProxy(Type classToProxy) : this(classToProxy, (IntPtr)0, null)
        {
        }

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.RealProxy1"]/*' />        
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected RealProxy(Type classToProxy, IntPtr stub, Object stubData)
        {
            if(!classToProxy.IsMarshalByRef && !classToProxy.IsInterface)
            {
                throw new ArgumentException(
                    Environment.GetResourceString("Remoting_Proxy_ProxyTypeIsNotMBR"));
            }

            if((IntPtr)0 == stub)
            {
                BCLDebug.Assert((IntPtr)0 != _defaultStub, "Default stub not set up");

                // The default stub checks for match of contexts defined by us
                stub = _defaultStub;
                // Start with a value of -1 because 0 is reserved for the default context
                stubData = _defaultStubData;   
            }

            _tp = null;
            if (stubData == null)
            {
                throw new ArgumentNullException("stubdata");
            }
            _tp = RemotingServices.CreateTransparentProxy(this, classToProxy, stub, stubData);
            RemotingProxy rp = this as RemotingProxy;
            if (rp != null)
            {
                _flags |= RealProxyFlags.RemotingProxy;
            }
        }

        // This is used (along the frequent path) of Invoke to avoid
        // casting to RemotingProxy
        internal bool IsRemotingProxy()
        {
            return (_flags & RealProxyFlags.RemotingProxy) == RealProxyFlags.RemotingProxy;
        }

        // This is mainly used for RemotingProxy case. It may be worthwhile
        // to make this virtual so extensible proxies can make use of this 
        // (and other flags) as well.
        internal bool Initialized
        {

            get { return (_flags & RealProxyFlags.Initialized) == RealProxyFlags.Initialized; }
            set 
            { 
                if (value)
                {
                    _flags |= RealProxyFlags.Initialized;
                }
                else
                {
                    _flags &= ~RealProxyFlags.Initialized;
                }
            }
        }
        
        // Method to initialize the server object for x-context scenarios
        // in an extensible way
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.InitializeServerObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg)
        {
            IConstructionReturnMessage retMsg = null;

            if (_serverObject == null)
            {
                Type svrType = GetProxiedType();
                if((ctorMsg != null) && (ctorMsg.ActivationType != svrType))
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString("Remoting_Proxy_BadTypeForActivation"), 
                                                          svrType.FullName,
                                                          ctorMsg.ActivationType));
                }

                // Create a blank object
                _serverObject = RemotingServices.AllocateUninitializedObject(svrType);

                // If the stub is the default stub, then set the server context 
                // to be the current context.
                SetContextForDefaultStub();

                // OK... we are all set to run the constructor call on the uninitialized object
                MarshalByRefObject proxy = (MarshalByRefObject)GetTransparentProxy();
                IMethodReturnMessage  msg = null;
                Exception e = null;
                if(null != ctorMsg)
                {
                    msg = RemotingServices.ExecuteMessage(proxy, ctorMsg);
                    e = msg.Exception;
                }
                else
                {
                    try
                    {
                        RemotingServices.CallDefaultCtor(proxy);
                    }
                    catch(Exception excep)
                    {
                        e = excep;
                    }
                }
                                 
                // Construct a return message
                if(null == e)
                {
                    Object[] outArgs = (msg == null ? null : msg.OutArgs);
                    int outLength = (null == outArgs ? 0 : outArgs.Length);
                    LogicalCallContext callCtx = (msg == null ? null : msg.LogicalCallContext);
                    retMsg = new ConstructorReturnMessage(proxy, 
                                                          outArgs, outLength,
                                                          callCtx, ctorMsg);                    

                    // setup identity
                    SetupIdentity();
                    if (IsRemotingProxy())
                    {
                        ((RemotingProxy) this).Initialized = true;
                    }
                }
                else
                {
                    // Exception occurred
                    retMsg = new ConstructorReturnMessage(e, ctorMsg);
                }
            }          
    
            
            return retMsg;
        }

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetServer"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected MarshalByRefObject GetUnwrappedServer()
        {
            return UnwrappedServerObject;
        }

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.DisconnectServer"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected MarshalByRefObject DetachServer()
        {
            MarshalByRefObject server = _serverObject;
            _serverObject = null;
            server.__ResetServerIdentity();
            return server;
        }
        
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.ReconnectServer"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected void AttachServer(MarshalByRefObject s)
        {
            AttachServerHelper(s);
        }

        private void SetupIdentity()
        {
            if (_identity == null)
            {
                _identity = IdentityHolder.FindOrCreateServerIdentity(
                                (MarshalByRefObject)_serverObject,
                                null,
                                IdOps.None);
                // Set the reference to the proxy in the identity object
                  ((Identity)_identity).RaceSetTransparentProxy(GetTransparentProxy());
            }
        }

        private void SetContextForDefaultStub()
        {
            // Check whether the stub is ours or not...
            if(GetStub() == _defaultStub)
            {
                // Yes.. setup the context in the TP so that 
                // contexts can be matched correctly...
                Object oVal = GetStubData(this);
                if(oVal is Int32)
                {
                    Int32 iVal = (Int32)oVal;

                    // Set the stub data only if it has been set to our default value,
                    // otherwise, the user has already indicated a preference for the
                    // stub data.
                    if(iVal.Equals(_defaultStubValue))
                    {
                        SetStubData(this, Thread.CurrentContext.InternalContextID);
                    }                
                }
            }
        }
        
        
        // Check whether the current context is the same as the
        // server context
        internal bool DoContextsMatch()
        {
            bool fMatch = false;

            // Check whether the stub is ours or not...
            if(GetStub() == _defaultStub)
            {
                // Yes.. setup the context in the TP so that 
                // contexts can be matched correctly...
                Object oVal = GetStubData(this);
                if(oVal is Int32)
                {
                    Int32 iVal = (Int32)oVal;
                    // Match the internal context ids...                     
                    if(iVal.Equals(Thread.CurrentContext.InternalContextID))
                    {
                        fMatch = true;
                    }
                }
            }

            return fMatch;
        }

        // This is directly called by RemotingServices::Wrap() when it needs
        // to bind a proxy with an uninitialized contextBound server object
        internal void AttachServerHelper(MarshalByRefObject s)
        {
            if (s == null || _serverObject != null)
            {
                throw new ArgumentException("s");
            }
            _serverObject = s;   
            // setup identity
            SetupIdentity();            
        }

        // Gets the stub pointer stashed away in the transparent proxy.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr GetStub();

        // Sets the stub data
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.SetStubData"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static extern void SetStubData(RealProxy rp, Object stubData);

        // Gets the stub data
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetStubData"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Object GetStubData(RealProxy rp);

        // Gets the default stub implemented by us
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern IntPtr GetDefaultStub();
        
        
        // Accessor to obtain the type being proxied
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetProxiedType"]/*' />        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Type GetProxiedType();

        // Method to which transparent proxy delegates when
        // it gets called
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.Invoke"]/*' />
        public abstract IMessage Invoke(IMessage msg);

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.CreateObjRef"]/*' />
        public virtual ObjRef CreateObjRef(Type requestedType)
        {
            if(_identity == null)
            {
                throw new RemotingException(Environment.GetResourceString(
                    "Remoting_NoIdentityEntry"));
            }        
            
            return new ObjRef((MarshalByRefObject)GetTransparentProxy(), requestedType);    
        }
            
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetObjectData"]/*' />
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            Object obj = GetTransparentProxy();
            RemotingServices.GetObjectData(obj, info, context);            
        }

        private static void HandleReturnMessage(IMessage reqMsg, IMessage retMsg)
        {
            IMethodReturnMessage mrm = retMsg as IMethodReturnMessage;
            if (retMsg==null || (mrm == null))
            {
                throw new RemotingException(Environment.GetResourceString(
                        "Remoting_Message_BadType"));                    
            }

            Exception e = mrm.Exception;

            if (e != null)
            {
                throw e.PrepForRemoting();
            }
            else
            {
                if (!(retMsg is StackBasedReturnMessage))
                {
                    if (reqMsg is Message)
                    {
                        PropagateOutParameters(reqMsg, mrm.Args, mrm.ReturnValue);
                    }
                    else if (reqMsg is ConstructorCallMessage)
                    {
                        // NOTE: We do not extract the return value as 
                        // the process of returning a value from a ConstructorCallMessage
                        // results in marshaling.
                        PropagateOutParameters(reqMsg, mrm.Args, null);
                    }
                }
            }  
        }
        
        // Propagate the out parameters to the stack. This should be called once
        // the call has finished. The input message parameter should be the same
        // as the one which was passed to the first sink to start the call.
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.PropagateOutParameters"]/*' />
        internal static void PropagateOutParameters(IMessage msg, 
                                                    Object[] outArgs, 
                                                    Object returnValue)
        {        
            // Check for method call
            Message m = msg as Message;

            // Check for constructor call
            if(null == m)
            {
                ConstructorCallMessage ccm = msg as ConstructorCallMessage;
                if(null != ccm)
                {
                    m = ccm.GetMessage();
                }
            }

            if(null == m)
            {
                throw new ArgumentException(
                    Environment.GetResourceString("Remoting_Proxy_ExpectedOriginalMessage"));
            }

            MethodBase mb = m.GetMethodBase();
            RemotingMethodCachedData cache = 
                    InternalRemotingServices.GetReflectionCachedData(mb);
            if (outArgs != null && outArgs.Length > 0)
            {
                Object[] args = m.Args; // original arguments           

                // If a byref parameter is marked only with [In], we need to copy the 
                //   original value from the request message into outargs, so that the
                //   value won't be bashed by CMessage::PropagateOutParameters below.
                ParameterInfo[] parameters = cache.Parameters;
                foreach (int index in cache.MarshalRequestArgMap)
                {
                    ParameterInfo param = parameters[index];
                    if (param.IsIn && param.ParameterType.IsByRef)
                    {
                        if (!param.IsOut)
                            outArgs[index] = args[index];
                    }
                }

                // copy non-byref arrays back into the same instance
                if (cache.NonRefOutArgMap.Length > 0)
                {
                    foreach (int index in cache.NonRefOutArgMap)
                    {
                        Array arg = args[index] as Array;
                        if (arg != null)
                        {
                            Array.Copy((Array)outArgs[index], arg, arg.Length);
                        }
                    }                    
                }

                // validate by-ref args (This must be done last)
                int[] outRefArgMap = cache.OutRefArgMap;
                if (outRefArgMap.Length > 0)
                {
                    foreach (int index in outRefArgMap)
                    {
                        ValidateReturnArg(outArgs[index], parameters[index].ParameterType);
                    }                    
                }                                
            } 

            // validate return value
            //   (We don't validate Message.BeginAsync because the return value
            //    is always an IAsyncResult and the method base is the one that
            //    represents the underlying synchronous method).
            int callType = m.GetCallType();

            if ((callType & Message.CallMask ) != Message.BeginAsync )
            {
                Type returnType = cache.ReturnType;
                if (returnType != null)
                {
                    ValidateReturnArg(returnValue, returnType);
                }
            }

            m.PropagateOutParameters(outArgs, returnValue);
        } // PropagateOutParameters

        private static void ValidateReturnArg(Object arg, Type paramType)
        {                       
            if (paramType.IsByRef)
                paramType = paramType.GetElementType();

            if (paramType.IsValueType)
            {
                if (arg == null)
                {
                    throw new RemotingException(
                        Environment.GetResourceString("Remoting_Proxy_ReturnValueTypeCannotBeNull"));
                }
                
                if (!paramType.IsInstanceOfType(arg))
                {
                    throw new InvalidCastException(
                        Environment.GetResourceString("Remoting_Proxy_BadReturnType"));
                }
            }
            else
            {
                if (arg != null)
                {
                    if (!paramType.IsInstanceOfType(arg))
                    {
                        throw new InvalidCastException(
                            Environment.GetResourceString("Remoting_Proxy_BadReturnType"));
                    }
                }
            }
        } // ValidateReturnArg
        

        // This is shared code path that executes when an EndInvoke is called 
        // either on a delegate on a proxy 
        // OR a regular delegate (called asynchronously).
        internal static IMessage EndInvokeHelper(Message reqMsg, bool bProxyCase)
        {
            AsyncResult ar = reqMsg.GetAsyncResult() as AsyncResult;
            IMessage retMsg = null; // used for proxy case only!
            if (ar == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Message_BadAsyncResult"));                    
            }
            if (ar.AsyncDelegate != reqMsg.GetThisPtr())
            {
                throw new InvalidOperationException(Environment.GetResourceString(
                        "InvalidOperation_MismatchedAsyncResult"));
            }
            if (!ar.IsCompleted)
            {
                // Note: using ThreadPoolAware to detect if this is a 
                // ThreadAffinity or Synchronization context.
                ar.AsyncWaitHandle.WaitOne(
                        Int32.MaxValue,
                        Thread.CurrentContext.IsThreadPoolAware);
            }

            lock (ar)
            {
                if (ar.EndInvokeCalled)
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_EndInvokeCalledMultiple"));

                ar.EndInvokeCalled = true;
            

                IMethodReturnMessage mrm =  
                    (IMethodReturnMessage) ar.GetReplyMessage();

                BCLDebug.Assert(
                    mrm != null, 
                    "Reply sink should ensure we have a reply message before signalling");

                // For the proxy case this is handled by RealProxy
                if (!bProxyCase)
                {
                    Exception e = mrm.Exception;

                    if (e != null)
                    {
                        // throw e;
                        throw e.PrepForRemoting();
                    }
                    else
                    {
                        reqMsg.PropagateOutParameters(
                            mrm.Args, 
                            mrm.ReturnValue);

                    }
                }
                else
                {
                    retMsg = mrm;
                }
                // Merge the call context back into the thread that 
                // called EndInvoke
                CallContext.GetLogicalCallContext().Merge(
                    mrm.LogicalCallContext);
            }
            // Will be non-null only for proxy case!
            return retMsg;
        } // EndInvokeHelper

        // itnerop methods
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetCOMIUnknown"]/*' />
        public virtual IntPtr GetCOMIUnknown(bool fIsMarshalled)
        {
            // sub -class should override
            return MarshalByRefObject.GetComIUnknown((MarshalByRefObject)GetTransparentProxy());
        }
        
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.SetCOMIUnknown"]/*' />
        public virtual void SetCOMIUnknown(IntPtr i)
        {
            // don't care
        }

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.SupportsInterface"]/*' />
        public virtual IntPtr SupportsInterface(ref Guid iid)
        {
            return IntPtr.Zero;
        }

        // Method used for traversing back to the TP
        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.GetTransparentProxy"]/*' />
        public virtual Object GetTransparentProxy()
        {
            return _tp;
        }

        internal MarshalByRefObject UnwrappedServerObject
        {
            get { return (MarshalByRefObject) _serverObject; }
        }

        internal virtual Identity IdentityObject
        {
            get
            {
                return (Identity) _identity;
            }

            set
            {
                _identity = value;
            }
        }

        // Private method invoked by the transparent proxy
        private void PrivateInvoke(ref MessageData msgData, int type)
        {
            IMessage reqMsg = null;
            CallType callType = (CallType)type;
            IMessage retMsg = null;
            int msgFlags = -1;

            // Used only for Construction case
            RemotingProxy rp = null;

            
            // Create a message object based on the type of call
            if(CallType.MethodCall == callType)
            {
                Message msg = new Message();
                msg.InitFields(msgData);
                reqMsg = msg;
                msgFlags = msg.GetCallType();
            }
            else if (CallType.ConstructorCall == (CallType)callType)
            {
                // We use msgFlags to handle CallContext around 
                // the virtual call to Invoke()
                msgFlags = Message.Sync;
                
                rp = this as RemotingProxy;
                ConstructorCallMessage ctorMsg = null;
                bool bIsWellKnown = false;
                if(!IsRemotingProxy())
                {
                    // Create a new constructor call message
                    // FUTURE: We should have a means to pass call-site
                    // attributes to extensible proxies during activation
                    ctorMsg = new ConstructorCallMessage(null, null, null, GetProxiedType());                    
                }                                
                else
                {
                    // Extract the constructor message set in the first step of activation.
                    ctorMsg = rp.ConstructorMessage;                                         
                    // If the proxy is a wellknown client proxy, we don't 
                    // need to run the c'tor.
                    Identity id = rp.IdentityObject;
                    if (id != null)
                        bIsWellKnown = id.IsWellKnown();
                }

                if ((null == ctorMsg) || bIsWellKnown)
                {
                    // This is also used to short-circuit the activation path
                    // when we have a well known proxy that has already been
                    // initialized (there's a race condition if we don't do this).
                    //      
                
                    // This is a special case, where we have a remoting proxy
                    // but the constructormessage hasn't been setup.
                    // so let us just bail out.. 
                    // this is currently used by ServicedComponent's for cross 
                    // appdomain pooling: rajak
                    //

                    ctorMsg = new ConstructorCallMessage(null, null, null, GetProxiedType());                    
                    // Set the constructor frame info in the CCM
                    ctorMsg.SetFrame(msgData); 
                    reqMsg = ctorMsg;

                    // If this was the default ctor, check that default .ctor was called.
                    if (bIsWellKnown)
                    {
                        BCLDebug.Assert(rp!=null, "RemotingProxy expected here!");
                        // Clear any cached ctorMsg on the RemotingProxy
                        rp.ConstructorMessage = null;               

                        // We did execute a Connect. Throw if the client
                        // code is also trying to use a non-default constructor 
                        // at the same time.
                        if (ctorMsg.ArgCount != 0)
                        {
                            throw new RemotingException(
                                Environment.GetResourceString(
                                    "Remoting_Activation_WellKnownCTOR"));
                        }
                    }
                    
                    // Create a constructor return message
                    retMsg = 
                        new ConstructorReturnMessage((MarshalByRefObject)GetTransparentProxy(), 
                            null, 
                            0, 
                            null, 
                            ctorMsg);
                }
                else
                {                
                    // Set the constructor frame info in the CCM
                    ctorMsg.SetFrame(msgData);
                    reqMsg = ctorMsg;
                }
            }
            else
            {
                BCLDebug.Assert(false, "Unknown call type");
            }

            // Make sure that outgoing remote calls are counted.
            ChannelServices.IncrementRemoteCalls();

            // For non-remoting proxies, EndAsync should not call Invoke()
            // because the proxy cannot support Async and the call has already
            // finished executing in BeginAsync
            if (!IsRemotingProxy() 
                && ((msgFlags&Message.EndAsync)==Message.EndAsync))
            {

                Message msg = reqMsg as Message;
                retMsg = EndInvokeHelper(msg, true);
                BCLDebug.Assert(null != retMsg, "null != retMsg");
            }


            // Invoke
            BCLDebug.Assert(null != reqMsg, "null != reqMsg");
            if (null == retMsg)
            {
                // NOTE: there are cases where we setup a return message 
                // and we don't want the activation call to go through
                // refer to the note above for ServicedComponents and Cross Appdomain
                // pooling

                LogicalCallContext cctx = null;
                Thread currentThread = Thread.CurrentThread;
                // Pick up or clone the call context from the thread 
                // and install it in the reqMsg as appropriate
                cctx = currentThread.GetLogicalCallContext();   
                SetCallContextInMessage(reqMsg, msgFlags, cctx);
                
                // Add the outgoing "Header"'s to the message.
                cctx.PropagateOutgoingHeadersToMessage(reqMsg);
                
                retMsg = Invoke(reqMsg);

                // Get the call context returned and set it on the thread
                ReturnCallContextToThread(currentThread, retMsg, msgFlags, cctx);

                // Pull response "Header"'s out of the message
                CallContext.GetLogicalCallContext().PropagateIncomingHeadersToCallContext(retMsg);
            }

            if (!IsRemotingProxy()
                && ((msgFlags&Message.BeginAsync) == Message.BeginAsync))
            {

                // This was a begin-async on a non-Remoting Proxy. For V-1 they 
                // cannot support Async and end up doing a Sync call. We need 
                // to fill up here to make the call look like async to 
                // the caller. 
                // Create the async result to return
                Message msg = reqMsg as Message;
                AsyncResult ar = new AsyncResult(msg);
                // Tell the async result that the call has actually completed 
                // so it can hold on to the return message.
                ar.SyncProcessMessage(retMsg);       
                // create a returnMessage to propagate just the asyncResult back
                // to the caller's stack.
                retMsg = new ReturnMessage(ar, null, 0, null/*cctx*/, msg);
            }
            
            // Propagate out parameters
            HandleReturnMessage(reqMsg, retMsg);

            // For constructor calls do some extra bookkeeping
            if(CallType.ConstructorCall == callType)
            {
                // NOTE: It is the responsiblity of the callee to propagate
                // the out parameters

                // Everything went well, we are ready to return
                // a proxy to the caller


                // Extract the return value
                MarshalByRefObject retObj = null;
                IConstructionReturnMessage ctorRetMsg = retMsg as IConstructionReturnMessage;
                if(null == ctorRetMsg)
                {
                    throw new RemotingException(
                        Environment.GetResourceString("Remoting_Proxy_BadReturnTypeForActivation"));
                }

                ConstructorReturnMessage crm = ctorRetMsg as ConstructorReturnMessage;
                if (null != crm)
                {
                    // If return message is of type ConstructorReturnMessage 
                    // this is an in-appDomain activation. So no unmarshaling
                    // needed.
                    retObj = (MarshalByRefObject)crm.GetObject();
                    if (retObj == null)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString("Remoting_Activation_NullReturnValue"));
                    }
                }
                else
                {
                    // Fetch the objRef out of the returned message and unmarshal it
                    retObj = (MarshalByRefObject)RemotingServices.InternalUnmarshal(
                                (ObjRef)ctorRetMsg.ReturnValue,
                                GetTransparentProxy(),
                                true /*fRefine*/);

                    if (retObj == null)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString("Remoting_Activation_NullFromInternalUnmarshal"));
                    }
                }

                if (retObj != (MarshalByRefObject)GetTransparentProxy())
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Activation_InconsistentState"));
                }

                if (IsRemotingProxy())
                {
                    // Clear any cached ctorMsg on the RemotingProxy
                    rp.ConstructorMessage = null;
                }
            }
        }

        void SetCallContextInMessage(
            IMessage reqMsg, int msgFlags, LogicalCallContext cctx)
        {
            BCLDebug.Assert(msgFlags != -1, "Unexpected msgFlags?");
            Message msg = reqMsg as Message;
            
            switch (msgFlags)
            {
            case Message.Sync:
                if (msg != null)
                {
                    msg.SetLogicalCallContext(cctx);
                }
                else
                {
                    ((ConstructorCallMessage)reqMsg).SetLogicalCallContext(cctx);
                }
                break;
            /* FUTURE: this code is currently in RemotingProxy.. should 
            disable it there and enable this when we allow extensible proxies
            to handle Async calls etc
             
            case Message.BeginAsync:
            case Message.BeginAsync | Message.OneWay:
            case Message.OneWay:
                // All these should be of type Message
                BCLDebug.Assert(msg != null,"bad one-way/async message?");
                // Clone the callcontext (NOTE: we do not do a deep copy)
                LogicalCallContext cloneCtx = (LogicalCallContext) cctx.Clone();
                msg.SetLogicalCallContext(cloneCtx);                                
                break;
            */
            }
        }            

        void ReturnCallContextToThread(Thread currentThread, IMessage retMsg, int msgFlags, LogicalCallContext currCtx)
        {
            if (msgFlags == Message.Sync)
            {
                if (retMsg == null)
                    return;

                IMethodReturnMessage mrm = retMsg as IMethodReturnMessage;
                if (mrm == null)
                    return;                            
                            
                LogicalCallContext retCtx = mrm.LogicalCallContext;
                if (retCtx == null){
                    currentThread.SetLogicalCallContext(currCtx);
                    return;
                }
                
                if (!(mrm is StackBasedReturnMessage))
                {
                    LogicalCallContext oldCtx = currentThread.SetLogicalCallContext(retCtx);
                    if ((Object)oldCtx != (Object)retCtx)
                    {
                        // If the new call context does not match the old call context,
                        //   we must have gone remote. We need to keep the preserve
                        //   the principal from the original call context.
                        IPrincipal principal = oldCtx.Principal;
                        if (principal != null)
                            retCtx.Principal = principal;
                    }                    
                }
                //for other types (async/one-way etc) there is nothing to be 
                //done as we have just finished processing BeginInvoke or EndInvoke
            }
        }

        internal virtual void Wrap()
        {
            // FUTURE: We have to find a way to notify the real proxies
            // that a wrap occurred.
            // EXTENSIBILITY:
            // If this is a serverID, set the native context field in the TP
            ServerIdentity serverID = _identity as ServerIdentity;
            if((null != serverID) && (this is RemotingProxy))
            {
                BCLDebug.Assert(null != serverID.ServerContext, "null != serverID.ServerContext");
                SetStubData(this, serverID.ServerContext.InternalContextID);
            }
        }

        /// <include file='doc\RealProxy.uex' path='docs/doc[@for="RealProxy.RealProxy2"]/*' />
        protected RealProxy()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\message.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    Message.cs
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines the message object created by the transparent
**          proxy and used by the message sinks
**
** Date:    Feb 16, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
    using System;
    using System.Collections;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;    
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Remoting.Metadata.W3cXsd2001;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;  
    using System.Runtime.Serialization.Formatters.Binary;  
    using System.Reflection;
    using System.Text;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.Globalization;

    //+=======================================================================
    //
    // Synopsis:   Message is used to represent call and is created by the
    //             Transparent proxy
    //
    //-=======================================================================
    [Serializable()]
    internal class Message : IMethodCallMessage, IInternalMessage, ISerializable
    {

        // *** NOTE ***
        // Keep these in sync with the flags in Message.h
        // flags
        internal const int Sync = 0;        // Synchronous call
        internal const int BeginAsync = 1;  // Async Begin call
        internal const int EndAsync   = 2;  // Async End call
        internal const int Ctor       = 4;  // The call is a .Ctor
        internal const int OneWay     = 8;  // One way call
        internal const int CallMask   = 15; // Mask for call type bits
        
        internal const int FixedArgs  = 16;  // Fixed number of arguments call       
        internal const int VarArgs    = 32; // Variable number of arguments call        

        // Private data members
        private IntPtr _frame;               // ptr to the call frame
        private IntPtr _methodDesc;          // ptr to the internal method descriptor
        private IntPtr _delegateMD;          // ptr to the internal method descriptor for the delegate
        private int _last;                // the index of the last argument queried
        private int _flags;               // internal flags

        private bool _initDone;           // called the native init routine
        private IntPtr _metaSigHolder;         // Pointer to the MetaSig structure


        private String _MethodName;                 // Method name
        private Type[] _MethodSignature;            // Array of parameter types
        private MethodBase _MethodBase;             // Reflection method object
        private Object  _properties;                // hash table for properities
        private String    _URI;                     // target object URI
        private Exception _Fault;                   // null if no fault

        private Identity _ID;            // identity cached during Invoke
        private ServerIdentity _srvID;   // server Identity cached during Invoke
        private LogicalCallContext _callContext;
        internal static String CallContextKey = "__CallContext";
        internal static String UriKey           = "__Uri";
        

        private ArgMapper _argMapper;
        private String _typeName;

        private static int MetaSigLen = nGetMetaSigLen();

        public virtual Exception GetFault()       {return _Fault;}
        public virtual void      SetFault(Exception e) {_Fault = e;}

        internal virtual void SetOneWay()   { _flags |= Message.OneWay;}
        public virtual int       GetCallType()
        {
            // We should call init only if neccessary
            InitIfNecessary();
            return _flags;
        }

        internal IntPtr GetFramePtr() { return _frame;}



        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void GetAsyncBeginInfo(out AsyncCallback acbd,
                                             out Object        state);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Object         GetThisPtr();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern IAsyncResult   GetAsyncResult();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void CallDelegate(Object d);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void Init();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Object GetReturnValue();
        //
        // Constructor
        // This should be internal. The message object is
        // allocated and deallocated via a pool to enable
        // reuse.
        //
        internal Message()
        {
        }

        // NOTE: This method is called multiple times as we reuse the
        // message object. Make sure that you reset any fields that you
        // add to the message object to the default values. This will
        // ensure that the reused message object starts with the correct
        // values.
        internal void InitFields(MessageData msgData)
        {
            _frame = msgData.pFrame;
            _delegateMD = msgData.pDelegateMD;
            _methodDesc = msgData.pMethodDesc;
            _last = -1;
            _flags = msgData.iFlags;
            _initDone = true;
            _metaSigHolder = msgData.pSig;

            _MethodName = null;
            _MethodSignature = null;
            _MethodBase = null;
            _URI = null;
            _Fault = null;
            _ID = null;
            _srvID = null;
            _callContext = null;

            if (_properties != null)
            {
                // A dictionary object already exists. This case occurs
                // when we reuse the message object. Just remove all the
                // entries from the dictionary object and reuse it.
                ((IDictionary)_properties).Clear();
            }
            
        }

        private void InitIfNecessary()
        {
            if (!_initDone)
            {
                // We assume that Init is an idempotent operation
                Init();
                _initDone = true;
            }
        }


        //-------------------------------------------------------------------
        //                  IInternalMessage
        //-------------------------------------------------------------------
        ServerIdentity IInternalMessage.ServerIdentityObject
        {
            get { return _srvID;}
            set {_srvID = value;}
        }

        Identity IInternalMessage.IdentityObject
        {
            get { return _ID;}
            set { _ID = value;}
        }

        void IInternalMessage.SetURI(String URI)
        {
            _URI = URI;
        }

        void IInternalMessage.SetCallContext(LogicalCallContext callContext)
        {
            _callContext = callContext;
        }

        bool IInternalMessage.HasProperties()
        {
            return _properties != null;
        }

        //-------------------------------------------------------------------
        //                           IMessage
        //-------------------------------------------------------------------
        public IDictionary Properties
        {
            get
            {
                if (_properties == null)
                {
                    Interlocked.CompareExchange(ref _properties,
                                                new MCMDictionary(this, null),
                                                null);
                }
                return (IDictionary)_properties;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public  extern RuntimeArgumentHandle GetVarArgsPtr();

        //-------------------------------------------------------------------
        //                      IMethodCallMessage
        //-------------------------------------------------------------------

        public String     Uri                
        { 
            get { return _URI;}

            set { _URI = value; }
        }
        
        public bool       HasVarArgs         
        { 
            get 
            {
                // When this method is called for the first time, we
                // obtain the answer from a native call and set the flags 
                if((0 == (_flags & Message.FixedArgs)) &&  
                    (0 == (_flags & Message.VarArgs)))
                {
                    if(!InternalHasVarArgs())
                    {
                        _flags |= Message.FixedArgs;
                    }
                    else
                    {
                        _flags |= Message.VarArgs;
                    }
                }
                return (1 == (_flags & Message.VarArgs));
            }
            
        }
        
        public int        ArgCount           
        { 
            get { return InternalGetArgCount();}
        }
        
        public Object     GetArg(int argNum) 
        { 
            return InternalGetArg(argNum);
        }
        
        public String     GetArgName(int index)
        {
            if (index >= ArgCount)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            RemotingMethodCachedData methodCache = 
                InternalRemotingServices.GetReflectionCachedData(GetMethodBase());

            ParameterInfo[] pi = methodCache.Parameters;

            if (index < pi.Length)
            {
                return pi[index].Name;
            }
            else
            {
                return "VarArg" + (index - pi.Length);
            }
        }

        public Object[]   Args
        {
            get
            {
                return InternalGetArgs();
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.InArgCount"]/*' />
        public int InArgCount                        
        { 
            get 
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, false);
                return _argMapper.ArgCount;
            }
        }

        public Object  GetInArg(int argNum)   
        {   
            if (_argMapper == null) _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.GetInArgName"]/*' />
        public String GetInArgName(int index) 
        { 
            if (_argMapper == null) _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArgName(index);
        }
        
        public Object[] InArgs                       
        {
            get
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, false);
                return _argMapper.Args;
            }
        }

        private void UpdateNames()
        {
            RemotingMethodCachedData methCache = 
                InternalRemotingServices.GetReflectionCachedData(GetMethodBase());
            _typeName = methCache.TypeAndAssemblyName;
            _MethodName = methCache.MethodName;
        }

        public String MethodName
        { 
            get 
            { 
                if(null == _MethodName)
                    UpdateNames();
                return _MethodName;
            }
        }
        
        public String TypeName
        { 
            get 
            { 
                if (_typeName == null)
                    UpdateNames();
                return _typeName;
            }
        }
        
        public Object MethodSignature
        { 
            get
            {
                if(null == _MethodSignature)
                    _MethodSignature = GenerateMethodSignature(GetMethodBase());
                    
                return _MethodSignature;
            }
        }

        public LogicalCallContext LogicalCallContext  
        { 
            get
            {                
                return GetLogicalCallContext();                 
            }
        }

        public MethodBase MethodBase
        {
            get
            {
                return GetMethodBase();
            }
        }


        //
        // ISerializable
        //
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));                
        }
        
        internal MethodBase GetMethodBase()
        {
            if(null == _MethodBase)
            {
                _MethodBase = InternalGetMethodBase();
            }           
            return _MethodBase;
        }

        internal LogicalCallContext SetLogicalCallContext(
            LogicalCallContext callCtx)
        {
            LogicalCallContext oldCtx = _callContext;
            _callContext = callCtx;
            
            return oldCtx;
        }

        internal LogicalCallContext GetLogicalCallContext()
        {
            if (_callContext == null)
                _callContext = new LogicalCallContext();
            return _callContext;
        }


        // Internal helper to create method signature
        internal static Type[] GenerateMethodSignature(MethodBase mb)
        {
            RemotingMethodCachedData methodCache = 
                InternalRemotingServices.GetReflectionCachedData(mb);
                
            ParameterInfo[] paramArray = methodCache.Parameters;
            Type[] methodSig = new Type[paramArray.Length];
            for(int i = 0; i < paramArray.Length; i++)
            {
                methodSig[i] = paramArray[i].ParameterType;
            }

            return methodSig;
        } // GenerateMethodSignature
        
        //
        // The following two routines are used by StackBuilderSink to check
        // the consistency of arguments.
        //
        // Check that all the arguments are of the type 
        // specified by the parameter list.
        //
        internal static Object[] CoerceArgs(IMethodMessage m)
        {
            MethodBase mb = m.MethodBase;
            BCLDebug.Assert(mb != null, "null method base passed to CoerceArgs");

            RemotingMethodCachedData methodCache = InternalRemotingServices.GetReflectionCachedData(mb);
            
            return CoerceArgs(m, methodCache.Parameters);
        } // CoerceArgs

        internal static Object[] CoerceArgs(IMethodMessage m, ParameterInfo[] pi)
        {
            return CoerceArgs(m.MethodBase, m.Args, pi);
        } // CoerceArgs

        internal static Object[] CoerceArgs(MethodBase mb, Object[] args, ParameterInfo[] pi)
        {
            if (pi == null) 
            {
                throw new ArgumentNullException("pi");
            }
            
            if (pi.Length != args.Length) 
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Message_ArgMismatch"),
                        mb.DeclaringType.FullName, mb.Name,
                        args.Length, pi.Length));
            }
            
            for (int i=0; i < pi.Length; i++)
            {
                ParameterInfo currentPi = pi[i];
                Type pt = currentPi.ParameterType;                    
                Object oArg = args[i];
                if (oArg != null) 
                {
                    args[i] = CoerceArg(oArg, pt);
                }
                else
                {   
                    if (pt.IsByRef)
                    {
                        Type paramType = pt.GetElementType();
                        if (paramType.IsValueType)
                        {
                            if (currentPi.IsOut)
                            {
                                // we need to fill in the blanks for value types if they are null
                                args[i] = Activator.CreateInstance(paramType, true);
                            }
                            else
                            {
                                throw new RemotingException(
                                    String.Format(
                                        Environment.GetResourceString("Remoting_Message_MissingArgValue"),
                                        paramType.FullName, i));
                            }
                        }
                    }
                    else
                    {
                        if (pt.IsValueType)
                        {
                            // A null value was passed as a value type parameter.
                            throw new RemotingException(
                                String.Format(
                                    Environment.GetResourceString("Remoting_Message_MissingArgValue"),
                                    pt.FullName, i));
                        }
                    }
                }
            }

            return args;
        } // CoerceArgs
        
        
        internal static Object CoerceArg(Object value, Type pt)
        {
            Object ret = null;
            
            if(null != value)
            {
                try
                {
                    if (pt.IsByRef) 
                    {
                        pt = pt.GetElementType();
                    }
                
                    if (pt.IsInstanceOfType(value))
                    {
                        ret = value;
                    }
                    else
                    {
                        ret = Convert.ChangeType(value, pt);
                    }
                }
                catch(Exception )
                {
                    // Quietly swallow all exceptions. We will throw
                    // a more meaningful exception below.
                }

                // If the coercion failed then throw an exception
                if(null == ret)
                {
                    // NOTE: Do not call value.ToString() on proxies as
                    // it results in loading the type and loss of refinement
                    // optimization or denial of service attacks by loading
                    // a lot of types in the server.
                    String valueName = null;
                    if(RemotingServices.IsTransparentProxy(value))
                    {
                        valueName = typeof(MarshalByRefObject).ToString();
                    }
                    else
                    {
                        valueName = value.ToString();
                    }

                    throw new RemotingException(                        
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_CoercionFailed"), valueName, pt));                
                }
            }
                
            return ret;
        } //end of CoerceArg

        internal static Object SoapCoerceArg(Object value, Type pt, Hashtable keyToNamespaceTable)
        {
            Object ret = null;

            if (value != null)
            {
                try
                {
                    if (pt.IsByRef) 
                    {
                        pt = pt.GetElementType();
                    }
                
                    if (pt.IsInstanceOfType(value))
                    {
                        ret = value;
                    }
                    else
                    {
                        String strValue = value as String;
                        if (strValue != null)
                        {
                            if (pt == typeof(Double))
                            {
                                if (strValue == "INF")
                                    ret =  Double.PositiveInfinity;
                                else if (strValue == "-INF")
                                    ret =  Double.NegativeInfinity;
                                else
                                    ret = Double.Parse(strValue, CultureInfo.InvariantCulture);
                            }
                            else if (pt == typeof(Single))
                            {
                                if (strValue == "INF")
                                    ret =  Single.PositiveInfinity;
                                else if (strValue == "-INF")
                                    ret =  Single.NegativeInfinity;
                                else
                                    ret = Single.Parse(strValue, CultureInfo.InvariantCulture);
                            }
                            else if (SoapType.typeofISoapXsd.IsAssignableFrom(pt))
                            { 
                                if (pt == SoapType.typeofSoapTime)
                                    ret = SoapTime.Parse(strValue);
                                else if (pt == SoapType.typeofSoapDate)
                                    ret = SoapDate.Parse(strValue);
                                else if (pt == SoapType.typeofSoapYearMonth)
                                    ret = SoapYearMonth.Parse(strValue);
                                else if (pt == SoapType.typeofSoapYear)
                                    ret = SoapYear.Parse(strValue);
                                else if (pt == SoapType.typeofSoapMonthDay)
                                    ret = SoapMonthDay.Parse(strValue);
                                else if (pt == SoapType.typeofSoapDay)
                                    ret = SoapDay.Parse(strValue);
                                else if (pt == SoapType.typeofSoapMonth)
                                    ret = SoapMonth.Parse(strValue);
                                else if (pt == SoapType.typeofSoapHexBinary)
                                    ret = SoapHexBinary.Parse(strValue);
                                else if (pt == SoapType.typeofSoapBase64Binary)
                                    ret = SoapBase64Binary.Parse(strValue);
                                else if (pt == SoapType.typeofSoapInteger)
                                    ret = SoapInteger.Parse(strValue);
                                else if (pt == SoapType.typeofSoapPositiveInteger)
                                    ret = SoapPositiveInteger.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNonPositiveInteger)
                                    ret = SoapNonPositiveInteger.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNonNegativeInteger)
                                    ret = SoapNonNegativeInteger.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNegativeInteger)
                                    ret = SoapNegativeInteger.Parse(strValue);
                                else if (pt == SoapType.typeofSoapAnyUri)
                                    ret = SoapAnyUri.Parse(strValue);
                                else if (pt == SoapType.typeofSoapQName)
                                {
                                    ret = SoapQName.Parse(strValue);
                                    SoapQName soapQName = (SoapQName)ret;
                                    if (soapQName.Key.Length == 0)
                                        soapQName.Namespace = (String)keyToNamespaceTable["xmlns"];
                                    else
                                        soapQName.Namespace = (String)keyToNamespaceTable["xmlns"+":"+soapQName.Key];
                                }
                                else if (pt == SoapType.typeofSoapNotation)
                                    ret = SoapNotation.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNormalizedString)
                                    ret = SoapNormalizedString.Parse(strValue);
                                else if (pt == SoapType.typeofSoapToken)
                                    ret = SoapToken.Parse(strValue);
                                else if (pt == SoapType.typeofSoapLanguage)
                                    ret = SoapLanguage.Parse(strValue);
                                else if (pt == SoapType.typeofSoapName)
                                    ret = SoapName.Parse(strValue);
                                else if (pt == SoapType.typeofSoapIdrefs)
                                    ret = SoapIdrefs.Parse(strValue);
                                else if (pt == SoapType.typeofSoapEntities)
                                    ret = SoapEntities.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNmtoken)
                                    ret = SoapNmtoken.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNmtokens)
                                    ret = SoapNmtokens.Parse(strValue);
                                else if (pt == SoapType.typeofSoapNcName)
                                    ret = SoapNcName.Parse(strValue);
                                else if (pt == SoapType.typeofSoapId)
                                    ret = SoapId.Parse(strValue);
                                else if (pt == SoapType.typeofSoapIdref)
                                    ret = SoapIdref.Parse(strValue);
                                else if (pt == SoapType.typeofSoapEntity)
                                    ret = SoapEntity.Parse(strValue);
                            }
                            else if (pt == typeof(Boolean))
                            {
                                if (strValue == "1" || strValue == "true")
                                    ret = (bool)true;
                                else if (strValue == "0" || strValue =="false")
                                    ret = (bool)false;
                                else
                                {
                                    throw new RemotingException(                        
                                        String.Format(
                                            Environment.GetResourceString(
                                                "Remoting_Message_CoercionFailed"), strValue, pt));                
                                }
                            }
                            else if (pt == typeof(DateTime))
                                ret = SoapDateTime.Parse(strValue);
                            else if (pt.IsPrimitive)
                                ret = Convert.ChangeType(value, pt);
                            else if (pt == typeof(TimeSpan))
                                ret = SoapDuration.Parse(strValue);
                            else if (pt == typeof(Char))
                                ret = strValue[0];

                            else
                                ret = Convert.ChangeType(value, pt); //Should this just throw an exception
                        }
                        else
                            ret = Convert.ChangeType(value, pt);
                    }
                }
                catch(Exception )
                {
                    // Quietly swallow all exceptions. We will throw
                    // a more meaningful exception below.
                }

                // If the coercion failed then throw an exception
                if(null == ret)
                {
                    // NOTE: Do not call value.ToString() on proxies as
                    // it results in loading the type and loss of refinement
                    // optimization or denial of service attacks by loading
                    // a lot of types in the server.
                    String valueName = null;
                    if(RemotingServices.IsTransparentProxy(value))
                    {
                        valueName = typeof(MarshalByRefObject).ToString();
                    }
                    else
                    {
                        valueName = value.ToString();
                    }

                    throw new RemotingException(                        
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_CoercionFailed"), valueName, pt));                
                }
            }
                
            return ret;
        }//end of SoapCoerceArg

                
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool InternalHasVarArgs();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetArgCount();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object    InternalGetArg(int argNum);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object[]    InternalGetArgs();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodBase InternalGetMethodBase();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void PropagateOutParameters(Object[] OutArgs, Object retVal);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String InternalGetMethodName(MethodBase mb, ref String TypeNAssemblyName);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool   Dispatch(Object target, bool fExecuteInContext);

        //
        // TEMP: DebugOut and Break until the classlibs have one
        //
        [System.Diagnostics.Conditional("_REMOTING_DEBUG")]
        public static void DebugOut(String s)
        {
            BCLDebug.Trace(
                "REMOTE", "RMTING: Thrd " 
                + Thread.CurrentThread.GetHashCode() 
                + " : " + s);
            OutToUnmanagedDebugger(
                "\nRMTING: Thrd "
                + Thread.CurrentThread.GetHashCode() 
                + " : " + s);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static void OutToUnmanagedDebugger(String s);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static int nGetMetaSigLen();

        internal static LogicalCallContext PropagateCallContextFromMessageToThread(IMessage msg)
        {
            return CallContext.SetLogicalCallContext(
                    (LogicalCallContext) msg.Properties[Message.CallContextKey]);            
        }

        internal static void PropagateCallContextFromThreadToMessage(IMessage msg)
        {
            LogicalCallContext callCtx = CallContext.GetLogicalCallContext();
            
            msg.Properties[Message.CallContextKey] = callCtx;
        }

        internal static void PropagateCallContextFromThreadToMessage(IMessage msg, LogicalCallContext oldcctx)
        {
            // First do the common work
            PropagateCallContextFromThreadToMessage(msg);

            // restore the old call context on the thread
            CallContext.SetLogicalCallContext(oldcctx);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static void MethodAccessCheck(MethodBase method, ref StackCrawlMark stackMark);
    }

    //+================================================================================
    //
    // Synopsis:   Return message for constructors
    //
    //-================================================================================
    internal class ConstructorReturnMessage : ReturnMessage, IConstructionReturnMessage
    {

        private const int Intercept = 0x1;

        private MarshalByRefObject _o;
        private int    _iFlags;


        public ConstructorReturnMessage(MarshalByRefObject o, Object[] outArgs, int outArgsCount,
                                        LogicalCallContext callCtx, IConstructionCallMessage ccm)
        : base(o, outArgs, outArgsCount, callCtx, ccm)
        {
            _o = o;
            _iFlags = Intercept;
        }

        public ConstructorReturnMessage(Exception e, IConstructionCallMessage ccm)
        :       base(e, ccm)
        {
        }

        public override  Object  ReturnValue
        {
            get
            {
                if (_iFlags == Intercept)
                {
                    return RemotingServices.MarshalInternal(_o,null,null);
                }
                else
                {
                    return base.ReturnValue;
                }
            }
        }


        public override  IDictionary Properties
        {
            get
            {
                if (_properties == null)
                {
                    Object properties = new CRMDictionary(this, new Hashtable());
                    Interlocked.CompareExchange(ref _properties, properties, null);
                }
                return(IDictionary) _properties;
            }
        }

        internal Object GetObject()
        {
            return _o;
        }
    }

    //+========================================================================
    //
    // Synopsis:  client side implementation of activation message
    //
    //-========================================================================
    internal class ConstructorCallMessage : IConstructionCallMessage
    {

        // data

        private Object[]            _callSiteActivationAttributes;
        private Object[]            _womGlobalAttributes;
        private Object[]            _typeAttributes;

        // The activation type isn't serialized because we want to 
        // re-resolve the activation type name on the other side
        // based on _activationTypeName.
        [NonSerialized()]
        private Type                _activationType;
        
        private String              _activationTypeName;
        
        private IList               _contextProperties;
        private int                 _iFlags;
        private Message             _message;
        private Object              _properties;
        private ArgMapper           _argMapper; 
        private IActivator          _activator;
        
        // flags
        private const int CCM_ACTIVATEINCONTEXT = 0x01;

        private ConstructorCallMessage()
        {
            // Default constructor
        }

        internal ConstructorCallMessage(Object[] callSiteActivationAttributes,
                    Object[]womAttr, Object[] typeAttr, Type serverType)
        {
            _activationType = serverType;
            _activationTypeName = RemotingServices.GetDefaultQualifiedTypeName(_activationType);
            _callSiteActivationAttributes = callSiteActivationAttributes;
            _womGlobalAttributes = womAttr;
            _typeAttributes = typeAttr;
        }

        public Object GetThisPtr()
        {
            if (_message != null)
            {
                return _message.GetThisPtr();
            }
            else
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
        }

        public Object[] CallSiteActivationAttributes
        {
            get
            {
                return _callSiteActivationAttributes;
            }

        }

        internal Object[] GetWOMAttributes()
        {
            return _womGlobalAttributes;
        }

        internal Object[] GetTypeAttributes()
        {
            return _typeAttributes;
        }

        public Type ActivationType
        {
            get
            {
                if ((_activationType == null) && (_activationTypeName != null))
                    _activationType = RemotingServices.InternalGetTypeFromQualifiedTypeName(_activationTypeName, false);
                    
                return _activationType;
            }
        }

        public String ActivationTypeName
        {
            get
            {
                return _activationTypeName;
            }
        }

        public IList ContextProperties
        {
            get
            {
                if (_contextProperties == null)
                {
                    _contextProperties = new ArrayList();
                }
                return _contextProperties;
            }
        }

        public String Uri
        {
            get
            {
                if (_message != null)
                {
                    return _message.Uri;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }

            set
            {
                if (_message != null)
                {
                    _message.Uri = value;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }

        }

        public String MethodName
        {
            get
            {
                if (_message != null)
                {
                    return _message.MethodName;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        }

        public String TypeName
        {
            get
            {
                if (_message != null)
                {
                    return _message.TypeName;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        }

        public Object MethodSignature
        {
            get
            {
                if (_message != null)
                {
                    return _message.MethodSignature;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        } // MethodSignature

        public MethodBase MethodBase
        {
            get
            {
                if (_message != null)
                {
                    return _message.MethodBase;
        }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        } // MethodBase


        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructorCallMessage.InArgCount"]/*' />
	/// <internalonly/>
        public int InArgCount                        
        { 
            get 
            {
                if (_argMapper == null) 
                    _argMapper = new ArgMapper(this, false);
                return _argMapper.ArgCount;
            }
        }

        public Object  GetInArg(int argNum)   
        {   
            if (_argMapper == null) 
                _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructorCallMessage.GetInArgName"]/*' />
	/// <internalonly/>
        public String GetInArgName(int index) 
        { 
            if (_argMapper == null) 
                _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArgName(index);
        }
        public Object[] InArgs                       
        {
            get
            {
                if (_argMapper == null) 
                    _argMapper = new ArgMapper(this, false);
                return _argMapper.Args;
            }
        }
    
        public int ArgCount
        {
            get
            {
                if (_message != null)
                {
                    return _message.ArgCount;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        }

        public Object GetArg(int argNum)
        {
            if (_message != null)
            {
                return _message.GetArg(argNum);
            }
            else
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
        }

        public String GetArgName(int index)
        {
            if (_message != null)
            {
                return _message.GetArgName(index);
            }
            else
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
        }

        public bool HasVarArgs
        {
            get
            {
                if (_message != null)
                {
                    return _message.HasVarArgs;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        }

        public Object[] Args
        {
            get
            {
                if (_message != null)
                {
                    return _message.Args;
                }
                else
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
            }
        }

        public IDictionary Properties
        {
            get
            {
                if (_properties == null)
                {
                    Object properties = new CCMDictionary(this, new Hashtable());
                    Interlocked.CompareExchange(ref _properties, properties, null);
                }
                return(IDictionary) _properties;
            }
        }

        public IActivator Activator
        {
            get { return _activator; }
            set { _activator =  value; }
        }

        public LogicalCallContext LogicalCallContext  
        { 
            get
            {
                return GetLogicalCallContext();                 
            }
        }
        

        internal bool ActivateInContext
        {
            get { return((_iFlags & CCM_ACTIVATEINCONTEXT) != 0);}
            set { _iFlags = value ? (_iFlags | CCM_ACTIVATEINCONTEXT) : (_iFlags & ~CCM_ACTIVATEINCONTEXT);}
        }

        internal void SetFrame(MessageData msgData)
        {
            BCLDebug.Assert(_message == null, "Can't set frame twice on ConstructorCallMessage");
            _message = new Message();
            _message.InitFields(msgData);
        }

        internal LogicalCallContext GetLogicalCallContext()
        {
            if (_message != null)
            {
                return _message.GetLogicalCallContext();
            }
            else
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
        }

        internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx)
        {
            if (_message != null)
            {
                return _message.SetLogicalCallContext(ctx);
            }
            else
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }

        }

		internal Message GetMessage()
		{
			return _message;
		}
    }

    //+========================================================================
    //
    // Synopsis:   Specialization of MessageDictionary for
    //             ConstructorCallMessage objects
    //
    //-========================================================================

    internal class CCMDictionary : MessageDictionary
    {
        public static String[] CCMkeys = {
            "__Uri",                //0
            "__MethodName",         //1
            "__MethodSignature",    //2
            "__TypeName",           //3
            "__Args",               //4
            "__CallContext",        //5
            "__CallSiteActivationAttributes",   //6
            "__ActivationType",         //7
            "__ContextProperties",  //8
            "__Activator",          //9
            "__ActivationTypeName"};         //10

        internal IConstructionCallMessage _ccmsg;           // back pointer to message object


        public CCMDictionary(IConstructionCallMessage msg, IDictionary idict)
        : base(CCMkeys, idict)
        {
            _ccmsg = msg;
        }

        internal override Object GetMessageValue(int i)
        {
            switch (i)
            {
            case 0:
                return _ccmsg.Uri;
            case 1:
                return _ccmsg.MethodName;
            case 2:
                return _ccmsg.MethodSignature;
            case 3:
                return _ccmsg.TypeName;
            case 4:
                return _ccmsg.Args;
            case 5:
                return FetchLogicalCallContext();
            case 6:
                return _ccmsg.CallSiteActivationAttributes;
            case 7:
                // This it to keep us from serializing the requested server type
                return null;
            case 8:
                return _ccmsg.ContextProperties;
            case 9:
                return _ccmsg.Activator;
            case 10:
                return _ccmsg.ActivationTypeName;
            }
            // We should not get here!
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));                    
        }

        private LogicalCallContext FetchLogicalCallContext()
        {
            ConstructorCallMessage ccm = _ccmsg as ConstructorCallMessage;
            if (null != ccm)
            {
                return ccm.GetLogicalCallContext();
            }
            else if (_ccmsg is ConstructionCall)
            {
                // This is the case where the message got serialized
                // and deserialized
                return((MethodCall)_ccmsg).GetLogicalCallContext();
            }
            else
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Message_BadType"));                    
            }
        }

        internal override void SetSpecialKey(int keyNum, Object value)
        {
            switch (keyNum)
            {
            case 0:
                ((ConstructorCallMessage)_ccmsg).Uri = (String)value;
                break;
            case 1:
                ((ConstructorCallMessage)_ccmsg).SetLogicalCallContext(
                      (LogicalCallContext)value);
                break;
            default:
                // We should not get here!
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }
        }
    }


    //+========================================================================
    //
    // Synopsis:   Specialization of MessageDictionary for ConstructorCallMessage objects
    //
    //-========================================================================

    internal class CRMDictionary : MessageDictionary
    {
        public static String[]  CRMkeysFault = {
            "__Uri",
            "__MethodName",
            "__MethodSignature",
            "__TypeName",
            "__CallContext"};
        public static String[]  CRMkeysNoFault =  {
            "__Uri",
            "__MethodName",
            "__MethodSignature",
            "__TypeName",
            "__Return",
            "__OutArgs",            
            "__CallContext"};
        internal IConstructionReturnMessage _crmsg;
        internal bool fault;

        public CRMDictionary(IConstructionReturnMessage msg, IDictionary idict)
        : base( (msg.Exception!=null)? CRMkeysFault : CRMkeysNoFault, idict)
        {
            fault = (msg.Exception != null) ;
            _crmsg = msg;
        }

        internal override Object GetMessageValue(int i)
        {
            switch (i)
            {
            case 0:
                return _crmsg.Uri;
            case 1:
                return _crmsg.MethodName;
            case 2:
                return _crmsg.MethodSignature;
            case 3:
                return _crmsg.TypeName;
            case 4:
                return fault ? FetchLogicalCallContext() : _crmsg.ReturnValue;
            case 5:
                return _crmsg.Args;
            case 6:
                return FetchLogicalCallContext();
            }
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));                    
        }

        private LogicalCallContext FetchLogicalCallContext()
        {
            ReturnMessage retMsg = _crmsg as ReturnMessage;
            if (null != retMsg)
            {
                return retMsg.GetLogicalCallContext();
            }
            else 
            {
                MethodResponse mr = _crmsg as MethodResponse;
                if (null != mr)
                {
                    return mr.GetLogicalCallContext();
                }
                else
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadType"));                    
                }
            }
        }

        internal override void SetSpecialKey(int keyNum, Object value)
        {
            // NOTE: we use this for Uri & CallContext only ...

            ReturnMessage rm = _crmsg as ReturnMessage;
            MethodResponse mr = _crmsg as MethodResponse;
            switch(keyNum)
            {
            case 0:
                if (null != rm)
                {
                    rm.Uri = (String)value;
                }
                else 
                {
                    
                    if (null != mr)
                    {
                        mr.Uri = (String)value;
                    }
                    else
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Message_BadType"));                    
                    }                        
                }
                break;
            case 1:
                if (null != rm)
                {
                    rm.SetLogicalCallContext((LogicalCallContext)value);
                }
                else 
                {
                    
                    if (null != mr)
                {
                        mr.SetLogicalCallContext((LogicalCallContext)value);
                }
                else
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadType"));                    
                }
                }
                break;
            default:
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }
        }
    }

    //+================================================================================
    //
    // Synopsis:   Specialization of MessageDictionary for MethodCallMessage
    //
    //-========================================================================

    internal class MCMDictionary : MessageDictionary
    {
        public static String[] MCMkeys = {
            "__Uri",
            "__MethodName",
            "__MethodSignature",
            "__TypeName",
            "__Args",
            "__CallContext"};

        internal IMethodCallMessage _mcmsg;           // back pointer to message object


        public MCMDictionary(IMethodCallMessage msg, IDictionary idict)
        : base(MCMkeys, idict)
        {
            _mcmsg = msg;
        }

        internal override Object GetMessageValue(int i)
        {
            switch (i)
            {
            case 0:
                return _mcmsg.Uri;
            case 1:
                return _mcmsg.MethodName;
            case 2:
                return _mcmsg.MethodSignature;
            case 3:
                return _mcmsg.TypeName;
            case 4:
                return _mcmsg.Args;
            case 5:
                return FetchLogicalCallContext();
            }

            // Shouldn't get here.
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));                    
        }

        private LogicalCallContext FetchLogicalCallContext()
        {
            Message msg = _mcmsg as Message;
            if (null != msg)
            {
                return msg.GetLogicalCallContext();
            }
            else
            {
                MethodCall mc = _mcmsg as MethodCall;
                if (null != mc)
                {
                    return mc.GetLogicalCallContext();
                }                    
            else
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Message_BadType"));                    
            }                
        }        
        }        

        internal override void SetSpecialKey(int keyNum, Object value)
        {
            Message msg = _mcmsg as Message;
            MethodCall mc = _mcmsg as MethodCall;
            switch (keyNum)
            {
            case 0:
                if(null != msg)
                {
                    msg.Uri = (String)value;
                }
                else if (null != mc)
                {
                    mc.Uri = (String)value;
                }                
                else
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadType"));                    
                }
            break;

            case 1:               
                if(null != msg)
                {
                    msg.SetLogicalCallContext((LogicalCallContext)value);
                }
                else
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadType"));                    
                }
                break;
            default:
                // Shouldn't get here.
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }        
        }
    }

    //+================================================================================
    //
    // Synopsis:   Specialization of MessageDictionary for MethodReturnMessage objects
    //
    //-================================================================================
    internal class MRMDictionary : MessageDictionary
    {
        public static String[]  MCMkeysFault = {"__CallContext"};
        public static String[]  MCMkeysNoFault =  {
            "__Uri",
            "__MethodName",
            "__MethodSignature",
            "__TypeName",
            "__Return",
            "__OutArgs",
            "__CallContext"};

        internal IMethodReturnMessage _mrmsg;
        internal bool fault;

        public MRMDictionary(IMethodReturnMessage msg, IDictionary idict)
        : base((msg.Exception != null) ? MCMkeysFault : MCMkeysNoFault, idict)
        {
            fault = (msg.Exception != null) ;
            _mrmsg = msg;
        }

        internal override Object GetMessageValue(int i)
        {
            switch (i)
            {
            case 0:
                if (fault)
                    return FetchLogicalCallContext();
                else
                    return _mrmsg.Uri;
            case 1:
                return _mrmsg.MethodName;
            case 2:
                return _mrmsg.MethodSignature;
            case 3:
                return _mrmsg.TypeName;
            case 4:
                if (fault)
                {
                    return _mrmsg.Exception;
                }
                else
                {
                    return _mrmsg.ReturnValue;
                }
            case 5:
                return _mrmsg.Args;
            case 6:
                return FetchLogicalCallContext();
            }
            // Shouldn't get here.
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));                    
        }

        private LogicalCallContext FetchLogicalCallContext()
        {
            ReturnMessage rm = _mrmsg as ReturnMessage;
            if (null != rm)
            {
                return rm.GetLogicalCallContext();
            }
            else                 
            {
                MethodResponse mr = _mrmsg as MethodResponse;
                if (null != mr)
                {
                    return mr.GetLogicalCallContext(); 
            }
                else
                {
                    StackBasedReturnMessage srm = _mrmsg as StackBasedReturnMessage;
                    if (null != srm)
            {
                        return srm.GetLogicalCallContext();
            }
            else
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Message_BadType"));                    
            }
        }        
            }
        }        

        internal override void SetSpecialKey(int keyNum, Object value)
        {
            // 0 == Uri
            // 1 == CallContext
            // NOTE : we use this for Uri & CallContext only ... 
            ReturnMessage rm = _mrmsg as ReturnMessage;
            MethodResponse mr = _mrmsg as MethodResponse;

            switch (keyNum)
            {
            case 0:
                if (null != rm)
                {
                    rm.Uri = (String)value;
                }
                else 
                {                    
                    if (null != mr)
                    {
                        mr.Uri = (String)value;
                    }
                    else
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Message_BadType"));                    
                    }            
                }
                break;
            case 1:
                if (null != rm)
                {
                    rm.SetLogicalCallContext((LogicalCallContext)value);
                }
                else 
                {
                    
                    if (null != mr)
                {
                        mr.SetLogicalCallContext((LogicalCallContext)value);
                }
                else
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadType"));                    
                }            
                }
                break;
            default:
                // Shouldn't get here.
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }        
        }

    }

    //+================================================================================
    //
    // Synopsis:   Abstract class to help present a dictionary view of an object
    //
    //-================================================================================
    internal abstract class MessageDictionary : IDictionary
    {
        internal String[] _keys;
        internal IDictionary  _dict;

        internal MessageDictionary(String[] keys, IDictionary idict)
        {
            _keys = keys;
            _dict = idict;
        }        

        internal bool HasUserData()
        {
            // used by message smuggler to determine if there is any custom user
            //   data in the dictionary
            if ((_dict != null) && (_dict.Count > 0))
                return true;
            else
                return false;
        }

        // used by message smuggler, so that it doesn't have to iterate
        //   through special keys
        internal IDictionary InternalDictionary
        {
            get { return _dict; }
        }
        

        internal abstract Object GetMessageValue(int i);

        internal abstract void SetSpecialKey(int keyNum, Object value);

        public virtual bool IsReadOnly { get { return false; } }
        public virtual bool IsSynchronized { get { return false; } }
        public virtual bool IsFixedSize { get { return false; } }
        
        public virtual Object SyncRoot { get { return this; } }
        

        public virtual bool Contains(Object key)
        {
            if (ContainsSpecialKey(key))
            {
                return true;
            }
            else if (_dict != null)
            {
                return _dict.Contains(key);
            }
            return false;
        }

        protected virtual bool ContainsSpecialKey(Object key)
        {
            if (!(key is System.String))
            {
                return false;
            }
            String skey = (String) key;
            for (int i = 0 ; i < _keys.Length; i++)
            {
                if (skey.Equals(_keys[i]))
                {
                    return true;
                }
            }
            return false;
        }

        public virtual void CopyTo(Array array, int index)
        {
            for (int i=0; i<_keys.Length; i++)
            {
                array.SetValue(GetMessageValue(i), index+i);
            }

            if (_dict != null)
            {
                _dict.CopyTo(array, index+_keys.Length);
            }
        }

        public virtual Object this[Object key]
        {
            get
            {
                System.String skey = key as System.String;
                if (null != skey)
                {
                    for (int i=0; i<_keys.Length; i++)
                    {
                        if (skey.Equals(_keys[i]))
                        {
                            return GetMessageValue(i);
                        }
                    }
                    if (_dict != null)
                    {
                        return _dict[key];
                    }
                }
                return null;
            }
            set
            {
                if (ContainsSpecialKey(key))
                {
                    if (key.Equals(Message.UriKey))
                    {
                        SetSpecialKey(0,value);
                    }
                    else if (key.Equals(Message.CallContextKey))
                    {
                        SetSpecialKey(1,value);
                    }                    
                    else
                    {
                        throw new ArgumentException(
                            Environment.GetResourceString(
                                "Argument_InvalidKey"));
                    }
                }
                else
                {
                    if (_dict == null)
                    {
                        _dict = new Hashtable();
                    }
                    _dict[key] = value;
                }

            }
        }

        IDictionaryEnumerator IDictionary.GetEnumerator()
        {
            return new MessageDictionaryEnumerator(this, _dict);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotSupportedException();
        }


        public virtual void Add(Object key, Object value)
        {
            if (ContainsSpecialKey(key))
            {
                throw new ArgumentException(
                    Environment.GetResourceString(
                        "Argument_InvalidKey"));
            } 
            else
            {
                if (_dict == null)
                {
                    // no need to interlock, message object not guaranteed to
                    // be thread-safe.
                    _dict = new Hashtable();
                }
                _dict.Add(key, value);
            }
        }

        public virtual void Clear()
        {
            // Remove all the entries from the hash table
            if (null != _dict)
            {
                _dict.Clear();
            }
        }

        public virtual void Remove(Object key)
        {
            if (ContainsSpecialKey(key) || (_dict == null))
            {
                throw new ArgumentException(
                    Environment.GetResourceString(
                        "Argument_InvalidKey"));
            } 
            else
            {
                _dict.Remove(key);
            }
        }

        public virtual ICollection Keys
        {
            get
            {

                int len = _keys.Length;
                ICollection c = (_dict != null) ? _dict.Keys : null;
                if (c != null)
                {
                    len += c.Count;
                }

                ArrayList l = new ArrayList(len);
                for (int i = 0; i<_keys.Length; i++)
                {
                    l.Add(_keys[i]);
                }

                if (c != null)
                {
                    l.AddRange(c);
                }

                return l;
            }
        }

        public virtual ICollection Values
        {
            get
            {
                int len = _keys.Length;
                ICollection c = (_dict != null) ? _dict.Keys : null;
                if (c != null)
                {
                    len += c.Count;
                }

                ArrayList l = new ArrayList(len);

                for (int i = 0; i<_keys.Length; i++)
                {
                    l.Add(GetMessageValue(i));
                }

                if (c != null)
                {
                    l.AddRange(c);
                }
                return l;
            }
        }

        public virtual int Count
        {
            get
            {
                if (_dict != null)
                {
                    return _dict.Count+_keys.Length;
                }
                else
                {
                    return _keys.Length;
                }
            }
        }

    }

    //+================================================================================
    //
    // Synopsis:   Dictionary enumerator for helper class
    //
    //-================================================================================
    internal class MessageDictionaryEnumerator : IDictionaryEnumerator
    {
        private int i=-1;
        private IDictionaryEnumerator _enumHash;
        private MessageDictionary    _md;


        public MessageDictionaryEnumerator(MessageDictionary md, IDictionary hashtable)
        {
            _md = md;
            if (hashtable != null)
            {
                _enumHash = hashtable.GetEnumerator();
            }
            else
            {
                _enumHash = null;
            }
        }
        // Returns the key of the current element of the enumeration. The returned
        // value is undefined before the first call to GetNext and following
        // a call to GetNext that returned false. Multiple calls to
        // GetKey with no intervening calls to GetNext will return
        // the same object.
        //
        public Object Key {
            get {
                Message.DebugOut("MessageDE::GetKey i = " + i + "\n");
                if (i < 0)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }
                if (i < _md._keys.Length)
                {
                    return _md._keys[i];
                }
                else
                {
                    BCLDebug.Assert(_enumHash != null,"_enumHash != null");
                    return _enumHash.Key;
                }
            }
        }

        // Returns the value of the current element of the enumeration. The
        // returned value is undefined before the first call to GetNext and
        // following a call to GetNext that returned false. Multiple calls
        // to GetValue with no intervening calls to GetNext will
        // return the same object.
        //
        public Object Value {
            get {
                if (i < 0)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_InternalState"));
                }

                if (i < _md._keys.Length)
                {
                    return _md.GetMessageValue(i);
                }
                else
                {
                    BCLDebug.Assert(_enumHash != null,"_enumHash != null");
                    return _enumHash.Value;
                }
            }
        }

        // Advances the enumerator to the next element of the enumeration and
        // returns a boolean indicating whether an element is available. Upon
        // creation, an enumerator is conceptually positioned before the first
        // element of the enumeration, and the first call to GetNext brings
        // the first element of the enumeration into view.
        //
        public bool MoveNext()
        {
            if (i == -2)
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
            i++;
            if (i < _md._keys.Length)
            {
                return true;
            }
            else
            {
                if (_enumHash != null && _enumHash.MoveNext())
                {
                    return true;
                }
                else
                {
                    i = -2;
                    return false;
                }
            }
        }

        // Returns the current element of the enumeration. The returned value is
        // undefined before the first call to MoveNext and following a call
        // to MoveNext that returned false. Multiple calls to
        // Current with no intervening calls to MoveNext will return
        // the same object.
        //
        public Object Current {
            get {
                return Value;
            }
        }

        public DictionaryEntry Entry {
            get {
                return new DictionaryEntry(Key, Value);
            }
        }

        // Resets the enumerator, positioning it before the first element.  If an
        // Enumerator doesn't support Reset, a NotSupportedException is
        // thrown.
        public void Reset()
        {
            i = -1;
            if (_enumHash != null)
            {
                _enumHash.Reset();
            }
        }
    }

    //+================================================================================
    //
    // Synopsis:   Message for return from a stack blit call
    //
    //-================================================================================
    internal class StackBasedReturnMessage : IMethodReturnMessage, IInternalMessage
    {
        Message _m;
        Hashtable _h;
        MRMDictionary _d;
        ArgMapper _argMapper;

        internal StackBasedReturnMessage()      {}

        // NOTE: This method is called multiple times as we reuse the
        // message object. Make sure that you reset any fields that you
        // add to the message object to the default values. This will
        // ensure that the reused message object starts with the correct
        // values.
        internal void InitFields(Message m)
        {
            _m = m;
            if (null != _h)
            {
                // Remove all the hashtable entries
                _h.Clear();
            }
            if (null != _d)
            {
                // Remove all the dictionary entries
                _d.Clear();
            }
        }

        public String Uri                    { get {return _m.Uri;} set {_m.Uri = value;}}
        public String MethodName             { get {return _m.MethodName;}}
        public String TypeName               { get {return _m.TypeName;}}
        public Object MethodSignature        { get {return _m.MethodSignature;}}
        public MethodBase MethodBase         { get {return _m.MethodBase;}}
        public bool HasVarArgs               { get {return _m.HasVarArgs;}}

        public int ArgCount                  { get {return _m.ArgCount;}}
        public Object GetArg(int argNum)     {return _m.GetArg(argNum);}
        public String GetArgName(int index)  {return _m.GetArgName(index);}
        public Object[] Args                 { get {return _m.Args;}}
        public LogicalCallContext LogicalCallContext          { get { return _m.GetLogicalCallContext(); } }

        internal LogicalCallContext GetLogicalCallContext() {return _m.GetLogicalCallContext();}
        internal LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx)
        {
            return _m.SetLogicalCallContext(callCtx);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="StackBasedReturnMessage.OutArgCount"]/*' />
        public int OutArgCount                        
        { 
            get 
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.ArgCount;
            }
        }

        public Object  GetOutArg(int argNum)   
        {   
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="StackBasedReturnMessage.GetOutArgName"]/*' />
        public String GetOutArgName(int index) 
        { 
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArgName(index);
        }
        public Object[] OutArgs                       
        {
            get
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.Args;
            }
        }

        public Exception Exception                    { get {return null;}}
        public Object ReturnValue                     { get {return _m.GetReturnValue();}}

        public IDictionary Properties
        {
            get
            {
                lock(this)
                {
                    if (_h == null)
                    {
                        _h = new Hashtable();
                    }
                    if (_d == null)
                    {
                        _d = new MRMDictionary(this, _h);
                    }
                    return _d;
                }
            }
        }

        //
        // IInternalMessage
        //

        ServerIdentity IInternalMessage.ServerIdentityObject
        {
            get { return null; }
            set {}
        }

        Identity IInternalMessage.IdentityObject
        {
            get { return null;}
            set {}
        }

        void IInternalMessage.SetURI(String val)
        {
            _m.Uri = val;
        }
        
        void IInternalMessage.SetCallContext(LogicalCallContext newCallContext)
        {
            _m.SetLogicalCallContext(newCallContext);
        }

        bool IInternalMessage.HasProperties()
        {
            return _h != null;
        }
    } // class StackBasedReturnMessage
    

    //+================================================================================
    //
    // Synopsis:   Message for return from a stack builder sink call
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ReturnMessage : IMethodReturnMessage
    {
        internal Object         _ret;
        internal Object         _properties;
        internal String         _URI;
        internal Exception      _e;
        internal Object[]      _outArgs;
        internal int            _outArgsCount;
        internal String         _methodName;
        internal String         _typeName;
        internal Type[]         _methodSignature;
        internal bool           _hasVarArgs;
        internal LogicalCallContext _callContext;
        internal ArgMapper      _argMapper;
        internal MethodBase     _methodBase;

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.ReturnMessage"]/*' />
        public ReturnMessage(Object ret, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx,
                             IMethodCallMessage mcm)
        {
            _ret = ret;
            _outArgs = outArgs;
            _outArgsCount = outArgsCount;
            
            if (callCtx != null)
                _callContext = callCtx;
            else
                _callContext = CallContext.GetLogicalCallContext();
                
            if (mcm != null)
            {
                _URI = mcm.Uri;
                _methodName = mcm.MethodName;
                _methodSignature = null;
                _typeName = mcm.TypeName;
                _hasVarArgs = mcm.HasVarArgs;
                _methodBase = mcm.MethodBase;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.ReturnMessage1"]/*' />
        public ReturnMessage(Exception e, IMethodCallMessage mcm)
        {
            _e   = IsCustomErrorEnabled()? new RemotingException(Environment.GetResourceString("Remoting_InternalError")):e;
            if (mcm != null)
            {
                _URI = mcm.Uri;
                _methodName = mcm.MethodName;
                _methodSignature = null;
                _typeName = mcm.TypeName;
                _hasVarArgs = mcm.HasVarArgs;
                _methodBase = mcm.MethodBase;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.Uri"]/*' />
        public String Uri { get { return _URI; } set { _URI = value; } }
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.MethodName"]/*' />
        public String MethodName { get { return _methodName; } }
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.TypeName"]/*' />
        public String TypeName { get { return _typeName; } }
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.MethodSignature"]/*' />
        public Object MethodSignature 
        {
            get 
            { 
                if ((_methodSignature == null) && (_methodBase != null))
                    _methodSignature = Message.GenerateMethodSignature(_methodBase);
                    
                return _methodSignature; 
            }
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.MethodBase"]/*' />
        public MethodBase MethodBase { get { return _methodBase; } }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.HasVarArgs"]/*' />
        public bool HasVarArgs
        {
            get
            {
                return _hasVarArgs;
            }

        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.ArgCount"]/*' />
        public int ArgCount
        {
            get
            {
                if (_outArgs == null)
                {
                    return _outArgsCount;
                }
                else
                {
                    return _outArgs.Length;
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.GetArg"]/*' />
        public Object GetArg(int argNum)
        {
            if (_outArgs == null)
            {
                if ((argNum<0) || (argNum>=_outArgsCount))
                {
                    throw new ArgumentOutOfRangeException();
                }
                return null;
            }
            else
            {
                if ((argNum<0) || (argNum>=_outArgs.Length))
                {
                    throw new ArgumentOutOfRangeException();
                }
                return _outArgs[argNum];
            }

        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.GetArgName"]/*' />
        public String GetArgName(int index)
        {

            if (_outArgs == null)
            {
                if ((index < 0) || (index>=_outArgsCount))
                {
                    throw new ArgumentOutOfRangeException();
                }
            }
            else
            {
                if ((index < 0) || (index>=_outArgs.Length))
                {
                    throw new ArgumentOutOfRangeException();
                }
            }
            
            if (_methodBase != null)
            {
                RemotingMethodCachedData methodCache = InternalRemotingServices.GetReflectionCachedData(_methodBase);             
                return methodCache.Parameters[index].Name;
            }
            else
                return "__param" + index;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.Args"]/*' />
        public Object[] Args
        {
            get
            {
                if (_outArgs == null)
                {
                    return new Object[_outArgsCount];
                }
                return _outArgs;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.OutArgCount"]/*' />
        public int OutArgCount                        
        { 
            get 
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.ArgCount;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.GetOutArg"]/*' />
        public Object  GetOutArg(int argNum)   
        {   
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.GetOutArgName"]/*' />
        public String GetOutArgName(int index) 
        { 
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArgName(index);
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.OutArgs"]/*' />
        public Object[] OutArgs                       
        {
            get
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.Args;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.Exception"]/*' />
        public Exception Exception                    { get {return _e;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.ReturnValue"]/*' />
        public virtual Object ReturnValue                    { get {return _ret;}}

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.Properties"]/*' />
        public virtual IDictionary Properties
        {
            get
            {
                if (_properties == null)
                {
                    _properties = new MRMDictionary(this, null);
                }
                return(MRMDictionary) _properties;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ReturnMessage.LogicalCallContext"]/*' />
        public LogicalCallContext LogicalCallContext 
        {
            get { return GetLogicalCallContext();}
        }
            

        internal LogicalCallContext GetLogicalCallContext()
        {
            if (_callContext == null)
                _callContext = new LogicalCallContext();
            return _callContext;
        }

        internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx)
        {
            LogicalCallContext old = _callContext;
            _callContext=ctx;
            return old;
        }

        // used to determine if the properties dictionary has already been created
        internal bool HasProperties()
        {
            return _properties != null;
        }
        static internal bool IsCustomErrorEnabled(){
            Object oIsCustomErrorEnabled  = CallContext.GetData("__CustomErrorsEnabled");
            // The server side will always have this CallContext item set. If it is not set then
            // it means this is the client side. In that case customError is false.
            return (oIsCustomErrorEnabled == null) ? false:(bool)oIsCustomErrorEnabled;
        }

    } // class ReturnMessage

    //+================================================================================
    //
    // Synopsis:   Message used for deserialization of a method call
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall"]/*' />
    /// <internalonly/>
    [Serializable,CLSCompliant(false)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class MethodCall : IMethodCallMessage, ISerializable, IInternalMessage, ISerializationRootObject
    {

        private const BindingFlags LookupAll = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
        private const BindingFlags LookupPublic = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

        // data
        private String uri;
        private String methodName;
        private MethodBase MI;
        private String typeName;
        private Object[] args;
        private LogicalCallContext callContext;
        private Type[] methodSignature;
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.ExternalProperties"]/*' />
	/// <internalonly/>
        protected IDictionary ExternalProperties = null;
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.InternalProperties"]/*' />
	/// <internalonly/>
        protected IDictionary InternalProperties = null;

        private ServerIdentity srvID;
        private Identity identity;
        private bool fSoap;
        private bool fVarArgs = false;
        private ArgMapper argMapper;

        //
        // MethodCall -- SOAP uses this constructor
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.MethodCall"]/*' />
	/// <internalonly/>
        public MethodCall(Header[] h1)
        {
            Message.DebugOut("MethodCall ctor IN headers: " + (h1 == null ? "<null>" : h1.ToString()) + "\n");

            Init();

            fSoap = true;
            FillHeaders(h1);            

            ResolveMethod();

            if (MI != null)
            {
                // Check caller's access to method.
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                Message.MethodAccessCheck(MI, ref stackMark);
            }

            Message.DebugOut("MethodCall ctor OUT\n");

        }

        //
        // MethodCall -- this constructor is used for copying an existing message
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.MethodCall1"]/*' />
	/// <internalonly/>
        public MethodCall(IMessage msg)
            : this( msg, true )
        {
        }

        internal MethodCall( IMessage msg, bool needAccessCheck )
        {
            if (msg == null)
                throw new ArgumentNullException("msg");

            Init();

            IDictionaryEnumerator de = msg.Properties.GetEnumerator();
            while (de.MoveNext())
            {
                FillHeader(de.Key.ToString(), de.Value);
            }
            
            IMethodCallMessage mcm = msg as IMethodCallMessage;

            if (mcm != null)

                MI = mcm.MethodBase;

            ResolveMethod();

            if (MI != null && needAccessCheck)
            {
                // Check caller's access to method.
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                Message.MethodAccessCheck(MI, ref stackMark);
            }
        }

        internal MethodCall(SerializationInfo info, StreamingContext context) 
        {        
            if (info == null)
                throw new ArgumentNullException("info");
            Init();

            SetObjectData(info, context);
        }


        internal MethodCall(SmuggledMethodCallMessage smuggledMsg, ArrayList deserializedArgs)
        {
            uri = smuggledMsg.Uri;
            typeName = smuggledMsg.TypeName;
            methodName = smuggledMsg.MethodName;
            methodSignature = (Type[])smuggledMsg.GetMethodSignature(deserializedArgs);
            args = smuggledMsg.GetArgs(deserializedArgs);
            callContext = smuggledMsg.GetCallContext(deserializedArgs);
   
            ResolveMethod();

            if (smuggledMsg.MessagePropertyCount > 0)
                smuggledMsg.PopulateMessageProperties(Properties, deserializedArgs);
        }

        internal MethodCall(Object handlerObject, BinaryMethodCallMessage smuggledMsg)
        {
            if (handlerObject != null)
            {
                uri = handlerObject as String;
                if (uri == null)
                {
                    // This must be the tranparent proxy
                    MarshalByRefObject mbr = handlerObject as MarshalByRefObject;
                    if (mbr != null)
                    {                      
						bool fServer;
                        srvID = MarshalByRefObject.GetIdentity(mbr, out fServer) as ServerIdentity; 
                        uri = srvID.URI;
                    }
                }
            }

            typeName = smuggledMsg.TypeName;
            methodName = smuggledMsg.MethodName;
            methodSignature = (Type[])smuggledMsg.MethodSignature;
            args = smuggledMsg.Args;
            callContext = smuggledMsg.LogicalCallContext;

            ResolveMethod();

            if (smuggledMsg.HasProperties)
                smuggledMsg.PopulateMessageProperties(Properties);
        }

        

        //
        // ISerializationRootObject
        //
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.RootSetObjectData"]/*' />
	/// <internalonly/>
        public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            SetObjectData(info, ctx);
        }

        //
        // SetObjectData -- the class can also be initialized in part or in whole by serialization
        // in the SOAP case, both the constructor and SetObjectData init the object, in the non-SOAP
        // case, just SetObjectData is called
        //

        internal void SetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException("info");

            if (fSoap)
            {
                SetObjectFromSoapData(info);
            }
            else
            {
                SerializationInfoEnumerator siEnum = info.GetEnumerator();
                while (siEnum.MoveNext())
                {
                    FillHeader(siEnum.Name, siEnum.Value);
                }
                if ((context.State == StreamingContextStates.Remoting) && 
                    (context.Context != null))
                {
                    Header[] h = context.Context as Header[];
                    if(null != h)
                    {
                        for (int i=0; i<h.Length; i++)
                            FillHeader(h[i].Name, h[i].Value);
                    }                
                }
            }
        } // SetObjectData
 
        //
        // ResolveMethod
        //

        internal Type ResolveType()
        {        
            // resolve type
            Type t = null;

            if (srvID == null)
                srvID = IdentityHolder.CasualResolveIdentity(uri) as ServerIdentity;                

            if (srvID != null)
            {
                int startIndex = 0; // start of type name

                // check to see if type name starts with "clr:"
                if (String.CompareOrdinal(typeName, 0, "clr:", 0, 4) == 0)
                {
                    // type starts just past "clr:"
                    startIndex = 4;
                }

                // find end of full type name
                int index = typeName.IndexOf(',', startIndex);
                if (index == -1)
                    index = typeName.Length;

                Type serverType = srvID.ServerType;
                t = Type.ResolveTypeRelativeTo(typeName, startIndex, index - startIndex, serverType);
            }

            if (t == null)
            {
                // fall back to Type.GetType() in case someone isn't using
                //   our convention for the TypeName
                t = RemotingServices.InternalGetTypeFromQualifiedTypeName(typeName);
            }

            return t;
        } // ResolveType


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.ResolveMethod"]/*' />
	/// <internalonly/>
        public void ResolveMethod()
        {
            ResolveMethod(true);
        }

        internal void ResolveMethod(bool bThrowIfNotResolved)
        {
            if ((MI == null) && (methodName != null))
            {
                BCLDebug.Trace("REMOTE", "TypeName: " + (typeName == null ? "<null>" : typeName) + "\n");

                // resolve type
                RuntimeType t = ResolveType() as RuntimeType;
                
                BCLDebug.Trace("REMOTE", "Type: " + (t == null ? "<null>" : t.ToString()) + "\n");
                if (methodName.Equals(".ctor"))
                    return;
                if (t == null)
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_BadType"),
                            typeName));
                }

                // Note: we reflect on non-public members here .. we do
                // block incoming remote calls and allow only specific methods
                // that we use for implementation of certain features (eg.
                // for remote field access)

                // ***********************************************************
                // Note: For the common (non-overloaded method, urt-to-urt) case
                // methodSignature is null.
                // If the call is from a urt client to an overloaded method, 
                // methodSignature is non-null. We could have a non-null 
                // methodSignature if the call is from a non-urt client for 
                // which we have to do special work if the method is overloaded
                // (in the try-catch below).
                // ***********************************************************
                if (null != methodSignature)
                {
                    MI = t.GetMethodImplInternal(methodName,
                                                 MethodCall.LookupAll,
                                                 null,
                                                 CallingConventions.Any,
                                                 methodSignature,
                                                 null,
                                                 false);

                    BCLDebug.Trace("REMOTE", "Method resolved w/sig ", MI == null ? "<null>" : "<not null>");
                }
                else
                {
                    
                    // Check the cache to see if you find the methodbase
                    RemotingTypeCachedData typeCache = InternalRemotingServices.GetReflectionCachedData(t);

                    MI = typeCache.GetLastCalledMethod(methodName);
                    if (MI != null)
                        return;

                    // This could give us the wrong MethodBase because
                    // the server and the client types could be of different 
                    // versions. The mismatch is caught either when the server has
                    // more than one method defined with the same name or when we
                    // coerce the args and the incoming argument types do not match 
                    // the method signature.                    
                    
                    BCLDebug.Assert(
                        !methodName.Equals(".ctor"),
                        "unexpected method type");

                    bool bOverloaded = false;

                    try
                    {
                        MI = t.GetMethodImplInternal(methodName,
                                                     MethodCall.LookupAll,
                                                     null,
                                                     CallingConventions.Any,
                                                     null,
                                                     null,
                                                     false);

                        BCLDebug.Trace("REMOTE", "Method resolved w/name ", MI == null ? "<null>" : methodName);
                        BCLDebug.Trace("REMOTE", "sig not filled in!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    }
                    catch (AmbiguousMatchException)
                    {
                        // This is the case when no methodSignature was found
                        // but the method is overloaded .. 
                        // (possibly because a non-URT client called us)
                        bOverloaded = true;                        
                        ResolveOverloadedMethod(t);
                    } //catch                    

                    // In the non-URT call, overloaded case, don't cache the MI
                    if (MI != null && !bOverloaded)
                        typeCache.SetLastCalledMethod(methodName, MI);
                }
    
                if (MI == null && bThrowIfNotResolved)
                {   
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_MethodMissing"),
                            methodName,
                            typeName));
                }
            }
        }

        // Helper that gets called when we attempt to resolve a method
        // without an accompanying methodSignature ... current thinking is
        // that we should make a good faith attempt by matching argument
        // counts
        void ResolveOverloadedMethod(RuntimeType t)
        {
            if (args == null) // args is null the first call from soap because we havem't passed the arguments yet.
                return;

            MethodInfo[] mi = t.GetMemberMethod(methodName,
                                                MethodCall.LookupPublic,
                                                CallingConventions.Any,
                                                null,
                                                -1,
                                                false);
            if (mi!=null)
            {
                if (mi.Length == 1)
                {
                    MI = mi[0];
                }
                else if (mi.Length > 1)
                {
                    int argCount = args.Length;
                    int match = 0;
                    int iMatch = -1;
                    for (int i=0; i<mi.Length; i++)
                    {
                        if (mi[i].GetParameters().Length == argCount)
                        {
                            match++;
                            iMatch = i;
                        } 
                    }

                    // We will let resolve succeed if exactly one
                    // of the overloaded methods matches in terms
                    // of argCount
                    if (match == 1)
                    {
                        MI = mi[iMatch]; 
                    }
                    else if (match > 1)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_AmbiguousMethod"));
                    }
                }     
            }
        }

        // This will find the right overloaded method if the argValues from soap have type information,
        // By default parameters will be of type string, this could lead to a wrong choice of methodbase.
        void ResolveOverloadedMethod(RuntimeType t, String methodName, ArrayList argNames, ArrayList argValues)
        {
            MethodInfo[] mi = t.GetMemberMethod(methodName,
                                                MethodCall.LookupPublic,
                                                CallingConventions.Any,
                                                null,
                                                -1,
                                                false);
            if (mi!=null)
            {
                if (mi.Length == 1)
                {
                    MI = mi[0];
                }
                else if (mi.Length > 1)
                {
                    for (int i=0; i<mi.Length; i++)
                    {
                        ParameterInfo[] piA = mi[i].GetParameters();
                        bool bMatch = true;
                        if (piA.Length == argValues.Count)
                        {
                            for (int j=0; j<piA.Length; j++)
                            {
                                Type ptype = piA[j].ParameterType;
                                if (ptype.IsByRef)
                                    ptype= ptype.GetElementType();

                                if (ptype != argValues[j].GetType())
                                {
                                    bMatch = false;
                                    break;
                                }

                            }
                            if (bMatch)
                            {
                                MI = mi[i];
                                break;
                            }
                        } 
                    }

                    if (MI == null)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_AmbiguousMethod"));
                    }
                }     
            }
        }
        
        //
        // GetObjectData -- not implemented
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.GetObjectData"]/*' />
	/// <internalonly/>
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));                
        }

        //
        // SetObjectFromSoapData -- parses soap format for serialization data
        //

        internal void SetObjectFromSoapData(SerializationInfo info)
        {
            // resolve method
            methodName = info.GetString("__methodName");
            ArrayList paramNames = (ArrayList)info.GetValue("__paramNameList", typeof(ArrayList));

            Hashtable keyToNamespaceTable = (Hashtable)info.GetValue("__keyToNamespaceTable", typeof(Hashtable));

            if (MI == null)
            {
                // This is the case where 
                // 1) there is no signature in the header, 
                // 2) there is an overloaded method which can not be resolved by a difference in the number of parameters.
                //
                // The methodbase can be found only if the parameters from soap have type information
                ArrayList argValues = new ArrayList();
                ArrayList argNames = paramNames;
                // SerializationInfoEnumerator siEnum1 = info.GetEnumerator();
                for (int i=0; i<argNames.Count; i++)
                {
                    argValues.Add(info.GetValue((String)argNames[i], typeof(Object)));
                }

                //ambiguous member, try to find methodBase using actual argment types (if available)
                RuntimeType t = ResolveType() as RuntimeType;
                if (t == null)
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_BadType"),
                            typeName));
                }

                ResolveOverloadedMethod(t, methodName, argNames, argValues); 

                if (MI == null)
                {   
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_MethodMissing"),
                            methodName,
                            typeName));
                }
            }
            //ResolveMethod();       


            //BCLDebug.Assert(null != MI, "null != MI");

            // get method parameters and parameter maps
            RemotingMethodCachedData methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
            ParameterInfo[] pinfos = methodCache.Parameters;
            int[] marshalRequestArgMap = methodCache.MarshalRequestArgMap;
            int[] outOnlyArgMap = methodCache.OutOnlyArgMap;
            
            // check to see if parameters are in-order
            Object fUnordered = (null == InternalProperties ? null : InternalProperties["__UnorderedParams"]);

            // Create an array for arguments
            args = new Object[pinfos.Length];           

            //SerializationInfoEnumerator siEnum = info.GetEnumerator();

            // Fill up the argument array
            if (fUnordered != null &&
                (fUnordered is System.Boolean) && 
                (true == (bool)fUnordered))
            {
                String memberName;

                for (int i=0; i<paramNames.Count; i++)
                {
                    memberName = (String)paramNames[i];
                    Message.DebugOut(
                        "MethodCall::PopulateData members[i].Name: " 
                        + memberName + " substring:>>" 
                        + memberName.Substring(7) + "<<\n");

                    int position = -1;
                    for (int j=0; j<pinfos.Length; j++)
                    {
                        if (memberName.Equals(pinfos[j].Name))
                        {
                            position = pinfos[j].Position;
                            break;
                        }
                    }

                    if (position == -1)
                    {
                        if (!memberName.StartsWith("__param"))
                        {
                            throw new RemotingException(
                                Environment.GetResourceString(
                                "Remoting_Message_BadSerialization"));
                        }
                        position = Int32.Parse(memberName.Substring(7));
                    }
                    if (position >= args.Length)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Message_BadSerialization"));
                    }
                    args[position] = Message.SoapCoerceArg(info.GetValue(memberName, typeof(Object)), pinfos[position].ParameterType, keyToNamespaceTable);
                }
            }
            else
            {
                for (int i=0; i<paramNames.Count; i++)
                    {
                    String memberName = (String)paramNames[i];
                        args[marshalRequestArgMap[i]] = 
                    Message.SoapCoerceArg(info.GetValue(memberName, typeof(Object)), pinfos[marshalRequestArgMap[i]].ParameterType, keyToNamespaceTable);
                }

                // We need to have a dummy object in the array for out parameters
                //   that have value types.
                foreach (int outArg in outOnlyArgMap)
                {
                    Type type = pinfos[outArg].ParameterType.GetElementType();
                    if (type.IsValueType)
                        args[outArg] = Activator.CreateInstance(type, true);
                }
            }
        } // SetObjectFromSoapData

        //
        // Init -- constructor helper for for default behavior
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.Init"]/*' />
	/// <internalonly/>
        public virtual void Init()
        {
        }

        //
        // IMethodCallMessage
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.ArgCount"]/*' />
	/// <internalonly/>
        public int ArgCount
        {
            get
            {
                return(args == null) ? 0 : args.Length;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.GetArg"]/*' />
	/// <internalonly/>
        public Object GetArg(int argNum)
        {
            return args[argNum];
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.GetArgName"]/*' />
	/// <internalonly/>
        public String GetArgName(int index)
        {
            ResolveMethod();
        
            RemotingMethodCachedData methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
            return methodCache.Parameters[index].Name;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.Args"]/*' />
	/// <internalonly/>
        public Object[] Args
        {
            get
            {
                return args;
            }
        }


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.InArgCount"]/*' />
	/// <internalonly/>
        public int InArgCount                        
        { 
            get 
            {
                if (argMapper == null) argMapper = new ArgMapper(this, false);
                return argMapper.ArgCount;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.GetInArg"]/*' />
	/// <internalonly/>
        public Object  GetInArg(int argNum)   
        {
            if (argMapper == null) argMapper = new ArgMapper(this, false);
            return argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.GetInArgName"]/*' />
	/// <internalonly/>
        public String GetInArgName(int index) 
        { 
            if (argMapper == null) argMapper = new ArgMapper(this, false);
            return argMapper.GetArgName(index);
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.InArgs"]/*' />
	/// <internalonly/>
        public Object[] InArgs                       
        {
            get
            {
                if (argMapper == null) argMapper = new ArgMapper(this, false);
                return argMapper.Args;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.MethodName"]/*' />
	/// <internalonly/>
        public String MethodName { get { return methodName; } }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.TypeName"]/*' />
	/// <internalonly/>
        public String TypeName { get { return typeName; } }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.MethodSignature"]/*' />
	/// <internalonly/>
        public Object MethodSignature
        {
            get
            {
                if (methodSignature != null)
                    return methodSignature;
                else if (MI != null)
                    methodSignature = Message.GenerateMethodSignature(this.MethodBase);
                
                return null;
            }
        }    

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.MethodBase"]/*' />
	/// <internalonly/>
        public MethodBase MethodBase 
        {
            get
            {
                if (MI == null)
                    MI = RemotingServices.InternalGetMethodBaseFromMethodMessage(this);
                return MI;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.Uri"]/*' />
	/// <internalonly/>
        public String Uri 
        {
            get { return uri; }
            set { uri = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.HasVarArgs"]/*' />
	/// <internalonly/>
        public bool HasVarArgs
        {
            get { return fVarArgs; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.Properties"]/*' />
	/// <internalonly/>
        public virtual IDictionary Properties
        {
            get
            {
                lock(this) {
                    if (InternalProperties == null)
                    {
                        InternalProperties = new Hashtable();
                    }
                    if (ExternalProperties == null)
                    {
                        ExternalProperties = new MCMDictionary(this, InternalProperties);
                    }
                    return ExternalProperties;
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.LogicalCallContext"]/*' />
	/// <internalonly/>
        public LogicalCallContext LogicalCallContext { get { return GetLogicalCallContext();} }
        internal LogicalCallContext GetLogicalCallContext()
        {
            if (callContext == null)
                callContext = new LogicalCallContext();
            return callContext;
        }

        internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx)
        {
            LogicalCallContext old=callContext;
            callContext=ctx;
            return old;
        }

        //
        // IInternalMessage
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.IInternalMessage.ServerIdentityObject"]/*' />
        /// <internalonly/>
        ServerIdentity IInternalMessage.ServerIdentityObject
        {
            get { return srvID;}
            set {srvID = value;}
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.IInternalMessage.IdentityObject"]/*' />
        /// <internalonly/>
        Identity IInternalMessage.IdentityObject
        {
            get { return identity;}
            set { identity = value;}
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.IInternalMessage.SetURI"]/*' />
        /// <internalonly/>
        void IInternalMessage.SetURI(String val)
        {
            uri = val;
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.IInternalMessage.SetCallContext"]/*' />
        /// <internalonly/>
        void IInternalMessage.SetCallContext(LogicalCallContext newCallContext)
        {
            callContext = newCallContext;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.IInternalMessage.HasProperties"]/*' />
        /// <internalonly/>
        bool IInternalMessage.HasProperties()
        {
            return (ExternalProperties != null) || (InternalProperties != null);
        }

        //
        // helper functions
        //
            
        internal void FillHeaders(Header[] h)
        {
            FillHeaders(h, false);
        }
    
        private void FillHeaders(Header[] h, bool bFromHeaderHandler)
        {            
            if (h == null)
                return;

            if (bFromHeaderHandler && fSoap)
            {            
                // Handle the case of headers coming off the wire in SOAP.

                // look for message properties
                int co;
                for (co = 0; co < h.Length; co++)
                {
                    Header header = h[co];
                    if (header.HeaderNamespace == "http://schemas.microsoft.com/clr/soap/messageProperties")
                    {
                        // add property to the message
                        FillHeader(header.Name, header.Value);
                    }
                    else
                    {
                        // add header to the message as a header
                        String name = LogicalCallContext.GetPropertyKeyForHeader(header);
                        FillHeader(name, header);
                    }
                }                
            }
            else
            {
                int i;
                for (i=0; i<h.Length; i++)
                {
                    FillHeader(h[i].Name, h[i].Value);
                }
            }
        }

        internal virtual bool FillSpecialHeader(String key, Object value)
        {
            if (key == null)
            {
                //skip
            }
            else if (key.Equals("__Uri"))
            {
                uri = (String) value;
            }
            else if (key.Equals("__MethodName"))
            {
                methodName = (String) value;
            }
            else if (key.Equals("__MethodSignature"))
            {
                methodSignature = (Type[]) value;
            }
            else if (key.Equals("__TypeName"))
            {
                typeName = (String) value;
            }
            else if (key.Equals("__Args"))
            {
                args = (Object[]) value;
            }
            else if (key.Equals("__CallContext"))
            {
                // if the value is a string, then its the LogicalCallId
                if (value is String)
                {
                    callContext = new LogicalCallContext();
                    callContext.RemotingData.LogicalCallID = (String) value;
                }
                else
                    callContext = (LogicalCallContext) value;
            }
            else
            {
                return false;
            }
            return true;
        }
        internal void FillHeader(String key, Object value)
        {
            Message.DebugOut("MethodCall::FillHeader: key:" + key + "\n");

            if (!FillSpecialHeader(key,value))
            {
                if (InternalProperties == null)
                {
                    InternalProperties = new Hashtable();
                }
                InternalProperties[key] = value;
            }

        }
   
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCall.HeaderHandler"]/*' />
    	/// <internalonly/>
        public virtual Object HeaderHandler(Header[] h)
        {
            SerializationMonkey m = (SerializationMonkey) FormatterServices.GetUninitializedObject(typeof(SerializationMonkey));
            Header[] newHeaders = null;
            if (h != null && h.Length > 0 && h[0].Name == "__methodName")
            {
                methodName = (String)h[0].Value;
                if (h.Length > 1)
                {
                    newHeaders = new Header[h.Length -1];
                    Array.Copy(h, 1, newHeaders, 0, h.Length-1);
                }
                else
                    newHeaders = null;
            }
            else
                newHeaders = h;

            FillHeaders(newHeaders, true);
            ResolveMethod(false);
            m._obj = this;
            if (MI != null)
            {
                ArgMapper argm = new ArgMapper(MI, false);
                m.fieldNames = argm.ArgNames;
                m.fieldTypes = argm.ArgTypes;
            }
            return m;
        }
    }


    //+================================================================================
    //
    // Synopsis:   Message used for deserialization of a construction call
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall"]/*' />
    /// <internalonly/>
    [Serializable,CLSCompliant(false)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ConstructionCall : MethodCall, IConstructionCallMessage
    {

        //
        // data
        //

        internal Type         _activationType;
        internal String        _activationTypeName;
        internal IList        _contextProperties;
        internal Object[]     _callSiteActivationAttributes;
        internal IActivator   _activator;

        /*
        [NonSerialized()]
        internal Object       _fakeThisPtr;     // used for proxyattribute::CI 
        */

        //
        // construction
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.ConstructionCall"]/*' />
	/// <internalonly/>
        public ConstructionCall(Header[] headers) : base(headers) {}
        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.ConstructionCall1"]/*' />
	/// <internalonly/>
        public ConstructionCall(IMessage m) : base(m) {}
        internal ConstructionCall(SerializationInfo info, StreamingContext context) : base(info, context) 
        {
        }

        /*
        internal Object GetThisPtr()
        {
            return _fakeThisPtr;
        }
        internal void SetThisPtr(Object obj)
        {
            _fakeThisPtr = obj;
        }
        */

        //
        //  Function:    FillSpecialHeader
        //
        //  Synopsis:    this is the only specialization we need to
        //               make things go in the right place
        //
        //
        internal override bool FillSpecialHeader(String key, Object value)
        {
            if (key == null)
            {
                //skip
            }
            else if (key.Equals("__ActivationType"))
            {
                BCLDebug.Assert(value==null, "Phoney type in CCM");
                _activationType = null;
            }
            else if (key.Equals("__ContextProperties"))
            {
                _contextProperties = (IList) value;
            }
            else if (key.Equals("__CallSiteActivationAttributes"))
            {
                _callSiteActivationAttributes = (Object[]) value;
            }
            else if (key.Equals("__Activator"))
            {
                _activator = (IActivator) value;
            }
            else if (key.Equals("__ActivationTypeName"))
            {
                _activationTypeName = (String) value;
            }
            else
            {
                return base.FillSpecialHeader(key, value);
            }
            return true;

        }


        //
        // IConstructionCallMessage
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.CallSiteActivationAttributes"]/*' />
	/// <internalonly/>
        public Object[] CallSiteActivationAttributes
        {
            get
            {
                return _callSiteActivationAttributes;
            }

        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.ActivationType"]/*' />
	/// <internalonly/>
        public Type ActivationType
        {
            get
            {
                if ((_activationType == null) && (_activationTypeName != null))
                    _activationType = RemotingServices.InternalGetTypeFromQualifiedTypeName(_activationTypeName, false);

                return _activationType;
            }
            }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.ActivationTypeName"]/*' />
	/// <internalonly/>
        public String ActivationTypeName
        {
            get
            {
                return _activationTypeName;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.ContextProperties"]/*' />
	/// <internalonly/>
        public IList ContextProperties
        {
            get
            {
                if (_contextProperties == null)
                {
                    _contextProperties = new ArrayList();
                }
                return _contextProperties;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.Properties"]/*' />
	/// <internalonly/>
        public override IDictionary Properties
        {
            get
            {
                lock(this) 
                {
                    if (InternalProperties == null)
                    {
                        InternalProperties = new Hashtable();
                    }
                    if (ExternalProperties == null)
                    {
                        ExternalProperties = new CCMDictionary(this, InternalProperties);
                    }
                    return ExternalProperties;
                }
            }
        }
        

        // IConstructionCallMessage::Activator
        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionCall.Activator"]/*' />
	/// <internalonly/>
        public IActivator Activator
        {
            get { return _activator; }
            set { _activator = value;}
        }
        
    }
    //+================================================================================
    //
    // Synopsis:   Message used for deserialization of a method response
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse"]/*' />
    /// <internalonly/>
    [Serializable,CLSCompliant(false)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class MethodResponse : IMethodReturnMessage, ISerializable, ISerializationRootObject, IInternalMessage
    {
        private MethodBase MI;
        private String     methodName;
        private Type[]     methodSignature;
        private String     uri;
        private String     typeName;
        private Object     retVal;
        private Exception  fault;
        private Object[]  outArgs;
        private LogicalCallContext callContext;
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.InternalProperties"]/*' />
	/// <internalonly/>
        protected IDictionary InternalProperties;
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.ExternalProperties"]/*' />
	/// <internalonly/>
        protected IDictionary ExternalProperties;

        private int       argCount;
        private bool      fSoap;
        private ArgMapper argMapper;
        private RemotingMethodCachedData _methodCache;

        // Constructor -- this constructor is called only in the SOAP Scenario


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.MethodResponse"]/*' />
	/// <internalonly/>
        public MethodResponse(Header[] h1, IMethodCallMessage mcm)
        {
            if (mcm == null)
                throw new ArgumentNullException("mcm");

            Message msg = mcm as Message;
            if (null != msg)
            {
                MI = (MethodBase)msg.GetMethodBase();
            }
            else
            {
                MI = (MethodBase)mcm.MethodBase;
            }
            if (MI == null)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_Message_MethodMissing"),
                        mcm.MethodName,
                        mcm.TypeName));
            }
            
            _methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
            
            argCount = _methodCache.Parameters.Length;
            fSoap = true;
            FillHeaders(h1);
        }


        internal MethodResponse(IMethodCallMessage msg,
                                SmuggledMethodReturnMessage smuggledMrm,
                                ArrayList deserializedArgs)
        {
            MI = (MethodBase)msg.MethodBase;
            _methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
            
            methodName = msg.MethodName;
            uri = msg.Uri;
            typeName = msg.TypeName;

            if (_methodCache.IsOverloaded())
                methodSignature = (Type[])msg.MethodSignature;
           
            retVal = smuggledMrm.GetReturnValue(deserializedArgs);
            outArgs = smuggledMrm.GetArgs(deserializedArgs);
            fault = smuggledMrm.GetException(deserializedArgs);

            callContext = smuggledMrm.GetCallContext(deserializedArgs);

            if (smuggledMrm.MessagePropertyCount > 0)
                smuggledMrm.PopulateMessageProperties(Properties, deserializedArgs);           
            
            argCount = _methodCache.Parameters.Length;
            fSoap = false;
        }

        internal MethodResponse(IMethodCallMessage msg,
                                Object handlerObject,
                                BinaryMethodReturnMessage smuggledMrm)
        {

            if (msg != null)
            {
                MI = (MethodBase)msg.MethodBase;
                _methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
            
                methodName = msg.MethodName;
                uri = msg.Uri;
                typeName = msg.TypeName;

                if (_methodCache.IsOverloaded())
                    methodSignature = (Type[])msg.MethodSignature;

                argCount = _methodCache.Parameters.Length;

            }
           
            retVal = smuggledMrm.ReturnValue;
            outArgs = smuggledMrm.Args;
            fault = smuggledMrm.Exception;

            callContext = smuggledMrm.LogicalCallContext;

            if (smuggledMrm.HasProperties)
                smuggledMrm.PopulateMessageProperties(Properties);           
            
            fSoap = false;
        }



        //
        // SetObjectData -- this can be called with the object in two possible states. 1. the object
        // is servicing a SOAP response in which it will have been half initialized by the constructor,
        // or 2. the object is uninitailized and serialization is passing in the contents.
        //
        internal MethodResponse(SerializationInfo info, StreamingContext context) 
        {
            if (info == null)
                throw new ArgumentNullException("info");
            SetObjectData(info, context);
        }


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.HeaderHandler"]/*' />
	/// <internalonly/>
        public virtual Object HeaderHandler(Header[] h)
        {
            SerializationMonkey m = (SerializationMonkey) FormatterServices.GetUninitializedObject(typeof(SerializationMonkey));

            Header[] newHeaders = null;
            if (h != null && h.Length > 0 && h[0].Name == "__methodName")
            {
                if (h.Length > 1)
                {
                    newHeaders = new Header[h.Length -1];
                    Array.Copy(h, 1, newHeaders, 0, h.Length-1);
                }
                else
                    newHeaders = null;
            }
            else
                newHeaders = h;

            Type retType = null;
            MethodInfo mi = MI as MethodInfo;
            if (mi != null)
            {
                retType = mi.ReturnType; 
            }

            ParameterInfo[] pinfos = _methodCache.Parameters;

            // Calculate length
            int outParamsCount = _methodCache.MarshalResponseArgMap.Length;
            if (!((retType == null) || (retType == typeof(void))))
                outParamsCount++;

            Type[] paramTypes = new Type[outParamsCount];
            String[] paramNames = new String[outParamsCount];
            int paramTypesIndex = 0;
            if (!((retType == null) || (retType == typeof(void))))
            {
                paramTypes[paramTypesIndex++] = retType;
            }

            foreach (int i in _methodCache.MarshalResponseArgMap)
            {
                paramNames[paramTypesIndex] = pinfos[i].Name;
                if (pinfos[i].ParameterType.IsByRef)
                    paramTypes[paramTypesIndex++] = pinfos[i].ParameterType.GetElementType();
                else
                    paramTypes[paramTypesIndex++] = pinfos[i].ParameterType;
            }

            ((IFieldInfo)m).FieldTypes = paramTypes;
            ((IFieldInfo)m).FieldNames = paramNames;
            FillHeaders(newHeaders, true);
            m._obj = this;
            return m;
        }

        //
        // ISerializationRootObject
        //
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.RootSetObjectData"]/*' />
	/// <internalonly/>
        public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            SetObjectData(info, ctx);
        }

        internal void SetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            if (info == null)
                throw new ArgumentNullException("info");

            if (fSoap)
            {
                SetObjectFromSoapData(info);
            }
            else
            {
                SerializationInfoEnumerator e = info.GetEnumerator();
                bool ret = false;
                bool excep = false;

                while (e.MoveNext())
                {
                    if (e.Name.Equals("__return"))
                    {
                        ret = true;
                        break;
                    }
                    if (e.Name.Equals("__fault"))
                    {
                        excep = true;
                        fault = (Exception)e.Value;
                        break;
                    }

                    FillHeader(e.Name, e.Value);
                }
                if ((excep) && (ret))
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_Message_BadSerialization"));
                }
            }
        }
        //
        // ISerializable
        //

        //
        // GetObjectData -- not implemented
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.GetObjectData"]/*' />
        /// <internalonly/>
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));                
        }

        //
        // SetObjectFromSoapData -- assumes SOAP format and populates the arguments array
        //

        internal virtual void SetObjectFromSoapData(SerializationInfo info)
        {
            //SerializationInfoEnumerator e = info.GetEnumerator(); 

            Hashtable keyToNamespaceTable = (Hashtable)info.GetValue("__keyToNamespaceTable", typeof(Hashtable));
            ArrayList paramNames = (ArrayList)info.GetValue("__paramNameList", typeof(ArrayList));
            SoapFault soapFault = (SoapFault)info.GetValue("__fault", typeof(SoapFault));

            if (soapFault != null)
                    {
                ServerFault serverFault = soapFault.Detail as ServerFault;
                if (null != serverFault)
                {
                    // Server Fault information
                    if (serverFault.Exception != null)
                        fault = serverFault.Exception;
                    else
                    {
                        Type exceptionType = RuntimeType.GetTypeInternal(serverFault.ExceptionType, false, false, false);
                        if (exceptionType == null)
                        {
                            // Exception type cannot be resolved, use a ServerException
                            StringBuilder sb = new StringBuilder();
                            sb.Append("\nException Type: ");
                            sb.Append(serverFault.ExceptionType);
                            sb.Append("\n");
                            sb.Append("Exception Message: ");
                            sb.Append(serverFault.ExceptionMessage);
                            sb.Append("\n");
                            sb.Append(serverFault.StackTrace);
                            fault = new ServerException(sb.ToString());
                        }
                        else 
                        {
                            // Exception type can be resolved, throw the exception
                            Object[] args = {serverFault.ExceptionMessage};
                            fault = (Exception)Activator.CreateInstance(
                                                    exceptionType, 
                                                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, 
                                                    null, 
                                                    args, 
                                                    null, 
                                                    null);
                        }
                    }
                }
                else if ((soapFault.Detail != null) && (soapFault.Detail.GetType() == typeof(String)) && (!(((String)soapFault.Detail).Length == 0)))
                {
                    fault = new ServerException((String)soapFault.Detail);
                }
                else
                {
                    fault = new ServerException(soapFault.FaultString);
                }

                return;
            }

            MethodInfo mi = MI as MethodInfo;
            int paramNameIndex = 0;
            if (mi != null)
            {
                Type retType = mi.ReturnType;
                if (retType != typeof(void))
                {
                    paramNameIndex++;
                    Object returnValue = info.GetValue((String)paramNames[0], typeof(Object));
                    if (returnValue is String)
                        retVal = Message.SoapCoerceArg(returnValue, retType, keyToNamespaceTable);
                    else
                        retVal = returnValue;
                }
            }

            // populate the args array
            ParameterInfo[] pinfos = _methodCache.Parameters;

            Object fUnordered = (InternalProperties == null) ? null : InternalProperties["__UnorderedParams"];
            if (fUnordered != null &&
                (fUnordered is System.Boolean) && 
                (true == (bool)fUnordered))
            {
                // Unordered
                for (int i=paramNameIndex; i<paramNames.Count; i++)
                {
                    String memberName = (String)paramNames[i];

                    // check for the parameter name

                    int position = -1;
                    for (int j=0; j<pinfos.Length; j++)
                    {
                        if (memberName.Equals(pinfos[j].Name))
                        {
                            position = pinfos[j].Position;
                        }
                    }

                    // no name so check for well known name

                    if (position == -1)
                    {
                        if (!memberName.StartsWith("__param"))
                        {
                            throw new RemotingException(
                                Environment.GetResourceString(
                                    "Remoting_Message_BadSerialization"));
                        }
                        position = Int32.Parse(memberName.Substring(7));
                    }

                    // if still not resolved then throw

                    if (position >= argCount)
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_Message_BadSerialization"));
                    }

                    // store the arg in the parameter array

                    if (outArgs == null)
                    {
                        outArgs = new Object[argCount];
                    }
                    outArgs[position]= Message.SoapCoerceArg(info.GetValue(memberName, typeof(Object)), pinfos[position].ParameterType, keyToNamespaceTable);
                }
            }
            else
            {                
                // ordered
                if (argMapper == null) argMapper = new ArgMapper(this, true);
                for (int j=paramNameIndex; j<paramNames.Count; j++)
                {
                    String memberName = (String)paramNames[j];
                    if (outArgs == null)
                    {
                        outArgs = new Object[argCount];
                    }

                    int position = argMapper.Map[j-paramNameIndex];
                    outArgs[position] = Message.SoapCoerceArg(info.GetValue(memberName, typeof(Object)), pinfos[position].ParameterType, keyToNamespaceTable);
                }
            }
        } // SetObjectFromSoapData



        internal LogicalCallContext GetLogicalCallContext()
        {
            if (callContext == null)
                callContext = new LogicalCallContext();
            return callContext;
        }

        internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx)
        {
            LogicalCallContext old=callContext;
            callContext=ctx;
            return old;
        }

        //
        // IMethodReturnMessage
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.Uri"]/*' />
        /// <internalonly/>
        public String Uri                             { get {return uri;} set {uri = value;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.MethodName"]/*' />
        /// <internalonly/>
        public String MethodName                      { get {return methodName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.TypeName"]/*' />
        /// <internalonly/>
        public String TypeName                        { get {return typeName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.MethodSignature"]/*' />
        /// <internalonly/>
        public Object MethodSignature                 { get {return methodSignature;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.MethodBase"]/*' />
        /// <internalonly/>
        public MethodBase MethodBase                  { get {return MI;}}

        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.HasVarArgs"]/*' />
        /// <internalonly/>
        public bool   HasVarArgs                      
        { 
            get {
                // Var args nyi..
                return false;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.ArgCount"]/*' />
	/// <internalonly/>
        public int ArgCount
        { 
            get 
            {
                if (outArgs == null)
                    return 0;
                else                
                    return outArgs.Length;
            }
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.GetArg"]/*' />
	/// <internalonly/>
        public Object GetArg(int argNum)              {return outArgs[argNum];}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.GetArgName"]/*' />
	/// <internalonly/>
        public String GetArgName(int index)           
        {
            if (MI != null)
            {
                RemotingMethodCachedData methodCache = InternalRemotingServices.GetReflectionCachedData(MI);
                ParameterInfo[] paramInfo = methodCache.Parameters;
                if (index < 0 || index >= paramInfo.Length)
                    throw new ArgumentOutOfRangeException();
                
                return methodCache.Parameters[index].Name;
            }
            else
                return "__param" + index;
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.Args"]/*' />
	/// <internalonly/>
        public Object[] Args                          { get {return outArgs;}}

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.OutArgCount"]/*' />
	/// <internalonly/>
        public int OutArgCount                        
        { 
            get 
            {
                if (argMapper == null) argMapper = new ArgMapper(this, true);
                return argMapper.ArgCount;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.GetOutArg"]/*' />
	/// <internalonly/>
        public Object  GetOutArg(int argNum)   
        {   
            if (argMapper == null) argMapper = new ArgMapper(this, true);
            return argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.GetOutArgName"]/*' />
	/// <internalonly/>
        public String GetOutArgName(int index) 
        { 
            if (argMapper == null) argMapper = new ArgMapper(this, true);
            return argMapper.GetArgName(index);
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.OutArgs"]/*' />
	/// <internalonly/>
        public Object[] OutArgs                       
        {
            get
            {
                if (argMapper == null) argMapper = new ArgMapper(this, true);
                return argMapper.Args;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.Exception"]/*' />
	/// <internalonly/>
        public Exception Exception                    { get {return fault;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.ReturnValue"]/*' />
	/// <internalonly/>
        public Object ReturnValue                     { get {return retVal;}}


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.Properties"]/*' />
	/// <internalonly/>
        public virtual IDictionary Properties
        {
            get
            {
                lock(this)
                {
                    if (InternalProperties == null)
                    {
                        InternalProperties = new Hashtable();
                    }
                    if (ExternalProperties == null)
                    {
                        ExternalProperties = new MRMDictionary(this, InternalProperties);
                    }
                    return ExternalProperties;
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.LogicalCallContext"]/*' />
	/// <internalonly/>
        public LogicalCallContext LogicalCallContext { get { return GetLogicalCallContext();} }

        //
        // helpers
        //
        internal void FillHeaders(Header[] h)
        {
            FillHeaders(h, false);
        } // FillHeaders

        
        private void FillHeaders(Header[] h, bool bFromHeaderHandler)
        {
            if (h == null)
                return;
        
            if (bFromHeaderHandler && fSoap)
            {            
                // Handle the case of headers coming off the wire in SOAP.

                // look for message properties
                int co;
                for (co = 0; co < h.Length; co++)
                {
                    Header header = h[co];
                    if (header.HeaderNamespace == "http://schemas.microsoft.com/clr/soap/messageProperties")
                    {
                        // add property to the message
                        FillHeader(header.Name, header.Value);
                    }
                    else
                    {
                        // add header to the message as a header
                        String name = LogicalCallContext.GetPropertyKeyForHeader(header);
                        FillHeader(name, header);
                    }
                }
            }
            else
            {        
                for (int i=0; i<h.Length; i++)
                {
                    FillHeader(h[i].Name, h[i].Value);
                }
            }
        } // FillHeaders
        

        internal virtual void FillHeader(String name, Object value)
        {
            Message.DebugOut("MethodCall::FillHeaders: name: " + (name == null ? "NULL" : name) + "\n");
            Message.DebugOut("MethodCall::FillHeaders: Value.GetClass: " + (value == null ? "NULL" : value.GetType().FullName) + "\n");
            Message.DebugOut("MethodCall::FillHeaders: Value.ToString: " + (value == null ? "NULL" : value.ToString()) + "\n");

            if (name.Equals("__MethodName"))
            {
                methodName = (String) value;
            }
            else if (name.Equals("__Uri"))
            {
                uri = (String) value;
            }
            else if (name.Equals("__MethodSignature"))
            {
                methodSignature = (Type[]) value;
            }
            else if (name.Equals("__TypeName"))
            {
                typeName = (String) value;
            }
            else if (name.Equals("__OutArgs"))
            {
                outArgs = (Object[]) value;
            }
            else if (name.Equals("__CallContext"))
            {
                // if the value is a string, then its the LogicalCallId
                if (value is String)
                {
                    callContext = new LogicalCallContext();
                    callContext.RemotingData.LogicalCallID = (String) value;
                }
                else
                    callContext = (LogicalCallContext) value;
            }
            else if (name.Equals("__Return"))
            {
                retVal = value;
            }
            else
            {
                if (InternalProperties == null)
                {
                    InternalProperties = new Hashtable();
                }
                InternalProperties[name] = value;
            }
        }

        //
        // IInternalMessage
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.IInternalMessage.ServerIdentityObject"]/*' />
        /// <internalonly/>
        ServerIdentity IInternalMessage.ServerIdentityObject
        {
            get { return null; }
            set {}
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.IInternalMessage.IdentityObject"]/*' />
        /// <internalonly/>
        Identity IInternalMessage.IdentityObject
        {
            get { return null;}
            set {}
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.IInternalMessage.SetURI"]/*' />
        /// <internalonly/>
        void IInternalMessage.SetURI(String val)
        {
            uri = val;
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.IInternalMessage.SetCallContext"]/*' />
        /// <internalonly/>
        void IInternalMessage.SetCallContext(LogicalCallContext newCallContext)
        {
            callContext = newCallContext;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodResponse.IInternalMessage.HasProperties"]/*' />
        /// <internalonly/>
        bool IInternalMessage.HasProperties()
        {
            return (ExternalProperties != null) || (InternalProperties != null);
        }
        
    } // class MethodResponse

    internal interface ISerializationRootObject
    {
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
        void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
    }

    [Serializable]
    internal class SerializationMonkey : ISerializable, IFieldInfo
    {
        internal ISerializationRootObject       _obj;
		internal String[] fieldNames = null;
		internal Type[] fieldTypes = null;

        internal SerializationMonkey(SerializationInfo info, StreamingContext ctx)
        {
            _obj.RootSetObjectData(info, ctx);
        }

	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            throw new NotSupportedException(
                Environment.GetResourceString(
                    "NotSupported_Method"));
        }

		public String[] FieldNames
		{
			get {return fieldNames;}
			set {fieldNames = value;}
		}

		public Type[] FieldTypes
		{
			get {return fieldTypes;}
			set {fieldTypes = value;}
		}

				
    }

    //+================================================================================
    //
    // Synopsis:   Message used for deserialization of a method construction
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionResponse"]/*' />
    /// <internalonly/>
    [Serializable,CLSCompliant(false)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class ConstructionResponse : MethodResponse, IConstructionReturnMessage
    {
        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionResponse.ConstructionResponse"]/*' />
	/// <internalonly/>
        public ConstructionResponse(Header[] h, IMethodCallMessage mcm) : base(h, mcm) {}
        internal ConstructionResponse(SerializationInfo info, StreamingContext context) : base (info, context) {}

        /// <include file='doc\Message.uex' path='docs/doc[@for="ConstructionResponse.Properties"]/*' />
	/// <internalonly/>
        public override IDictionary Properties
        {
            get
            {
                lock(this)
                {
                    if (InternalProperties == null)
                    {
                        InternalProperties = new Hashtable();
                    }
                    if (ExternalProperties == null)
                    {
                        ExternalProperties = new CRMDictionary(this, InternalProperties);
                    }
                    return ExternalProperties;
                }
            }
        }
    }

    // This is a special message used for helping someone make a transition
    // into a Context (or AppDomain) and back out. This is intended as a replacement
    // of the callBack object mechanism which is expensive since it involves
    // 2 round trips (one to get the callback object) and one to make the call
    // on it. Furthermore the callBack object scheme in cross domain cases would
    // involve unnecessary marshal/unmarshal-s of vari'ous callBack objects.
    //
    // We implement IInternalMessage and do our own magic when various
    // infrastructure sinks ask for serverID etc. Bottomline intent is to make
    // everything look like a complete remote call with all the entailing transitions
    // and executing some delegate in another context (or appdomain) without
    // actually having a proxy to call "Invoke" on or a server object to "Dispatch"
    // on.
    [Serializable()]
    internal class TransitionCall
        :IMessage, IInternalMessage, IMessageSink, ISerializable
    {
        IDictionary _props;             // For IMessage::GetDictionary
        int _sourceCtxID;               // Where the request emerged
        int _targetCtxID;               // Where the request should execute
        int _targetDomainID;            // Non zero if we are going to another domain
        ServerIdentity _srvID;          // cooked up serverID
        Identity _ID;                   // cooked up ID

        CrossContextDelegate _delegate; // The delegate to execute for the cross context case
        int _eeData; // Used for DoCallbackInEE

        // The _delegate should really be on an agile object otherwise
        // the whole point of doing a callBack is moot. However, even if it
        // is not, remoting and serialization together will ensure that
        // everything happens as expected and there is no smuggling.

        internal TransitionCall(
            int targetCtxID, 
            CrossContextDelegate deleg)
        {
            BCLDebug.Assert(targetCtxID!=0, "bad target ctx for call back");
            _sourceCtxID = Thread.CurrentContext.InternalContextID;
            _targetCtxID = targetCtxID;
            _delegate = deleg;
            _targetDomainID = 0;
            _eeData = 0;

            // We are going to another context in the same app domain
            _srvID = new ServerIdentity(
                null, 
                Thread.GetContextInternal(_targetCtxID));
            _ID = _srvID;
            _ID.RaceSetChannelSink(CrossContextChannel.MessageSink);
            _srvID.RaceSetServerObjectChain(this);
                
            //DBG Console.WriteLine("### TransitionCall ctor: " + Int32.Format(_sourceCtxID,"x") + ":" + Int32.Format(_targetCtxID,"x"));
        } // TransitionCall


        // This constructor should be used for cross appdomain case.
        internal TransitionCall(int targetCtxID, int eeData, int targetDomainID)
        {
            BCLDebug.Assert(targetCtxID !=0, "bad target ctx for call back");
            BCLDebug.Assert(targetDomainID !=0, "bad target ctx for call back");

            _sourceCtxID = Thread.CurrentContext.InternalContextID;
            _targetCtxID = targetCtxID;
            _delegate = null;
            _targetDomainID = targetDomainID;
            _eeData = eeData;
            

            // In the cross domain case, the client side just has a base Identity
            // and the server domain has the Server identity. We fault in the latter
            // when requested later.

            // We are going to a context in another app domain
            _srvID = null;
            _ID = new Identity("TransitionCallURI", null);

            // Cook up the data needed for the channel sink creation
            CrossAppDomainData data = 
                new CrossAppDomainData(
                    _targetCtxID,
                    _targetDomainID,
                    Identity.ProcessGuid);
            String unUsed;
            IMessageSink channelSink =
            CrossAppDomainChannel.AppDomainChannel.CreateMessageSink(
                null, //uri
                data, //channelData
                out unUsed);//out objURI

            BCLDebug.Assert(channelSink != null, "X-domain transition failure");
            _ID.RaceSetChannelSink(channelSink);
        } // TransitionCall
        

        internal TransitionCall(SerializationInfo info, StreamingContext context) 
        {
            if (info == null || (context.State != StreamingContextStates.CrossAppDomain))
            {
                throw new ArgumentNullException("info");
            }
            
            _props = (IDictionary)info.GetValue("props", typeof(IDictionary));
            _delegate = (CrossContextDelegate) info.GetValue("delegate", typeof(CrossContextDelegate));            
            _sourceCtxID  = info.GetInt32("sourceCtxID");
            _targetCtxID  = info.GetInt32("targetCtxID");
            _eeData = info.GetInt32("eeData");
            
            _targetDomainID = info.GetInt32("targetDomainID");
            BCLDebug.Assert(_targetDomainID != 0, "target domain should be non-zero");
        }

        //IMessage::GetProperties
        public IDictionary Properties
        {
            get
            {
                if (_props == null)
                {
                    lock(this)
                    {
                        if (_props == null)
                        {
                            _props = new Hashtable();
                        }
                    }
                }
                return _props;
            }
        }

        //IInternalMessage::ServerIdentityObject
        ServerIdentity IInternalMessage.ServerIdentityObject
        {
            get
            {
                if ( (_targetDomainID!=0) && _srvID == null)
                {
                    // We should now be in the target context! (We should not be
                    // attempting to get the server identity in the client domain).
                    BCLDebug.Assert(Thread.CurrentContext.InternalContextID
                                        == _targetCtxID,
                                "ServerID requested in wrong appDomain!");
                    lock(this)
                    {
                        /*DBG Console.WriteLine("### Get SrvID: thrdCtxID== " + Int32.Format(Thread.CurrentContext.InternalContextID,"x"));
                        Console.WriteLine("### Get SrvID: _targetCtxID" + Int32.Format(_targetCtxID,"x")); DBG*/

                        // NOTE: if we don't have a managed context object 
                        // corresponding to the targetCtxID ... we just use 
                        // the default context for the AppDomain. This could 
                        // be a problem if by some means we could have
                        // a non-default target VM context without a managed
                        // context object associated with it.
                        Context ctx = Thread.GetContextInternal(_targetCtxID);                        
                        if (ctx == null)
                        {
                            ctx = Context.DefaultContext;                            
                        }
                        BCLDebug.Assert(ctx != null, "Null target context unexpected!");
                        _srvID = new ServerIdentity(
                                    null,
                                    Thread.GetContextInternal(_targetCtxID));

                        _srvID.RaceSetServerObjectChain(this);
                    }
                }
                return _srvID;
            }
            set
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));
            }
        }

        //IInternalMessage::IdentityObject
        Identity IInternalMessage.IdentityObject 
        { 
            get
            {
                return _ID;
            }
            set
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));
            }
        }

        //IInternalMessage::SetURI
        void IInternalMessage.SetURI(String uri)
        {
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));
        }

        
        void IInternalMessage.SetCallContext(LogicalCallContext callContext)
        {
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));
        }

        bool IInternalMessage.HasProperties()
        {
            throw new RemotingException(
                Environment.GetResourceString(
                    "Remoting_Default"));
        }


        //IMessage::SyncProcessMessage
        public IMessage SyncProcessMessage(IMessage msg)
        {
            BCLDebug.Assert(
                Thread.CurrentContext.InternalContextID == _targetCtxID,
                "Transition message routed to wrong context");

            try
            {
                LogicalCallContext oldcctx = Message.PropagateCallContextFromMessageToThread(msg);
                if (_delegate != null)
                {
                    _delegate();            
                }
                else
                {
                    // This is the cross appdomain case, so we need to construct
                    //   the delegate and call on it.
                    CallBackHelper cb = new CallBackHelper(
                                            _eeData,
                                            true /*fromEE*/,
                                            _targetDomainID); 
                    CrossContextDelegate ctxDel = new CrossContextDelegate(cb.Func);
                    ctxDel(); 
                }
                Message.PropagateCallContextFromThreadToMessage(msg, oldcctx);
            }

            catch (Exception e)
            {
                ReturnMessage retMsg = new ReturnMessage(e, new ErrorMessage());
                retMsg.SetLogicalCallContext(
                    (LogicalCallContext) msg.Properties[Message.CallContextKey]);
                return retMsg;
            }

            return this;    
        }

        //IMessage::AsyncProcessMessage
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            IMessage retMsg = SyncProcessMessage(msg);
            replySink.SyncProcessMessage(retMsg);
            return null;
        }

        //IMessage::GetNextSink()
        public IMessageSink NextSink
        {
            get{return null;}
        }

        //ISerializable::GetObjectData
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null || (context.State != StreamingContextStates.CrossAppDomain))
            {
                throw new ArgumentNullException("info");
            }
            info.AddValue("props", _props, typeof(IDictionary));
            info.AddValue("delegate", _delegate, typeof(CrossContextDelegate));
            info.AddValue("sourceCtxID", _sourceCtxID);
            info.AddValue("targetCtxID", _targetCtxID);
            info.AddValue("targetDomainID", _targetDomainID);
            info.AddValue("eeData", _eeData);
        }

    }// class TransitionCall

    internal class ArgMapper
    {
        int[] _map;
        IMethodMessage _mm;
        RemotingMethodCachedData _methodCachedData;

        internal ArgMapper(IMethodMessage mm, bool fOut)
        {
            _mm = mm;
            MethodBase mb = (MethodBase)_mm.MethodBase;
            _methodCachedData = 
                InternalRemotingServices.GetReflectionCachedData(mb);

            if (fOut)
                _map = _methodCachedData.MarshalResponseArgMap;
            else
                _map = _methodCachedData.MarshalRequestArgMap;
        } // ArgMapper

        internal ArgMapper(MethodBase mb, bool fOut)
        {
            _methodCachedData = 
                InternalRemotingServices.GetReflectionCachedData(mb);

            if (fOut)
                _map = _methodCachedData.MarshalResponseArgMap;
            else
                _map = _methodCachedData.MarshalRequestArgMap;
        } // ArgMapper

        
        internal int[] Map
        { 
            get { return _map; }
        }
            
        internal int ArgCount                        
        { 
            get 
            {
            if (_map == null) 
            {
                return 0;
            }
            else
            {
                return _map.Length;
            }
            }
        }
            
        internal Object  GetArg(int argNum)   
        { 
            
            if (_map == null || argNum < 0 || argNum >= _map.Length) 
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
            else
            {
                return _mm.GetArg(_map[argNum]);
            }
        }

        internal String GetArgName(int argNum) 
        { 
            if (_map == null || argNum < 0 || argNum >= _map.Length) 
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "InvalidOperation_InternalState"));
            }
            else
            {
                return _mm.GetArgName(_map[argNum]);
            }
        }

        internal Object[] Args                       
        {
            get 
            {
                if (_map == null)
                {
                    return null;
                }
                else
                {
                    Object[] ret = new Object[_map.Length];
                    for(int i=0; i<_map.Length; i++) 
                    {
                    ret[i] = _mm.GetArg(_map[i]);
                    }
                    return ret;
                }
            }
        }

        internal Type[] ArgTypes
        {
            get
            {
                Type[] ret = null;
                if (_map != null)
                {
                    ParameterInfo[] pi = _methodCachedData.Parameters;
                    ret = new Type[_map.Length];
                    for (int i=0; i<_map.Length; i++)
                    {
                        ret[i] = pi[_map[i]].ParameterType;
                    }
                }
                return ret;
            }
        }

        internal String[] ArgNames
        {
            get
            {
                String[] ret = null;
                if (_map != null)
                {
                    ParameterInfo[] pi = _methodCachedData.Parameters;
                    ret = new String[_map.Length];
                    for (int i=0; i<_map.Length; i++)
                    {
                        ret[i] = pi[_map[i]].Name;
                    }
                }
                return ret;
            }
        }


        //
        // Helper functions for getting argument maps
        //

        internal static void GetParameterMaps(ParameterInfo[] parameters,
                                              out int[] inRefArgMap,
                                              out int[] outRefArgMap,
                                              out int[] outOnlyArgMap,
                                              out int[] nonRefOutArgMap,
                                              out int[] marshalRequestMap,
                                              out int[] marshalResponseMap)
        {
            int co;
        
            int inRefCount = 0;
            int outRefCount = 0;
            int outOnlyCount = 0;
            int nonRefOutCount = 0;

            int marshalRequestCount = 0;
            int marshalResponseCount = 0;
            int[] tempMarshalRequestMap = new int[param