ULT
CHsmSessionTotals::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmSessionTotals::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 4 * WsbPersistSizeOf(LONGLONG) + WsbPersistSizeOf(ULONG);

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // pSize->QuadPart += 2 * WsbPersistSizeOf(LONGLONG);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmSessionTotals::GetStats(
    OUT LONGLONG* pItems,
    OUT LONGLONG* pSize,
    OUT LONGLONG* pSkippedItems,
    OUT LONGLONG* pSkippedSize,
    OUT LONGLONG* pErrorItems,
    OUT LONGLONG* pErrorSize
    )
/*++

Implements:

  IHsmSessionTotals::GetStats().

--*/
{
    HRESULT     hr = S_OK;

    if (0 != pItems) {
        *pItems = m_items;
    }

    if (0 != pSize) {
        *pSize = m_size;
    }

    if (0 != pSkippedItems) {
        *pSkippedItems = m_skippedItems;
    }

    if (0 != pSkippedSize) {
        *pSkippedSize = m_skippedSize;
    }

    if (0 != pErrorItems) {
        *pErrorItems = m_errorItems;
    }

    if (0 != pSize) {
        *pErrorSize = m_errorSize;
    }
    
    return(hr);
}


HRESULT
CHsmSessionTotals::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_action = static_cast<HSM_JOB_ACTION>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_items));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_size));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedItems));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedSize));
        
        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorItems));
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorSize));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmSessionTotals::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_action)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_items));
        WsbAffirmHr(WsbSaveToStream(pStream, m_size));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedItems));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedSize));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorItems));
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorSize));
        
        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::SetAction(
    IN HSM_JOB_ACTION action
    )
/*++

Implements:

  IHsmSessionTotals::SetAction().

--*/
{
    m_action = action;

    return(S_OK);
}


HRESULT
CHsmSessionTotals::SetStats(
    IN LONGLONG items,
    IN LONGLONG size,
    IN LONGLONG skippedItems,
    IN LONGLONG skippedSize,
    IN LONGLONG errorItems,
    IN LONGLONG errorSize
    )
/*++

Implements:

  IHsmSessionTotals::SetStats().

--*/
{
    m_items = items;
    m_size = size;
    m_skippedItems = skippedItems;
    m_skippedSize = skippedSize;
    m_errorItems = errorItems;
    m_errorSize = errorSize;

    return(S_OK);
}


HRESULT
CHsmSessionTotals::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmsess.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsess.cpp

Abstract:

    This module contains the session component. The session is the collator of information for the work being done on
    a resource (for a job, demand recall, truncate, ...).

Author:

    Chuck Bardeen   [cbardeen]   18-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "HsmSess.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmSession::AdviseOfEvent(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryEvent>      pSink;

    try {

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IUnknown*)(IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionEvent(((IHsmSession*) this), phase, event));
            } WsbCatchAndDo(hr2, ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfItem(
    IN IHsmPhase* pPhase,
    IN IFsaScanItem* pScanItem,
    IN HRESULT hrItem,
    IN IHsmSessionTotals* pSessionTotals
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    FILETIME                                currentTime;
    LONGLONG                                advisedInterval;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryItem>       pSink;
    CComPtr<IHsmSessionSinkSomeItems>       pSink2;
    HSM_JOB_PHASE                           phase;

    try {

        // For the item there are two ways to tell, so both need to be checked.

        // Tell those who want to know about every single file.
        WsbAffirmHr(((IUnknown*)(IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryItem, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while (pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryItem, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionItem(((IHsmSession*) this), pPhase, pScanItem, hrItem, pSessionTotals));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }
        pCPC = 0;
        pCP = 0;
        pConnection = 0;


        // If we haven't told them withing the interval, then tell those who want to know about some of the files.
        GetSystemTimeAsFileTime(&currentTime);
        advisedInterval = ((currentTime.dwHighDateTime - m_lastAdviseFile.dwHighDateTime) << 32) + (currentTime.dwLowDateTime - m_lastAdviseFile.dwLowDateTime);

        if ((advisedInterval) > m_adviseInterval) {
            m_lastAdviseFile = currentTime;

            WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkSomeItems, &pCP));
            WsbAffirmHr(pCP->EnumConnections(&pConnection));

            while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

                // We don't care if the sink has problems (it's their problem).
                try {
                    WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkSomeItems, (void**) &pSink2));
                    WsbAffirmHr(pSink2->ProcessSessionItem(((IHsmSession*) this), pPhase, pScanItem, hrItem, pSessionTotals));
                } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

                WsbAffirmHr((pConnectData.pUnk)->Release());
                pSink2=0;
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfMediaState(
    IN IHsmPhase* pPhase,
    IN HSM_JOB_MEDIA_STATE state,
    IN OLECHAR* mediaName,
    IN HSM_JOB_MEDIA_TYPE mediaType,
    IN ULONG time
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryMediaState> pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new media state for the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryMediaState, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryMediaState, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionMediaState(((IHsmSession*) this), pPhase, state, mediaName, mediaType, time));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfPriority(
    IN IHsmPhase* pPhase
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryPriority>   pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new priority of a phase of the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryPriority, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryPriority, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionPriority(((IHsmSession*) this), pPhase));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfState(
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryState>      pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionState(((IHsmSession*) this), pPhase, currentPath));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Cancel(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Cancel().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_CANCEL));
}


HRESULT
CHsmSession::EnumPhases(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPhases->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::EnumTotals(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pTotals->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::FinalConstruct"), OLESTR("this = %p"),
               this);
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_hsmId = GUID_NULL;
        m_adviseInterval = 10000;
        m_runId = 0;
        m_subRunId = 0;
        m_state = HSM_JOB_STATE_IDLE;
        m_activePhases = 0;
        m_lastAdviseFile.dwHighDateTime = 0;
        m_lastAdviseFile.dwLowDateTime = 0;
        m_logControl = HSM_JOB_LOG_NORMAL;
        m_isCanceling = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        // Create the phase and totals collections.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPhases));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pTotals));

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmSession::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmSession::FinalRelease(
    void
    )

/*++

Implements:

  CHsmSession::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmSession::FinalRelease"), OLESTR("this = %p"),
               this);

    CWsbObject::FinalRelease();
    iCount--;

    WsbTraceOut(OLESTR("CHsmSession::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmSession::GetAdviseInterval(
    OUT LONGLONG* pInterval
    )

/*++

Implements:

  IHsmSession::GetAdviseInterval().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pInterval, E_POINTER);
        *pInterval = m_adviseInterval;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmSession;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmSession::GetHsmId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmSession::GetHsmId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_hsmId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmSession::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetJob(
    OUT IHsmJob** ppJob
    )

/*++

Implements:

  IHsmSession::GetJob().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppJob, E_POINTER);
        *ppJob = m_pJob;
        if (m_pJob != 0)  {
            m_pJob.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetName(
    OLECHAR** pName,
    ULONG bufferSize
    )

/*++

Implements:

  IHsmSession::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetResource(
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IHsmSession::GetResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        *ppResource = m_pResource;
        if (m_pResource != 0)  {
            m_pResource.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetRunId(
    OUT ULONG* pId
    )

/*++

Implements:

  IHsmSession::GetRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_runId;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmSession::GetSubRunId(
    OUT ULONG* pId
    )

/*++

Implements:

  IHsmSession::GetSubRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_subRunId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::GetSizeMax"), OLESTR(""));

    pSize->QuadPart = 0;
    hr = E_NOTIMPL;

    WsbTraceOut(OLESTR("CHsmSession::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmSession::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSession::Pause(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Pause().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_PAUSE));
}


HRESULT
CHsmSession::ProcessEvent(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

Implements:

  IHsmSession::ProcessEvent().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;

    try {

        // Tell everyone about the new event, but don't return an error if this fails.
        try {
            WsbAffirmHr(AdviseOfEvent(phase, event));
        } WsbCatchAndDo(hr2, ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessHr(
    IN HSM_JOB_PHASE phase,
    IN CHAR* file,
    IN ULONG line,
    IN HRESULT inHr
    )

/*++

Implements:

  IHsmSession::ProcessHr().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CWsbStringPtr               phaseName;
    CWsbStringPtr               resourceName;
    CWsbStringPtr               fileName = file;

    UNREFERENCED_PARAMETER(line);

    try {

        if ((m_logControl & HSM_JOB_LOG_HR) != 0) {

            WsbAffirmHr(EnumPhases(&pEnum));
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
            WsbAffirmHr(pPhasePriv->SetPhase(phase));
            WsbAffirmHr(pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv));
            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));

            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));

            // If no file was specified, then don't display the file and line number.
            if ((0 == file) || (0 == *file)) {
                WsbLogEvent(JOB_MESSAGE_SESSION_ERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbHrAsString(inHr), NULL);
            } else {
#ifdef DBG
                WsbLogEvent(JOB_MESSAGE_SESSION_INTERNALERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, (OLECHAR*) fileName, WsbLongAsString(line), WsbHrAsString(inHr), NULL);
#else
                WsbLogEvent(JOB_MESSAGE_SESSION_ERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbHrAsString(inHr), NULL);
#endif
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessItem(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_ACTION action,
    IN IFsaScanItem* pScanItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmSession::ProcessItem().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;
    CWsbStringPtr                   itemPath;
    CWsbStringPtr                   phaseName;
    CWsbStringPtr                   resourceName;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmPhasePriv>          pPhasePriv;
    CComPtr<IHsmPhasePriv>          pFoundPhasePriv;
    CComPtr<IHsmPhase>              pFoundPhase;
    CComPtr<IHsmSessionTotalsPriv>  pTotalsPriv;
    CComPtr<IHsmSessionTotalsPriv>  pFoundTotalsPriv;
    CComPtr<IHsmSessionTotals>      pFoundTotals;

    try {

        // Update the phase.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->AddItem(pScanItem, hrItem));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else if (SUCCEEDED(hr)) {
            WsbAffirmHr(pFoundPhasePriv->AddItem(pScanItem, hrItem));
        }
        pEnum = 0;

        // Update the session totals.
        WsbAffirmHr(EnumTotals(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotalsPriv, (void**) &pTotalsPriv));
        WsbAffirmHr(pTotalsPriv->SetAction(action));
        hr = pEnum->Find(pTotalsPriv, IID_IHsmSessionTotalsPriv, (void**) &pFoundTotalsPriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pTotalsPriv->AddItem(pScanItem, hrItem));
            WsbAffirmHr(m_pTotals->Add(pTotalsPriv));
            pFoundTotalsPriv = pTotalsPriv;
        } else if (SUCCEEDED(hr)) {
            WsbAffirmHr(pFoundTotalsPriv->AddItem(pScanItem, hrItem));
        }

        // If we had a error (other than just some information ones from the scanner), then
        // log it.
        if (((m_logControl & HSM_JOB_LOG_ITEMALL) != 0) ||
            (((m_logControl & HSM_JOB_LOG_ITEMALLFAIL) != 0) && FAILED(hrItem)) ||
            (((m_logControl & HSM_JOB_LOG_ITEMMOSTFAIL) != 0) &&
             (FAILED(hrItem) && (hrItem != JOB_E_FILEEXCLUDED) && (hrItem != JOB_E_DOESNTMATCH)))) {

            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));
            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));
            WsbAffirmHr(pScanItem->GetPathAndName(0, &itemPath,  0));

            WsbLogEvent(JOB_MESSAGE_SESSION_ITEM_SKIPPED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbAbbreviatePath(itemPath, 120), WsbHrAsString(hrItem), NULL);
        }

        // Tell everyone about the item.
        //
        // NOTE: We might want to clone the phase and session totals so that the don't get
        // updated before the called method gets a chance to look at them.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(pFoundTotalsPriv->QueryInterface(IID_IHsmSessionTotals, (void**) &pFoundTotals));
            WsbAffirmHr(AdviseOfItem(pFoundPhase, pScanItem, hrItem, pFoundTotals));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessMediaState(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_MEDIA_STATE state,
    IN OLECHAR* mediaName,
    IN HSM_JOB_MEDIA_TYPE mediaType,
    IN ULONG time
    )

/*++

Implements:

  IHsmSession::ProcessMediaState().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CComPtr<IHsmPhase>          pFoundPhase;

    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetMediaState(state));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetMediaState(state));
        }

        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfMediaState(pFoundPhase, state, mediaName, mediaType, time));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessPriority(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_PRIORITY priority
    )

/*++

Implements:

  IHsmSession::ProcessPriority().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmPhasePriv>          pPhasePriv;
    CComPtr<IHsmPhasePriv>          pFoundPhasePriv;
    CComPtr<IHsmPhase>              pFoundPhase;

    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetPriority(priority));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetPriority(priority));
        }

        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfPriority(pFoundPhase));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessState(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_STATE state,
    IN OLECHAR* currentPath,
    IN BOOL bLog
    )

/*++

Implements:

  IHsmSession::ProcessState().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhase>          pPhase;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhase>          pFoundPhase;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CComPtr<IHsmPhase>          pClonedPhase;
    CComPtr<IHsmPhasePriv>      pClonedPhasePriv;
    HSM_JOB_STATE               oldState;
    HSM_JOB_STATE               otherState;
    HSM_JOB_STATE               setState;
    BOOL                        shouldSet;
    LONGLONG                    items;
    LONGLONG                    skippedItems;
    LONGLONG                    errorItems;
    LONGLONG                    size;
    LONGLONG                    skippedSize;
    LONGLONG                    errorSize;
    ULONG                       days;
    USHORT                      hours;
    USHORT                      minutes;
    USHORT                      seconds;
    LONGLONG                    elapsedTime;
    OLECHAR                     itemsString[40];
    OLECHAR                     sizeString[40];
    OLECHAR                     skippedItemsString[40];
    OLECHAR                     skippedSizeString[40];
    OLECHAR                     errorItemsString[40];
    OLECHAR                     errorSizeString[40];
    OLECHAR                     durationString[40];
    OLECHAR                     itemRateString[40];
    OLECHAR                     byteRateString[40];
    CWsbStringPtr               resourceName;
    CWsbStringPtr               phaseName;

    WsbTraceIn(OLESTR("CHsmSession::ProcessState"), OLESTR("Phase = <%d>, State = <%d>, Path = <%ls>, pLog = <%s>"),
            phase, state, WsbAbbreviatePath(currentPath, (WSB_TRACE_BUFF_SIZE - 100)), WsbBoolAsString(bLog));
    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetState(state));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetState(state));
        }

        // Put something in the event log that indicates when is happening with the session.
        if (((m_logControl & HSM_JOB_LOG_STATE) != 0) && (bLog)) {
            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));
            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));
            WsbAffirmHr(pFoundPhasePriv->GetStats(&items, &size, &skippedItems, &skippedSize, &errorItems, &errorSize));
            WsbAffirmHr(pFoundPhasePriv->GetElapsedTime(&days, &hours, &minutes, &seconds));
            elapsedTime = max(1, ((LONGLONG) seconds) + 60 * (((LONGLONG) minutes) + 60 * (((LONGLONG) hours) + (24 * ((LONGLONG) days)))));

            swprintf(itemsString, OLESTR("%I64u"), items);
            swprintf(sizeString, OLESTR("%I64u"), size);
            swprintf(skippedItemsString, OLESTR("%I64u"), skippedItems);
            swprintf(skippedSizeString, OLESTR("%I64u"), skippedSize);
            swprintf(errorItemsString, OLESTR("%I64u"), errorItems);
            swprintf(errorSizeString, OLESTR("%I64u"), errorSize);
            swprintf(durationString, OLESTR("%2.2u:%2.2u:%2.2u"), hours + (24 * days), minutes, seconds);
            swprintf(itemRateString, OLESTR("%I64u"), items / elapsedTime);
            swprintf(byteRateString, OLESTR("%I64u"), size / elapsedTime);

            switch (state) {

                case HSM_JOB_STATE_STARTING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_STARTING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_RESUMING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_RESUMING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                // If one hits this state, then change the overall state to this value
                case HSM_JOB_STATE_ACTIVE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_ACTIVE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_CANCELLING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_CANCELLING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_PAUSING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_PAUSING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_SUSPENDING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SUSPENDING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_CANCELLED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_CANCELLED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_DONE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_DONE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_FAILED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_FAILED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_IDLE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_IDLE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_PAUSED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_PAUSED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_SUSPENDED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SUSPENDED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_SKIPPED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SKIPPED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                default:
                    break;
            }
        }


        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfState(pFoundPhase, currentPath));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););


        // We may need to generate the "HSM_JOB_PHASE_ALL" messages. This is the session
        // summary for all the phases.

        // Remember the state, and only send a message if the state changes. We also need some strings to
        // log messages.
        oldState = m_state;

        switch (state) {

            // If one hits this state, then change the overall state to this value.
            // Also increment the activePhases count.
            case HSM_JOB_STATE_STARTING:
                if (0 == m_activePhases) {
                    m_state = state;
                }
                m_activePhases++;
                break;

            case HSM_JOB_STATE_RESUMING:
                if (0 == m_activePhases) {
                    m_state = state;
                }
                m_activePhases++;
                break;

            // If one hits this state, then change the overall state to this value
            case HSM_JOB_STATE_ACTIVE:
                if ((HSM_JOB_STATE_STARTING == m_state) || (HSM_JOB_STATE_RESUMING == m_state)) {
                    m_state = state;
                }
                break;

            // If all change to this state, then change to this value.
            case HSM_JOB_STATE_CANCELLING:
            case HSM_JOB_STATE_PAUSING:
            case HSM_JOB_STATE_SUSPENDING:
                shouldSet = TRUE;
                for (hr2 = pEnum->First(IID_IHsmPhase, (void**) &pPhase);
                    SUCCEEDED(hr2) && shouldSet;
                    hr2 = pEnum->Next(IID_IHsmPhase, (void**) &pPhase)) {

                    WsbAffirmHr(pPhase->GetState(&otherState));
                    if ((state != otherState) && (HSM_JOB_STATE_SKIPPED != otherState)) {
                        shouldSet = FALSE;
                    }
                    pPhase = 0;
                }

                if (state == HSM_JOB_STATE_CANCELLING) {
                    // Some jobs might need to know that a phase is canceling
                    m_isCanceling = TRUE;
                }

                if (shouldSet) {
                    m_state = state;
                }
                break;

            // Decrement the the activePhases count. If all phases are in one of these states
            // (i.e. activeSessions count goes to 0), then change it to the "worst" state (first
            // in the follwing list) :
            //   1) Cancelled
            //   2) Failed
            //   3) Suspended
            //   4) Paused
            //   5) Idle
            //   6) Done
            case HSM_JOB_STATE_CANCELLED:
            case HSM_JOB_STATE_DONE:
            case HSM_JOB_STATE_FAILED:
            case HSM_JOB_STATE_IDLE:
            case HSM_JOB_STATE_PAUSED:
            case HSM_JOB_STATE_SUSPENDED:
                if (m_activePhases > 0) {
                    m_activePhases--;

                    if (m_activePhases == 0) {

                        shouldSet = FALSE;
                        setState = state;

                        for (hr2 = pEnum->First(IID_IHsmPhase, (void**) &pPhase);
                             SUCCEEDED(hr2);
                             hr2 = pEnum->Next(IID_IHsmPhase, (void**) &pPhase)) {

                            WsbAffirmHr(pPhase->GetState(&otherState));
                            switch (otherState) {
                                case HSM_JOB_STATE_CANCELLED:
                                    shouldSet = TRUE;
                                    setState = otherState;
                                    break;

                                case HSM_JOB_STATE_FAILED:
                                    if (HSM_JOB_STATE_CANCELLED != setState) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_SUSPENDED:
                                    if ((HSM_JOB_STATE_CANCELLED != setState) &&
                                        (HSM_JOB_STATE_FAILED != setState)) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_IDLE:
                                    if ((HSM_JOB_STATE_CANCELLED != setState) &&
                                        (HSM_JOB_STATE_FAILED != setState) &&
                                        (HSM_JOB_STATE_SUSPENDED != setState)) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_PAUSED:
                                    if (HSM_JOB_STATE_DONE == setState) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_DONE:
                                    if (HSM_JOB_STATE_DONE == setState) {
                                        shouldSet = TRUE;
                                    }
                                    break;

                                case HSM_JOB_STATE_ACTIVE:
                                case HSM_JOB_STATE_CANCELLING:
                                case HSM_JOB_STATE_PAUSING:
                                case HSM_JOB_STATE_RESUMING:
                                case HSM_JOB_STATE_SKIPPED:
                                case HSM_JOB_STATE_STARTING:
                                case HSM_JOB_STATE_SUSPENDING:
                                default:
                                    break;
                            }
                            pPhase = 0;
                        }

                        if (shouldSet) {
                            m_state = setState;
                        }
                    }
                }
                break;

            case HSM_JOB_STATE_SKIPPED:
                break;

            default:
                break;
        }

        if (oldState != m_state) {

            try {
                WsbAffirmHr(pFoundPhasePriv->Clone(&pClonedPhasePriv));
                WsbAffirmHr(pClonedPhasePriv->SetPhase(HSM_JOB_PHASE_ALL));
                WsbAffirmHr(pClonedPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pClonedPhase));
                WsbAffirmHr(AdviseOfState(pClonedPhase, currentPath));
            } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::ProcessState"), OLESTR("hr = <%ls>, State = <%d>, ActivePhases = <%lu>"), WsbHrAsString(hr), m_state, m_activePhases);
    return(hr);
}


HRESULT
CHsmSession::ProcessString(
    IN HSM_JOB_PHASE /*phase*/,
    IN OLECHAR* string
    )

/*++

Implements:

  IHsmSession::ProcessString().

--*/
{
    HRESULT                         hr = S_OK;

    try {

        // Don't know what to really do with it, but for now just print it.
        _putts(string);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Resume(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Resume().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_RESUME));
}


HRESULT
CHsmSession::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmSession::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSession::SetAdviseInterval(
    IN LONGLONG interval
    )

/*++

Implements:

  IHsmSession::SetAdviseInterval

--*/
{
    m_adviseInterval = interval;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmSession::Start(
    IN OLECHAR* name,
    IN ULONG logControl,
    IN GUID hsmId,
    IN IHsmJob* pJob,
    IN IFsaResource* pResource,
    IN ULONG runId,
    IN ULONG subRunId
    )

/*++

Implements:

  IHsmSession::Start().

--*/
{
    HRESULT                             hr = S_OK;

    try {

        WsbAssert(0 != pResource, E_POINTER);

        // You can only use a session once (i.e. no restart).
        WsbAssert(m_pResource == 0, E_UNEXPECTED);

        // Store the information that has been provided.
        m_logControl = logControl;
        m_name = name;
        m_hsmId = hsmId;
        m_runId = runId;
        m_subRunId = subRunId;

        m_pJob = pJob;
        m_pResource = pResource;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Suspend(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Suspend().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_SUSPEND));
}


HRESULT
CHsmSession::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmSession::IsCanceling(
    void
    )

/*++

Implements:

  IHsmSession::IsCanceling().

--*/
{
    HRESULT                     hr = S_FALSE;

    if (m_isCanceling) {
        hr = S_OK;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\job.cpp ===
// job.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for job.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          job_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f jobps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "task.h"
#include "hsmcrit.h"
#include "hsmactn.h"
#include "hsmacrsc.h"
#include "hsmjob.h"
#include "hsmjobcx.h"
#include "hsmjobdf.h"
#include "hsmjobwi.h"
#include "hsmphase.h"
#include "hsmpolcy.h"
#include "hsmrule.h"
#include "hsmrlstk.h"
#include "hsmscan.h"
#include "hsmsess.h"
#include "hsmsesst.h"

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CHsmActionCopy,  CHsmActionCopy)
    OBJECT_ENTRY(CLSID_CHsmActionDelete, CHsmActionDelete)
    OBJECT_ENTRY(CLSID_CHsmActionManage, CHsmActionManage)
    OBJECT_ENTRY(CLSID_CHsmActionMigrate, CHsmActionMigrate)
    OBJECT_ENTRY(CLSID_CHsmActionMove, CHsmActionMove)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreUnmanage, CHsmActionOnResourcePreUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePostUnmanage, CHsmActionOnResourcePostUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreScanUnmanage, CHsmActionOnResourcePreScanUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePostValidate, CHsmActionOnResourcePostValidate)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreValidate, CHsmActionOnResourcePreValidate)
    OBJECT_ENTRY(CLSID_CHsmActionRecall, CHsmActionRecall)
    OBJECT_ENTRY(CLSID_CHsmActionRecycle, CHsmActionRecycle)
    OBJECT_ENTRY(CLSID_CHsmActionTruncate, CHsmActionTruncate)
    OBJECT_ENTRY(CLSID_CHsmActionUnmanage, CHsmActionUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionValidate, CHsmActionValidate)

    OBJECT_ENTRY(CLSID_CHsmCritAccessTime, CHsmCritAccessTime)
    OBJECT_ENTRY(CLSID_CHsmCritAlways, CHsmCritAlways)
    OBJECT_ENTRY(CLSID_CHsmCritCompressed, CHsmCritCompressed)
    OBJECT_ENTRY(CLSID_CHsmCritLinked, CHsmCritLinked)
    OBJECT_ENTRY(CLSID_CHsmCritMbit, CHsmCritMbit)
    OBJECT_ENTRY(CLSID_CHsmCritManageable, CHsmCritManageable)
    OBJECT_ENTRY(CLSID_CHsmCritMigrated, CHsmCritMigrated)
    OBJECT_ENTRY(CLSID_CHsmCritPremigrated, CHsmCritPremigrated)
    OBJECT_ENTRY(CLSID_CHsmCritGroup, CHsmCritGroup)
    OBJECT_ENTRY(CLSID_CHsmCritLogicalSize, CHsmCritLogicalSize)
    OBJECT_ENTRY(CLSID_CHsmCritModifyTime, CHsmCritModifyTime)
    OBJECT_ENTRY(CLSID_CHsmCritOwner, CHsmCritOwner)
    OBJECT_ENTRY(CLSID_CHsmCritPhysicalSize, CHsmCritPhysicalSize)

    OBJECT_ENTRY(CLSID_CHsmJob, CHsmJob)
    OBJECT_ENTRY(CLSID_CHsmJobContext, CHsmJobContext)
    OBJECT_ENTRY(CLSID_CHsmJobDef, CHsmJobDef)
    OBJECT_ENTRY(CLSID_CHsmJobWorkItem, CHsmJobWorkItem)
    OBJECT_ENTRY(CLSID_CHsmPhase, CHsmPhase)
    OBJECT_ENTRY(CLSID_CHsmPolicy, CHsmPolicy)
    OBJECT_ENTRY(CLSID_CHsmRule, CHsmRule)
    OBJECT_ENTRY(CLSID_CHsmRuleStack, CHsmRuleStack)
    OBJECT_ENTRY(CLSID_CHsmScanner, CHsmScanner)
    OBJECT_ENTRY(CLSID_CHsmSession, CHsmSession)
    OBJECT_ENTRY(CLSID_CHsmSessionTotals, CHsmSessionTotals)

END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    // Not registering the Type Library right now
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
      _Module.UnregisterServer();
      CoUninitialize( );
      hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB
#include "wsb.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by job.rc
//
#define IDS_HSMACTIONCOPY_DESC          1
#define IDS_HSMACTIONDELETE_DESC        2
#define IDS_HSMACTIONMANAGE_DESC        3
#define IDS_HSMACTIONMIGRATE_DESC       4
#define IDS_HSMACTIONMOVE_DESC          5
#define IDS_HSMACTIONRECALL_DESC        6
#define IDS_HSMACTIONRECYCLE_DESC       7
#define IDS_HSMACTIONTRUNCATE_DESC      8
#define IDS_HSMACTIONUNMANAGE_DESC      9
#define IDS_HSMACTIONVALIDATE_DESC      10
#define IDS_HSMCRITACCESSTIME_DESC      11
#define IDS_HSMCRITALWAYS_DESC          12
#define IDS_HSMCRITCOMPRESSED_DESC      13
#define IDS_HSMCRITGROUP_DESC           14
#define IDS_HSMCRITLINKED_DESC          15
#define IDS_HSMCRITLOGICALSIZE_DESC     16
#define IDS_HSMCRITMBIT_DESC            17
#define IDS_HSMCRITMIGRATED_DESC        18
#define IDS_HSMCRITMANAGEABLE_DESC      19
#define IDS_HSMCRITMODIFYTIME_DESC      20
#define IDS_HSMCRITOWNER_DESC           21
#define IDS_HSMCRITPHYSICALSIZE_DESC    22
#define IDS_HSMCRITPREMIGRATED_DESC     23
#define IDS_HSMJOB_DESC                 24
#define IDS_HSMJOBDEF_DESC              25
#define IDS_HSMJOBCONTEXT_DESC          26
#define IDS_HSMPOLICY_DESC              27
#define IDS_HSMRULE_DESC                28
#define IDS_HSMJOBWORKITEM_DESC         29
#define IDS_HSMSCANNER_DESC             30
#define IDS_HSMSESSION_DESC             31
#define IDS_HSMPHASE_DESC               32
#define IDS_HSMSESSIONTOTALS_DESC       33
#define IDS_HSMRULESTACK_DESC           34

#define IDS_HSMJOBPHASEALL              60
#define IDS_HSMJOBPHASESCAN             61
#define IDS_HSMJOBPHASEFSAACTION        62
#define IDS_HSMJOBPHASEMOVEACTION       63
#define IDS_HSMJOBPHASEPOSTACTION       64

#define IDS_HSMJOBACTION_UNKNOWN        80
#define IDS_HSMJOBACTION_COPY           81
#define IDS_HSMJOBACTION_DELETE         82
#define IDS_HSMJOBACTION_MOVE           83
#define IDS_HSMJOBACTION_NONE           84
#define IDS_HSMJOBACTION_PREMIGRATE     85
#define IDS_HSMJOBACTION_RECALL         86
#define IDS_HSMJOBACTION_RECYCLE        87
#define IDS_HSMJOBACTION_REPAIR         88
#define IDS_HSMJOBACTION_SCAN           89
#define IDS_HSMJOBACTION_TRUNCATE       90
#define IDS_HSMJOBACTION_UNMANAGE       91
#define IDS_HSMJOBACTION_VALIDATE       92

#define IDR_CHsmActionCopy          1
#define IDR_CHsmActionDelete        2
#define IDR_CHsmActionManage        3
#define IDR_CHsmActionMigrate       4
#define IDR_CHsmActionMove          5
#define IDR_CHsmActionRecall        6
#define IDR_CHsmActionRecycle       7
#define IDR_CHsmActionTruncate      8
#define IDR_CHsmActionUnmanage      9
#define IDR_CHsmActionValidate      10
#define IDR_CHsmCritAccessTime      11
#define IDR_CHsmCritAlways          12
#define IDR_CHsmCritCompressed      13
#define IDR_CHsmCritGroup           14
#define IDR_CHsmCritLinked          15
#define IDR_CHsmCritLogicalSize     16
#define IDR_CHsmCritMbit            17
#define IDR_CHsmCritMigrated        18
#define IDR_CHsmCritManageable      19
#define IDR_CHsmCritModifyTime      20
#define IDR_CHsmCritOwner           21
#define IDR_CHsmCritPhysicalSize    22
#define IDR_CHsmCritPremigrated     23
#define IDR_CHsmJob                 24
#define IDR_CHsmJobDef              25
#define IDR_CHsmJobContext          26
#define IDR_CHsmPolicy              27
#define IDR_CHsmRule                28
#define IDR_CHsmJobWorkItem         29
#define IDR_CHsmScanner             30
#define IDR_CHsmSession             31
#define IDR_CHsmPhase               32
#define IDR_CHsmSessionTotals       33
#define IDR_CHsmRuleStack           34
#define IDR_CHsmActionOnResourcePostValidate    35
#define IDR_CHsmActionOnResourcePreValidate     36
#define IDR_CHsmActionOnResourcePostUnmanage    37
#define IDR_CHsmActionOnResourcePreUnmanage     38
#define IDR_CHsmActionOnResourcePreScanUnmanage 39

#define IDS_HSMACTIONCOPY_ID            101
#define IDS_HSMACTIONDELETE_ID          102
#define IDS_HSMACTIONMANAGE_ID          103
#define IDS_HSMACTIONMIGRATE_ID         104
#define IDS_HSMACTIONMOVE_ID            105
#define IDS_HSMACTIONRECALL_ID          106
#define IDS_HSMACTIONRECYCLE_ID         107
#define IDS_HSMACTIONTRUNCATE_ID        108
#define IDS_HSMACTIONUNMANAGE_ID        109
#define IDS_HSMACTIONVALIDATE_ID        110
#define IDS_HSMCRITACCESSTIME_ID        111
#define IDS_HSMCRITALWAYS_ID            112
#define IDS_HSMCRITCOMPRESSED_ID        113
#define IDS_HSMCRITGROUP_ID             114
#define IDS_HSMCRITLINKED_ID            115
#define IDS_HSMCRITLOGICALSIZE_ID       116
#define IDS_HSMCRITMBIT_ID              117
#define IDS_HSMCRITMANAGEABLE_ID        118
#define IDS_HSMCRITMIGRATED_ID          119
#define IDS_HSMCRITMODIFYTIME_ID        120
#define IDS_HSMCRITOWNER_ID             121
#define IDS_HSMCRITPHYSICALSIZE_ID      122
#define IDS_HSMCRITPREMIGRATED_ID       123
#define IDS_HSMACTIONONRESOURCEPOSTVALIDATE_ID      124
#define IDS_HSMACTIONONRESOURCEPREVALIDATE_ID       125
#define IDS_HSMACTIONONRESOURCEPOSTUNMANAGE_ID      126
#define IDS_HSMACTIONONRESOURCEPREUNMANAGE_ID       127
#define IDS_HSMACTIONONRESOURCEPRESCANUNMANAGE_ID   128

#define IDS_HSMJOBSTATEACTIVE           151
#define IDS_HSMJOBSTATECANCELLED        152
#define IDS_HSMJOBSTATECANCELLING       153
#define IDS_HSMJOBSTATEDONE             154
#define IDS_HSMJOBSTATEFAILED           155
#define IDS_HSMJOBSTATEIDLE             156
#define IDS_HSMJOBSTATEPAUSED           157
#define IDS_HSMJOBSTATEPAUSING          158
#define IDS_HSMJOBSTATERESUMING         159
#define IDS_HSMJOBSTATESKIPPED          160
#define IDS_HSMJOBSTATESTARTING         161
#define IDS_HSMJOBSTATESUSPENDED        162
#define IDS_HSMJOBSTATESUSPENDING       163

#define IDS_HSMJOBMEDIASTATEIDLE            170
#define IDS_HSMJOBMEDIASTATEUNAVAILABLE     171
#define IDS_HSMJOBMEDIASTATEMOUNTING        172
#define IDS_HSMJOBMEDIASTATEMOUNTED         173
#define IDS_HSMJOBMEDIASTATETRANSFERRING    174
#define IDS_HSMJOBMEDIASTATETRANSFERRED     175
#define IDS_HSMJOBMEDIASTATEDISMOUNTING     176
#define IDS_HSMJOBMEDIASTATEDISMOUNTED      177

#define IDS_HSMCRITALWAYS_VALUE_T       201
#define IDS_HSMCRITCOMPRESSED_VALUE_T   203
#define IDS_HSMCRITCOMPRESSED_VALUE_F   204
#define IDS_HSMCRITLINKED_VALUE_T       205
#define IDS_HSMCRITLINKED_VALUE_F       206
#define IDS_HSMCRITMBIT_VALUE_T         207
#define IDS_HSMCRITMBIT_VALUE_F         208
#define IDS_HSMCRITMANAGEABLE_VALUE_T   209
#define IDS_HSMCRITMANAGEABLE_VALUE_F   210
#define IDS_HSMCRITMIGRATED_VALUE_T     211
#define IDS_HSMCRITMIGRATED_VALUE_F     212
#define IDS_HSMCRITPREMIGRATED_VALUE_T  213
#define IDS_HSMCRITPREMIGRATED_VALUE_F  214

#define IDS_HSM_CRITERIACOMPARATOR_NOTSET 301
#define IDS_HSM_CRITERIACOMPARATOR_LT   302
#define IDS_HSM_CRITERIACOMPARATOR_LTE  303
#define IDS_HSM_CRITERIACOMPARATOR_EQL  304
#define IDS_HSM_CRITERIACOMPARATOR_NEQL  305
#define IDS_HSM_CRITERIACOMPARATOR_GTE  306
#define IDS_HSM_CRITERIACOMPARATOR_GT   307
#define IDS_HSM_CRITERIACOMPARATOR_BETWEEN 308
#define IDS_HSM_CRITERIACOMPARATOR_OUTSIDE 309
#define IDS_HSM_CRITERIACOMPARATOR_MEMBEROF 310

#define IDS_HSMJOBPRIORITY_IDLE         320
#define IDS_HSMJOBPRIORITY_LOWEST       321
#define IDS_HSMJOBPRIORITY_LOW          322
#define IDS_HSMJOBPRIORITY_NORMAL       323
#define IDS_HSMJOBPRIORITY_HIGH         324
#define IDS_HSMJOBPRIORITY_HIGHEST      325
#define IDS_HSMJOBPRIORITY_CRITICAL     326

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        401
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\hsmsesst.h ===
#ifndef _HSMSESST_
#define _HSMSESST_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.h

Abstract:

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

/*++

Class Name:
    
    CHsmSessionTotals

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Class Description:


--*/

class CHsmSessionTotals : 
    public CWsbObject,
    public IHsmSessionTotals,
    public IHsmSessionTotalsPriv,
    public CComCoClass<CHsmSessionTotals,&CLSID_CHsmSessionTotals>
{
public:
    CHsmSessionTotals() {} 

BEGIN_COM_MAP(CHsmSessionTotals)
    COM_INTERFACE_ENTRY(IHsmSessionTotals)
    COM_INTERFACE_ENTRY(IHsmSessionTotalsPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmSessionTotals)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSessionTotals
public:
    STDMETHOD(Clone)(IHsmSessionTotals** ppSessionTotals);
    STDMETHOD(CompareToAction)(HSM_JOB_ACTION action, SHORT* pResult);
    STDMETHOD(CompareToISessionTotals)(IHsmSessionTotals* pTotal, SHORT* pResult);
    STDMETHOD(CopyTo)(IHsmSessionTotals* pSessionTotals);
    STDMETHOD(GetAction)(HSM_JOB_ACTION* pAction);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStats)(LONGLONG* pItems, LONGLONG* pSize, LONGLONG* pSkippedItems, LONGLONG* pSkippedSize, LONGLONG* errorItems, LONGLONG* errorSize);

// IHsmSessionTotalsPriv
    STDMETHOD(AddItem)(IFsaScanItem* pItem, HRESULT hrItem);
    STDMETHOD(Clone)(IHsmSessionTotalsPriv** ppSessionTotalsPriv);
    STDMETHOD(CopyTo)(IHsmSessionTotalsPriv* pSessionTotalsPriv);
    STDMETHOD(SetAction)(HSM_JOB_ACTION pAction);
    STDMETHOD(SetStats)(LONGLONG items, LONGLONG size, LONGLONG skippedItems, LONGLONG skippedSize, LONGLONG errorItems, LONGLONG errorSize);

protected:
    HSM_JOB_ACTION      m_action;
    LONGLONG            m_items;
    LONGLONG            m_size;
    LONGLONG            m_skippedItems;
    LONGLONG            m_skippedSize;
    LONGLONG            m_errorItems;
    LONGLONG            m_errorSize;
};

#endif // _HSMSESST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    help.c

Abstract:

    help for HSM kd extensions
Author:

    Ravisankar Pudipeddi 22 June 1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


DECLARE_API( help )
{

    dprintf("\nHSM Debugger Extensions\n");
 
    dprintf("rpfilename <filename> [flags]"
            "       - dumps the context for the specified filename\n"
            "           filename: dumps entries matching the filename\n"
            "           flags:    1 - verbose\n");

    dprintf("rpfilecontext <filecontext> [flags]"
            "       -  dumps the specified file context\n"
            "          flags: 1 - verbose\n"
	    "                 2 - dump all entries from <filecontext> (or from queue head if it is 0)\n");

    dprintf("rpfileobj <fileobj>              [flags]  -  dumps the specified RP_FILE_OBJ entry\n");
    dprintf("rpirp     <irp_queue_entry>      [flags]  -  dumps the specified RP_IRP_QUEUE entry\n");
    dprintf("rpmsg     <RP_MSG_ENTRY pointer>          -  dumps the specified RP_MSG_ENTRY\n");
    dprintf("rpbuf     <cache_buffer_entry>   [flags]  -  dumps the specified RP_FILE_BUF entry\n");
    dprintf("rpbucket  <bucket-number>        [flags]  -  dumps the specified cache hash bucket\n");
    dprintf("rplru                            [flags]  -  dumps the list of file buffers on the LRU\n");
    dprintf("rpdata    <rpdata>               [flags]  -  dumps the reparse point data\n");
    dprintf("rpsummary                                 -  dumps assorted counters and variables\n");
    dprintf("rpvalque  <q-head>               [flags]  -  counts the number of entries in the queue optionally dumping entry details\n");
    dprintf("rpioq                            [flags]  -  dumps the queue of Irps for sending requests to the recall engine\n");
    dprintf("\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\hsmkd.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION		ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS	ExtensionApis;

USHORT			SavedMajorVersion;
USHORT			SavedMinorVersion;

ULONG			STeip;
ULONG			STebp;
ULONG			STesp;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\job\dll\makefile.inc ===
$(O)\job.res: ..\hsmactcp.rgs  \
              ..\hsmactdl.rgs  \
              ..\hsmactmg.rgs  \
              ..\hsmactmt.rgs  \
              ..\hsmactmv.rgs  \
              ..\hsmactrl.rgs  \
              ..\hsmactrc.rgs  \
              ..\hsmacttr.rgs  \
              ..\hsmactum.rgs  \
              ..\hsmactvl.rgs  \
              ..\hsmcrtat.rgs  \
              ..\hsmcrtal.rgs  \
              ..\hsmcrtcp.rgs  \
              ..\hsmcrtgp.rgs  \
              ..\hsmcrtlk.rgs  \
              ..\hsmcrtls.rgs  \
              ..\hsmcrtmb.rgs  \
              ..\hsmcrtmd.rgs  \
              ..\hsmcrtmg.rgs  \
              ..\hsmcrtmt.rgs  \
              ..\hsmcrtow.rgs  \
              ..\hsmcrtps.rgs  \
              ..\hsmcrtpd.rgs  \
              ..\hsmjob.rgs    \
              ..\hsmjobdf.rgs  \
              ..\hsmjobcx.rgs  \
              ..\hsmpolcy.rgs  \
              ..\hsmrule.rgs   \
              ..\hsmjobwi.rgs  \
              ..\hsmscan.rgs   \
              ..\hsmsess.rgs   \
              ..\hsmphase.rgs  \
              ..\hsmsesst.rgs  \
              ..\hsmrlstk.rgs  \
              ..\$(O)\joblib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\makefile.inc ===
$(O)\hsmkd.def: hsmkd.src
    $(TARGET_CPP) /EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) hsmkd.src > $(O)\hsmkd.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\launch\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\filter.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rpfilter.c

Abstract:

    WinDbg Extension Api to dump the HSM filter driver structures.

Author:

    Ravisankar Pudipeddi (ravisp)  22 June, 1998

Environment:

    User Mode.

--*/


#include "pch.h"
#pragma hdrstop

#include "rpdata.h"
#include "rpio.h"
#include "rpfsa.h"
#include "local.h"



typedef struct _ENUM_NAME {
    PUCHAR Name;
} ENUM_NAME, *PENUM_NAME;

typedef struct _FLAG_NAME {
    ULONG  Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define ENUM_NAME(val)    #val

#define FLAG_NAME(flag)   {flag, #flag}

/*
** Index by command. See inc\rpio.h
*/
ENUM_NAME RpCommands[] = {
    ENUM_NAME(Undefined),		//  0
    ENUM_NAME(RP_GET_REQUEST),		//  1
    ENUM_NAME(Undefined),		//  2
    ENUM_NAME(RP_RECALL_COMPLETE),	//  3
    ENUM_NAME(RP_SUSPEND_NEW_RECALLS),	//  4
    ENUM_NAME(RP_ALLOW_NEW_RECALLS),	//  5
    ENUM_NAME(RP_CANCEL_ALL_RECALLS),	//  6
    ENUM_NAME(RP_CANCEL_ALL_DEVICEIO),	//  7
    ENUM_NAME(RP_GET_RECALL_INFO),	//  8
    ENUM_NAME(RP_SET_ADMIN_SID),	//  9
    ENUM_NAME(RP_PARTIAL_DATA),		// 10
    ENUM_NAME(RP_CHECK_HANDLE),		// 11
    ENUM_NAME(Undefined),		// 12
    ENUM_NAME(Undefined),		// 13
    ENUM_NAME(Undefined),		// 14
    ENUM_NAME(Undefined),		// 15
    ENUM_NAME(Undefined),		// 16
    ENUM_NAME(Undefined),		// 17
    ENUM_NAME(Undefined),		// 18
    ENUM_NAME(Undefined),		// 19
    ENUM_NAME(RP_OPEN_FILE),		// 20
    ENUM_NAME(RP_RECALL_FILE),		// 21
    ENUM_NAME(RP_CLOSE_FILE),		// 22
    ENUM_NAME(RP_CANCEL_RECALL),	// 23
    ENUM_NAME(RP_RUN_VALIDATE),		// 24
    ENUM_NAME(RP_START_NOTIFY),		// 25
    ENUM_NAME(RP_END_NOTIFY)		// 26
};

FLAG_NAME  RpFileContextFlags[] = {
    FLAG_NAME(RP_FILE_WAS_WRITTEN),                  
    FLAG_NAME(RP_FILE_INITIALIZED),                  
    FLAG_NAME(RP_FILE_REPARSE_POINT_DELETED),
    {0,0}    
};

FLAG_NAME  RpFileObjFlags[] = {
    FLAG_NAME(RP_NO_DATA_ACCESS),
    FLAG_NAME(RP_OPEN_BY_ADMIN),
    FLAG_NAME(RP_OPEN_LOCAL),
    FLAG_NAME(RP_NOTIFICATION_SENT),
    {0,0}
};

FLAG_NAME  RpReparsePointFlags[] = {
    FLAG_NAME(RP_FLAG_TRUNCATED),
    FLAG_NAME(RP_FLAG_TRUNCATE_ON_CLOSE),
    FLAG_NAME(RP_FLAG_PREMIGRATE_ON_CLOSE),
    FLAG_NAME(RP_FLAG_ENGINE_ORIGINATED),
    {0,0}
};

FLAG_NAME  RpReparseIrpFlags[] = {
    FLAG_NAME(RP_IRP_NO_RECALL),
    {0,0}
};

//
// Define flags
//

#define RPDBG_VERBOSE       1
#define RPDBG_PRINT_ALL     2



VOID
DumpUnicode (IN UNICODE_STRING unicodeString);

VOID
DumpRpIrp (IN ULONG64 ul64addrIrp, 
	   IN ULONG   flags,
	   IN ULONG   depth);

VOID
DumpRpFileObj (IN ULONG64 ul64addrFileObject,
               IN ULONG   Flags);

VOID
DumpRpFileContext (IN ULONG64 ul64addrFileContext, 
		   IN ULONG   fFlags); 

VOID
DumpRpFileBuf (IN ULONG64 ul64addrFileBuffer,
	       IN ULONG   flags,
	       IN ULONG   depth);

VOID
DumpRpHashBucket (IN LONG  BucketNumber,
		  IN ULONG Flags,
		  IN ULONG Depth);

VOID
DumpRpLru (IN ULONG Flags,
	   IN ULONG Depth);

VOID
DumpRpMsg (IN ULONG64 ul64addrMessage,
	   IN ULONG   Flags,
	   IN ULONG   Depth);

VOID
DumpFlags (IN ULONG Depth,
	   IN LPSTR FlagDescription,
	   IN ULONG Flags,
	   IN PFLAG_NAME FlagTable);

VOID
DumpRpData (IN ULONG64 ul64addrReparsePointData,
	    IN ULONG   fFlags);


/*
********************************************************************
********************************************************************
********************************************************************
********************************************************************
*/


DECLARE_API (rpfilename) 
/*++

Routine Description:

    Finds an RP_FILE_CONTEXT entry of the specified file name
    and dumps it

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64		ul64addrRsFileContextQHead   = 0;
    ULONG64		ul64addrFileContextListQHead = 0;
    ULONG64		ul64addrFileContext          = 0;
    ULONG64		ul64addrFilename             = 0;
    ULONG64		ul64addrFlink                = 0;
    ULONG64		ul64addrFilenameBuffer       = 0;
    ULONG		ulOffsetListFlink            = 0;
    ULONG		fFlags                       = 0;
    const ULONG		fLegalFlags                  = RPDBG_VERBOSE;
    BOOLEAN		fileNameAllocated            = FALSE;
    BOOLEAN		fFound                       = FALSE;
    NTSTATUS		status;
    UNICODE_STRING	fileName;
    ANSI_STRING		ansiString;
    UCHAR		uchBuffer [256];



    RtlZeroMemory (uchBuffer, sizeof (uchBuffer));

    sscanf (args, "%s %lx", uchBuffer, &fFlags);


    if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	{
	dprintf("Illegal flags specified\n");
	return;
	}


    if ('\0' == uchBuffer [0]) 
	{
	dprintf ("Illegal filename specified\n");
	return;
	}
    else
	{
	RtlInitAnsiString (&ansiString,
			   (PCSZ) uchBuffer);

	status = RtlAnsiStringToUnicodeString (&fileName,
					       &ansiString,
					       TRUE);
	if (NT_SUCCESS (status)) 
	    {
	    fileNameAllocated = TRUE;
	    }
        }


    ul64addrRsFileContextQHead = GetExpression ("RsFilter!RsFileContextQHead");

    if (0 == ul64addrRsFileContextQHead) 
	{
	dprintf("Error retrieving address of RsFileContextQHead\n");
	return;
	}


    GetFieldValue (ul64addrRsFileContextQHead, "LIST_ENTRY", "Flink", ul64addrFlink);

    GetFieldOffset ("RP_FILE_CONTEXT", "list.Flink", &ulOffsetListFlink);


    if (ul64addrFlink == ul64addrRsFileContextQHead)
	{
	dprintf ("RsFileContextQ empty, list head @ 0x%I64x\n", ul64addrRsFileContextQHead);
	}

    else
	{
	while (!CheckControlC () && !fFound && (ul64addrFlink != ul64addrRsFileContextQHead))
	    {
	    UNICODE_STRING	ucsFilenameLocalCopy;


	    ul64addrFileContext = ul64addrFlink - ulOffsetListFlink;

	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "uniName", ul64addrFilename);

	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.MaximumLength", ucsFilenameLocalCopy.MaximumLength);
	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Length",        ucsFilenameLocalCopy.Length);
	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Buffer",        ul64addrFilenameBuffer);


	    ucsFilenameLocalCopy.Buffer = LocalAlloc (LPTR, ucsFilenameLocalCopy.MaximumLength);

	    if (NULL != ucsFilenameLocalCopy.Buffer)
		{
		fFound = ((xReadMemory (ul64addrFilenameBuffer, ucsFilenameLocalCopy.Buffer, ucsFilenameLocalCopy.Length)) &&
			  (0 == RtlCompareUnicodeString (&fileName, &ucsFilenameLocalCopy, TRUE)));

		if (fFound)
		    {
		    DumpRpFileContext (ul64addrFileContext, fFlags);
		    }

		LocalFree (ucsFilenameLocalCopy.Buffer);
		}

	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "list.Flink", ul64addrFlink);
	    }
	}


    if (fileNameAllocated) RtlFreeUnicodeString (&fileName);
    }


DECLARE_API (rpfilecontext) 
/*++

Routine Description:

    Finds an RP_FILE_CONTEXT entry of the specified file name
    and dumps it

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrRsFileContextQHead   = 0;
    ULONG64	ul64addrFileContextListQHead = 0;
    ULONG64	ul64addrFileContext          = 0;
    ULONG64	ul64addrFileContextRequested = 0;
    ULONG64	ul64addrFlink                = 0;
    ULONG	ulOffsetListFlink            = 0;
    ULONG	fFlags                       = 0;
    const ULONG	fLegalFlags                  = RPDBG_VERBOSE | RPDBG_PRINT_ALL;
    BOOLEAN	fFound                       = FALSE;
    BOOLEAN	fDumpFollowingEntries        = FALSE;
    NTSTATUS	status;



    if (GetExpressionEx (args, &ul64addrFileContextRequested, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }

	else
	    {
	    fDumpFollowingEntries = (0 != (fFlags & RPDBG_PRINT_ALL));
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpfilecontext\n");

	return;
	}



    ul64addrRsFileContextQHead = GetExpression ("RsFilter!RsFileContextQHead");

    if (0 == ul64addrRsFileContextQHead) 
	{
	dprintf("Error retrieving address of RsFileContextQHead\n");
	return;
	}



    GetFieldValue (ul64addrRsFileContextQHead, "LIST_ENTRY", "Flink", ul64addrFlink);

    GetFieldOffset ("RP_FILE_CONTEXT", "list.Flink", &ulOffsetListFlink);


    if (ul64addrFlink == ul64addrRsFileContextQHead)
	{
	dprintf ("RsFileContextQ empty, list head @ 0x%I64x\n", ul64addrRsFileContextQHead);
	}

    else
	{
	while (!CheckControlC () && (!fFound || fDumpFollowingEntries) && (ul64addrFlink != ul64addrRsFileContextQHead))
	    {
	    ul64addrFileContext = ul64addrFlink - ulOffsetListFlink;


	    if (ul64addrFileContext == ul64addrFileContextRequested)
		{
		/*
		** Enable dumping of current and possibly all following entries.
		*/
		fFound = TRUE;
		}


	    if (fFound || (0 == ul64addrFileContextRequested))
		{
		DumpRpFileContext (ul64addrFileContext, fFlags);
		}


	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "list.Flink", ul64addrFlink);
	    }

	if (!fFound && (0 != ul64addrFileContextRequested)) 
	    {
	    dprintf ("Specified context 0x%I64x not found\n", ul64addrFileContextRequested);
	    }
	}
    }


DECLARE_API (rpfileobj) 
/*++

Routine Description:

    Dumnps RP_FILE_OBJ entries 

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrFileObject = 0;
    ULONG	fFlags             = 0;


    if (GetExpressionEx (args, &ul64addrFileObject, &args))
	{
	sscanf (args, "%x", &fFlags);

	DumpRpFileObj (ul64addrFileObject, fFlags);
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpfileobj\n");
	}
    }


DECLARE_API (rpirp)
/*++

Routine Description:

    Dumps a pending IRP (RP_IRP_QUEUE) entry 

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrPendingIrp = 0;
    ULONG	fFlags             = 0;
    ULONG	fLegalFlags        = RPDBG_VERBOSE;


    if (GetExpressionEx (args, &ul64addrPendingIrp, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpirp\n");

	return;
	}



    DumpRpIrp (ul64addrPendingIrp, fFlags, 0);

    return;
    }


DECLARE_API (rpbuf)
/*++

Routine Description

    Dumps a specfied cache file buffer

Arguments
    
    Pointer to the file buffer

Return Value

    none
--*/
    {
    ULONG64	ul64addrFileBuffer = 0;
    ULONG	fFlags             = 0;


    if (GetExpressionEx (args, &ul64addrFileBuffer, &args))
	{
	sscanf (args, "%x", &fFlags);

	DumpRpFileBuf (ul64addrFileBuffer, fFlags, 0);
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpbuf\n");
	}
    }


DECLARE_API (rpbucket)
/*++

Routine Description

    Dumps a specfied cache bucket: if the bucket number
    is not supplied or it is -1, dumps all the buckets


Arguments
    
    number of bucket

Return Value

    none
--*/
    {
    ULONG	fFlags                  = 0;
    LONG        bucketNumber            = -1;
    LONG	maxBucket               = 0;
    LONG	i;

    maxBucket = GetUlongValue ("RsFilter!RspCacheMaxBuckets");

    sscanf (args, "%lx %lx", &bucketNumber, &fFlags);

    if (bucketNumber == -1) 
	{
        for (i = 0; i < maxBucket; i++) 
	    {
            DumpRpHashBucket (i, fFlags, 0);
	    }
	}
 
    else if (bucketNumber <= maxBucket)
	{
        DumpRpHashBucket (bucketNumber, fFlags, 0);
	}

    else
	{
	dprintf ("Specified bucket doesn't exist (max bucket = 0x%x)\n");
	}
    }
        

DECLARE_API (rplru)
/*++

Routine Description

    Dumps a specfied cache bucket

Arguments
    
    number of bucket

Return Value

    none
--*/
    {
    ULONG        fFlags = 0;

    sscanf (args, "%lx",  &fFlags);

    DumpRpLru (fFlags, 0);
    }


VOID
DumpRpFileBufWaitQueue (IN ULONG64 ul64addrFileBufferQHead,
			IN ULONG   depth)
    {
    ULONG64	ul64addrFlink;
    ULONG64	ul64addrIrp;
    ULONG	ulOffsetFileBufferWaitQueue;

    PLIST_ENTRY entryAddr;
    LIST_ENTRY  entry;
    PIRP        irp;

    xdprintf (depth, "Queue of IRPs waiting on this block:\n");

    GetFieldValue (ul64addrFileBufferQHead, "LIST_ENTRY", "Flink", ul64addrFlink);


    /*
    ** Need to calculate the offset of Tail.Overlay.DriverContext[2]
    ** or whatever is being used now. Needs to be kept in sync with
    ** the calculation in RsCacheIrpWaitQueueContainingIrp() in
    ** filter\rpcache.c
    **
    ** Currently the required field is Tail.Overlay.DriverContext[2]
    */
    GetFieldOffset ("IRP", "Tail.Overlay.DriverContext", &ulOffsetFileBufferWaitQueue);

    ulOffsetFileBufferWaitQueue += 2 * GetTypeSize ("PVOID");


    while (ul64addrFlink != ul64addrFileBufferQHead)
	{
	ul64addrIrp = ul64addrFlink - ulOffsetFileBufferWaitQueue;

	xdprintf (depth, "0x%I64x ", ul64addrIrp);

	GetFieldValue (ul64addrFlink, "LIST_ENTRY", "Flink", ul64addrFlink);
	}

    dprintf("\n");
    }


VOID
DumpRpFileBuf (IN ULONG64 ul64addrFileBuffer,
	       IN ULONG   fFlags,
	       IN ULONG   depth)
    {
    ULONG	ulState = 0;

    xdprintf (depth, 
	      "RP_FILE_BUF ENTRY @ 0x%I64X\n", 
	      ul64addrFileBuffer);

    xdprintf (depth, 
	      "Volume Serial 0x%X  File Id 0x%I64X  Block 0x%I64X\n", 
	      GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "VolumeSerial"),
	      GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "FileId"),
	      GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Block"));


    if (!(fFlags & RPDBG_VERBOSE)) 
	{
        return;
	}


    xdprintf(depth, "State         ");

    ulState = GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "State");

    switch (ulState)
	{
        case RP_FILE_BUF_INVALID: xdprintf (depth, "RP_FILE_BUF_INVALID");                break;
        case RP_FILE_BUF_IO:      xdprintf (depth, "RP_FILE_BUF_IO");                     break;
        case RP_FILE_BUF_VALID:   xdprintf (depth, "RP_FILE_BUF_VALID");                  break;
        case RP_FILE_BUF_ERROR:   xdprintf (depth, "RP_FILE_BUF_ERROR");                  break;
        default:                  xdprintf (depth, "UNKNOWN STATE 0x%X", ulState);        break;
	}


    dprintf("   ");
    xdprintf (depth, "IoStatus        0x%x\n",    GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "IoStatus"));
    xdprintf (depth, "Usn             0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Usn"));
    xdprintf (depth, "Data @          0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Data"));
    xdprintf (depth, "Lru Links @     0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "LruLinks"));
    xdprintf (depth, "Bucket Links @  0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "BucketLinks"));


    //
    // Dump the wait queue
    //
    DumpRpFileBufWaitQueue (GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "WaitQueue"),
			    depth);
    
}


VOID
DumpRpIrp(IN ULONG64 ul64addrIrp, 
	  IN ULONG   flags,
          IN ULONG   depth) 

/*++

Routine Description:

    Dumps  RP_IRP_QUEUE

Arguments:

    rpIrp       - pointer to the RP_IRP_QUEUE structure (local)
    rpIrpAddr   - address of the structure to dump on the target machine
    depth       - indentation

Return Value:

    none
--*/
    {
    xdprintf (depth, "RP_IRP_QUEUE ENTRY @ 0x%I64x\n", ul64addrIrp);
 
    xdprintf (depth, "Lists Entries\n");
    xdprintf (depth, "  Flink              0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "list.Flink"));
    xdprintf (depth, "  Blink              0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "list.Blink"));
    xdprintf (depth, "Irp                  0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "irp"));

    DumpFlags (depth, "Flags               ",             GetFieldValueUlong32 (ul64addrIrp, "RP_IRP_QUEUE", "flags"), RpReparseIrpFlags);

    xdprintf (depth, "ReadId               0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "readId"));
    xdprintf (depth, "Recall offset        0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "recallOffset"));
    xdprintf (depth, "Recall length        0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "recallLength"));
    xdprintf (depth, "UserBuffer           0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "userBuffer"));
    xdprintf (depth, "  Offset             0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "offset"));
    xdprintf (depth, "  Length             0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "length"));
    xdprintf (depth, "CacheBuffer          0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "cacheBuffer"));
    xdprintf (depth, "DeviceExtension      0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "deviceExtension"));
    }


VOID
DumpRpFileContext (IN ULONG64 ul64addrFileContext, 
		   IN ULONG   fFlags) 
/*++

Routine Description:

    Dumps an RP_FILE_CONTEXT structure

Arguments:

    ul64addrFileContext - specificies the pointer on the target machine to the structure
    fFlags              - flags indicating degree of verbosity

Return Value:

    none

--*/
    {
    ULONG64		ul64addrFilename       = 0;
    ULONG64		ul64addrFilenameBuffer = 0;
    ULONG64		ul64addrQHead          = 0;
    ULONG64		ul64addrFlink          = 0;
    ULONG64		ul64Value;
    ULONG		ulValue;
    ULONG		ulTargetFlags          = 0;
    ULONG		ulTargetState          = 0;
    ULONG		ulOffsetRpData;
    ULONG		ulOffsetQHead;
    UNICODE_STRING	ucsFilenameLocalCopy;


    dprintf("FILE CONTEXT ENTRY @ 0x%I64x\n", ul64addrFileContext);

    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "flags", ulTargetFlags);
    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "state", ulTargetState);

    if (!(ulTargetFlags & RP_FILE_INITIALIZED)) 
	{
        dprintf("FileContextNotInitialized ");
	}


    if (ulTargetFlags & RP_FILE_WAS_WRITTEN) 
	{
        dprintf("FileWasWritten ");    
	}


    dprintf("State:                    ");

    switch (ulTargetState) 
	{
        case RP_RECALL_COMPLETED:    dprintf ("RecallCompleted"); break;
        case RP_RECALL_NOT_RECALLED: dprintf ("NotRecalled    "); break;
	case RP_RECALL_STARTED:      dprintf ("RecallStarted  "); break;
	default:                     dprintf ("Unknown        "); break;
	}

    dprintf(" (%u)\n", ulTargetState);


    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "uniName", ul64addrFilename);

    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.MaximumLength", ucsFilenameLocalCopy.MaximumLength);
    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Length",        ucsFilenameLocalCopy.Length);
    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Buffer",        ul64addrFilenameBuffer);

    ucsFilenameLocalCopy.Buffer = LocalAlloc (LPTR, ucsFilenameLocalCopy.MaximumLength);

    if (NULL != ucsFilenameLocalCopy.Buffer)
	{
	if (xReadMemory (ul64addrFilenameBuffer, ucsFilenameLocalCopy.Buffer, ucsFilenameLocalCopy.Length))
	    {
            dprintf ("File name:                %wZ\n", &ucsFilenameLocalCopy);
	    }

	LocalFree (ucsFilenameLocalCopy.Buffer);
	}


    if (!(fFlags & RPDBG_VERBOSE)) 
	{
        dprintf("\n");
        return;
	}



    DumpFlags (0, "Flags                    ", ulTargetFlags, RpFileContextFlags);


    GetFieldOffset ("RP_FILE_CONTEXT", "fileObjects", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileContext + ulOffsetQHead;

    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "fileObjects.Flink", ul64addrFlink);

    if (ul64addrFlink == ul64addrQHead)
	{
	dprintf ("FileObjectsQ empty Qhead  0x%I64x\n", ul64addrQHead);
	} 
    else 
	{
	dprintf ("FileObjects QHead         0x%I64x  first entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}


    GetFieldOffset ("RP_FILE_CONTEXT", "rpData", &ulOffsetRpData);

    dprintf ("File Object to write      0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fileObjectsToWrite"));
    dprintf ("FsContext                 0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fsContext"));
    dprintf ("Next write buffer         0x%I64x  ", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "nextWriteBuffer"));
    dprintf ("Size 0x%x\n",                         GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "nextWriteSize"));
    dprintf ("File Id                   0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fileId"));
    dprintf ("Filter Id                 0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "filterId"));
    dprintf ("Recall size               0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "recallSize"));
    dprintf ("Current recall offset     0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "currentOffset"));
    dprintf ("Recall status             0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "recallStatus"));
    dprintf ("Volume serial number      0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "serial"));
    dprintf ("Reference count           0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "refCount"));
    dprintf ("Usn                       0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "usn"));
    dprintf ("CreateSectionLock         0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "createSectionLock"));
    dprintf ("Reparse Data @            0x%I64x\n", ul64addrFileContext + ulOffsetRpData);
    dprintf ("\n");
    }


VOID
DumpRpFileObj (IN ULONG64 ul64addrFileObject,
	       IN ULONG   Flags)
/*++

Routine Description:

    Dumps the supplied RP_FILE_OBJ entry

Arguments:

    FileObj      -    Pointer to contents of file obj entry      
    FileObjAddr  -    Address of this entry on remote machine
    Flags        -    Flags indicating degree of verbosity
                            
Return Value:

    none

--*/
    {
    ULONG64	ul64addrQHead;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetQHead;


    dprintf ("FILE OBJECT ENTRY @ 0x%I64x\n", ul64addrFileObject);

    dprintf ("Next entry               0x%I64x  Prev entry  0x%I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "list.Flink"), 
									GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "list.Blink"));
    dprintf ("File object              0x%I64x\n",			GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fileObj"));
    dprintf ("File context entry       0x%I64x\n",			GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fsContext"));



    GetFieldOffset ("RP_FILE_OBJ", "readQueue", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileObject + ulOffsetQHead; 

    ul64addrFlink = GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "readQueue.Flink");

    if (ul64addrFlink == ul64addrQHead)
	{
        dprintf ("Read  IRP Q<empty> Qhead 0x%I64x\n", ul64addrQHead);
	} 
    else 
	{
        dprintf ("Read  IRP Q        QHead 0x%I64x first  entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}



    GetFieldOffset ("RP_FILE_OBJ", "writeQueue", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileObject + ulOffsetQHead; 

    ul64addrFlink = GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "writeQueue.Flink");

    if (ul64addrFlink == ul64addrQHead)
	{
        dprintf ("Write IRP Q<empty> QHead 0x%I64x\n", ul64addrQHead);
	} 
    else  
	{
	dprintf ("Write IRP Q        QHead 0x%I64x  first entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}



    dprintf ("Open options             0x%x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "openOptions"));

    DumpFlags (0, "Flags                   ", GetFieldValueUlong32 (ul64addrFileObject, "RP_FILE_OBJ", "flags"), RpFileObjFlags); 

    dprintf ("ObjId Hi                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "objIdHi"));
    dprintf ("ObjId Lo                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "objIdLo"));
    dprintf ("FileId                   %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fileId"));
    dprintf ("FilterId                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "filterId"));
    dprintf ("User security info @     %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "userSecurityInfo"));
    }


VOID
DumpRpHashBucket (IN LONG  BucketNumber,
		  IN ULONG Flags,
		  IN ULONG Depth)
    {
    ULONG64	ul64addrBucketArray;
    ULONG64	ul64addrChainQHead;
    ULONG64	ul64addrFileBuffer;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetBucketFlink;
    ULONG       ulCount = 0;


    ul64addrBucketArray = GetPointerValue ("RsFilter!RspCacheBuckets");

    ul64addrChainQHead = ul64addrBucketArray + BucketNumber * GetTypeSize ("RP_CACHE_BUCKET");


    xdprintf (Depth, "HASH BUCKET %x @ 0x%I64x\n", BucketNumber, ul64addrChainQHead);

    ul64addrFlink = GetFieldValueUlong64 (ul64addrChainQHead, "RP_CACHE_BUCKET", "FileBufHead.Flink");

    GetFieldOffset ("RP_FILE_BUF", "BucketLinks.Flink", &ulOffsetBucketFlink);


    while (ul64addrFlink != ul64addrChainQHead)
	{
        if (CheckControlC())
	    {
            return;
	    } 



	ul64addrFileBuffer = ul64addrFlink - ulOffsetBucketFlink;

        DumpRpFileBuf (ul64addrFileBuffer, Flags, Depth + 1);         

        dprintf("\n");

	GetFieldValue (ul64addrFileBuffer, "RP_FILE_BUF", "BucketLinks.Flink", ul64addrFlink);

        ulCount++;
	}


    xdprintf (Depth, "%d entries\n", ulCount);
    }
  

VOID
DumpRpLru (IN ULONG Flags,
	   IN ULONG Depth)
    {
    ULONG64	ul64addrCacheLru;
    ULONG64	ul64addrFileBuffer;
    ULONG64	ul64addrQHead;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetFileBufferFlink;
    ULONG	ulOffsetLruLinksFlink;
    ULONG	ulCount = 0;

    ul64addrCacheLru = GetExpression ("RsFilter!RspCacheLru");

    if (0 == ul64addrCacheLru) 
	{
	return;
	}


    xdprintf (Depth, 
	      "Cache LRU contents (head @ 0x%I64x) TotalCount %d LruCount %d\n",
	      ul64addrCacheLru,
	      GetFieldValueUlong32 (ul64addrCacheLru, "RP_CACHE_LRU", "TotalCount"),
	      GetFieldValueUlong32 (ul64addrCacheLru, "RP_CACHE_LRU", "LruCount"));

    GetFieldOffset ("RP_CACHE_LRU", "FileBufHead.Flink", &ulOffsetFileBufferFlink);
    GetFieldOffset ("RP_FILE_BUF",  "LruLinks.Flink",    &ulOffsetLruLinksFlink);

    ul64addrQHead = ul64addrCacheLru + ulOffsetFileBufferFlink;
    ul64addrFlink = GetFieldValueUlong64 (ul64addrCacheLru, "RP_CACHE_LRU", "FileBufHead.Flink");


    while (ul64addrFlink != ul64addrQHead)
	{
        if (CheckControlC())
	    {
            return;
	    }

	
	ul64addrFileBuffer = ul64addrFlink - ulOffsetLruLinksFlink;

        DumpRpFileBuf (ul64addrFileBuffer, Flags, Depth + 1);

        dprintf ("\n");

	GetFieldValue (ul64addrFileBuffer, "RP_FILE_BUF", "LruLinks.Flink", ul64addrFlink);

        ulCount++;
	}                                   

    xdprintf (Depth, "%d entries\n", ulCount);
    }
  

DECLARE_API (rpmsg)
/*++

Routine Description

    Dumps a specfied RP_MSG

Arguments
    
    Pointer to the msg

Return Value

    none
--*/
    {
    ULONG64	ul64addrMessage;
    ULONG	flags = 0;


    GetExpressionEx (args, &ul64addrMessage, &args);

    sscanf(args, "%lx", &flags);

    if (ul64addrMessage != 0)
	{
        DumpRpMsg (ul64addrMessage, flags, 0);
	}
    }


VOID
DumpRpMsg (IN ULONG64 ul64addrMessage,
	   IN ULONG   Flags,
	   IN ULONG   Depth)
    {
    ULONG	ulCommand = GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "inout.command");


    xdprintf (Depth, "RP_MSG ENTRY @ 0x%I64x\n", ul64addrMessage);

    xdprintf (Depth,
	      "Command: %s  Status: 0x%x\n", 
	      RpCommands[ulCommand].Name,
	      GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "inout.status"));

    switch(ulCommand) 
	{
        case RP_PARTIAL_DATA:
            xdprintf (Depth, "FilterId     0x%I64x\n", GetFieldValueUlong64 (ul64addrMessage, "RP_MSG", "msg.pRep.filterId"));
            xdprintf (Depth, "BytesRead    0x%x\n",    GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "msg.pRep.bytesRead"));
            xdprintf (Depth, "ByteOffset   0x%I64x\n", GetFieldValueUlong64 (ul64addrMessage, "RP_MSG", "msg.pRep.byteOffset"));
            xdprintf (Depth, "OffsetToData 0x%x\n",    GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "msg.pRep.offsetToData"));
            break;
	}           
    }


VOID
DumpFlags(
    ULONG Depth,
    LPSTR FlagDescription,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x)  ", FlagDescription, Flags);

    xdprintf(Depth, "%s", prolog);

    if (Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for (i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if ((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if (count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if ((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if ((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}




/*
**++
**
**  Routine Description:
**
**	Dump a reparse data block
**
**
**  Arguments:
**
**	args - the location of the entry to dump
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpdata) 
    {
    ULONG64	ul64addrReparsePointData = 0;
    ULONG	fFlags                   = 0;
    const ULONG	fLegalFlags              = RPDBG_VERBOSE;


    if (GetExpressionEx (args, &ul64addrReparsePointData, &args))
	{
	sscanf (args, "%x", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}

    if (0 != ul64addrReparsePointData)
	{
	DumpRpData (ul64addrReparsePointData, fFlags);
	}

    return;
    }


VOID
DumpRpData (IN ULONG64 ul64addrReparsePointData,
	    IN ULONG   fFlags)
    {
    ULONG64	ul64addrPrivateData = 0;
    ULONG	ulOffsetPrivateData = 0;
    ULONG64	ul64Time;
    CHAR	achFormattedString [200];
    GUID	guidValue;
    




    GetFieldOffset ("RP_DATA", "data", &ulOffsetPrivateData);

    ul64addrPrivateData = ul64addrReparsePointData + ulOffsetPrivateData;


    GetFieldData (ul64addrReparsePointData, "RP_DATA", "vendorId", sizeof (guidValue), &guidValue);
    FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

    dprintf ("Vendor ID            %s\n", achFormattedString);


    dprintf ("Qualifier            0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "qualifier"));
    dprintf ("Version              0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "version"));

    DumpFlags (0, "Global Bit Flags    ",   GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "globalBitFlags"), RpReparsePointFlags);

    dprintf ("Size of Private Data 0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "numPrivateData"));


    GetFieldData (ul64addrReparsePointData, "RP_DATA", "fileIdentifier", sizeof (guidValue), &guidValue);
    FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

    dprintf ("File Identifier      %s\n", achFormattedString);


    dprintf ("Private Data @       0x%I64x\n", ul64addrPrivateData);

    if (0 != (fFlags & RPDBG_VERBOSE))
	{
	/*	reserved[RP_RESV_SIZE];        // Must be 0 */

	DumpFlags (1, "Bit Flags           ", GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "bitFlags"), RpReparsePointFlags);


	dprintf ("\n");

	GetFieldData (ul64addrPrivateData, "RP_PRIVATE_DATA", "hsmId", sizeof (guidValue), &guidValue);
	FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Hsm Id               %s\n", achFormattedString);


	GetFieldData (ul64addrPrivateData, "RP_PRIVATE_DATA", "bagId", sizeof (guidValue), &guidValue);
	FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Bag Id               %s\n", achFormattedString);


	dprintf ("\n");

	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileVersionId");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  File Version Id      0x%016I64x (%s)\n", ul64Time, achFormattedString);


	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "timegrationTime");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Migration Time       0x%016I64x (%s)\n", ul64Time, achFormattedString);


	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "recallTime");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Recall Time          0x%016I64x (%s)\n", ul64Time, achFormattedString);


	dprintf ("  File Start           0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileStart"));
	dprintf ("  File Size            0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileSize"));
	dprintf ("  Data Start           0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStart"));
	dprintf ("  Data Size            0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataSize"));
	dprintf ("  Verification Data    0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "verificationData"));
	dprintf ("  Verification Type    0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "verificationType"));
	dprintf ("  Recall Count         0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "recallCount"));
	dprintf ("  Data Stream Start    0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamStart"));
	dprintf ("  Data Stream Size     0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamSize"));
	dprintf ("  Data Stream          0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStream"));
	dprintf ("  Data Stream CRC Type 0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamCRCType"));
	dprintf ("  Data Stream CRC      0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamCRC"));
	}


    return ;
    }



/*
**++
**
**  Routine Description:
**
**	Dumps some summary information from the filter
**
**
**  Arguments:
**
**	args - the location of the entry to dump
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpsummary) 
    {
    dprintf ("ExtendedDebug:              %u\n", GetUlongValue ("RsFilter!ExtendedDebug"));
    dprintf ("RsAllowRecalls:             %u\n", GetUlongValue ("RsFilter!RsAllowRecalls"));
    dprintf ("RsNoRecallDefault:          %u\n", GetUlongValue ("RsFilter!RsNoRecallDefault"));
    dprintf ("RsSkipFilesForLegacyBackup: %u\n", GetUlongValue ("RsFilter!RsSkipFilesForLegacyBackup"));
    dprintf ("RsUseUncachedNoRecall:      %u\n", GetUlongValue ("RsFilter!RsUseUncachedNoRecall"));

    dprintf ("RsFileContextId:            %u\n", GetUlongValue ("RsFilter!RsFileContextId"));
    dprintf ("RsFileObjId:                %u\n", GetUlongValue ("RsFilter!RsFileObjId"));
    dprintf ("RsNoRecallReadId:           %u\n", GetUlongValue ("RsFilter!RsNoRecallReadId"));
    dprintf ("RsFsaRequestCount:          %u\n", GetUlongValue ("RsFilter!RsFsaRequestCount"));

    dprintf ("\n");

    dprintf ("RspCacheBlockSize:          %u\n", GetUlongValue ("RsFilter!RspCacheBlockSize"));
    dprintf ("RspCacheMaxBuffers:         %u\n", GetUlongValue ("RsFilter!RspCacheMaxBuffers"));
    dprintf ("RspCacheMaxBuckets:         %u\n", GetUlongValue ("RsFilter!RspCacheMaxBuckets"));
    dprintf ("RspCachePreAllocate:        %u\n", GetUlongValue ("RsFilter!RspCachePreAllocate"));
    dprintf ("RspCacheInitialized:        %u\n", GetUlongValue ("RsFilter!RspCacheInitialized"));

    dprintf ("\n");

    dprintf ("RspCacheBuckets           @ 0x%I64x\n", GetPointerValue ("RsFilter!RspCacheBuckets"));
    dprintf ("RspCacheLru               @ 0x%I64x\n", GetExpression   ("RsFilter!RspCacheLru"));
    dprintf ("RsValidateQHead           @ 0x%I64x\n", GetExpression   ("RsFilter!RsValidateQHead"));
    dprintf ("RsFileContextQHead        @ 0x%I64x\n", GetExpression   ("RsFilter!RsFileContextQHead"));
    dprintf ("RsIoQHead                 @ 0x%I64x\n", GetExpression   ("RsFilter!RsIoQHead"));

    return ;
    }



/*
**++
**
**  Routine Description:
**
**	Walk a queue and count the number of entries
**
**
**  Arguments:
**
**	args - the location of the queue to walk
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpvalque) 
    {
    LIST_ENTRY64	le64ListEntry;
    ULONG64		ul64addrBaseQHead;
    ULONG64		ul64addrItemQHead;
    ULONG		ulEntryCount = 0;
    ULONG		fFlags       = 0;
    ULONG		fLegalFlags  = RPDBG_VERBOSE;
    DWORD		dwStatus     = 0;


    if (GetExpressionEx (args, &ul64addrBaseQHead, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpvalque\n");

	return;
	}


    dwStatus = ReadListEntry (ul64addrBaseQHead, &le64ListEntry);

    ul64addrItemQHead = le64ListEntry.Flink;


    while ((dwStatus) && (!CheckControlC ()) && (ul64addrItemQHead != ul64addrBaseQHead))
	{
	dwStatus = ReadListEntry (ul64addrItemQHead, &le64ListEntry);

	if (fFlags & RPDBG_VERBOSE)
	    {
	    dprintf ("  Entry %4u: QHead 0x%016I64x, Flink 0x%016I64x, Blink 0x%016I64x\n", 
		     ulEntryCount, 
		     ul64addrItemQHead,
		     le64ListEntry.Flink, 
		     le64ListEntry.Blink);
	    }

	ulEntryCount++;

	ul64addrItemQHead = le64ListEntry.Flink;
	}


    dprintf ("  Total entries: %u\n", ulEntryCount);
	

    return ;
    }


/*
**++
**
**  Routine Description:
**
**	Walks the RpIoQueue and dumps some interesting fields
**
**
**  Arguments:
**
**	args - flags
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpioq) 
    {
    LIST_ENTRY64	le64ListEntry;
    ULONG64		ul64addrRsIoQHead;
    ULONG64		ul64addrItemQHead;
    ULONG64		ul64addrIrp;
    ULONG		ulOffsetIrpListEntryFlink;
    ULONG		ulEntryCount = 0;
    ULONG		fFlags       = 0;
    ULONG		fLegalFlags  = 0x0;
    DWORD		dwStatus     = 0;


    ul64addrRsIoQHead = GetExpression ("RsFilter!RsIoQHead");
    
    if (0 != ul64addrRsIoQHead)
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Error retrieving address of RsIoQHead\n");

	return;
	}


    GetFieldOffset ("IRP", "Tail.Overlay.ListEntry.Flink", &ulOffsetIrpListEntryFlink);



    dwStatus = ReadListEntry (ul64addrRsIoQHead, &le64ListEntry);

    ul64addrItemQHead = le64ListEntry.Flink;
    

    while ((dwStatus) && (!CheckControlC ()) && (ul64addrItemQHead != ul64addrRsIoQHead))
	{
	dwStatus = ReadListEntry (ul64addrItemQHead, &le64ListEntry);

	ul64addrIrp = ul64addrItemQHead - ulOffsetIrpListEntryFlink;

	dprintf ("  Entry %4u: QHead 0x%016I64x, Flink 0x%016I64x, Blink 0x%016I64x, Irp 0x%016I64x\n", 
		 ulEntryCount,
		 ul64addrItemQHead,
		 le64ListEntry.Flink, 
		 le64ListEntry.Blink, 
		 ul64addrIrp);


	if (fFlags & RPDBG_VERBOSE)
	    {
	    /*
	    ** Can choose to dump some Irp fields here based off ul64addrIrp if we choose.
	    */
//	    dprintf ("  Entry %4u: Flink 0x%016I64x, Blink 0x%016I64x\n", ulEntryCount, le64ListEntry.Flink, le64ListEntry.Blink);
	    }

	ulEntryCount++;


	ul64addrItemQHead = le64ListEntry.Flink;
	}


    dprintf ("  Total entries: %u\n", ulEntryCount);
	

    return ;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <fsrtl.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#include <memory.h>

// grab the scsi related headers too
#include <scsi.h>
#include <srb.h>


// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG


//
// We're 64 bit aware

#define KDEXT_64BIT

#include <wdbgexts.h>

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\utils.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

   utils.c   

Abstract:

    Various utility routines used by the extensions.

Author:

    Ravisankar Pudipeddi 

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "local.h"


VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}


BOOLEAN
xReadMemory (
            ULONG64 Src,
            PVOID   Dst,
            ULONG   Len
            )
{
   ULONG result;

   return (ReadMemory (Src, Dst, Len, &result) && (result == Len));
}



ULONG GetUlongFromAddress (ULONG64 Location)
    {
    ULONG Value = 0;
    ULONG result;

    if ((!ReadMemory (Location, &Value, sizeof (ULONG), &result)) || (result < sizeof (ULONG))) 
	{
        dprintf ("unable to read from %08x\n", Location);
	}

    return (Value);
    }


ULONG64 GetPointerFromAddress (ULONG64 Location)
    {
    ULONG64 Value = 0;
    ULONG   result;

    if (ReadPointer (Location, &Value))
	{
        dprintf ("unable to read from %016p\n", Location);
	}

    return (Value);
    }


ULONG GetUlongValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG   Value = 0;
    ULONG   result;


    Location = GetExpression (String);

    if (!Location) 
	{
        dprintf ("unable to get %s\n", String);
	}

    return GetUlongFromAddress( Location );
    }


ULONG64 GetPointerValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG64 Value = 0;


    Location = GetExpression (String);

    if (!Location) 
	{
        dprintf ("unable to get %s\n", String);
	}


    ReadPointer (Location, &Value);

    return (Value);
    }




ULONG GetFieldValueUlong32 (ULONG64 ul64addrStructureBase,
			    PCHAR   pchStructureType,
			    PCHAR   pchFieldname)
    {
    ULONG	ulReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ulReturnValue);

    return (ulReturnValue);
    }


ULONG64 GetFieldValueUlong64 (ULONG64 ul64addrStructureBase,
			      PCHAR   pchStructureType,
			      PCHAR   pchFieldname)
    {
    ULONG64	ul64ReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ul64ReturnValue);

    return (ul64ReturnValue);
    }



ULONG FormatDateAndTime (ULONG64 ul64Time, PCHAR pszFormattedDateAndTime, ULONG ulBufferLength)
    {
    FILETIME		ftTimeOriginal;
    FILETIME		ftTimeLocal;
    SYSTEMTIME		stTimeSystem;
    CHAR		achFormattedDateString [200];
    CHAR		achFormattedTimeString [200];
    DWORD		dwStatus   = 0;
    BOOL		bSucceeded = FALSE;
    ULARGE_INTEGER	uliConversionTemp;
    int			iReturnValue;


    uliConversionTemp.QuadPart = ul64Time;

    ftTimeOriginal.dwLowDateTime  = uliConversionTemp.LowPart;
    ftTimeOriginal.dwHighDateTime = uliConversionTemp.HighPart;


    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToLocalFileTime (&ftTimeOriginal, &ftTimeLocal);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToSystemTime (&ftTimeLocal, &stTimeSystem);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetDateFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedDateString, 
				      sizeof (achFormattedDateString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetTimeFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedTimeString, 
				      sizeof (achFormattedTimeString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = _snprintf (pszFormattedDateAndTime, 
				  ulBufferLength / sizeof (CHAR), 
				  "%s %s",
				  achFormattedDateString,
				  achFormattedTimeString);

	if (iReturnValue < 0)
	    {
	    dwStatus = ERROR_INSUFFICIENT_BUFFER;
	    }
	else
	    {
	    dwStatus = 0;
	    }
	}



    if (0 != dwStatus)
	{
	if (0 == ul64Time)
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time not specified");
	    }
	else
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time invalid");
	    }
	}



    return (dwStatus);
    }




/*
** {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} 
*/
ULONG FormatGUID (GUID guidValue, PCHAR pszFormattedGUID, ULONG ulBufferLength)
    {
    DWORD	dwStatus = 0;


    if (sizeof ("{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}") > ulBufferLength)
	{
	dwStatus = ERROR_INSUFFICIENT_BUFFER;
	}


    if (0 == dwStatus)
	{
	_snprintf (pszFormattedGUID, ulBufferLength, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
		   guidValue.Data1,
		   guidValue.Data2,
		   guidValue.Data3,
		   guidValue.Data4[0],
		   guidValue.Data4[1],
		   guidValue.Data4[2],
		   guidValue.Data4[3],
		   guidValue.Data4[4],
		   guidValue.Data4[5],
		   guidValue.Data4[6],
		   guidValue.Data4[7]);
	}


    return (dwStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\kdexts\local.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

   local.h

Abstract:

   local header to be included by all source files
   pertaining to the kdext dll

Author:

   Ravisankar Pudipeddi 

Environment:

    User Mode.

Revision History:

--*/



//
// Util functions
//
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

BOOLEAN
xReadMemory (
            ULONG64 Src,
            PVOID   Dst,
            ULONG   Len
            );

ULONG64 GetPointerValue       (PCHAR   String);
ULONG64 GetPointerFromAddress (ULONG64 Location);
ULONG   GetUlongValue         (PCHAR   String);
ULONG   GetUlongFromAddress   (ULONG64 Location);

ULONG   GetFieldValueUlong32 (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);
ULONG64 GetFieldValueUlong64 (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);

ULONG FormatDateAndTime  (ULONG64 ul64Time,  PCHAR pszFormattedDateAndTime, ULONG ulBufferLength);
ULONG FormatGUID         (GUID    guidValue, PCHAR pszFormattedGUID,        ULONG ulBufferLength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\launch\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#include "wsb.h"
#include "resource.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500 //for WinNT 4.0 or Win95 with DCOM
#endif 

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "MvrInt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION


#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\launch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VERSION.RC
//
#define IDS_APPLICATION_TITLE           1
#define IDS_INVALID_PARAMETER           100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_)
#define AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\launch\rslaunch.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rslaunch.cpp

Abstract:

    HSM Remote Storage Job Launch Program.

    This program is used by the HSM Remote Storage system to submit 
    user-requested jobs to the NT Task Scheduler.  This standalone command 
    line program has two primary functions:  to start the HSM job specified 
    and not return until the job has completed; and to call into the HSM 
    Engine to either update secondary storage copy set media, or to 
    re-create a master secondary storage media from its most recent copy.  
    
    NOTE: This program is linked as a windows program, but has no visible
    window.  It  creates an invisible window so it can get the WM_CLOSE
    message from the Task Scheduler if the user wants to cancel the job.
    
    ALSO NOTE: This program has no correspoinding header file.

--*/

#include "stdafx.h"
#include "windows.h"
#include "stdio.h"

#include "wsb.h"
#include "hsmeng.h"
#include "fsa.h"
#include "job.h"
#include "rms.h"
#include "hsmconn.h"

HINSTANCE g_hInstance;

//#define RSL_TRACE
#if defined(RSL_TRACE)
#define LTRACE(x)        WsbTracef x
#else
#define LTRACE(x)
#endif

#define TRACE_FILE    L"RsLaunch.trc"
#define WINDOW_CLASS  L"RsLaunchWin"

//  Typedefs
typedef enum {  // Type of work requested
    WORK_NONE,
    WORK_RUN,
    WORK_RECREATE,
    WORK_SYNCH
} WORK_TYPE;

typedef struct {  // For passing data to/from DoWork
    WCHAR *     pCmdLine;
    WORK_TYPE   wtype;
    HRESULT     hr;
    IHsmJob *   pJob;
} DO_WORK_DATA;

//  Global data
CComModule      _Module;

//  Local data

//  Local functions
static HRESULT CancelWork(DO_WORK_DATA* pWork);
static HRESULT ConnectToServer(IHsmServer** ppServer);
static BOOL    CreateOurWindow(HINSTANCE hInstance);
static DWORD   DoWork(void* pVoid);
static HRESULT RecreateMaster(GUID oldMasterMediaId, 
    OLECHAR* oldMasterMediaName, USHORT copySet);
static void    ReportError(HRESULT hr);
static HRESULT RunJob(OLECHAR* jobName, IHsmJob** ppJob);
static HRESULT SynchronizeMedia(OLECHAR* poolName, USHORT copySet);
static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
            LPARAM lParam);


//******************************   Functions:


static HRESULT 
CancelWork(
    IN DO_WORK_DATA* pWork
    ) 

/*++

Routine Description:

    Try to cancel the current work.

Arguments:

    None.

Return Value:

    S_OK  - Success

--*/
{ 
    HRESULT hr = E_FAIL;

    LTRACE((L"CancelWork: entry\n"));

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));
        
        //  Because of a possible timing problem, we may have to wait
        //  for the operation to start before we can cancel it
        for (int i = 0; i < 60; i++) {
            if (WORK_RUN == pWork->wtype) {
                LTRACE((L"CancelWork: wtype = WORK_RUN, pJob = %p\n",
                        pWork->pJob));
                if (pWork->pJob) {
                    LTRACE((L"CancelWork: cancelling job\n"));
                    hr = pWork->pJob->Cancel(HSM_JOB_PHASE_ALL);
                    break;
                }
            } else {
                LTRACE((L"CancelWork: cancelling copy media operation\n"));
                if (S_OK == pServer->CancelCopyMedia()) {
                    hr = S_OK;
                    break;
                }
            }

            Sleep(1000);
        }
    } WsbCatch(hr);


    LTRACE((L"CancelWork: exit = %ls\n", WsbHrAsString(hr)));
    return(hr);
}


static HRESULT 
ConnectToServer(
    IN OUT IHsmServer** ppServer
    ) 

/*++

Routine Description:

    Connect to the server that will do the work.

Arguments:

    ppServer - Pointer to pointer to server.

Return Value:

    S_OK  - Success

--*/
{ 
    HRESULT hr = S_OK;

    LTRACE((L"ConnectToServer: entry\n"));

    try {
        CWsbStringPtr           tmpString;

        WsbAffirm(ppServer, E_POINTER);
        WsbAffirm(!(*ppServer), E_FAIL);

        // Store of the name of the server.
        WsbAffirmHr( WsbGetComputerName( tmpString ) );

        // Find the Hsm to get it's id.
        WsbAffirmHr(HsmConnectFromName(HSMCONN_TYPE_HSM, tmpString, IID_IHsmServer, 
                (void**) ppServer));
    } WsbCatch(hr);


    LTRACE((L"ConnectToServer: exit = %ls\n", WsbHrAsString(hr)));
    return(hr);
}


static BOOL 
CreateOurWindow(
    HINSTANCE hInstance
    ) 

/*++

Routine Description:

    Create our invisible window.

    NOTE: If the Task Scheduler ever gets smarter and can send the WM_CLOSE
    message to an application without a window, the invisible window may
    not be needed.

Arguments:

    hInstance - Handle for this instance of the program.

Return Value:

    TRUE  - Everything worked.

    FALSE - Something went wrong.


            
--*/
{ 
    BOOL     bRet  = FALSE;
    WNDCLASS wc; 

    //  Register our window type 
    wc.style = 0; 
    wc.lpfnWndProc = &WindowProc; 
    wc.cbClsExtra = 0; 
    wc.cbWndExtra = 0; 
    wc.hInstance = hInstance; 
    wc.hIcon = NULL; 
    wc.hCursor = NULL; 
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName = NULL; 
    wc.lpszClassName = WINDOW_CLASS; 
    if  (RegisterClass(&wc)) {

        //  Create the window (invisible by default)
        if (CreateWindowEx(  0, 
                WINDOW_CLASS, 
                L"RsLaunch", 
                WS_OVERLAPPEDWINDOW, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                NULL, 
                NULL, 
                hInstance, 
                NULL)) {
            bRet = TRUE;
        } else {
            LTRACE((L"CreateWindowEx failed\n"));
        }
    } else {
        LTRACE((L"RegisterClass failed\n"));
    }
    return(bRet);
}


static DWORD   
DoWork(
    IN void* pVoid
    )

/*++

Routine Description:

    Process the command line and start the processing.

Arguments:

    pVoid - A pointer (cast to void*) to a DO_WORK_DATA structure.

Return Value:

    The return value from the job
            
--*/

{
    HRESULT          hr = S_OK;
    DO_WORK_DATA *   pWork;

    LTRACE((L"DoWork: entry\n"));

    pWork = static_cast<DO_WORK_DATA*>(pVoid);

    try {
        WCHAR            delims[] = L" \r\n\t\"";
        WCHAR            delims2[] = L" \t";
        WCHAR            delims3[] = L"\"";
        WCHAR *          pToken;

        WsbAssert(pWork, E_POINTER);
        WsbAssert(pWork->pCmdLine, E_POINTER);
        LTRACE((L"DoWork: CmdLine = %ls\n", pWork->pCmdLine));

        // Validate we have a parameter
        pToken = wcstok(pWork->pCmdLine, delims);
        WsbAssert(pToken, E_INVALIDARG);

        // What type of request is it?
        if (_wcsicmp(pToken, OLESTR("run")) == 0) {
            CWsbStringPtr       jobName;

            // 'run' option passed in
            pWork->wtype = WORK_RUN;

            //  The job name can have embedded spaces so it may be in quotes.
            //  This means that using wcstok may not work correctly.
            pToken = pToken + wcslen(pToken) + 1; // Skip "run" & NULL
            pToken = pToken + wcsspn(pToken, delims2); // Skip spaces
            if (L'\"' == *pToken) {
                //  Job name is in quotes
                jobName = wcstok(pToken, delims3);
            } else {
                jobName = wcstok(pToken, delims);
            }
            WsbAssert(jobName, E_INVALIDARG);
            LTRACE((L"DoWork: calling RunJob(%ls)\n", jobName));
            WsbAffirmHr(RunJob(jobName, &(pWork->pJob)));

        } else if (_wcsicmp(pToken, OLESTR("sync")) == 0) {
            CWsbStringPtr       poolName;
            USHORT              copySet = 1;
            WCHAR *             pTemp;

            // 'sync' (update a copy set) option passed in
            pWork->wtype = WORK_SYNCH;
            pToken = wcstok(NULL, delims);
            WsbAssert(pToken, E_INVALIDARG);
            pTemp = wcstok(NULL, delims);
            if (!pTemp) {
                // will pass NULL for poolName if no pool name specified
                copySet = (USHORT) _wtoi(pToken);
            } else {
                poolName = pToken;
                copySet = (USHORT) _wtoi(pTemp);
            }

            WsbAffirmHr(SynchronizeMedia(poolName, copySet));

        } else if (_wcsicmp(pToken, OLESTR("recreate")) == 0) {
            USHORT              copySet = 0;
            CWsbStringPtr       mediaName;
            GUID                mediaId = GUID_NULL;

            // 'recreate' (re-create a master media) option passed in
            pWork->wtype = WORK_RECREATE;
            pToken = wcstok(NULL, delims);
            WsbAssert(pToken, E_INVALIDARG);
            if ( _wcsicmp(pToken, OLESTR("-i")) == 0 ) {

                // media id was passed in, convert from string to GUID
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                WsbAffirmHr(WsbGuidFromString( pToken, &mediaId ));
            } else if ( _wcsicmp(pToken, OLESTR("-n")) == 0 ) {

                // Media description (name) was passed in.
                // The function RecreateMaster() will look up its id (GUID).
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                mediaName = pToken;
            }

            // Get copySet number
            pToken = wcstok(NULL, delims);
            if (pToken && _wcsicmp(pToken, OLESTR("-c")) == 0) {
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                copySet = (USHORT) _wtoi(pToken);
            }

            WsbAffirmHr( RecreateMaster( mediaId, mediaName, copySet ));

        } else {
            WsbThrow(E_INVALIDARG);
        }
    } WsbCatch(hr);

    if (pWork) {
        pWork->hr = hr;
    }

    LTRACE((L"DoWork: exit = %ls\n", WsbHrAsString(hr)));
    return(static_cast<DWORD>(hr));
}


static HRESULT 
RecreateMaster(
    IN GUID     oldMasterMediaId, 
    IN OLECHAR* oldMasterMediaName,
    IN USHORT   copySet
    )

/*++

Routine Description:

    This routine implements the method that will cause a Remote Storage master media
    to be re-created by calling the appropraite method on the Remote Storage engine.  
    The master will be re-created from the specified copy or its most recent copy.

Arguments:

    oldMasterMediaId - The GUID of the current master media which is to be re-created.
                    Normally passed, but an option exists where if the master's
                    description is passed, the id (GUID) will be looked up by this
                    method prior to invoking the engine.  See below.

    oldMasterMediaName - A wide character string representing the master media's 
                    description (display name).  If this argument is passed with a valid 
                    string, the string is used to look up the oldMasterMediaId above.

    copySet  - The copyset number of the copy to use for the recreation or zero, which
                    indicates that the Engine should just use the most recent copy

Return Value:

    S_OK - The call succeeded (the specified master was re-created).

    E_FAIL - Could not get host computer's name (highly unexpected error).

    E_UNEXPECTED - The argument 'oldMasterMediaId' equaled GUID_NULL just prior to
            calling the HSM Engine to re-create a media master.  This argument should
            either be received with a valid value (the norm), or it should be set by this
            method if a valid media description was passed in as 'oldMasterMediaName'. 

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));

        // If we were passed a media name, find its id.  Since the name option is
        // presently only used internally and it bypasses the UI, also mark
        // the media record for re-creation (normally done by the UI) otherwise
        // the RecreateMaster() call below will fail.

        // If the string is not null...
        if ( oldMasterMediaName != 0 ) {
            // and if the 1st character of the string is not the null terminator
            if ( *oldMasterMediaName != 0 ) {
                WsbAffirmHr(pServer->FindMediaIdByDescription(oldMasterMediaName, 
                                                                &oldMasterMediaId));
                WsbAffirmHr(pServer->MarkMediaForRecreation(oldMasterMediaId));
            }
        }

        // Ensure we have a non-null media id
        WsbAffirm( oldMasterMediaId != GUID_NULL, E_UNEXPECTED );
        
        // Re-create the master media.
        WsbAffirmHr(pServer->RecreateMaster( oldMasterMediaId, copySet ));

    } WsbCatch(hr);

    return(hr);
}


static void    
ReportError(
    IN HRESULT hr
    )

/*++

Routine Description:

    Report errors.

Arguments:

    hr - The error.

Return Value:

    None.
            
--*/

{
    CWsbStringPtr   BoxTitle;
    CWsbStringPtr   BoxString;
    CWsbStringPtr   BoxString1;
    CWsbStringPtr   BoxString2;
    CWsbStringPtr   BoxString3;
    CWsbStringPtr   BoxString4;
    CWsbStringPtr   BoxString5;
    CWsbStringPtr   BoxString6;
    BOOL            displayMsg = FALSE;
    UINT            style = MB_OK;

#if DBG
    if (E_INVALIDARG == hr) {
         // If this is a Debug build then command line invocation is allowed.
        // (Debug build implies Development/Test usage.) 
        // Tell them the valid command lines.  Since this program, originally 
        // written as a console app, is now linked as a Windows program, pop
        // this up as a message box.
        
        // define the lines of text to appear in the message box
        BoxString  = L"Remote Storage Launch Program\r\n";
        BoxString1 = L"allowable command line options:\r\n\n";
        BoxString2 = L"   RSLAUNCH run <job name>\r\n";
        BoxString3 = L"   RSLAUNCH sync <copyset number>\r\n";
        BoxString4 = L"   RSLAUNCH sync <pool name> <copyset number>\r\n";
        BoxString5 = L"   RSLAUNCH recreate -i <media id> [-c <copyset number>]\r\n";
        BoxString6 = L"   RSLAUNCH recreate -n <media name> [-c <copyset number>]\r\n";

        // display the Help message box
        style =  MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND;
        displayMsg = TRUE;

    } else {

        // message box text lines
        BoxString  = L"An error occurred while Remote Storage Launch was launching a job.\n";
        BoxString1 = WsbHrAsString(hr);

        // display the Error message box
        style = MB_OK | MB_ICONERROR | MB_TOPMOST;
        displayMsg = TRUE;
    }

#else
    if (E_INVALIDARG == hr) {
        // error message box if the Release version:
            
        // message box text lines
        BoxString.LoadFromRsc( g_hInstance, IDS_INVALID_PARAMETER );

        // display the Error message box
        style = MB_OK | MB_ICONERROR | MB_SETFOREGROUND;
        displayMsg = TRUE;
    }
#endif // DBG

    if (displayMsg) {
        // concatenate all text lines
        BoxString.Append( BoxString1 );
        BoxString.Append( BoxString2 );
        BoxString.Append( BoxString3 );
        BoxString.Append( BoxString4 );
        BoxString.Append( BoxString5 );
        BoxString.Append( BoxString6 );
        WsbAffirm(0 != (WCHAR *)BoxString, E_OUTOFMEMORY);

        // message box title line
        WsbAffirmHr(BoxTitle.LoadFromRsc( g_hInstance, IDS_APPLICATION_TITLE ));

        // display the Help message box
        MessageBox( NULL, BoxString, BoxTitle, style);
    }

}


static HRESULT 
RunJob(
    IN  OLECHAR* jobName, 
    OUT IHsmJob** ppJob
    )

/*++

Routine Description:

    This routine implements the method for running a Remote Storage job.

Arguments:

    jobName - A wide character string containing the name of the job to run.

    ppJob   - Pointer to pointer to Job interface obtained from the server

Return Value:

    S_OK - The call succeeded (the specified job ran successfully).

    E_POINTER - Input argument 'jobName' is null.

    E_FAIL - Used to indicate 2 error conditions:
                1. could not get host computer's name (highly unexpected error);
                2. the job run by this method returned an HRESULT other than S_OK.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                 hr = S_OK;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAssert(0 != jobName, E_POINTER);
        WsbAssert(ppJob, E_POINTER);
        WsbAffirmHr(ConnectToServer(&pServer));

        // Find the job, start the job, wait for the job to complete.
        WsbAffirmHr(pServer->FindJobByName(jobName, ppJob));
        WsbAffirmHr((*ppJob)->Start());
        WsbAffirmHr((*ppJob)->WaitUntilDone());

    } WsbCatch(hr);

    return(hr);
}



static HRESULT 
SynchronizeMedia(
    IN OLECHAR* poolName, 
    IN USHORT copySet
    )

/*++

Routine Description:

    This routine implements the method that will cause the updating (synchronizing) of 
    an entire copy set by calling the appropriate method on the Remote Storage engine.  
    Specifically, this method causes all copy media belonging to a specified copy set 
    to be checked for synchronization (being up to date) with each of their respective
    master media.  Those out of date will be brought up to date.  Running this method
    assumes that Remote Storage has already been configured for a certain number of
    copy sets.

Arguments:

    poolName - A wide character string containing the name of a specific storage pool
                that the user wants the specified copy set synchronized for.  If this 
                argument is passed as NULL then all storage pools will have the specified
                copy set synchronized.

    copySet - A number indicating which copy set is to be synchronized.

Return Value:

    S_OK - The call succeeded (the specified copy set of the specified storage pool was
                updated).

    E_FAIL - Could not get host computer's name (highly unexpected error).

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;
    GUID                        poolId = GUID_NULL;
    CComPtr<IHsmStoragePool>    pPool;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));

        // If they specified a pool, then find it's id.
        if ( poolName != 0 ) {
            if ( *poolName != 0 ) {
                CWsbStringPtr tmpString;

                WsbAffirmHr(pServer->FindStoragePoolByName(poolName, &pPool));
                WsbAffirmHr(pPool->GetMediaSet(&poolId, &tmpString));
            }
        }

        // Synchronize the media.  Note that if no pool name was passed in, we pass
        // GUID_NULL as the pool id.
        WsbAffirmHr(pServer->SynchronizeMedia(poolId, copySet));

    } WsbCatch(hr);

    return(hr);
}

//  WindowProc - Needed for our invisible window
static LRESULT CALLBACK 
WindowProc(  
    HWND   hwnd,  
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
  )
{
    LTRACE((L"WindowProc: msg = %4.4x\n", uMsg));
    return(DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//******************************   MAIN   *********************************

extern "C"
int WINAPI wWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, 
    LPTSTR lpCmdLine, 
    int /*nShowCmd*/
    )
{
    HRESULT             hr = S_OK;
#if defined(RSL_TRACE)
    CComPtr<IWsbTrace>  pTrace;
#endif

    // Store our instance handle so it can be used by called code.
    g_hInstance = hInstance;

    try {
        HANDLE         hJobThread[1] = { NULL };
        DO_WORK_DATA   workData = { NULL, WORK_NONE, E_FAIL, NULL };

        // Register & create our invisible window
        WsbAssert(CreateOurWindow(hInstance), E_FAIL);

        // Initialize COM
        WsbAffirmHr(CoInitializeEx(NULL, COINIT_MULTITHREADED));

        // This provides a NULL DACL - RsNotify is only a COM client therefore this ACL is not important
        // If a COm object is ever implemented here, the ACL should match potential clients.
        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();
        WsbAffirmHr(CoInitializeSecurity(sd, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IDENTIFY, NULL, 
            EOAC_NONE, NULL));

        try {
            DWORD               ThreadId = 0;

#if defined(RSL_TRACE)
            //  Start tracing
            CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace,
                    (void **) &pTrace);
            pTrace->DirectOutput(WSB_TRACE_OUT_DEBUG_SCREEN | WSB_TRACE_OUT_FILE);
            pTrace->SetTraceFileControls(TRACE_FILE, FALSE, 3000000, NULL);
            pTrace->SetOutputFormat(TRUE, TRUE, TRUE);
            pTrace->SetTraceSettings(0xffffffffffffffffL);
            pTrace->StartTrace();
#endif

            LTRACE((L"Main: lpCmdLine = %ls\n", lpCmdLine));
            workData.pCmdLine = lpCmdLine;

            //  Create a thread to start the work and wait for it
            //  to finish
            LTRACE((L"Main: creating thread for DoWork\n"));
            hJobThread[0] = CreateThread(0, 0, DoWork, 
                    static_cast<void*>(&workData), 0, &ThreadId);
            if (!hJobThread[0]) {
                LTRACE((L"Main: CreateThread failed\n"));
                WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
            }

            //  Don't exit if we're waiting for work to complete
            while (TRUE) {
                DWORD exitcode;
                DWORD waitStatus;

                //  Wait for a message or thread to end
                LTRACE((L"Main: waiting for multiple objects\n"));
                waitStatus = MsgWaitForMultipleObjects(1, hJobThread, FALSE, 
                        INFINITE, QS_ALLINPUT);

                //  Find out which event happened
                if (WAIT_OBJECT_0 == waitStatus) {

                    //  The thread ended; get it's exit code
                    LTRACE((L"Main: got event on thread\n"));
                    if (GetExitCodeThread(hJobThread[0], &exitcode)) {
                        if (STILL_ACTIVE == exitcode) {
                            //  This shouldn't happen; don't know what to do!
                        } else {
                            WsbThrow(static_cast<HRESULT>(exitcode));
                        }
                    } else {
                        WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
                    }

                } else if ((WAIT_OBJECT_0 + 1) == waitStatus) {

                    //  Message in queue
                    MSG   msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        LTRACE((L"Main: message = %4.4x\n", msg.message));
                        if (WM_CLOSE == msg.message) {

                            //  Cancel the job since someone cancelled us.
                            //  (Should we kill the thread that is waiting?)
                            LTRACE((L"Main: got WM_CLOSE\n"));
                            WsbThrow(CancelWork(&workData));
                        }
                        DispatchMessage(&msg);
                    }

                } else if (0xFFFFFFFF == waitStatus) {

                    //  Error in MsgWaitForMultipleObjects
                    WsbThrow(HRESULT_FROM_WIN32(GetLastError()));

                } else {

                    //  This shouldn't happend; don't know what to do
                }
            }

        } WsbCatch(hr);

        if (hJobThread[0]) {
            CloseHandle(hJobThread[0]);
        }

        if (workData.pJob) {
            workData.pJob->Release();
        }

        // Cleanup COM
        CoUninitialize();
    
    } WsbCatch(hr);

    LTRACE((L"Main: exit hr = %ls\n", WsbHrAsString(hr)));
    if (FAILED(hr)) {
        ReportError(hr);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\makefile.inc ===
$(O)\mover.res: FilterIo.rgs \
                NtTapeIo.rgs \
                NtFileIo.rgs \
                ..\..\inc\$(O)\MvrLib.tlb 

stdafx.h: ..\..\inc\Mover.h ..\..\inc\Rms.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\filterio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FilterIo.cpp

Abstract:

    CFilterIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "FilterIo.h"
#include "Mll.h"
#include "Mll.h"
#include "rpdata.h"
#include "rpio.h"


int CFilterIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

#pragma optimize("g", off)

STDMETHODIMP
CFilterIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hFile = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_isLocalStream = FALSE;
        m_OriginalAttributes = 0;
        m_BlockSize = DefaultBlockSize;
        m_filterId = 0;
        m_ioctlHandle = INVALID_HANDLE_VALUE;
        m_ioctlBuffer = NULL;
        m_bytesInBuffer = 0;
        m_pDataBuffer = NULL;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CFilterIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CFilterIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FinalRelease"), OLESTR(""));

    try {

        (void) CloseStream();  // in case anything is left open

        CComObjectRoot::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CFilterIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CFilterIo::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
#pragma optimize("", on)



HRESULT
CFilterIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CFilterIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CFilterIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CFilterIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFilterIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CFilterIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CFilterIo::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//


STDMETHODIMP
CFilterIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetObjectId"), OLESTR(""));

    UNREFERENCED_PARAMETER(pObjectId);

    try {

        WsbThrow( E_NOTIMPL );

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

Notes:

    Each session is written as a single MTF file data set.  To create a consistant
    MTF data set we copy the MediaLabel object and use it for the TAPE DBLK for
    each data set generated.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::EndSession"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER *pRemoteDataSetStart,
    OUT ULARGE_INTEGER *pRemoteFileStart,
    OUT ULARGE_INTEGER *pRemoteFileSize,
    OUT ULARGE_INTEGER *pRemoteDataStart,
    OUT ULARGE_INTEGER *pRemoteDataSize,
    OUT DWORD *pRemoteVerificationType,
    OUT ULARGE_INTEGER *pRemoteVerificationData,
    OUT DWORD *pDatastreamCRCType,
    OUT ULARGE_INTEGER *pDatastreamCRC,
    OUT ULARGE_INTEGER *pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    UNREFERENCED_PARAMETER(pRemoteDataSetStart);
    UNREFERENCED_PARAMETER(pRemoteFileStart);
    UNREFERENCED_PARAMETER(pRemoteFileSize);
    UNREFERENCED_PARAMETER(pRemoteDataStart);
    UNREFERENCED_PARAMETER(pRemoteDataSize);
    UNREFERENCED_PARAMETER(pRemoteVerificationType);
    UNREFERENCED_PARAMETER(pDatastreamCRC);
    UNREFERENCED_PARAMETER(pUsn);
    UNREFERENCED_PARAMETER(pRemoteVerificationData);
    UNREFERENCED_PARAMETER(pDatastreamCRCType);
    
    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::RecallData(
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*options*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::RecallData"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CFilterIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::ReadLabel(
    IN OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::ReadLabel"), OLESTR(""));


    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CFilterIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::VerifyLabel"), OLESTR("<%ls>"), label);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::GetDeviceName(
    OUT BSTR* pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetDeviceName"), OLESTR(""));

    UNREFERENCED_PARAMETER(pName);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::GetDeviceName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::SetDeviceName(
    IN BSTR name,
    IN BSTR volumeName)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    HRESULT     hr = S_OK;
    DWORD       lpSectorsPerCluster;
    DWORD       lpBytesPerSector;
    DWORD       lpNumberOfFreeClusters;
    DWORD       lpTotalNumberOfClusters;
    CWsbBstrPtr volName;

    try {
        WsbAssertPointer(name);

        WsbAssert(wcslen((WCHAR *)name) > 0, E_INVALIDARG);

        m_DeviceName = name;
        
        WsbTraceAlways( OLESTR("CFilterIo: SetDeviceName  Opening %ws.\n"), (PWCHAR) m_DeviceName);
        
        WsbAffirmHandle(m_ioctlHandle = CreateFile(m_DeviceName, FILE_WRITE_DATA | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL));
        
        
        if (volumeName != 0) {
            volName = volumeName;
        } else {
            //
            // Use the supplied device name itself as the vol name
            //
            volName = m_DeviceName;           
        }

        volName.Append(L"\\");

        WsbTraceAlways( OLESTR("CFilterIo: Getdisk free space for %ws.\n"), (PWCHAR) volName);

        if (GetDiskFreeSpace(volName, &lpSectorsPerCluster, &lpBytesPerSector,  &lpNumberOfFreeClusters, &lpTotalNumberOfClusters) != 0) {
            m_secSize = lpBytesPerSector;
        } else {
            WsbThrow(E_FAIL);
        }

    } WsbCatch(hr);

    return S_OK;
}


STDMETHODIMP
CFilterIo::GetLargestFreeSpace(
    OUT LONGLONG* pFreeSpace,
    OUT LONGLONG* pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh
    )
/*++

Implements:

    IDataMover::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetLargestFreeSpace"), OLESTR(""));
    
    UNREFERENCED_PARAMETER(pFreeSpace);
    UNREFERENCED_PARAMETER(pCapacity);
    UNREFERENCED_PARAMETER(defaultFreeSpaceLow);
    UNREFERENCED_PARAMETER(defaultFreeSpaceHigh);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    WsbTraceOut(OLESTR("CFilterIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CFilterIo::GetCartridge(
    OUT IRmsCartridge** ptr
    )
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;
    
    UNREFERENCED_PARAMETER(ptr);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CFilterIo::SetCartridge(
    IN IRmsCartridge* ptr
    )
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER(ptr);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CFilterIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Cancel"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::CreateLocalStream(
    IN BSTR name,
    IN DWORD mode,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );
        WsbAffirm( mode & MVR_MODE_WRITE, E_UNEXPECTED ); // Only Recall supported this way.

        m_Mode = mode;
        m_StreamName = name;
        m_isLocalStream = TRUE;


        if ( m_Mode & MVR_FLAG_HSM_SEMANTICS ) {
            //
            // Recall - Filter has the file object
            //
            // Save away the filter ID
            //
            WsbTrace( OLESTR("CFilterIo: ID = %ws\n"), (PWCHAR) name);
            
            swscanf((PWCHAR) name, L"%I64u", &m_filterId);

        } else {
            //
            // Restore - Not supported.
            //
            WsbThrow(E_NOTIMPL);
        }

        WsbTrace( OLESTR("CFilterIo: Query...\n"));
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface(IID_IStream, (void **) ppStream));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR /*remoteSessionDescription*/,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream **ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CreateRemoteStream"), OLESTR(""));

    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(mode);
    UNREFERENCED_PARAMETER(name);
    UNREFERENCED_PARAMETER(ppStream);
    UNREFERENCED_PARAMETER(remoteDataSetStart);
    UNREFERENCED_PARAMETER(remoteFileStart);
    UNREFERENCED_PARAMETER(remoteFileSize);
    UNREFERENCED_PARAMETER(remoteDataStart);
    UNREFERENCED_PARAMETER(remoteDataSize);
    UNREFERENCED_PARAMETER(remoteVerificationType);
    UNREFERENCED_PARAMETER(remoteVerificationData);
    
    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CloseStream"), OLESTR(""));

    try {
        if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(m_ioctlHandle);
            m_ioctlHandle = INVALID_HANDLE_VALUE;
        }
        if (m_ioctlBuffer != NULL) {
            VirtualFree(m_ioctlBuffer, 0, MEM_RELEASE);
            m_ioctlBuffer = NULL;
        }
    
        hr = S_OK;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Duplicate(
    IN IDataMover* /*pDestination*/,
    IN DWORD /*options*/,
    OUT ULARGE_INTEGER* /*pBytesCopied*/,
    OUT ULARGE_INTEGER* /*pBytesReclaimed*/)
/*++

Implements:

    IDataMover::Duplicate

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Duplicate"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::Duplicate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FlushBuffers"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

--*/
{
    HRESULT hr = S_OK;
    *pDeleteFile = FALSE;
    WsbTraceIn(OLESTR("CFilterIo::Recover"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CFilterIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead)
/*++

Implements:

    IStream::Read

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    UNREFERENCED_PARAMETER(pcbRead);
    UNREFERENCED_PARAMETER(pv);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Read"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Write(
    IN void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), 
        cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);


        WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));

        if (pcbWritten) {
            *pcbWritten = bytesWritten;
        }

        // NOTE: Stream offset is updated by WriteBuffer

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CFilterIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Seek"), OLESTR("<%I64d> <%d>"), dlibMove.QuadPart, dwOrigin);

    UNREFERENCED_PARAMETER(plibNewPosition);
    
    try {

        //
        // Note: Somewhere it is written that FILE_BEGIN is always and
        //       forever same as STREAM_SEEK_CUR, etc.
        //
        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            m_StreamOffset.QuadPart = dlibMove.QuadPart;
            break;

        case STREAM_SEEK_CUR:
            m_StreamOffset.QuadPart += dlibMove.QuadPart;
            break;

        case STREAM_SEEK_END:
            WsbThrow( E_NOTIMPL );
            break;

        default:
            WsbThrow(STG_E_INVALIDFUNCTION);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Seek"), OLESTR("hr = <%ls>, newPosition=%I64u"), WsbHrAsString(hr), m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CFilterIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    UNREFERENCED_PARAMETER(pcbWritten);
    UNREFERENCED_PARAMETER(pcbRead);
    UNREFERENCED_PARAMETER(pstm);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT     hr = S_OK;
    PRP_MSG     pMsgBuff = (PRP_MSG) NULL;
    DWORD       ioSize, xferSize, retSize, lastError;
    BOOL        code;
    DWORD       offsetFrom;
    

    WsbTraceIn(OLESTR("CFilterIo::Commit"), OLESTR(""));
    
    UNREFERENCED_PARAMETER(grfCommitFlags);

    try {
        WsbAffirmPointer(m_ioctlBuffer);
        //
        // Bail out with a success code if there are no more bytes to write.
        //
        WsbAffirm(m_bytesInBuffer != 0, S_OK);

        ioSize = sizeof(RP_MSG) + m_bytesInBuffer + m_secSize;
        
        offsetFrom = ((sizeof(RP_MSG) / m_secSize) + 1) * m_secSize;
        
        m_pDataBuffer = (PCHAR) m_ioctlBuffer + offsetFrom;
        pMsgBuff = (PRP_MSG) m_ioctlBuffer;
        pMsgBuff->msg.pRep.offsetToData = offsetFrom;
        
        //
        // It seems to work even if the last write is not a sector multiple so we will leave it that way
        // for now.
        //
        xferSize = m_bytesInBuffer;
        
        //if (m_bytesInBuffer % m_secSize == 0) {
        //    xferSize = m_bytesInBuffer;
        //} else {
        //    //
        //    // Round to the next sector size.
        //    //
        //    xferSize = ((m_bytesInBuffer / m_secSize) + 1) * m_secSize;
        //}
        
        
        pMsgBuff->inout.command = RP_PARTIAL_DATA;
        pMsgBuff->inout.status = 0;
        pMsgBuff->msg.pRep.bytesRead = xferSize;
        pMsgBuff->msg.pRep.byteOffset = m_StreamOffset.QuadPart;
        pMsgBuff->msg.pRep.filterId = m_filterId;
        
        code = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, pMsgBuff, ioSize,
                NULL, 0, &retSize, NULL);
        lastError = GetLastError();
        WsbTrace(OLESTR("CFilterIo::Commit: Final write of %u bytes at offset %I64u for id %I64x Ioctl returned %u  (%x)\n"), 
                xferSize, m_StreamOffset.QuadPart, m_filterId, code, lastError);
        if (!code) {
            //
            // Some kind of error
            //
            WsbLogEvent(MVR_MESSAGE_FILTER_DATA_SEND_ERROR, 0, NULL, WsbHrAsString(HRESULT_FROM_WIN32(lastError)), NULL);
            WsbAffirm(FALSE, HRESULT_FROM_WIN32(lastError));
        } 
        
        //
        // Reset the output buffer
        //
        m_bytesInBuffer = 0;
        m_StreamOffset.QuadPart += xferSize;
        
        
        WsbTrace(OLESTR("CFilterIo::Commit: Final write for id = %I64x\n"), m_filterId);
    
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Revert"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//


HRESULT
CFilterIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    PRP_MSG     pMsgBuff = (PRP_MSG) NULL;
    DWORD       ioSize, xferSize, retSize, lastError;
    BOOL        code;
    BYTE        *pInputBuffer;
    DWORD       offsetFrom;
    BOOL        writing = TRUE;
    DWORD       bytesLeft;
    

    WsbTraceIn(OLESTR("CFilterIo::WriteBuffer"), OLESTR(""));


    try {
        if (m_ioctlBuffer == NULL) {
            //
            // We need to allocate an aligned buffer to send the data so that writes can be non-cached
            //
            
            WsbAffirmPointer((m_ioctlBuffer = VirtualAlloc(NULL, sizeof(RP_MSG) + WRITE_SIZE + m_secSize, MEM_COMMIT, PAGE_READWRITE)));
        }

        ioSize = sizeof(RP_MSG) + WRITE_SIZE + m_secSize;
        pInputBuffer = pBuffer;
        offsetFrom = ((sizeof(RP_MSG) / m_secSize) + 1) * m_secSize;
        
        m_pDataBuffer = (PCHAR) m_ioctlBuffer + offsetFrom;
        pMsgBuff = (PRP_MSG) m_ioctlBuffer;
        pMsgBuff->msg.pRep.offsetToData = offsetFrom;
        
        *pBytesWritten = 0;
        bytesLeft = nBytesToWrite;
        while (writing) {
            //
            // Stay in the loop until we have removed all the data from the input buffer
            //
            xferSize = min(bytesLeft, WRITE_SIZE - m_bytesInBuffer);
            //
            // Fill the output buffer with up to WRITE_SIZE of data.
            //
            memcpy(m_pDataBuffer + m_bytesInBuffer, pInputBuffer, xferSize);
            bytesLeft -= xferSize;
            *pBytesWritten += xferSize;
            m_bytesInBuffer += xferSize;
            pInputBuffer += xferSize;
            //
            // If we have a full buffer then write it out.
            //
            if (m_bytesInBuffer == WRITE_SIZE) {
                pMsgBuff->inout.command = RP_PARTIAL_DATA;
                pMsgBuff->inout.status = 0;
                pMsgBuff->msg.pRep.bytesRead = WRITE_SIZE;
                pMsgBuff->msg.pRep.byteOffset = m_StreamOffset.QuadPart;
                pMsgBuff->msg.pRep.filterId = m_filterId;
            
                code = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, pMsgBuff, ioSize,
                        NULL, 0, &retSize, NULL);
                lastError = GetLastError();
                WsbTrace(OLESTR("CFilterIo::WriteBuffer: Partial write of %u bytes at offset %u Ioctl returned %u  (%x)\n"), 
                        WRITE_SIZE, m_StreamOffset.QuadPart, code, lastError);
                if (!code) {
                    //
                    // Some kind of error
                    //
                    WsbLogEvent(MVR_MESSAGE_FILTER_DATA_SEND_ERROR, 0, NULL, WsbHrAsString(HRESULT_FROM_WIN32(lastError)), NULL);
                    WsbAffirm(FALSE, HRESULT_FROM_WIN32(lastError));
                } 
                //
                // Reset the output buffer
                //
                m_bytesInBuffer = 0;
                m_StreamOffset.QuadPart += WRITE_SIZE;
            }    
            
            if (*pBytesWritten == nBytesToWrite) {
                writing = FALSE;
            }
        }
        //
        // Tell them we have written all they asked.
        // It may not have actually been written out yet but we will get it later.
        //
        *pBytesWritten = nBytesToWrite;
        
        WsbTrace(OLESTR("CFilterIo::WriteBuffer: Partial write for id = %I64x bytes taken = %u\n"), 
            m_filterId, nBytesToWrite);
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::WriteBuffer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CFilterIo::ReadBuffer (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(nBytesToRead);
    UNREFERENCED_PARAMETER(pBytesRead);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\filterio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FilterIo.h

Abstract:

    Definition of the CFilterIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(FilterIo_H)
#define FilterIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CFilterIo

class CFilterIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CFilterIo,&CLSID_CFilterIo>
{
public:
    CFilterIo() {}
BEGIN_COM_MAP(CFilterIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CFilterIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CFilterIo)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(
        IN REFIID riid);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR volName);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        IN void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

//
// Writes must be aligned and multiples of the sector size
//

#define WRITE_SIZE  (128 * 1024)


private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = RMS_DEFAULT_BLOCK_SIZE,  // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hFile;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*
    ULARGE_INTEGER          m_StreamOffset;         // The Current offset into the data stream
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream
    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    BOOL                    m_isLocalStream;        // Either local and remote stream is created
    ULONG                   m_OriginalAttributes;   // The original attributes of the local file.

    DWORD                   m_BlockSize;            // The read/write blocking factor.

    static int              s_InstanceCount;        // Counter of the number of object instances.
    
    ULONGLONG               m_filterId;             // ID Filter uses for this file
    HANDLE                  m_ioctlHandle;          // Handle to talk to the filter with
    PVOID                   m_ioctlBuffer;          // Aligned buffer 
    DWORD                   m_secSize;              // Sector size to align on
    PCHAR                   m_pDataBuffer;          // Pointer to the buffer to put the write data
    DWORD                   m_bytesInBuffer;        // Number of unwritten bytes in the buffer

    // File I/O
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);

};

#endif // !defined(FilterIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtfapi.h ===
//____________________________________________________________________________
//
//
// FILE NAME :          mtfapi.h
//
// DESCRIPTION :        An object that provides api for creating mtf format structures
//                      (see detail description below)
//
// CREATED:             7/7/00 , based on an old C api sources (mtf_api.h , mtf_api.cpp)
//

/*****************************************************************************
DETAIL DESCRIPTION

NOTE:  See the file MTF_TST.C for an example showing how to use this API

OVERVIEW
========
The MTF API provides a set of structures, each of which corresponds (but is not
identical to) to the structures described in the Microsoft Tape Format reference 
manual.  The client instanciates these structures, fills in the fields and then 
uses an MTF API function to format the information in the structure into a supplied
buffer in MTF format.  The buffer is then padded up to the next alignment factor
using an MTF API call and then  may then be written to tape using WIN32 Write. 

For example, to write an MTF TAPE DBLK,

1) Instanciate the MTF API structures.  The common header structure is used 
separately so that it can be re-used among DBLK writes
    
    MTF_DBLK_HDR_INFO sHdr;
    MTF_DBLK_TAPE_INFO sTape;

2) Use MTF API set default functions to set default values of these

    MTF_SetDblkHdrDefaults(&sHdr);
    MTF_SetTAPEDefaults(&sTape);

3) Override the default values as necessary

    sHdr.uFormatLogicalAddress = ...
    ...
    sTape.szTapeName = L"MY TAPE!"
    ...

4) Use the MTF API calls to format the contents of these structures into a buffer.
   If the API needs more room than BUFSIZE then then ammount needed is stored in 
   nBufUsed.  Otherwise nBufUsed reflects the amount of space in the buffer 
   used by the call.

    MTF_WriteTAPEDblk(&sHdr,
                      &sTape,
                      pBuffer,
                      BUFSIZE,
                      &nBufUsed);

5) NOTE WELL:  The write calls *DO NOT PAD* to the next alignment index.  But this 
   is easily done using the MTF API call:

    MTF_PadToNextAlignmentFactor(pBuffer,     
                                 nBufUsed,
                                 BUFSIZE, 
                                 &nBufUsed);

6) At this point, nBufUsed % MTF_GetAlignmentFactor should == 0.  If our blocksize
   evenly divides our alignment factor, then we can use the WIN32 Write call to

    WriteFile(hTape, pBuffer, nBufUsed, &nBytesWritten, 0);

   Since our blocksize divides our AF, then nBytesWritten should == nBufUsed

*** SEE THE MTF_TST.C FOR A COMPLETE EXAMPLE SHOWING THE USE OF THIS API TO CREATE
    A BACKUP SET


MTF API DATA STRUCTURE AND FUNCTION SUMMARY
===========================================
===========================================
**summary only -- generic detail comments appear below**


LOW LEVEL TYPES
===============
The following are typedefed to the corresponding "unsigned __intxx"

types:
    UINT8
    UINT16
    UINT32
    UINT64

functions:
MTF_CreateUINT64()  -- creates a 64 bit unsigned from two UINT32 values (lsb & msb)


DATE & TIME
===========
MTF_DATE_TIME                    -- structure used by MTF API for holding packed date & time info 
MTF_CreateDateTimeNull()         -- returns a null MTF_DATE_TIME
MTF_CreateDateTime()             -- creates MTF_DATE_TIME from year, month, day, hour, min, sec
MTF_CreateDateTimeFromTM()       -- creates MTF_DATE_TIME from struct tm in <time.h>
MTF_CreateDateTimeFromFileTime() -- creates MTF_DATE_TIME from FILETIME used by FindFirst/FindNext
MTF_CreateDateTimeToTM()         -- fills in a struct tm structure given an MTF_DATE_TIME struct


ALIGNMENT FACTOR
================
MTF_SetAlignmentFactor           -- sets the alignment factor for the MTF API (you must do this)
MTF_GetAlignmentFactor           -- returns the set alignment factor
MTF_PadToNextAlignmentFactor     -- Pads out a buffer using an SPAD to the next alignment factor
MTF_PadToNextPhysicalBlockBoundary -- Pads out a buffer using an SPAD to the next physical block boundary


MTF COMMON HEADER BLOCK
=======================
MTF_DBLK_HDR_INFO                -- common block header (must be supplied to all calls to write dblks
MTF_SetDblkHdrDefaults           -- sets default values (always call this before you set your own)


MTF TAPE DBLK INFO
==================
MTF_DBLK_TAPE_INFO     -- info corresponding to a TAPE dblk   
MTF_SetTAPEDefaults    -- sets defaults (always do this before setting your own)
MTF_WriteTAPEDblk      -- formats info in MTF_DBLK_TAPE_INFO to tape
MTF_ReadTAPEDblk       -- reads info back from a buffer holding MTF FORMATTED TAPE DBLK


MTF SSET DBLK INFO
==================
MTF_DBLK_SSET_INFO     -- all similar to above but for SSET DBLK
MTF_SetSSETDefaults    -- 
MTF_WriteSSETDblk      -- 
MTF_ReadSSETDblk       -- 


MTF VOLB DBLK INFO
==================
MTF_DBLK_VOLB_INFO     -- all similar to above but for VOLB DBLK
MTF_SetVOLBDefaults    -- 
MTF_WriteVOLBDblk      -- 
MTF_ReadVOLBDblk       -- 
MTF_SetVOLBForDevice   -- sets default values given a device name ("C:") using 
                          GetVolumeInformation (WIN32 call)


MTF DIRB DBLK INFO
==================
MTF_DBLK_DIRB_INFO        -- all similar to above but for DIRB DBLK
MTF_SetDIRBDefaults       -- 
MTF_WriteDIRBDblk         -- (dblk only -- no stream)
MTF_ReadDIRBDblk          -- 
MTF_SetDIRBFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF FILE DBLK INFO
==================
MTF_DBLK_FILE_INFO        -- all similar to above but for FILE DBLK
MTF_SetFILEDefaults       -- 
MTF_WriteFILEDblk         -- (dblk only -- no stream)
MTF_ReadFILEDblk          -- 
MTF_SetFILEFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF CFIL DBLK INFO
==================
MTF_DBLK_CFIL_INFO        -- all similar to above but for CFIL DBLK
MTF_SetCFILDefaults       -- 
MTF_WriteCFILDblk         -- 
MTF_ReadCFILDblk          -- 


MTF ESET DBLK INFO
==================
MTF_DBLK_ESET_INFO        -- all similar to above but for ESET DBLK
MTF_SetESETDefaults       -- 
MTF_WriteESETDblk         -- 
MTF_ReadESETDblk          -- 


MTF EOTM DBLK INFO
==================
MTF_DBLK_EOTM_INFO        -- all similar to above but for EOTM DBLK
MTF_SetEOTMDefaults       -- 
MTF_WriteEOTMDblk         -- 
MTF_ReadEOTMDblk          -- 


MTF STREAM INFO
==================
MTF_STREAM_INFO           -- all similar to above but for EOTM DBLK
MTF_SetSTREAMDefaults     -- 
MTF_WriteSTREAMHeader     -- 
MTF_ReadSTREAMHeader      -- 
MTF_SetSTREAMDefaultsFromStreamId
                          -- sets stream defaults from a WIN32_STREAM_ID struct
                             (returned from the WIN32 BackupRead function)

***********************************************************************************/

#ifndef _MTFAPI_H_
#define _MTFAPI_H_

#include <windows.h>
#include <stdlib.h>
#include <wchar.h>
#include <time.h>


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Constants, defines and bit masks
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     MTF ERROR CODES
================================================================================== */

#define MTF_ERROR_NONE              0
#define MTF_ERROR_BUFFER_TOO_SMALL  1000
#define MTF_NO_STREAMS              1001
#define MTF_OUT_OF_MEMORY           1002

/* ==================================================================================
     MTF Misc. Defaults and Constants
================================================================================== */
#define MTF_DEFAULT_ALIGNMENT_FACTOR 1024;

#define MTF_FORMAT_VER_MAJOR      1
#define MTF_FORMAT_VER_MINOR      0 // BMD: This API is verison 5; use 0 for compatibility with NT Backup

#define MTF_PW_ENCRYPT_NONE       0
#define MTF_DATA_ENCRYPT_NONE     0
#define MTF_ECC_NONE              0

#define MTF_COMPRESS_NONE         0

#define MTF_OTC_NONE              0
#define MTF_OTC_TYPE              1
#define MTF_OTC_VERSION           2

#define MTF_LOCAL_TZ              127

#define MTF_STRING_NONE           0
#define MTF_STRING_ANSI_STR       1
#define MTF_STRING_UNICODE_STR    2

#define MTF_OSID_NT               14
#define MTF_OSID_DOS              24

/* ==================================================================================
     MTF Block Types
================================================================================== */

#define  MTF_ID_TAPE     "TAPE"    /* Tape Header ID */
#define  MTF_ID_VOLB     "VOLB"    /* Volume Control Block ID */
#define  MTF_ID_SSET     "SSET"    /* Start of Backup Set Description Block ID */
#define  MTF_ID_ESET     "ESET"    /* End of Backup Set Description Block ID */
#define  MTF_ID_EOTM     "EOTM"    /* End of tape, continuation Block ID */
#define  MTF_ID_DIRB     "DIRB"    /* Directory Descriptor Block ID */
#define  MTF_ID_FILE     "FILE"    /* File Descriptor Block ID */
#define  MTF_ID_CFIL     "CFIL"    /* Corrupt File Descriptor Block ID */
#define  MTF_ID_ESPB     "ESPB"    /* End of Set Pad Block */
#define  MTF_ID_SFMB     "SFMB"    /* Soft Filemark Descriptor Block ID */


/* ==================================================================================
     DBLK Block Attributes

     The lower 16 bits are reserved for general attribute bits (those
     which may appear in more than one type of DBLK), the upper 16 are
     for attributes which are specific to one type of DBLK.

     Note that the block specific bit definitions overlap, and the block
     type is used to determine the meaning of a given bit.
================================================================================== */

/* any : */
#define MTF_CONTINUATION        0x00000001UL
#define MTF_COMPRESSION         0x00000004UL
#define MTF_EOS_AT_EOM          0x00000008UL
#define MTF_VAR_BLKS            0x00000010UL
#define MTF_SESSION             0x00000020UL

/* TAPE : */
#define MTF_SM_EXISTS           0x00010000UL
#define MTF_FDD_ALLOWED         0x00020000UL
#define MTF_SM_ALT_OVERWRITE    0x00040000UL
#define MTF_FDD_ALT_PART        0x00080000UL
#define MTF_SM_ALT_APPEND       0x00200000UL

/* SSET : */
#define MTF_FDD_EXISTS          0x00010000UL
#define MTF_ENCRYPTION          0x00020000UL

/* ESET : */
#define MTF_FDD_ABORTED         0x00010000UL
#define MTF_END_OF_FAMILY       0x00020000UL
#define MTF_ABORTED_SET         0x00040000UL
#define MTF_SET_VERIFIED        0x00080000UL

/* EOTM : */
#define MTF_NO_ESET_PBA         0x00010000UL
#define MTF_INVALID_ESET_PBA    0x00020000UL

/* ==================================================================================
     TAPE Block Attributes
================================================================================== */

#define MTF_TAPE_SOFT_FILEMARK  0x00000001UL
#define MTF_TAPE_MEDIA_LABEL    0x00000002UL

/* ==================================================================================
     SSET Block Attributes
================================================================================== */

#define MTF_SSET_TRANSFER       0x00000001UL
#define MTF_SSET_COPY           0x00000002UL
#define MTF_SSET_NORMAL         0x00000004UL
#define MTF_SSET_DIFFERENTIAL   0x00000008UL
#define MTF_SSET_INCREMENTAL    0x00000010UL
#define MTF_SSET_DAILY          0x00000020UL

/* ==================================================================================
     VOLB Block Attributes
================================================================================== */

#define MTF_VOLB_NO_REDIRECT    0x00000001UL
#define MTF_VOLB_NON_VOLUME     0x00000002UL
#define MTF_VOLB_DEV_DRIVE      0x00000004UL
#define MTF_VOLB_DEV_UNC        0x00000008UL
#define MTF_VOLB_DEV_OS_SPEC    0x00000010UL
#define MTF_VOLB_DEV_VEND_SPEC  0x00000020UL

/* ==================================================================================
     DIRB Block Attributes
================================================================================== */

#define MTF_DIRB_READ_ONLY      0x00000100UL
#define MTF_DIRB_HIDDEN         0x00000200UL
#define MTF_DIRB_SYSTEM         0x00000400UL
#define MTF_DIRB_MODIFIED       0x00000800UL
#define MTF_DIRB_EMPTY          0x00010000UL
#define MTF_DIRB_PATH_IN_STREAM 0x00020000UL
#define MTF_DIRB_CORRUPT        0x00040000UL

/* ==================================================================================
     FILE Block Attributes
================================================================================== */

#define MTF_FILE_READ_ONLY      0x00000100UL
#define MTF_FILE_HIDDEN         0x00000200UL
#define MTF_FILE_SYSTEM         0x00000400UL
#define MTF_FILE_MODIFIED       0x00000800UL
#define MTF_FILE_IN_USE         0x00010000UL
#define MTF_FILE_NAME_IN_STREAM 0x00020000UL
#define MTF_FILE_CORRUPT        0x00040000UL

/* ==================================================================================
     CFIL Block Attributes
================================================================================== */

#define MTF_CFIL_LENGTH_CHANGE  0x00010000UL
#define MTF_CFIL_UNREADABLE_BLK 0x00020000UL
#define MTF_CFIL_DEADLOCK       0x00040000UL

/* ==================================================================================
     ESET Block Attributes
================================================================================== */

#define MTF_ESET_TRANSFER       0x00000001UL
#define MTF_ESET_COPY           0x00000002UL
#define MTF_ESET_NORMAL         0x00000004UL
#define MTF_ESET_DIFFERENTIAL   0x00000008UL
#define MTF_ESET_INCREMENTAL    0x00000010UL
#define MTF_ESET_DAILY          0x00000020UL

/* ==================================================================================
     STREAM File System Attributes
================================================================================== */

#define MTF_STREAM_MODIFIED_BY_READ     0x00000001UL
#define MTF_STREAM_CONTAINS_SECURITY    0x00000002UL
#define MTF_STREAM_IS_NON_PORTABLE      0x00000004UL
#define MTF_STREAM_IS_SPARSE            0x00000008UL

/* ==================================================================================
     STREAM Media Format Attributes
================================================================================== */

#define MTF_STREAM_CONTINUE         0x00000001UL
#define MTF_STREAM_VARIABLE         0x00000002UL
#define MTF_STREAM_VAR_END          0x00000004UL
#define MTF_STREAM_ENCRYPTED        0x00000008UL
#define MTF_STREAM_COMPRESSED       0x00000010UL
#define MTF_STREAM_CHECKSUMED       0x00000020UL
#define MTF_STREAM_EMBEDDED_LENGTH  0x00000040UL

/* ==================================================================================
     STREAM Types (Platform Independent)
================================================================================== */

#define MTF_STANDARD_DATA_STREAM    "STAN"
#define MTF_PATH_NAME_STREAM        "PNAM"
#define MTF_FILE_NAME_STREAM        "FNAM"
#define MTF_CHECKSUM_STREAM         "CSUM"
#define MTF_CORRUPT_STREAM          "CRPT"
#define MTF_PAD_STREAM              "SPAD"
#define MTF_SPARSE_STREAM           "SPAR"
#define MTF_MBC_LMO_SET_MAP_STREAM  "TSMP"
#define MTF_MBC_LMO_FDD_STREAM      "TFDD"
#define MTF_MBC_SLO_SET_MAP_STREAM  "MAP2"
#define MTF_MBC_SLO_FDD_STREAM      "FDD2"

/* ==================================================================================
     STREAM Types (Windows NT specific)
================================================================================== */

#define MTF_NTFS_ALT_STREAM         "ADAT"
#define MTF_NTFS_EA_STREAM          "NTEA"
#define MTF_NT_SECURITY_STREAM      "NACL"
#define MTF_NT_ENCRYPTED_STREAM     "NTED"
#define MTF_NT_QUOTA_STREAM         "NTQU"
#define MTF_NT_PROPERTY_STREAM      "NTPR"
#define MTF_NT_REPARSE_STREAM       "NTRP"
#define MTF_NT_OBJECT_ID_STREAM     "NTOI"

/* ==================================================================================
     STREAM Frame Headers
================================================================================== */

#define MTF_COMPRESSION_HEADER_ID   "FM"
#define MTF_ECRYPTION_HEADER_ID     "EH"

/* ==================================================================================
 * Turn on packing here.  Need to be sure that date is packed. 
================================================================================== */
#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Miscelaneous Data Types (and some handy methods for them)
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     General Data Types
================================================================================== */
#ifndef _BASET32_H_
#ifndef _BASETSD_H_
// This one is now in a NT header file but not as __int32
typedef unsigned __int8  UINT8;
typedef unsigned __int16 UINT16;
typedef unsigned __int32 UINT32;
#endif
#endif
typedef unsigned __int64 UINT64;


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
================================================================================== */
typedef struct {
     UINT8     dt_field[5] ;
} MTF_DATE_TIME;


/************************************************************************************
* MTF_CreateDataTime#####()
*
* Description:  Given various arguments, this set of functions returns a packed 
*               MTF_DATE_TIME struct which can then be assigned to fields found 
*               in the various info structs found below
* Example:
*               sSetInfo.sBackupDate = MTF_CreateDateTime(1995, 6, 12, 16, 30, 0);
************************************************************************************/


/***********************************************************************************
************************************************************************************
****  MTF Alignment Factor - GENERIC DETAIL COMMENTS FOR METHODS FOUND BELOW
************************************************************************************
***********************************************************************************/

/************************************************************************************
* MTF_SetAlignmentFactor()
*
* Description:  Sets the alignment factor to be used by the MTF API
*               (particularly by MTF_PadToNextAlignmentFactor and MTF_WriteTAPEDblk)
*
* Pre:
* Post: MTF API Alignment Factor == uAF
*
* uAF -- alignment factor value to set
************************************************************************************/

/************************************************************************************
* MTF_GetAlignmentFactor()
*
* Description:  Returns the Alignment Factor set by MTF_SetAlignmentFactor
*
* Pre: MTF_SetAlignmentFactor has been called
************************************************************************************/

/************************************************************************************
* MTF_PadToNextAlignmentFactor()
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next alignment factor
*               
*
* Pre:  The alignment factor has been set by calling MTF_SetAlignmentFactor,
*       pBuffer points to a buffer whose size is reflected by nBufferSize
*
* Post: return value == MTF_ERROR_NONE
*           => padding was successful, *pnSizeUsed reflects amount of buffer used,
*              AND *pnSizeUsed % MTF_GetAlignmentFactor == 0  is  TRUE
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* NOTE: If the space between the end of the buffer and the next alignment factor is 
*       smaller than the size of a stream header, then the spad hogs up the whole 
*       next alignment factor.
*
* pBuffer     -- the buffer to spad out
* nBufUsed    -- the amount of the buffer used so far (position where to append)
* nBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- points to where to store size used or needed
************************************************************************************/

/************************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next physical block boundary.
*
************************************************************************************/


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURES
************************************************************************************
************************************************************************************
***********************************************************************************/

/***********************************************************************************
GENERIC DETAIL COMMENTS FOR METHODS FOUND BELOW
=================================================

************************************************************************************
* MTF_Set####Defaults()
*
* Description:  Sets up default values for the structure.  Always call this to
*               avoid garbage values in case you over look a field, 
* Pre:  
* Post: All fields of the referenced structure are filled in with *something*. 
*       Date fields are initialized to current date and time.
*       Strings pointers are set to 0
*       Most other values set to 0
*
* p####Info     -- pointer to structure to be set
************************************************************************************
void MTF_Set####Defaults(
    MTF_####_INFO *p####Info);    


************************************************************************************
* MTF_Write####Dblk()
*
* Description:  Formats the information supplied in psHdrInfo and ps####Info into
*               MTF Format and places the results in pBuffer
*
* Pre:  psHdrInfo and ps####Info contain valid information / default values
*       pBuffer points to a buffer where resulting format is to be stored
*       nBuffer size indicates the size of the buffer
*
*       MTF_WriteTAPEDblk -- MTF_SetAlingmentFactor has been called
*
* Post: return value == MTF_ERROR_NONE
*           => Format was successful, *pnSizeUsed reflects amount of buffer used
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* psHdrInfo   -- MTF Common header information 
* ps####Info  -- MTF DBLK info
* pBuffer     -- pointer to buffer which will receive MTF formatted info
* pBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- pointer to a size_t in which amount of buffer used or needed is stored
************************************************************************************
DWORD MTF_Write####Dblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 



************************************************************************************
* MTF_Read####Dblk()
*
* Description:  Translates MTF Formatted information from a buffer to MTF API info
*               structures -- the opposite of MTF_Write####Dblk
*               
*
* Pre:  pBuffer contains correct MTF Buffer information 
*
* Post: psHdrInfo and ps####Info contain the de-formatted info.  
*
* NOTE: Strings point to strings stored statically by the API, and will be over 
*       written on the next read call. 
*
* psHdrInfo   -- MTF Common header info struct to receive info
* ps####Info  -- MTF DBLK info struct to receive info
* pBuffer     -- pointer to buffer which holds MTF formatted data
************************************************************************************
DWORD MTF_Read####Dblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer);    



************************************************************************************
* MTF_Set####From?????????()
*
* Description: Similar to MTF_Set####Defaults(), but takes as an argument one or more
*              commonly used structures and sets values from that.  For example, 
*              MTF_SetFILEFromFindData takes as an argument a WIN32_FIND_DATA struct
*              from which it extracts the file name, date, time, etc. 
*               
*
* Pre:  
* Post: As many fields as are reasonable are automatically set.  The rest of the 
*       fields are set to default values.
*
* NOTE: Strings such as file names, directory names are stored statically by the 
*       MTF API and are only good until the next call to an MTF_Set#####From??????
*       function.
*
* NOTE: FILE and DIRB calls automatically set the file and directory attibutes from 
*       the info in the WIN32_FIND_DATA structure.
*
* NOTE: MTF_SetSTREAMFromStreamId will automatically set the stream header id based
*       on the attributes found in the WIN32 stream header
*
************************************************************************************
void MTF_Set####From?????????(MTF_DBLK_####_INFO *p####Info, 
                              SomeType????        Id??? 
                              ....);
***********************************************************************************/



/* ==================================================================================
     Common DBLK: MTF_STD_DBLK_INFO
================================================================================== */
typedef struct { 

    char    acBlockType[5];         /* for reading only -- ignored when writing (includes \0)*/
    UINT32  uBlockAttributes;
    UINT16  uOffsetToFirstStream;   /* for reading only */
    UINT8   uOSID;                  /* Machine/OS id where written, low byte */
    UINT8   uOSVersion;             /* Machine/OS id where written, high byte */
    UINT64  uDisplayableSize;       /* Displayable data size */
    UINT64  uFormatLogicalAddress;
    UINT16  uReservedForMBC;        /* Reserved for Media Based Catalog */
    UINT16  uSoftwareCompression;   /* Software Compression Algorithm */
    UINT32  uControlBlockId;        /* Used for error recovery */
    void *  pvOSData;               /* OS specific Data */
    UINT16  uOSDataSize;            /* the size of the OS data in bytes */
    UINT8   uStringType;            /* String type */   
    UINT16  uHeaderCheckSum;        /* for reading only */

} MTF_DBLK_HDR_INFO;

/* ==================================================================================
     TAPE DBLK: MTF_TAPE_INFO
================================================================================== */
typedef struct { 

    UINT32  uTapeFamilyId;
    UINT32  uTapeAttributes;
    UINT16  uTapeSequenceNumber;
    UINT16  uPasswordEncryptionAlgorithm;
    UINT16  uSoftFilemarkBlockSize;
    UINT16  uTapeCatalogType;
    wchar_t *   szTapeName;
    wchar_t * szTapeDescription;
    wchar_t * szTapePassword;
    wchar_t * szSoftwareName;
    UINT16  uAlignmentFactor;
    UINT16  uSoftwareVendorId;
    MTF_DATE_TIME   sTapeDate;
    UINT8   uMTFMajorVersion;

} MTF_DBLK_TAPE_INFO;

/* ==================================================================================
     Start of Set DBLK (SSET)
================================================================================== */
typedef struct {
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     wchar_t *           szDataSetName;
     wchar_t *           szDataSetDescription;
     wchar_t *           szDataSetPassword;
     wchar_t *           szUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone ;
     UINT8               uMTFMinorVer ;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET_INFO;

/* ==================================================================================
     Volume DBLK (VOLB)
================================================================================== */
typedef struct {
     UINT32              uVolumeAttributes;
     wchar_t *           szDeviceName;
     wchar_t *           szVolumeName;
     wchar_t *           szMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB_INFO;

typedef struct {
     UINT32              uFileSystemFlags;
     UINT32              uBackupSetAttributes;
} MTF_VOLB_OS_NT_1;

/* ==================================================================================
     Directory DBLK (DIRB)
================================================================================== */
typedef struct {
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     wchar_t *           szDirectoryName;
} MTF_DBLK_DIRB_INFO;

typedef struct {
     UINT32              uDirectoryAttributes;
} MTF_DIRB_OS_NT_0;

typedef struct {
     UINT32              uDirectoryAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
} MTF_DIRB_OS_NT_1;

/* ==================================================================================
     File DBLK (FILE)
================================================================================== */
typedef struct {
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     wchar_t *           szFileName;
     UINT64              uDisplaySize;
} MTF_DBLK_FILE_INFO;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT16              lLink;
     UINT16              uReserved;
} MTF_FILE_OS_NT_0;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT32              uFileFlags;
} MTF_FILE_OS_NT_1;

/* ==================================================================================
     Corrupt File DBLK (CFIL)
================================================================================== */
typedef struct {
     UINT32              uCFileAttributes;
     UINT32              uDirectoryId;      /* Or CFIL Attributes                             ***/
     UINT32              uFileId;           /* Or reserved                                    ***/
     UINT64              uStreamOffset;
     UINT16              uCorruptStreamNumber;
} MTF_DBLK_CFIL_INFO;

/* ==================================================================================
     End of Set DBLK (ESET)
================================================================================== */
typedef struct {
     UINT32              uESETAttributes;
     UINT32              uNumberOfCorrupFiles;
     UINT64              uSetMapPBA;
     UINT64              uFileDetailPBA;
     UINT16              uFDDTapeSequenceNumber;
     UINT16              uDataSetNumber;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_ESET_INFO;

/* ==================================================================================
     End of Tape Media DBLK (EOTM)
================================================================================== */
typedef struct {
     UINT64              uLastESETPBA;
} MTF_DBLK_EOTM_INFO;

/* ==================================================================================
     Soft Filemark DBLK (SFMB) - (bmd)
================================================================================== */
typedef struct {
     UINT32              uNumberOfFilemarkEntries;
     UINT32              uFilemarkEntriesUsed;
     UINT32              uFilemarkArray[1];
} MTF_DBLK_SFMB_INFO;

/* ==================================================================================
     STREAM 
================================================================================== */
typedef struct {
     UINT8               acStreamId[4];
     UINT16              uStreamFileSystemAttributes;
     UINT16              uStreamTapeFormatAttributes;
     UINT64              uStreamLength;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uDataCompressionAlgorithm;
     UINT16              uCheckSum;

} MTF_STREAM_INFO;


/* ==================================================================================
     Tape Address
================================================================================== */
typedef struct {
     UINT16 uSize;        /* Size of the data */
     UINT16 uOffset;      /* Offset to the data */
} MTF_TAPE_ADDRESS;


#pragma pack()

//
// The CMTFApi class
//
class CMTFApi
{
public:
    // Construction
    CMTFApi();
    ~CMTFApi();

    // General type utilties
    static UINT64 MTF_CreateUINT64(UINT32 uLSB, 
                                   UINT32 uMSB);

    // MTF Date-Time utilities
    MTF_DATE_TIME MTF_CreateDateTimeNull();

    MTF_DATE_TIME MTF_CreateDateTime(int iYear, 
                                     int iMonth, 
                                     int iDay, 
                                     int iHour, 
                                     int iMinute,
                                     int iSecond);

    MTF_DATE_TIME MTF_CreateDateTimeFromTM(struct tm *pT);

    MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(FILETIME sFileTime);

    void MTF_CreateDateTimeToTM(MTF_DATE_TIME *pDT, 
                                struct tm     *pT);

    // MTF Alignment Factor 
    void MTF_SetAlignmentFactor(UINT16 uAF);

    UINT16 MTF_GetAlignmentFactor();

    DWORD MTF_PadToNextAlignmentFactor(BYTE     *pBuffer,    
                                       size_t    nBufUsed,
                                       size_t    nBufferSize, 
                                       size_t   *pnSizeUsed);

    DWORD MTF_PadToNextPhysicalBlockBoundary(BYTE *pBuffer,
                                             size_t nBlockSize,
                                             size_t nBufUsed,
                                             size_t nBufferSize,
                                             size_t *pnSizeUsed);
 
    // Common DBLK
    void MTF_SetDblkHdrDefaults(MTF_DBLK_HDR_INFO *pStdInfo);

    // TAPE DBLK
    void MTF_SetTAPEDefaults(MTF_DBLK_TAPE_INFO *pTapeInfo);
    
    DWORD MTF_WriteTAPEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_TAPE_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadTAPEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_TAPE_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Start of Set DBLK (SSET)
    void MTF_SetSSETDefaults(MTF_DBLK_SSET_INFO *pSSETInfo);

    DWORD MTF_WriteSSETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_SSET_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadSSETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_SSET_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Volume DBLK (VOLB)
    void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo);

    void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice);

    DWORD MTF_WriteVOLBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_VOLB_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadVOLBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_VOLB_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Directory DBLK (DIRB)
    void MTF_SetDIRBDefaults(MTF_DBLK_DIRB_INFO *pDIRBInfo);

    void MTF_SetDIRBFromFindData(MTF_DBLK_DIRB_INFO *pDIRBInfo, 
                                 wchar_t            *szFullFileName, 
                                 WIN32_FIND_DATAW   *pFindData);

    DWORD MTF_WriteDIRBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_DIRB_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadDIRBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_DIRB_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // File DBLK (FILE)
    void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo);

    void MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, 
                                 WIN32_FIND_DATAW *pFindData);

    DWORD MTF_WriteFILEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_FILE_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadFILEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_FILE_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Corrupt File DBLK (CFIL)
    void MTF_SetCFILDefaults(MTF_DBLK_CFIL_INFO *pCFILInfo);

    DWORD MTF_WriteCFILDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_CFIL_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadCFILDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_CFIL_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // End of Set Pad DBLK (ESPB)
    DWORD MTF_WriteESPBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadESPBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           BYTE               *pBuffer);    

    // End of Set DBLK (ESET)
    void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo);

    DWORD MTF_WriteESETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_ESET_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadESETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_ESET_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // End of Tape Media DBLK (EOTM)
    void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo);

    DWORD MTF_WriteEOTMDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_EOTM_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadEOTMDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_EOTM_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Soft Filemark DBLK (SFMB) - (bmd)
    size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize);

    void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                                UINT32 pba);

    DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                            MTF_DBLK_SFMB_INFO *psSoftInfo,
                            BYTE *pBuffer,
                            size_t nBufferSize,
                            size_t *pnSizeUsed);

    DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                           MTF_DBLK_SFMB_INFO *psSoftInfo,
                           BYTE *pBuffer);

    // STREAM 
    static void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, 
                                      char            *szId);

    static void MTF_SetSTREAMFromStreamId(MTF_STREAM_INFO *pSTREAMInfo, 
                                          WIN32_STREAM_ID *pStreamId, 
                                          size_t           nIDHeaderSize);

    static void MTF_SetStreamIdFromSTREAM(WIN32_STREAM_ID *pStreamId,
                                          MTF_STREAM_INFO *pSTREAMInfo, 
                                          size_t           nIDHeaderSize);

    static DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                                       BYTE               *pBuffer,     
                                       size_t              nBufferSize, 
                                       size_t             *pnSizeUsed); 

    static DWORD MTF_WriteNameStream(char      *szType,
                                     wchar_t   *szName,
                                     BYTE      *pBuffer,
                                     size_t     nBufferSize,
                                     size_t    *pnSizeUsed);

    static DWORD MTF_ReadStreamHeader(MTF_STREAM_INFO    *psStreamInfo,  
                                      BYTE               *pBuffer);    

    // Utilities 
    void MTF_DBLK_HDR_INFO_ReadFromBuffer(MTF_DBLK_HDR_INFO *psHdrInfo, 
                                          BYTE              *pBuffer);
private:
    // Internal methods
    static size_t Align(size_t uSize, size_t uAlignment);
    static UINT16 CalcChecksum(BYTE * pStartPtr, int nNum);
    static UINT32 CalcChecksumOfStreamData(BYTE * pStartPtr, int nNum);

    static size_t wstrsize(wchar_t *s);
    static size_t ua_wstrsize(wchar_t UNALIGNED *s);
    void ClearStrings();
    wchar_t * MakeString(wchar_t UNALIGNED * pString, size_t iSize);

    size_t StringToTapeAddress(MTF_TAPE_ADDRESS *pAd,
                               BYTE             *pBuffer,
                               wchar_t          *str,
                               size_t           uCurrentStorageOffset);

    void MTF_WriteDblkHdrToBuffer(UINT8              acID[4],
                                  UINT16             uOffsetToFirstStream,  
                                  MTF_DBLK_HDR_INFO *psHdrInfo,             
                                  BYTE              *pBuffer,               
                                  size_t            *puCurrentStorage);
                                  
    size_t MTF_DBLK_HDR_INFO_CalcAddDataSize(MTF_DBLK_HDR_INFO *pSTDInfo);
    size_t MTF_DBLK_TAPE_INFO_CalcAddDataSize(MTF_DBLK_TAPE_INFO *pTapeInfo);
    size_t MTF_DBLK_SSET_INFO_CalcAddDataSize(MTF_DBLK_SSET_INFO *pSSETInfo);
    size_t MTF_DBLK_VOLB_INFO_CalcAddDataSize(MTF_DBLK_VOLB_INFO *pVOLBInfo);
    size_t MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo);
    size_t MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo);

    MTF_DATE_TIME MTF_CreateDateNull(void);

#define MTF_STRLEN 256
#define iNUMSTRINGS 5

    // Data members
    UINT16 m_uAlignmentFactor;          // Alignment factor

    // When the api formats it's own strings (i.e. file names from the WIN32_FIND_DATA,
    // we need to keep those strings somewhere so we can set the pointers to them in 
    // the info structs.  
    wchar_t m_szDeviceName[MTF_STRLEN];                     
    wchar_t m_szVolumeName[MTF_STRLEN];
    wchar_t m_szMachineName[MAX_COMPUTERNAME_LENGTH+1];
    wchar_t m_szDirectoryName[MTF_STRLEN];
    wchar_t m_szFileName[MTF_STRLEN];

    // Internal string management
    wchar_t *m_aszStrings[iNUMSTRINGS]; // we keep an array of pointers to allocated strings
                                        // this managed by ClearStrings() and MakeString()
    int      m_iNumStrings;             // the number of strings currently allocated

};


#endif  // of _MTFAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtfsessn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MTFSessn.cpp

Abstract:

    CMTFSession class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "engine.h"
#include "MTFSessn.h"

//
// !!!!! VERY IMPORTANT !!!!!
//
// WIN32_STREAM_ID_SIZE -- Size of WIN32_STREAM_ID (20) != sizeof(WIN32_STREAM_ID) (24)
//                         due to WIN32_STREAM_ID being a variable sized structure --
//                         See below.

#define WIN32_STREAM_ID_SIZE 20

/*****************************************************************************
DETAIL DESCRIPTION 

OVERVIEW
========
This class uses MTF API calls to create a data set.  A data set
is created by writing a series of DBLKs which may optionally be followed by
data streams.

For each DBLK, the MTF API defines a corresponding xxxx_DBLK_INFO struct 
which is filled in by the client.  This can be done field by field or by 
using an MTF API function which automatically fills in the structure with 
default information.

The xxxx_DBLK_INFO structs are then passed to MTF_WriteXXXXDblk functions which 
use the information in the struct to format a buffer, which can then be written
to the data set, using the Stream I/O Write function.

DATA SET FORMAT
===============
A data set is created by writing DBLKs and Streams in the following order:

TAPE DBLK  -- describes the media
FILEMARK
SSET DBLK  -- start of set describing the data set
VOLB DBLK  -- describs the volume being stored

for each directory and parent directory 
    DIRB DBLK  -- one for each directory/sub-directory, starting with the root
    STREAM     -- may contain security info for the directory

for each file to backup
    FILE DBLK  -- one for each file, followed by one or more streams, describing
    STREAM        security info, as well as the file data streams themselves
    STREAM 

FILEMARK
ESET DBLK  -- indicates the end of the data set

FILEMARK   -- terminates the data set



FUNCTIONS OVERVIEW
==================
The MTF session maintains various information about the data set being created.
This member data is then used by the following routines.

    InitCommonHeader()      -- Initializes the common header which is used in
                               all DBLKS is stored

    DoTapeDblk()            -- writes the TAPE DBLK 
    DoSSETDblk()            -- writes the SSET DBLK
    DoVolumeDblk()          -- writes the VOLB DBLK

    DoParentDirectories()   -- writes DIRB DBLKs and Streams for the directory
                               to backed up and each of its parent directories

    DoDirectoryDblk()       -- writes a single DIRB DBLK and associated security
                               stream

    DoDataSet()             -- writes FILE and DIRB DBLKs and associated data
                               streams for everything in the directory.
                               Recurses for sub-directories

    DoFileDblk()            -- writes a FILE DBLK

    DoDataStream()          -- writes data stream(s) associated with a file or
                               directory

    DoEndOfDataSet()        -- writes ESET DBLK and surrounding FILEMARKS


NOTES AND WARNINGS
==================
o  Directory names are stored in DIRB DBLKs as "DIR\SUBDIR1\...\SUBDIRn\" 
   (no vol, and with a trailing \) where as filenames are stored in 
   FILE DBLKS just as "FILENAME.EXT"

o  In DIRB's, the backslashes between directory names are covnerted to L'\0'!!!!!
   (the mtf api takes care of this -- give it names with slashes!!!!)

o  All strings are assumed to be WCHAR by the MTF API

o  We assume here that __uint64 is supported by the compiler.

*****************************************************************************/

static USHORT iCountMTFs = 0;  // Count of existing objects


CMTFSession::CMTFSession(void)
{
    WsbTraceIn(OLESTR("CMTFSession::CMTFSession"), OLESTR(""));

    // public
    m_pStream = NULL;
    memset(&m_sHints, 0, sizeof(MVR_REMOTESTORAGE_HINTS));

    // private
    m_nCurrentBlockId = 0;
    m_nDirectoryId = 0;
    m_nFileId = 0;
    m_nFormatLogicalAddress = 0;
    m_nPhysicalBlockAddress = 0;

    m_nBlockSize = 0;

    m_pSoftFilemarks = NULL;

    memset (&m_sHeaderInfo, 0, sizeof(MTF_DBLK_HDR_INFO));
    memset (&m_sSetInfo, 0, sizeof(MTF_DBLK_SSET_INFO));
    memset (&m_sVolInfo, 0, sizeof(MTF_DBLK_VOLB_INFO));

    m_pBuffer = NULL;
    m_pRealBuffer = NULL;
    m_nBufUsed = 0;
    m_nBufSize = 0;
    m_nStartOfPad = 0;

    m_bUseFlatFileStructure = FALSE;
    m_bUseSoftFilemarks = FALSE;
    m_bUseCaseSensitiveSearch = FALSE;
    m_bCommitFile = FALSE;
    m_bSetInitialized = FALSE;

    memset (&m_SaveBasicInformation, 0, sizeof(FILE_BASIC_INFORMATION));

    m_pvReadContext = NULL;

    // Create an MTFApi object 
    m_pMTFApi = new CMTFApi;

    iCountMTFs++;
    WsbTraceOut(OLESTR("CMTFSession::CMTFSession"),OLESTR("Count is <%d>"), iCountMTFs);
}



CMTFSession::~CMTFSession(void)
{
    WsbTraceIn(OLESTR("CMTFSession::~CMTFSession"), OLESTR(""));

    if (m_pMTFApi) {
        delete m_pMTFApi;
        m_pMTFApi = NULL;
    }

    if (m_pSoftFilemarks) {
        WsbFree(m_pSoftFilemarks);
        m_pSoftFilemarks = NULL;
    }

    if (m_pRealBuffer) {
        WsbFree(m_pRealBuffer);
        m_pBuffer = NULL;
        m_pRealBuffer = NULL;
    }

    iCountMTFs--;
    WsbTraceOut(OLESTR("CMTFSession::~CMTFSession"),OLESTR("Count is <%d>"), iCountMTFs);
}

////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//

HRESULT
CMTFSession::SetBlockSize(
    UINT32 blockSize)
/*++

Routine Description:

    Defines the physical block size for the session.  This is used for various PBA calculations.
    The value should only be set once per session.

Arguments:

    blockSize   -  The new block size for the session.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SetBlockSize"), OLESTR("<%d>"), blockSize);

    ULONG bufferSize = 0;

    try {
        WsbAssert(blockSize > 0, E_INVALIDARG);
        WsbAssert(!(blockSize % 512), E_INVALIDARG);

        m_nBlockSize = blockSize;

        // **MTF API CALL**
        // The MTF API needs to know the alignment factor!!!!!!!
        //
        WsbAssert(m_pMTFApi != NULL, E_OUTOFMEMORY);

        if (!(blockSize % 1024)) {
            m_pMTFApi->MTF_SetAlignmentFactor((UINT16) 1024);
        }
        else {
            // We already checked that the block size is a multiple of 512....
            m_pMTFApi->MTF_SetAlignmentFactor((UINT16) 512);
        }

        ULONG defaultBufferSize = RMS_DEFAULT_BUFFER_SIZE;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG nBlocks = defaultBufferSize/m_nBlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_nBlockSize;

        // Make sure we work with a virtual address aligned with sector size
        m_pRealBuffer = (BYTE *)WsbAlloc(bufferSize+m_nBlockSize);
        if (m_pRealBuffer) {
            if ((ULONG_PTR)m_pRealBuffer % m_nBlockSize) {
                m_pBuffer = m_pRealBuffer - ((ULONG_PTR)m_pRealBuffer % m_nBlockSize) + m_nBlockSize;
            } else {
                m_pBuffer = m_pRealBuffer;
            }
        } else {
            m_pBuffer = NULL;
        }

        WsbTrace(OLESTR("CMTFSession::SetBlockSize: Real Buffer Ptr = %I64X , Use Buffer Ptr = %I64X\n"), 
            (UINT64)m_pRealBuffer, (UINT64)m_pBuffer);

        if (m_pBuffer) {
            m_nBufSize = bufferSize;
            m_nBufUsed = 0;
        }
        else {
            m_nBufSize = 0;
            m_nBufUsed = bufferSize;
        }

        WsbAssertPointer(m_pBuffer);

        WsbTraceAlways( OLESTR("Using buffer size of %d bytes for data transfers.\n"), bufferSize);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SetBlockSize"), OLESTR("hr = <%ls>, Alignment = %d, BufferSize = %d"), WsbHrAsString(hr), m_pMTFApi->MTF_GetAlignmentFactor(), bufferSize);

    return hr;
}


HRESULT
CMTFSession::SetUseFlatFileStructure(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flags to the value specified.

Arguments:

    val         -  The new value for the UseFlatFileStructure flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bUseFlatFileStructure = val;

    return S_OK;
}



HRESULT
CMTFSession::SetUseCaseSensitiveSearch(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flag to the value specified.

Arguments:

    val         -  The new value for the CaseSensitiveSearch flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bUseCaseSensitiveSearch = val;

    return S_OK;
}



HRESULT
CMTFSession::SetCommitFile(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flag to the value specified.

Arguments:

    val         -  The new value for the CommitFile flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bCommitFile = val;

    return S_OK;
}


HRESULT
CMTFSession::SetUseSoftFilemarks(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flags to the value specified.

Arguments:

    val         -  The new value for the UseSoftFilemarks flag.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        m_bUseSoftFilemarks = val;

        if (TRUE == m_bUseSoftFilemarks) {
            WsbAssert(NULL == m_pSoftFilemarks, E_UNEXPECTED);

            // Make sure the block size was initialized.
            WsbAssert(m_nBlockSize > 0, E_UNEXPECTED);

            // Allocate a block of memory for the soft filemark array
            m_pSoftFilemarks = (MTF_DBLK_SFMB_INFO *) WsbAlloc(m_nBlockSize);
            WsbAffirmPointer(m_pSoftFilemarks);
            memset(m_pSoftFilemarks, 0 , m_nBlockSize);

            // **MTF API CALL**
            m_pSoftFilemarks->uNumberOfFilemarkEntries = m_pMTFApi->MTF_GetMaxSoftFilemarkEntries(m_nBlockSize);
            WsbAssert(m_pSoftFilemarks->uNumberOfFilemarkEntries > 0, E_UNEXPECTED);
        }
        else {
            if (m_pSoftFilemarks) {
                WsbFree(m_pSoftFilemarks);
                m_pSoftFilemarks = NULL;
            }
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::InitCommonHeader(void)
/*++

Routine Description:

    Sets up the common header.

    m_sHeaderInfo is set for unicode, NT & no block
    attributes

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{

    // Init Common header
    // **MTF API CALL**
    m_pMTFApi->MTF_SetDblkHdrDefaults(&m_sHeaderInfo);

    m_sHeaderInfo.uBlockAttributes = 0;
    m_sHeaderInfo.uOSID            = MTF_OSID_DOS; // MTF_OSID_NT or MTF_OSID_DOS
    m_sHeaderInfo.uStringType      = MTF_STRING_UNICODE_STR;

    return S_OK;
}


HRESULT
CMTFSession::DoTapeDblk(
    IN WCHAR *szLabel,
    IN ULONG maxIdSize,
    IN OUT BYTE *pIdentifier,
    IN OUT ULONG *pIdSize,
    IN OUT ULONG *pIdType)
/*++

Routine Description:

    Formats and Writes a TAPE DBLK.  TAPE DBLK and
    FILEMARK are written to beginning of tape, disk, or file.
 
Arguments:

    szLabel     -  The media label.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoTapeDblk"), OLESTR("<%ls>"), szLabel);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoTapeDblk.0");

        WsbAssertPointer(m_pBuffer);

        if ( maxIdSize > 0 ) {
            WsbAssertPointer( pIdentifier );
            WsbAssertPointer( pIdSize );
            WsbAssertPointer( pIdType );
        }

        MTF_DBLK_TAPE_INFO  sTapeInfo;           // **MTF API STRUCT ** -- info for TAPE

        (void) InitCommonHeader();

        // **MTF API CALL**
        // First set defaults for the info struct
        //
        // Note: Tthis sets the alignment factor to that set previously by 
        //        MTF_SetAlignmentFactor()
        m_pMTFApi->MTF_SetTAPEDefaults(&sTapeInfo);

        // Set the values of the MTF_DBLK_TAPE_INFO struct to suit our application

        // Set SFMB size, this should be used during restoration on media types that use SFM
        sTapeInfo.uSoftFilemarkBlockSize = (UINT16)(m_nBlockSize / 512);

        // The family id should be a unique value for each piece of media.  Although not
        //  guaranteed to be unique, the time function should provide something close enough.
        time_t tTime;

        sTapeInfo.uTapeFamilyId        = (unsigned int) time(&tTime);
        sTapeInfo.uTapeAttributes     |= MTF_TAPE_MEDIA_LABEL;

        if (TRUE == m_bUseSoftFilemarks) {
            sTapeInfo.uTapeAttributes |= MTF_TAPE_SOFT_FILEMARK;
        }

        sTapeInfo.uTapeSequenceNumber  = 1;
        sTapeInfo.szTapeDescription    = szLabel;
        sTapeInfo.uSoftwareVendorId    = REMOTE_STORAGE_MTF_VENDOR_ID;

        //
        // Get remaining information from the label
        //

        CWsbBstrPtr tempLabel = szLabel;
        WCHAR delim[]   = OLESTR("|");
        WCHAR *token;
        int   index=0;

        token = wcstok( (WCHAR *)tempLabel, delim );
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1: // Tag
            case 2: // Version
            case 3: // Vendor
                break;
            case 4: // Vendor Product ID
                sTapeInfo.szSoftwareName = token;
                break;
            case 5: // Creation Time Stamp
                {
                    int iYear, iMonth, iDay, iHour, iMinute, iSecond;
                    swscanf( token, L"%d/%d/%d.%d:%d:%d", &iYear, &iMonth, &iDay, &iHour, &iMinute, &iSecond );
                    // **MTF API CALL**
                    sTapeInfo.sTapeDate = m_pMTFApi->MTF_CreateDateTime( iYear, iMonth, iDay, iHour, iMinute, iSecond );
                }
                break;
            case 6: // Cartridge Label
                sTapeInfo.szTapeName = token;
                break;
            case 7: // Side
            case 8: // Media ID
            case 9: // Media Domain ID
            default: // Vendor specific of the form L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        // These are zero for the tape dblk
        m_sHeaderInfo.uControlBlockId       = 0;
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        WsbTrace(OLESTR("Writing Tape Header (TAPE)\n"));

        // Sets the current position to beginning of data.
        WsbAffirmHr(SpaceToBOD());

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_TAPE_INFO structs to this
        // function.  The result is an MTF formatted TAPE DBLK in m_pBuffer.
        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteTAPEDblk(&m_sHeaderInfo, &sTapeInfo, m_pBuffer, m_nBufSize, &m_nBufUsed));

        WsbTrace(OLESTR("Tape Header uses %lu of %lu bytes\n"), (ULONG)m_nBufUsed, (ULONG)m_nBufSize);

        // Save the on media identifier
        if (maxIdSize > 0) {
            *pIdSize = (maxIdSize > (ULONG)m_nBufUsed) ? (ULONG)m_nBufUsed : maxIdSize;
            *pIdType = (LONG) RmsOnMediaIdentifierMTF;
            memcpy(pIdentifier, m_pBuffer, *pIdSize);
        }

        WsbAffirmHr(PadToNextPBA());

        // Write a filemark.  This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoSSETDblk(
    IN WCHAR *szSessionName,
    IN WCHAR *szSessionDescription,
    IN MTFSessionType type,
    IN USHORT nDataSetNumber)
/*++

Routine Description:

    Formats and Writes a SSET DBLK.  The SSET is the first DBLK written
    to a data set.

Arguments:

    szSessionName   -  Session name.
    szSessionDescription - Session description that is displayed by the Backup program
    type            -  Specifies the data set type: Transfer, copy , normal, differential,
                       incremental, daily, etc.
    nDataSetNumber  -  The data set number.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoSSETDblk"), OLESTR("<%ls> <%ls> <%d> <%d>"), szSessionName, szSessionDescription, type, nDataSetNumber);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoSSETDblk.0");

        WsbAssertPointer(m_pBuffer);

        UINT64  curPos;
        size_t  nBufUsed = 0;

        // Reset Control Block info.

        m_nCurrentBlockId = 0;
        m_nDirectoryId = 0;
        m_nFileId = 0;

        (void) InitCommonHeader();

        // Init SSET block
        // **MTF API CALL**
        m_pMTFApi->MTF_SetSSETDefaults(&m_sSetInfo);
        m_bSetInitialized = TRUE;

        //
        // Find out our account information
        //
        CWsbStringPtr accountName;
        WsbAffirmHr(WsbGetServiceInfo(APPID_RemoteStorageEngine, NULL, &accountName));

        //
        // Set the values of the MTF_DBLK_SSET_INFO struct...
        //

        // First select the type of data set we are creating.
        switch (type) {
        case MTFSessionTypeTransfer:
            m_sSetInfo.uSSETAttributes = MTF_SSET_TRANSFER;
            break;

        case MTFSessionTypeCopy:
            m_sSetInfo.uSSETAttributes = MTF_SSET_COPY;
            break;

        case MTFSessionTypeNormal:
            m_sSetInfo.uSSETAttributes = MTF_SSET_NORMAL;
            break;

        case MTFSessionTypeDifferential:
            m_sSetInfo.uSSETAttributes = MTF_SSET_DIFFERENTIAL;
            break;

        case MTFSessionTypeIncremental:
            m_sSetInfo.uSSETAttributes = MTF_SSET_INCREMENTAL;
            break;

        case MTFSessionTypeDaily:
            m_sSetInfo.uSSETAttributes = MTF_SSET_DAILY;
            break;

        default:
            WsbThrow(E_INVALIDARG);
            break;
        }

        m_sSetInfo.uDataSetNumber        = nDataSetNumber;
        m_sSetInfo.uSoftwareVendorId     = REMOTE_STORAGE_MTF_VENDOR_ID;
        m_sSetInfo.szDataSetName         = szSessionName;
        m_sSetInfo.szDataSetDescription  = szSessionDescription;
        m_sSetInfo.szUserName            = accountName;
        WsbAffirmHr(GetCurrentPBA(&curPos)); // utility fn below
        m_sSetInfo.uPhysicalBlockAddress = curPos;
        m_sSetInfo.uPhysicalBlockAddress += 1 ;  // MTF is one based, devices are zero based.
        m_sSetInfo.uSoftwareVerMjr       = REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ;
        m_sSetInfo.uSoftwareVerMnr       = REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN;

        // Save the PBA for the data set
        m_nPhysicalBlockAddress = m_sSetInfo.uPhysicalBlockAddress -1;
        WsbAssert(m_nPhysicalBlockAddress > 0, E_UNEXPECTED);  // Someting went wrong!
        m_nFormatLogicalAddress = 0;

        // The Control Block ID field is used for error recovery.  The 
        // Control Block ID value for an SSET DBLK should be zero.  All 
        // subsequent DBLKs within the Data Set will have a Control Block
        // ID one greater than the previous DBLKs Control Block ID.
        // Values for this field are only defined for DBLKs within a Data
        // Set from the SSET to the last DBLK occurring prior to the ESET.
        WsbAssert(0 == m_nCurrentBlockId, E_UNEXPECTED);
        m_sHeaderInfo.uControlBlockId = m_nCurrentBlockId++;

        // Increment them here after for every dblk we write
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        WsbTrace(OLESTR("Writing Start of Set (SSET) @ PBA %I64u\n"), m_nPhysicalBlockAddress);

        // **MTF API CALL** -- 
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_SSET_INFO structs to
        // this function.  The result is an MTF formatted SSET DBLK in m_pBuffer.
        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteSSETDblk(&m_sHeaderInfo, &m_sSetInfo, m_pBuffer, m_nBufSize, &m_nBufUsed));

        // We pass in FALSE to make sure we don't actually touch tape.  The SSET is the
        // first DBLK written in the data set so we have plenty of transfer buffer for
        // the DBLKs to follow.
        //
        // This routine is called when the application starts a new data set, but
        // we don't wan't to fail if we're going to get device errors, that will come
        // later.
        WsbAffirmHr(PadToNextFLA(FALSE));

        m_sHints.DataSetStart.QuadPart = m_nPhysicalBlockAddress * m_nBlockSize;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoSSETDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoVolumeDblk(
    IN WCHAR *szPath)
/*++

Routine Description:

    Formats and Writes a VOLB DBLK.

Arguments:

    szPath      -  Full pathname containing name of volume.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoVolumeDblk"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    try {
        MvrInjectError(L"Inject.CMTFSession::DoVolumeDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        CWsbStringPtr       szVolume;
        size_t              nMoreBufUsed;

        szVolume = szPath;
        WsbAffirm(0 != (WCHAR *)szVolume, E_OUTOFMEMORY);
        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);
        
        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (VOLB) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        // **MTF API CALL**

        // Sets the MTF_VOLB_DBLK_INFO struct using Win32 GetVolumeInformation data
        m_pMTFApi->MTF_SetVOLBForDevice(&m_sVolInfo, szVolume);

        // Increment the blockid and alignment index values that we keep in 
        // our common block header structure.
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_VOLB_INFO structs to
        // this function.  The result is an MTF formatted VOLB DBLK in m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteVOLBDblk(&m_sHeaderInfo, &m_sVolInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // Output VOLB to the data set.
        WsbAffirmHr(PadToNextFLA(TRUE));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoVolumeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoParentDirectories(
    IN WCHAR *szPath)
/*++

Routine Description:

    Formats and writes the parent DIRB Dblks for the given pathname.

Arguments:

    szPath      -  Full pathname of directory.

Return Value:

    S_OK        -  Success.


Note:

    In order for both stickyName and driveLetter-colon path formats to work properly, both with and
    without writing separate DIRBs for the parent directories,
    THE EXISTENCE AND PLACEMENT OF THE PATH MANIPULATION CODE (APPEND/PREPEND, ETC.) IS CRUCIAL!!!

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoParentDirectories"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoParentDirectories.0");

        WsbAssertPointer( szPath );

        WIN32_FIND_DATAW    obFindData;

        CWsbStringPtr  path;
        CWsbStringPtr  nameSpace;
        WCHAR *szDirs;
        WCHAR *token;

        DWORD additionalSearchFlags = 0;
        additionalSearchFlags |= (m_bUseCaseSensitiveSearch) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

        nameSpace = szPath;
        nameSpace.GiveTo(&szDirs);

        // First we need to do a DIRB dblk for the root directory
        nameSpace = wcstok(szDirs, OLESTR("\\"));  // pop off "Volume{......}" or "driveLetter:"
        WsbAffirmHr(nameSpace.Append(OLESTR("\\")));

        // ** WIN32 API Call - gets directory info for the root directory
        // For the root directory only, we need to call GetFileInformationByHandle instead of
        // ..FindFirstFileEx.  FindFirst doesn't return root dir info since the root has no parent 
        path = nameSpace;
        WsbAffirmHr(path.Prepend(OLESTR("\\\\?\\")));
        WsbAffirm(0 != (WCHAR *)path, E_OUTOFMEMORY);
        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
        WsbAffirmHandle(hSearchHandle = CreateFile(path, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
        WsbAffirmStatus(GetFileInformationByHandle(hSearchHandle, &obGetFileInfoData));
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // At time of this writing CreateTime for root dir is bogus.  (bills 10/20/98).
        WsbTrace(OLESTR("Create Time      = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftCreationTime));
        WsbTrace(OLESTR("Last Access Time = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftLastAccessTime));
        WsbTrace(OLESTR("Last Write Time  = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftLastWriteTime));

        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;

        WsbAffirmHr(DoDirectoryDblk(nameSpace, &obFindData));


        // Now do the same for each succeeding directory in the path using strtok

        token = wcstok(0, OLESTR("\\"));            // pop off first subdir

        for ( ; token; token = wcstok(0, OLESTR("\\"))) {

            nameSpace.Append(token);

            path = nameSpace;
            path.Prepend(OLESTR("\\\\?\\"));

            WsbAssertHandle(hSearchHandle = FindFirstFileEx((WCHAR *) path, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));

            if ( obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                nameSpace.Append(OLESTR("\\"));     // add in \ to dir
                WsbAffirmHr(DoDirectoryDblk((WCHAR *) nameSpace, &obFindData)); 

            }

            FindClose(hSearchHandle);
            hSearchHandle = INVALID_HANDLE_VALUE;
        }

        nameSpace.TakeFrom(szDirs, 0); // cleanup

    } WsbCatch(hr);

    if (hSearchHandle != INVALID_HANDLE_VALUE) {
        FindClose(hSearchHandle);
    }


    WsbTraceOut(OLESTR("CMTFSession::DoParentDirectories"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDataSet(
    IN WCHAR *szPath)
/*++

Routine Description:

    Recurses through all the items contained in the directory
    specified by path and backs them up calling DoFileDblk and 
    DoDirectoryDblk

Arguments:

    szPath      -  Full pathname of directory.

Return Value:

    S_OK            -  Success.
    MVR_E_NOT_FOUND -  Object not found.

--*/
{
    HRESULT hr = MVR_E_NOT_FOUND;
    WsbTraceIn(OLESTR("CMTFSession::DoDataSet"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDataSet.0");

        WsbAssertPointer( szPath );

        WIN32_FIND_DATAW obFindData;
        BOOL bMoreFiles;

        CWsbStringPtr nameSpace;
        CWsbStringPtr pathname;

        // check if the specification is for file(s):  nameSpace = c:\dir\test*.* or c:\dir\test1.tst
        nameSpace = szPath;
        WsbAffirmHr(nameSpace.Prepend(OLESTR("\\\\?\\")));

        DWORD additionalSearchFlags = 0;
        additionalSearchFlags |= (m_bUseCaseSensitiveSearch) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

        WsbAssertHandle(hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags));

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            // Skip all directories
            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {  // Not a dir

                CWsbStringPtr path;

                WCHAR *end;
                LONG numChar;

                // use the szPath to get the pathname, then append the filename
                pathname = szPath;
                WsbAffirm(0 != (WCHAR *)pathname, E_OUTOFMEMORY);
                end = wcsrchr((WCHAR *)pathname, L'\\');
                WsbAssert(end != NULL, MVR_E_INVALIDARG);
                numChar = (LONG)(end - (WCHAR *)pathname + 1);
                WsbAssert(numChar > 0, E_UNEXPECTED);
                WsbAffirmHr(path.Alloc(numChar + MAX_PATH));
                wcsncpy((WCHAR *)path, (WCHAR *)pathname, numChar);
                ((WCHAR *)path)[numChar] = L'\0';
                path.Append(obFindData.cFileName);

                WsbAffirmHr(hr = DoFileDblk((WCHAR *)path, &obFindData));
            }
        }

        // close search handle after processing all the files
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // process all files for this directory:  nameSpace = c:\dir
        nameSpace = szPath;
        nameSpace.Append(OLESTR("\\*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags);

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                // use the szPath to get the pathname, then append the filename
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmHr(hr = DoFileDblk((WCHAR *)pathname, &obFindData));
            }
        }

        // close search handle after processing all the files
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // process all directories in this directory:  nameSpace = c:\dir
        nameSpace = szPath;
        nameSpace.Append(OLESTR("\\*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags);

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            // Recursively handle any directories other than . and ..
            if (((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
                (wcscmp(obFindData.cFileName, OLESTR(".")) != 0) &&
                (wcscmp(obFindData.cFileName, OLESTR("..")) != 0)) {

                // append the directory name to pathname
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);
                pathname.Append(OLESTR("\\"));

                WsbAffirmHr(hr = DoDirectoryDblk((WCHAR *) pathname, &obFindData));

                // append the directory name to pathname and process
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmHr(DoDataSet((WCHAR *) pathname));
            }
        }
    } WsbCatch(hr);

    // close search handle after processing all the directories
    if (hSearchHandle != INVALID_HANDLE_VALUE) {
        FindClose(hSearchHandle);
    }


    WsbTraceOut(OLESTR("CMTFSession::DoDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDirectoryDblk(
    IN WCHAR *szPath,
    IN WIN32_FIND_DATAW *pFindData)
/*++

Routine Description:

    Writes out a DIRB DBLK and calls DoStream to write out
    associated stream data.

Arguments:

    szPath      -  Full pathname of directory.
    pFindData   -  WIN32 information about the directiory.

Return Value:

    S_OK        -  Success.

Note:

    In order for both stickyName and driveLetter-colon path formats to work properly, both with and
    without writing separate DIRBs for the parent directories,
    THE EXISTENCE AND PLACEMENT OF THE PATH MANIPULATION CODE (APPEND/PREPEND, ETC.) IS CRUCIAL!!!

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoDirectoryDblk"), OLESTR(""));

    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDirectoryDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        MTF_DBLK_DIRB_INFO  sDIRB;  // **MTF API STRUCT ** -- info for DIRB
        PWCHAR              pSlash;
        size_t              nMoreBufUsed;

        WCHAR               *end;

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);

        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (DIRB) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        CWsbStringPtr path = szPath;

        // tack on trailing backslash if not already there
        end = wcsrchr((WCHAR *)path, L'\0');
        WsbAssert(end != NULL, MVR_E_INVALIDARG);  // Something went wrong!
        if(*(end-1) != L'\\') { 
            path.Append(OLESTR("\\"));
        }

        // Get a handle to the directory.  If this fails we need to skip everything else.
        WsbAffirmHr(OpenStream(path, &hStream));

        // **MTF API CALL**
        // automatically fill in the MTF_DIRB_DBLK_INFO structure using
        // information in the pFindData structure
        //
        // if we are getting something in the form of "C:\", 
        //      then we want to send the name along as just "\"
        // otherwise
        //      we want to send the full path, but omit the volume ("C:\")
        //      thus the "+3"

        pSlash = wcschr(path, L'\\');
        WsbAssert(pSlash != NULL, MVR_E_INVALIDARG);  // Something went wrong!
        pSlash++;                       // Look for the second one
        pSlash = wcschr(pSlash, L'\\');
        if (NULL == pSlash) {
            // It's just the volume name and nothing more
            m_pMTFApi->MTF_SetDIRBFromFindData(&sDIRB, OLESTR("\\"), pFindData);
        }
        else {
            pSlash = wcschr(path, L'\\');  // point to first backslash (beginning of path)
            m_pMTFApi->MTF_SetDIRBFromFindData(&sDIRB, pSlash + 1, pFindData);
        }


        // Check if we need to set the Backup Date field for the DIRB
        if (m_sSetInfo.uSSETAttributes & MTF_SSET_NORMAL) {

            time_t tTime;
            time(&tTime);
            
            sDIRB.sBackupDate = m_pMTFApi->MTF_CreateDateTimeFromTM(gmtime(&tTime));
        }


        // make sure to mark and update the directory id as well as the
        // control block id and alignment is already correct
        sDIRB.uDirectoryId                  = ++m_nDirectoryId;
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        // Add in OS Specific data
        MTF_DIRB_OS_NT_0 sOSNT;

        switch ( m_sHeaderInfo.uOSID ) {
        case MTF_OSID_NT:
            sOSNT.uDirectoryAttributes = sDIRB.uDirectoryAttributes;
            m_sHeaderInfo.pvOSData = &sOSNT;
            m_sHeaderInfo.uOSDataSize = sizeof(sOSNT);
            break;
        default:
            break;
        }

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // provide the MTF_DBLK_HDR_INFO and MTF_DBLK_DIRB_INFO structs
        // to this function.  The result is an MTF formatted DIRB DBLK in
        // m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteDIRBDblk(&m_sHeaderInfo, &sDIRB, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // **MTF API CALL**
        // output the name stream, if required.
        if ( sDIRB.uDirectoryAttributes & MTF_DIRB_PATH_IN_STREAM ) {
            nMoreBufUsed = 0;
            if ( m_sVolInfo.uVolumeAttributes & MTF_VOLB_DEV_DRIVE ) {
                WsbAssertNoError(m_pMTFApi->MTF_WriteNameStream(MTF_PATH_NAME_STREAM, szPath + 3, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                m_nBufUsed += nMoreBufUsed;
            }
            else if ( m_sVolInfo.uVolumeAttributes & MTF_VOLB_DEV_OS_SPEC ) {

                if ( 0 == _wcsnicmp( m_sVolInfo.szDeviceName, OLESTR("Volume{"), 7 )) {
                    WsbAssertNoError(m_pMTFApi->MTF_WriteNameStream(MTF_PATH_NAME_STREAM, szPath + 45, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                    m_nBufUsed += nMoreBufUsed;
                }
                else {
                    // unrecognized operating system specific format
                    WsbThrow(MVR_E_INVALIDARG);
                }
            }
            else {
                // UNC path - unsupported
                WsbThrow(MVR_E_INVALIDARG);
            }
        }
        // Now, instead of padding this out, we call this funciton to write
        // out the stream which will write out the current contents of the
        // buffer as well.  When this call returns, the current contents of
        // the buffer as well as the associated data stream will have been
        // written to media.

        // Note:  Data may still remain in the device buffer, or the
        //        local m_pBuffer if the file doesn't pad to a block
        //        boundary, and the device buffer is not flushed.

        WsbAffirmHr(DoDataStream(hStream));

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hStream) {
        CloseStream(hStream);
        hStream = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CMTFSession::DoDirectoryDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoFileDblk(
    IN WCHAR *szPath,
    IN WIN32_FIND_DATAW *pFindData)
/*++

Routine Description:

    Writes out a FILE DBLK and calls DoStream to write out
    associated stream data

Arguments:

    szPath      -  Full pathname of file.
    pFindData   -  WIN32 information about the file.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoFileDblk"), OLESTR(""));

    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoFileDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        MTF_DBLK_FILE_INFO  sFILE;     // **MTF API STRUCT ** -- info for FILE
        size_t              nMoreBufUsed;

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);
        
        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (FILE) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        // Get a handle to the directory.  If this fails we need to skip everything else.
        WsbAffirmHr(OpenStream(szPath, &hStream));

        // Initialize the hints set for each file.
        m_sHints.FileStart.QuadPart = fla * uAlignmentFactor;
        m_sHints.FileSize.QuadPart = 0;
        m_sHints.DataStart.QuadPart = 0;
        m_sHints.DataSize.QuadPart = 0;
        m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
        m_sHints.VerificationData.QuadPart = 0;
        m_sHints.DatastreamCRCType = WSB_CRC_CALC_NONE;
        m_sHints.DatastreamCRC.QuadPart = 0;
        m_sHints.FileUSN.QuadPart = 0;

        if (m_bUseFlatFileStructure) {

            // For HSM we rename the file to it's logical address

            swprintf( pFindData->cFileName, L"%08x", fla );
        }

        // **MTF API CALL**
        // automatically fill in the MTF_FILE_DBLK_INFO structure using
        // information in the pFindData structure
        m_pMTFApi->MTF_SetFILEFromFindData(&sFILE, pFindData);

        // Check if we need to set the Backup Date field for the FILE DBLK

        if ((m_sSetInfo.uSSETAttributes & MTF_SSET_NORMAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_DIFFERENTIAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_INCREMENTAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_DAILY)){

            time_t tTime;
            time(&tTime);

            sFILE.sBackupDate = m_pMTFApi->MTF_CreateDateTimeFromTM(gmtime(&tTime));
        }

        // make sure to mark and update the file id as well as the control
        // block id and alignment is already correct
        sFILE.uDirectoryId                  = m_nDirectoryId;
        sFILE.uFileId                       = ++m_nFileId;
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        // Add in OS Specific data
        MTF_FILE_OS_NT_0 sOSNT;

        switch ( m_sHeaderInfo.uOSID ) {
        case MTF_OSID_NT:
            sOSNT.uFileAttributes = sFILE.uFileAttributes;
            sOSNT.uShortNameOffset = 0;
            sOSNT.uShortNameSize = 0;
            sOSNT.lLink = 0;
            sOSNT.uReserved = 0;
            m_sHeaderInfo.pvOSData = &sOSNT;
            m_sHeaderInfo.uOSDataSize = sizeof(sOSNT);
            break;
        default:
            break;
        }

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_FILE_INFO structs
        // to this function.  The result is an MTF formatted FILE DBLK in
        // m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteFILEDblk(&m_sHeaderInfo, &sFILE, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // Like the directory, instead of padding this out, we call this
        // funciton to write out the stream which will write out the current
        // contents of the buffer as well.  When this call returns, the
        // current contents of the buffer as well as the associated data
        // stream will have been written to media.

        // Note:  Data may still remain in the device buffer, or the
        //        local m_pBuffer if the file doesn't pad to a block
        //        boundary, and the device buffer is not flushed.

        hr = DoDataStream(hStream);
        if ( hr != S_OK) {
            // unable to copy the file to target media.
            WsbTraceAlways( OLESTR("Unable to store file %ls.  reason = %s\n"), WsbAbbreviatePath(szPath, 120), WsbHrAsString(hr));
            WsbThrow(hr);
        }
        else {
            // Make sure we are alinged with a FLA (i.e. the last stream was properly padded).
            WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);

            m_sHints.FileSize.QuadPart = 
                m_nFormatLogicalAddress * uAlignmentFactor + m_nBufUsed - m_sHints.FileStart.QuadPart;
        }
    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hStream) {
        CloseStream(hStream);
        hStream = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CMTFSession::DoFileDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CMTFSession::OpenStream(
    IN WCHAR *szPath,
    OUT HANDLE *pStreamHandle)
/*++

Routine Description:

    Opens the file to backup in "backup read" mode, and returns
    stream handle for the file specified.

Arguments:

    szPath      -  Full pathname of file.
    hStream     -  Returned stream handle.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::OpenStream"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));
    
    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::OpenStream.0");

        WsbAssertPointer(szPath);
        WsbAssertPointer(pStreamHandle);

        *pStreamHandle = INVALID_HANDLE_VALUE;

        FILE_BASIC_INFORMATION      basicInformation;
        IO_STATUS_BLOCK             IoStatusBlock;
        NTSTATUS                    ccode;

        // ** WIN32 File API Call - open the file for backup read.  This can be more involved if
        // the app needs to be run by someone without the proper authority to
        // backup certain files....
        // We also ask for GENERIC_WRITE so we can set the attributes to prevent the
        // modification of dates.

        DWORD posixFlag = (m_bUseCaseSensitiveSearch) ? FILE_FLAG_POSIX_SEMANTICS : 0;

        CWsbStringPtr name = szPath;
        WsbAffirmHr(name.Prepend(OLESTR("\\\\?\\")));
        WsbAffirm(0 != (WCHAR *)name, E_OUTOFMEMORY);
        WsbAffirmHandle(hStream = CreateFileW((WCHAR *) name,
                                   GENERIC_READ | FILE_WRITE_ATTRIBUTES,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                                   NULL));

        //
        // Prevent modification of file dates
        //
        // ** NT System Call - query for file information
        WsbAffirmNtStatus(NtQueryInformationFile(hStream, &IoStatusBlock, (PVOID)&basicInformation,
                            sizeof( basicInformation ), FileBasicInformation));

        m_SaveBasicInformation = basicInformation;
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;

        // ** NT System Call - set file information
        WsbAffirmNtStatus(ccode = NtSetInformationFile( hStream, &IoStatusBlock, (PVOID)&basicInformation,
                                sizeof( basicInformation ), FileBasicInformation));

        if (pStreamHandle) {
            *pStreamHandle = hStream;
        }

    } WsbCatchAndDo(hr,
            if (INVALID_HANDLE_VALUE != hStream) {
                CloseHandle( hStream );
                hStream = INVALID_HANDLE_VALUE;
            }
        );


    WsbTraceOut(OLESTR("CMTFSession::OpenStream"), OLESTR("hr = <%ls>, handle = <0x%08x>"), WsbHrAsString(hr), hStream);

    return hr;
}


HRESULT
CMTFSession::CloseStream(
    IN HANDLE hStream)
/*++

Routine Description:

    Close stream handle and performs cleanup.

Arguments:

    hStream     -  Stream handle to close

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::CloseStream"), OLESTR("<0x%08x>"), hStream);

    try {

        if (INVALID_HANDLE_VALUE != hStream) {

            //
            // Cleanup from a partial backup read.  We're setting bAbort=TRUE
            // to free resources used by BackupRead()
            //
            if (m_pvReadContext) {
                (void) BackupRead(hStream, NULL, 0, NULL, TRUE, FALSE, &m_pvReadContext);
                m_pvReadContext = NULL;
            }
            (void) CloseHandle( hStream );
            hStream = INVALID_HANDLE_VALUE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDataStream(
    IN HANDLE hStream)
/*++

Routine Description:

    Uses WIN32 BackupRead to read streams associated with a file 
    and then write them out to the data set.  BackupRead opens a 
    file and successively reads data streams from that file.
    Each data stream is preceeded by a WIN32_STREAM_ID struct.

Arguments:

    hStream      -  File handle.

Return Value:

    S_OK        -  Success.

Algorithm:

    - with buffer, current_buf_position do:

        - while there are more streams loop
            - read next stream header using BackupRead
            - exit loop when no next stream

            - use stream header to append format MTF STREAM HEADER to buffer

            - flush as much of buffer as possible to the data set.

            - while entire stream not read loop
                - read as much of current stream as possible into remainder
                  of buffer 
                - flush as much of buffer as possible to the data set.
            - end loop this stream not read
        - end loop more streams

        - flush as much of the buffer to the data set

        - pad buffer out to next alignment factor

        - flush as much of the buffer to the data set

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoDataStream"), OLESTR("<0x%08x>"), hStream);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDataStream.0");

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        WsbTrace(OLESTR("CMTFSession::DoDataStream - Start: FLA = %I64u\n"), fla);

        WIN32_STREAM_ID sStreamHeader;      // comes back from Win32 BackupRead
        ULONG           nThisRead;          // number of bytes to read
        ULONG           nBytesRead;         // number of bytes read
        UINT64          nStreamBytesToRead; // total number bytes that we need to read
        UINT64          nStreamBytesRead;   // total number bytes that have been read
        USHORT          nStreamCount = 0;   // current stream number
        MTF_STREAM_INFO sSTREAM;
        size_t          nMoreBufUsed;
        BOOL            bReadStatus = FALSE;

        // Prepare to calculate the CRC for the unnamed datastream
        BYTE* pCurrent;
        BYTE* pStart;
        ULONG datastreamCRC;
        BOOL doDatastreamCRC;

        memset(&sStreamHeader, 0, sizeof(WIN32_STREAM_ID));
        
        INITIALIZE_CRC(datastreamCRC);
        WsbTrace(OLESTR("CMTFSession::DoDataStream initialzed CRC is <%lu> for <0x%08x>\n"),
            datastreamCRC, hStream);
        m_sHints.DatastreamCRCType = WSB_CRC_CALC_NONE;

        WsbTrace(OLESTR("CMTFSession::DoDataStream - Start While\n"));
        while(1) {
            // We want to do a CRC on the unnamed datastream
            doDatastreamCRC = FALSE;
            nBytesRead = 0;

            try {

                MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.1.0");
            
                // ** WIN32 File API Call - Backup read returns the file as a sequence of streams each
                // preceed by a WIN32_STREAM_ID struct.  Note that this structure is a
                // variable size -- depending on the length of the name of the stream.
                // In any case, we are guaranteed at least 20 bytes of it
                // (WIN32_STREAM_ID_SIZE)
                nStreamCount++;
                WsbAffirmStatus(BackupRead(hStream,
                            (BYTE *) &sStreamHeader,
                            WIN32_STREAM_ID_SIZE,
                            &nBytesRead,
                            FALSE,
                            TRUE,
                            &m_pvReadContext));

                MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.1.1");

            } catch (HRESULT catchHr) {

                //
                // CORRUPT FILE PROCESSING for stream header
                //

                hr = catchHr;

                WsbLogEvent(MVR_E_ERROR_IO_DEVICE, 0, NULL, WsbHrAsString(hr), NULL);

                // Write SPAD
                WsbAffirmHr(PadToNextFLA(TRUE));

                // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
                // It won't be if we are having problems writing to tape.
                WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);
                UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
                UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
                WsbTrace(OLESTR("%ls (CFIL) @ FLA %I64u (%I64u, %I64u)\n"), fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

                // Write a corrupt file (CFIL) DBLK
                MTF_DBLK_CFIL_INFO sCFILInfo;

                m_pMTFApi->MTF_SetCFILDefaults( &sCFILInfo );

                sCFILInfo.uCorruptStreamNumber = nStreamCount;
                sCFILInfo.uStreamOffset = 0;

                m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                m_sHeaderInfo.uFormatLogicalAddress = fla;

                WsbAssertNoError(m_pMTFApi->MTF_WriteCFILDblk(&m_sHeaderInfo, &sCFILInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                m_nBufUsed += nMoreBufUsed;

                WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                WsbThrow(hr);

            };

            if (nBytesRead < WIN32_STREAM_ID_SIZE)
                break;


            // **MTF API CALL**
            // now use the info in the stream header to fill in an mtf stream
            // header using the mtf call then write the resulting info to the
            // buffer.

            // BMD Note: special conditional code added on third arg for named data streams

            m_pMTFApi->MTF_SetSTREAMFromStreamId( &sSTREAM,
                                       &sStreamHeader,
                                       (sStreamHeader.dwStreamNameSize) ? sStreamHeader.dwStreamNameSize + 4 : 0 );
  
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            // **MTF API CALL**
            // Write out the stream header.
            nMoreBufUsed = 0;
            WsbAssertNoError(m_pMTFApi->MTF_WriteStreamHeader(&sSTREAM, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
            m_nBufUsed += nMoreBufUsed;

            // BMD Note: we need to put the size of the stream name in the MTF stream
            //           right after the header.  We'll write the name itself as part of the stream.
            //
            //           ?? Should this be in MTF_WriteStreamHeader ??

            if ( sStreamHeader.dwStreamNameSize ) {
                *(DWORD UNALIGNED *)(m_pBuffer + m_nBufUsed) = sStreamHeader.dwStreamNameSize;
                m_nBufUsed += sizeof( DWORD );
            }

            // Save away the "STAN" stream start byte address, and size.
            // This is the one we recall.
            if ( 0 == memcmp( sSTREAM.acStreamId, "STAN", 4 ) ) {
                // This is an unnamed data stream, so there's no stream name.
                m_sHints.VerificationData.QuadPart = sSTREAM.uCheckSum;
                m_sHints.VerificationType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                m_sHints.DataStart.QuadPart = m_nFormatLogicalAddress * uAlignmentFactor + m_nBufUsed - m_sHints.FileStart.QuadPart;
                m_sHints.DataSize.QuadPart = sSTREAM.uStreamLength;
                doDatastreamCRC = TRUE;
                m_sHints.DatastreamCRCType = WSB_CRC_CALC_MICROSOFT_32;
            }

            // the above stream should always fit...
            WsbAssert(m_nBufUsed < m_nBufSize, MVR_E_LOGIC_ERROR);

            // try to flush as many BLOCK SIZE chunks out of the buffer as possible
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
            // now, while there is more data in the stream, read the rest of
            // the stream, or how ever much will fit into the buffer
            nStreamBytesToRead = m_pMTFApi->MTF_CreateUINT64(sStreamHeader.Size.LowPart, sStreamHeader.Size.HighPart)
                                 + sStreamHeader.dwStreamNameSize;

            nStreamBytesRead = 0;

            WsbTrace(OLESTR("CMTFSession::DoDataStream - Start Do\n"));
            do
            {
                nThisRead = 0;

                // we read as many bytes as will fit into our buffer, up to
                // the end of the stream min doesn't work well here... 
                if (nStreamBytesToRead < (m_nBufSize - m_nBufUsed))
                    nThisRead = (ULONG) nStreamBytesToRead;
                else
                    nThisRead = (ULONG)(m_nBufSize - m_nBufUsed);

                    try {

                        MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.2.0");

                        // ** WIN32 File API Call - read nThisRead bytes, bail out if the read failed or
                        // no bytes were read (assume done)
                        bReadStatus = FALSE;
                        bReadStatus = BackupRead(hStream,
                                             m_pBuffer + m_nBufUsed,
                                             nThisRead,
                                             &nBytesRead,
                                             FALSE,
                                             TRUE,
                                             &m_pvReadContext);

                        nStreamBytesRead += nBytesRead;

                        WsbAffirmStatus(bReadStatus);

                        MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.2.1");

                    } catch (HRESULT catchHr) {

                        //
                        // CORRUPT FILE PROCESSING for stream data
                        //
                        hr = catchHr;

                        WsbLogEvent(MVR_E_ERROR_IO_DEVICE, 0, NULL, WsbHrAsString(hr), NULL);

                        // Go to the last good byte
                        m_nBufUsed += nBytesRead;

                        // Pad to fill up size of file
                        while( nStreamBytesRead < nStreamBytesToRead ) {
                            for( ; (m_nBufUsed < m_nBufSize) && (nStreamBytesRead < nStreamBytesToRead); ++m_nBufUsed, ++nStreamBytesRead ) {
                                m_pBuffer[m_nBufUsed] = 0;
                            }
                            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
                        }
                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        // Align on 4-byte boundary
                        for( ; m_nBufUsed % 4; ++m_nBufUsed ){
                            m_pBuffer[m_nBufUsed] = 0;
                        }

                        // Write SPAD
                        WsbAffirmHr(PadToNextFLA(TRUE));

                        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
                        // It won't be if we are having problems writing to tape.
                        WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);
                        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
                        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
                        WsbTrace(OLESTR("%ls (CFIL) @ FLA %I64u (%I64u, %I64u)\n"), fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

                        // Write a corrupt file (CFIL) DBLK
                        MTF_DBLK_CFIL_INFO sCFILInfo;

                        m_pMTFApi->MTF_SetCFILDefaults( &sCFILInfo );

                        sCFILInfo.uCorruptStreamNumber = nStreamCount;
                        sCFILInfo.uStreamOffset = nStreamBytesRead;

                        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                        m_sHeaderInfo.uFormatLogicalAddress = fla;

                        WsbAssertNoError(m_pMTFApi->MTF_WriteCFILDblk(&m_sHeaderInfo, &sCFILInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                        m_nBufUsed += nMoreBufUsed;

                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        WsbThrow(hr);

                    };

                if (nBytesRead == 0)
                    break;

                nStreamBytesToRead -= nBytesRead;
                pStart = m_pBuffer + m_nBufUsed;
                m_nBufUsed += nBytesRead;

                HRESULT hrCRC = S_OK;
                if (TRUE == doDatastreamCRC )  {
                    for (pCurrent = pStart; (pCurrent < (pStart + nBytesRead)) && (S_OK == hr); pCurrent++) {
                        hrCRC = WsbCRCReadFile(pCurrent, &datastreamCRC);
                        if (S_OK != hrCRC) {
                            WsbThrow(MVR_E_CANT_CALC_DATASTREAM_CRC);
                        }
                    }
                }

                // At this point we've got stuff in the buffer that might need
                // to be flushed so, try to do that
                WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            } while (nStreamBytesToRead > 0);
            WsbTrace(OLESTR("CMTFSession::DoDataStream - End Do\n"));

            // Okay.  At this point we're done with the stream.  As much as
            // possible was actually written out to the data set by FlushBuffer, but
            // some probably still remains in the buffer.  It will get flushed
            // later on...  At this point we need to align on a four byte
            // boundary.  Once we do this, we can start all over again with
            // the next stream (if none, then we bail out of this loop)
            for( ; m_nBufUsed % 4; ++m_nBufUsed )
                m_pBuffer[m_nBufUsed] = 0;
        }
        WsbTrace(OLESTR("CMTFSession::DoDataStream - End While\n"));

        // Finish off the unnamed datastream CRC stuff
        FINIALIZE_CRC(datastreamCRC);
        WsbTrace(OLESTR("CMTFSession::DoDataStream finalized CRC is <%lu>\n"), datastreamCRC);
        if (WSB_CRC_CALC_NONE != m_sHints.DatastreamCRCType)  {
            // We have a CRC that we want to save in the hints.
            m_sHints.DatastreamCRC.QuadPart = datastreamCRC;
        }

        IO_STATUS_BLOCK             IoStatusBlock;
        NTSTATUS                    ccode;

        // ** NT System Call - set file information
        // This call fixes the access time that can be changed by the BackupRead call above
        // When BackupRead is fixed this line should be removed.  RAID 121023.
        //
        // IMPORTANT NOTE:  This changes the USN, and must be done before we save the USN.
        //
        // TODO:  See if we still need this
        HRESULT infoHr = S_OK;
        try {
            WsbAffirmNtStatus(ccode = NtSetInformationFile( hStream, &IoStatusBlock, (PVOID)&m_SaveBasicInformation,
                                sizeof( m_SaveBasicInformation ), FileBasicInformation));
        } WsbCatch(infoHr);

        // Get the USN of the file before we close it
        //
        // Before we close the file, get the USN
        //
        LONGLONG lUsn;
        if (S_OK == WsbGetUsnFromFileHandle(hStream, TRUE, &lUsn)) {
            m_sHints.FileUSN.QuadPart = lUsn;
        } else  {
            // If we can't get the USN, then just set it to 0
            // which is invalid.  Don't stop things.
            m_sHints.FileUSN.QuadPart = 0;
        }

        // Now, were done with all of the streams.  If there is data left
        // in the buffer, we need to pad out to the next alignment block boundary and
        // flush the buffer.

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        if (m_bCommitFile) {

            WsbTrace(OLESTR("CMTFSession::DoDataStream - Commit\n"));

            // Pad and Flush to next physical block
            WsbAffirmHr(PadToNextPBA());

            // Now flush the device buffer.
            WsbAffirmNoError(WriteFilemarks(0));

        }
        else {

            // Pad and Flush to next format logical block
            WsbAffirmHr(PadToNextFLA(TRUE));

        }

        // Make sure we are aligned with a FLA (i.e. the last DBLK/stream was properly padded).
        WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);

        fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        WsbTrace(OLESTR("CMTFSession::DoDataStream - End: FLA = %I64u\n"), fla);\

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::DoDataStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoEndOfDataSet(
    IN USHORT nDataSetNumber)
/*++

Routine Description:

    Formats and Writes an ESET DBLK.  The end of data set sequence
    starts with a filemark (which terminates the file data), followed
    by an ESET, then a final filemark.

Arguments:

    nDataSetNumber - The data set number.  Used only in error recover. Otherwise
                     The original data set number is used.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::DoEndOfDataSet"), OLESTR("<%d>"), nDataSetNumber);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoEndOfDataSet.0");

        WsbAssertPointer(m_pBuffer);

        MTF_DBLK_ESET_INFO  sESET;    // **MTF API STRUCT ** -- info for ESET
        size_t              nMoreBufUsed;

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);

        //
        // We can enter this routine in error recovery mode if
        // we need to write out an ESET at the end of a previously
        // written data set.  In this case the Initialization flag 
        // will be FALSE.
        //
        if (! m_bSetInitialized) {

            // This block of code is special to error recovery.

            (void) InitCommonHeader();

            // Since we use the Init SSET block to retrieve ESET info
            // we need to initialize it.

            // **MTF API CALL**
            m_pMTFApi->MTF_SetSSETDefaults(&m_sSetInfo);

            // Reset the set attributes and DataSetNumber.
            m_sSetInfo.uSSETAttributes = 0;  // TODO: This should match the original set attribute
            m_sSetInfo.uDataSetNumber  = nDataSetNumber;

            // Can't be anyting in the buffer if we are only writing
            // out the ESET.
            WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        }

        if (m_nBufUsed > 0) {
            // Write out an ESPB if we have something in the buffer.  This conditional covers
            // the error recovery case where a missing ESET is detected.  In this case we
            // don't have enough info to write an ESBP, and were already on a physical block
            // boundary, so we skip the ESPB.

            // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
            // It won't be if we are having problems writing to tape.
            WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
            UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
            UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
            WsbTrace(OLESTR("Writing End of Set Pad (ESPB) @ FLA %I64u (%I64u, %I64u)\n"),
                fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

            // TODO:  Not sure all the error cases are handled, here.  What if we
            //        end the set before completing the last I/O transfer.  May need
            //        to add code to write out CFIL.

            // Increment the BlockId and alignment index values that we keep in 
            // our common block header structure.
            m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
            m_sHeaderInfo.uFormatLogicalAddress = fla;

            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            // **MTF API CALL**
            // Write ESPB to pad the backup set to a phyical block boundary.
            nMoreBufUsed = 0;
            WsbAssertNoError(m_pMTFApi->MTF_WriteESPBDblk(&m_sHeaderInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
            m_nBufUsed += nMoreBufUsed;

            // Write out the ESPB DBLK and SPAD.
            WsbAffirmHr(PadToNextPBA());
        }

        // Write a filemark to begin the end of data set sequence.  This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

        // **MTF API CALL**
        // First set defaults for the info struct
        m_pMTFApi->MTF_SetESETDefaults(&sESET);

        sESET.uESETAttributes = m_sSetInfo.uSSETAttributes;
        sESET.uDataSetNumber  = m_sSetInfo.uDataSetNumber;

        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        UINT64 curPos = 0;
        WsbAffirmHr(GetCurrentPBA(&curPos));  // From the stream I/O model
        WsbTrace(OLESTR("Writing End of Set (ESET) @ PBA %I64u\n"), curPos);

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_SSET_INFO structs to
        // this function.  The result is an MTF formatted SSET DBLK in m_pBuffer.

        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteESETDblk(&m_sHeaderInfo, &sESET, m_pBuffer, m_nBufSize, &m_nBufUsed));

        // Write out the ESET DBLK and SPAD.
        WsbAffirmHr(PadToNextPBA());

        // NOTE: The PadToNextPBA() is a placeholder.
        //       The On Media Catalog would be generated and written after the ESET DBLK and SPAD.
        //       If we ever implement a catalog, we need to change the previous PadToNextPBA() to
        //       PadToNextPLA();

        // Write a filemark. This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CMTFSession::ExtendLastPadToNextPBA(void)
/*++

Routine Description:

    Re-writes the last SPAD in the transfer buffer to align with
    the next physical block boundary.  This routine shoud only be
    used before flushing the device buffer to guarantee data is written
    to the physical device.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

Comments:

      !!! Not for CMTFSession internal use !!!

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::ExtendLastPadToNextPBA"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CMTFSession::ExtendLastPadToNextPBA.0");

        WsbAssertPointer(m_pBuffer);

        //
        // The start of the SPAD could be in last part of a previous
        // block that was flushed.  In this case the transfer buffer
        // contains the remaning portion of the SPAD, and the
        // SPAD cannot be extended so we simply return.
        //
        // If we hit EOM while in the middle of a file transfer, the
        // last thing in the transfer buffer won't be a SPAD.  No SPAD
        // is indicated by m_nStartOfPad == 0.
        //

        if ((m_nBufUsed > 0) && (m_nStartOfPad > 0) && (m_nStartOfPad < m_nBufUsed)) {
            MTF_STREAM_INFO sSTREAM;

            // Verify that there's an SPAD within the valid part of the buffer.
            // Make sure our last pad pointer is at an SPAD.
            WsbAffirmNoError(m_pMTFApi->MTF_ReadStreamHeader(&sSTREAM, &m_pBuffer[m_nStartOfPad]));

            WsbAssert((0 == memcmp(sSTREAM.acStreamId, "SPAD", 4)), MVR_E_LOGIC_ERROR);

            // Now, make sure we aren't going to overwrite anything other than a trailing SPAD.
            WsbAssert(m_nBufUsed == (m_nStartOfPad + sizeof(MTF_STREAM_INFO) + sSTREAM.uStreamLength), MVR_E_LOGIC_ERROR);

            // Reset the amount of buffer used to the start of the current SPAD
            // in preparation for overwrite of SPAD to a physical block boundary.
            m_nBufUsed = m_nStartOfPad;

            WsbAffirmHr(PadToNextPBA());
        }

        // Flush the device buffer.
        WsbAffirmHr(WriteFilemarks(0));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::ExtendLastPadToNextPBA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

/***

Note:
    "Skip" methods used for Recovery assume that you may read FLA size blocks 
    rather than PBA size block. Therefore, they muse be used only for files opened
    without the FILE_FLAG_NO_BUFFERING flag.
    If we come to the point where we must read only sector-size blocks, then some
    of this code should be enhanced!

***/

HRESULT
CMTFSession::SkipOverTapeDblk(void)
/*++

Routine Description:
    
    Skips over a TAPE DBLK and the following FILEMARK. 
    Expects to find a full or partial TAPE DBLK but no other data.

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::SkipOverTapeDblk"), OLESTR(""));

    try {
        ULONG bytesRead = 0;
        ULONG bytesToRead = m_nBlockSize;
        UINT64  fileMarkPos;

        // Read TAPE DBLK
        WsbAffirmHr(SetCurrentPBA(0));
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_TAPE, 4), MVR_E_UNKNOWN_MEDIA);

        // Next block should be a FILEMARK
        WsbAffirmHr(GetCurrentPBA(&fileMarkPos));
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Keep Soft File Marks array updated
        if (TRUE == m_bUseSoftFilemarks) {
            m_pMTFApi->MTF_InsertSoftFilemark(m_pSoftFilemarks, (UINT32)fileMarkPos);
        }

     } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::SkipOverTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverSSETDblk(OUT USHORT* pDataSetNumber)
/*++

Routine Description:
    
    Skips over a SSET DBLK 
    Expects to find a full or partial SSET DBLK but no other data.

Arguments:

    pDataSetNumber - Data set number taken from the skipped block

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverSSETDblk"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;

        LARGE_INTEGER zero = {0,0};

        m_nFormatLogicalAddress = 0;

        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read SSET DBLK
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block and get set number
        MTF_DBLK_HDR_INFO sHdrInfo;
        MTF_DBLK_SSET_INFO sSsetInfo;
        m_pMTFApi->MTF_ReadSSETDblk(&sHdrInfo, &sSsetInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SSET, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
        *pDataSetNumber = m_sSetInfo.uDataSetNumber;

        // Skip over rest of the block
        WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
        m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        );


    WsbTraceOut(OLESTR("CMTFSession::SkipOverSSETDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipToDataSet(void)
/*++

Routine Description:
    
    Skips to the beginning of the next FILE DBLK 
    Expects to find 0 to n other blocks such as DIRB DBLK.
    In case of a partial last block, stream pointer is set to the beginning of the partial block

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_S_SETMARK_DETECTED - No more data sets (i.e. end-of-data-set detected)
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};
    BOOL bIdRead = FALSE;

    WsbTraceIn(OLESTR("CMTFSession::SkipToDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;
        LARGE_INTEGER zero = {0,0};

        while (TRUE) {
            bIdRead = FALSE;

            // keep current position, before block starts
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

            // Read block header
            WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
            if (bytesRead < bytesToRead) {
                // incomplete block
                WsbThrow(MVR_E_NOT_FOUND);
            }

            // Check block
            MTF_DBLK_HDR_INFO sHdrInfo;
            m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);

            m_nFormatLogicalAddress = sHdrInfo.uFormatLogicalAddress;
            m_nCurrentBlockId = sHdrInfo.uControlBlockId + 1;
            bIdRead = TRUE;

            if ((0 == memcmp(sHdrInfo.acBlockType, MTF_ID_VOLB, 4)) ||
                (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_DIRB, 4))) {
                // Just skip following streams
                WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

                WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
                m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_FILE, 4)) {
                WsbAffirmHr(m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL));
                break;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4)) {
                // end of data-set reached, no ESPB block, must be alligned with PBA
                WsbAffirmHr(m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL));
                WsbAssert(0 == (startBlockPosition.QuadPart % m_nBlockSize), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
                hr = MVR_S_SETMARK_DETECTED;
                break;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_ESPB, 4)) {
                // last block in data-set found. Make sure it is complete
                WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

                WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
                WsbAssert(0 == (currentBlockPosition.QuadPart % m_nBlockSize), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
                m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

                hr = MVR_S_SETMARK_DETECTED;
                break;

            } else {
                // unexpected data
                WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT);
            }
        }

    } WsbCatchAndDo(hr,
        // Seek back to the end of the last complete & valid block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        if (bIdRead) {
            m_nCurrentBlockId--;
        }
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipToDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverDataSet(void)
/*++

Routine Description:
    
    Skips over one FILE DBLK, including all of its data streams
    Expects to find a FILE DBLK.
    In case of a partial block, stream pointer is set back to the beginning of the block

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;
        LARGE_INTEGER zero = {0,0};

        // keep current position, before block starts
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read block header
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);

        if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_FILE, 4)) {
            WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
            m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;
        } else {
            // unexpected data
            WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT);
        }

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nCurrentBlockId--;
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipOverDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverEndOfDataSet(void)
/*++

Routine Description:
    
    Skips over one the sequence FILEMARK + ESET DBLK + FILEMARK
    Expects to find a FILE MARK, even if ESPB exists, it should have been already skipped.
    In case of a partial sequence, stream pointer is set back to the beginning of the sequence

Arguments:

    None.

Return Value:

    S_OK        -  Success. (It really means that the file is valid & complete)
    MVR_E_NOT_FOUND - Sequence is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    UINT64 nFormatLogicalAddress = m_nFormatLogicalAddress;

    WsbTraceIn(OLESTR("CMTFSession::SkipOverEndOfDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = m_nBlockSize;

        LARGE_INTEGER zero = {0,0};

        // keep current position, before block starts
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read block header
        m_nFormatLogicalAddress = startBlockPosition.QuadPart / uAlignmentFactor;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a FILE MARK
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Read next block
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a ESET DBLK
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_ESET, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Read next block
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a FILEMARK
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nFormatLogicalAddress = nFormatLogicalAddress;
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipOverEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::PrepareForEndOfDataSet(void)
/*++

Routine Description:
    
    Write an ESPB block in case that last complete fla is NOT aligned with pba
    File position should be aligned with pba after the method ends

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER zero = {0,0};
    UINT64 nRemainder;
    UINT64 nFormatLogicalAddress = m_nFormatLogicalAddress;

    WsbTraceIn(OLESTR("CMTFSession::PrepareForEndOfDataSet"), OLESTR(""));

    try {
        // ESPB block should be written only if:
        //  1. Physical Block size is larger than MTF Logical Block size
        //  2. Current location is not aligned with pba (it already must be aligned with fla)
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        if (m_nBlockSize != uAlignmentFactor) {
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));
            nRemainder = startBlockPosition.QuadPart % m_nBlockSize;
            if (0 != nRemainder) {
                size_t nSizeUsed = 0;
                size_t nBufUsed = 0;

                ULONG bytesWritten = 0;
                ULONG bytesToWrite;

                WsbTrace(OLESTR("Writing ESPB for Recovery, completing a remainder of %I64u bytes (%I64u fla) to pba\n"),
                    nRemainder, (nRemainder / uAlignmentFactor));

                (void) InitCommonHeader();
                m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                m_sHeaderInfo.uFormatLogicalAddress = m_nFormatLogicalAddress;

                // **MTF API CALL**
                WsbAssertNoError(m_pMTFApi->MTF_WriteESPBDblk(&m_sHeaderInfo, m_pBuffer+m_nBufUsed, m_nBufSize, &nSizeUsed));
                WsbAssertNoError(m_pMTFApi->MTF_PadToNextPhysicalBlockBoundary(m_pBuffer, m_nBlockSize, nSizeUsed, m_nBufSize, &nBufUsed));

                // Write data and flush
                bytesToWrite = (ULONG)(m_nBlockSize - nRemainder);
                WsbAffirmHr(m_pStream->Write(m_pBuffer, bytesToWrite, &bytesWritten));
                WsbAffirm((bytesWritten == bytesToWrite), E_FAIL);
                WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers
                m_nFormatLogicalAddress += bytesWritten / uAlignmentFactor;
            }
        }

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nCurrentBlockId--;
        );

    WsbTraceOut(OLESTR("CMTFSession::PrepareForEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT 
CMTFSession::SkipOverStreams(IN UINT64 uOffsetToFirstStream)
/*++

Routine Description:
    
    Skips over all streams of current block
    Expects to find a SPAD stream as the last one (if data is not truncated)

Arguments:

    uOffsetToFirstStream - Offset to the beginning of the first stream (absolute position)

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Stream is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startStreamPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverStreams"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = (ULONG)sizeof(MTF_STREAM_INFO);

        UINT64   uStreamLength;
        LARGE_INTEGER skipToPosition = {0,0};
        LARGE_INTEGER endPosition = {0,0};
        LARGE_INTEGER zero = {0,0};

        BOOL bMoreStreams = TRUE;

        // Keep end position
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_END, (ULARGE_INTEGER *)&endPosition));

        // Seek to begining of first stream
        skipToPosition.QuadPart = uOffsetToFirstStream;
        WsbAffirmHr(m_pStream->Seek(skipToPosition, STREAM_SEEK_SET, NULL));

        while (bMoreStreams) {
            // keep current position, before stream starts
            startStreamPosition.QuadPart = skipToPosition.QuadPart;

            // Read stream header
            WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
            if (bytesRead < bytesToRead) {
                // incomplete stream
                WsbThrow(MVR_E_NOT_FOUND);
            }

            MTF_STREAM_INFO sHdrInfo;
            m_pMTFApi->MTF_ReadStreamHeader(&sHdrInfo, m_pBuffer);

            if (0 == memcmp(sHdrInfo.acStreamId, MTF_PAD_STREAM, 4)) {
                bMoreStreams = FALSE;
            }

            // Skip to the next stream
            uStreamLength = sHdrInfo.uStreamLength + sizeof(MTF_STREAM_INFO);
            if (uStreamLength % 4) {
                uStreamLength = uStreamLength - (uStreamLength % 4) + 4;
            }
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&skipToPosition));
            skipToPosition.QuadPart = skipToPosition.QuadPart + uStreamLength - bytesToRead;
            if (skipToPosition.QuadPart > endPosition.QuadPart) {
                // incomplete block
                WsbThrow(MVR_E_NOT_FOUND);
            }
            WsbAffirmHr(m_pStream->Seek(skipToPosition, STREAM_SEEK_SET, NULL));
        }

        // If we got here, SPAD was found and skipped hence we must be FLA alligned
        WsbAssert(0 == (skipToPosition.QuadPart % uAlignmentFactor), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

    } WsbCatchAndDo(hr,
        // Seek back to the end of the last complete & valid stream
        (void) m_pStream->Seek(startStreamPosition, STREAM_SEEK_SET, NULL);
        );


    WsbTraceOut(OLESTR("CMTFSession::SkipOverStreams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::PadToNextPBA(void)
/*++

Routine Description:

    Writes an SPAD to the transfer buffer upto the next physical block boundary.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::PadToNextPBA"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CMTFSession::PadToNextPBA.0");

        WsbAssertPointer(m_pBuffer);

        // **MTF API CALL **
        // Write an SPAD out to the next physical block boundary.
        WsbAssertNoError(m_pMTFApi->MTF_PadToNextPhysicalBlockBoundary(m_pBuffer, m_nBlockSize, m_nBufUsed, m_nBufSize, &m_nBufUsed));

        // At this point our buffer should be padded out to
        // the next physical block boundary, which means it is
        // ready to be written in its entirety to the target
        // media.

        // Write out the data and SPAD stream.
        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // Everything in the buffer should be written out when
        // the buffer is aligned on a physical block boundary.
        WsbAssert(0 == m_nBufUsed, E_UNEXPECTED);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::PadToNextPBA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::PadToNextFLA(
    BOOL flush)
/*++

Routine Description:

    Writes an SPAD to the transfer buffer upto format logical block boundary.

Arguments:

    flush - if TRUE, the transfer buffer is flushed.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::PadToNextFLA"), OLESTR("<%ls>"), WsbBoolAsString(flush));

    try {
        MvrInjectError(L"Inject.CMTFSession::PadToNextFLA.0");

        WsbAssertPointer(m_pBuffer);

        size_t startOfPad;

        // **MTF API CALL **
        // Write an SPAD out to the next alignment block boundary.
        startOfPad = m_nBufUsed;
        WsbAssertNoError(m_pMTFApi->MTF_PadToNextAlignmentFactor(m_pBuffer, m_nBufUsed, m_nBufSize, &m_nBufUsed));

        if (flush) {
            // Write out data and SPAD stream.
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
        }

        // Reset the location of the last SPAD within the buffer.
        // Note:  The value is only valid of m_nStartOfPad < m_nBufUsed.
        m_nStartOfPad = (m_nBufUsed > 0) ? startOfPad % m_nBlockSize : 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::PadToNextFLA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::WriteToDataSet(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.
    Format Logical Address is updated to the current offset.

Arguments:

    pBuffer         -  Data buffer.
    nBytesToWrite   -  number of bytes to write in buffer.
    pBytesWritten   -  Bytes written.

Return Value:

    S_OK            -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        MvrInjectError(L"Inject.CMTFSession::WriteToDataSet.0");
        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pBuffer);
        WsbAssertPointer(pBytesWritten);

        *pBytesWritten = 0;

        // Make sure that we are asked to write only full blocks
        WsbAssert(!(nBytesToWrite % m_nBlockSize), MVR_E_LOGIC_ERROR);

        try {
            WsbAffirmHr(m_pStream->Write(pBuffer, nBytesToWrite, pBytesWritten));
        } WsbCatch(hr);

        // Making sure that we are writing only full blocks
        if (*pBytesWritten != nBytesToWrite) {
            WsbTraceAlways(OLESTR("Asked to write %lu bytes but wrote only %lu bytes. Write hr = <%ls>\n"),
                nBytesToWrite, *pBytesWritten, WsbHrAsString(hr));
            if (SUCCEEDED(hr)) {
                // Write "succeeded" buy didn't write all the bytes (full disk scenario):
                //  Shouldn't happen since caller is expected to verify that there's enough free space in advance.
                hr = E_FAIL;
            }
        }

        // Update the total number of alignment factors
        m_nFormatLogicalAddress += *pBytesWritten / (m_pMTFApi->MTF_GetAlignmentFactor());

    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::ReadFromDataSet (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.
    Format Logical Address is updated to the current offset.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        MvrInjectError(L"Inject.CMTFSession::ReadFromDataSet.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pBuffer);
        WsbAssertPointer(pBytesRead);

        // We need to set hr.  MVR_S_FILEMARK_DETECTED, MVR_S_SETMARK_DETECTED are Okay.
        hr = m_pStream->Read(pBuffer, nBytesToRead, pBytesRead);

        // update the total number of alignment factors
        m_nFormatLogicalAddress += *pBytesRead / (m_pMTFApi->MTF_GetAlignmentFactor());

        // Now test hr
        WsbAffirmHr(hr);

        // Make sure that we read only full blocks
        WsbAssert(!(*pBytesRead % m_nBlockSize), MVR_E_LOGIC_ERROR);


    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::FlushBuffer(
    IN BYTE *pBuffer,
    IN OUT size_t *pBufPosition)
/*++

Routine Description:

    Writes as much of the buffer as possible out to the device.
    Any remaining data not written out is moved to the front of
    the buffer, and *pBufPosition is updated accordingly

Arguments:

    pBuffer      -  Data buffer.
    pBufPosition -  Number of bytes to write in buffer.  On output
                    holds the number of bytes still in the buffer.

Return Value:

    S_OK         -  Success.

--*/
{
    HRESULT hr = S_OK;

    ULONG   uPosition = (ULONG)(*pBufPosition);

    try {
        MvrInjectError(L"Inject.CMTFSession::FlushBuffer.0");

        // If the buffer has more than a physical block of bytes in it, dump as many as
        // possible to the device, then move the remaining data to the head of the buffer
        if (uPosition >= m_nBlockSize) {
            ULONG nBlocksToWrite;
            ULONG nBytesWritten = 0;

            // Determine the number of physical blocks to write
            nBlocksToWrite = uPosition / m_nBlockSize;

            try {
                // Write the data to the data set
                WsbAffirmHr(WriteToDataSet(pBuffer, nBlocksToWrite * m_nBlockSize, &nBytesWritten));
            } WsbCatch(hr);

            // Adjust the buffer position and slide the unwritten data down in the buffer
            WsbAssert(uPosition >= nBytesWritten, E_UNEXPECTED);
            uPosition -= nBytesWritten;
            memmove(pBuffer, pBuffer + nBytesWritten, uPosition);

            // Invalidate the pad start location after any flush.  This is reset in PadToNextFLA().
            m_nStartOfPad = 0;

        }

    } WsbCatch(hr);

    // Set output
    *pBufPosition = (size_t)uPosition;

    return hr;
}


HRESULT
CMTFSession::WriteFilemarks(
    IN ULONG nCount)
/*++

Routine Description:

    Writes count filemarks at the current location.

Arguments:

    nCount       -  Number of Filemarks to write.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::WriteFilemarks"), OLESTR("<%u>"), nCount);

    try {
        MvrInjectError(L"Inject.CMTFSession::WriteFilemarks.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(m_pBuffer);

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        if ( nCount > 0) {
            // Can't write a filemark with data still in the transfer buffer if nCount > 0!
            WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);

            UINT64 pba = 0;
            UINT64 curPos = 0;
            WsbAffirmHr(GetCurrentPBA(&curPos));  // From the stream I/O model

            if ( m_nPhysicalBlockAddress > 0 ) {
                // Make sure the FLA aligns with a PBA!
                WsbAssert(0 == (m_nFormatLogicalAddress*uAlignmentFactor) % m_nBlockSize, MVR_E_LOGIC_ERROR);

                // Provided there's nothing in the transfer buffer, this is an accurate calc.
                pba = m_nPhysicalBlockAddress + ((m_nFormatLogicalAddress*uAlignmentFactor)/m_nBlockSize);

                // Make sure we are where we think we are.
                WsbAssert(curPos == pba, MVR_E_LOGIC_ERROR);
            }
            else {

                //
                // We skip the consistency check for the case were we're writing filemarks
                // through the session model and m_nPhysicalBlockAddress is uninitialzed.
                // This happens we we are writing an ESET sequence in dataset recovery code.
                // 

                pba = curPos;

            }

            if (TRUE == m_bUseSoftFilemarks) {
                LONG n = nCount;

                if (n > 0) {
                    UINT32 pba32 = (UINT32) pba;

                    // Soft Filemark support only handles 2^32 * 1 KByte media (16 TBytes using 1 KByte logical Blocks)
                    // Some day this won't be enough... and we'll know!
                    WsbAssert((UINT64)pba32 == pba, E_UNEXPECTED);

                    // One last check... Can't write out more filemarks, at one time, than can be stored in
                    // the filemark table.
                    WsbAssert(nCount < m_pSoftFilemarks->uNumberOfFilemarkEntries, E_UNEXPECTED);

                    while(n-- > 0) {
                        // **MTF API CALL**
                        m_pMTFApi->MTF_InsertSoftFilemark(m_pSoftFilemarks, pba32++);
                        // **MTF API CALL**
                        WsbAssertNoError(m_pMTFApi->MTF_WriteSFMBDblk(&m_sHeaderInfo, m_pSoftFilemarks, m_pBuffer, m_nBufSize, &m_nBufUsed));

                        // Write out the SFMB DBLK.
                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        // Everything should be written to media after a filemark!
                        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);

                        // PBA counter should never roll over!
                        WsbAssert(pba32 > 0, E_UNEXPECTED);
                    };

                }

                WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers

                // NOTE:  The total number of alignment factors is updated via FlushBuffer(),
                //        so we don't need to do it here.

            }
            else {
                // We use the IStream::Commit interface to write out the filemark.
                // This is not a perfect match in that the nCount parameter is supposed to
                // be a commit flag, not filemark count. Zero flushes device buffers
                // without writing a filemark. 
                WsbAffirmHr(m_pStream->Commit(nCount));

                // update the total number of alignment factors
                m_nFormatLogicalAddress += (nCount * m_nBlockSize) / uAlignmentFactor;
            }
        }
        else {
            // 0 == nCount implies flush device buffers.
            //
            // We skip all consistency checks since it is
            // is always safe to flush device buffers.
            //
            WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::WriteFilemarks"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::GetCurrentPBA(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::GetCurrentPBA"), OLESTR(""));

    ULARGE_INTEGER position = {0xffffffff,0xffffffff};

    try {
        MvrInjectError(L"Inject.CMTFSession::GetCurrentPBA.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pPosition);

        LARGE_INTEGER zero = {0,0};

        // Gets the current position.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, &position));

        position.QuadPart = position.QuadPart / m_nBlockSize;
        *pPosition = position.QuadPart;


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::GetCurrentPBA"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), position);

    return hr;
}


HRESULT
CMTFSession::SetCurrentPBA(
    IN UINT64 position)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SetCurrentPBA"), OLESTR("<%I64u>"), position);

    try {
        WsbAssertPointer(m_pStream);

        LARGE_INTEGER seekTo;
        seekTo.QuadPart = position * m_nBlockSize;

        // Move to the specified position.
        WsbAffirmHr(m_pStream->Seek(seekTo, STREAM_SEEK_SET, NULL));

        m_nPhysicalBlockAddress = position;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SetCurrentPBA"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), m_nPhysicalBlockAddress);

    return hr;
}


HRESULT
CMTFSession::SpaceToEOD(void)
/*++

Routine Description:

    Positions the media to the end of data of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SpaceToEOD"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        MvrInjectError(L"Inject.CMTFSession::SpaceToEOD.0");

        WsbAssertPointer(m_pStream);

        LARGE_INTEGER zero = {0,0};

        // Sets the current position to the end of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_END, NULL));

        WsbAffirmHr(GetCurrentPBA(&curPos));

        m_nPhysicalBlockAddress = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SpaceToEOD"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CMTFSession::SpaceToBOD(void)
/*++

Routine Description:

    Posotions the media to the beginnning of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SpaceToBOD"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        MvrInjectError(L"Inject.CMTFSession::SpaceToBOD.0");

        WsbAssertPointer(m_pStream);

        LARGE_INTEGER zero = {0,0};

        // Sets the current position to the beginning of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_SET, NULL));

        WsbAffirmHr(GetCurrentPBA(&curPos));

        m_nPhysicalBlockAddress = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SpaceToBOD"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}

HRESULT
CMTFSession::ReadTapeDblk(OUT WCHAR **pszLabel)
/*++

Routine Description:
    
    Skips over a SSET DBLK 
    Expects to find a full or partial SSET DBLK but no other data.

Arguments:

    pszLabel - Pointer to a buffer to hold the RSS tape label.
               Reallocated as necessary

Return Value:

    S_OK        -  Success.
    MVR_E_UNKNOWN_MEDIA - No TAPE DBLK or not RSS TAPE

--*/
{
    HRESULT hr = S_OK;
    ULONG bytesRead = 0;

    WsbTraceIn(OLESTR("CMTFSession::ReadTapeDblk"), OLESTR(""));

    try {
        ULARGE_INTEGER position = {0,0};
        LARGE_INTEGER zero = {0,0};

        // The MTF labels are < 1024 bytes.  We need to read 1024 bytes + the filemark
        // (1 block), 3x the min block size covers all cases.
        // The MTFSession work buffer is at least 2 blocks
        ULONG nBlocks = (3*512)/m_nBlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;

        ULONG bytesToRead = nBlocks * m_nBlockSize;
        WsbAssertPointer(m_pBuffer);
        memset(m_pBuffer, 0, bytesToRead);

        // Sets the current position to the beginning of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_SET, &position));

        // Read upto first Filemark.
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));

        MTF_DBLK_HDR_INFO sHdrInfo;
        MTF_DBLK_TAPE_INFO sTapeInfo;
        m_pMTFApi->MTF_ReadTAPEDblk(&sHdrInfo, &sTapeInfo, m_pBuffer);

        // Is this a MTF Tape?
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_TAPE, 4), MVR_E_UNKNOWN_MEDIA);

        // Now try to identify it as one of ours,
        // using the following criteria:
        //   1) It has a UNICODE tape name and tape description and software name.
        //   2) It has our Vendor Id (accept both old Win2K id and current id).
        WsbAffirm(sHdrInfo.uStringType == MTF_STRING_UNICODE_STR, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szTapeName, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szTapeDescription, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szSoftwareName, MVR_E_UNKNOWN_MEDIA);

        WsbAffirm((REMOTE_STORAGE_MTF_VENDOR_ID == sTapeInfo.uSoftwareVendorId) ||
                  (REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID == sTapeInfo.uSoftwareVendorId), 
                  MVR_E_UNKNOWN_MEDIA);

        CWsbStringPtr label = sTapeInfo.szTapeDescription;
        *pszLabel = NULL;
        WsbAffirmHr(label.CopyTo(pszLabel));

    } WsbCatchAndDo(hr,
        // Trace the illegal buffer where the RSS TAPE DBLK should reside
        if (m_pBuffer) {
            WsbTraceBuffer(bytesRead, m_pBuffer);
        }
    );

    WsbTraceOut(OLESTR("CMTFSession::ReadTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtfsessn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MTFSessn.h

Abstract:

    Definition of the CMTFSession class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(MTFSessn_H)
#define MTFSessn_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "mtfapi.h"

//
// REMOTE_STORAGE_MTF_VENDOR_ID       - This is the unique vendor Id assigned for Microsoft Remote Storage.
//                                      Used in Whistler (NT 5.1) and beyond
//
// REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID - This is the unique vendor Id assigned
//                                      to Eastman Software (Spring, 1997), by Seagate.
//                                      Used in Win2K (NT 5.0) Remote Storage
//

#define REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID      0x1300
#define REMOTE_STORAGE_MTF_VENDOR_ID            0x1515 

//
// REMOTE_STORAGE_MTF_VENDOR_NAME -- This is the vendor name used for MTF labels.
//

#define REMOTE_STORAGE_MTF_VENDOR_NAME  OLESTR("Microsoft Corporation")


//
// REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ -- This the the major version number
//                                           for Remote Storage
//

#define REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ   1

//
// REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN -- This the the minor version number
//                                           for Remote Storage
//
#define REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN   0

/*++

Enumeration Name:

    MTFSessionType

Description:

    Specifies a type of data set.

--*/
typedef enum MTFSessionType {
    MTFSessionTypeTransfer = 0,
    MTFSessionTypeCopy,
    MTFSessionTypeNormal,
    MTFSessionTypeDifferential,
    MTFSessionTypeIncremental,
    MTFSessionTypeDaily,
};

//
//  MVR_DEBUG_OUTPUT - Special flag used for outputing extra debug info
//

#ifdef DBG
#define MVR_DEBUG_OUTPUT TRUE
#else
#define MVR_DEBUG_OUTPUT FALSE
#endif

//
//  MrvInjectError - Special macro for allowing test running to inject
//                   device errors at specific location throughout the
//                   data mover.
//
/*++

Macro Name:

    MrvInjectError

Macro Description:

    Special macro for allowing test running to inject device errors
    at specific location throughout the data mover.

Arguments:

    injectPoint - A UNICODE string describing the injection point.

--*/

#ifdef DBG
#define MvrInjectError(injectPoint)                 \
    {                                               \
        DWORD size;                                 \
        OLECHAR tmpString[256];                     \
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, injectPoint, tmpString, 256, &size))) { \
            DWORD injectHr;                         \
            injectHr = wcstoul(tmpString, NULL, 16); \
            if (injectHr) {                         \
                WsbTrace(OLESTR("%ls - Injecting Error <%ls>\n"), injectPoint, WsbHrAsString(injectHr)); \
                if (IDOK == MessageBox(NULL, L"Inject error, then press OK.  Cancel skips over this injection point.", injectPoint, MB_OKCANCEL)) { \
                    if (injectHr != S_FALSE) {      \
                        WsbThrow(injectHr);         \
                    }                               \
                }                                   \
            }                                       \
        }                                           \
    }
#else
#define MvrInjectError(injectPoint)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMTFSession

class CMTFSession
{
public:
    CMTFSession();
    ~CMTFSession();

    // TODO:  Add SetStream() for m_pStream, and replace m_sHints with object that supports IRemoteStorageHint

    CComPtr<IStream>        m_pStream;          // Stream used for I/O.
    MVR_REMOTESTORAGE_HINTS m_sHints;           // We keep the information need for
                                                //  optimized retrieval of the file/data.

    HRESULT SetBlockSize(UINT32 blockSize);
    HRESULT SetUseFlatFileStructure(BOOL val);
    HRESULT SetUseSoftFilemarks(BOOL val);
    HRESULT SetUseCaseSensitiveSearch(BOOL val);
    HRESULT SetCommitFile(BOOL val);

    // MTF Formatting methods
    HRESULT InitCommonHeader(void);
    HRESULT DoTapeDblk(IN WCHAR* szLabel, IN ULONG maxIdSize, IN OUT BYTE* pIdentifier, IN OUT ULONG* pIdSize, IN OUT ULONG* pIdType);
    HRESULT DoSSETDblk(IN WCHAR* szSessionName, IN WCHAR* szSessionDescription, IN MTFSessionType type, IN USHORT nDataSetNumber);
    HRESULT DoVolumeDblk(IN WCHAR* szPath);
    HRESULT DoDataSet(IN WCHAR* szPath);
    HRESULT DoParentDirectories(IN WCHAR* szPath);
    HRESULT DoDirectoryDblk(IN WCHAR* szPath, IN WIN32_FIND_DATAW* pFindData);
    HRESULT DoFileDblk(IN WCHAR* szPath, IN WIN32_FIND_DATAW* pFindData);
    HRESULT DoDataStream(IN HANDLE hStream);
    HRESULT DoEndOfDataSet(IN USHORT nDataSetNumber);
    HRESULT ExtendLastPadToNextPBA(void);

    // Read methods
    HRESULT ReadTapeDblk(OUT WCHAR **pszLabel);

    // Validate methods (for Recovery usage)
    HRESULT SkipOverTapeDblk(void);
    HRESULT SkipOverSSETDblk(OUT USHORT* pDataSetNumber);
    HRESULT SkipToDataSet(void);
    HRESULT SkipOverDataSet(void);
    HRESULT SkipOverEndOfDataSet(void);
    HRESULT PrepareForEndOfDataSet(void);

private:
    HRESULT PadToNextPBA(void);
    HRESULT PadToNextFLA(BOOL flush);

    // For Recovery usage
    HRESULT SkipOverStreams(IN UINT64 uOffsetToFirstStream);

private:

    enum {                                      // Class specific constants:
                                                //
        Version = 1,                            // Class version, this should be
                                                //   incremented each time the
                                                //   the class definition changes.
    };
    // Session data
    UINT32              m_nCurrentBlockId;      // Used for "control_block_id" in common header.
                                                //  We increment this for each dblk written.
    UINT32              m_nDirectoryId;         // Tracks the directory id used in DIRB and FILE
                                                // DBLKs.  We increment this for each directory 
                                                //  written.
    UINT32              m_nFileId;              // Tracks the file id used in FILE dblks.  We 
                                                //  increment this for each file written.
    UINT64              m_nFormatLogicalAddress;// We need to keep track of how many alignment
                                                //  indicies we are away from the SSET, as this
                                                //  info is used in the common block headers.
                                                //  We increment this for each alignment index
                                                //  written, including streams, to the device.
    UINT64              m_nPhysicalBlockAddress;// Hold onto the PBA of the beginning of the SSET.
    UINT32              m_nBlockSize;           // Physical Block Size of the media used.

    MTF_DBLK_SFMB_INFO* m_pSoftFilemarks;       // Holds Soft Filemark information.
    MTF_DBLK_HDR_INFO   m_sHeaderInfo;          // We keep one header info struct here,
                                                //  fill it in once, and then just make 
                                                //  changes as necessary as we supply it
                                                //  to MTF_Write... calls.
    MTF_DBLK_SSET_INFO  m_sSetInfo;             // We keep the data set info struct to handle
                                                //  special case DBLK formatting.
    MTF_DBLK_VOLB_INFO  m_sVolInfo;             // We keep the volume info struct to handle
                                                //  special case DBLK formatting.

    BYTE *              m_pBuffer;              // The buffer used to format data (with virtual address aligend to sectore size)
    BYTE *              m_pRealBuffer;          // The actual buffer
    size_t              m_nBufUsed;             // The number of bytes in the buffer with valid data.
    size_t              m_nBufSize;             // The size of the buffer.
    size_t              m_nStartOfPad;          // Holds the location within the transfer buffer
                                                //  of the last SPAD.

    BOOL                m_bUseFlatFileStructure;// If TRUE, Directory information is not written to
                                                //  the MTF session, and filenames are mangled
                                                //  to preserve uniqueness.
    BOOL                m_bUseSoftFilemarks;    // If TRUE, filemark emulation is turned on.
    BOOL                m_bUseCaseSensitiveSearch; // If TRUE, all filename queries are case sensitve (i.e. Posix Semantics)
    BOOL                m_bCommitFile;          // If TRUE, flushes devices buffers after file is
                                                //  written to the data set.
    BOOL                m_bSetInitialized;       // If TRUE, sSet was initialized (for detecting Recovery)

    FILE_BASIC_INFORMATION m_SaveBasicInformation;  // Basic info for last file/dir (see notes on CloseStream).
    void *              m_pvReadContext;        // Holds BackupRead context info.

    CMTFApi *           m_pMTFApi;              // Object that implements internal MTF details


    // MTF I/O abstracton methods
    HRESULT OpenStream(IN WCHAR* szPath, OUT HANDLE *pStreamHandle);
    HRESULT CloseStream(IN HANDLE hStream);

    HRESULT WriteToDataSet(IN BYTE* pBuffer, IN ULONG nBytesToWrite, OUT ULONG* pBytesWritten);
    HRESULT ReadFromDataSet(IN BYTE* pBuffer, IN ULONG nBytesToRead, OUT ULONG* pBytesRead);
    HRESULT FlushBuffer(IN BYTE* pBuffer, IN OUT size_t* pBufPosition);
    HRESULT WriteFilemarks(IN ULONG count);
    HRESULT GetCurrentPBA(OUT UINT64* pPosition);
    HRESULT SetCurrentPBA(IN UINT64 position);
    HRESULT SpaceToEOD(void);
    HRESULT SpaceToBOD(void);

};

#endif // !defined(MTFSessn_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mover.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mover.cpp

Abstract:

    Data Mover defines

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

// Mover.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for Mover.idl by adding the following 
//      files to the Outputs.
//          Mover_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Moverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Mover.h"
#include "dlldatax.h"

#include "NtTapeIo.h"
#include "NtFileIo.h"
#include "FilterIo.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CNtTapeIo, CNtTapeIo)
    OBJECT_ENTRY(CLSID_CNtFileIo, CNtFileIo)
    OBJECT_ENTRY(CLSID_CFilterIo, CFilterIo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtfapi.cpp ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.c
//
// DESCRIPTION :        mtf api implementation 
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________
// *****************************************************************************/

#include <assert.h>
#include <time.h>
#include <string.h>
#include <wchar.h>
#include <stralign.h>

#include "stdafx.h"
#include "mtfapi.h"

static USHORT iCountMTFa = 0;  // Count of existing objects
//
//  Constructor
//
CMTFApi::CMTFApi(void)
{
    m_uAlignmentFactor = 0;

    m_iNumStrings = 0;
    for (int i = 0; i < iNUMSTRINGS; ++i){
        m_aszStrings[i] = 0;
    }

    iCountMTFa++;
}

//
// Destructor
//
CMTFApi::~CMTFApi()
{
    ClearStrings();

    iCountMTFa--;
}


/* ==================================================================================
     String Management
     When reading blocks, the strings are not null terminated -- we would like to 
     pull them out and deliver them back in the ####_INFO structures in a civilized
     (null terminated) way.  Thus, just set up an array of malloc'ec strings.  
     Each call that uses strings should first call "ClearStrings" -- strings returned
     to the user will only be good up until the next call...
================================================================================= */

// - returns the size of a wchar_t string
//   and returns zero for a null pointer
size_t CMTFApi::wstrsize(wchar_t *s)
{
    if (s)
        return wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}

// - returns the size of a wchar_t unaligned string
//   and returns zero for a null pointer
size_t CMTFApi::ua_wstrsize(wchar_t UNALIGNED *s)
{
    if (s)
        return ua_wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}


// - frees all allocated pointers in m_aszStrings and sets
//   m_iNumStrings to zero
void CMTFApi::ClearStrings()
{
    int i;
    for (i = 0; i < iNUMSTRINGS; ++i)
    {
        if (m_aszStrings[i])
            free(m_aszStrings[i]);         
        m_aszStrings[i] = 0;
    }

    m_iNumStrings = 0;
}


// - allocates a string in m_aszStrings that is a copy of pString
//   (pString need not be null terminated)
//   (note -- iSize is the size of the string in bytes -- not the length!!!!!
wchar_t * CMTFApi::MakeString(wchar_t UNALIGNED * pString, size_t iSize)
{
    size_t i;
    if (m_iNumStrings >= iNUMSTRINGS) {
        return NULL;
    }
    m_aszStrings[m_iNumStrings] = (wchar_t *)malloc(iSize + sizeof(wchar_t));
    if (!m_aszStrings[m_iNumStrings])
        return NULL;
    
    for (i = 0; i < iSize / sizeof(wchar_t); ++i)
        m_aszStrings[m_iNumStrings][i] = pString[i];
    
    m_aszStrings[m_iNumStrings][i] = L'\0';

    return m_aszStrings[m_iNumStrings++]; 
}


/* ==================================================================================
    Other data structures
================================================================================= */

#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF On Tape Structures 
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     Common DBLK Header
     - The common dblk header exactly as it appears on tape in the head of the dblks
================================================================================== */
typedef struct { 

     UINT8              acBlockType[4];         /* 00h  Unique identifier, see above            */
     UINT32             uBlockAttributes;       /* 04h  Common attributes for this block        */
     UINT16             uOffsetToFirstStream;   /* 08h  Offset to data associated with this     */
                                                /*      DBLK, or offset to next DBLK or         */
                                                /*      filemark if there is no associated      */
                                                /*      data.                                   */
     UINT8              uOSID;                  /* 0Ah  Machine/OS id where written, low byte   */
     UINT8              uOSVersion;             /* 0Bh  Machine/OS id where written, high byte  */
     UINT64             uDisplayableSize;       /* 0Ch  Displayable data size                   */
     UINT64             uFormatLogicalAddress;  /* 14h  Logical blk address relative to SSET    */
     UINT16             uReservedForMBC;        /* 1Ch  Reserved for Media Based Catalog        */
     UINT16             uSoftwareCompression;   /* 1Eh  Software Compression Algorithm        ***/
     UINT8              acReserved1[4];         /* 20h  reserved                                */
     UINT32             uControlBlockId;        /* 24h  Used for error recovery                 */
     UINT8              acReserved2[4];         /* 28h  reserved                                */
     MTF_TAPE_ADDRESS   sOSSpecificData;        /* 2Ch  Size and offset of OS specific stuff    */
     UINT8              uStringType;            /* 30h  ASCII, Unicode, etc.                    */
     UINT8              uReserved3;             /* 31h  for alignment purposes                  */
     UINT16             uHeaderCheckSum;        /* 32h  Checksum of the block header.  The      */
                                                /*      algorithm is: XOR each word preceeding  */
                                                /*      this one and store the result here.     */
                                                /*      (When the checksum is verified the      */
                                                /*      'block_type' is also checked for a      */
                                                /*      non-zero value.                         */
} MTF_DBLK_HDR;



/* ==================================================================================
     DBLK TAPE Header
     - The TAPE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {    /* MTF_DBLK_TAPE */

     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uTapeFamilyId;
     UINT32              uTapeAttributes;
     UINT16              uTapeSequenceNumber;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uSoftFilemarkBlockSize;         /* Or ECC Algorithm */
     UINT16              uTapeCatalogType;
     MTF_TAPE_ADDRESS    sTapeName;
     MTF_TAPE_ADDRESS    sTapeDescription;
     MTF_TAPE_ADDRESS    sTapePassword;
     MTF_TAPE_ADDRESS    sSoftware_name;
     UINT16              uAlignmentFactor;
     UINT16              uSoftwareVendorId;
     MTF_DATE_TIME       sTapeDate;
     UINT8               uMTFMajorVersion;

} MTF_DBLK_TAPE;



/* ==================================================================================
     Start of Set DBLK (SSET)
     - The SSET DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;  /* Or Software Compression Algorithm      ***/
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     MTF_TAPE_ADDRESS    sDataSetName;
     MTF_TAPE_ADDRESS    sDataSetDescription;
     MTF_TAPE_ADDRESS    sDataSetPassword;
     MTF_TAPE_ADDRESS    sUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone;
     UINT8               uMTFMinorVer;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET;



/* ==================================================================================
     Volume DBLK (VOLB)
     - The VOLB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uVolumeAttributes;
     MTF_TAPE_ADDRESS    sDeviceName;
     MTF_TAPE_ADDRESS    sVolumeName;
     MTF_TAPE_ADDRESS    sMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB;



/* ==================================================================================
     Directory DBLK (DIRB)
     - The DIRB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     MTF_TAPE_ADDRESS    sDirectoryName;
} MTF_DBLK_DIRB;



/* ==================================================================================
     Directory DBLK (FILE)
     - The FILE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     MTF_TAPE_ADDRESS    sFileName;
} MTF_DBLK_FILE;


#pragma pack()

/* ==================================================================================
     Corrupt File DBLK (CFIL)
     - use MTF_DBLK_CFIL_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_CFIL_INFO MTF_DBLK_CFIL;

/* ==================================================================================
     End of Set Pad Block (ESPB)
================================================================================== */
// consists only of header

/* ==================================================================================
     End of Set Block (ESET)
     - use MTF_DBLK_ESET_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_ESET_INFO MTF_DBLK_ESET;

/* ==================================================================================
     End of Set Block (EOTM)
     - use MTF_DBLK_EOTM_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_EOTM_INFO MTF_DBLK_EOTM;

/* ==================================================================================
     Soft Filemark (SFMB)
     - use MTF_DBLK_SFMB_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_SFMB_INFO MTF_DBLK_SFMB;

/* ==================================================================================
     StreamHeader
     - use MTF_STREAM_INFO -- same structure
================================================================================== */
typedef MTF_STREAM_INFO MTF_STREAM;


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Misc Data Types
************************************************************************************
************************************************************************************
***********************************************************************************/
/* ==================================================================================
     Alignment Factor
================================================================================== */

/***********************************************************************************
* MTF_SetAlignmentFactor()                                 
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetAlignmentFactor(UINT16 uAF)
{
    // store the user's alignment factor in a private member
    m_uAlignmentFactor = uAF;
}




/***********************************************************************************
* MTF_GetAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT16 CMTFApi::MTF_GetAlignmentFactor()
{
    return m_uAlignmentFactor;
}




/***********************************************************************************
* MTF_PadToNextAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;
    
    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), MTF_GetAlignmentFactor());
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");
    
    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream,
                          pBuffer + nBufUsed,
                          nBufferSize - nBufUsed,
                          0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;    

    return MTF_ERROR_NONE;
}     


/***********************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;

    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), nBlockSize);
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");

    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream, pBuffer + nBufUsed, nBufferSize - nBufUsed, 0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;

    return MTF_ERROR_NONE;
}


/***********************************************************************************
* MTF_CreateUINT64()
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT64 CMTFApi::MTF_CreateUINT64(UINT32 uLSB, UINT32 uMSB)
{
    UINT64 uRet;

    uRet = (UINT64) uMSB << 32;
    uRet += uLSB;
    return uRet;
}


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
    33333333  33222222  22221111  11111100  00000000
    98765432  10987654  32109876  54321098  76543210
================================================================================== */

/***********************************************************************************
* MTF_CreateDateTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    )
{
    MTF_DATE_TIME sDateTime = {0};

     UINT16    temp ;


    // pack the date time structure with the arguments as per the diagram above
      temp = (UINT16)iYear << 2 ;
      sDateTime.dt_field[0] = ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[1] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iMonth << 6 ;
      sDateTime.dt_field[1] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[2] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iDay << 1 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iHour << 4 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[3] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iMinute << 6 ;
      sDateTime.dt_field[3] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[4] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iSecond ;
      sDateTime.dt_field[4] |= ((UINT8 *)&temp)[0] ;

    return sDateTime;    
}





/***********************************************************************************
* MTF_CreateDateTimeFromTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTimeFromTM(
    struct tm *pT
    )
{
    // translate call to MTF_CreateDateTime
    return MTF_CreateDateTime(pT->tm_year + 1900, pT->tm_mon + 1, pT->tm_mday, pT->tm_hour, pT->tm_min, pT->tm_sec);
}





/***********************************************************************************
* MTF_CreateDateTimeToTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT
    )
{
     UINT8     temp[2] ;

    // unpack the MTF_DATE_TIME structure and store the results
     temp[0] = pDT->dt_field[1] ;
     temp[1] = pDT->dt_field[0] ;
     pT->tm_year = *((UINT16 *)temp) >> 2 ;

     temp[0] = pDT->dt_field[2] ;
     temp[1] = pDT->dt_field[1] ;
     pT->tm_mon = (*((UINT16 *)temp) >> 6) & 0x000F ;

     pT->tm_mday = (*((UINT16 *)temp) >> 1) & 0x001F ;

     temp[0] = pDT->dt_field[3] ;
     temp[1] = pDT->dt_field[2] ;
     pT->tm_hour = (*((UINT16 *)temp) >> 4) & 0x001F ;

     temp[0] = pDT->dt_field[4] ;
     temp[1] = pDT->dt_field[3] ;
     pT->tm_min = (*((UINT16 *)temp) >> 6) & 0x003F ;

     pT->tm_sec = *((UINT16 *)temp) & 0x003F ;
}




/***********************************************************************************
* MTF_CreateDateNull()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateNull()
{
    MTF_DATE_TIME sDateTime = {0};
    
    return sDateTime;    
}




/***********************************************************************************
* MTF_CreateDateTimeFromFileTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTimeFromFileTime(
    FILETIME sFileTime
    )
{
    SYSTEMTIME sSystemTime;
    FileTimeToSystemTime(&sFileTime, &sSystemTime);

    return MTF_CreateDateTime(sSystemTime.wYear, 
                              sSystemTime.wMonth, 
                              sSystemTime.wDay, 
                              sSystemTime.wHour, 
                              sSystemTime.wMinute, 
                              sSystemTime.wSecond);
}





/***********************************************************************************
************************************************************************************
****  MTF internal HELPER FUNCITONS
************************************************************************************
***********************************************************************************/

/***********************************************************************************
* StringToTapeAddress()
*
* Description:  Used by the MTF_Write#### functions below.  Given a Buffer, an 
*               MTF_TAPE_ADDRESS struct and the current end of the string storage 
*               area in the buffer, this function appends the string to the string
*               storage area, fills in the MTF_TAPE_ADDRESS struct indicating where
*               the string was stored and returns the new end of the string storage
*               area accounting for the added string.
***********************************************************************************/
size_t CMTFApi::StringToTapeAddress(
    MTF_TAPE_ADDRESS *pAd,                  // the mtf tape address structure to fill
    BYTE             *pBuffer,              // the buffer that is being filled
    wchar_t          *str,                  // the string to store MTF style in the buffer
    size_t           uCurrentStorageOffset  // the next available point in the buffer for string storage
    )
{
    // if we have a string, 
    //      - put the size and offset in the MTF_TAPE_ADDRESS structure and then copy 
    //        the string to the pBuffer at the uCurrentStorageOffset'th byte
    // otherwise
    //      - put a zero size and offset in the MTF_TAPE_ADDRESS struct.
    // return the new end of the string storage area
    
    if (str)
    {
        pAd->uSize   = (UINT16)wstrsize(str);
        pAd->uOffset = (UINT16)uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, str, pAd->uSize);
        uCurrentStorageOffset += pAd->uSize;
    }
    else
    {
        pAd->uSize   = 0;
        pAd->uOffset = 0;
    }
    
    return uCurrentStorageOffset;
}



/***********************************************************************************
* Align()
*
* Description:  Given uSize and an alignment factor, retuns the value
*               of the uSize+ pad, where pad is the value necesary to 
*               get to the next alignment factor.
*               
* Returns       uSize + pad -- not just pad!
***********************************************************************************/
size_t CMTFApi::Align(
    size_t uSize, 
    size_t uAlignment)
{
    if (uSize % uAlignment)    
        return uSize - (uSize  % uAlignment) + uAlignment;
    else
        return uSize;
}




/***********************************************************************************
* CalcChecksum()
*
* Description:  returns the 16bit XOR sum of the nNum bytes starting at the UINT16
*               pointed to by pStartPtr
*               
***********************************************************************************/
UINT16 CMTFApi::CalcChecksum(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT16 resultSoFar = 0;
     UINT16 UNALIGNED *pCur = (UINT16 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}




/***********************************************************************************
* CalcChecksumOfStreamData() - (bmd)
*
* Description:  returns the 32bit XOR sum of the nNum bytes starting at the UINT64
*               pointed to by pStartPtr
*               
***********************************************************************************/
UINT32 CMTFApi::CalcChecksumOfStreamData(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT32 resultSoFar = 0;
     UINT32 UNALIGNED *pCur = (UINT32 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}


     
/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURE FUNCTIONS
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
=====================================================================================
     Common DBLK: MTF_DBLK_HDR_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
size_t CMTFApi::MTF_DBLK_HDR_INFO_CalcAddDataSize(
    MTF_DBLK_HDR_INFO *pSTDInfo
    )
{
    return pSTDInfo->uOSDataSize;
}




/***********************************************************************************
* MTF_SetDblkHdrDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO * pStdInfo
    )
{
    int i;
    for (i = 0; i < 5; ++i)
        pStdInfo->acBlockType[i] = 0;

    pStdInfo->uBlockAttributes      = 0;
    pStdInfo->uOSID                 = 0;
    pStdInfo->uOSVersion            = 0;
    pStdInfo->uDisplayableSize      = 0;
    pStdInfo->uFormatLogicalAddress = 0;
    pStdInfo->uReservedForMBC       = 0;
    pStdInfo->uSoftwareCompression  = MTF_COMPRESS_NONE;
    pStdInfo->uControlBlockId       = 0;
    pStdInfo->pvOSData              = 0;
    pStdInfo->uOSDataSize           = 0;
    pStdInfo->uStringType           = MTF_STRING_UNICODE_STR; 
}




/***********************************************************************************
* MTF_WriteDblkHdrToBuffer()
*
* Description:  called by the MTF_Write#####() functions to format the common block 
*               header to the buffer
*               - this also calculates the header check sum and fills it in
*
* Pre:  - *puCurrentStorageOffset is the offset at where string and OS Data storage will 
*         begin in the buffer
*       - the size of the buffer has been checked and can hold any info written to it
*
* Post: - *puCurrentStorageOffset is updated to reflect any added strings or storage
*               
***********************************************************************************/
void CMTFApi::MTF_WriteDblkHdrToBuffer(
    UINT8              acID[4],                 // four byte header id to write
    UINT16             uOffsetToFirstStream,    // the size of the DBLK for which this will be a header
    MTF_DBLK_HDR_INFO *psHdrInfo,               // the header info struct to use (filled in by client)
    BYTE              *pBuffer,                 // the buffer to format to
    size_t            *puCurrentStorage)        // the point in the buffer where string and os data stroage begins
                                                // (this will be updated upon return to reflect added data to storage)
{
    MTF_DBLK_HDR *pHDR = 0;
    UINT16 uCurrentStorageOffset = 0;
    int i;

    // - if no *puCurrentStorage, we assume storage starts at 
    //   the end of the on tape MTF_DBLK_HDR structure
    if (puCurrentStorage)
        uCurrentStorageOffset = (UINT16)*puCurrentStorage;
    else
        uCurrentStorageOffset = (UINT16)sizeof(MTF_DBLK_HDR);

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    // write in the four byte DBLK ID
    for (i = 0; i < 4; ++i)
        pHDR->acBlockType[i] = acID[i];

    pHDR->uBlockAttributes      = psHdrInfo->uBlockAttributes;
    pHDR->uOffsetToFirstStream  = uOffsetToFirstStream;
    pHDR->uOSID                 = psHdrInfo->uOSID;
    pHDR->uOSVersion            = psHdrInfo->uOSVersion;
    pHDR->uDisplayableSize      = psHdrInfo->uDisplayableSize;
    pHDR->uFormatLogicalAddress = psHdrInfo->uFormatLogicalAddress;
    pHDR->uReservedForMBC       = 0; // must be zero in backup set
    pHDR->uSoftwareCompression  = psHdrInfo->uSoftwareCompression;
    pHDR->uControlBlockId       = psHdrInfo->uControlBlockId;
    pHDR->sOSSpecificData.uSize = psHdrInfo->uOSDataSize;

    // write out the os specific data at the current storage offset and update it
    if (psHdrInfo->uOSDataSize)
    {
        pHDR->sOSSpecificData.uOffset = uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, psHdrInfo->pvOSData, psHdrInfo->uOSDataSize);
        uCurrentStorageOffset = uCurrentStorageOffset + psHdrInfo->uOSDataSize;
    }
    else
    {
        pHDR->sOSSpecificData.uOffset = 0;
        pHDR->sOSSpecificData.uSize   = 0;
    }

    pHDR->uStringType = psHdrInfo->uStringType;
    
    pHDR->uHeaderCheckSum = CalcChecksum(pBuffer, sizeof(MTF_DBLK_HDR) / sizeof(UINT16) - 1);
    
    if (puCurrentStorage)
        *puCurrentStorage = uCurrentStorageOffset;
}




void CMTFApi::MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer)
{
    MTF_DBLK_HDR *pHDR = 0;
    size_t uCurrentStorageOffset = 0;
    int i;

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    for (i = 0; i < 4; ++i)
        psHdrInfo->acBlockType[i] = pHDR->acBlockType[i];
    
    psHdrInfo->acBlockType[4] = 0;

    psHdrInfo->uOffsetToFirstStream = pHDR->uOffsetToFirstStream;
    psHdrInfo->uBlockAttributes     = pHDR->uBlockAttributes ;
    psHdrInfo->uOSID                = pHDR->uOSID;
    psHdrInfo->uOSVersion           = pHDR->uOSVersion;
    psHdrInfo->uDisplayableSize     = pHDR->uDisplayableSize;
    psHdrInfo->uFormatLogicalAddress= pHDR->uFormatLogicalAddress;
    psHdrInfo->uSoftwareCompression = pHDR->uSoftwareCompression;
    psHdrInfo->uControlBlockId      = pHDR->uControlBlockId;
    psHdrInfo->uOSDataSize          = pHDR->sOSSpecificData.uSize;
    psHdrInfo->pvOSData             = (pBuffer + pHDR->sOSSpecificData.uOffset);
    psHdrInfo->uStringType          = pHDR->uStringType;
    psHdrInfo->uHeaderCheckSum      = pHDR->uHeaderCheckSum;
}




/* ==================================================================================
=====================================================================================
     TAPE DBLK: MTF_DBLK_TAPE_INFO
=====================================================================================
================================================================================== */
// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_TAPE_INFO_CalcAddDataSize(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    return wstrsize(pTapeInfo->szTapeName) +
           wstrsize(pTapeInfo->szTapeDescription) +
           wstrsize(pTapeInfo->szTapePassword) +
           wstrsize(pTapeInfo->szSoftwareName);
}



/***********************************************************************************
* MTF_SetTAPEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetTAPEDefaults(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    time_t tTime;
    time(&tTime);

    pTapeInfo->uTapeFamilyId                = 0;
    pTapeInfo->uTapeAttributes              = 0;
    pTapeInfo->uTapeSequenceNumber          = 0;
    pTapeInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pTapeInfo->uSoftFilemarkBlockSize       = 0;
    pTapeInfo->uTapeCatalogType             = MTF_OTC_NONE; // MTF_OTC_TYPE
    pTapeInfo->szTapeName                   = 0 ;
    pTapeInfo->szTapeDescription            = 0 ;
    pTapeInfo->szTapePassword               = 0;
    pTapeInfo->szSoftwareName               = 0;
    pTapeInfo->uAlignmentFactor             = MTF_GetAlignmentFactor();
    pTapeInfo->uSoftwareVendorId            = 0;
    pTapeInfo->sTapeDate                    = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pTapeInfo->uMTFMajorVersion             = MTF_FORMAT_VER_MAJOR;
}



/***********************************************************************************
* MTF_WriteTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_TAPE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_TAPE_INFO_CalcAddDataSize(psTapeInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    
    // 
    // write the header and then fill in the stuff from this info struct
    //
    {
        MTF_DBLK_TAPE *pTape = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_TAPE);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_TAPE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        pTape = (MTF_DBLK_TAPE *) pBuffer;
    
        pTape->uTapeFamilyId                = psTapeInfo->uTapeFamilyId;
        pTape->uTapeAttributes              = psTapeInfo->uTapeAttributes;
        pTape->uTapeSequenceNumber          = psTapeInfo->uTapeSequenceNumber;
        pTape->uPasswordEncryptionAlgorithm = psTapeInfo->uPasswordEncryptionAlgorithm;
        pTape->uSoftFilemarkBlockSize       = psTapeInfo->uSoftFilemarkBlockSize;
        pTape->uTapeCatalogType             = psTapeInfo->uTapeCatalogType;

        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeName, pBuffer, psTapeInfo->szTapeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeDescription, pBuffer, psTapeInfo->szTapeDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapePassword, pBuffer, psTapeInfo->szTapePassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sSoftware_name, pBuffer, psTapeInfo->szSoftwareName, uCurrentStorageOffset);

        pTape->uAlignmentFactor  = psTapeInfo->uAlignmentFactor;
        pTape->uSoftwareVendorId = psTapeInfo->uSoftwareVendorId;
        pTape->sTapeDate         = psTapeInfo->sTapeDate;
        pTape->uMTFMajorVersion  = psTapeInfo->uMTFMajorVersion;
      
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}






/***********************************************************************************
* MTF_ReadTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_TAPE *pTape = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    pTape = (MTF_DBLK_TAPE *) pBuffer;

    psTapeInfo->uTapeFamilyId                = pTape->uTapeFamilyId;
    psTapeInfo->uTapeAttributes              = pTape->uTapeAttributes;
    psTapeInfo->uTapeSequenceNumber          = pTape->uTapeSequenceNumber;
    psTapeInfo->uPasswordEncryptionAlgorithm = pTape->uPasswordEncryptionAlgorithm;
    psTapeInfo->uSoftFilemarkBlockSize       = pTape->uSoftFilemarkBlockSize;
    psTapeInfo->uTapeCatalogType             = pTape->uTapeCatalogType;

    psTapeInfo->uAlignmentFactor  = pTape->uAlignmentFactor;
    psTapeInfo->uSoftwareVendorId = pTape->uSoftwareVendorId;
    psTapeInfo->sTapeDate         = pTape->sTapeDate;
    psTapeInfo->uMTFMajorVersion  = pTape->uMTFMajorVersion;

    psTapeInfo->szTapeName        = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapeName.uOffset), pTape->sTapeName.uSize);
    psTapeInfo->szTapeDescription = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapeDescription.uOffset), pTape->sTapeDescription.uSize);
    psTapeInfo->szTapePassword    = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapePassword.uOffset), pTape->sTapePassword.uSize);
    psTapeInfo->szSoftwareName    = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sSoftware_name.uOffset), pTape->sSoftware_name.uSize);

    if ( !psTapeInfo->szTapeName || !psTapeInfo->szTapeDescription || !psTapeInfo->szTapePassword || !psTapeInfo->szSoftwareName)
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



    
/* ==================================================================================
=====================================================================================
     SSET DBLK: MTF_DBLK_SSET_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_SSET_INFO_CalcAddDataSize(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    return wstrsize(pSSETInfo->szDataSetName)         
           + wstrsize(pSSETInfo->szDataSetDescription)  
           + wstrsize(pSSETInfo->szDataSetPassword)     
           + wstrsize(pSSETInfo->szUserName);
}




/***********************************************************************************
* MTF_SetSSETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSSETDefaults(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    time_t tTime;
    time(&tTime);

    pSSETInfo->uSSETAttributes              = 0;
    pSSETInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pSSETInfo->uDataEncryptionAlgorithm     = MTF_DATA_ENCRYPT_NONE;
    pSSETInfo->uSoftwareVendorId            = 0;
    pSSETInfo->uDataSetNumber               = 0;
    pSSETInfo->szDataSetName                = 0 ;
    pSSETInfo->szDataSetDescription         = 0 ;
    pSSETInfo->szDataSetPassword            = 0 ;
    pSSETInfo->szUserName                   = 0 ;
    pSSETInfo->uPhysicalBlockAddress        = 0;
    pSSETInfo->sMediaWriteDate              = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pSSETInfo->uSoftwareVerMjr              = 0;
    pSSETInfo->uSoftwareVerMnr              = 0;
    pSSETInfo->uTimeZone                    = MTF_LOCAL_TZ;
    pSSETInfo->uMTFMinorVer                 = MTF_FORMAT_VER_MINOR;
    pSSETInfo->uTapeCatalogVersion          = MTF_OTC_NONE;  // MTF_OTC_VERSION
}




/***********************************************************************************
* MTF_WriteSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_SSET) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) +
                           MTF_DBLK_SSET_INFO_CalcAddDataSize(psSSETInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_SSET *psSSET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_SSET);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_SSET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psSSET = (MTF_DBLK_SSET *) pBuffer;

        psSSET->uSSETAttributes              = psSSETInfo->uSSETAttributes;
        psSSET->uPasswordEncryptionAlgorithm = psSSETInfo->uPasswordEncryptionAlgorithm;
        psSSET->uDataEncryptionAlgorithm     = psSSETInfo->uDataEncryptionAlgorithm;
        psSSET->uSoftwareVendorId            = psSSETInfo->uSoftwareVendorId;
        psSSET->uDataSetNumber               = psSSETInfo->uDataSetNumber;

        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetName, pBuffer, psSSETInfo->szDataSetName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetDescription, pBuffer, psSSETInfo->szDataSetDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetPassword, pBuffer, psSSETInfo->szDataSetPassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sUserName, pBuffer, psSSETInfo->szUserName, uCurrentStorageOffset);

        psSSET->uPhysicalBlockAddress = psSSETInfo->uPhysicalBlockAddress;
        psSSET->sMediaWriteDate       = psSSETInfo->sMediaWriteDate;
        psSSET->uSoftwareVerMjr       = psSSETInfo->uSoftwareVerMjr;
        psSSET->uSoftwareVerMnr       = psSSETInfo->uSoftwareVerMnr;
        psSSET->uTimeZone             = psSSETInfo->uTimeZone;
        psSSET->uMTFMinorVer          = psSSETInfo->uMTFMinorVer;
        psSSET->uTapeCatalogVersion   = psSSETInfo->uTapeCatalogVersion;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_SSET *psSSET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSSET = (MTF_DBLK_SSET *) pBuffer;

    psSSETInfo->uSSETAttributes              = psSSET->uSSETAttributes;
    psSSETInfo->uPasswordEncryptionAlgorithm = psSSET->uPasswordEncryptionAlgorithm;
    psSSETInfo->uDataEncryptionAlgorithm     = psSSET->uDataEncryptionAlgorithm;
    psSSETInfo->uSoftwareVendorId            = psSSET->uSoftwareVendorId;
    psSSETInfo->uDataSetNumber               = psSSET->uDataSetNumber;

    psSSETInfo->uPhysicalBlockAddress   = psSSET->uPhysicalBlockAddress;
    psSSETInfo->sMediaWriteDate         = psSSET->sMediaWriteDate;
    psSSETInfo->uSoftwareVerMjr         = psSSET->uSoftwareVerMjr;
    psSSETInfo->uSoftwareVerMnr         = psSSET->uSoftwareVerMnr;
    psSSETInfo->uTimeZone               = psSSET->uTimeZone;
    psSSETInfo->uMTFMinorVer            = psSSET->uMTFMinorVer;
    psSSETInfo->uTapeCatalogVersion     = psSSET->uTapeCatalogVersion;

    psSSETInfo->szDataSetName = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetName.uOffset), psSSET->sDataSetName.uSize);
    psSSETInfo->szDataSetDescription = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetDescription.uOffset), psSSET->sDataSetDescription.uSize);
    psSSETInfo->szDataSetPassword = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetPassword.uOffset), psSSET->sDataSetPassword.uSize);
    psSSETInfo->szUserName = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sUserName.uOffset), psSSET->sUserName.uSize);

    if ( !psSSETInfo->szDataSetName || !psSSETInfo->szDataSetDescription || !psSSETInfo->szDataSetPassword || !psSSETInfo->szUserName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     VOLB DBLK: MTF_DBLK_VOLB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_VOLB_INFO_CalcAddDataSize(
    MTF_DBLK_VOLB_INFO *pVOLBInfo
    )
{
    return wstrsize(pVOLBInfo->szDeviceName) +
           wstrsize(pVOLBInfo->szVolumeName) +
           wstrsize(pVOLBInfo->szMachineName);
}




/***********************************************************************************
* MTF_SetVOLBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo)
{
    time_t tTime;
    time(&tTime);

    pVOLBInfo->uVolumeAttributes = 0;
    pVOLBInfo->szDeviceName      = 0 ;
    pVOLBInfo->szVolumeName      = 0 ;
    pVOLBInfo->szMachineName     = 0 ;
    pVOLBInfo->sMediaWriteDate   = MTF_CreateDateTimeFromTM(gmtime(&tTime));;
}




/***********************************************************************************
* MTF_SetVOLBForDevice()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice)
{
    DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;
    wchar_t tempDeviceName[MTF_STRLEN+4];

    wcscpy(m_szDeviceName, szDevice);
    MTF_SetVOLBDefaults(pVOLBInfo);  // initialize

    // Determine the format and set the appropriate bit in the VOLB attributes.
    if (*(m_szDeviceName+1) == L':') {
        // drive letter w/colon format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_DRIVE;
    }
    else if (0 == wcsncmp( m_szDeviceName, L"UNC", 3 )) {
        // UNC format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_UNC;
    }
    else {
        // operating system specific format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_OS_SPEC;
    }

    // need to prepend \\?\ for the GetVolumeInformation call
    wcscpy(tempDeviceName, L"\\\\?\\");
    wcscat(tempDeviceName, m_szDeviceName);

    GetVolumeInformationW(tempDeviceName, m_szVolumeName, MTF_STRLEN, 0, 0, 0, 0, 0);
    GetComputerNameW(m_szMachineName, &dwBufSize);
    
    pVOLBInfo->szDeviceName         = m_szDeviceName;
    pVOLBInfo->szVolumeName         = m_szVolumeName;
    pVOLBInfo->szMachineName        = m_szMachineName;
}




/***********************************************************************************
* MTF_WriteVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_VOLB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_VOLB_INFO_CalcAddDataSize(psVOLBInfo));


    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_VOLB *psVOLB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_VOLB);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_VOLB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psVOLB = (MTF_DBLK_VOLB *) pBuffer;

        psVOLB->uVolumeAttributes = psVOLBInfo->uVolumeAttributes;

        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sDeviceName, pBuffer, psVOLBInfo->szDeviceName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sVolumeName, pBuffer, psVOLBInfo->szVolumeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sMachineName, pBuffer, psVOLBInfo->szMachineName, uCurrentStorageOffset);

        psVOLB->sMediaWriteDate = psVOLBInfo->sMediaWriteDate;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_VOLB *psVOLB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psVOLB = (MTF_DBLK_VOLB *) pBuffer;

    psVOLBInfo->uVolumeAttributes = psVOLB->uVolumeAttributes;

    psVOLBInfo->sMediaWriteDate = psVOLB->sMediaWriteDate;

    psVOLBInfo->szDeviceName  = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sDeviceName.uOffset), psVOLB->sDeviceName.uSize);
    psVOLBInfo->szVolumeName  = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sVolumeName.uOffset), psVOLB->sVolumeName.uSize);
    psVOLBInfo->szMachineName = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sMachineName.uOffset), psVOLB->sMachineName.uSize);

    if ( !psVOLBInfo->szDeviceName || !psVOLBInfo->szVolumeName || !psVOLBInfo->szMachineName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



/* ==================================================================================
=====================================================================================
     DIRB DBLK: MTF_DBLK_DIRB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo)
{
    return wstrsize(pDIRBInfo->szDirectoryName);
}




/***********************************************************************************
* MTF_SetDIRBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDIRBDefaults(
    MTF_DBLK_DIRB_INFO *pDIRBInfo
    )
{
    pDIRBInfo->uDirectoryAttributes  = 0;
    pDIRBInfo->sLastModificationDate = MTF_CreateDateNull();
    pDIRBInfo->sCreationDate         = MTF_CreateDateNull();
    pDIRBInfo->sBackupDate           = MTF_CreateDateNull();
    pDIRBInfo->sLastAccessDate       = MTF_CreateDateNull();
    pDIRBInfo->uDirectoryId          = 0;
    pDIRBInfo->szDirectoryName       = 0 ;
}




/***********************************************************************************
* MTF_SetDIRBFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDIRBFromFindData(
    MTF_DBLK_DIRB_INFO *pDIRBInfo, 
    wchar_t            *szDirectoryName, 
    WIN32_FIND_DATAW   *pFindData
    )
{
    MTF_SetDIRBDefaults(pDIRBInfo); // initialize

    if ( wcslen( szDirectoryName ) < MTF_STRLEN ) {
        wcscpy(m_szDirectoryName, szDirectoryName);
        pDIRBInfo->szDirectoryName  = m_szDirectoryName;
    }
    else {
        pDIRBInfo->uDirectoryAttributes |= MTF_DIRB_PATH_IN_STREAM;
        pDIRBInfo->szDirectoryName  = 0;
    }

    if (pFindData)
    {
        pDIRBInfo->uDirectoryAttributes |= 
              ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? MTF_DIRB_READ_ONLY : 0) 
            | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)  ? MTF_DIRB_HIDDEN : 0) 
            | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)  ? MTF_DIRB_SYSTEM : 0) 
            | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) ? MTF_DIRB_MODIFIED : 0); 
    
        pDIRBInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
        pDIRBInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
        pDIRBInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    }

    pDIRBInfo->uDirectoryId     = 0;
}


/***********************************************************************************
* MTF_WriteDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_DIRB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_DIRB_INFO_CalcAddDataSize(psDIRBInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_DIRB *psDIRB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_DIRB);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_DIRB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psDIRB = (MTF_DBLK_DIRB *) pBuffer;

        psDIRB->uDirectoryAttributes  = psDIRBInfo->uDirectoryAttributes;
        psDIRB->sLastModificationDate = psDIRBInfo->sLastModificationDate;
        psDIRB->sCreationDate         = psDIRBInfo->sCreationDate;
        psDIRB->sBackupDate           = psDIRBInfo->sBackupDate;
        psDIRB->sLastAccessDate       = psDIRBInfo->sLastAccessDate;
        psDIRB->uDirectoryId          = psDIRBInfo->uDirectoryId;
                              
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        // 
        {
            int i, iLen;
            wchar_t UNALIGNED *szDirectoryName = (wchar_t UNALIGNED *) (pBuffer + uCurrentStorageOffset);

            uCurrentStorageOffset = StringToTapeAddress(&psDIRB->sDirectoryName, pBuffer, psDIRBInfo->szDirectoryName, uCurrentStorageOffset);
            if (psDIRBInfo->szDirectoryName) {
                iLen = wcslen(psDIRBInfo->szDirectoryName);
            } else {
                iLen = 0;
            }
            for (i = 0; i < iLen; ++i)
                if (szDirectoryName[i] == L'\\')
                    szDirectoryName[i] = L'\0';
        }
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_DIRB *psDIRB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psDIRB = (MTF_DBLK_DIRB *) pBuffer;

    psDIRBInfo->uDirectoryAttributes  = psDIRB->uDirectoryAttributes;
    psDIRBInfo->sLastModificationDate = psDIRB->sLastModificationDate;
    psDIRBInfo->sCreationDate         = psDIRB->sCreationDate;
    psDIRBInfo->sBackupDate           = psDIRB->sBackupDate;
    psDIRBInfo->sLastAccessDate       = psDIRB->sLastAccessDate;
    psDIRBInfo->uDirectoryId          = psDIRB->uDirectoryId;

    psDIRBInfo->szDirectoryName = NULL;

    // 
    // we need to turn the zeros in the directory name back to slashes
    // (there are no terminating \0's in the string -- all \0's are really \\'s
    // 
    {
        wchar_t *pTmpBuffer;   
        int i;
        pTmpBuffer = (wchar_t *) malloc(psDIRB->sDirectoryName.uSize);

        if (pTmpBuffer) {

            memmove(pTmpBuffer, pBuffer + psDIRB->sDirectoryName.uOffset, psDIRB->sDirectoryName.uSize);
            for (i = 0; i < (int)(psDIRB->sDirectoryName.uSize / sizeof(wchar_t)); ++i)
                if (pTmpBuffer[i] == L'\0')
                    pTmpBuffer[i] = L'\\';
    
            psDIRBInfo->szDirectoryName = MakeString(pTmpBuffer, psDIRB->sDirectoryName.uSize);
            free(pTmpBuffer);

        }

    }

    if ( !psDIRBInfo->szDirectoryName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}





/* ==================================================================================
=====================================================================================
     FILE DBLK: MTF_DBLK_FILE_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    return wstrsize(pFILEInfo->szFileName);
}




/***********************************************************************************
* MTF_SetFILEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    pFILEInfo->uFileAttributes       = 0;
    pFILEInfo->sLastModificationDate = MTF_CreateDateNull();
    pFILEInfo->sCreationDate         = MTF_CreateDateNull();
    pFILEInfo->sBackupDate           = MTF_CreateDateNull();
    pFILEInfo->sLastAccessDate       = MTF_CreateDateNull();
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = 0;
}





/***********************************************************************************
* MTF_SetFILEFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, WIN32_FIND_DATAW *pFindData)
{
    time_t tTime;
    time(&tTime);

    MTF_SetFILEDefaults(pFILEInfo);  // initialize

    wcscpy(m_szFileName, pFindData->cFileName);

    pFILEInfo->uFileAttributes = 
        ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? MTF_FILE_READ_ONLY : 0) 
      | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)  ? MTF_FILE_HIDDEN : 0) 
      | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)  ? MTF_FILE_SYSTEM : 0)
      | ((pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) ? MTF_FILE_MODIFIED : 0) ;
    
    pFILEInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
    pFILEInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
    pFILEInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = m_szFileName;

    pFILEInfo->uDisplaySize          = MTF_CreateUINT64(pFindData->nFileSizeLow, pFindData->nFileSizeHigh);

}





/***********************************************************************************
* MTF_WriteFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_FILE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_FILE_INFO_CalcAddDataSize(psFILEInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);
    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_FILE *psFILE = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_FILE);
        psHdrInfo->uDisplayableSize = psFILEInfo->uDisplaySize;

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_FILE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psFILE = (MTF_DBLK_FILE *) pBuffer;

        psFILE->uFileAttributes         = psFILEInfo->uFileAttributes;
        psFILE->sLastModificationDate   = psFILEInfo->sLastModificationDate;
        psFILE->sCreationDate           = psFILEInfo->sCreationDate;
        psFILE->sBackupDate             = psFILEInfo->sBackupDate;
        psFILE->sLastAccessDate         = psFILEInfo->sLastAccessDate;
        psFILE->uDirectoryId            = psFILEInfo->uDirectoryId;
        psFILE->uFileId                 = psFILEInfo->uFileId;

        uCurrentStorageOffset = StringToTapeAddress(&psFILE->sFileName, pBuffer, psFILEInfo->szFileName, uCurrentStorageOffset);

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_FILE *psFILE = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psFILE = (MTF_DBLK_FILE *) pBuffer;

    psFILEInfo->uFileAttributes         = psFILE->uFileAttributes;
    psFILEInfo->sLastModificationDate   = psFILE->sLastModificationDate;
    psFILEInfo->sCreationDate           = psFILE->sCreationDate;
    psFILEInfo->sBackupDate             = psFILE->sBackupDate;
    psFILEInfo->sLastAccessDate         = psFILE->sLastAccessDate;
    psFILEInfo->uDirectoryId            = psFILE->uDirectoryId;
    psFILEInfo->uFileId                 = psFILE->uFileId;

    psFILEInfo->szFileName              = MakeString((wchar_t UNALIGNED *) (pBuffer + psFILE->sFileName.uOffset), psFILE->sFileName.uSize);

    if ( !psFILEInfo->szFileName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     CFIL DBLK: MTF_DBLK_CFIL_INFO
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetCFILDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetCFILDefaults(
    MTF_DBLK_CFIL_INFO *pCFILInfo
    )
{
    pCFILInfo->uCFileAttributes     = MTF_CFIL_UNREADABLE_BLK;
    pCFILInfo->uDirectoryId         = 0;
    pCFILInfo->uFileId              = 0;
    pCFILInfo->uStreamOffset        = 0;
    pCFILInfo->uCorruptStreamNumber = 0;
}




/***********************************************************************************
* MTF_WriteCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;


    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_HDR) + 
                           sizeof(MTF_DBLK_CFIL) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_CFIL_INFO *psCFIL = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_CFIL);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_CFIL, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

        *psCFIL = *psCFILInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_CFIL *psCFIL = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

    *psCFILInfo = *psCFIL;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     ESPB DBLK
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_WriteESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,
                         size_t              nBufferSize,
                         size_t             *pnSizeUsed)

{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream) {
        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }

        return MTF_ERROR_BUFFER_TOO_SMALL;                
    }

    memset(pBuffer, 0, uOffsetToFirstStream);

    MTF_WriteDblkHdrToBuffer(
        (UINT8 *)(char *)MTF_ID_ESPB,
        uOffsetToFirstStream,
        psHdrInfo,
        pBuffer,
        0);

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToFirstStream;

    return MTF_ERROR_NONE;    
}                                             




/***********************************************************************************
* MTF_ReadESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer)     
{
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    return MTF_ERROR_NONE;    
}                            




/* ==================================================================================
=====================================================================================
     End of Set DBLK (ESET)
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetESETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo)
{
    time_t tTime;
    time(&tTime);

    pESETInfo->uESETAttributes          = 0;
    pESETInfo->uNumberOfCorrupFiles     = 0;
    pESETInfo->uSetMapPBA               = 0;
    pESETInfo->uFileDetailPBA           = 0;
    pESETInfo->uFDDTapeSequenceNumber   = 0;
    pESETInfo->uDataSetNumber           = 0;
    pESETInfo->sMediaWriteDate          = MTF_CreateDateTimeFromTM(gmtime(&tTime));
}





/***********************************************************************************
* MTF_WriteESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_ESET) +
                           sizeof(MTF_DBLK_HDR) +  
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));
                        
    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_ESET_INFO *psESET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_ESET) + sizeof(MTF_DBLK_HDR);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_ESET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psESET = *psESETInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_ESET *psESET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psESETInfo = *psESET;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     End of Set DBLK (EOTM)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_SetEOTMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo)
{
    pEOTMInfo->uLastESETPBA = 0;
}





/***********************************************************************************
* MTF_WriteEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_EOTM_INFO) + 
                           sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_EOTM_INFO *psEOTM = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_EOTM);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_EOTM, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psEOTM = *psEOTMInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_EOTM *psEOTM = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psEOTMInfo = *psEOTM;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     Soft Filemark (SFMB)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_CreateSFMB() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
size_t CMTFApi::MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize)
{
    size_t n;

    if (0 == nBlockSize || nBlockSize % 512) {
        return 0;
    }

    // The SFMB fills the entire block.
    // Calculate the total number of entries that fit within a block
    // such that MTF_DBLK_HDR + MTF_DBLK_SFMB + (n-1 elements) < nBlockSize
    n = (nBlockSize - sizeof(MTF_DBLK_HDR) - sizeof(MTF_DBLK_SFMB) + sizeof(UINT32))/sizeof(UINT32);

    return n;
}

/***********************************************************************************
* MTF_InsertSoftFilemark() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba)
{
    size_t n;
    size_t bytesToShift;

    // We insert a filemark entry by shifting all the entries down.  The one closest BOM
    // eventually drop out of the array.

    if (psSoftInfo) {
        n = psSoftInfo->uNumberOfFilemarkEntries;

        bytesToShift = psSoftInfo->uFilemarkEntriesUsed * sizeof(UINT32);

        // So we don't overwrite memory.
        bytesToShift -= (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) ? 0 : sizeof(UINT32);
    
        memmove(&psSoftInfo->uFilemarkArray[1], &psSoftInfo->uFilemarkArray[0], bytesToShift);

        psSoftInfo->uFilemarkArray[0] = pba;

        if (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) {
            psSoftInfo->uFilemarkEntriesUsed++;
        }
    }
}


/***********************************************************************************
* MTF_WriteSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed)
{
    UINT16 uOffsetToFirstStream;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer || NULL == pnSizeUsed || 0 == nBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSoftInfo->uNumberOfFilemarkEntries-1)*sizeof(UINT32);

    uOffsetToFirstStream = (UINT16) (sizeOfSFMB +
                           sizeof(MTF_DBLK_HDR) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;

        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);

    {
        MTF_DBLK_SFMB_INFO *psSFMB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeOfSFMB;

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_SFMB,
            uOffsetToFirstStream,
            psHdrInfo,
            pBuffer,
            &uCurrentStorageOffset);

        psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

        // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
        memcpy(psSFMB, psSoftInfo, sizeOfSFMB);

        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }
    }

    return MTF_ERROR_NONE;
}

/***********************************************************************************
* MTF_ReadSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer)
{
    MTF_DBLK_SFMB *psSFMB = 0;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

    // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSFMB->uNumberOfFilemarkEntries-1)*sizeof(UINT32);
    memcpy(psSoftInfo, psSFMB, sizeOfSFMB);

    return MTF_ERROR_NONE;
}

/* ==================================================================================
=====================================================================================
     STREAM HEADER
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetSTREAMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, char *szId)
{
    memcpy(pSTREAMInfo->acStreamId, szId, 4);
    pSTREAMInfo->uStreamFileSystemAttributes = 0;
    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = 0;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetSTREAMFromStreamId()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSTREAMFromStreamId(
    MTF_STREAM_INFO *pSTREAMInfo, 
    WIN32_STREAM_ID *pStreamId, 
    size_t           nIDHeaderSize
    )
{

// From Steve DeVos, Seagate:
//   > BACKUP_INVALID and BACKUP_LINK will never be returned from BackupRead.
//   >
//   > -Steve
//
// TODO:  MTF_NT_ENCRYPTED_STREAM     "NTED"; These retrieved by NT Encyption APIs
// TODO:  MTF_NT_QUOTA_STREAM         "NTQU"; These retrieved by NT Quota APIs

    MTF_SetSTREAMDefaults(pSTREAMInfo, "UNKN");

    if (pStreamId->dwStreamId == BACKUP_DATA)
        memcpy(pSTREAMInfo->acStreamId, "STAN", 4);
    else if (pStreamId->dwStreamId == BACKUP_EA_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTEA", 4);
    else if (pStreamId->dwStreamId == BACKUP_SECURITY_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NACL", 4);
    else if (pStreamId->dwStreamId == BACKUP_ALTERNATE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "ADAT", 4);
    else if (pStreamId->dwStreamId == BACKUP_OBJECT_ID)
        memcpy(pSTREAMInfo->acStreamId, "NTOI", 4);
    else if (pStreamId->dwStreamId == BACKUP_REPARSE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTRP", 4);
    else if (pStreamId->dwStreamId == BACKUP_SPARSE_BLOCK)
        memcpy(pSTREAMInfo->acStreamId, "SPAR", 4);
    else {
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_NON_PORTABLE;
    }

    if (pStreamId->dwStreamAttributes & STREAM_MODIFIED_WHEN_READ)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_MODIFIED_BY_READ;
    if (pStreamId->dwStreamAttributes & STREAM_CONTAINS_SECURITY)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_CONTAINS_SECURITY;
    if (pStreamId->dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_SPARSE;

    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = MTF_CreateUINT64(pStreamId->Size.LowPart, pStreamId->Size.HighPart) + nIDHeaderSize;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetStreamIdFromSTREAM() - (bmd)                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetStreamIdFromSTREAM(
    WIN32_STREAM_ID *pStreamId, 
    MTF_STREAM_INFO *pSTREAMInfo, 
    size_t           nIDHeaderSize
    )
{
    UNREFERENCED_PARAMETER(nIDHeaderSize);

    memset( pStreamId, 0, sizeof( WIN32_STREAM_ID ) );

    if (0 == memcmp(pSTREAMInfo->acStreamId, "STAN", 4))
        pStreamId->dwStreamId = BACKUP_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTEA", 4))
        pStreamId->dwStreamId = BACKUP_EA_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NACL", 4))
        pStreamId->dwStreamId = BACKUP_SECURITY_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "ADAT", 4))
        pStreamId->dwStreamId = BACKUP_ALTERNATE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTOI", 4))
        pStreamId->dwStreamId = BACKUP_OBJECT_ID;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTRP", 4))
        pStreamId->dwStreamId = BACKUP_REPARSE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "SPAR", 4))
        pStreamId->dwStreamId = BACKUP_SPARSE_BLOCK;
    else {
        pStreamId->dwStreamId = BACKUP_INVALID;
    }

    pStreamId->dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_MODIFIED_BY_READ)
        pStreamId->dwStreamAttributes |= STREAM_MODIFIED_WHEN_READ;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_CONTAINS_SECURITY)
        pStreamId->dwStreamAttributes |= STREAM_CONTAINS_SECURITY;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_IS_SPARSE)
        pStreamId->dwStreamAttributes |= STREAM_SPARSE_ATTRIBUTE;

    // TODO: Handle named data streams (size of name and in MTF stream)
    //       ? How do I know ?

    pStreamId->Size.LowPart  = (DWORD)((pSTREAMInfo->uStreamLength << 32) >>32);
    pStreamId->Size.HighPart = (DWORD)(pSTREAMInfo->uStreamLength >> 32);

}





/***********************************************************************************
* MTF_WriteStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                            BYTE            *pBuffer,     
                            size_t           nBufferSize, 
                            size_t          *pnSizeUsed) 

{

    psStreamInfo->uCheckSum = CalcChecksum((BYTE *) psStreamInfo, sizeof(MTF_STREAM_INFO) / sizeof(UINT16) - 1);

    if (nBufferSize < sizeof(MTF_STREAM_INFO))
    {
        if (pnSizeUsed)
            *pnSizeUsed = sizeof(MTF_STREAM_INFO);
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, sizeof(MTF_STREAM_INFO));
    
    
    *((MTF_STREAM_INFO *) pBuffer) = *psStreamInfo;

    if (pnSizeUsed)
        *pnSizeUsed = sizeof(MTF_STREAM_INFO);


    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_WriteNameStream() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteNameStream(
    char *szType,
    wchar_t *szName,
    BYTE *pBuffer,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    MTF_STREAM_INFO sStream;
    UINT16 uOffsetToCSUMStream;
    UINT16 uOffsetToNextStream;
    size_t nBufUsed;
    UINT16 nameSize;
    UINT32 nameChecksum;

    //
    // Figure the size of the entire Name stream including trailing CSUM and make sure we have room.
    //
    nameSize = (UINT16)wstrsize(szName);  // including terminating '\0'

    uOffsetToCSUMStream = sizeof(MTF_STREAM_INFO) + nameSize;
    uOffsetToCSUMStream = (UINT16)Align(uOffsetToCSUMStream, 4);

    uOffsetToNextStream = uOffsetToCSUMStream;

    uOffsetToNextStream += sizeof(MTF_STREAM_INFO) + 4; // includes 4 byte CSUM data
    uOffsetToNextStream = (UINT16)Align(uOffsetToNextStream, 4);

    if (nBufferSize < uOffsetToNextStream) {
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToNextStream);

    MTF_SetSTREAMDefaults(&sStream, szType);
    sStream.uStreamLength = nameSize;
    sStream.uStreamTapeFormatAttributes |= MTF_STREAM_CHECKSUMED;
    MTF_WriteStreamHeader(&sStream, pBuffer, nBufferSize, &nBufUsed);

    memcpy(pBuffer + nBufUsed, szName, nameSize);

    if ( 0 == memcmp(sStream.acStreamId, "PNAM", 4) ) {
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        //
        int i, iLen;
        wchar_t UNALIGNED *szDirectoryName = (wchar_t UNALIGNED *) (pBuffer + nBufUsed);

        if (szDirectoryName) {
            iLen = ua_wcslen(szDirectoryName);
        } else {
            iLen = 0;
        }
        for (i = 0; i < iLen; ++i)
            if (szDirectoryName[i] == L'\\')
                szDirectoryName[i] = L'\0';
    }

    // For Name streams, we always tack on a CSUM

    nameChecksum = CalcChecksumOfStreamData(pBuffer + nBufUsed, nameSize / sizeof(UINT32) + 1);

    MTF_SetSTREAMDefaults(&sStream, MTF_CHECKSUM_STREAM);
    sStream.uStreamLength = sizeof(nameChecksum);
    MTF_WriteStreamHeader(&sStream, pBuffer + uOffsetToCSUMStream, nBufferSize, &nBufUsed);

    memcpy(pBuffer + uOffsetToCSUMStream + nBufUsed, &nameChecksum, sizeof(nameChecksum));

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToNextStream;

    return MTF_ERROR_NONE;
}




/***********************************************************************************
* MTF_ReadStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadStreamHeader(MTF_STREAM_INFO   *psStreamInfo,  
                          BYTE              *pBuffer)    

{
    *psStreamInfo = *((MTF_STREAM_INFO *) pBuffer);
    return MTF_ERROR_NONE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtf_api.c ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.c
//
// DESCRIPTION :        mtf api implementation 
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________
// *****************************************************************************/

#include <assert.h>
#include <time.h>
#include <string.h>
#include <wchar.h>

#include "mtf_api.h"

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API Static Data Structures and Housekeeping
************************************************************************************
************************************************************************************
***********************************************************************************/
// see below

static UINT16 s_uAlignmentFactor = 0;

static size_t Align(size_t uSize, size_t uAlignment);


// when the api formats it's own strings (i.e. file names from the WIN32_FIND_DATA,
// we need to keep those strings somewhere so we can set the pointers to them in 
// the info structs.  
#define STRLEN 256
static wchar_t s_szDeviceName[STRLEN];                     
static wchar_t s_szVolumeName[STRLEN];
static wchar_t s_szMachineName[MAX_COMPUTERNAME_LENGTH+1];
static wchar_t s_szDirectoryName[STRLEN];
static wchar_t s_szFileName[STRLEN];



/* ==================================================================================
     String Management
     When reading blocks, the strings are not null terminated -- we would like to 
     pull them out and deliver them back in the ####_INFO structures in a civilized
     (null terminated) way.  Thus, just set up an array of malloc'ec strings.  
     Each call that uses strings should first call "ClearStrings" -- strings returned
     to the user will only be good up until the next call...
================================================================================= */
#define iNUMSTRINGS 5

static wchar_t *s_aszStrings[iNUMSTRINGS] = {0};      // we keep an array of pointers to allocated strings
                                                      // this managed by ClearStrings() and MakeString()

static int      s_iNumStrings = 0;                    // the number of strings currently allocated


// - returns the size of a wchar_t string
//   and returns zero for a null pointer
static size_t wstrsize(wchar_t *s)
{
    if (s)
        return wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}


// - frees all allocated pointers in s_aszStrings and sets
//   s_iNumStrings to zero
static void ClearStrings()
{
    int i;
    for (i = 0; i < iNUMSTRINGS; ++i)
    {
        if (s_aszStrings[i])
            free(s_aszStrings[i]);         
        s_aszStrings[i] = 0;
    }

    s_iNumStrings = 0;
}


// - allocates a string in s_aszStrings that is a copy of pString
//   (pString need not be null terminated)
//   (note -- iSize is the size of the string in bytes -- not the length!!!!!
static wchar_t * MakeString(wchar_t * pString, size_t iSize)
{
    size_t i;
    assert(s_iNumStrings < iNUMSTRINGS);
    s_aszStrings[s_iNumStrings] = malloc(iSize + sizeof(wchar_t));
    if (!s_aszStrings[s_iNumStrings])
        return NULL;
    
    for (i = 0; i < iSize / sizeof(wchar_t); ++i)
        s_aszStrings[s_iNumStrings][i] = pString[i];
    
    s_aszStrings[s_iNumStrings][i] = L'\0';

    return s_aszStrings[s_iNumStrings++]; 
}


/* ==================================================================================
    Other static data structures
================================================================================= */

#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF On Tape Structures 
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     Tape Address
================================================================================== */
typedef struct {
     UINT16 uSize;        /* Size of the data */
     UINT16 uOffset;      /* Offset to the data */
} MTF_TAPE_ADDRESS;

/* ==================================================================================
     Common DBLK Header
     - The common dblk header exactly as it appears on tape in the head of the dblks
================================================================================== */
typedef struct { 

     UINT8              acBlockType[4];         /* 00h  Unique identifier, see above            */
     UINT32             uBlockAttributes;       /* 04h  Common attributes for this block        */
     UINT16             uOffsetToFirstStream;   /* 08h  Offset to data associated with this     */
                                                /*      DBLK, or offset to next DBLK or         */
                                                /*      filemark if there is no associated      */
                                                /*      data.                                   */
     UINT8              uOSID;                  /* 0Ah  Machine/OS id where written, low byte   */
     UINT8              uOSVersion;             /* 0Bh  Machine/OS id where written, high byte  */
     UINT64             uDisplayableSize;       /* 0Ch  Displayable data size                   */
     UINT64             uFormatLogicalAddress;  /* 14h  Logical blk address relative to SSET    */
     UINT16             uReservedForMBC;        /* 1Ch  Reserved for Media Based Catalog        */
     UINT16             uSoftwareCompression;   /* 1Eh  Software Compression Algorithm        ***/
     UINT8              acReserved1[4];         /* 20h  reserved                                */
     UINT32             uControlBlockId;        /* 24h  Used for error recovery                 */
     UINT8              acReserved2[4];         /* 28h  reserved                                */
     MTF_TAPE_ADDRESS   sOSSpecificData;        /* 2Ch  Size and offset of OS specific stuff    */
     UINT8              uStringType;            /* 30h  ASCII, Unicode, etc.                    */
     UINT8              uReserved3;             /* 31h  for alignment purposes                  */
     UINT16             uHeaderCheckSum;        /* 32h  Checksum of the block header.  The      */
                                                /*      algorithm is: XOR each word preceeding  */
                                                /*      this one and store the result here.     */
                                                /*      (When the checksum is verified the      */
                                                /*      'block_type' is also checked for a      */
                                                /*      non-zero value.                         */
} MTF_DBLK_HDR;



/* ==================================================================================
     DBLK TAPE Header
     - The TAPE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {    /* MTF_DBLK_TAPE */

     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uTapeFamilyId;
     UINT32              uTapeAttributes;
     UINT16              uTapeSequenceNumber;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uSoftFilemarkBlockSize;         /* Or ECC Algorithm */
     UINT16              uTapeCatalogType;
     MTF_TAPE_ADDRESS    sTapeName;
     MTF_TAPE_ADDRESS    sTapeDescription;
     MTF_TAPE_ADDRESS    sTapePassword;
     MTF_TAPE_ADDRESS    sSoftware_name;
     UINT16              uAlignmentFactor;
     UINT16              uSoftwareVendorId;
     MTF_DATE_TIME       sTapeDate;
     UINT8               uMTFMajorVersion;

} MTF_DBLK_TAPE;



/* ==================================================================================
     Start of Set DBLK (SSET)
     - The SSET DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;  /* Or Software Compression Algorithm      ***/
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     MTF_TAPE_ADDRESS    sDataSetName;
     MTF_TAPE_ADDRESS    sDataSetDescription;
     MTF_TAPE_ADDRESS    sDataSetPassword;
     MTF_TAPE_ADDRESS    sUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone;
     UINT8               uMTFMinorVer;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET;



/* ==================================================================================
     Volume DBLK (VOLB)
     - The VOLB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uVolumeAttributes;
     MTF_TAPE_ADDRESS    sDeviceName;
     MTF_TAPE_ADDRESS    sVolumeName;
     MTF_TAPE_ADDRESS    sMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB;



/* ==================================================================================
     Directory DBLK (DIRB)
     - The DIRB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     MTF_TAPE_ADDRESS    sDirectoryName;
} MTF_DBLK_DIRB;



/* ==================================================================================
     Directory DBLK (FILE)
     - The FILE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     MTF_TAPE_ADDRESS    sFileName;
} MTF_DBLK_FILE;


#pragma pack()

/* ==================================================================================
     Corrupt File DBLK (CFIL)
     - use MTF_DBLK_CFIL_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_CFIL_INFO MTF_DBLK_CFIL;

/* ==================================================================================
     End of Set Pad Block (ESPB)
================================================================================== */
// consists only of header

/* ==================================================================================
     End of Set Block (ESET)
     - use MTF_DBLK_ESET_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_ESET_INFO MTF_DBLK_ESET;

/* ==================================================================================
     End of Set Block (EOTM)
     - use MTF_DBLK_EOTM_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_EOTM_INFO MTF_DBLK_EOTM;

/* ==================================================================================
     Soft Filemark (SFMB)
     - use MTF_DBLK_SFMB_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_SFMB_INFO MTF_DBLK_SFMB;

/* ==================================================================================
     StreamHeader
     - use MTF_STREAM_INFO -- same structure
================================================================================== */
typedef MTF_STREAM_INFO MTF_STREAM;


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Misc Data Types
************************************************************************************
************************************************************************************
***********************************************************************************/
/* ==================================================================================
     Alignment Factor
================================================================================== */

/***********************************************************************************
* MTF_SetAlignmentFactor()                                 
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetAlignmentFactor(UINT16 uAF)
{
    // store the user's alignment factor in a static variable
    s_uAlignmentFactor = uAF;
}




/***********************************************************************************
* MTF_GetAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT16 MTF_GetAlignmentFactor()
{
    // make sure an alignment factor was stored,
    // and return it
    assert(s_uAlignmentFactor != 0);
    return s_uAlignmentFactor;
}




/***********************************************************************************
* MTF_PadToNextAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;
    
    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), MTF_GetAlignmentFactor());
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");
    
    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream,
                          pBuffer + nBufUsed,
                          nBufferSize - nBufUsed,
                          0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;    

    return MTF_ERROR_NONE;
}     


/***********************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;

    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), nBlockSize);
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");

    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream, pBuffer + nBufUsed, nBufferSize - nBufUsed, 0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;

    return MTF_ERROR_NONE;
}


/***********************************************************************************
* MTF_CreateUINT64()
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT64 MTF_CreateUINT64(UINT32 uLSB, UINT32 uMSB)
{
    UINT64 uRet;

    uRet = (UINT64) uMSB << 32;
    uRet += uLSB;
    return uRet;
}


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
    33333333  33222222  22221111  11111100  00000000
    98765432  10987654  32109876  54321098  76543210
================================================================================== */

/***********************************************************************************
* MTF_CreateDateTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    )
{
    MTF_DATE_TIME sDateTime = {0};

     UINT16    temp ;


    // pack the date time structure with the arguments as per the diagram above
      temp = iYear << 2 ;
      sDateTime.dt_field[0] = ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[1] = ((UINT8 *)&temp)[0] ;
      
      temp = iMonth << 6 ;
      sDateTime.dt_field[1] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[2] = ((UINT8 *)&temp)[0] ;
      
      temp = iDay << 1 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[0] ;
      
      temp = iHour << 4 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[3] = ((UINT8 *)&temp)[0] ;
      
      temp = iMinute << 6 ;
      sDateTime.dt_field[3] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[4] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iSecond ;
      sDateTime.dt_field[4] |= ((UINT8 *)&temp)[0] ;

    return sDateTime;    
}





/***********************************************************************************
* MTF_CreateDateTimeFromTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTimeFromTM(
    struct tm *pT
    )
{
    // translate call to MTF_CreateDateTime
    return MTF_CreateDateTime(pT->tm_year + 1900, pT->tm_mon + 1, pT->tm_mday, pT->tm_hour, pT->tm_min, pT->tm_sec);
}





/***********************************************************************************
* MTF_CreateDateTimeToTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT
    )
{
     UINT8     temp[2] ;

    // unpack the MTF_DATE_TIME structure and store the results
     temp[0] = pDT->dt_field[1] ;
     temp[1] = pDT->dt_field[0] ;
     pT->tm_year = *((UINT16 *)temp) >> 2 ;

     temp[0] = pDT->dt_field[2] ;
     temp[1] = pDT->dt_field[1] ;
     pT->tm_mon = (*((UINT16 *)temp) >> 6) & 0x000F ;

     pT->tm_mday = (*((UINT16 *)temp) >> 1) & 0x001F ;

     temp[0] = pDT->dt_field[3] ;
     temp[1] = pDT->dt_field[2] ;
     pT->tm_hour = (*((UINT16 *)temp) >> 4) & 0x001F ;

     temp[0] = pDT->dt_field[4] ;
     temp[1] = pDT->dt_field[3] ;
     pT->tm_min = (*((UINT16 *)temp) >> 6) & 0x003F ;

     pT->tm_sec = *((UINT16 *)temp) & 0x003F ;
}




/***********************************************************************************
* MTF_CreateDateNull()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateNull()
{
    MTF_DATE_TIME sDateTime = {0};
    
    return sDateTime;    
}




/***********************************************************************************
* MTF_CreateDateTimeFromFileTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(
    FILETIME sFileTime
    )
{
    SYSTEMTIME sSystemTime;
    FileTimeToSystemTime(&sFileTime, &sSystemTime);

    return MTF_CreateDateTime(sSystemTime.wYear, 
                              sSystemTime.wMonth, 
                              sSystemTime.wDay, 
                              sSystemTime.wHour, 
                              sSystemTime.wMinute, 
                              sSystemTime.wSecond);
}





/***********************************************************************************
************************************************************************************
****  MTF static HELPER FUNCITONS
************************************************************************************
***********************************************************************************/

/***********************************************************************************
* StringToTapeAddress()
*
* Description:  Used by the MTF_Write#### functions below.  Given a Buffer, an 
*               MTF_TAPE_ADDRESS struct and the current end of the string storage 
*               area in the buffer, this function appends the string to the string
*               storage area, fills in the MTF_TAPE_ADDRESS struct indicating where
*               the string was stored and returns the new end of the string storage
*               area accounting for the added string.
***********************************************************************************/
static size_t StringToTapeAddress(
    MTF_TAPE_ADDRESS *pAd,                  // the mtf tape address structure to fill
    BYTE             *pBuffer,              // the buffer that is being filled
    wchar_t          *str,                  // the string to store MTF style in the buffer
    size_t           uCurrentStorageOffset  // the next available point in the buffer for string storage
    )
{
    // if we have a string, 
    //      - put the size and offset in the MTF_TAPE_ADDRESS structure and then copy 
    //        the string to the pBuffer at the uCurrentStorageOffset'th byte
    // otherwise
    //      - put a zero size and offset in the MTF_TAPE_ADDRESS struct.
    // return the new end of the string storage area
    
    if (str)
    {
        pAd->uSize   = (UINT16)wstrsize(str);
        pAd->uOffset = (UINT16)uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, str, pAd->uSize);
        uCurrentStorageOffset += pAd->uSize;
    }
    else
    {
        pAd->uSize   = 0;
        pAd->uOffset = 0;
    }
    
    return uCurrentStorageOffset;
}



/***********************************************************************************
* Align()
*
* Description:  Given uSize and an alignment factor, retuns the value
*               of the uSize+ pad, where pad is the value necesary to 
*               get to the next alignment factor.
*               
* Returns       uSize + pad -- not just pad!
***********************************************************************************/
static size_t Align(
    size_t uSize, 
    size_t uAlignment)
{
    if (uSize % uAlignment)    
        return uSize - (uSize  % uAlignment) + uAlignment;
    else
        return uSize;
}




/***********************************************************************************
* CalcChecksum()
*
* Description:  returns the 16bit XOR sum of the nNum bytes starting at the UINT16
*               pointed to by pStartPtr
*               
***********************************************************************************/
static UINT16 CalcChecksum(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT16 resultSoFar = 0;
     UINT16 *pCur = (UINT16 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}




/***********************************************************************************
* CalcChecksumOfStreamData() - (bmd)
*
* Description:  returns the 32bit XOR sum of the nNum bytes starting at the UINT64
*               pointed to by pStartPtr
*               
***********************************************************************************/
static UINT32 CalcChecksumOfStreamData(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT32 resultSoFar = 0;
     UINT32 *pCur = (UINT32 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}


     
/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURE FUNCTIONS
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
=====================================================================================
     Common DBLK: MTF_DBLK_HDR_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
static size_t MTF_DBLK_HDR_INFO_CalcAddDataSize(
    MTF_DBLK_HDR_INFO *pSTDInfo
    )
{
    return pSTDInfo->uOSDataSize;
}




/***********************************************************************************
* MTF_SetDblkHdrDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO * pStdInfo
    )
{
    int i;
    for (i = 0; i < 5; ++i)
        pStdInfo->acBlockType[i] = 0;

    pStdInfo->uBlockAttributes      = 0;
    pStdInfo->uOSID                 = 0;
    pStdInfo->uOSVersion            = 0;
    pStdInfo->uDisplayableSize      = 0;
    pStdInfo->uFormatLogicalAddress = 0;
    pStdInfo->uReservedForMBC       = 0;
    pStdInfo->uSoftwareCompression  = MTF_COMPRESS_NONE;
    pStdInfo->uControlBlockId       = 0;
    pStdInfo->pvOSData              = 0;
    pStdInfo->uOSDataSize           = 0;
    pStdInfo->uStringType           = MTF_STRING_UNICODE_STR; 
}




/***********************************************************************************
* MTF_WriteDblkHdrToBuffer()
*
* Description:  called by the MTF_Write#####() functions to format the common block 
*               header to the buffer
*               - this also calculates the header check sum and fills it in
*
* Pre:  - *puCurrentStorageOffset is the offset at where string and OS Data storage will 
*         begin in the buffer
*       - the size of the buffer has been checked and can hold any info written to it
*
* Post: - *puCurrentStorageOffset is updated to reflect any added strings or storage
*               
***********************************************************************************/
static void MTF_WriteDblkHdrToBuffer(
    UINT8              acID[4],                 // four byte header id to write
    UINT16             uOffsetToFirstStream,    // the size of the DBLK for which this will be a header
    MTF_DBLK_HDR_INFO *psHdrInfo,               // the header info struct to use (filled in by client)
    BYTE              *pBuffer,                 // the buffer to format to
    size_t            *puCurrentStorage)        // the point in the buffer where string and os data stroage begins
                                                // (this will be updated upon return to reflect added data to storage)
{
    MTF_DBLK_HDR *pHDR = 0;
    UINT16 uCurrentStorageOffset = 0;
    int i;

    // - if no *puCurrentStorage, we assume storage starts at 
    //   the end of the on tape MTF_DBLK_HDR structure
    if (puCurrentStorage)
        uCurrentStorageOffset = (UINT16)*puCurrentStorage;
    else
        uCurrentStorageOffset = (UINT16)sizeof(MTF_DBLK_HDR);

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    // write in the four byte DBLK ID
    for (i = 0; i < 4; ++i)
        pHDR->acBlockType[i] = acID[i];

    pHDR->uBlockAttributes      = psHdrInfo->uBlockAttributes;
    pHDR->uOffsetToFirstStream  = uOffsetToFirstStream;
    pHDR->uOSID                 = psHdrInfo->uOSID;
    pHDR->uOSVersion            = psHdrInfo->uOSVersion;
    pHDR->uDisplayableSize      = psHdrInfo->uDisplayableSize;
    pHDR->uFormatLogicalAddress = psHdrInfo->uFormatLogicalAddress;
    pHDR->uReservedForMBC       = 0; // must be zero in backup set
    pHDR->uSoftwareCompression  = psHdrInfo->uSoftwareCompression;
    pHDR->uControlBlockId       = psHdrInfo->uControlBlockId;
    pHDR->sOSSpecificData.uSize = psHdrInfo->uOSDataSize;

    // write out the os specific data at the current storage offset and update it
    if (psHdrInfo->uOSDataSize)
    {
        pHDR->sOSSpecificData.uOffset = uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, psHdrInfo->pvOSData, psHdrInfo->uOSDataSize);
        uCurrentStorageOffset += psHdrInfo->uOSDataSize;
    }
    else
    {
        pHDR->sOSSpecificData.uOffset = 0;
        pHDR->sOSSpecificData.uSize   = 0;
    }

    pHDR->uStringType = psHdrInfo->uStringType;
    
    pHDR->uHeaderCheckSum = CalcChecksum(pBuffer, sizeof(MTF_DBLK_HDR) / sizeof(UINT16) - 1);
    
    if (puCurrentStorage)
        *puCurrentStorage = uCurrentStorageOffset;
}




void MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer)
{
    MTF_DBLK_HDR *pHDR = 0;
    size_t uCurrentStorageOffset = 0;
    int i;

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    for (i = 0; i < 4; ++i)
        psHdrInfo->acBlockType[i] = pHDR->acBlockType[i];
    
    psHdrInfo->acBlockType[4] = 0;

    psHdrInfo->uOffsetToFirstStream = pHDR->uOffsetToFirstStream;
    psHdrInfo->uBlockAttributes     = pHDR->uBlockAttributes ;
    psHdrInfo->uOSID                = pHDR->uOSID;
    psHdrInfo->uOSVersion           = pHDR->uOSVersion;
    psHdrInfo->uDisplayableSize     = pHDR->uDisplayableSize;
    psHdrInfo->uFormatLogicalAddress= pHDR->uFormatLogicalAddress;
    psHdrInfo->uSoftwareCompression = pHDR->uSoftwareCompression;
    psHdrInfo->uControlBlockId      = pHDR->uControlBlockId;
    psHdrInfo->uOSDataSize          = pHDR->sOSSpecificData.uSize;
    psHdrInfo->pvOSData             = (pBuffer + pHDR->sOSSpecificData.uOffset);
    psHdrInfo->uStringType          = pHDR->uStringType;
    psHdrInfo->uHeaderCheckSum      = pHDR->uHeaderCheckSum;
}




/* ==================================================================================
=====================================================================================
     TAPE DBLK: MTF_DBLK_TAPE_INFO
=====================================================================================
================================================================================== */
// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_TAPE_INFO_CalcAddDataSize(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    return wstrsize(pTapeInfo->szTapeName) +
           wstrsize(pTapeInfo->szTapeDescription) +
           wstrsize(pTapeInfo->szTapePassword) +
           wstrsize(pTapeInfo->szSoftwareName);
}



/***********************************************************************************
* MTF_SetTAPEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetTAPEDefaults(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    time_t tTime;
    time(&tTime);

    pTapeInfo->uTapeFamilyId                = 0;
    pTapeInfo->uTapeAttributes              = 0;
    pTapeInfo->uTapeSequenceNumber          = 0;
    pTapeInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pTapeInfo->uSoftFilemarkBlockSize       = 0;
    pTapeInfo->uTapeCatalogType             = MTF_OTC_NONE; // MTF_OTC_TYPE
    pTapeInfo->szTapeName                   = 0 ;
    pTapeInfo->szTapeDescription            = 0 ;
    pTapeInfo->szTapePassword               = 0;
    pTapeInfo->szSoftwareName               = 0;
    pTapeInfo->uAlignmentFactor             = MTF_GetAlignmentFactor();
    pTapeInfo->uSoftwareVendorId            = 0;
    pTapeInfo->sTapeDate                    = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pTapeInfo->uMTFMajorVersion             = MTF_FORMAT_VER_MAJOR;
}



/***********************************************************************************
* MTF_WriteTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_TAPE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_TAPE_INFO_CalcAddDataSize(psTapeInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    
    // 
    // write the header and then fill in the stuff from this info struct
    //
    {
        MTF_DBLK_TAPE *pTape = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_TAPE);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_TAPE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        pTape = (MTF_DBLK_TAPE *) pBuffer;
    
        pTape->uTapeFamilyId                = psTapeInfo->uTapeFamilyId;
        pTape->uTapeAttributes              = psTapeInfo->uTapeAttributes;
        pTape->uTapeSequenceNumber          = psTapeInfo->uTapeSequenceNumber;
        pTape->uPasswordEncryptionAlgorithm = psTapeInfo->uPasswordEncryptionAlgorithm;
        pTape->uSoftFilemarkBlockSize       = psTapeInfo->uSoftFilemarkBlockSize;
        pTape->uTapeCatalogType             = psTapeInfo->uTapeCatalogType;

        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeName, pBuffer, psTapeInfo->szTapeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeDescription, pBuffer, psTapeInfo->szTapeDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapePassword, pBuffer, psTapeInfo->szTapePassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sSoftware_name, pBuffer, psTapeInfo->szSoftwareName, uCurrentStorageOffset);

        pTape->uAlignmentFactor  = psTapeInfo->uAlignmentFactor;
        pTape->uSoftwareVendorId = psTapeInfo->uSoftwareVendorId;
        pTape->sTapeDate         = psTapeInfo->sTapeDate;
        pTape->uMTFMajorVersion  = psTapeInfo->uMTFMajorVersion;
      
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}






/***********************************************************************************
* MTF_ReadTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_TAPE *pTape = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    pTape = (MTF_DBLK_TAPE *) pBuffer;

    psTapeInfo->uTapeFamilyId                = pTape->uTapeFamilyId;
    psTapeInfo->uTapeAttributes              = pTape->uTapeAttributes;
    psTapeInfo->uTapeSequenceNumber          = pTape->uTapeSequenceNumber;
    psTapeInfo->uPasswordEncryptionAlgorithm = pTape->uPasswordEncryptionAlgorithm;
    psTapeInfo->uSoftFilemarkBlockSize       = pTape->uSoftFilemarkBlockSize;
    psTapeInfo->uTapeCatalogType             = pTape->uTapeCatalogType;

    psTapeInfo->uAlignmentFactor  = pTape->uAlignmentFactor;
    psTapeInfo->uSoftwareVendorId = pTape->uSoftwareVendorId;
    psTapeInfo->sTapeDate         = pTape->sTapeDate;
    psTapeInfo->uMTFMajorVersion  = pTape->uMTFMajorVersion;

    psTapeInfo->szTapeName        = MakeString((wchar_t *) (pBuffer + pTape->sTapeName.uOffset), pTape->sTapeName.uSize);
    psTapeInfo->szTapeDescription = MakeString((wchar_t *) (pBuffer + pTape->sTapeDescription.uOffset), pTape->sTapeDescription.uSize);
    psTapeInfo->szTapePassword    = MakeString((wchar_t *) (pBuffer + pTape->sTapePassword.uOffset), pTape->sTapePassword.uSize);
    psTapeInfo->szSoftwareName    = MakeString((wchar_t *) (pBuffer + pTape->sSoftware_name.uOffset), pTape->sSoftware_name.uSize);

    if ( !psTapeInfo->szTapeName || !psTapeInfo->szTapeDescription || !psTapeInfo->szTapePassword || !psTapeInfo->szSoftwareName)
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



    
/* ==================================================================================
=====================================================================================
     SSET DBLK: MTF_DBLK_SSET_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_SSET_INFO_CalcAddDataSize(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    return wstrsize(pSSETInfo->szDataSetName)         
           + wstrsize(pSSETInfo->szDataSetDescription)  
           + wstrsize(pSSETInfo->szDataSetPassword)     
           + wstrsize(pSSETInfo->szUserName);
}




/***********************************************************************************
* MTF_SetSSETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSSETDefaults(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    time_t tTime;
    time(&tTime);

    pSSETInfo->uSSETAttributes              = 0;
    pSSETInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pSSETInfo->uDataEncryptionAlgorithm     = MTF_DATA_ENCRYPT_NONE;
    pSSETInfo->uSoftwareVendorId            = 0;
    pSSETInfo->uDataSetNumber               = 0;
    pSSETInfo->szDataSetName                = 0 ;
    pSSETInfo->szDataSetDescription         = 0 ;
    pSSETInfo->szDataSetPassword            = 0 ;
    pSSETInfo->szUserName                   = 0 ;
    pSSETInfo->uPhysicalBlockAddress        = 0;
    pSSETInfo->sMediaWriteDate              = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pSSETInfo->uSoftwareVerMjr              = 0;
    pSSETInfo->uSoftwareVerMnr              = 0;
    pSSETInfo->uTimeZone                    = MTF_LOCAL_TZ;
    pSSETInfo->uMTFMinorVer                 = MTF_FORMAT_VER_MINOR;
    pSSETInfo->uTapeCatalogVersion          = MTF_OTC_NONE;  // MTF_OTC_VERSION
}




/***********************************************************************************
* MTF_WriteSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_SSET) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) +
                           MTF_DBLK_SSET_INFO_CalcAddDataSize(psSSETInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_SSET *psSSET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_SSET);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_SSET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psSSET = (MTF_DBLK_SSET *) pBuffer;

        psSSET->uSSETAttributes              = psSSETInfo->uSSETAttributes;
        psSSET->uPasswordEncryptionAlgorithm = psSSETInfo->uPasswordEncryptionAlgorithm;
        psSSET->uDataEncryptionAlgorithm     = psSSETInfo->uDataEncryptionAlgorithm;
        psSSET->uSoftwareVendorId            = psSSETInfo->uSoftwareVendorId;
        psSSET->uDataSetNumber               = psSSETInfo->uDataSetNumber;

        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetName, pBuffer, psSSETInfo->szDataSetName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetDescription, pBuffer, psSSETInfo->szDataSetDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetPassword, pBuffer, psSSETInfo->szDataSetPassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sUserName, pBuffer, psSSETInfo->szUserName, uCurrentStorageOffset);

        psSSET->uPhysicalBlockAddress = psSSETInfo->uPhysicalBlockAddress;
        psSSET->sMediaWriteDate       = psSSETInfo->sMediaWriteDate;
        psSSET->uSoftwareVerMjr       = psSSETInfo->uSoftwareVerMjr;
        psSSET->uSoftwareVerMnr       = psSSETInfo->uSoftwareVerMnr;
        psSSET->uTimeZone             = psSSETInfo->uTimeZone;
        psSSET->uMTFMinorVer          = psSSETInfo->uMTFMinorVer;
        psSSET->uTapeCatalogVersion   = psSSETInfo->uTapeCatalogVersion;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_SSET *psSSET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSSET = (MTF_DBLK_SSET *) pBuffer;

    psSSETInfo->uSSETAttributes              = psSSET->uSSETAttributes;
    psSSETInfo->uPasswordEncryptionAlgorithm = psSSET->uPasswordEncryptionAlgorithm;
    psSSETInfo->uDataEncryptionAlgorithm     = psSSET->uDataEncryptionAlgorithm;
    psSSETInfo->uSoftwareVendorId            = psSSET->uSoftwareVendorId;
    psSSETInfo->uDataSetNumber               = psSSET->uDataSetNumber;

    psSSETInfo->uPhysicalBlockAddress   = psSSET->uPhysicalBlockAddress;
    psSSETInfo->sMediaWriteDate         = psSSET->sMediaWriteDate;
    psSSETInfo->uSoftwareVerMjr         = psSSET->uSoftwareVerMjr;
    psSSETInfo->uSoftwareVerMnr         = psSSET->uSoftwareVerMnr;
    psSSETInfo->uTimeZone               = psSSET->uTimeZone;
    psSSETInfo->uMTFMinorVer            = psSSET->uMTFMinorVer;
    psSSETInfo->uTapeCatalogVersion     = psSSET->uTapeCatalogVersion;

    psSSETInfo->szDataSetName = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetName.uOffset), psSSET->sDataSetName.uSize);
    psSSETInfo->szDataSetDescription = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetDescription.uOffset), psSSET->sDataSetDescription.uSize);
    psSSETInfo->szDataSetPassword = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetPassword.uOffset), psSSET->sDataSetPassword.uSize);
    psSSETInfo->szUserName = MakeString((wchar_t *) (pBuffer + psSSET->sUserName.uOffset), psSSET->sUserName.uSize);

    if ( !psSSETInfo->szDataSetName || !psSSETInfo->szDataSetDescription || !psSSETInfo->szDataSetPassword || !psSSETInfo->szUserName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     VOLB DBLK: MTF_DBLK_VOLB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_VOLB_INFO_CalcAddDataSize(
    MTF_DBLK_VOLB_INFO *pVOLBInfo
    )
{
    return wstrsize(pVOLBInfo->szDeviceName) +
           wstrsize(pVOLBInfo->szVolumeName) +
           wstrsize(pVOLBInfo->szMachineName);
}




/***********************************************************************************
* MTF_SetVOLBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo)
{
    time_t tTime;
    time(&tTime);

    pVOLBInfo->uVolumeAttributes = 0;
    pVOLBInfo->szDeviceName      = 0 ;
    pVOLBInfo->szVolumeName      = 0 ;
    pVOLBInfo->szMachineName     = 0 ;
    pVOLBInfo->sMediaWriteDate   = MTF_CreateDateTimeFromTM(gmtime(&tTime));;
}




/***********************************************************************************
* MTF_SetVOLBForDevice()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice)
{
    int nBufSize = MAX_COMPUTERNAME_LENGTH + 1;
    wchar_t tempDeviceName[STRLEN+4];

    wcscpy(s_szDeviceName, szDevice);
    MTF_SetVOLBDefaults(pVOLBInfo);  // initialize

    // Determine the format and set the appropriate bit in the VOLB attributes.
    if (*(s_szDeviceName+1) == L':') {
        // drive letter w/colon format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_DRIVE;
    }
    else if (0 == wcsncmp( s_szDeviceName, L"UNC", 3 )) {
        // UNC format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_UNC;
    }
    else {
        // operating system specific format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_OS_SPEC;
    }

    // need to prepend \\?\ for the GetVolumeInformation call
    wcscpy(tempDeviceName, L"\\\\?\\");
    wcscat(tempDeviceName, s_szDeviceName);

    GetVolumeInformationW(tempDeviceName, s_szVolumeName, STRLEN, 0, 0, 0, 0, 0);
    GetComputerNameW(s_szMachineName, &nBufSize);
    
    pVOLBInfo->szDeviceName         = s_szDeviceName;
    pVOLBInfo->szVolumeName         = s_szVolumeName;
    pVOLBInfo->szMachineName        = s_szMachineName;
}




/***********************************************************************************
* MTF_WriteVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_VOLB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_VOLB_INFO_CalcAddDataSize(psVOLBInfo);


    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_VOLB *psVOLB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_VOLB);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_VOLB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psVOLB = (MTF_DBLK_VOLB *) pBuffer;

        psVOLB->uVolumeAttributes = psVOLBInfo->uVolumeAttributes;

        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sDeviceName, pBuffer, psVOLBInfo->szDeviceName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sVolumeName, pBuffer, psVOLBInfo->szVolumeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sMachineName, pBuffer, psVOLBInfo->szMachineName, uCurrentStorageOffset);

        psVOLB->sMediaWriteDate = psVOLBInfo->sMediaWriteDate;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_VOLB *psVOLB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psVOLB = (MTF_DBLK_VOLB *) pBuffer;

    psVOLBInfo->uVolumeAttributes = psVOLB->uVolumeAttributes;

    psVOLBInfo->sMediaWriteDate = psVOLB->sMediaWriteDate;

    psVOLBInfo->szDeviceName  = MakeString((wchar_t *) (pBuffer + psVOLB->sDeviceName.uOffset), psVOLB->sDeviceName.uSize);
    psVOLBInfo->szVolumeName  = MakeString((wchar_t *) (pBuffer + psVOLB->sVolumeName.uOffset), psVOLB->sVolumeName.uSize);
    psVOLBInfo->szMachineName = MakeString((wchar_t *) (pBuffer + psVOLB->sMachineName.uOffset), psVOLB->sMachineName.uSize);

    if ( !psVOLBInfo->szDeviceName || !psVOLBInfo->szVolumeName || !psVOLBInfo->szMachineName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



/* ==================================================================================
=====================================================================================
     DIRB DBLK: MTF_DBLK_DIRB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo)
{
    return wstrsize(pDIRBInfo->szDirectoryName);
}




/***********************************************************************************
* MTF_SetDIRBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDIRBDefaults(
    MTF_DBLK_DIRB_INFO *pDIRBInfo
    )
{
    pDIRBInfo->uDirectoryAttributes  = 0;
    pDIRBInfo->sLastModificationDate = MTF_CreateDateNull();
    pDIRBInfo->sCreationDate         = MTF_CreateDateNull();
    pDIRBInfo->sBackupDate           = MTF_CreateDateNull();
    pDIRBInfo->sLastAccessDate       = MTF_CreateDateNull();
    pDIRBInfo->uDirectoryId          = 0;
    pDIRBInfo->szDirectoryName       = 0 ;
}




/***********************************************************************************
* MTF_SetDIRBFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDIRBFromFindData(
    MTF_DBLK_DIRB_INFO *pDIRBInfo, 
    wchar_t            *szDirectoryName, 
    WIN32_FIND_DATAW   *pFindData
    )
{
    MTF_SetDIRBDefaults(pDIRBInfo); // initialize

    if ( wcslen( szDirectoryName ) < STRLEN ) {
        wcscpy(s_szDirectoryName, szDirectoryName);
        pDIRBInfo->szDirectoryName  = s_szDirectoryName;
    }
    else {
        pDIRBInfo->uDirectoryAttributes |= MTF_DIRB_PATH_IN_STREAM;
        pDIRBInfo->szDirectoryName  = 0;
    }

    if (pFindData)
    {
        pDIRBInfo->uDirectoryAttributes |= 
            pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_DIRB_READ_ONLY : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_DIRB_HIDDEN : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_DIRB_SYSTEM : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_DIRB_MODIFIED : 0; 
    
        pDIRBInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
        pDIRBInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
        pDIRBInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    }

    pDIRBInfo->uDirectoryId     = 0;
}


/***********************************************************************************
* MTF_WriteDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_DIRB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_DIRB_INFO_CalcAddDataSize(psDIRBInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_DIRB *psDIRB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_DIRB);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_DIRB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psDIRB = (MTF_DBLK_DIRB *) pBuffer;

        psDIRB->uDirectoryAttributes  = psDIRBInfo->uDirectoryAttributes;
        psDIRB->sLastModificationDate = psDIRBInfo->sLastModificationDate;
        psDIRB->sCreationDate         = psDIRBInfo->sCreationDate;
        psDIRB->sBackupDate           = psDIRBInfo->sBackupDate;
        psDIRB->sLastAccessDate       = psDIRBInfo->sLastAccessDate;
        psDIRB->uDirectoryId          = psDIRBInfo->uDirectoryId;
                              
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        // 
        {
            int i, iLen;
            wchar_t *szDirectoryName = (wchar_t *) (pBuffer + uCurrentStorageOffset);

            uCurrentStorageOffset = StringToTapeAddress(&psDIRB->sDirectoryName, pBuffer, psDIRBInfo->szDirectoryName, uCurrentStorageOffset);
            iLen = wstrsize(psDIRBInfo->szDirectoryName);
            for (i = 0; i < iLen; ++i)
                if (szDirectoryName[i] == L'\\')
                    szDirectoryName[i] = L'\0';
        }
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_DIRB *psDIRB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psDIRB = (MTF_DBLK_DIRB *) pBuffer;

    psDIRBInfo->uDirectoryAttributes  = psDIRB->uDirectoryAttributes;
    psDIRBInfo->sLastModificationDate = psDIRB->sLastModificationDate;
    psDIRBInfo->sCreationDate         = psDIRB->sCreationDate;
    psDIRBInfo->sBackupDate           = psDIRB->sBackupDate;
    psDIRBInfo->sLastAccessDate       = psDIRB->sLastAccessDate;
    psDIRBInfo->uDirectoryId          = psDIRB->uDirectoryId;

    psDIRBInfo->szDirectoryName = NULL;

    // 
    // we need to turn the zeros in the directory name back to slashes
    // (there are no terminating \0's in the string -- all \0's are really \\'s
    // 
    {
        wchar_t *pTmpBuffer;   
        int i;
        pTmpBuffer = (wchar_t *) malloc(psDIRB->sDirectoryName.uSize);

        if (pTmpBuffer) {

            memmove(pTmpBuffer, pBuffer + psDIRB->sDirectoryName.uOffset, psDIRB->sDirectoryName.uSize);
            for (i = 0; i < psDIRB->sDirectoryName.uSize; ++i)
                if (pTmpBuffer[i] == L'\0')
                    pTmpBuffer[i] = L'\\';
    
            psDIRBInfo->szDirectoryName = MakeString(pTmpBuffer, psDIRB->sDirectoryName.uSize);
            free(pTmpBuffer);

        }

    }

    if ( !psDIRBInfo->szDirectoryName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}





/* ==================================================================================
=====================================================================================
     FILE DBLK: MTF_DBLK_FILE_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    return wstrsize(pFILEInfo->szFileName);
}




/***********************************************************************************
* MTF_SetFILEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    pFILEInfo->uFileAttributes       = 0;
    pFILEInfo->sLastModificationDate = MTF_CreateDateNull();
    pFILEInfo->sCreationDate         = MTF_CreateDateNull();
    pFILEInfo->sBackupDate           = MTF_CreateDateNull();
    pFILEInfo->sLastAccessDate       = MTF_CreateDateNull();
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = 0;
}





/***********************************************************************************
* MTF_SetFILEFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, WIN32_FIND_DATAW *pFindData)
{
    time_t tTime;
    time(&tTime);

    MTF_SetFILEDefaults(pFILEInfo);  // initialize

    wcscpy(s_szFileName, pFindData->cFileName);

    pFILEInfo->uFileAttributes = 
        (pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_FILE_READ_ONLY : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_FILE_HIDDEN : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_FILE_SYSTEM : 0)
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_FILE_MODIFIED : 0) ;
    
    pFILEInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
    pFILEInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
    pFILEInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = s_szFileName;

    pFILEInfo->uDisplaySize          = MTF_CreateUINT64(pFindData->nFileSizeLow, pFindData->nFileSizeHigh);

}





/***********************************************************************************
* MTF_WriteFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_FILE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_FILE_INFO_CalcAddDataSize(psFILEInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);
    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_FILE *psFILE = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_FILE);
        psHdrInfo->uDisplayableSize = psFILEInfo->uDisplaySize;

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_FILE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psFILE = (MTF_DBLK_FILE *) pBuffer;

        psFILE->uFileAttributes         = psFILEInfo->uFileAttributes;
        psFILE->sLastModificationDate   = psFILEInfo->sLastModificationDate;
        psFILE->sCreationDate           = psFILEInfo->sCreationDate;
        psFILE->sBackupDate             = psFILEInfo->sBackupDate;
        psFILE->sLastAccessDate         = psFILEInfo->sLastAccessDate;
        psFILE->uDirectoryId            = psFILEInfo->uDirectoryId;
        psFILE->uFileId                 = psFILEInfo->uFileId;

        uCurrentStorageOffset = StringToTapeAddress(&psFILE->sFileName, pBuffer, psFILEInfo->szFileName, uCurrentStorageOffset);

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_FILE *psFILE = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psFILE = (MTF_DBLK_FILE *) pBuffer;

    psFILEInfo->uFileAttributes         = psFILE->uFileAttributes;
    psFILEInfo->sLastModificationDate   = psFILE->sLastModificationDate;
    psFILEInfo->sCreationDate           = psFILE->sCreationDate;
    psFILEInfo->sBackupDate             = psFILE->sBackupDate;
    psFILEInfo->sLastAccessDate         = psFILE->sLastAccessDate;
    psFILEInfo->uDirectoryId            = psFILE->uDirectoryId;
    psFILEInfo->uFileId                 = psFILE->uFileId;

    psFILEInfo->szFileName              = MakeString((wchar_t *) (pBuffer + psFILE->sFileName.uOffset), psFILE->sFileName.uSize);

    if ( !psFILEInfo->szFileName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     CFIL DBLK: MTF_DBLK_CFIL_INFO
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetCFILDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetCFILDefaults(
    MTF_DBLK_CFIL_INFO *pCFILInfo
    )
{
    pCFILInfo->uCFileAttributes     = MTF_CFIL_UNREADABLE_BLK;
    pCFILInfo->uDirectoryId         = 0;
    pCFILInfo->uFileId              = 0;
    pCFILInfo->uStreamOffset        = 0;
    pCFILInfo->uCorruptStreamNumber = 0;
}




/***********************************************************************************
* MTF_WriteCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;


    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_HDR) + 
                           sizeof(MTF_DBLK_CFIL) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_CFIL_INFO *psCFIL = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_CFIL);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_CFIL, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

        *psCFIL = *psCFILInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_CFIL *psCFIL = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

    *psCFILInfo = *psCFIL;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     ESPB DBLK
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_WriteESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,
                         size_t              nBufferSize,
                         size_t             *pnSizeUsed)

{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream) {
        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }

        return MTF_ERROR_BUFFER_TOO_SMALL;                
    }

    memset(pBuffer, 0, uOffsetToFirstStream);

    MTF_WriteDblkHdrToBuffer(
        MTF_ID_ESPB,
        uOffsetToFirstStream,
        psHdrInfo,
        pBuffer,
        0);

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToFirstStream;

    return MTF_ERROR_NONE;    
}                                             




/***********************************************************************************
* MTF_ReadESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer)     
{
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    return MTF_ERROR_NONE;    
}                            




/* ==================================================================================
=====================================================================================
     End of Set DBLK (ESET)
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetESETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo)
{
    time_t tTime;
    time(&tTime);

    pESETInfo->uESETAttributes          = 0;
    pESETInfo->uNumberOfCorrupFiles     = 0;
    pESETInfo->uSetMapPBA               = 0;
    pESETInfo->uFileDetailPBA           = 0;
    pESETInfo->uFDDTapeSequenceNumber   = 0;
    pESETInfo->uDataSetNumber           = 0;
    pESETInfo->sMediaWriteDate          = MTF_CreateDateTimeFromTM(gmtime(&tTime));
}





/***********************************************************************************
* MTF_WriteESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_ESET) +
                           sizeof(MTF_DBLK_HDR) +  
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);
                        
    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_ESET_INFO *psESET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_ESET) + sizeof(MTF_DBLK_HDR);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_ESET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psESET = *psESETInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_ESET *psESET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psESETInfo = *psESET;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     End of Set DBLK (EOTM)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_SetEOTMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo)
{
    pEOTMInfo->uLastESETPBA = 0;
}





/***********************************************************************************
* MTF_WriteEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_EOTM_INFO) + 
                           sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_EOTM_INFO *psEOTM = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_EOTM);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_EOTM, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psEOTM = *psEOTMInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_EOTM *psEOTM = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psEOTMInfo = *psEOTM;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     Soft Filemark (SFMB)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_CreateSFMB() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize)
{
    size_t n;

    if (0 == nBlockSize || nBlockSize % 512) {
        return 0;
    }

    // The SFMB fills the entire block.
    // Calculate the total number of entries that fit within a block
    // such that MTF_DBLK_HDR + MTF_DBLK_SFMB + (n-1 elements) < nBlockSize
    n = (nBlockSize - sizeof(MTF_DBLK_HDR) - sizeof(MTF_DBLK_SFMB) + sizeof(UINT32))/sizeof(UINT32);

    return n;
}

/***********************************************************************************
* MTF_InsertSoftFilemark() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba)
{
    size_t n;
    size_t bytesToShift;

    // We insert a filemark entry by shifting all the entries down.  The one closest BOM
    // eventually drop out of the array.

    if (psSoftInfo) {
        n = psSoftInfo->uNumberOfFilemarkEntries;

        bytesToShift = psSoftInfo->uFilemarkEntriesUsed * sizeof(UINT32);

        // So we don't overwrite memory.
        bytesToShift -= (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) ? 0 : sizeof(UINT32);
    
        memmove(&psSoftInfo->uFilemarkArray[1], &psSoftInfo->uFilemarkArray[0], bytesToShift);

        psSoftInfo->uFilemarkArray[0] = pba;

        if (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) {
            psSoftInfo->uFilemarkEntriesUsed++;
        }
    }
}


/***********************************************************************************
* MTF_WriteSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed)
{
    UINT16 uOffsetToFirstStream;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer || NULL == pnSizeUsed || 0 == nBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSoftInfo->uNumberOfFilemarkEntries-1)*sizeof(UINT32);

    uOffsetToFirstStream = sizeOfSFMB +
                           sizeof(MTF_DBLK_HDR) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;

        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);

    {
        MTF_DBLK_SFMB_INFO *psSFMB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeOfSFMB;

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_SFMB,
            uOffsetToFirstStream,
            psHdrInfo,
            pBuffer,
            &uCurrentStorageOffset);

        psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

        // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
        memcpy(psSFMB, psSoftInfo, sizeOfSFMB);

        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }
    }

    return MTF_ERROR_NONE;
}

/***********************************************************************************
* MTF_ReadSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer)
{
    MTF_DBLK_SFMB *psSFMB = 0;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

    // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSFMB->uNumberOfFilemarkEntries-1)*sizeof(UINT32);
    memcpy(psSoftInfo, psSFMB, sizeOfSFMB);

    return MTF_ERROR_NONE;
}

/* ==================================================================================
=====================================================================================
     STREAM HEADER
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetSTREAMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, char *szId)
{
    memcpy(pSTREAMInfo->acStreamId, szId, 4);
    pSTREAMInfo->uStreamFileSystemAttributes = 0;
    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = 0;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetSTREAMFromStreamId()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSTREAMFromStreamId(
    MTF_STREAM_INFO *pSTREAMInfo, 
    WIN32_STREAM_ID *pStreamId, 
    size_t           nIDHeaderSize
    )
{

// From Steve DeVos, Seagate:
//   > BACKUP_INVALID and BACKUP_LINK will never be returned from BackupRead.
//   >
//   > -Steve
//
// TODO:  MTF_NT_ENCRYPTED_STREAM     "NTED"; These retrieved by NT Encyption APIs
// TODO:  MTF_NT_QUOTA_STREAM         "NTQU"; These retrieved by NT Quota APIs

    MTF_SetSTREAMDefaults(pSTREAMInfo, "UNKN");

    if (pStreamId->dwStreamId == BACKUP_DATA)
        memcpy(pSTREAMInfo->acStreamId, "STAN", 4);
    else if (pStreamId->dwStreamId == BACKUP_EA_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTEA", 4);
    else if (pStreamId->dwStreamId == BACKUP_SECURITY_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NACL", 4);
    else if (pStreamId->dwStreamId == BACKUP_ALTERNATE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "ADAT", 4);
    else if (pStreamId->dwStreamId == BACKUP_OBJECT_ID)
        memcpy(pSTREAMInfo->acStreamId, "NTOI", 4);
    else if (pStreamId->dwStreamId == BACKUP_REPARSE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTRP", 4);
    else if (pStreamId->dwStreamId == BACKUP_SPARSE_BLOCK)
        memcpy(pSTREAMInfo->acStreamId, "SPAR", 4);
    else {
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_NON_PORTABLE;
    }

    if (pStreamId->dwStreamAttributes & STREAM_MODIFIED_WHEN_READ)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_MODIFIED_BY_READ;
    if (pStreamId->dwStreamAttributes & STREAM_CONTAINS_SECURITY)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_CONTAINS_SECURITY;
    if (pStreamId->dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_SPARSE;

    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = MTF_CreateUINT64(pStreamId->Size.LowPart, pStreamId->Size.HighPart) + nIDHeaderSize;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetStreamIdFromSTREAM() - (bmd)                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetStreamIdFromSTREAM(
    WIN32_STREAM_ID *pStreamId, 
    MTF_STREAM_INFO *pSTREAMInfo, 
    size_t           nIDHeaderSize
    )
{
    memset( pStreamId, 0, sizeof( WIN32_STREAM_ID ) );

    if (0 == memcmp(pSTREAMInfo->acStreamId, "STAN", 4))
        pStreamId->dwStreamId = BACKUP_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTEA", 4))
        pStreamId->dwStreamId = BACKUP_EA_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NACL", 4))
        pStreamId->dwStreamId = BACKUP_SECURITY_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "ADAT", 4))
        pStreamId->dwStreamId = BACKUP_ALTERNATE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTOI", 4))
        pStreamId->dwStreamId = BACKUP_OBJECT_ID;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTRP", 4))
        pStreamId->dwStreamId = BACKUP_REPARSE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "SPAR", 4))
        pStreamId->dwStreamId = BACKUP_SPARSE_BLOCK;
    else {
        pStreamId->dwStreamId = BACKUP_INVALID;
    }

    pStreamId->dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_MODIFIED_BY_READ)
        pStreamId->dwStreamAttributes |= STREAM_MODIFIED_WHEN_READ;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_CONTAINS_SECURITY)
        pStreamId->dwStreamAttributes |= STREAM_CONTAINS_SECURITY;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_IS_SPARSE)
        pStreamId->dwStreamAttributes |= STREAM_SPARSE_ATTRIBUTE;

    // TODO: Handle named data streams (size of name and in MTF stream)
    //       ? How do I know ?

    pStreamId->Size.LowPart  = (DWORD)((pSTREAMInfo->uStreamLength << 32) >>32);
    pStreamId->Size.HighPart = (DWORD)(pSTREAMInfo->uStreamLength >> 32);

}





/***********************************************************************************
* MTF_WriteStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                            BYTE            *pBuffer,     
                            size_t           nBufferSize, 
                            size_t          *pnSizeUsed) 

{

    psStreamInfo->uCheckSum = CalcChecksum((BYTE *) psStreamInfo, sizeof(MTF_STREAM_INFO) / sizeof(UINT16) - 1);

    if (nBufferSize < sizeof(MTF_STREAM_INFO))
    {
        if (pnSizeUsed)
            *pnSizeUsed = sizeof(MTF_STREAM_INFO);
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, sizeof(MTF_STREAM_INFO));
    
    
    *((MTF_STREAM_INFO *) pBuffer) = *psStreamInfo;

    if (pnSizeUsed)
        *pnSizeUsed = sizeof(MTF_STREAM_INFO);


    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_WriteNameStream() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteNameStream(
    char *szType,
    wchar_t *szName,
    BYTE *pBuffer,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    MTF_STREAM_INFO sStream;
    UINT16 uOffsetToCSUMStream;
    UINT16 uOffsetToNextStream;
    size_t nBufUsed;
    UINT16 nameSize;
    UINT32 nameChecksum;

    //
    // Figure the size of the entire Name stream including trailing CSUM and make sure we have room.
    //
    nameSize = (UINT16)wstrsize(szName);  // including terminating '\0'

    uOffsetToCSUMStream = sizeof(MTF_STREAM_INFO) + nameSize;
    uOffsetToCSUMStream = (UINT16)Align(uOffsetToCSUMStream, 4);

    uOffsetToNextStream = uOffsetToCSUMStream;

    uOffsetToNextStream += sizeof(MTF_STREAM_INFO) + 4; // includes 4 byte CSUM data
    uOffsetToNextStream = (UINT16)Align(uOffsetToNextStream, 4);

    if (nBufferSize < uOffsetToNextStream) {
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToNextStream);

    MTF_SetSTREAMDefaults(&sStream, szType);
    sStream.uStreamLength = nameSize;
    sStream.uStreamTapeFormatAttributes |= MTF_STREAM_CHECKSUMED;
    MTF_WriteStreamHeader(&sStream, pBuffer, nBufferSize, &nBufUsed);

    memcpy(pBuffer + nBufUsed, szName, nameSize);

    if ( 0 == memcmp(sStream.acStreamId, "PNAM", 4) ) {
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        //
        int i, iLen;
        wchar_t *szDirectoryName = (wchar_t *) (pBuffer + nBufUsed);

        iLen = wstrsize(szDirectoryName);
        for (i = 0; i < iLen; ++i)
            if (szDirectoryName[i] == L'\\')
                szDirectoryName[i] = L'\0';
    }

    // For Name streams, we always tack on a CSUM

    nameChecksum = CalcChecksumOfStreamData(pBuffer + nBufUsed, nameSize / sizeof(UINT32) + 1);

    MTF_SetSTREAMDefaults(&sStream, MTF_CHECKSUM_STREAM);
    sStream.uStreamLength = sizeof(nameChecksum);
    MTF_WriteStreamHeader(&sStream, pBuffer + uOffsetToCSUMStream, nBufferSize, &nBufUsed);

    memcpy(pBuffer + uOffsetToCSUMStream + nBufUsed, &nameChecksum, sizeof(nameChecksum));

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToNextStream;

    return MTF_ERROR_NONE;
}




/***********************************************************************************
* MTF_ReadStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadStreamHeader(MTF_STREAM_INFO   *psStreamInfo,  
                          BYTE              *pBuffer)    

{
    *psStreamInfo = *((MTF_STREAM_INFO *) pBuffer);
    return MTF_ERROR_NONE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\ntfileio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtFileIo.cpp

Abstract:

    CNtFileIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "NtFileIo.h"
#include "engine.h"
#include "wsbfmt.h"
#include "Mll.h"
#include "ntmsapi.h"
#include "aclapi.h"

int CNtFileIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

#pragma optimize("g", off)

STDMETHODIMP
CNtFileIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hFile = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_isLocalStream = FALSE;
        m_OriginalAttributes = 0;
        m_BlockSize = DefaultBlockSize;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CNtFileIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtFileIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FinalRelease"), OLESTR(""));

    try {

        (void) CloseStream();  // in case anything is left open

        CComObjectRoot::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CNtFileIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtFileIo::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
#pragma optimize("", on)


HRESULT
CNtFileIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CNtFileIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CNtFileIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}



HRESULT
CNtFileIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CNtFileIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CNtFileIo::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//



STDMETHODIMP
CNtFileIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetObjectId"), OLESTR(""));

    UNREFERENCED_PARAMETER(pObjectId);

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_ObjectId;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

  Notes:

    Each Mover session is written as a single MTF file data set. To create a consistant
    MTF data set we copy the MediaLabel data and use it for the TAPE DBLK for
    each data set generated.

--*/
{
    HRESULT hr = S_OK;
    CComPtr<IStream> pStream;

    WsbTraceIn(OLESTR("CNtFileIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    try {
        if (!(options & MVR_SESSION_METADATA)) {
            WsbAssert(remoteDataSet > 0, MVR_E_INVALIDARG);
        }
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        ULARGE_INTEGER nil = {0,0};

        CWsbBstrPtr label, tempLabel;
        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;
        DWORD mode;

        // We need to read the label and use this label for each dataset created.
        // One data set per session.  One data set per remote file.
        WsbAffirmHr(ReadLabel(&label));
        tempLabel = label;
        WsbAssertHr(VerifyLabel(tempLabel));

        // Try recovery, that is look for an indication for an incomplete data-set remote files
        // We continue even if Recovery fails since each data-set is kept in a separate file
        // Note: This code should be protected with CS when we support multiple migration to the SAME media
        (void) DoRecovery ();

        // Create the remote stream used for the entire session.
        // Use given remote session name as the remote file name
        mode = MVR_MODE_WRITE;
        if (options & MVR_SESSION_METADATA) {
            mode |= MVR_FLAG_SAFE_STORAGE;
        }
        WsbAffirmHr(CreateRemoteStream(remoteSessionName, mode, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Create the Recovery indicator (avoid creating for safe-storage files)
        // Note: the Recovery indicator just indicates that a Recovery may be required
        if (! (mode & MVR_FLAG_SAFE_STORAGE)) {
            WsbAssert(m_StreamName != MVR_UNDEFINED_STRING, MVR_E_LOGIC_ERROR);
            WsbAffirmHr(CreateRecoveryIndicator(m_StreamName));
        }

        // Write the TAPE DBLK and filemark
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));

        m_DataSetNumber = remoteDataSet;

        // Convert session option type bits to MTFSessionType
        MTFSessionType type;

        switch (options & MVR_SESSION_TYPES) {
            case MVR_SESSION_TYPE_TRANSFER:
                type = MTFSessionTypeTransfer;
                break;
            case MVR_SESSION_TYPE_COPY:
                type = MTFSessionTypeCopy;
                break;
            case MVR_SESSION_TYPE_NORMAL:
                type = MTFSessionTypeNormal;
                break;
            case MVR_SESSION_TYPE_DIFFERENTIAL:
                type = MTFSessionTypeDifferential;
                break;
            case MVR_SESSION_TYPE_INCREMENTAL:
                type = MTFSessionTypeIncremental;
                break;
            case MVR_SESSION_TYPE_DAILY:
                type = MTFSessionTypeDaily;
                break;
            default:
                type = MTFSessionTypeCopy;
                break;
        }

        // Write the SSET DBLK
        WsbAffirmHr(m_pSession->DoSSETDblk(remoteSessionName, remoteSessionDescription, type, remoteDataSet));

    } WsbCatchAndDo(hr,
        WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_CREATED, 0, NULL, WsbHrAsString(hr), NULL);
        if (pStream) {    
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtFileIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::EndSession"), OLESTR(""));

    try {

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Write the trailing filemark, ESET DBLK, and filemark
        WsbAffirmHr(m_pSession->DoEndOfDataSet(m_DataSetNumber));

    } WsbCatch(hr);

    (void) CloseStream();

    if (! (m_Mode & MVR_FLAG_SAFE_STORAGE)) {
        WsbAssert(m_StreamName != MVR_UNDEFINED_STRING, MVR_E_LOGIC_ERROR);
        (void) DeleteRecoveryIndicator(m_StreamName);
    }

    // If Safe Storage flag is indicated, copy the temporary backup file to the dataset file
    // We copy by delete & rename (instead of copy) so if the dataset file exists, it is consistent
    if ((m_Mode & MVR_FLAG_SAFE_STORAGE) && (m_Mode & MVR_MODE_WRITE || m_Mode & MVR_MODE_APPEND)) {
        CWsbBstrPtr     datasetName;
        int             nLen, nExtLen;
        DWORD           dwStatus;

        // Build dataset name
        nLen = wcslen(m_StreamName);
        nExtLen = wcslen(MVR_SAFE_STORAGE_FILETYPE);
        WsbAffirmHr(datasetName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_DATASET_FILETYPE) + 1));
        wcsncpy(datasetName, m_StreamName, nLen-nExtLen);
        wcscpy(&(datasetName[nLen-nExtLen]), MVR_DATASET_FILETYPE);

        // No need to flush bedore Copy since flush-buffers always follows writing FILEMARKs
        if (! DeleteFile(datasetName)) {
            // DeleteFile may fail with NOT_FOUND if the dataset file is created for the first time
            dwStatus = GetLastError();
            if (ERROR_FILE_NOT_FOUND != dwStatus) {
                WsbAffirmNoError(dwStatus);
            }
        }

        WsbAffirmStatus(MoveFile(m_StreamName, datasetName));
    }

    // Clear internal data (such that another Mover Session could be started)
    m_Flags = 0;
    m_LastVolume = OLESTR("");
    m_LastPath = OLESTR("");
    m_ValidLabel = TRUE;
    m_isLocalStream = FALSE;
    m_OriginalAttributes = 0;

    WsbTraceOut(OLESTR("CNtFileIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER* pRemoteDataSetStart,
    OUT ULARGE_INTEGER* pRemoteFileStart,
    OUT ULARGE_INTEGER* pRemoteFileSize,
    OUT ULARGE_INTEGER* pRemoteDataStart,
    OUT ULARGE_INTEGER* pRemoteDataSize,
    OUT DWORD* pRemoteVerificationType,
    OUT ULARGE_INTEGER* pRemoteVerificationData,
    OUT DWORD* pDatastreamCRCType,
    OUT ULARGE_INTEGER* pDatastreamCRC,
    OUT ULARGE_INTEGER* pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CNtFileIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    WsbTraceAlways(OLESTR("CNtFileIo::StoreData - Begin\n"));
    try {
        MvrInjectError(L"Inject.CNtFileIo::StoreData.0");

        WsbAssertPointer(m_pSession);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Default is to perform non-case sensitive searches.
        // So knock down the posix flag.
        m_Flags &= ~MVR_FLAG_POSIX_SEMANTICS;

        // Default is to not commit after each file.
        // So knock down the commit flag.
        m_Flags &= ~MVR_FLAG_COMMIT_FILE;

        // Default is to write one DIRB containing all directory info
        //  instead of writing a DIRB for each directory level.
        // So knock down the write parent dir info flag.
        m_Flags &= ~MVR_FLAG_WRITE_PARENT_DIR_INFO;

        m_Flags |= flags;
        m_Flags |= MVR_MODE_WRITE;

        // Unconditionally set the case sensitive flag for each file.
        // We allow this flag to be set on a per file basis
        WsbTrace(OLESTR("Posix Semantics Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_POSIX_SEMANTICS & m_Flags));
        WsbAffirmHr(m_pSession->SetUseCaseSensitiveSearch(MVR_FLAG_POSIX_SEMANTICS & m_Flags));

        // This tells the session object to pad to a block boundary and flush the device
        // after the file is written.
        WsbTrace(OLESTR("Commit Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_COMMIT_FILE & m_Flags));
        WsbAffirmHr(m_pSession->SetCommitFile(MVR_FLAG_COMMIT_FILE & m_Flags));

        WsbTrace(OLESTR("ParentDirInfo Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags));

        if ((MVR_FLAG_BACKUP_SEMANTICS & m_Flags) || (MVR_FLAG_HSM_SEMANTICS & m_Flags)) {

            // Compare the volume and path with the last ones written to tape.

            CWsbStringPtr pathname;

            WCHAR *end;
            LONG numChar;

            pathname = localName;

            // strip off the path and file name
            end = wcschr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar =(LONG)(end - (WCHAR *)pathname + 1);  // keep the trailing backslash
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // We do a case sensitive search if using Posix semantics.
            WsbTrace(OLESTR("Comparing with last volume: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastVolume, 120));

            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastVolume, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastVolume, (WCHAR *) pathname))) ) {
                // write the VOLB DBLK
                WsbAffirmHr(m_pSession->DoVolumeDblk(pathname));
                m_LastVolume = pathname;
            }

            pathname = localName;

            // strip off the file name
            end = wcsrchr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar = (LONG)(end - (WCHAR *)pathname);
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // pathname is now in the form "Volume{guid}\dir1\...\dirn"
            //                      or "<drive letter>:\dir1\...\dirn"

/***
   m_Flags |= MVR_FLAG_WRITE_PARENT_DIR_INFO;
***/
            WsbTrace(OLESTR("Comparing with last path: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastPath, 120));

            // We do a case sensitive search if using Posix semantics.
            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastPath, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastPath, (WCHAR *) pathname))) ) {

                if (MVR_FLAG_HSM_SEMANTICS & m_Flags) {

                    // We're not supporting this anymore!
                    WsbThrow(E_NOTIMPL);

                    WCHAR szRoot[16];
                      
                    // We use a flat file structure for MVR_FLAG_HSM_SEMANTICS
                    WsbAffirmHr(m_pSession->SetUseFlatFileStructure(TRUE));

                    // do DIRB DBLKs for root
                    wcscpy(szRoot, L"X:\\");
                    szRoot[0] = localName[0];
                    WsbAffirmHr(m_pSession->DoParentDirectories(szRoot));

                }
                else if (MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags) {
                    // do a DIRB DBLK for each directory level of the file(s) to be backed up.
                    WsbAffirmHr(m_pSession->DoParentDirectories(pathname));
                    m_LastPath = pathname;
                }
                else {
                    // do one DIRB DBLK for the whole directory structure of the file(s) to be backed up.
                    WIN32_FIND_DATAW obFindData;
                    CWsbStringPtr tempPath;

                    DWORD additionalSearchFlags = 0;
                    additionalSearchFlags |= (m_Flags & MVR_FLAG_POSIX_SEMANTICS) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

                    tempPath = pathname;
                    tempPath.Prepend(OLESTR("\\\\?\\"));

                    if (NULL == wcschr((WCHAR *)tempPath+4, L'\\'))
                    {
                        // no path (i.e. we're at the root)
                        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
                        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
                        tempPath.Append(OLESTR("\\"));
                        // ** WIN32 API Calls
                        WsbAffirmHandle(hFile = CreateFile(tempPath, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
                        WsbAffirmStatus(GetFileInformationByHandle(hFile, &obGetFileInfoData));
                        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
                        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
                        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
                        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
                        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
                        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
                        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;
                    }
                    else {
                        // ** WIN32 API Call - gets file info
                        WsbAffirmHandle(hSearchHandle = FindFirstFileEx((WCHAR *) tempPath, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));
                    }
                    WsbAffirmHr(m_pSession->DoDirectoryDblk((WCHAR *) pathname, &obFindData)); 
                    if (hSearchHandle != INVALID_HANDLE_VALUE) {
                        FindClose(hSearchHandle);
                        hSearchHandle = INVALID_HANDLE_VALUE;
                    }
                    if (hFile != INVALID_HANDLE_VALUE) {
                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                    m_LastPath = pathname;
                }
            }
        }

        // The following uses code to store multiple files, but the 
        // RS Hints is only valid for the last file.  With the current
        // implementation, the HSM engine sends one file request through
        // StoreData at a time.  The caveat is that Posix is case
        // sensitive, and therefore files created in this fashion could
        // overload the same filename (ignoring case) with multiple files.
        WsbAffirmHr(m_pSession->DoDataSet(localName));

        *pRemoteDataSetStart     = m_pSession->m_sHints.DataSetStart;
        *pRemoteFileStart        = m_pSession->m_sHints.FileStart;
        *pRemoteFileSize         = m_pSession->m_sHints.FileSize;
        *pRemoteDataStart        = m_pSession->m_sHints.DataStart;
        *pRemoteDataSize         = m_pSession->m_sHints.DataSize;
        *pRemoteVerificationType = m_pSession->m_sHints.VerificationType;
        *pRemoteVerificationData = m_pSession->m_sHints.VerificationData;
        *pDatastreamCRCType      = m_pSession->m_sHints.DatastreamCRCType;
        *pDatastreamCRC          = m_pSession->m_sHints.DatastreamCRC;
        *pUsn                    = m_pSession->m_sHints.FileUSN;

    } WsbCatchAndDo(hr,

            if (hSearchHandle != INVALID_HANDLE_VALUE) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            WsbLogEvent(MVR_MESSAGE_DATA_TRANSFER_ERROR, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);

            // All fatal device errors are converted to E_ABORT so the calling code
            // can detect this general class of problem.
            switch(hr) {
            case MVR_E_BUS_RESET:
            case MVR_E_MEDIA_CHANGED:
            case MVR_E_NO_MEDIA_IN_DRIVE:
            case MVR_E_DEVICE_REQUIRES_CLEANING:
            case MVR_E_SHARING_VIOLATION:
            case MVR_E_ERROR_IO_DEVICE:
            case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
            case MVR_E_ERROR_NOT_READY:
                hr = E_ABORT;
                break;

            case MVR_E_INVALID_BLOCK_LENGTH:
            case MVR_E_WRITE_PROTECT:
            case MVR_E_CRC:
                hr = MVR_E_MEDIA_ABORT;
                break;

            default:
                break;
            }

        );

    WsbTraceAlways(OLESTR("CNtFileIo::StoreData - End\n"));


    WsbTraceOut(OLESTR("CNtFileIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::RecallData (
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*options*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::RecallData"), OLESTR(""));

    try {

        WsbThrow( E_NOTIMPL );

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        CWsbStringPtr strGuid;

        WsbAssertPointer(pLabel);
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        // Media Label or Description
        CWsbBstrPtr label;

        // Tag
        label = OLESTR("MTF Media Label"); // Required text per MTF specification.

        // Version
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MAJOR)));
        WsbAffirmHr(label.Append(OLESTR(".")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MINOR)));

        // Vendor
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MTF_VENDOR_NAME));

        // Vendor Product ID
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MLL_SOFTWARE_NAME));

        // Creation Time Stamp
        WsbAffirmHr(label.Append(OLESTR("|")));
        WCHAR timeStamp[128];
        time_t lTime;
        time(&lTime);
        wcsftime(timeStamp, 128, L"%Y/%m/%d.%H:%M:%S", localtime(&lTime));
        WsbAffirmHr(label.Append(timeStamp));

        // Cartridge Label
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use barcode if available
            CWsbBstrPtr barcode;
            if (S_OK == m_pCartridge->GetBarcode(&barcode)) {
                WsbAffirmHr(label.Append(barcode));
            }
            else {
                WsbAffirmHr(label.Append(displayName));
            }
        }
        else {
            WsbAffirmHr(label.Append(displayName));
        }

        // Side
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // TODO: This is broken, we need to know if the cartridge is inverted?
            if (S_OK == m_pCartridge->IsTwoSided()) {
                WsbAffirmHr(label.Append(OLESTR("2")));
            }
            else {
                WsbAffirmHr(label.Append(OLESTR("1")));
            }
        }
        else {
            WsbAffirmHr(label.Append(OLESTR("1")));  // Default
        }

        // Media Id
        GUID cartId;
        WsbAffirmHr(label.Append(OLESTR("|")));

        if (m_pCartridge) {

            // Use cartridge Id
            if (S_OK == m_pCartridge->GetCartridgeId(&cartId)) {
                WsbAffirmHr(WsbSafeGuidAsString(cartId, strGuid));
            }
            else {
                WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
            }
        }
        else {
            WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
        }
        WsbAffirmHr(label.Append(strGuid));

        // Media Domain Id
        GUID mediaSetId;
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use MediaSet Id
            if (S_OK == m_pCartridge->GetMediaSetId(&mediaSetId)) {
                WsbAffirmHr(WsbSafeGuidAsString(mediaSetId, strGuid));
            }
            else {
                WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
            }
        }
        else {
            WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
        }
        WsbAffirmHr(label.Append(strGuid));

        // Vendor Specific
        WsbAffirmHr(label.Append(OLESTR("|VS:DisplayName=")));
        WsbAffirmHr(label.Append(displayName));

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtFileIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    CComPtr<IStream> pStream;
    HRESULT hr = S_OK;

    CWsbBstrPtr DirName;
    PSID pAdminSID = NULL;
    PSID pSystemSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     REMOTE_DIR_NUM_ACE      2
    EXPLICIT_ACCESS ea[REMOTE_DIR_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;

    WsbTraceIn(OLESTR("CNtFileIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;
        ULARGE_INTEGER nil = {0,0};

        // WriteLabel should be the first access to the remote media. 
        // Therefore, some media initialization is done here:
        //  1) Formatting the volume
        //  2) Creating RSS directory
        //  (We may consider moving this initialization part to rms unit)

        // Initialize volume (format in case of Removable Disk)
        UINT type = GetDriveType(m_DeviceName);
        switch (type) {
        case DRIVE_REMOVABLE: {
            // Format the volume on the media
            WCHAR *driveName = 0;
            WsbAffirmHr(m_DeviceName.CopyTo(&driveName));

            // Remove trailing backslash from drive name
            int len = wcslen(driveName);
            WsbAffirm(len > 0, E_UNEXPECTED);
            if (driveName[len-1] == OLECHAR('\\')) {
                driveName[len-1] = OLECHAR('\0');
            }

            // If the volume is already formatted to NTFS, perform a quick format
            BOOLEAN bQuickFormat = FALSE;
            BOOLEAN bNoFS = FALSE;
            WCHAR fileSystemType[MAX_PATH];

            if (! GetVolumeInformation((WCHAR *)m_DeviceName, NULL, 0,
                NULL, NULL, NULL, fileSystemType, MAX_PATH) ) {
                DWORD status = GetLastError();
                if (ERROR_UNRECOGNIZED_VOLUME == status) {
                    status = NO_ERROR;
                    bNoFS = TRUE;
                }
                if (status != NO_ERROR) {
                    hr = HRESULT_FROM_WIN32(status);
                    if (! SUCCEEDED(hr)) {
                        WsbFree(driveName);
                        WsbAffirmHr(hr);
                    }
                }
            }

            if ( (! bNoFS) && (0 == wcscmp(L"NTFS", fileSystemType)) ) {
                bQuickFormat = TRUE;
                WsbTrace(OLESTR("CNtFileIo::WriteLabel: Quick formatting %ls to NTFS\n"), driveName);
            } else {
                WsbTrace(OLESTR("CNtFileIo::WriteLabel: Full formatting %ls to NTFS\n"), driveName);
            }

            hr = FormatPartition(driveName,                          // drive name
                                        FSTYPE_NTFS,                        // format to NTFS
                                        MVR_VOLUME_LABEL,                   // colume label
                                        WSBFMT_ENABLE_VOLUME_COMPRESSION,   // enable compression
                                        bQuickFormat,                       // Full or Quick format
                                        TRUE,                               // Force format
                                        0);                                // Use default allocation size

            WsbTrace(OLESTR("CNtFileIo::WriteLabel: Finish formatting hr=<%ls>\n"), WsbHrAsString(hr));

            if (! SUCCEEDED(hr)) {
                CWsbBstrPtr name;
                m_pCartridge->GetName(&name);

                WsbLogEvent(MVR_MESSAGE_MEDIA_FORMAT_FAILED, 0, NULL, driveName, WsbHrAsString(hr), (WCHAR *)name, NULL);
                WsbFree(driveName);
                WsbAffirmHr(hr);
            }

            WsbFree(driveName);

            break;
            }

        case DRIVE_FIXED:
            // Delete files from RS remote directory
            WsbAffirmHr(DeleteAllData());
            break;

        case DRIVE_CDROM:
        case DRIVE_UNKNOWN:
        case DRIVE_REMOTE:
        case DRIVE_RAMDISK:
        default:
            WsbAssertHr(E_UNEXPECTED);
            break;
        }

        // Prepare security attribute for admin only access:
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * REMOTE_DIR_NUM_ACE);

        // Create a SID for the local system account
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        // Create a SID for the Administrators group.
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &pAdminSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[1].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[1].Trustee.pMultipleTrustee = NULL;
        ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

        // Create a new ACL that contains the new ACEs.
        WsbAffirmNoError( SetEntriesInAcl(REMOTE_DIR_NUM_ACE, ea, NULL, &pACL));

        // Initialize a security descriptor.  
        pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
        WsbAffirmPointer(pSD);
        WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
        // Add the ACL to the security descriptor. 
        WsbAffirmStatus(SetSecurityDescriptorDacl
                            (pSD, 
                            TRUE,     // fDaclPresent flag   
                            pACL, 
                            FALSE));   // not a default DACL 

        // Initialize a security attributes structure.
        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

        // In case of removable media - put strong acl on the root directory as well
        if (type == DRIVE_REMOVABLE) {
            WsbAffirmWin32(SetNamedSecurityInfo(m_DeviceName, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, 
                                NULL, NULL, pACL, NULL));
        }

        // Create the RSS directory with Admin Only access
        WsbAffirmHr(GetRemotePath(&DirName));

        if (! CreateDirectory(DirName, &sa)) {
            DWORD status = GetLastError();
            if ((status == ERROR_ALREADY_EXISTS) || (status == ERROR_FILE_EXISTS)) {
                // Directory already exists on remote media - ignore it
                status = NO_ERROR;
            }
            WsbAffirmNoError(status);
        }

        // Create the remote stream. Use fixed named for the media label file
        WsbAffirmHr(CreateRemoteStream(MVR_LABEL_FILENAME, MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Write the TAPE DBLK and filemark
        WsbAssertPointer(m_pSession);
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));
        WsbAffirmHr(CloseStream());
        pStream = NULL;

        // Now verify the label
        CWsbBstrPtr tempLabel;
        WsbAffirmHr(ReadLabel(&tempLabel));
        WsbAffirmHr(VerifyLabel(tempLabel));

        // Now that the tape header is written, we update the cartridge info.
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->SetOnMediaLabel(label));
            WsbAffirmHr(m_pCartridge->SetBlockSize(m_BlockSize));

            // For files systems we ignore the TAPE DBLK identifier, and use file system info.
            NTMS_FILESYSTEM_INFO fsInfo;
            DWORD filenameLength;
            DWORD fileSystemFlags;

            WsbAffirmStatus(GetVolumeInformation( (WCHAR *)m_DeviceName, fsInfo.VolumeName, 64,
                &fsInfo.SerialNumber, &filenameLength, &fileSystemFlags, fsInfo.FileSystemType, 256));
            WsbAffirmHr(m_pCartridge->SetOnMediaIdentifier((BYTE *)&fsInfo, sizeof(NTMS_FILESYSTEM_INFO), RmsOnMediaIdentifierWIN32));
        }

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    // Cleanup security allocations
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pSystemSID) 
        FreeSid(pSystemSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        WsbFree(pSD);
    
    WsbTraceOut(OLESTR("CNtFileIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::ReadLabel(
    IN OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::ReadLabel"), OLESTR(""));

    CComPtr<IStream> pStream;

    try {
        WsbAssertPointer(pLabel);
        WsbAssert(m_BlockSize > 0, MVR_E_LOGIC_ERROR);

        // Read the MTF TAPE DBLK, and pull out the label.
        ULARGE_INTEGER nil = {0,0};

        // Create remote stream of copy
        WsbAffirmHr(CreateRemoteStream(MVR_LABEL_FILENAME, MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Read label
        CWsbStringPtr label;
        WsbAffirmHr(m_pSession->ReadTapeDblk(&label));

        WsbAffirmHr(CloseStream());
        pStream = NULL;

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtFileIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtFileIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::VerifyLabel"), OLESTR("<%ls>"), label);

    GUID mediaId[2];

    try {
        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        //
        // To verify a label we assert that the on-media Id matches the cartridge Id.
        //
        // From the media label we obtain the on-media Id.
        //
        WCHAR delim[] = OLESTR("|");
        WCHAR *token;
        int index = 0;

        token = wcstok((WCHAR *)label, delim);  // !!! This toasts the string !!!
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1:  // Tag
            case 2:  // Version
            case 3:  // Vendor
            case 4:  // Vendor Product ID
            case 5:  // Creation Time Stamp
            case 6:  // Cartridge Label
            case 7:  // Side
                break;
            case 8:  // Media ID
                WsbGuidFromString(token, &mediaId[0]);
                break;
            case 9:  // Media Domain ID
            default: // Vendor specific of the form: L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        if (m_pCartridge) {
            //
            // Now compare on-media Id taken from the label to the cartridge's object Id.
            //
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&mediaId[1]));
            WsbAffirm(mediaId[0] == mediaId[1], MVR_E_UNEXPECTED_MEDIA_ID_DETECTED);
        }

        m_ValidLabel = TRUE;

    } WsbCatchAndDo(hr,
            m_ValidLabel = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;
            if ( m_pCartridge ) {
                m_pCartridge->GetName(&name);
                m_pCartridge->GetDescription(&desc);
            }
            WsbLogEvent(MVR_MESSAGE_ON_MEDIA_ID_VERIFY_FAILED, 2*sizeof(GUID), mediaId,
                (WCHAR *) name, (WCHAR *) desc, WsbHrAsString(hr), NULL);
        );


    WsbTraceOut(OLESTR("CNtFileIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::GetDeviceName(
    OUT BSTR* pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr(m_DeviceName.CopyToBstr(pName));

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::SetDeviceName(
    IN BSTR name,
    IN BSTR /*unused*/)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(name);

        m_DeviceName = name;

    } WsbCatch(hr);

    return S_OK;
}


STDMETHODIMP
CNtFileIo::GetLargestFreeSpace(
    OUT LONGLONG* pFreeSpace,
    OUT LONGLONG* pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh
    )
/*++

Implements:

    IDataMover::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetLargestFreeSpace"), OLESTR(""));

    UNREFERENCED_PARAMETER(defaultFreeSpaceLow);
    UNREFERENCED_PARAMETER(defaultFreeSpaceHigh);

    LONGLONG capacity = MAXLONGLONG;
    LONGLONG remaining = MAXLONGLONG;

    try {
        // Note: Fot File I/O, we currentlym always go to the file system to query 
        //  for free space and capacity and avoid internal counting like in tape.
        // If we want to use internal counting (IRmsStorageInfo interface of m_pCartridge),
        //  then we need to maintain it by calling IncrementBytesWritten when appropriate

        ULARGE_INTEGER freeSpaceForCaller;
        ULARGE_INTEGER totalCapacity;
        ULARGE_INTEGER totalFreeSpace;

        capacity = MAXLONGLONG;
        remaining = MAXLONGLONG;

        try {
            // WIN32 - get disk free space
            WsbAffirmStatus(GetDiskFreeSpaceEx( m_DeviceName, &freeSpaceForCaller, &totalCapacity, &totalFreeSpace));
            capacity = totalCapacity.QuadPart;
            remaining = freeSpaceForCaller.QuadPart;

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_GETFREESPACE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapFileError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

    } WsbCatch(hr);

    // Fill in the return parameters
    if ( pCapacity ) {
        *pCapacity = capacity;
    }

    if ( pFreeSpace ) {
        *pFreeSpace = remaining;
    }

    WsbTraceOut(OLESTR("CNtFileIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>, free=%I64u, capacity=%I64u"), WsbHrAsString(hr), remaining, capacity);

    return hr;
}

STDMETHODIMP
CNtFileIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    WsbTraceOut(OLESTR("CNtFileIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::GetCartridge(
    OUT IRmsCartridge** ptr
    )
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( ptr );

        *ptr = m_pCartridge;
        m_pCartridge.p->AddRef();

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::SetCartridge(
    IN IRmsCartridge* ptr
    )
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( ptr );

        if ( m_pCartridge )
            m_pCartridge = 0;

        m_pCartridge = ptr;

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Cancel"), OLESTR(""));

    try {
        (void) Revert();
        (void) CloseStream();
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CreateLocalStream(
    IN BSTR name,
    IN DWORD mode,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );
        WsbAffirm( mode & MVR_MODE_WRITE, E_UNEXPECTED ); // Only Recall or Restore supported this way.

        FILE_BASIC_INFORMATION      basicInformation;
        IO_STATUS_BLOCK             IoStatusBlock;

        m_Mode = mode;
        m_StreamName = name;
        m_isLocalStream = TRUE;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_OriginalAttributes = GetFileAttributes(name);
        if ( 0xffffffff == m_OriginalAttributes ) { 
            WsbAssertNoError(GetLastError());
        } else if ( m_OriginalAttributes & FILE_ATTRIBUTE_READONLY ) {
            //
            // Set it to read/write 
            //
            WsbAssertStatus(SetFileAttributes(m_StreamName, m_OriginalAttributes & ~FILE_ATTRIBUTE_READONLY));
        }

        DWORD posixFlag = (m_Mode & MVR_FLAG_POSIX_SEMANTICS) ? FILE_FLAG_POSIX_SEMANTICS : 0;

        if ( m_Mode & MVR_FLAG_HSM_SEMANTICS ) {
            //
            // Recall - File must already exits!
            //

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                NULL));

            //
            // Mark the USN source for this handle (So content indexing knows there is no real change)
            //
            WsbAffirmHr(WsbMarkUsnSource(m_hFile, m_DeviceName));

        } else {
            //
            // Restore
            //

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                NULL));
        }

        //
        // Set the time flags so that when we close the handle the
        // times are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        WsbAffirmNtStatus(NtQueryInformationFile(m_hFile,
            &IoStatusBlock,
            (PVOID)&basicInformation,
            sizeof(basicInformation),
            FileBasicInformation));

        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;

        WsbAffirmNtStatus(NtSetInformationFile(m_hFile,
            &IoStatusBlock,
            (PVOID)&basicInformation,
            sizeof(basicInformation),
            FileBasicInformation));

        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface(IID_IStream, (void **) ppStream));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(remoteSessionDescription);

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateRemoteStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );

        m_Mode = mode;
        WsbAffirmHr(GetRemotePath(&m_StreamName));

        // Use given name as file-name here, use remoteSessionName only if name is NULL
        if (name && (0 < wcslen((WCHAR *)name))) {
            WsbAffirmHr(m_StreamName.Append(name));
        } else {
            WsbAffirmHr(m_StreamName.Append(remoteSessionName));
        }

        // Add file extension
        // Note: In case of safe storage, we write to a temporary file.
        //       After a successful store, we rename the temporary file to the real file name
        if ((m_Mode & MVR_FLAG_SAFE_STORAGE) && (m_Mode & MVR_MODE_WRITE || m_Mode & MVR_MODE_APPEND)) {
            WsbAffirmHr(m_StreamName.Append(MVR_SAFE_STORAGE_FILETYPE));
        } else {
            WsbAffirmHr(m_StreamName.Append(MVR_DATASET_FILETYPE));
        }

        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = remoteDataSize.QuadPart;

        WsbTrace(OLESTR("CNtFileIo::CreateRemoteStream: Creating <%ls>\n"), (WCHAR *)m_StreamName);

        if (m_Mode & MVR_FLAG_HSM_SEMANTICS || m_Mode & MVR_MODE_READ) {
            //
            // File must already exists!
            //
            DWORD dwFlags = FILE_ATTRIBUTE_NORMAL;
            if (m_Mode & MVR_FLAG_NO_CACHING) {
                dwFlags |= FILE_FLAG_NO_BUFFERING;
            }

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                dwFlags,
                NULL));

        } else if (m_Mode & MVR_MODE_RECOVER) {
            //
            // Open for R/W an already existsing file
            //
            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,  // cannot use FILE_FLAG_NO_BUFFERING here !!
                NULL));

        } else {
            //
            // Create Data Set or Media Label
            //
            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                NULL));

        }

        // Create and initialize an MTF Session object
        CComPtr<IStream> pStream;
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface( IID_IStream, (void **) &pStream));

        WsbAssert(NULL == m_pSession, MVR_E_LOGIC_ERROR);
        m_pSession = new CMTFSession();
        WsbAssertPointer(m_pSession);

        m_pSession->m_pStream = pStream;

        m_pSession->m_sHints.DataSetStart.QuadPart = remoteDataSetStart.QuadPart;
        m_pSession->m_sHints.FileStart.QuadPart = remoteFileStart.QuadPart;
        m_pSession->m_sHints.FileSize.QuadPart = remoteFileSize.QuadPart;
        m_pSession->m_sHints.DataStart.QuadPart = remoteDataStart.QuadPart;
        m_pSession->m_sHints.DataSize.QuadPart = remoteDataSize.QuadPart;
        m_pSession->m_sHints.VerificationType = remoteVerificationType;
        m_pSession->m_sHints.VerificationData.QuadPart = remoteVerificationData.QuadPart;

        // Set block size according to device sector size
        //  (On FS-based media, the sector size is fixed, therefore we ignore the cached value in the cartridge record)
        DWORD dummy1, dummy2, dummy3;
        WsbAffirmStatus(GetDiskFreeSpace(m_DeviceName, &dummy1, &m_BlockSize, &dummy2, &dummy3));
        WsbAssert((m_BlockSize % 512) == 0, E_UNEXPECTED);  

        WsbTrace( OLESTR("Setting Block Size to %d bytes/block.\n"), m_BlockSize);

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetBlockSize(m_BlockSize));

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetUseSoftFilemarks(TRUE));

        if (m_Mode & MVR_MODE_APPEND) {
            // Sets the current position to the end of data.
            LARGE_INTEGER zero = {0,0};
            WsbAffirmHr(pStream->Seek(zero, STREAM_SEEK_END, NULL));
        }

        *ppStream = pStream;
        pStream.p->AddRef();

    } WsbCatchAndDo(hr,
            (void) CloseStream();
            WsbLogEvent(MVR_MESSAGE_DATA_SET_FILE_ERROR, 0, NULL, (WCHAR *)m_StreamName, WsbHrAsString(hr), NULL);
        );

    WsbTraceOut(OLESTR("CNtFileIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CloseStream"), OLESTR(""));

    try {

        if (m_hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }

        if (m_isLocalStream) {
            if (m_OriginalAttributes & FILE_ATTRIBUTE_READONLY) {
                //
                // Set it back to read only
                WsbAssertStatus(SetFileAttributesW(m_StreamName, m_OriginalAttributes));
            }
        }

        if (m_pSession) {
            delete m_pSession;
            m_pSession = NULL;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Duplicate(
    IN IDataMover* pDestination,
    IN DWORD options,
    OUT ULARGE_INTEGER* pBytesCopied,
    OUT ULARGE_INTEGER* pBytesReclaimed)
/*++

Implements:

    IDataMover::Duplicate

Notes:

      1) The method uses an internal copy method instead of CopyFile since CopyFile makes wrong assumptions on
      whether a copy is feasible based on the file-size and target volume size (ignores compression factor for example).

      2) It is assumed that for RSS data-set files, only the unnamed data stream should be copied.
      Otherwise, the internal copy method that Duplicate calls for each file needs to be changed.

      3) The method uses the MVR_RECOVERY_FILETYPE files to mark (on the copy-media) a file that is
      in the middle of copy. In case of a crash, the next time the function runs it will identify
      such a case and delete the partial file.

--*/
{
    ULARGE_INTEGER bytesCopied = {0,0};
    ULARGE_INTEGER bytesReclaimed = {0,0};

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::Duplicate"), OLESTR(""));

    try {
        CWsbBstrPtr dirName;
        CWsbBstrPtr copyDirName;
        CWsbStringPtr nameSpace;
        CWsbStringPtr nameSpacePrefix;
        CWsbStringPtr originalFile;
        CWsbStringPtr copyFile;
        CWsbStringPtr specificFile;
        BOOL bRefresh;

        WIN32_FIND_DATA findData;
        BOOL bMoreFiles = TRUE;

        bRefresh = (options & MVR_DUPLICATE_REFRESH) ? TRUE : FALSE;

        // Check if recovery is needed on the master media before duplicating the media
        // We continue even if Recovery fails
        (void) DoRecovery ();

        // Get remote path of original and copy
        WsbAffirmHr(GetRemotePath(&dirName));
        WsbAffirmHr(pDestination->GetDeviceName(&copyDirName));
        WsbAffirmHr(copyDirName.Append(MVR_RSDATA_PATH));

        // Traverse directory (traverse only MTF files)
        nameSpacePrefix = dirName;
        WsbAffirmHr(nameSpacePrefix.Prepend(OLESTR("\\\\?\\")));
        WsbAffirmHr(nameSpacePrefix.Append(OLESTR("*")));
        nameSpace = nameSpacePrefix;
        WsbAffirmHr(nameSpace.Append(MVR_DATASET_FILETYPE));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        // Copy only non-existing data-set (BAG) files
        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            if ( (0 == (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                 (0 != wcsncmp(findData.cFileName, MVR_LABEL_FILENAME, wcslen(MVR_LABEL_FILENAME))) ) {
                originalFile = dirName;
                WsbAffirmHr(originalFile.Append(findData.cFileName));
                copyFile = copyDirName;
                WsbAffirmHr(copyFile.Append(findData.cFileName));

                // Test for an incomplete copy from a previous session
                WsbAffirmHr(TestRecoveryIndicatorAndDeleteFile(copyFile));

                // Create a recovery indicator file for crash consistency on the copy media
                WsbAffirmHr(CreateRecoveryIndicator(copyFile));

                // Copy
                hr = InternalCopyFile(originalFile, copyFile, (! bRefresh));

                // Delete the recovery indicator file
                (void) DeleteRecoveryIndicator(copyFile);

                if (! SUCCEEDED(hr)) {
                    if ( (! bRefresh) &&
                         ((HRESULT_CODE(hr) == ERROR_ALREADY_EXISTS) || (HRESULT_CODE(hr) == ERROR_FILE_EXISTS)) ) {
                        // File already exists on remote media - ignore it
                        hr = S_OK;
                    }
                    WsbAffirmHr(hr);
                } else {
                    // Increase counter only if a file is really copied
                    bytesCopied.HighPart += findData.nFileSizeHigh;
                    bytesCopied.LowPart += findData.nFileSizeLow;
                }

            }

            bMoreFiles = FindNextFile(hSearchHandle, &findData);
        }

        if (INVALID_HANDLE_VALUE != hSearchHandle) {
            FindClose(hSearchHandle);
            hSearchHandle = INVALID_HANDLE_VALUE;
        }

        // Copy safe-storage backup files (if exist, usually they don't)
        bMoreFiles = TRUE;
        nameSpace = nameSpacePrefix;
        WsbAffirmHr(nameSpace.Append(MVR_SAFE_STORAGE_FILETYPE));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            if ( (0 == (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) ) {
                originalFile = dirName;
                WsbAffirmHr(originalFile.Append(findData.cFileName));
                copyFile = copyDirName;
                WsbAffirmHr(copyFile.Append(findData.cFileName));

                WsbAffirmHr(InternalCopyFile(originalFile, copyFile, FALSE));
            }

            bMoreFiles = FindNextFile(hSearchHandle, &findData);
        }

        // Copy specific files (currently, only HSM metadata file)
        specificFile = HSM_METADATA_NAME;
        WsbAffirmHr(specificFile.Append(MVR_DATASET_FILETYPE));
        originalFile = dirName;
        WsbAffirmHr(originalFile.Append(specificFile));
        copyFile = copyDirName;
        WsbAffirmHr(copyFile.Append(specificFile));

        hr = InternalCopyFile(originalFile, copyFile, FALSE);
        if (! SUCCEEDED(hr)) {
            if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND) {
                // Original file may not exist
                hr = S_OK;
            }
            WsbAffirmHr(hr);
        } 

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }

    // Set output params
    if ( pBytesCopied ) {
        pBytesCopied->QuadPart = bytesCopied.QuadPart;
    }
    if ( pBytesReclaimed ) {
        pBytesReclaimed->QuadPart = bytesReclaimed.QuadPart;
    }

    WsbTraceOut(OLESTR("CNtFileIo::Duplicate"), OLESTR("hr = <%ls>, bytesCopied=%I64u, bytesReclaimed=%I64u"),
        WsbHrAsString(hr), bytesCopied.QuadPart, bytesReclaimed.QuadPart);

    return hr;
}



STDMETHODIMP
CNtFileIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FlushBuffers"), OLESTR(""));

    try {

        // Pad to the next physical block boundary and flush the filesystem buffer.
        // Note: The session object calls Commit which flush the data
        WsbAffirmHr(m_pSession->ExtendLastPadToNextPBA());

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CNtFileIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

  Notes:

Recovery is done by:
1. Verifying existence of initial blocks
2. Skip to data sets (FILE DNLKs)
3. If a data set is incomplete - delete it and write FILEMARK+ESET+FILEMARK
4. If FILEMARK is found, all the data is there, just verify and complete the FILEMARK+ESET+FILEMARK

--*/
{
    HRESULT hr = S_OK;

    *pDeleteFile = FALSE;

    WsbTraceIn(OLESTR("CNtFileIo::Recover"), OLESTR(""));

    try {
        USHORT nDataSetNumber = 0;
        BOOL bForceEset = FALSE;

        // Check first part of the file
        hr = m_pSession->SkipOverTapeDblk();
        if (hr == S_OK) {
            hr = m_pSession->SkipOverSSETDblk(&nDataSetNumber);
        }
        if (hr == S_OK) {
            hr = m_pSession->SkipToDataSet();
        }
        if (hr == S_OK) {
            hr = m_pSession->SkipOverDataSet();
        }

        if (hr == MVR_E_NOT_FOUND) {
            // File is consistent but no remote data was written or first data written was cut
            // Therefore, indicate that file can be deleted altogether and exit
            *pDeleteFile = TRUE;
            hr = S_OK;
            WsbThrow(hr);
        } else {
            // Verify no other unexpected error
            WsbAffirmHr(hr);
        }

        // Skip over data sets until they are done or we find a problem
        while (TRUE) {
            hr = m_pSession->SkipToDataSet();
            if (hr == S_OK) {
                hr = m_pSession->SkipOverDataSet();
                if (hr != S_OK) {
                    bForceEset = TRUE;
                    break;
                }

            // No more data sets
            } else {
                // force re-marking end-of-set unless end-of-set was detected
                if (hr != MVR_S_SETMARK_DETECTED) {
                    bForceEset = TRUE;
                }

                break;
            }
        }

        // Whatever the error is, since we collected at least one legal data set (one
        //  complete migrated file), continueby terminating the file properly
        // TEMPORARY: in case of an 'inconsistent' error should we ignore, terminate, log event
        hr = S_OK;

        // Handle end of set
        if (! bForceEset) {
            // Verify that end-of-data-set is complete
            hr = m_pSession->SkipOverEndOfDataSet();
            if (hr != S_OK) {
                bForceEset = TRUE;
                hr = S_OK;
            }
        }

        if (bForceEset) {
            // End-of-set is missing or incomplete
            WsbAffirmHr(m_pSession->PrepareForEndOfDataSet());
            WsbAffirmHr(m_pSession->DoEndOfDataSet(nDataSetNumber));
            WsbAffirmStatus(SetEndOfFile(m_hFile));
        } 
        
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CNtFileIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead)
/*++

Implements:

    IStream::Read

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesRead = 0;
    ULONG bytesToRead = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);
        WsbAssert(FALSE == m_isLocalStream, E_UNEXPECTED);

        //
        // Read data from disk
        //

        LARGE_INTEGER  loc = {0,0};

        if ( MVR_MODE_UNFORMATTED & m_Mode ) {
            //
            // Set location according to current stream offset
            //  (m_StreamOffset represents here the absolute location to read from)
            //
            loc.QuadPart = m_StreamOffset.QuadPart;

            bytesToRead = cb;
        }
        else if ( MVR_FLAG_HSM_SEMANTICS & m_Mode ) {
            //
            // Set location according to session parameters
            //  (m_StreamOffset represents here an offset into the actual stream-to-read)
            //
            loc.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                             m_pSession->m_sHints.FileStart.QuadPart +
                             m_pSession->m_sHints.DataStart.QuadPart +
                             m_StreamOffset.QuadPart );
            bytesToRead = cb;
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Set Position
        //
        WsbAffirmHr(SetPosition(loc.QuadPart));

        hr = ReadBuffer((BYTE *) pv, cb, &bytesRead);

        if ( FAILED(hr) ) {
            WsbThrow(hr)
        }
        else {
            switch (hr) {
            case MVR_S_FILEMARK_DETECTED:
            case MVR_S_SETMARK_DETECTED:
                m_StreamOffset.QuadPart += (unsigned _int64) m_BlockSize;
                break;
            }
        }

        m_StreamOffset.QuadPart += bytesRead;

        if ( pcbRead ) {
            *pcbRead = bytesRead;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Read"), OLESTR("hr = <%ls> bytes Read = %u, new offset = %I64u"), WsbHrAsString(hr), bytesRead, m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::Write(
    IN void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), 
        cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);

        // Consistency Check
        // UINT64 pos = m_StreamOffset.QuadPart / m_BlockSize;;
        // WsbAffirmHr(EnsurePosition(pos));
        // UINT64 curPos;
        // WsbAffirmHr(GetPosition(&curPos));
        // WsbAssert(curPos == m_StreamOffset.QuadPart / m_BlockSize, E_UNEXPECTED);

        WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));

        if (pcbWritten) {
            *pcbWritten = bytesWritten;
        }

        m_StreamOffset.QuadPart += bytesWritten;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CNtFileIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Seek"), OLESTR("<%I64d> <%d>"), dlibMove.QuadPart, dwOrigin);

    ULARGE_INTEGER newPosition;

    try {

        newPosition.QuadPart = dlibMove.QuadPart;

        //
        // Note: Somewhere it is written that FILE_BEGIN is always and
        //       forever same as STREAM_SEEK_CUR, etc.
        //
        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            newPosition.LowPart = SetFilePointer(m_hFile, dlibMove.LowPart, (long *)&newPosition.HighPart, FILE_BEGIN);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset.QuadPart = dlibMove.QuadPart;
            break;

        case STREAM_SEEK_CUR:
            newPosition.LowPart = SetFilePointer(m_hFile, dlibMove.LowPart, (long *)&newPosition.HighPart, FILE_CURRENT);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset.QuadPart += dlibMove.QuadPart;
            break;

        case STREAM_SEEK_END:
            WsbAssert(0 == dlibMove.QuadPart, STG_E_INVALIDPARAMETER);
            newPosition.LowPart = SetFilePointer(m_hFile, 0, (long *)&newPosition.HighPart, FILE_END);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset = newPosition;
            break;

        default:
            WsbThrow(STG_E_INVALIDFUNCTION);
        }

        WsbAssert(newPosition.QuadPart == m_StreamOffset.QuadPart, MVR_E_LOGIC_ERROR);

        if (plibNewPosition) {
            plibNewPosition->QuadPart = newPosition.QuadPart;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtFileIo::Seek"), OLESTR("hr = <%ls>, newPosition=%I64u"), WsbHrAsString(hr), newPosition.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

Note:
    A lot of the code that is implemented for Tape I/O in the Read method, is 
    implemented here in CopyTo, the method that alloacte the I/O buffer.
    Otherwise, we would have to alloacte an internal buffer in Read and perform
    double copy. In File I/O we want to avoid this for better performance.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    ULARGE_INTEGER totalBytesRead = {0,0};
    ULARGE_INTEGER totalBytesWritten = {0,0};

    BYTE *pBuffer = NULL;
    BYTE *pRealBuffer = NULL;

    try {
        WsbAssert(pstm != 0, STG_E_INVALIDPOINTER);
        WsbAssert(m_BlockSize > 0, MVR_E_LOGIC_ERROR);

        ULONG defaultBufferSize = DefaultMinBufferSize;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG bufferSize;
        ULONG nBlocks = defaultBufferSize/m_BlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_BlockSize;

        // Allocate buffer and make sure its virtual address is aligned with block size
        pRealBuffer = (BYTE *) WsbAlloc(bufferSize+m_BlockSize);
        if (pRealBuffer) {
            if ((ULONG_PTR)pRealBuffer % m_BlockSize) {
                pBuffer = pRealBuffer - ((ULONG_PTR)pRealBuffer % m_BlockSize) + m_BlockSize;
            } else {
                pBuffer = pRealBuffer;
            }
        } else {
            pBuffer = NULL;
        }
        WsbAffirmPointer(pBuffer);
        memset(pBuffer, 0, bufferSize);

        ULONG           bytesToRead;
        ULONG           bytesRead;
        ULONG           bytesWritten;
        ULONG           bytesToSkip;
        ULONG           bytesToCut;
        ULARGE_INTEGER  bytesToCopy;

        bytesToCopy.QuadPart = cb.QuadPart;

        while ((bytesToCopy.QuadPart > 0) && (S_OK == hr)) {
            bytesToRead = 0;
            bytesRead = 0;
            bytesWritten = 0;
            bytesToSkip = 0;
            bytesToCut = 0;

            if ((m_Mode & MVR_FLAG_NO_CACHING) || 
                (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType )) {
                // Must read additional data for alignment and/or CRC check
                ULARGE_INTEGER  loc = {0,0};
                ULONG tempMode;
                ULARGE_INTEGER offsetIntoFile;

                // Set absoulte offset to read from
                if ( MVR_VERIFICATION_TYPE_NONE == m_pSession->m_sHints.VerificationType ) {
                    // No verification - no stream header
                    loc.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                                     m_pSession->m_sHints.FileStart.QuadPart +
                                     m_pSession->m_sHints.DataStart.QuadPart +
                                     m_StreamOffset.QuadPart );

                }  else if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                    // Currently, we don't support CRC checking if you don't read from the beginning of the stream
                    WsbAssert(m_StreamOffset.QuadPart == 0, MVR_E_INVALIDARG);

                    // Position to the stream header and crc it first.
                    loc.QuadPart = (m_pSession->m_sHints.DataSetStart.QuadPart + 
                                    m_pSession->m_sHints.FileStart.QuadPart + 
                                    m_pSession->m_sHints.DataStart.QuadPart - 
                                    sizeof(MTF_STREAM_INFO));
                    bytesToSkip += sizeof(MTF_STREAM_INFO);
                } else {
                    WsbThrow( E_UNEXPECTED );
                }

                // Set absolute place to read from, how many bytes to read and 
                //  how many bytes for skipping to the actual data
                offsetIntoFile.QuadPart = m_StreamOffset.QuadPart;
                m_StreamOffset.QuadPart = loc.QuadPart - (loc.QuadPart % m_BlockSize);
                bytesToSkip += (ULONG)(loc.QuadPart % m_BlockSize);
                if (bytesToCopy.QuadPart > bufferSize) {
                    bytesToRead = bufferSize;
                } else {
                    bytesToRead = bytesToCopy.LowPart;
                    bytesToRead += bytesToSkip;
                    bytesToRead =  (bytesToRead < bufferSize) ? bytesToRead : bufferSize;
                }
                if (bytesToRead % m_BlockSize) {
                    // Expected only when reading the last chunk
                    bytesToCut = m_BlockSize - (bytesToRead % m_BlockSize);
                    bytesToRead = bytesToRead - (bytesToRead % m_BlockSize) + m_BlockSize;
                }

                // Read the aligned data in an 'unformated' Read
                tempMode = m_Mode;                
                m_Mode |= MVR_MODE_UNFORMATTED;
                hr = Read(pBuffer, bytesToRead, &bytesRead);
                m_Mode = tempMode;
                m_StreamOffset.QuadPart = offsetIntoFile.QuadPart;
                if (FAILED(hr)) {
                    WsbThrow(hr);
                }

                if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                    // Peform the CRC check

                    // If for some unexpected reason not enough bytes are read, we skip the CRC check
                    if (bytesToSkip <= bytesRead) {
                        MTF_STREAM_INFO sSTREAM;

                        CMTFApi::MTF_ReadStreamHeader(&sSTREAM, &(pBuffer[bytesToSkip-sizeof(MTF_STREAM_INFO)]));

                        try {
                            // Make sure it is the correct type of header
                            WsbAffirm((0 == memcmp(sSTREAM.acStreamId, MTF_STANDARD_DATA_STREAM, 4)), MVR_E_UNEXPECTED_DATA);
    
                            // Verify the stream header checksum
                            WsbAffirm((m_pSession->m_sHints.VerificationData.QuadPart == sSTREAM.uCheckSum), MVR_E_UNEXPECTED_DATA);

                        } catch (HRESULT catchHr) {
                            hr = catchHr;

                            // Log a detailed error
                            //  Give as attached data the beginning of the buffer which usually contains the FILE DBLK + Stream Info
                            CWsbBstrPtr name;
                            CWsbBstrPtr desc;

                            if (m_pCartridge) {
                                m_pCartridge->GetName(&name);
                                m_pCartridge->GetDescription(&desc);
                            }

                            WCHAR location[32];
                            WCHAR offset[16];
                            WCHAR mark[8];
                            WCHAR found[16];

                            swprintf(found, L"0x%04x", sSTREAM.uCheckSum);
                            swprintf(location, L"%I64u", m_StreamOffset.QuadPart);
                            swprintf(offset, L"%lu", bytesToSkip - sizeof(MTF_STREAM_INFO));
                            swprintf(mark, L"0");

                            WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA,
                                bytesToSkip, pBuffer,
                                found, (WCHAR *)name, (WCHAR *)desc,
                                location, offset, mark, NULL);

                            WsbThrow(hr);
                        }
                    }

                    // CRC check is done only once
                    m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
                }

                // Set file offset, handle unexpected cases where bytesRead<bytesToRead
                if (bytesToCut) {
                    if ((bytesToRead - bytesRead) < bytesToCut) {
                        bytesToCut = bytesToCut - (bytesToRead - bytesRead);
                    } else {
                        bytesToCut = 0;
                    }
                }
                if (bytesRead > bytesToSkip) {
                    m_StreamOffset.QuadPart += (bytesRead - (bytesToSkip+bytesToCut));
                }

            } else {
                // May read only actual data (no alignments) - let default Read to do its job
                bytesToRead =  (bytesToCopy.QuadPart < bufferSize) ? bytesToCopy.LowPart : bufferSize;

                hr = Read(pBuffer, bytesToRead, &bytesRead);
                if (FAILED(hr)) {
                    WsbThrow(hr);
                }
            }

            // Write the data in the output stream and calculate totals
            if (bytesRead > (bytesToSkip+bytesToCut)) {
                totalBytesRead.QuadPart += (bytesRead - (bytesToSkip+bytesToCut));
    
                WsbAffirmHrOk(pstm->Write(pBuffer+bytesToSkip, bytesRead - (bytesToSkip+bytesToCut), &bytesWritten));
                totalBytesWritten.QuadPart += bytesWritten;
    
                bytesToCopy.QuadPart -= (bytesRead - (bytesToSkip+bytesToCut));
            }
        }

        if (pcbRead) {
            pcbRead->QuadPart = totalBytesRead.QuadPart;
        }

        if (pcbWritten) {
            pcbWritten->QuadPart = totalBytesWritten.QuadPart;
        }

    } WsbCatch(hr);

    if (pRealBuffer) {
        WsbFree(pRealBuffer);
        pRealBuffer = NULL;
        pBuffer = NULL;
    }


    WsbTraceOut(OLESTR("CNtFileIo::CopyTo"), OLESTR("hr = <%ls>, bytesRead=%I64u, bytesWritten=%I64u"),
        WsbHrAsString(hr), totalBytesRead.QuadPart, totalBytesWritten.QuadPart);

    return hr;
}

STDMETHODIMP
CNtFileIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Commit"), OLESTR(""));

    try {
        if (STGC_DEFAULT == grfCommitFlags)  {
            WsbAssertStatus(FlushFileBuffers(m_hFile));
        }
        else  {
            WsbThrow(E_NOTIMPL);
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Revert"), OLESTR(""));

    try {

        // TEMPORARY: Setting the mode to 0 currently doesn't prevent any write
        //  which is ongoing. We need to re-visit this issue
        m_Mode = 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//


HRESULT
CNtFileIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        if (!m_isLocalStream) {
            // Must have a valid label!
            WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

            // Making sure that we are writting only full blocks
            WsbAssert(!(nBytesToWrite % m_BlockSize), MVR_E_LOGIC_ERROR);
        }

        try {

            // ** WIN32 Tape API Call - write the data
            WsbAffirmStatus(WriteFile(m_hFile, pBuffer, nBytesToWrite, pBytesWritten, 0));

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_WRITE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapFileError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        if (!m_isLocalStream) {
            // Making sure that we have written only full blocks
            WsbAssert(!(*pBytesWritten % m_BlockSize), E_UNEXPECTED);
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtFileIo::ReadBuffer (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        static WCHAR errBuf[32];
        static BOOL bFirstTime = TRUE;

        // For FileSystem I/O restrictions on reading only full blocks depends on how 
        // the file is opened. Therefore, we don't enforce it here.

        try {

            // ** WIN32 Tape API Call - read the data
            WsbAffirmStatus(ReadFile(m_hFile, pBuffer, nBytesToRead, pBytesRead, 0));

        } WsbCatchAndDo(hr,
                // Get error string once since Read may return a none-OK status which 
                // is not really an error
                if (bFirstTime) {
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_READ) != S_OK) {
                        tmpString = L"";
                    }
                    if (wcslen(tmpString) >= 32) {
                        tmpString = L"";
                    }
                    wcscpy(errBuf, tmpString);
                    bFirstTime = FALSE;
                }

                hr = MapFileError(hr, errBuf);

                if ( FAILED(hr) ) {
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, errBuf, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                }

            );

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtFileIo::GetPosition(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetPosition"), OLESTR(""));

    try {

        WsbThrow(E_NOTIMPL);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), *pPosition);

    return hr;
}


HRESULT
CNtFileIo::SetPosition(
    IN UINT64 position)
/*++

Routine Description:

    Mover to the specified physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetPosition"), OLESTR("<%I64u>"), position);

    ULARGE_INTEGER newPosition;

    try {

        newPosition.QuadPart = position;

        newPosition.LowPart = SetFilePointer(m_hFile, newPosition.LowPart, (long *)&newPosition.HighPart, FILE_BEGIN);
        if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
            WsbAffirmNoError(GetLastError());
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::SetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), newPosition.QuadPart);

    return hr;
}


HRESULT
CNtFileIo::EnsurePosition(
    IN UINT64 position)
/*++

Routine Description:

    Checks that the tape is positioned at the specified current physical block
    address relative to the current partition.  If it is not an attempt is made 
    to recover to the specified position.

Arguments:

    postion     -  The physical block address to verify.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::EnsurePosition"), OLESTR("<%I64u>"), position);

    try {

        WsbThrow(E_NOTIMPL);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::EnsurePosition"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::GetRemotePath(
    OUT BSTR *pDestinationString)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetRemotePath"), OLESTR(""));

    try {
        CWsbBstrPtr tmpString;

        tmpString = m_DeviceName;
        WsbAffirmHr(tmpString.Append(MVR_RSDATA_PATH));

        WsbTrace(OLESTR("RemotePath is <%ls>\n"), (WCHAR *) tmpString);

        // Hand over the string
        WsbAffirmHr(tmpString.CopyToBstr(pDestinationString));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetRemotePath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::DoRecovery(void)
{
    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::DoRecovery"), OLESTR(""));

    try {
        CWsbBstrPtr dirName;
        CWsbStringPtr nameSpace;
        CWsbStringPtr recoveredFile;

        WIN32_FIND_DATA findData;
        BOOL bMoreFiles = TRUE;

        // Traverse remote directory for Recovery Indicator files
        WsbAffirmHr(GetRemotePath(&dirName));
        nameSpace = dirName;
        WsbAffirmHr(nameSpace.Append(OLESTR("*")));
        WsbAffirmHr(nameSpace.Append(MVR_RECOVERY_FILETYPE));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            CComPtr<IDataMover> pMover;
            CComPtr<IStream> pStream;
            CWsbBstrPtr recoveryName;
            ULARGE_INTEGER nil = {0,0};
            int nLen, nExtLen;
            BOOL bDeleteFile = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;

            // Prepare file name to recover
            nLen = wcslen(findData.cFileName);
            nExtLen = wcslen(MVR_RECOVERY_FILETYPE);
            WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + 1));
            wcsncpy(recoveryName, findData.cFileName, nLen-nExtLen);
            recoveryName[nLen-nExtLen] = NULL;

            // Recover - a failure to recover in file doesn't stop from trying to recover others
            try {
                if ( m_pCartridge ) {
                    m_pCartridge->GetName(&name);
                    m_pCartridge->GetDescription(&desc);
                }
                WsbLogEvent(MVR_MESSAGE_INCOMPLETE_DATA_SET_DETECTED, 0, NULL,
                    (WCHAR *)recoveryName, (WCHAR *) name, (WCHAR *) desc, NULL);

                // Create and initializa a data mover
                WsbAssertHr(CoCreateInstance(CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&pMover));

                WsbAffirmHr(pMover->SetDeviceName(m_DeviceName));
                WsbAffirmHr(pMover->SetCartridge(m_pCartridge));

                // Create the stream for Recovery 
                WsbAffirmHr(pMover->CreateRemoteStream(recoveryName, MVR_MODE_RECOVER | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));

                // Perform the actual recovery over the file
                WsbAffirmHr(pMover->Recover(&bDeleteFile));
                (void) pMover->CloseStream();
                pStream = NULL;
                if (bDeleteFile) {
                    // Delete the remote file itself
                    recoveredFile = dirName;
                    WsbAffirmHr(recoveredFile.Append(recoveryName));
                    WsbAffirmHr(recoveredFile.Append(MVR_DATASET_FILETYPE));
                    WsbTrace(OLESTR("CNtFileIo::DoRecovery: Nothing to recover in <%ls> - Deleting file!\n"), (WCHAR *)recoveredFile);
                    WsbAffirmStatus(DeleteFile(recoveredFile));
                }

                WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);

            } WsbCatchAndDo (hr,
                if (pStream) {    
                    (void) pMover->CloseStream();
                    pStream = NULL;
                }
                WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, WsbHrAsString(hr), NULL);
                hr = S_OK;
            );
    
            // Create (for deleting) full name of indicator file
            recoveredFile = dirName;
            WsbAffirmHr(recoveredFile.Append(findData.cFileName));

            // Get next file
            bMoreFiles = FindNextFile(hSearchHandle, &findData);

            // Delete indicator file (independent of the recovery result)
            WsbAffirmStatus(DeleteFile(recoveredFile));
        }

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
    }

    WsbTraceOut(OLESTR("CNtFileIo::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::CreateRecoveryIndicator(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::CreateRecoveryIndicator

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateRecoveryIndicator"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;
        HANDLE  hFile;

        // Generate file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        //Create and immediately close the file
        WsbAffirmHandle(hFile = CreateFile(recoveryName,
            GENERIC_READ,   
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_HIDDEN,
            NULL));

        CloseHandle(hFile);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CreateRecoveryIndicator"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::DeleteRecoveryIndicator(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::DeleteRecoveryIndicator

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::DeleteRecoveryIndicator"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;

        // Generate file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        //Delete the indicator file
        WsbAffirmStatus(DeleteFile(recoveryName));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::DeleteRecoveryIndicator"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::TestRecoveryIndicatorAndDeleteFile(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::TestRecoveryIndicatorAndDeleteFile

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

    The method:
        1) Test if the recovery indicator for the given file exists
        2) If so, it deletes the file
        3) Then, it deleted the recovery indicator

Returns:

    S_OK - If found a recovery indicator and deleted successfully
    S_FALSE - If didn't find a recovery indicator

--*/
{
    HRESULT hr = S_FALSE;
    WsbTraceIn(OLESTR("CNtFileIo::TestRecoveryIndicatorAndDeleteFile"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;

        // Generate recovery-indicator file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        // Test recovery indicator file existance
        HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        hSearchHandle = FindFirstFile(recoveryName, &findData);

        if (INVALID_HANDLE_VALUE != hSearchHandle) {
            FindClose(hSearchHandle);

            hr = S_OK;

            WsbTrace(OLESTR("CNtFileIo::TestRecoveryIndicator... : Found recovery indicator. Therefore, deleting <%ls>\n"),
                        pFileName);

            //Delete the target file itself
            WsbAffirmStatus(DeleteFile(pFileName));

            //Delete the indicator file
            WsbAffirmStatus(DeleteFile(recoveryName));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtFileIo::TestRecoveryIndicatorAndDeleteFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::DeleteAllData(void)
{
    HRESULT hr = S_OK;
    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    WsbTraceIn(OLESTR("CNtFileIo::DeleteAllData"), OLESTR(""));

    try {
        CWsbStringPtr nameSpace;
        CWsbStringPtr pathname;

        WIN32_FIND_DATAW obFindData;
        BOOL bMoreFiles;

        CWsbBstrPtr remotePath;
        WsbAffirmHr(GetRemotePath(&remotePath));
        nameSpace = remotePath;
        nameSpace.Append(OLESTR("*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));

        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, 0);

        for (bMoreFiles = TRUE;
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                // use the remotePath to get the pathname, then append the filename
                pathname = remotePath;
                pathname.Prepend(OLESTR("\\\\?\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmStatus(DeleteFile((WCHAR *)pathname));
            }
        }

    } WsbCatch(hr);

    // close search handle after processing all the files
    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CNtFileIo::DeleteAllData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::FormatDrive(
    IN BSTR label)
/*++

Routine Description:

    Formats a unit of media.

Arguments:

    label - The formatted label returned from FormatLabel().

Return Value:

    S_OK                        - Success.
    E_ABORT                     - Operation aborted.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::FormatDrive"), OLESTR("<%ls>"), (WCHAR *)label);

    PROCESS_INFORMATION exeInfo;
    STARTUPINFO startupInfo;
    memset(&startupInfo, 0, sizeof(startupInfo));

    startupInfo.cb          = sizeof( startupInfo );
    startupInfo.wShowWindow = SW_HIDE;
    startupInfo.dwFlags     = STARTF_USESHOWWINDOW;

    try {

        //
        // Get volumeLabel for the FS from the label parameter
        //

        CWsbBstrPtr volumeLabel = MVR_UNDEFINED_STRING;

        CWsbBstrPtr tempLabel = label;
        WCHAR delim[]   = OLESTR("|");
        WCHAR *token;
        int   index=0;

        token = wcstok( (WCHAR *)tempLabel, delim );
        while( token != NULL ) {
            index++;
            switch ( index ) {
            case 1: // Tag
            case 2: // Version
            case 3: // Vendor
            case 4: // Vendor Product ID
            case 5: // Creation Time Stamp
            case 6: // Cartridge Label
            case 7: // Side
            case 8: // Media ID
            case 9: // Media Domain ID
            default: // Vendor specific of the form L"VS:Name=Value"
                {
                    WCHAR *name = NULL;
                    int nameLen = 0;

                    // DisplayName
                    name = L"VS:DisplayName=";
                    nameLen = wcslen(name);
                    if( 0 == wcsncmp(token, name, nameLen) ) {
                        volumeLabel = &token[nameLen];
                    }
                }
                break;
            }
            token = wcstok( NULL, delim );
        }


        // Build the format command with options:
        // "Format d: /fs:ntfs /force /q /x /v:ROOT_D  > Null:"

        OLECHAR drive[256];
        (void) wcsncpy((WCHAR *)drive, (WCHAR *)m_DeviceName, 2);
        drive[2] = '\0';  // TODO: Fix for no drive letter support

        // NOTE: It's possible that the format command isn't where we
        //       think it is.  The following registry entry allows
        //       an override.

        CWsbBstrPtr formatCmd = RMS_DEFAULT_FORMAT_COMMAND;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_COMMAND, tmpString, 256, &size))) {
            // Get the value.
            formatCmd = tmpString;
        }

        WsbTrace(OLESTR("Using command: <%ls>.\n"), (WCHAR *)formatCmd);

        WsbAffirmHr(formatCmd.Append(L" "));
        WsbAffirmHr(formatCmd.Append(drive));

        CWsbBstrPtr commandLine = formatCmd;

        CWsbBstrPtr formatOpts = RMS_DEFAULT_FORMAT_OPTIONS;

        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS, tmpString, 256, &size))) {
            // Get the value.
            formatOpts = tmpString;
        }

        WsbTrace(OLESTR("Using options: <%ls>.\n"), (WCHAR *)formatOpts);
        
        DWORD formatWaitTime = RMS_DEFAULT_FORMAT_WAIT_TIME;

        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_WAIT_TIME, tmpString, 256, &size))) {
            // Get the value.
            formatWaitTime = wcstol(tmpString, NULL, 10);
        }

        WsbTrace(OLESTR("Using wait time: %d.\n"), formatWaitTime);
        
        int retry = 0;

        do {

            try {

                WsbAffirm(0 == wcslen((WCHAR *)formatOpts), E_UNEXPECTED);

                WsbAffirmHr(commandLine.Append(L" "));
                WsbAffirmHr(commandLine.Append(formatOpts));

                WsbAffirmHr(commandLine.Append(L" /v:"));
                WsbAffirmHr(commandLine.Append(volumeLabel));
                WsbAffirmHr(commandLine.Append(L" > Null:"));

                WsbTrace(OLESTR("Using command: <%ls> to format media.\n"), (WCHAR *)commandLine);
                WsbAffirmStatus(CreateProcess(0, (WCHAR *)commandLine, 0, 0, FALSE, 0, 0, 0, &startupInfo, &exeInfo));
                WsbAffirmStatus(WAIT_FAILED != WaitForSingleObject(exeInfo.hProcess, 20*60*1000));
                break;

            } WsbCatchAndDo(hr,

                retry++;
                commandLine = formatCmd;

                if (retry == 1) {
                    formatOpts = RMS_DEFAULT_FORMAT_OPTIONS_ALT1;

                    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS_ALT1, tmpString, 256, &size))) {
                        // Get the value.
                        formatOpts = tmpString;
                    }
                }
                else if (retry == 2) {
                    formatOpts = RMS_DEFAULT_FORMAT_OPTIONS_ALT2;

                    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS_ALT2, tmpString, 256, &size))) {
                        // Get the value.
                        formatOpts = tmpString;
                    }
                }
                else {
                    WsbThrow(hr);
                }

                WsbTrace(OLESTR("Retrying with otions: <%ls>.\n"), (WCHAR *)formatOpts);

            );

        } while (retry < 3);


    } WsbCatch(hr);

    if (FAILED(hr)) {
        hr = E_ABORT;
    }

    WsbTraceOut(OLESTR("CNtFileIo::FormatDrive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::MapFileError(
    IN HRESULT hrToMap,
    IN WCHAR *pAction)
/*++

Routine Description:

    Maps a WIN32 file error, specified as an HRESULT, to a MVR error.

Arguments:

    hrToMap     -  WIN32 file error to map.
    pAction     -  Action being done while error occured

Return Value:

    S_OK                            - Success.
    MVR_E_BEGINNING_OF_MEDIA        - The beginning of the tape or a partition was encountered.
    MVR_E_BUS_RESET                 - The I/O bus was reset.
    MVR_E_END_OF_MEDIA              - The physical end of the tape has been reached.
    MVR_S_FILEMARK_DETECTED         - A tape access reached a filemark.
    MVR_S_SETMARK_DETECTED          - A tape access reached the end of a set of files.
    MVR_S_NO_DATA_DETECTED          - No more data is on the tape.
    MVR_E_PARTITION_FAILURE         - Tape could not be partitioned.
    MVR_E_INVALID_BLOCK_LENGTH      - When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
    MVR_E_DEVICE_NOT_PARTITIONED    - Tape partition information could not be found when loading a tape.
    MVR_E_MEDIA_CHANGED             - The media in the drive may have changed.
    MVR_E_NO_MEDIA_IN_DRIVE         - No media in drive.
    MVR_E_UNABLE_TO_LOCK_MEDIA      - Unable to lock the media eject mechanism.
    MVR_E_UNABLE_TO_UNLOAD_MEDIA    - Unable to unload the media.
    MVR_E_WRITE_PROTECT             - The media is write protected.
    MVR_E_CRC                       - Data error (cyclic redundancy check).
    MVR_E_SHARING_VIOLATION         - The process cannot access the file because it is being used by another process.
    MVR_E_ERROR_IO_DEVICE           - The request could not be performed because of an I/O device error.                          - Unknown error.
    MVE_E_ERROR_DEVICE_NOT_CONNECTED - The device is not connected.
    MVR_E_DISK_FULL                 - There is insufficient disk space to complete the operation.
    E_ABORT                         - Unknown error, abort.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::MapFileError"), OLESTR("<%ls>"), WsbHrAsString(hrToMap));

    try {

        // The valid label flag is knocked down when the media may have changed
        // or device parameters (i.e. block size) may have been reset.
        switch ( hrToMap ) {
        case S_OK:
            break;
        case HRESULT_FROM_WIN32( ERROR_BEGINNING_OF_MEDIA ):
            hr = MVR_E_BEGINNING_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_BUS_RESET ):
            hr = MVR_E_BUS_RESET;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_END_OF_MEDIA ):
            hr = MVR_E_END_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_FILEMARK_DETECTED ):     // Maps to Success
            hr = MVR_S_FILEMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SETMARK_DETECTED ):      // Maps to Success
            hr = MVR_S_SETMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_DATA_DETECTED ):      // Maps to Success
            // EOD
            // This happens on SpaceFilemarks() past end of data.
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_PARTITION_FAILURE ):
            hr = MVR_E_PARTITION_FAILURE;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_BLOCK_LENGTH ):
            hr = MVR_E_INVALID_BLOCK_LENGTH;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_PARTITIONED ):
            hr = MVR_E_DEVICE_NOT_PARTITIONED;
            break;
        case HRESULT_FROM_WIN32( ERROR_MEDIA_CHANGED ):
            hr = MVR_E_MEDIA_CHANGED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_MEDIA_IN_DRIVE ):
            hr = MVR_E_NO_MEDIA_IN_DRIVE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_LOCK_MEDIA ):
            hr = MVR_E_UNABLE_TO_LOCK_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_UNLOAD_MEDIA ):
            hr = MVR_E_UNABLE_TO_UNLOAD_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_WRITE_PROTECT ):
            hr = MVR_E_WRITE_PROTECT;
            break;
        case HRESULT_FROM_WIN32( ERROR_CRC ): 
            // This is may indicate that the drive needs cleaning.
            hr = MVR_E_CRC;
            break;
        case HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ):
            // This happens when the CreateFile fails because the device is in use by some other app.
            hr = MVR_E_SHARING_VIOLATION;
            break;
        case HRESULT_FROM_WIN32( ERROR_IO_DEVICE ):
            // This happens when the device is turned off during I/O, for example.
            hr = MVR_E_ERROR_IO_DEVICE;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_CONNECTED ):
            // This happens when the device is turned off.
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
            // This happens when the SCSI command does not return within the timeout period.  A system error is logged for the SCSI controler (adapter).
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_DISK_FULL ):
            // There is not enough space on the disk.
            hr = MVR_E_DISK_FULL;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNRECOGNIZED_VOLUME ):
            // This happens when the volume is not formatted to any file system
            hr = MVR_E_UNRECOGNIZED_VOLUME;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ):
            // This happens after a Cancel() operation.
            hr = E_ABORT;
            break;
        default:
            WsbThrow(hrToMap);
        }

    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_UNKNOWN_DEVICE_ERROR, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            hr = E_ABORT;
        );


    WsbTraceOut(OLESTR("CNtFileIo::MapFileError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::InternalCopyFile(
    IN WCHAR *pOriginalFileName, 
    IN WCHAR *pCopyFileName, 
    IN BOOL bFailIfExists)
/*++

Implements:

    CNtFileIo::InternalCopyFile

Notes:

    1) The method copies only the unnamed data stream using Read/Write.
       Currently this is sufficient for RSS .bkf files on a media, however, if we ever use
       other-than-default file characteristics like named streams, per-file security attributes,
       special file attributes, etc. - then we should consider using BackupRead & BackupWrite
       for implementing the internal-copy

    2) If caller ask for bFailIfExists=TRUE, then the method returns HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)

    3) In case of a failure half way through, the method deletes the partial file

--*/
{
    HRESULT hr = S_OK;

    HANDLE hOriginal = INVALID_HANDLE_VALUE;
    HANDLE hCopy = INVALID_HANDLE_VALUE;
    BYTE *pBuffer = NULL;

    WsbTraceIn(OLESTR("CNtFileIo::InternalCopyFile"), OLESTR(""));

    try {
		// Create file on the Original media with no write-sharing - upper level should ensure 
        //  that nobody opens the file for write while a copy-media is going on
        WsbAffirmHandle(hOriginal = CreateFile(pOriginalFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL));

		// Create the file on the Copy media with no sharing at all. Create-disposition 
        //  depends on caller request
        //  Exisitng file would generate ERROR_FILE_EXISTS that should be handled by the caller
        DWORD dwCreationDisposition;
        dwCreationDisposition = bFailIfExists ? CREATE_NEW : CREATE_ALWAYS;
        WsbAffirmHandle(hCopy = CreateFile(pCopyFileName,
                GENERIC_WRITE,
                0,              // no sharing
                NULL,
                dwCreationDisposition,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL));

        // Allocate a buffer for the media copy
        ULONG defaultBufferSize = RMS_DEFAULT_BUFFER_SIZE;
        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_COPY_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }
        pBuffer = (BYTE *)WsbAlloc(defaultBufferSize);
        WsbAffirmAlloc(pBuffer);

        // Read and write in chunks
        //  Synchronous ReadFile should signal eof by returning zero bytes read
        BOOL done = FALSE;
        DWORD dwBytesToRead = defaultBufferSize;
        DWORD dwBytesRead, dwBytesWritten;
        while (! done) {
            WsbAffirmStatus(ReadFile(hOriginal, pBuffer, dwBytesToRead, &dwBytesRead, NULL));

            if (dwBytesRead == 0) {
                // eof
                done = TRUE;
            } else {
                // Write to copy-file
                WsbAffirmStatus(WriteFile(hCopy, pBuffer, dwBytesRead, &dwBytesWritten, NULL));

                if (dwBytesWritten != dwBytesRead) {
                    // Fail the copy
                    WsbTraceAlways(OLESTR("CNtFileIo::InternalCopyFile: writing to copy-file is not completed to-write=%lu, written=%lu - Aborting!\n"),
                            dwBytesRead, dwBytesWritten);
                    WsbThrow(E_FAIL);
                }
            }
        }

        // Flush to media
        WsbAffirmStatus(FlushFileBuffers(hCopy));

    } WsbCatch(hr);

    // Close original file
    if (INVALID_HANDLE_VALUE != hOriginal) {
        CloseHandle(hOriginal);
        hOriginal = INVALID_HANDLE_VALUE;
    }

    // Close copy file
    if (INVALID_HANDLE_VALUE != hCopy) {
        if (! CloseHandle(hCopy)) {
            DWORD dwErr = GetLastError();
            WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: CloseHandle for copy-file failed with error=%lu\n"), dwErr);

            // Set hr only if there was a success so far...
            if (SUCCEEDED(hr)) {
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }

        hCopy = INVALID_HANDLE_VALUE;

        // Delete copy file on any error, including close errors
        if (! SUCCEEDED(hr)) {
            WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: Deleting copy-file <%s> due to an error during the copy\n"),
                        pCopyFileName);

            if (! DeleteFile(pCopyFileName)) {
                DWORD dwErr = GetLastError();
                WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: Failed to delete copy-file, DeleteFile error=%lu\n"), dwErr);
            }
        }

    }

    if (pBuffer) {
        WsbFree(pBuffer);
        pBuffer = NULL;
    }

    WsbTraceOut(OLESTR("CNtFileIo::InternalCopyFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\mtf_api.h ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.h
//
// DESCRIPTION :        api for creating mtf format structures
//                      (see detail description below)
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________

/*****************************************************************************
DETAIL DESCRIPTION

NOTE:  See the file MTF_TST.C for an example showing how to use this API

OVERVIEW
========
The MTF API provides a set of structures, each of which corresponds (but is not
identical to) to the structures described in the Microsoft Tape Format reference 
manual.  The client instanciates these structures, fills in the fields and then 
uses an MTF API function to format the information in the structure into a supplied
buffer in MTF format.  The buffer is then padded up to the next alignment factor
using an MTF API call and then  may then be written to tape using WIN32 Write. 

For example, to write an MTF TAPE DBLK,

1) Instanciate the MTF API structures.  The common header structure is used 
separately so that it can be re-used among DBLK writes
    
    MTF_DBLK_HDR_INFO sHdr;
    MTF_DBLK_TAPE_INFO sTape;

2) Use MTF API set default functions to set default values of these

    MTF_SetDblkHdrDefaults(&sHdr);
    MTF_SetTAPEDefaults(&sTape);

3) Override the default values as necessary

    sHdr.uFormatLogicalAddress = ...
    ...
    sTape.szTapeName = L"MY TAPE!"
    ...

4) Use the MTF API calls to format the contents of these structures into a buffer.
   If the API needs more room than BUFSIZE then then ammount needed is stored in 
   nBufUsed.  Otherwise nBufUsed reflects the amount of space in the buffer 
   used by the call.

    MTF_WriteTAPEDblk(&sHdr,
                      &sTape,
                      pBuffer,
                      BUFSIZE,
                      &nBufUsed);

5) NOTE WELL:  The write calls *DO NOT PAD* to the next alignment index.  But this 
   is easily done using the MTF API call:

    MTF_PadToNextAlignmentFactor(pBuffer,     
                                 nBufUsed,
                                 BUFSIZE, 
                                 &nBufUsed);

6) At this point, nBufUsed % MTF_GetAlignmentFactor should == 0.  If our blocksize
   evenly divides our alignment factor, then we can use the WIN32 Write call to

    WriteFile(hTape, pBuffer, nBufUsed, &nBytesWritten, 0);

   Since our blocksize divides our AF, then nBytesWritten should == nBufUsed

*** SEE THE MTF_TST.C FOR A COMPLETE EXAMPLE SHOWING THE USE OF THIS API TO CREATE
    A BACKUP SET


MTF API DATA STRUCTURE AND FUNCTION SUMMARY
===========================================
===========================================
**summary only -- generic detail comments appear below**


LOW LEVEL TYPES
===============
The following are typedefed to the corresponding "unsigned __intxx"

types:
    UINT8
    UINT16
    UINT32
    UINT64

functions:
MTF_CreateUINT64()  -- creates a 64 bit unsigned from two UINT32 values (lsb & msb)


DATE & TIME
===========
MTF_DATE_TIME                    -- structure used by MTF API for holding packed date & time info 
MTF_CreateDateTimeNull()         -- returns a null MTF_DATE_TIME
MTF_CreateDateTime()             -- creates MTF_DATE_TIME from year, month, day, hour, min, sec
MTF_CreateDateTimeFromTM()       -- creates MTF_DATE_TIME from struct tm in <time.h>
MTF_CreateDateTimeFromFileTime() -- creates MTF_DATE_TIME from FILETIME used by FindFirst/FindNext
MTF_CreateDateTimeToTM()         -- fills in a struct tm structure given an MTF_DATE_TIME struct


ALIGNMENT FACTOR
================
MTF_SetAlignmentFactor           -- sets the alignment factor for the MTF API (you must do this)
MTF_GetAlignmentFactor           -- returns the set alignment factor
MTF_PadToNextAlignmentFactor     -- Pads out a buffer using an SPAD to the next alignment factor
MTF_PadToNextPhysicalBlockBoundary -- Pads out a buffer using an SPAD to the next physical block boundary


MTF COMMON HEADER BLOCK
=======================
MTF_DBLK_HDR_INFO                -- common block header (must be supplied to all calls to write dblks
MTF_SetDblkHdrDefaults           -- sets default values (always call this before you set your own)


MTF TAPE DBLK INFO
==================
MTF_DBLK_TAPE_INFO     -- info corresponding to a TAPE dblk   
MTF_SetTAPEDefaults    -- sets defaults (always do this before setting your own)
MTF_WriteTAPEDblk      -- formats info in MTF_DBLK_TAPE_INFO to tape
MTF_ReadTAPEDblk       -- reads info back from a buffer holding MTF FORMATTED TAPE DBLK


MTF SSET DBLK INFO
==================
MTF_DBLK_SSET_INFO     -- all similar to above but for SSET DBLK
MTF_SetSSETDefaults    -- 
MTF_WriteSSETDblk      -- 
MTF_ReadSSETDblk       -- 


MTF VOLB DBLK INFO
==================
MTF_DBLK_VOLB_INFO     -- all similar to above but for VOLB DBLK
MTF_SetVOLBDefaults    -- 
MTF_WriteVOLBDblk      -- 
MTF_ReadVOLBDblk       -- 
MTF_SetVOLBForDevice   -- sets default values given a device name ("C:") using 
                          GetVolumeInformation (WIN32 call)


MTF DIRB DBLK INFO
==================
MTF_DBLK_DIRB_INFO        -- all similar to above but for DIRB DBLK
MTF_SetDIRBDefaults       -- 
MTF_WriteDIRBDblk         -- (dblk only -- no stream)
MTF_ReadDIRBDblk          -- 
MTF_SetDIRBFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF FILE DBLK INFO
==================
MTF_DBLK_FILE_INFO        -- all similar to above but for FILE DBLK
MTF_SetFILEDefaults       -- 
MTF_WriteFILEDblk         -- (dblk only -- no stream)
MTF_ReadFILEDblk          -- 
MTF_SetFILEFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF CFIL DBLK INFO
==================
MTF_DBLK_CFIL_INFO        -- all similar to above but for CFIL DBLK
MTF_SetCFILDefaults       -- 
MTF_WriteCFILDblk         -- 
MTF_ReadCFILDblk          -- 


MTF ESET DBLK INFO
==================
MTF_DBLK_ESET_INFO        -- all similar to above but for ESET DBLK
MTF_SetESETDefaults       -- 
MTF_WriteESETDblk         -- 
MTF_ReadESETDblk          -- 


MTF EOTM DBLK INFO
==================
MTF_DBLK_EOTM_INFO        -- all similar to above but for EOTM DBLK
MTF_SetEOTMDefaults       -- 
MTF_WriteEOTMDblk         -- 
MTF_ReadEOTMDblk          -- 


MTF STREAM INFO
==================
MTF_STREAM_INFO           -- all similar to above but for EOTM DBLK
MTF_SetSTREAMDefaults     -- 
MTF_WriteSTREAMHeader     -- 
MTF_ReadSTREAMHeader      -- 
MTF_SetSTREAMDefaultsFromStreamId
                          -- sets stream defaults from a WIN32_STREAM_ID struct
                             (returned from the WIN32 BackupRead function)

***********************************************************************************/

#ifndef _MTF_API_H_
#define _MTF_API_H_

#include <windows.h>
#include <stdlib.h>
#include <wchar.h>
#include <time.h>

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Constants, defines and bit masks
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     MTF ERROR CODES
================================================================================== */

#define MTF_ERROR_NONE              0
#define MTF_ERROR_BUFFER_TOO_SMALL  1000
#define MTF_NO_STREAMS              1001
#define MTF_OUT_OF_MEMORY           1002

/* ==================================================================================
     MTF Misc. Defaults and Constants
================================================================================== */
#define MTF_DEFAULT_ALIGNMENT_FACTOR 1024;

#define MTF_FORMAT_VER_MAJOR      1
#define MTF_FORMAT_VER_MINOR      0 // BMD: This API is verison 5; use 0 for compatibility with NT Backup

#define MTF_PW_ENCRYPT_NONE       0
#define MTF_DATA_ENCRYPT_NONE     0
#define MTF_ECC_NONE              0

#define MTF_COMPRESS_NONE         0

#define MTF_OTC_NONE              0
#define MTF_OTC_TYPE              1
#define MTF_OTC_VERSION           2

#define MTF_LOCAL_TZ              127

#define MTF_STRING_NONE           0
#define MTF_STRING_ANSI_STR       1
#define MTF_STRING_UNICODE_STR    2

#define MTF_OSID_NT               14
#define MTF_OSID_DOS              24

/* ==================================================================================
     MTF Block Types
================================================================================== */

#define  MTF_ID_TAPE     "TAPE"    /* Tape Header ID */
#define  MTF_ID_VOLB     "VOLB"    /* Volume Control Block ID */
#define  MTF_ID_SSET     "SSET"    /* Start of Backup Set Description Block ID */
#define  MTF_ID_ESET     "ESET"    /* End of Backup Set Description Block ID */
#define  MTF_ID_EOTM     "EOTM"    /* End of tape, continuation Block ID */
#define  MTF_ID_DIRB     "DIRB"    /* Directory Descriptor Block ID */
#define  MTF_ID_FILE     "FILE"    /* File Descriptor Block ID */
#define  MTF_ID_CFIL     "CFIL"    /* Corrupt File Descriptor Block ID */
#define  MTF_ID_ESPB     "ESPB"    /* End of Set Pad Block */
#define  MTF_ID_SFMB     "SFMB"    /* Soft Filemark Descriptor Block ID */


/* ==================================================================================
     DBLK Block Attributes

     The lower 16 bits are reserved for general attribute bits (those
     which may appear in more than one type of DBLK), the upper 16 are
     for attributes which are specific to one type of DBLK.

     Note that the block specific bit definitions overlap, and the block
     type is used to determine the meaning of a given bit.
================================================================================== */

/* any : */
#define MTF_CONTINUATION        0x00000001UL
#define MTF_COMPRESSION         0x00000004UL
#define MTF_EOS_AT_EOM          0x00000008UL
#define MTF_VAR_BLKS            0x00000010UL
#define MTF_SESSION             0x00000020UL

/* TAPE : */
#define MTF_SM_EXISTS           0x00010000UL
#define MTF_FDD_ALLOWED         0x00020000UL
#define MTF_SM_ALT_OVERWRITE    0x00040000UL
#define MTF_FDD_ALT_PART        0x00080000UL
#define MTF_SM_ALT_APPEND       0x00200000UL

/* SSET : */
#define MTF_FDD_EXISTS          0x00010000UL
#define MTF_ENCRYPTION          0x00020000UL

/* ESET : */
#define MTF_FDD_ABORTED         0x00010000UL
#define MTF_END_OF_FAMILY       0x00020000UL
#define MTF_ABORTED_SET         0x00040000UL
#define MTF_SET_VERIFIED        0x00080000UL

/* EOTM : */
#define MTF_NO_ESET_PBA         0x00010000UL
#define MTF_INVALID_ESET_PBA    0x00020000UL

/* ==================================================================================
     TAPE Block Attributes
================================================================================== */

#define MTF_TAPE_SOFT_FILEMARK  0x00000001UL
#define MTF_TAPE_MEDIA_LABEL    0x00000002UL

/* ==================================================================================
     SSET Block Attributes
================================================================================== */

#define MTF_SSET_TRANSFER       0x00000001UL
#define MTF_SSET_COPY           0x00000002UL
#define MTF_SSET_NORMAL         0x00000004UL
#define MTF_SSET_DIFFERENTIAL   0x00000008UL
#define MTF_SSET_INCREMENTAL    0x00000010UL
#define MTF_SSET_DAILY          0x00000020UL

/* ==================================================================================
     VOLB Block Attributes
================================================================================== */

#define MTF_VOLB_NO_REDIRECT    0x00000001UL
#define MTF_VOLB_NON_VOLUME     0x00000002UL
#define MTF_VOLB_DEV_DRIVE      0x00000004UL
#define MTF_VOLB_DEV_UNC        0x00000008UL
#define MTF_VOLB_DEV_OS_SPEC    0x00000010UL
#define MTF_VOLB_DEV_VEND_SPEC  0x00000020UL

/* ==================================================================================
     DIRB Block Attributes
================================================================================== */

#define MTF_DIRB_READ_ONLY      0x00000100UL
#define MTF_DIRB_HIDDEN         0x00000200UL
#define MTF_DIRB_SYSTEM         0x00000400UL
#define MTF_DIRB_MODIFIED       0x00000800UL
#define MTF_DIRB_EMPTY          0x00010000UL
#define MTF_DIRB_PATH_IN_STREAM 0x00020000UL
#define MTF_DIRB_CORRUPT        0x00040000UL

/* ==================================================================================
     FILE Block Attributes
================================================================================== */

#define MTF_FILE_READ_ONLY      0x00000100UL
#define MTF_FILE_HIDDEN         0x00000200UL
#define MTF_FILE_SYSTEM         0x00000400UL
#define MTF_FILE_MODIFIED       0x00000800UL
#define MTF_FILE_IN_USE         0x00010000UL
#define MTF_FILE_NAME_IN_STREAM 0x00020000UL
#define MTF_FILE_CORRUPT        0x00040000UL

/* ==================================================================================
     CFIL Block Attributes
================================================================================== */

#define MTF_CFIL_LENGTH_CHANGE  0x00010000UL
#define MTF_CFIL_UNREADABLE_BLK 0x00020000UL
#define MTF_CFIL_DEADLOCK       0x00040000UL

/* ==================================================================================
     ESET Block Attributes
================================================================================== */

#define MTF_ESET_TRANSFER       0x00000001UL
#define MTF_ESET_COPY           0x00000002UL
#define MTF_ESET_NORMAL         0x00000004UL
#define MTF_ESET_DIFFERENTIAL   0x00000008UL
#define MTF_ESET_INCREMENTAL    0x00000010UL
#define MTF_ESET_DAILY          0x00000020UL

/* ==================================================================================
     STREAM File System Attributes
================================================================================== */

#define MTF_STREAM_MODIFIED_BY_READ     0x00000001UL
#define MTF_STREAM_CONTAINS_SECURITY    0x00000002UL
#define MTF_STREAM_IS_NON_PORTABLE      0x00000004UL
#define MTF_STREAM_IS_SPARSE            0x00000008UL

/* ==================================================================================
     STREAM Media Format Attributes
================================================================================== */

#define MTF_STREAM_CONTINUE         0x00000001UL
#define MTF_STREAM_VARIABLE         0x00000002UL
#define MTF_STREAM_VAR_END          0x00000004UL
#define MTF_STREAM_ENCRYPTED        0x00000008UL
#define MTF_STREAM_COMPRESSED       0x00000010UL
#define MTF_STREAM_CHECKSUMED       0x00000020UL
#define MTF_STREAM_EMBEDDED_LENGTH  0x00000040UL

/* ==================================================================================
     STREAM Types (Platform Independent)
================================================================================== */

#define MTF_STANDARD_DATA_STREAM    "STAN"
#define MTF_PATH_NAME_STREAM        "PNAM"
#define MTF_FILE_NAME_STREAM        "FNAM"
#define MTF_CHECKSUM_STREAM         "CSUM"
#define MTF_CORRUPT_STREAM          "CRPT"
#define MTF_PAD_STREAM              "SPAD"
#define MTF_SPARSE_STREAM           "SPAR"
#define MTF_MBC_LMO_SET_MAP_STREAM  "TSMP"
#define MTF_MBC_LMO_FDD_STREAM      "TFDD"
#define MTF_MBC_SLO_SET_MAP_STREAM  "MAP2"
#define MTF_MBC_SLO_FDD_STREAM      "FDD2"

/* ==================================================================================
     STREAM Types (Windows NT specific)
================================================================================== */

#define MTF_NTFS_ALT_STREAM         "ADAT"
#define MTF_NTFS_EA_STREAM          "NTEA"
#define MTF_NT_SECURITY_STREAM      "NACL"
#define MTF_NT_ENCRYPTED_STREAM     "NTED"
#define MTF_NT_QUOTA_STREAM         "NTQU"
#define MTF_NT_PROPERTY_STREAM      "NTPR"
#define MTF_NT_REPARSE_STREAM       "NTRP"
#define MTF_NT_OBJECT_ID_STREAM     "NTOI"

/* ==================================================================================
     STREAM Frame Headers
================================================================================== */

#define MTF_COMPRESSION_HEADER_ID   "FM"
#define MTF_ECRYPTION_HEADER_ID     "EH"

/* ==================================================================================
 * Turn on packing here.  Need to be sure that date is packed. 
================================================================================== */
#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Miscelaneous Data Types (and some handy methods for them)
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     General Data Types
================================================================================== */

UINT64 MTF_CreateUINT64(
    UINT32 uLSB, UINT32 uMSB);


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
================================================================================== */
typedef struct {
     UINT8     dt_field[5] ;
} MTF_DATE_TIME;


/************************************************************************************
* MTF_CreateDataTime#####()
*
* Description:  Given various arguments, this set of functions returns a packed 
*               MTF_DATE_TIME struct which can then be assigned to fields found 
*               in the various info structs found below
* Example:
*               sSetInfo.sBackupDate = MTF_CreateDateTime(1995, 6, 12, 16, 30, 0);
************************************************************************************/

MTF_DATE_TIME MTF_CreateDateTimeNull();

MTF_DATE_TIME MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    );

MTF_DATE_TIME MTF_CreateDateTimeFromTM(
    struct tm *pT);

MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(   
    FILETIME sFileTime);

void MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT);



/***********************************************************************************
************************************************************************************
****  MTF Alignment Factor 
************************************************************************************
***********************************************************************************/

/************************************************************************************
* MTF_SetAlignmentFactor()
*
* Description:  Sets the alignment factor to be used by the MTF API
*               (particularly by MTF_PadToNextAlignmentFactor and MTF_WriteTAPEDblk)
*
* Pre:
* Post: MTF API Alignment Factor == uAF
*
* uAF -- alignment factor value to set
************************************************************************************/
void MTF_SetAlignmentFactor(
    UINT16 uAF);



/************************************************************************************
* MTF_GetAlignmentFactor()
*
* Description:  Returns the Alignment Factor set by MTF_SetAlignmentFactor
*
* Pre: MTF_SetAlignmentFactor has been called
************************************************************************************/
UINT16 MTF_GetAlignmentFactor();



/************************************************************************************
* MTF_PadToNextAlignmentFactor()
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next alignment factor
*               
*
* Pre:  The alignment factor has been set by calling MTF_SetAlignmentFactor,
*       pBuffer points to a buffer whose size is reflected by nBufferSize
*
* Post: return value == MTF_ERROR_NONE
*           => padding was successful, *pnSizeUsed reflects amount of buffer used,
*              AND *pnSizeUsed % MTF_GetAlignmentFactor == 0  is  TRUE
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* NOTE: If the space between the end of the buffer and the next alignment factor is 
*       smaller than the size of a stream header, then the spad hogs up the whole 
*       next alignment factor.
*
* pBuffer     -- the buffer to spad out
* nBufUsed    -- the amount of the buffer used so far (position where to append)
* nBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- points to where to store size used or needed
************************************************************************************/
DWORD MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed);

/************************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next physical block boundary.
*
************************************************************************************/
DWORD MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed);


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURES
************************************************************************************
************************************************************************************
***********************************************************************************/

/***********************************************************************************
GENERIC DETAIL COMMENTS FOR FUNCTIONS FOUND BELOW
=================================================

************************************************************************************
* MTF_Set####Defaults()
*
* Description:  Sets up default values for the structure.  Always call this to
*               avoid garbage values in case you over look a field, 
* Pre:  
* Post: All fields of the referenced structure are filled in with *something*. 
*       Date fields are initialized to current date and time.
*       Strings pointers are set to 0
*       Most other values set to 0
*
* p####Info     -- pointer to structure to be set
************************************************************************************
void MTF_Set####Defaults(
    MTF_####_INFO *p####Info);    


************************************************************************************
* MTF_Write####Dblk()
*
* Description:  Formats the information supplied in psHdrInfo and ps####Info into
*               MTF Format and places the results in pBuffer
*
* Pre:  psHdrInfo and ps####Info contain valid information / default values
*       pBuffer points to a buffer where resulting format is to be stored
*       nBuffer size indicates the size of the buffer
*
*       MTF_WriteTAPEDblk -- MTF_SetAlingmentFactor has been called
*
* Post: return value == MTF_ERROR_NONE
*           => Format was successful, *pnSizeUsed reflects amount of buffer used
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* psHdrInfo   -- MTF Common header information 
* ps####Info  -- MTF DBLK info
* pBuffer     -- pointer to buffer which will receive MTF formatted info
* pBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- pointer to a size_t in which amount of buffer used or needed is stored
************************************************************************************
DWORD MTF_Write####Dblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 



************************************************************************************
* MTF_Read####Dblk()
*
* Description:  Translates MTF Formatted information from a buffer to MTF API info
*               structures -- the opposite of MTF_Write####Dblk
*               
*
* Pre:  pBuffer contains correct MTF Buffer information 
*
* Post: psHdrInfo and ps####Info contain the de-formatted info.  
*
* NOTE: Strings point to strings stored statically by the API, and will be over 
*       written on the next read call. 
*
* psHdrInfo   -- MTF Common header info struct to receive info
* ps####Info  -- MTF DBLK info struct to receive info
* pBuffer     -- pointer to buffer which holds MTF formatted data
************************************************************************************
DWORD MTF_Read####Dblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer);    



************************************************************************************
* MTF_Set####From?????????()
*
* Description: Similar to MTF_Set####Defaults(), but takes as an argument one or more
*              commonly used structures and sets values from that.  For example, 
*              MTF_SetFILEFromFindData takes as an argument a WIN32_FIND_DATA struct
*              from which it extracts the file name, date, time, etc. 
*               
*
* Pre:  
* Post: As many fields as are reasonable are automatically set.  The rest of the 
*       fields are set to default values.
*
* NOTE: Strings such as file names, directory names are stored statically by the 
*       MTF API and are only good until the next call to an MTF_Set#####From??????
*       function.
*
* NOTE: FILE and DIRB calls automatically set the file and directory attibutes from 
*       the info in the WIN32_FIND_DATA structure.
*
* NOTE: MTF_SetSTREAMFromStreamId will automatically set the stream header id based
*       on the attributes found in the WIN32 stream header
*
************************************************************************************
void MTF_Set####From?????????(MTF_DBLK_####_INFO *p####Info, 
                              SomeType????        Id??? 
                              ....);
***********************************************************************************/



/* ==================================================================================
     Common DBLK: MTF_STD_DBLK_INFO
================================================================================== */
typedef struct { 

    char    acBlockType[5];         /* for reading only -- ignored when writing (includes \0)*/
    UINT32  uBlockAttributes;
    UINT16  uOffsetToFirstStream;   /* for reading only */
    UINT8   uOSID;                  /* Machine/OS id where written, low byte */
    UINT8   uOSVersion;             /* Machine/OS id where written, high byte */
    UINT64  uDisplayableSize;       /* Displayable data size */
    UINT64  uFormatLogicalAddress;
    UINT16  uReservedForMBC;        /* Reserved for Media Based Catalog */
    UINT16  uSoftwareCompression;   /* Software Compression Algorithm */
    UINT32  uControlBlockId;        /* Used for error recovery */
    void *  pvOSData;               /* OS specific Data */
    UINT16  uOSDataSize;            /* the size of the OS data in bytes */
    UINT8   uStringType;            /* String type */   
    UINT16  uHeaderCheckSum;        /* for reading only */

} MTF_DBLK_HDR_INFO;

void MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO *pStdInfo);



/* ==================================================================================
     TAPE DBLK: MTF_TAPE_INFO
================================================================================== */
typedef struct { 

    UINT32  uTapeFamilyId;
    UINT32  uTapeAttributes;
    UINT16  uTapeSequenceNumber;
    UINT16  uPasswordEncryptionAlgorithm;
    UINT16  uSoftFilemarkBlockSize;
    UINT16  uTapeCatalogType;
    wchar_t *   szTapeName;
    wchar_t * szTapeDescription;
    wchar_t * szTapePassword;
    wchar_t * szSoftwareName;
    UINT16  uAlignmentFactor;
    UINT16  uSoftwareVendorId;
    MTF_DATE_TIME   sTapeDate;
    UINT8   uMTFMajorVersion;

} MTF_DBLK_TAPE_INFO;

void MTF_SetTAPEDefaults(MTF_DBLK_TAPE_INFO *pTapeInfo);
    
DWORD MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
                                                          
                                                          

DWORD MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
                                                          
                                                          

/* ==================================================================================
     Start of Set DBLK (SSET)
================================================================================== */
typedef struct {
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     wchar_t *           szDataSetName;
     wchar_t *           szDataSetDescription;
     wchar_t *           szDataSetPassword;
     wchar_t *           szUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone ;
     UINT8               uMTFMinorVer ;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET_INFO;

void MTF_SetSSETDefaults(MTF_DBLK_SSET_INFO *pSSETInfo);

DWORD MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
                                                          
                                                          

/* ==================================================================================
     Volume DBLK (VOLB)
================================================================================== */
typedef struct {
     UINT32              uVolumeAttributes;
     wchar_t *           szDeviceName;
     wchar_t *           szVolumeName;
     wchar_t *           szMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB_INFO;

typedef struct {
     UINT32              uFileSystemFlags;
     UINT32              uBackupSetAttributes;
} MTF_VOLB_OS_NT_1;

void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo);

void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice);

DWORD MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
/* ==================================================================================
     Directory DBLK (DIRB)
================================================================================== */
typedef struct {
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     wchar_t *           szDirectoryName;
} MTF_DBLK_DIRB_INFO;

typedef struct {
     UINT32              uDirectoryAttributes;
} MTF_DIRB_OS_NT_0;

typedef struct {
     UINT32              uDirectoryAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
} MTF_DIRB_OS_NT_1;

void MTF_SetDIRBDefaults(MTF_DBLK_DIRB_INFO *pDIRBInfo);

void MTF_SetDIRBFromFindData( MTF_DBLK_DIRB_INFO *pDIRBInfo, 
                              wchar_t            *szFullFileName, 
                              WIN32_FIND_DATAW   *pFindData);

DWORD MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          



/* ==================================================================================
     File DBLK (FILE)
================================================================================== */
typedef struct {
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     wchar_t *           szFileName;
     UINT64              uDisplaySize;
} MTF_DBLK_FILE_INFO;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT16              lLink;
     UINT16              uReserved;
} MTF_FILE_OS_NT_0;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT32              uFileFlags;
} MTF_FILE_OS_NT_1;

void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo);

void MTF_SetFILEFromFindData( MTF_DBLK_FILE_INFO *pFILEInfo, 
                              WIN32_FIND_DATAW *pFindData);

DWORD MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    



/* ==================================================================================
     Corrupt File DBLK (CFIL)
================================================================================== */
typedef struct {
     UINT32              uCFileAttributes;
     UINT32              uDirectoryId;      /* Or CFIL Attributes                             ***/
     UINT32              uFileId;           /* Or reserved                                    ***/
     UINT64              uStreamOffset;
     UINT16              uCorruptStreamNumber;
} MTF_DBLK_CFIL_INFO;

void MTF_SetCFILDefaults(MTF_DBLK_CFIL_INFO *pCFILInfo);

DWORD MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     End of Set Pad DBLK (ESPB)
================================================================================== */
DWORD MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer);    



/* ==================================================================================
     End of Set DBLK (ESET)
================================================================================== */
typedef struct {
     UINT32              uESETAttributes;
     UINT32              uNumberOfCorrupFiles;
     UINT64              uSetMapPBA;
     UINT64              uFileDetailPBA;
     UINT16              uFDDTapeSequenceNumber;
     UINT16              uDataSetNumber;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_ESET_INFO;

void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo);

DWORD MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     End of Tape Media DBLK (EOTM)
================================================================================== */
typedef struct {
     UINT64              uLastESETPBA;
} MTF_DBLK_EOTM_INFO;

void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo);

DWORD MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     Soft Filemark DBLK (SFMB) - (bmd)
================================================================================== */
typedef struct {
     UINT32              uNumberOfFilemarkEntries;
     UINT32              uFilemarkEntriesUsed;
     UINT32              uFilemarkArray[1];
} MTF_DBLK_SFMB_INFO;

size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize);

void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba);

DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed);

DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer);

/* ==================================================================================
     STREAM 
================================================================================== */
typedef struct {
     UINT8               acStreamId[4];
     UINT16              uStreamFileSystemAttributes;
     UINT16              uStreamTapeFormatAttributes;
     UINT64              uStreamLength;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uDataCompressionAlgorithm;
     UINT16              uCheckSum;

} MTF_STREAM_INFO;

void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, 
                           char            *szId);

void MTF_SetSTREAMFromStreamId( MTF_STREAM_INFO *pSTREAMInfo, 
                                WIN32_STREAM_ID *pStreamId, 
                                size_t           nIDHeaderSize);

void MTF_SetStreamIdFromSTREAM( WIN32_STREAM_ID *pStreamId,
                                MTF_STREAM_INFO *pSTREAMInfo, 
                                size_t           nIDHeaderSize);

DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_WriteNameStream(char      *szType,
                          wchar_t   *szName,
                          BYTE      *pBuffer,
                          size_t     nBufferSize,
                          size_t    *pnSizeUsed);

DWORD MTF_ReadStreamHeader(  MTF_STREAM_INFO    *psStreamInfo,  
                             BYTE               *pBuffer);    

/* ==================================================================================
     Utilities 
================================================================================== */
void MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer);

#pragma pack()

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mover.rc
//
#define IDS_CNTTAPEIO_DESC                4
#define IDR_CNtTapeIo                     4
#define IDS_CNTFILEIO_DESC                5
#define IDR_CNtFileIo                     5
#define IDS_CFILTERIO_DESC                9
#define IDR_CFilterIo                     9
#define IDS_PROJNAME                    100

// String ids
#define IDS_MOVER_GETFREESPACE          161
#define IDS_MOVER_WRITE                 162
#define IDS_MOVER_READ                  163
#define IDS_MOVER_OPENTAPE              164
#define IDS_MOVER_CLOSETAPE             165
#define IDS_MOVER_WRITEFILEMARKS        166
#define IDS_MOVER_GETPOSITION           167
#define IDS_MOVER_SETPOSITION           168
#define IDS_MOVER_SETPOSITIONFILEMARKS  169
#define IDS_MOVER_SETPOSITIONTOEND      170
#define IDS_MOVER_REWINDTAPE            171


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        9
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\ntfileio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtFileIo.h

Abstract:

    Definition of the CNtFileIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(NtFileIo_H)
#define NtFileIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CNtFileIo

class CNtFileIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CNtFileIo,&CLSID_CNtFileIo>
{
public:
    CNtFileIo() {}
BEGIN_COM_MAP(CNtFileIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNtFileIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CNtFileIo)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(
        IN REFIID riid);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR unused);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        IN void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = 512,                     // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hFile;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*, MVR_FLAG_*
    ULARGE_INTEGER          m_StreamOffset;         // Unformatted mode: The (absolute) current offset into the data stream
                                                    // HSM Semantics mode: The offset into the remote file itself from the beginning of the file
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream
    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    BOOL                    m_isLocalStream;        // Either local and remote stream is created
    ULONG                   m_OriginalAttributes;   // The original attributes of the local file.

    DWORD                   m_BlockSize;            // The read/write blocking factor.

    static int              s_InstanceCount;        // Counter of the number of object instances.

    // File I/O
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);

    HRESULT InternalCopyFile(IN WCHAR *pOriginalFileName, IN WCHAR *pCopyFileName, IN BOOL bFailIfExists);

    // Block Positioning
    HRESULT GetPosition(OUT UINT64 *pPosition);
    HRESULT SetPosition(IN UINT64 position);
    HRESULT EnsurePosition(IN UINT64 position);

    // Utililties
    HRESULT GetRemotePath(OUT BSTR *pDestinationString);
    HRESULT DeleteAllData(void);
    HRESULT FormatDrive(IN BSTR label);
    HRESULT DoRecovery (void);
    HRESULT CreateRecoveryIndicator (IN WCHAR *pFileName);
    HRESULT DeleteRecoveryIndicator (IN WCHAR *pFileName);
    HRESULT TestRecoveryIndicatorAndDeleteFile (IN WCHAR *pFileName);

    HRESULT MapFileError(IN HRESULT hrToMap, IN WCHAR *pAction);
};

#endif // !defined(NtFileIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H_)
#define _STDAFX_H_

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

extern "C" {
#include <ntddtape.h>
}

#define WSB_TRACE_IS    WSB_TRACE_BIT_DATAMOVER

#include "Mover.h"

#endif // !defined(_STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\makefile.inc ===
$(O)\rms.res: RmsCartg.rgs \
              RmsChngr.rgs \
              RmsClien.rgs \
              RmsServr.rgs \
              RmsDrCls.rgs \
              RmsDrive.rgs \
              RmsIPort.rgs \
              RmsLibry.rgs \
              RmsMdSet.rgs \
              RmsNTMS.rgs  \
              RmsPartn.rgs \
              RmsReqst.rgs \
              RmsSSlot.rgs \
              RmsTmplt.rgs \
              ..\..\inc\$(O)\RmsLib.tlb   \

stdafx.h: ..\..\inc\rms.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\nttapeio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtTapeIo.cpp

Abstract:

    CNtTapeIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "NtTapeIo.h"
#include "Mll.h"

int CNtTapeIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

ULONG
CNtTapeIo::InternalAddRef(void) {

    DWORD refs = CComObjectRoot::InternalAddRef();
    WsbTrace(OLESTR("CNtTapeIo::InternalAddRef - Refs=%d\n"), refs);

    return refs;

}

ULONG
CNtTapeIo::InternalRelease(void) {

    DWORD refs = CComObjectRoot::InternalRelease();
    WsbTrace(OLESTR("CNtTapeIo::InternalRelease - Refs=%d\n"), refs);

    return refs;

}


#pragma optimize("g", off)
STDMETHODIMP
CNtTapeIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FinalConstruct"), OLESTR(""));

    try {
        m_bCritSecCreated = FALSE;

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hTape = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        memset(&m_sMediaParameters, 0, sizeof(TAPE_GET_MEDIA_PARAMETERS));
        memset(&m_sDriveParameters, 0, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_pStreamBuf = NULL;
        m_StreamBufSize = 0;
        m_StreamBufUsed = 0;
        m_StreamBufPosition = 0;
        m_StreamBufStartPBA.QuadPart = 0;

        WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 0));
        m_bCritSecCreated = TRUE;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CNtTapeIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtTapeIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FinalRelease"),OLESTR(""));

    (void) CloseStream();  // in case anything is left open
    (void) CloseTape();

    CComObjectRoot::FinalRelease();

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CNtTapeIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtTapeIo::FinalRelease"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    if (m_bCritSecCreated) {
        DeleteCriticalSection(&m_CriticalSection);
    }

    return hr;
}
#pragma optimize("", on)


HRESULT
CNtTapeIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CNtTapeIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CNtTapeIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CNtTapeIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CNtTapeIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CNtTapeIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CNtTapeIo::InterfaceSupportsErrorInfo(REFIID riid)
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//



STDMETHODIMP
CNtTapeIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetObjectId"), OLESTR(""));

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_ObjectId;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    CComPtr<IStream> pStream;
    ULARGE_INTEGER nil = {0,0};

    try {
        MvrInjectError(L"Inject.CNtTapeIo::BeginSession.0");

        WsbAssert(remoteDataSet > 0, MVR_E_INVALIDARG);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // This may be overkill, but just in case we verify we're working with the correct media.
        CWsbBstrPtr label;
        WsbAffirmHr(ReadLabel(&label));
        WsbAssertHr(VerifyLabel(label));

        // Create the remote stream used for the entire session.
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAffirmPointer(pStream);

        SHORT startSet = remoteDataSet;
        UINT64 addr1=0, addr2=0;
        LONG tapeMarks=0;

        //
        // Only allow append at EOD or last data set
        //
        tapeMarks = 1 + (startSet-1)*2;
        if ( MVR_SESSION_APPEND_TO_DATA_SET & options ) {
            tapeMarks += 2;
        }

        int retry = 3;  // We allow a two pass error recovery, one for each possible
                        // missing filemark, we abort on failure of the third attempt.

        do {
            hr = S_OK;

            // Each pass recovers from a single missing filemark (two max).
            // This is the case where a files were recorded to media but the
            // EndSession() method was never called or did not complete (i.e. power failure).
            try {
                WsbAssertPointer(m_pSession);

                // Make sure we have a consistant data set.  We handle a single instance of
                // a partially written data set, including those with a missing EOD marker.

                // NOTE: The MISSING EOD error may eventually be detected by ERROR_NOT_FOUND, per Chuck Parks.

                WsbAffirmHr(RewindTape());

                WsbAffirmHrOk(SpaceFilemarks(tapeMarks, &addr1));
                WsbAffirmHr(SpaceToEndOfData(&addr2));
/*
                hr = SpaceFilemarks(tapeMarks, &addr1);
                if (S_OK != hr) {
                    // TODO: FIX:  Clean this up when missing EOD marker results in ERROR_NOT_FOUND.

                    // We're missing Filemarks or the EOD marker.

                    // If the EOD marker is missing the SpaceToEndOfData will again return same hr.
                    if (hr == SpaceToEndOfData(&addr2)) {
                        WsbAffirm(addr1 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);
                        WsbThrow(MVR_E_NOT_FOUND); // handled by recovery code!
                    }
                    else {
                        WsbThrow(hr); // Can't recover, just throw the original error
                    }
                }
                else {
                    WsbAffirmHr(SpaceToEndOfData(&addr2));
                }
*/
                //
                // Affirm that we are at the end of tape.
                //
                WsbAffirm(addr1 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);
                //
                // Affirm that we are starting at a consistent location.
                // Is there at least a TAPE DBLK + filemark.
                //
                WsbAffirm(addr1 > 1, MVR_E_INCONSISTENT_MEDIA_LAYOUT);

                if ( MVR_SESSION_APPEND_TO_DATA_SET & options ) {

                    WsbAffirmHr(SpaceToEndOfData(&addr1));
                    WsbAffirmHrOk(SpaceFilemarks(-2, &addr2));
                    //
                    // Affirm that we are at the end of a data set.
                    //
                    WsbAffirm(addr1-3 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);

                    // TODO: We need to read ESET/or SSET to esablish state of the
                    //       data set we're appending.

                    m_DataSetNumber = remoteDataSet;

                    // Align the stream I/O model
                    LARGE_INTEGER zero = {0,0};
                    WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));
                    break;
                }
                else {
                    // MVR_SESSION_OVERWRITE_DATA_SET
                    // MVR_SESSION_AS_LAST_DATA_SET

                    m_DataSetNumber = remoteDataSet;

                    // Align the stream I/O model
                    LARGE_INTEGER zero = {0,0};
                    WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));

                    //
                    // Convert session option type bits to MTFSessionType
                    //
                    MTFSessionType type;

                    switch (options & MVR_SESSION_TYPES) {
                    case MVR_SESSION_TYPE_TRANSFER:
                        type = MTFSessionTypeTransfer;
                        break;

                    case MVR_SESSION_TYPE_COPY:
                        type = MTFSessionTypeCopy;
                        break;

                    case MVR_SESSION_TYPE_NORMAL:
                        type = MTFSessionTypeNormal;
                        break;

                    case MVR_SESSION_TYPE_DIFFERENTIAL:
                        type = MTFSessionTypeDifferential;
                        break;

                    case MVR_SESSION_TYPE_INCREMENTAL:
                        type = MTFSessionTypeIncremental;
                        break;

                    case MVR_SESSION_TYPE_DAILY:
                        type = MTFSessionTypeDaily;
                        break;

                    default:
                        type = MTFSessionTypeCopy;
                        break;
                    }

                    
                    // Write the SSET DBLK
                    // This does not actually write anything to tape; only writes to the transfer buffer
                    WsbAffirmHr(m_pSession->DoSSETDblk(remoteSessionName, remoteSessionDescription, type, remoteDataSet));

                    // After the tape head is in the right place, we want to make sure
                    //  that we ask the driver for free space and not use internal counting
                    CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
                    WsbAffirmPointer(pInfo);
                    WsbAffirmHr(pInfo->SetFreeSpace(-1));
                    WsbAffirmHr(GetLargestFreeSpace(NULL, NULL));
                    break;
                }

            } catch (HRESULT catchHr) {
                hr = catchHr;

                // Only allow two attempts at recovery
                WsbAffirm(retry > 1, MVR_E_INCONSISTENT_MEDIA_LAYOUT);

                if ( MVR_E_NOT_FOUND == hr) {
                    // TODO: FIX: this goes away when missing EOD marker results in ERROR_NOT_FOUND.

                    // Recovery code for missing EOD marker

                    SpaceToEndOfData(NULL);  // Redundant!
                    WsbAffirmHr(WriteFilemarks(1));

                }
                else if ( MVR_S_NO_DATA_DETECTED == hr) {
                    // Recovery code for missing end of data set.

                    try {

                        CWsbBstrPtr name;
                        CWsbBstrPtr desc;
                        if ( m_pCartridge ) {
                            m_pCartridge->GetName(&name);
                            m_pCartridge->GetDescription(&desc);
                        }

                        WsbLogEvent(MVR_MESSAGE_INCOMPLETE_DATA_SET_DETECTED, 0, NULL,
                            WsbLongAsString(startSet-1),
                            (WCHAR *) name, (WCHAR *) desc, NULL);

                        //
                        // Make the end data set conform to: filemark + ESET + filemark,
                        // for the previous session.  This may require two passes.
                        //
                        // Recoverable Exceptions:
                        //   1) Partial data set (no trailing filemark + ESET + filemark).
                        //      This occurs from power-off during Write() of data.  Two pass recovery;
                        //      write filemark, then EndSession().
                        //   2) Partial data set (filemark with no trailing ESET + filemark).
                        //      This occurs from power-off during EndSession() before ESET.
                        //      One pass recovery; EndSession();
                        //   3) Partial data set (ESET with no trailing filemark).
                        //      This occurs from power-off during EndSession() after ESET.
                        //      One pass recovery; write filemark.
                        // Non-Recoverable Exceptions detected:
                        //   a) No filemarks at expected locations.
                        //   b) No data set (no data, no trailing filemark + ESET + filemark).
                        //      This occurs from power-off after BeginSession(), but before device
                        //      buffer is flushed, and no SSET is written to tape, application
                        //      database may have recorded a successfull BeginSession().  For
                        //      this case BeginSession() returns MVR_E_DATA_SET_MISSING.
                        //   c) Blank tape, no label, no filemarks, or inconsistent tape.
                        //
                        // From ntBackup testing this apprears to be enough, in that we do not
                        // need to rebuild complete ESET info from previous SSET.  The last
                        // ControlBlockId is not required to be valid.  (Brian, 9/23/97)
                        //

                        // Detect condition (a) through (c) or some variant.
                        if ( tapeMarks-2 > 0) {
                            // Verify that EOD is not at the beginning of the previous data set.
                            WsbAffirmHr(RewindTape());
                            WsbAffirmHrOk(SpaceFilemarks(tapeMarks-2, &addr1)); // (a)
                            WsbAffirmHr(SpaceToEndOfData(&addr2));
                            if ( addr1 == addr2 ) {
                                WsbThrow(MVR_E_DATA_SET_MISSING); // (b)
                            }
                        }
                        else {
                            WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT); // (c)
                        }

                        // Check for a Filemark at EOD
                        WsbAffirmHr(SpaceToEndOfData(&addr1));
                        WsbAffirmHrOk(SpaceFilemarks(-1, &addr2));
                        if (addr1-1 == addr2 ) {

                            // Align the stream I/O model to the end of the dataset;
                            // Set the stream pointer to before the Filemark that
                            // terminates the dataset and preceeds the ESET.
                            LARGE_INTEGER zero = {0,0};
                            WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));

                            // Write the trailing filemark, ESET DBLK, and filemark
                            WsbAffirmHr(m_pSession->DoEndOfDataSet( (USHORT) ( startSet - 1 ) ));

                        }
                        else {
                            WsbAffirmHr(SpaceToEndOfData(NULL));
                            WsbAffirmHr(WriteFilemarks(1));
                        }

                        WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);

                    } catch (HRESULT catchHr) {
                        hr = catchHr;

                        WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    } // end catch

                }
                else {
                    WsbThrow(hr);
                }
            } // end catch

        } while (retry-- > 0);


    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_CREATED, 0, NULL, WsbHrAsString(hr), NULL);
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::EndSession"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CNtTapeIo::EndSession.0");

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Write the trailing filemark, ESET DBLK, and filemark
        WsbAffirmHr(m_pSession->DoEndOfDataSet(m_DataSetNumber));

    } WsbCatch(hr);

    (void) CloseStream();


    WsbTraceOut(OLESTR("CNtTapeIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER *pRemoteDataSetStart,
    OUT ULARGE_INTEGER *pRemoteFileStart,
    OUT ULARGE_INTEGER *pRemoteFileSize,
    OUT ULARGE_INTEGER *pRemoteDataStart,
    OUT ULARGE_INTEGER *pRemoteDataSize,
    OUT DWORD *pRemoteVerificationType,
    OUT ULARGE_INTEGER *pRemoteVerificationData,
    OUT DWORD *pDatastreamCRCType,
    OUT ULARGE_INTEGER *pDatastreamCRC,
    OUT ULARGE_INTEGER *pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CNtTapeIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    WsbTraceAlways(OLESTR("CNtTapeIo::StoreData - Begin\n"));
    try {
        MvrInjectError(L"Inject.CNtTapeIo::StoreData.0");

        WsbAssertPointer(m_pSession);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Default is to perform non-case sensitive searches.
        // So knock down the posix flag.
        m_Flags &= ~MVR_FLAG_POSIX_SEMANTICS;

        // Default is to not commit after each file.
        // So knock down the commit flag.
        m_Flags &= ~MVR_FLAG_COMMIT_FILE;

        // Default is to write one DIRB containing all directory info
        //  instead of writing a DIRB for each directory level.
        // So knock down the write parent dir info flag.
        m_Flags &= ~MVR_FLAG_WRITE_PARENT_DIR_INFO;

        m_Flags |= flags;
        m_Flags |= MVR_MODE_WRITE;

        // Unconditionally set the case sensitive flag for each file.
        // We allow this flag to be set on a per file basis
        WsbTrace(OLESTR("Posix Semantics Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_POSIX_SEMANTICS & m_Flags));
        WsbAffirmHr(m_pSession->SetUseCaseSensitiveSearch(MVR_FLAG_POSIX_SEMANTICS & m_Flags));

        // This tells the session object to pad to a block boundary and flush the device
        // after the file is written.
        WsbTrace(OLESTR("Commit Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_COMMIT_FILE & m_Flags));
        WsbAffirmHr(m_pSession->SetCommitFile(MVR_FLAG_COMMIT_FILE & m_Flags));

        WsbTrace(OLESTR("ParentDirInfo Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags));

        if ((MVR_FLAG_BACKUP_SEMANTICS & m_Flags) || (MVR_FLAG_HSM_SEMANTICS & m_Flags)) {

            // Compare the volume and path with the last ones written to tape.

            CWsbStringPtr pathname;

            WCHAR *end;
            LONG numChar;

            pathname = localName;
            WsbAffirm(0 != (WCHAR *)pathname, E_OUTOFMEMORY);

            // strip off the path and file name
            end = wcschr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar =(LONG)(end - (WCHAR *)pathname + 1);  // keep the trailing backslash
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // We do a case sensitive search if using Posix semantics.
            WsbTrace(OLESTR("Comparing with last volume: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastVolume, 120));

            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastVolume, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastVolume, (WCHAR *) pathname))) ) {
                // write the VOLB DBLK
                WsbAffirmHr(m_pSession->DoVolumeDblk(pathname));
                m_LastVolume = pathname;
            }

            pathname = localName;

            // strip off the file name
            end = wcsrchr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar = (LONG)(end - (WCHAR *)pathname);
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // pathname is now in the form "Volume{guid}\dir1\...\dirn"
            //                      or "<drive letter>:\dir1\...\dirn"

/***
   m_Flags |= MVR_FLAG_WRITE_PARENT_DIR_INFO;
***/
            WsbTrace(OLESTR("Comparing with last path: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastPath, 120));

            // We do a case sensitive search if using Posix semantics.
            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastPath, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastPath, (WCHAR *) pathname))) ) {

                if (MVR_FLAG_HSM_SEMANTICS & m_Flags) {

                    // We're not supporting this anymore!
                    WsbThrow(E_NOTIMPL);

                    WCHAR szRoot[16];
                      
                    // We use a flat file structure for MVR_FLAG_HSM_SEMANTICS
                    WsbAffirmHr(m_pSession->SetUseFlatFileStructure(TRUE));

                    // do DIRB DBLKs for root
                    wcscpy(szRoot, L"X:\\");
                    szRoot[0] = localName[0];
                    WsbAffirmHr(m_pSession->DoParentDirectories(szRoot));

                }
                else if (MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags) {
                    // do a DIRB DBLK for each directory level of the file(s) to be backed up.
                    WsbAffirmHr(m_pSession->DoParentDirectories(pathname));
                    m_LastPath = pathname;
                }
                else {
                    // do one DIRB DBLK for the whole directory structure of the file(s) to be backed up.
                    WIN32_FIND_DATAW obFindData;
                    CWsbStringPtr tempPath;

                    DWORD additionalSearchFlags = 0;
                    additionalSearchFlags |= (m_Flags & MVR_FLAG_POSIX_SEMANTICS) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

                    tempPath = pathname;
                    tempPath.Prepend(OLESTR("\\\\?\\"));

                    if (NULL == wcschr((WCHAR *)tempPath+4, L'\\'))
                    {
                        // no path (i.e. we're at the root)
                        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
                        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
                        tempPath.Append(OLESTR("\\"));
                        // ** WIN32 API Calls
                        WsbAffirmHandle(hFile = CreateFile(tempPath, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
                        WsbAffirmStatus(GetFileInformationByHandle(hFile, &obGetFileInfoData));
                        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
                        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
                        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
                        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
                        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
                        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
                        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;
                    }
                    else {
                        // ** WIN32 API Call - gets file info
                        WsbAffirmHandle(hSearchHandle = FindFirstFileEx((WCHAR *) tempPath, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));
                    }
                    WsbAffirmHr(m_pSession->DoDirectoryDblk((WCHAR *) pathname, &obFindData)); 
                    if (hSearchHandle != INVALID_HANDLE_VALUE) {
                        FindClose(hSearchHandle);
                        hSearchHandle = INVALID_HANDLE_VALUE;
                    }
                    if (hFile != INVALID_HANDLE_VALUE) {
                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                    m_LastPath = pathname;
                }
            }
        }

        // The following uses code to store multiple files, but the 
        // RS Hints is only valid for the last file.  With the current
        // implementation, the HSM engine sends one file request through
        // StoreData at a time.  The caveat is that Posix is case
        // sensitive, and therefore files created in this fashion could
        // overload the same filename (ignoring case) with multiple files.
        WsbAffirmHr(m_pSession->DoDataSet(localName));

        *pRemoteDataSetStart     = m_pSession->m_sHints.DataSetStart;
        *pRemoteFileStart        = m_pSession->m_sHints.FileStart;
        *pRemoteFileSize         = m_pSession->m_sHints.FileSize;
        *pRemoteDataStart        = m_pSession->m_sHints.DataStart;
        *pRemoteDataSize         = m_pSession->m_sHints.DataSize;
        *pRemoteVerificationType = m_pSession->m_sHints.VerificationType;
        *pRemoteVerificationData = m_pSession->m_sHints.VerificationData;
        *pDatastreamCRCType      = m_pSession->m_sHints.DatastreamCRCType;
        *pDatastreamCRC          = m_pSession->m_sHints.DatastreamCRC;
        *pUsn                    = m_pSession->m_sHints.FileUSN;

    } WsbCatchAndDo(hr,

            if (hSearchHandle != INVALID_HANDLE_VALUE) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            WsbLogEvent(MVR_MESSAGE_DATA_TRANSFER_ERROR, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);

            // All fatal device errors are converted to E_ABORT so the calling code
            // can detect this general class of problem.
            // If the device error indicates bad media, convert to a different error code.
            switch(hr) {
            case MVR_E_BUS_RESET:
            case MVR_E_MEDIA_CHANGED:
            case MVR_E_NO_MEDIA_IN_DRIVE:
            case MVR_E_DEVICE_REQUIRES_CLEANING:
            case MVR_E_SHARING_VIOLATION:
            case MVR_E_ERROR_IO_DEVICE:
            case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
            case MVR_E_ERROR_NOT_READY:
                hr = E_ABORT;
                break;

            case MVR_E_INVALID_BLOCK_LENGTH:
            case MVR_E_WRITE_PROTECT:
            case MVR_E_CRC:
                hr = MVR_E_MEDIA_ABORT;
                break;

            default:
                break;
            }

        );

    WsbTraceAlways(OLESTR("CNtTapeIo::StoreData - End\n"));


    WsbTraceOut(OLESTR("CNtTapeIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::RecallData(
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*flags*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::RecallData"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtTapeIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR *pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        CWsbStringPtr strGuid;

        MvrInjectError(L"Inject.CNtTapeIo::FormatLabel.0");

        WsbAssertPointer(pLabel);
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        // Media Label or Description
        CWsbBstrPtr label;

        // Tag
        label = OLESTR("MTF Media Label"); // Required text per MTF specification.

        // Version
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MAJOR)));
        WsbAffirmHr(label.Append(OLESTR(".")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MINOR)));

        // Vendor
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MTF_VENDOR_NAME));

        // Vendor Product ID
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MLL_SOFTWARE_NAME));

        // Creation Time Stamp
        WsbAffirmHr(label.Append(OLESTR("|")));
        WCHAR timeStamp[128];
        time_t lTime;
        time(&lTime);
        wcsftime(timeStamp, 128, L"%Y/%m/%d.%H:%M:%S", localtime(&lTime));
        WsbAffirmHr(label.Append(timeStamp));

        // Cartridge Label
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use barcode if available
            CWsbBstrPtr barcode;
            if (S_OK == m_pCartridge->GetBarcode(&barcode)) {
                WsbAffirmHr(label.Append(barcode));
            }
            else {
                WsbAffirmHr(label.Append(displayName));
            }
        }
        else {
            WsbAffirmHr(label.Append(displayName));
        }

        // Side
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // TODO: This is broken, we need to know if the cartridge is inverted?
            if (S_OK == m_pCartridge->IsTwoSided()) {
                WsbAffirmHr(label.Append(OLESTR("2")));
            }
            else {
                WsbAffirmHr(label.Append(OLESTR("1")));
            }
        }
        else {
            WsbAffirmHr(label.Append(OLESTR("1")));  // Default
        }

        // Media Id
        GUID cartId;
        WsbAffirmHr(label.Append(OLESTR("|")));

        if (m_pCartridge) {

            // Use cartridge Id
            if (S_OK == m_pCartridge->GetCartridgeId(&cartId)) {
                WsbAffirmHr(WsbSafeGuidAsString(cartId, strGuid));
            }
            else {
                WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
            }
        }
        else {
            WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
        }
        WsbAffirmHr(label.Append(strGuid));

        // Media Domain Id
        GUID mediaSetId;
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use MediaSet Id
            if (S_OK == m_pCartridge->GetMediaSetId(&mediaSetId)) {
                WsbAffirmHr(WsbSafeGuidAsString(mediaSetId, strGuid));
            }
            else {
                WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
            }
        }
        else {
            WsbAffirmHr(WsbSafeGuidAsString(GUID_NULL, strGuid));
        }
        WsbAffirmHr(label.Append(strGuid));

        // Vendor Specific
        WsbAffirmHr(label.Append(OLESTR("|VS:DisplayName=")));
        WsbAffirmHr(label.Append(displayName));

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtTapeIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        MvrInjectError(L"Inject.CNtTapeIo::WriteLabel.0");

        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;

        CComPtr<IStream> pStream;
        ULARGE_INTEGER nil = {0,0};

        // Create the remote stream.
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Write the TAPE DBLK and filemark
        WsbAssertPointer(m_pSession);
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));
        WsbAffirmHr(CloseStream());
        pStream = NULL;

        // Now verify the label
        CWsbBstrPtr tempLabel;
        WsbAffirmHr(ReadLabel(&tempLabel));
        WsbAffirmHr(VerifyLabel(tempLabel));

        // Now that the tape header is written, we update the cartridge info.
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->SetOnMediaLabel(label));
            WsbAffirmHr(m_pCartridge->SetOnMediaIdentifier(identifier, (LONG) idSize, (LONG) idType));
            WsbAffirmHr(m_pCartridge->SetBlockSize(m_sMediaParameters.BlockSize));
        }

    } WsbCatchAndDo(hr,
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::ReadLabel(
    IN OUT BSTR *pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::ReadLabel"), OLESTR(""));

    CComPtr<IStream> pStream;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::ReadLabel.0");

        WsbAssertPointer(pLabel);

        // Read the MTF TAPE DBLK, and pull out the label.
        ULARGE_INTEGER nil = {0,0};

        // Create remote stream of copy
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Read label
        CWsbStringPtr label;
        WsbAffirmHr(m_pSession->ReadTapeDblk(&label));

        WsbAffirmHr(CloseStream());
        pStream = NULL;

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtTapeIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtTapeIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::VerifyLabel"), OLESTR("<%ls>"), label);

    GUID mediaId[2];

    try {
        MvrInjectError(L"Inject.CNtTapeIo::VerifyLabel.0");

        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        //
        // To verify a label we assert that the on-media Id matches the cartridge Id.
        //
        // From the media label we obtain the on-media Id.
        //
        WCHAR delim[] = OLESTR("|");
        WCHAR *token;
        int index = 0;

        token = wcstok((WCHAR *)label, delim);  // !!! This toasts the string !!!
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1:  // Tag
            case 2:  // Version
            case 3:  // Vendor
            case 4:  // Vendor Product ID
            case 5:  // Creation Time Stamp
            case 6:  // Cartridge Label
            case 7:  // Side
                break;
            case 8:  // Media ID
                WsbGuidFromString(token, &mediaId[0]);
                break;
            case 9:  // Media Domain ID
            default: // Vendor specific of the form: L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        if (m_pCartridge) {
            //
            // Now compare on-media Id taken from the label to the cartridge's object Id.
            //
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&mediaId[1]));
            WsbAffirm(mediaId[0] == mediaId[1], MVR_E_UNEXPECTED_MEDIA_ID_DETECTED);
        }

        m_ValidLabel = TRUE;

    } WsbCatchAndDo(hr,
            m_ValidLabel = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;
            if ( m_pCartridge ) {
                m_pCartridge->GetName(&name);
                m_pCartridge->GetDescription(&desc);
            }
            WsbLogEvent(MVR_MESSAGE_ON_MEDIA_ID_VERIFY_FAILED, 2*sizeof(GUID), mediaId,
                (WCHAR *) name, (WCHAR *) desc, WsbHrAsString(hr));
        );


    WsbTraceOut(OLESTR("CNtTapeIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::GetDeviceName(
    OUT BSTR *pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr(m_DeviceName.CopyToBstr(pName));

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetDeviceName(
    IN BSTR name,
    IN BSTR /*unused*/)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    
    m_DeviceName = name;

    return S_OK;
}



STDMETHODIMP
CNtTapeIo::GetLargestFreeSpace(
    OUT LONGLONG *pFreeSpace,
    OUT LONGLONG *pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh)
/*++

Implements:

    IDataMover::GetLargestFreeSpace

Note:
  The defaultFreeSpace parameter is used by the mover to maintain internally 
  media free space in case that the device doesn't provide this information.
  If the device supports reporting on free space, then this parameter has no affect.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetLargestFreeSpace"), OLESTR(""));

    const LONGLONG  MaxBytes = 0x7fffffffffffffff;

    LONGLONG        capacity = MaxBytes;
    LONGLONG        remaining = capacity;

    LARGE_INTEGER   defaultFreeSpace;
    if ((defaultFreeSpaceLow == 0xFFFFFFFF) && (defaultFreeSpaceHigh == 0xFFFFFFFF)) {
        defaultFreeSpace.QuadPart = -1;
    } else {
        defaultFreeSpace.LowPart = defaultFreeSpaceLow;
        defaultFreeSpace.HighPart = defaultFreeSpaceHigh;
    }

    try {
        MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.0");

        // Check if we already have valid space info for the cartridge.

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;

        WsbAffirmHr(pInfo->GetLargestFreeSpace(&remaining));
        WsbAffirmHr(pInfo->GetCapacity(&capacity));

        // Zero or Negative bytes remaining indicate the free space
        // may be stale, so go directly to the device for
        // the value.
        if (remaining <= 0) {

            WsbTrace(OLESTR("CNtTapeIo::GetLargestFreeSpace - Getting capacity and free-space from the device\n"));

            capacity = MaxBytes;
            remaining = capacity;

            if (INVALID_HANDLE_VALUE == m_hTape) {
                WsbAffirmHr(OpenTape());
            }

            TAPE_GET_DRIVE_PARAMETERS sDriveParameters;
            DWORD sizeOfDriveParameters = sizeof(TAPE_GET_DRIVE_PARAMETERS);
            memset(&sDriveParameters, 0, sizeOfDriveParameters);

            WsbAffirmHrOk(IsAccessEnabled());

            try {
                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.1.0");

                // ** WIN32 Tape API Call - get the tape drive parameters
                WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_DRIVE_INFORMATION, &sizeOfDriveParameters, &sDriveParameters));

                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.1.1");

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_GETFREESPACE) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            TAPE_GET_MEDIA_PARAMETERS sMediaParameters;
            DWORD sizeOfMediaParameters = sizeof(TAPE_GET_MEDIA_PARAMETERS);
            memset(&sMediaParameters, 0, sizeOfMediaParameters);

            try {
                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.2.0");

                // ** WIN32 Tape API Call - get the media parameters
                WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_MEDIA_INFORMATION, &sizeOfMediaParameters, &sMediaParameters));

                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.2.1");

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_GETFREESPACE) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            if ( sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_CAPACITY ) {
                capacity = sMediaParameters.Capacity.QuadPart;
                if ( 0 == capacity ) {
                    // Bogus value!
                    capacity = MaxBytes;
                }
            }

            if ( sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_REMAINING ) {
                remaining = sMediaParameters.Remaining.QuadPart;
            }
            else {
                // Use default value if given, otherwise, set to capacity
                if (defaultFreeSpace.QuadPart >= 0) {
                    remaining = defaultFreeSpace.QuadPart;
                } else {
                    remaining = capacity;
                }
            }

            WsbAffirmHr(pInfo->SetFreeSpace(remaining));
            WsbAffirmHr(pInfo->SetCapacity(capacity));

        }

    } WsbCatch(hr);

    // Fill in the return parameters
    if ( pCapacity ) {
        *pCapacity = capacity;
    }

    if ( pFreeSpace ) {
        *pFreeSpace = remaining;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>, free=%I64d, capacity=%I64d"), WsbHrAsString(hr), remaining, capacity);

    return hr;
}

STDMETHODIMP
CNtTapeIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
        m_StreamSize = m_StreamOffset;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::GetCartridge(
    OUT IRmsCartridge **ptr)
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( ptr );

        *ptr = m_pCartridge;
        m_pCartridge.p->AddRef();

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetCartridge(
    IN IRmsCartridge *ptr)
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( ptr );

        if ( m_pCartridge )
            m_pCartridge = 0;

        m_pCartridge = ptr;

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Cancel"), OLESTR(""));

    try {

        (void) Revert();
        (void) CloseStream();
        (void) CloseTape();

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CreateLocalStream(
    IN BSTR /*name*/,
    IN DWORD /*mode*/,
    OUT IStream ** /*ppStream*/)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream **ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(remoteSessionDescription);

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CreateRemoteStream"),
        OLESTR("<%ls> <0x%08x> <%I64u> <%I64u> <%I64u> <%I64u> <%I64u> <0x%08x> <0x%08x> <0x%08x> <0x%08x>"),
        name, mode, remoteDataSetStart.QuadPart, remoteFileStart.QuadPart, remoteFileSize.QuadPart,
        remoteDataStart.QuadPart, remoteDataSize.QuadPart, remoteVerificationType,
        remoteVerificationData.LowPart, remoteVerificationData.HighPart, ppStream);

    try {
        WsbAssertPointer(ppStream);

        MvrInjectError(L"Inject.CNtTapeIo::CreateRemoteStream.0");

        if (INVALID_HANDLE_VALUE == m_hTape) {
            WsbAffirmHr(OpenTape());
        }
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        m_StreamName = name;
        m_Mode = mode;

        m_StreamPBA.QuadPart = 0xffffffffffffffff;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = remoteDataSize.QuadPart;

        WsbAssert(NULL == m_pStreamBuf, MVR_E_LOGIC_ERROR); // We forgot a CloseStream somewhere

        // We need to allocate memory for the internal buffer used to handle
        // odd byte (non-block) size I/O requests.  At a minumum we make the
        // buffer 2x the block size.

        ULONG bufferSize;
        ULONG nBlocks = DefaultMinBufferSize/m_sMediaParameters.BlockSize;

        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_sMediaParameters.BlockSize;

        WsbTrace( OLESTR("Using %d byte internal buffer.\n"), bufferSize);

        m_pStreamBuf = (BYTE *) WsbAlloc(bufferSize);
        WsbAssertPointer(m_pStreamBuf);
        memset(m_pStreamBuf, 0, bufferSize);
        m_StreamBufSize = bufferSize;
        m_StreamBufUsed = 0;
        m_StreamBufPosition = 0;
        m_StreamBufStartPBA.QuadPart = 0;
       
        if (m_pCartridge) {
            if ( S_OK == m_pCartridge->LoadDataCache(m_pStreamBuf, &m_StreamBufSize, &m_StreamBufUsed, &m_StreamBufStartPBA) ) {
                WsbTrace( OLESTR("DataCache loaded.\n"));
            }
        }

        CComPtr<IStream> pStream;
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface( IID_IStream, (void **) &pStream));

        WsbAssert(NULL == m_pSession, MVR_E_LOGIC_ERROR);
        m_pSession = new CMTFSession();
        WsbAssertPointer(m_pSession);

        m_pSession->m_pStream = pStream;

        m_pSession->m_sHints.DataSetStart.QuadPart = remoteDataSetStart.QuadPart;
        m_pSession->m_sHints.FileStart.QuadPart = remoteFileStart.QuadPart;
        m_pSession->m_sHints.FileSize.QuadPart = remoteFileSize.QuadPart;
        m_pSession->m_sHints.DataStart.QuadPart = remoteDataStart.QuadPart;
        m_pSession->m_sHints.DataSize.QuadPart = remoteDataSize.QuadPart;
        m_pSession->m_sHints.VerificationType = remoteVerificationType;
        m_pSession->m_sHints.VerificationData.QuadPart = remoteVerificationData.QuadPart;

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetBlockSize(m_sMediaParameters.BlockSize));

        if (m_Mode & MVR_MODE_APPEND) {
            // Sets the current position to the end of data.
            LARGE_INTEGER zero = {0,0};
            WsbAffirmHr(pStream->Seek(zero, STREAM_SEEK_END, NULL));
        }

        *ppStream = pStream;
        pStream.p->AddRef();

    } WsbCatchAndDo(hr,
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CloseStream"), OLESTR("StreamName=<%ls>"), m_StreamName);

    try {

        //
        // For unformatted I/O we add filemark on close
        //
        if (m_Mode & MVR_MODE_UNFORMATTED) {
            if ((m_Mode & MVR_MODE_WRITE) || (m_Mode & MVR_MODE_APPEND)) {
                try {
                    WsbAffirmHr(WriteFilemarks(1));
                } WsbCatch(hr);
            }
        }

        //
        // If we may have written to tape, sync up the space stats
        // to reflect what device reports.
        //
        if ((m_Mode & MVR_MODE_WRITE) || (m_Mode & MVR_MODE_APPEND)) {
            try {
                CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
                // marking the FreeSpace to -1 gaurantees it's stale for the
                // following GetLargestFreeSpace() call.
                WsbAffirmPointer(pInfo);
                WsbAffirmHr(pInfo->SetFreeSpace(-1));
                WsbAffirmHr(GetLargestFreeSpace(NULL, NULL));
            } WsbCatchAndDo(hr,
                hr = S_OK;
                );

        }

        //
        // Since the stream is closed, we re-init stream member data.
        //
        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;

        if (m_pSession) {
            delete m_pSession;
            m_pSession = NULL;
        }

        if (m_pStreamBuf) {

            //
            // Save of the internal buffer to the cartridge.
            //

            if ( S_OK == m_pCartridge->SaveDataCache(m_pStreamBuf, m_StreamBufSize, m_StreamBufUsed, m_StreamBufStartPBA) ) {
                WsbTrace(OLESTR("DataCache saved.\n"));
            }

            // Clear internal buffer state
            WsbFree(m_pStreamBuf);
            m_pStreamBuf = NULL;
            m_StreamBufSize = 0;
            m_StreamBufUsed = 0;
            m_StreamBufPosition = 0;
            m_StreamBufStartPBA.QuadPart = 0;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtTapeIo::Duplicate(
    IN IDataMover *pCopy,
    IN DWORD options,
    OUT ULARGE_INTEGER *pBytesCopied,
    OUT ULARGE_INTEGER *pBytesReclaimed)
/*++

Implements:

    IDataMover::Duplicate

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Duplicate"), OLESTR("<0x%08x>"), options);

    CComPtr<IStream> pOriginalStream;
    CComPtr<IStream> pCopyStream;
    ULARGE_INTEGER bytesCopied = {0,0};
    ULARGE_INTEGER bytesReclaimed = {0,0};

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Duplicate.0");

        ULARGE_INTEGER nil = {0,0};
        ULARGE_INTEGER position = {0,0};
        LARGE_INTEGER zero = {0,0};
        LARGE_INTEGER seekTo = {0,0};

        ULARGE_INTEGER originalEOD = {0,0};
        ULARGE_INTEGER copyEOD = {0,0};

        ULARGE_INTEGER bytesRead = {0,0};
        ULARGE_INTEGER bytesWritten = {0,0};

        BOOL refresh = ( options & MVR_DUPLICATE_REFRESH ) ? TRUE : FALSE;

        BOOL moreToCopy = TRUE;

        // Duplicate the unit of media.
        // MVR_DUPLICATE_UPDATE     - starts from the end of the copy.
        // MVR_DUPLICATE_REFRESH    - starts from the beginning of the original (except tape header)

        while ( moreToCopy ) {
            // We copy the SSET, data, and ESET as individual streams, and continue
            // until there's nothing more to copy.

            if ( refresh ) {
                ULONG bytesRead;

                // Create remote stream of copy
                WsbAffirmHr(pCopy->CreateRemoteStream(L"Copy", MVR_MODE_WRITE | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pCopyStream));
                WsbAssertPointer(pCopyStream);

                // Sets the current position to beginning of data.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_SET, &position));

                // The MTF labels are < 1024 bytes.  We need to read 1024 bytes + the filemark
                // (1 block), 3x the min block size covers all cases.
                WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

                ULONG nBlocks = (3*512)/m_sMediaParameters.BlockSize;
                nBlocks = (nBlocks < 2) ? 2 : nBlocks;

                ULONG bytesToRead = nBlocks * m_sMediaParameters.BlockSize;

                BYTE *pBuffer = (BYTE *)WsbAlloc(bytesToRead);
                WsbAssertPointer(pBuffer);
                memset(pBuffer, 0, bytesToRead);

                // Read upto first Filemark to skip over header.
                hr = pCopyStream->Read(pBuffer, bytesToRead, &bytesRead);
                WsbFree(pBuffer);
                pBuffer = NULL;
                WsbAssert(hr == MVR_S_FILEMARK_DETECTED, E_UNEXPECTED);

                // Gets the current position... this is the low water mark of the copy.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_CUR, &position));
                refresh = FALSE;
            }
            else {
                // Create remote stream of copy
                WsbAffirmHr(pCopy->CreateRemoteStream(L"Copy", MVR_MODE_APPEND | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pCopyStream));
                WsbAssertPointer(pCopyStream);

                // Gets the current position... this is the low water mark of the copy.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_CUR, &position));
            }

            // Create remote stream or original
            WsbAffirmHr(CreateRemoteStream(L"Master", MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pOriginalStream));
            WsbAssertPointer(pOriginalStream);

            // Set the current position to the high water mark.
            seekTo.QuadPart = position.QuadPart;
            WsbAffirmHr(pOriginalStream->Seek( seekTo, STREAM_SEEK_SET, NULL));

            // Now both streams are aligned for the copy.
            ULARGE_INTEGER bytesToCopy = {0xffffffff, 0xffffffff};

            // Copy from original to copy until we don't having anything more to read.
            hr = pOriginalStream->CopyTo(pCopyStream, bytesToCopy, &bytesRead, &bytesWritten);
            bytesCopied.QuadPart += bytesWritten.QuadPart;
            if ( FAILED(hr) ) {
                WsbThrow(hr);
            }

            if ( MVR_S_FILEMARK_DETECTED == hr ) {
                WsbAffirmHr(pCopy->CloseStream());
                pCopyStream = 0;
            }
            else {
                // End of data
                WsbAssert(MVR_S_NO_DATA_DETECTED == hr, E_UNEXPECTED);
                moreToCopy = FALSE;

                //
                // Verify we're where we think we are..
                //
                // We should always have an EOD on the copy. So affirm OK.
                //
                WsbAffirmHrOk(pCopyStream->Seek(zero, STREAM_SEEK_END, &copyEOD));
                //
                // A missing EOD which gets translated to MVR_S_NO_DATA_DETECTED, or MVR_E_CRC,
                // should not cause us to fail on the Seek.
                //
                HRESULT hrSeek = Seek(zero, STREAM_SEEK_END, &originalEOD);
                WsbAffirm(originalEOD.QuadPart == copyEOD.QuadPart, (S_OK == hrSeek) ? E_ABORT : hrSeek);

                // When we get EOD we don't write a FM, so revert RW Mode to prevent
                // Filemarks from being written.  This leaves the copy in an identical
                // state with the master.

                pCopyStream->Revert();
                WsbAffirmHr(pCopy->CloseStream());
                pCopyStream = 0;
                hr = S_OK;  // Normal completion
            }

            WsbAffirmHr(CloseStream());
            pOriginalStream = 0;

        }


    } WsbCatchAndDo(hr,
            // Revert resets the RW Mode to prevent Filemarks from being written
            // after a copy error.
            if (pCopyStream) {
                pCopyStream->Revert();
                pCopy->CloseStream();
            }
            if (pOriginalStream) {
                pOriginalStream->Revert();
            }
            CloseStream();
        );

    if ( pBytesCopied ) {
        pBytesCopied->QuadPart = bytesCopied.QuadPart;
    }
    if ( pBytesReclaimed ) {
        pBytesReclaimed->QuadPart = bytesReclaimed.QuadPart;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::Duplicate"), OLESTR("hr = <%ls>, bytesCopied=%I64u, bytesReclaimed=%I64u"),
        WsbHrAsString(hr), bytesCopied.QuadPart, bytesReclaimed.QuadPart);

    return hr;
}



STDMETHODIMP
CNtTapeIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FlushBuffers"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CNtTapeIo::FlushBuffers.0");

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Pad to the next physical block boundary and flush the device bufffer.
        WsbAffirmHr(m_pSession->ExtendLastPadToNextPBA());

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CNtTapeIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

--*/
{
    HRESULT hr = S_OK;
    *pDeleteFile = FALSE;
    WsbTraceIn(OLESTR("CNtTapeIo::Recover"), OLESTR(""));

    try {
        // Note: Recovery of the tape stream is done explicitly in BeginSession
        //  We might consider moving this code over here...
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtTapeIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CNtTapeIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead
    )
/*++

Implements:

    IStream::Read

Notes:

    Only MVR_FLAG_HSM_SEMANTICS is currently supported.

    Returns S_FALSE when no more data can be read from the stream.  EOD or FILEMARK Detected.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesRead = 0;
    ULONG bytesToCopy = 0;
    ULONG bytesToRead = 0;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Read.0");

        WsbAssert( pv != 0, STG_E_INVALIDPOINTER );

        BOOL bUseInternalBuffer = FALSE;
        ULONG offsetToData = 0;
        ULARGE_INTEGER pba = {0,0};

        if ( MVR_FLAG_HSM_SEMANTICS & m_Mode ) {
            //
            // The m_DataStart field will point to the actual start of the data stream.
            // The MTF stream header will be a few bytes before that.
            //
            if ( MVR_VERIFICATION_TYPE_NONE == m_pSession->m_sHints.VerificationType ) {
                //
                // No verification - no stream header
                //
                pba.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                                 m_pSession->m_sHints.FileStart.QuadPart +
                                 m_pSession->m_sHints.DataStart.QuadPart +
                                 m_StreamOffset.QuadPart )
                                    / m_sMediaParameters.BlockSize;

                offsetToData = (ULONG) (( m_pSession->m_sHints.DataSetStart.QuadPart + 
                                            m_pSession->m_sHints.FileStart.QuadPart + 
                                            m_pSession->m_sHints.DataStart.QuadPart +
                                            m_StreamOffset.QuadPart)
                                        % (unsigned _int64) m_sMediaParameters.BlockSize);
                bytesToRead = cb + offsetToData;
            }
            else if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                //
                // Position to the stream header and crc it first.
                //
                pba.QuadPart = (m_pSession->m_sHints.DataSetStart.QuadPart + 
                                m_pSession->m_sHints.FileStart.QuadPart + 
                               (m_pSession->m_sHints.DataStart.QuadPart - sizeof(MTF_STREAM_INFO)) ) 
                               / m_sMediaParameters.BlockSize;

                offsetToData = (ULONG) (( m_pSession->m_sHints.DataSetStart.QuadPart + 
                                            m_pSession->m_sHints.FileStart.QuadPart + 
                                            m_pSession->m_sHints.DataStart.QuadPart +
                                            m_StreamOffset.QuadPart
                                            - sizeof(MTF_STREAM_INFO))
                                        % (unsigned _int64) m_sMediaParameters.BlockSize);
                bytesToRead = cb + offsetToData + sizeof(MTF_STREAM_INFO);
            } 
            else {
                WsbThrow( E_UNEXPECTED );
            }
        }
        else if ( MVR_MODE_UNFORMATTED & m_Mode ) {

            pba.QuadPart = m_StreamOffset.QuadPart
                / m_sMediaParameters.BlockSize;

            offsetToData = (ULONG) ((m_StreamOffset.QuadPart) 
                % (unsigned _int64) m_sMediaParameters.BlockSize);
            bytesToRead = cb + offsetToData;
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Check if the current read request requires a tape access
        //

        if (// pba starts before the internal buffer, OR
            (pba.QuadPart < m_StreamBufStartPBA.QuadPart) ||
            // pba starts beyond the internal buffer, OR
            (pba.QuadPart >= (m_StreamBufStartPBA.QuadPart + (m_StreamBufUsed / m_sMediaParameters.BlockSize)))  ||
            // the internal buffer is not valid.
            (!m_StreamBufUsed) ) {

            //
            // Then, we must read data from tape
            //

            //
            // Set Position
            //
            if ( pba.QuadPart != m_StreamPBA.QuadPart ) {
                //
                // AffirmOk to fail if EOD reached before desired pba.
                //
                WsbAffirmHrOk(SetPosition(pba.QuadPart));
            }

            // We should now be positioned at the beginning of the block containing
            // the start of the stream OR at the beginning of data.

            //
            // Read data
            //
            // We can use the output buffer if the offset and size are aligned 
            // on block boundaries and there is no verification , otherwise we must use 
            // the internal stream buffer.
            //

            if ( (MVR_VERIFICATION_TYPE_NONE != m_pSession->m_sHints.VerificationType ) ||
                 (offsetToData) ||
                 (cb % m_sMediaParameters.BlockSize) ) {

                /*****************************************
                !!! Old Method !!!
                if ( bytesToRead < m_StreamBufSize ) {
                    //  Round up the number of bytes to read so we read full blocks
                    bytesToRead = bytesToRead + m_sMediaParameters.BlockSize - 
                            (bytesToRead % m_sMediaParameters.BlockSize);
                }
                *****************************************/
                bytesToRead = m_StreamBufSize;

                WsbTrace(OLESTR("Reading %u (%u) bytes...\n"), bytesToRead, m_StreamBufSize);
                m_StreamBufStartPBA = pba;
                hr = ReadBuffer(m_pStreamBuf, bytesToRead, &bytesRead);
                if ( FAILED(hr) ) {
                    m_StreamBufUsed = 0;
                    WsbThrow(hr)
                }
                bUseInternalBuffer = TRUE;
                m_StreamBufUsed = bytesRead;

                //
                // Do the verification here, if needed
                //

                if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {

                    MTF_STREAM_INFO sSTREAM;
                    WIN32_STREAM_ID sStreamHeader;      // comes back from Win32 BackupRead

                    //
                    // If we're positioned before a tapemark, the read will succeed,
                    // but no bytes will have been read.  This shouldn't happen when
                    // recalling data.
                    //
                    WsbAssert(bytesRead > 0, MVR_E_UNEXPECTED_DATA);

                    ///////////////////////////////////////////////////////////////////////////////////////
                    //
                    // TODO: Special code for when:
                    //          offsetToData + sizeof(MTF_STREAM_INFO) > nBytesRead
                    //
                    // IMPORTANT NOTE:  In theory this special case should be possible,
                    //                  but this has never been observed, so we assert
                    //                  to test the special case logic.
                    WsbAssert(offsetToData < bytesRead, MVR_E_UNEXPECTED_DATA);
                    WsbAssert((offsetToData + sizeof(MTF_STREAM_INFO)) <= bytesRead, MVR_E_UNEXPECTED_DATA);
                    //
                    // TODO: Now that we asserted, let's see if the code to handle this case works!
                    //
                    ///////////////////////////////////////////////////////////////////////////////////////
    
    
                    if ( (offsetToData + sizeof(MTF_STREAM_INFO)) <= bytesRead ) {
                        CMTFApi::MTF_ReadStreamHeader(&sSTREAM, &m_pStreamBuf[offsetToData]);
                        offsetToData += sizeof(MTF_STREAM_INFO);
                    }
                    else {
                        LONG nBytes;
    
                        nBytes = bytesRead - offsetToData;
    
                        // if nBytes is negative the FILE DBLK is larger the the buffer
                        // and I don't think this is possible?
                        WsbAssert(nBytes >= 0, MVR_E_LOGIC_ERROR);
    
                        if (nBytes) {
                            memcpy( &sSTREAM, &m_pStreamBuf[offsetToData], nBytes);
                        }
    
                        m_StreamOffset.QuadPart += nBytes;
                        m_StreamBufStartPBA = pba;
                        hr = ReadBuffer(m_pStreamBuf, m_StreamBufSize, &bytesRead);
                        if ( FAILED(hr) ) {
                            m_StreamBufUsed = 0;
                            WsbThrow(hr)
                        }
                        m_StreamBufUsed = bytesRead;
    
                        memcpy( &sSTREAM+nBytes, m_pStreamBuf, sizeof(MTF_STREAM_INFO)-nBytes);
                        offsetToData = sizeof(MTF_STREAM_INFO) - nBytes;
                    }
    

                    // Convert STREAM to WIN32 streamID
                    CMTFApi::MTF_SetStreamIdFromSTREAM(&sStreamHeader, &sSTREAM, 0);

                    try {
                        // Make sure it is the correct type of header
                        WsbAffirm((0 == memcmp(sSTREAM.acStreamId, "STAN", 4)), MVR_E_UNEXPECTED_DATA);

                        // Verify the stream header checksum
                        WsbAffirm((m_pSession->m_sHints.VerificationData.QuadPart == sSTREAM.uCheckSum), MVR_E_UNEXPECTED_DATA);
                    } catch (HRESULT catchHr) {
                        hr = catchHr;

                        //
                        // Log the error.
                        //
                        // This is an unrecoverable recall error.  We need to put as much info
                        // in the event log to handle the probable service call.
                        //
                        // We try to output at least MaxBytes starting with the stream
                        // header to give a clue of what we tried to recall.  If there isn't
                        // enough data through the end of the buffer we back out until we
                        // get upto MaxBytes and record the expected location of the stream
                        // header in the event message.
                        //
                        const int MaxBytes = 4*1024;                        // Max data bytes to log
                        int size = 0;                                       // Size of data to be logged.
                        int loc = 0;                                        // location of start of bogus stream header in log data       
                        int start = offsetToData - sizeof(MTF_STREAM_INFO); // start of log data relativet the data buffer.
                        int nBytes = bytesRead - start;                     // Number of bytes through the end of the data buffer
                        if (nBytes < MaxBytes) {
                            // Adjust the start/location
                            start = bytesRead - MaxBytes;
                            if (start < 0) {
                                start = 0;
                            }
                            nBytes = bytesRead - start;
                            loc = offsetToData - sizeof(MTF_STREAM_INFO) - start;
                        }

                        // Allocate and copy data to log

                        // Only copy user data when building debug code
                        if ( MVR_DEBUG_OUTPUT ) {
                            size = nBytes < MaxBytes ? nBytes : MaxBytes;
                        }

                        unsigned char *data = (unsigned char *) WsbAlloc(size + sizeof(MVR_REMOTESTORAGE_HINTS));

                        if (data) {
                            memset(data, 0, size + sizeof(MVR_REMOTESTORAGE_HINTS));
                            if ( MVR_DEBUG_OUTPUT ) {
                                memcpy(&data[0], &m_pStreamBuf[start], size);
                            }

                            memcpy(&data[size], &m_pSession->m_sHints, sizeof(MVR_REMOTESTORAGE_HINTS));
                            size += sizeof(MVR_REMOTESTORAGE_HINTS);
                        }
                        else {
                            size = 0;
                        }

                        //
                        // Output the message and data to the event log.
                        //
                        CWsbBstrPtr name;
                        CWsbBstrPtr desc;

                        if (m_pCartridge) {
                            m_pCartridge->GetName(&name);
                            m_pCartridge->GetDescription(&desc);
                        }

                        WCHAR location[16];
                        WCHAR offset[16];
                        WCHAR mark[16];
                        WCHAR found[16];

                        swprintf(found, L"0x%04x", sSTREAM.uCheckSum);
                        swprintf(location, L"%I64u", pba.QuadPart);
                        swprintf(offset, L"%d", offsetToData - sizeof(MTF_STREAM_INFO));
                        swprintf(mark, L"0x%04x", loc);

                        WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA,
                            size, data,
                            found,
                            (WCHAR *) name,
                            (WCHAR *) desc,
                            location, offset, mark,
                            NULL);

                        if (data) {
                            WsbFree(data);
                            data = NULL;
                        }

                        WsbThrow(hr);
                    }

                    //
                    // Set the verification type to none so we only do this once
                    //
                    m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
                }
            }
            else {
                WsbTrace(OLESTR("Reading %u bytes.\n"), cb);
                hr = ReadBuffer((BYTE *) pv, cb, &bytesRead);
                if ( FAILED(hr) ) {
                    WsbThrow(hr)
                }
                else {
                    switch (hr) {
                    case MVR_S_FILEMARK_DETECTED:
                    case MVR_S_SETMARK_DETECTED:
                        m_StreamOffset.QuadPart += (unsigned _int64) m_sMediaParameters.BlockSize;
                        break;
                    }
                }
            }
        }
        else {
            bUseInternalBuffer = TRUE;

            // We need to re-calculate the offset relative the internal buffer.
            // The orginal offset is the offset from the beginning of the nearest
            // block.  We need an offset relative the beginning of the internal buffer.

            offsetToData += (ULONG)((pba.QuadPart - m_StreamBufStartPBA.QuadPart)*(unsigned _int64) m_sMediaParameters.BlockSize);
            
            // !!!TEMPORARY 
            if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                offsetToData += sizeof(MTF_STREAM_INFO);
            }
            m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
        }

        if ( bUseInternalBuffer ) {
            //
            // Just copy the previously read data from the internal stream buffer.
            //
            ULONG maxBytesToCopy;
            maxBytesToCopy = m_StreamBufUsed - offsetToData;

            bytesToCopy = ( cb < maxBytesToCopy ) ? cb : maxBytesToCopy;
            memcpy( pv, &m_pStreamBuf[offsetToData], bytesToCopy );
            bytesRead = bytesToCopy;

        }

        m_StreamOffset.QuadPart += bytesRead;

        if ( pcbRead ) {
            *pcbRead = bytesRead;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Read"), OLESTR("hr = <%ls> bytes Read = %u, new offset = %I64u"), WsbHrAsString(hr), bytesRead, m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Write(
    OUT void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Write.0");

        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);
        UINT64 pos = m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize;

        int retry;
        const int delta = 10;
        const int MaxRetry = 0;  // TODO:  This needs work; disabled for now.

        retry = 0;
        do {
            try {
                // Consistency Check
                // WsbAffirmHr(EnsurePosition(pos));

                // UINT64 curPos;
                // WsbAffirmHr(GetPosition(&curPos));  // This kills DLT performance
                // WsbAssert(curPos == m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize, E_UNEXPECTED);

                // Can't retry if part of the buffer has already been written.
                WsbAssert(0 == bytesWritten, E_ABORT);

                WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));
                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;
            } WsbCatchAndDo(hr,
                    switch (hr) {
                    // Can't recover from these since they indicate the media may have changed,
                    // or device parameters are reset to defaults.
                    /**************************************
                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_IO_DEVICE:
                    **************************************/

                    // This may still be unsafe... not sure if partial i/o completes
                    case MVR_E_CRC:
                        if (retry < MaxRetry) {
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device to come ready - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000); // Sleep a few seconds to give the device time to quite down... This may be useless!
                            hr = S_OK;
                        }
                        else {
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    // Can't do anything about this one... just quietly fail.
                    case MVR_E_END_OF_MEDIA:
                        WsbThrow(hr);
                        break;

                    default:
                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;
                    }
                );
        } while (++retry < MaxRetry);

    } WsbCatch(hr);

    if (pcbWritten) {
        *pcbWritten = bytesWritten;
    }

    // Now update the storage info stats for the cartridge.
    CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
    if (pInfo) {
        pInfo->IncrementBytesWritten(bytesWritten);
    }

    // Update the stream model
    m_StreamOffset.QuadPart += bytesWritten;
    m_StreamSize = m_StreamOffset; // For tape this is always true

    WsbTraceOut(OLESTR("CNtTapeIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition
    )
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Seek"), OLESTR("<%I64d> <%d>; offset=%I64u"), dlibMove.QuadPart, dwOrigin, m_StreamOffset.QuadPart);

    ULARGE_INTEGER newPosition;
    UINT64 curPos;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Seek.0");

        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        newPosition.QuadPart = 0;

        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            // If reading, defer physical move 'til later...
            if (!(m_Mode & MVR_MODE_READ)) {
                WsbAffirmHr(SetPosition(dlibMove.QuadPart/m_sMediaParameters.BlockSize));
            }
            m_StreamOffset.QuadPart = dlibMove.QuadPart;

            if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
                m_StreamSize = m_StreamOffset;
            }

            break;

        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart != 0) {
                // If reading, defer physical move 'til later...
                if (!(m_Mode & MVR_MODE_READ)) {
                    WsbAffirmHr(SetPosition((m_StreamOffset.QuadPart + dlibMove.QuadPart)/m_sMediaParameters.BlockSize));
                }
                m_StreamOffset.QuadPart += dlibMove.QuadPart;
            }
            else {
                WsbAffirmHr(GetPosition(&curPos));
                m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            }

            if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
                m_StreamSize = m_StreamOffset;
            }

            break;

        case STREAM_SEEK_END:
            // TODO: FIX:  We can use WsbAffirmHrOk when missing EOD markers is translated to MVR_S_NO_DATA_DETECTED.
            hr = SpaceToEndOfData(&curPos);
            m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            m_StreamSize = m_StreamOffset;
            break;

        case 100:
            // dlibMove is a DataSet number.
            WsbAffirmHrOk(RewindTape());
            WsbAffirmHrOk(SpaceFilemarks((LONG)(1+(dlibMove.QuadPart-1)*2), &curPos));
            m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            m_StreamSize = m_StreamOffset;
            break;

        default:
            WsbThrow( STG_E_INVALIDFUNCTION );
        }

        newPosition.QuadPart = m_StreamOffset.QuadPart;

        if ( plibNewPosition ) {
            plibNewPosition->QuadPart = newPosition.QuadPart;
        }

    } WsbCatch(hr);


    //
    // TODO: Do we need to invalidate the internal stream buffer, or reset the
    //       stream buffer position to correspond to the stream offset?
    //

    WsbTraceOut(OLESTR("CNtTapeIo::Seek"), OLESTR("hr = <%ls>, new offset=%I64u"), WsbHrAsString(hr), m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    ULARGE_INTEGER totalBytesRead = {0,0};
    ULARGE_INTEGER totalBytesWritten = {0,0};

    BYTE *pBuffer = NULL;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::CopyTo.0");

        WsbAssert(pstm != 0, STG_E_INVALIDPOINTER);
        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        ULONG defaultBufferSize = DefaultMinBufferSize;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG bufferSize;
        ULONG nBlocks = defaultBufferSize/m_sMediaParameters.BlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_sMediaParameters.BlockSize;

        pBuffer = (BYTE *) WsbAlloc(bufferSize);
        WsbAssertPointer(pBuffer);
        memset(pBuffer, 0, bufferSize);

        ULONG           bytesToRead;
        ULONG           bytesRead;
        ULONG           bytesWritten;
        ULARGE_INTEGER  bytesToCopy;

        bytesToCopy.QuadPart = cb.QuadPart;

        while ((bytesToCopy.QuadPart > 0) && (S_OK == hr)) {
            bytesRead = 0;
            bytesWritten = 0;

            bytesToRead =  (bytesToCopy.QuadPart < bufferSize) ? bytesToCopy.LowPart : bufferSize;

            hr = Read(pBuffer, bytesToRead, &bytesRead);
            totalBytesRead.QuadPart += bytesRead;

            WsbAffirmHrOk(pstm->Write(pBuffer, bytesRead, &bytesWritten));
            totalBytesWritten.QuadPart += bytesWritten;

            bytesToCopy.QuadPart -= bytesRead;

        }

        if (pcbRead) {
            pcbRead->QuadPart = totalBytesRead.QuadPart;
        }

        if (pcbWritten) {
            pcbWritten->QuadPart = totalBytesWritten.QuadPart;
        }

        // TODO: FIX:  We'll be getting an error if there's a missing EOD marker.
        // This is hacked-up until we get a correct error code from
        // the drivers, at which time we can remove this code.
        if (FAILED(hr)) {
            LARGE_INTEGER   zero = {0,0};
            ULARGE_INTEGER  pos1, pos2;

            WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, &pos1));
            // We're looking for the same error conditon and
            // verifying position doesn't change.
            if (hr == Seek(zero, STREAM_SEEK_END, &pos2)){
                if (pos1.QuadPart == pos2.QuadPart) {
                    hr = MVR_S_NO_DATA_DETECTED;
                }
            }
            else {
                WsbThrow(hr);
            }
        }

    } WsbCatch(hr);

    if (pBuffer) {
        WsbFree(pBuffer);
        pBuffer = NULL;
    }


    WsbTraceOut(OLESTR("CNtTapeIo::CopyTo"), OLESTR("hr = <%ls>, bytesRead=%I64u, bytesWritten=%I64u"),
        WsbHrAsString(hr), totalBytesRead.QuadPart, totalBytesWritten.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Commit"), OLESTR("0x%08x"), grfCommitFlags);

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Commit.0");

        // Consistency Check
        // UINT64 pos = m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize;;
        // WsbAffirmHr(EnsurePosition(pos));
        UINT64 curPos;
        WsbAffirmHr(GetPosition(&curPos));
        WsbAssert(curPos == m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize, E_UNEXPECTED);

        // This is a real stretch!
        WsbAffirmHr(WriteFilemarks(grfCommitFlags));

        // Now update the storage info stats for the cartridge.
        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
        pInfo->IncrementBytesWritten(grfCommitFlags*m_sMediaParameters.BlockSize);

        m_StreamOffset.QuadPart += grfCommitFlags*m_sMediaParameters.BlockSize;
        m_StreamSize = m_StreamOffset; // For tape this is always true

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Revert"), OLESTR(""));

    try {

        m_Mode = 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// Local and Static Methods
//


HRESULT
CNtTapeIo::OpenTape(void)
/*++

Routine Description:

    Opens the tape drive and gets media and drive info

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::OpenTape"), OLESTR("<%ls>"), m_DeviceName);

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        MvrInjectError(L"Inject.CNtTapeIo::OpenTape.0");

        WsbAssert(wcscmp((WCHAR *)m_DeviceName, MVR_UNDEFINED_STRING), MVR_E_LOGIC_ERROR);
        WsbAssertPointer(m_pCartridge);

        DWORD nStructSize;

        int retry;
        const int delta = 10;
        const int MaxRetry = 10;

        retry = 0;
        do {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.CreateFile.0");

                // ** WIN32 Tape API Call - open the tape drive for read/write
                WsbAffirmHandle(m_hTape = CreateFile(m_DeviceName, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));

                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.CreateFile.1");
                
                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_OPENTAPE) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);

                    switch (hr) {

                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:

                        if (retry < MaxRetry){
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000);
                            hr = S_OK;
                        }
                        else {
                            //
                            // This is the last try, so log the failure.
                            //
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    default:

                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;

                    }

                );

        } while (++retry < MaxRetry);

        retry = 0;
        do {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeStatus.0");

                // ** WIN32 Tape API Call - get the tape status
                WsbAffirmNoError(GetTapeStatus(m_hTape));

                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeStatus.1");

                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_OPENTAPE) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);

                    switch (hr) {

                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_ERROR_IO_DEVICE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_NOT_READY:

                        if (retry < MaxRetry){
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000);
                            hr = S_OK;
                        }
                        else {
                            //
                            // This is the last try, so log the failure.
                            //
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    default:

                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;

                    }

                );

        } while (++retry < MaxRetry);

        nStructSize = sizeof(TAPE_GET_DRIVE_PARAMETERS) ;

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.0");

            // ** WIN32 Tape API Call - get the tape drive parameters
            WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_DRIVE_INFORMATION, &nStructSize, &m_sDriveParameters));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_OPENTAPE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        // Set the Block Size to the default for the device, or DefaultBlockSize.
        TAPE_SET_MEDIA_PARAMETERS parms;

        LONG nBlockSize = 0;
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->GetBlockSize(&nBlockSize));
        }

        if (0 == nBlockSize) {

            // If the block size is zero, it must be scratch media!
            if (m_pCartridge) {
                LONG status;
                WsbAffirmHr(m_pCartridge->GetStatus(&status));
                WsbAssert(RmsStatusScratch == status, E_UNEXPECTED);
            }

            // Allow registry override!

            DWORD size;
            OLECHAR tmpString[256];
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BLOCK_SIZE, tmpString, 256, &size))) {
                // Get the value.
                nBlockSize = wcstol(tmpString, NULL, 10);

                // BlockSize must be a multiple of 512.
                if (nBlockSize % 512) {
                    // The block size specified is not valid, revert to default setting.
                    nBlockSize = 0;
                }
            }
        }

        if (nBlockSize > 0) {
            parms.BlockSize = nBlockSize;
        }
        else {
            // NOTE:  We can't arbitrarily use the default block size for the device.  It could
            // change between different devices supporting the same media format.  Migrate / Recall
            // operations depend on using the same block size.

            parms.BlockSize = m_sDriveParameters.DefaultBlockSize;
        }

        WsbTrace( OLESTR("Setting Block Size to %d bytes/block.\n"), parms.BlockSize);

        WsbAssert(parms.BlockSize > 0, E_UNEXPECTED);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.SetTapeParameters.1");

            // ** WIN32 Tape API Call - set the tape drive parameters
            WsbAffirmNoError(SetTapeParameters(m_hTape, SET_TAPE_MEDIA_INFORMATION, &parms));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.SetTapeParameters.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_OPENTAPE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        nStructSize = sizeof( TAPE_GET_MEDIA_PARAMETERS );

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.2.0");

            // ** WIN32 Tape API Call - get the media parameters
            WsbAffirmNoError( GetTapeParameters(m_hTape, GET_TAPE_MEDIA_INFORMATION, &nStructSize, &m_sMediaParameters));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.2.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_OPENTAPE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        // Make sure we have a media block size that we can deal with.
        WsbAssert(m_sMediaParameters.BlockSize > 0, E_UNEXPECTED);
        WsbAssert(!(m_sMediaParameters.BlockSize % 512), E_UNEXPECTED);

        WsbTrace( OLESTR("Media Parameters:\n"));
        WsbTrace( OLESTR("  BlockSize           = %d bytes/block.\n"), m_sMediaParameters.BlockSize);
        WsbTrace( OLESTR("  Capacity            = %I64u\n"), m_sMediaParameters.Capacity.QuadPart);
        WsbTrace( OLESTR("  Remaining           = %I64u\n"), m_sMediaParameters.Remaining.QuadPart);
        WsbTrace( OLESTR("  PartitionCount      = %d\n"), m_sMediaParameters.PartitionCount);
        WsbTrace( OLESTR("  WriteProtect        = %ls\n"), WsbBoolAsString(m_sMediaParameters.WriteProtected));

        WsbTrace( OLESTR("Drive Parameters:\n"));
        WsbTrace( OLESTR("  ECC                 = %ls\n"), WsbBoolAsString(m_sDriveParameters.ECC));
        WsbTrace( OLESTR("  Compression         = %ls\n"), WsbBoolAsString(m_sDriveParameters.Compression));
        WsbTrace( OLESTR("  DataPadding         = %ls\n"), WsbBoolAsString(m_sDriveParameters.DataPadding));
        WsbTrace( OLESTR("  ReportSetmarks      = %ls\n"), WsbBoolAsString(m_sDriveParameters.ReportSetmarks));
        WsbTrace( OLESTR("  DefaultBlockSize    = %d (%d, %d)\n"),
            m_sDriveParameters.DefaultBlockSize,
            m_sDriveParameters.MinimumBlockSize,
            m_sDriveParameters.MaximumBlockSize);
        WsbTrace( OLESTR("  MaxPartitionCount   = %d\n"), m_sDriveParameters.MaximumPartitionCount);
        WsbTrace(     OLESTR("  FeaturesLow         = 0x%08x      FIXED(%d)            SELECT(%d)          INITIATOR(%d)\n"),
            m_sDriveParameters.FeaturesLow,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_FIXED ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_SELECT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_INITIATOR ? 1 : 0);
        WsbTrace( OLESTR("                                        ERASE_SHORT(%d)      ERASE_LONG(%d)      ERASE_BOP_ONLY(%d)   ERASE_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_SHORT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_LONG ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_BOP_ONLY ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        TAPE_CAPACITY(%d)    TAPE_REMAINING(%d)  FIXED_BLOCK(%d)      VARIABLE_BLOCK(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_CAPACITY ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_REMAINING ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_FIXED_BLOCK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_VARIABLE_BLOCK ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_PROTECT(%d)    EOT_WZ_SIZE(%d)     ECC(%d)              COMPRESSION(%d)      PADDING(%d)        REPORT_SMKS(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_WRITE_PROTECT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_EOT_WZ_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ECC ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_COMPRESSION ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_PADDING ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_REPORT_SMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        GET_ABSOLUTE_BLK(%d) GET_LOGICAL_BLK(%d) SET_EOT_WZ_SIZE(%d)  EJECT_MEDIA(%d)      CLEAN_REQUESTS(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_GET_ABSOLUTE_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_GET_LOGICAL_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_SET_EOT_WZ_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_EJECT_MEDIA ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_CLEAN_REQUESTS ? 1 : 0);
        WsbTrace(     OLESTR("  FeaturesHigh        = 0x%08x      LOAD_UNLOAD(%d)      TENSION(%d)         LOCK_UNLOCK(%d)      REWIND_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOAD_UNLOAD ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_TENSION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOCK_UNLOCK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_REWIND_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        SET_BLOCK_SIZE(%d)   LOAD_UNLD_IMMED(%d) TENSION_IMMED(%d)    LOCK_UNLK_IMMED(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_BLOCK_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOAD_UNLD_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_TENSION_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOCK_UNLK_IMMED ? 1 : 0);
        WsbTrace( OLESTR("                                        SET_ECC(%d)          SET_COMPRESSION(%d) SET_PADDING(%d)      SET_REPORT_SMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_ECC ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_COMPRESSION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_PADDING ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_REPORT_SMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        ABSOLUTE_BLK(%d)     ABS_BLK_IMMED(%d)   LOGICAL_BLK(%d)      LOG_BLK_IMMED(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_ABSOLUTE_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_ABS_BLK_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOGICAL_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOG_BLK_IMMED ? 1 : 0);
        WsbTrace( OLESTR("                                        END_OF_DATA(%d)      RELATIVE_BLKS(%d)   FILEMARKS(%d)        SEQUENTIAL_FMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_END_OF_DATA ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_RELATIVE_BLKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FILEMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SEQUENTIAL_FMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        SETMARKS(%d)         SEQUENTIAL_SMKS(%d) REVERSE_POSITION(%d) SPACE_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SETMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SEQUENTIAL_SMKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_REVERSE_POSITION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SPACE_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_SETMARKS(%d)   WRITE_FILEMARKS(%d) WRITE_SHORT_FMKS(%d) WRITE_LONG_FMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_SETMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_FILEMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_SHORT_FMKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_LONG_FMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_MARK_IMMED(%d) FORMAT(%d)          FORMAT_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_MARK_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FORMAT ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FORMAT_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("  EOTWarningZoneSize  = %d\n"), m_sDriveParameters.EOTWarningZoneSize);


        //
        // We assume the label is valid unless the flag is knocked down
        // while opening the device.  This could happen if we get a bus
        // reset between the mount the OpenTape call.
        //
        if (!m_ValidLabel) {

            CWsbBstrPtr label;
            WsbAffirmHr(ReadLabel(&label));
            WsbAffirmHr(VerifyLabel(label));

        }

    } WsbCatchAndDo(hr,
            // Clean up...
            (void) CloseTape();
        );

    WsbTraceOut(OLESTR("CNtTapeIo::OpenTape"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::CloseTape(void)
/*++

Routine Description:

    Closes the tape drive.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CloseTape"), OLESTR("DeviceName=<%ls>"), m_DeviceName);

    //
    // CloseTape() can be called from RsSub during dismount, and/or shutdown.
    //
    // <<<<< ENTER SINGLE THREADED SECTION
    WsbAffirmHr(Lock());

    if (INVALID_HANDLE_VALUE != m_hTape) {

        try {

            // ** WIN32 Tape API Call - close the tape drive
            WsbTraceAlways(OLESTR("Closing %ls...\n"), m_DeviceName);
            WsbAffirmStatus(CloseHandle( m_hTape ));
            WsbTraceAlways(OLESTR("%ls was closed.\n"), m_DeviceName);

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_CLOSETAPE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        m_hTape = INVALID_HANDLE_VALUE;
        m_ValidLabel = FALSE;
    }

    WsbAffirmHr(Unlock());
    // >>>>> LEAVE SINGLE THREADED SECTION

    WsbTraceOut(OLESTR("CNtTapeIo::CloseTape"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // making sure that we are writting only full blocks
        WsbAssert(!(nBytesToWrite % m_sMediaParameters.BlockSize), E_INVALIDARG);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::WriteBuffer.WriteFile.0");

            // ** WIN32 Tape API Call - write the data
            WsbAffirmStatus(WriteFile(m_hTape, pBuffer, nBytesToWrite, pBytesWritten, 0));

            MvrInjectError(L"Inject.CNtTapeIo::WriteBuffer.WriteFile.1");
        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_WRITE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        // making sure that we have written only full blocks
        WsbAssert(!(*pBytesWritten % m_sMediaParameters.BlockSize), E_UNEXPECTED);

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtTapeIo::ReadBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        static WCHAR errBuf[32];
        static BOOL bFirstTime = TRUE;

        WsbAffirmHrOk(IsAccessEnabled());

        // making sure that we are reading only full blocks
        WsbAssert(!(nBytesToRead % m_sMediaParameters.BlockSize), MVR_E_LOGIC_ERROR);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::ReadBuffer.ReadFile.0");

            // ** WIN32 Tape API Call - read the data
            WsbAffirmStatus(ReadFile(m_hTape, pBuffer, nBytesToRead, pBytesRead, 0));

            MvrInjectError(L"Inject.CNtTapeIo::ReadBuffer.ReadFile.1");

        } WsbCatchAndDo(hr,
                // Get error string once since Read may return a none-OK status which 
                // is not really an error
                if (bFirstTime) {
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_READ) != S_OK) {
                        tmpString = L"";
                    }
                    if (wcslen(tmpString) >= 32) {
                        tmpString = L"";
                    }
                    wcscpy(errBuf, tmpString);
                    bFirstTime = FALSE;
                }

                hr = MapTapeError(hr, errBuf);

                // Errors like filemark detected and end-of-data are Okay!

                if ( FAILED(hr) ) {
                   WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, errBuf, WsbHrAsString(hr), NULL);
                }

            );

        // making sure that we have read only full blocks
        WsbAssert(!(*pBytesRead % m_sMediaParameters.BlockSize), E_UNEXPECTED);

        m_StreamPBA.QuadPart += *pBytesRead / m_sMediaParameters.BlockSize;

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtTapeIo::WriteFilemarks(
    IN ULONG nCount)
/*++

Routine Description:

    Writes count filemarks at the current location.

Arguments:

    nCount      -  Number of Filemarks to write.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::WriteFilemarks"), OLESTR("<%u>"), nCount);

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        UINT64 pos;
        WsbAffirmHr(GetPosition(&pos));

        // Some drives support the default, others require long filemarks.
        if ( m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_FILEMARKS ) {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.1.0");

                // ** WIN32 Tape API Call - write a filemark
                WsbAffirmNoError(WriteTapemark(m_hTape, TAPE_FILEMARKS, nCount, FALSE));

                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.1.1");

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_WRITEFILEMARKS) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            WsbTrace(OLESTR("  %d Filemark(s) @ PBA %I64u\n"), nCount, pos );

        }
        else if ( m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_LONG_FMKS ) {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.2.0");

                // ** WIN32 Tape API Call - write a filemark
                WsbAffirmNoError(WriteTapemark(m_hTape, TAPE_LONG_FILEMARKS, nCount, FALSE));

                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.2.1");

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_WRITEFILEMARKS) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            WsbTrace(OLESTR("  %d Long Filemark(s) @ PBA %I64u\n"), nCount, pos );

        }
        else {
            // Short filemark???
            WsbThrow( E_UNEXPECTED );
        }


    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, L"", WsbHrAsString(hr), NULL);
        );


    WsbTraceOut(OLESTR("CNtTapeIo::WriteFilemarks"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::GetPosition(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetPosition"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAssertPointer(pPosition);
        WsbAffirmHrOk(IsAccessEnabled());

        DWORD uPartition, uLSB, uMSB;
        ULARGE_INTEGER pba;

        try {
            MvrInjectError(L"Inject.CNtTapeIo::GetPosition.GetTapePosition.0");

            // ** WIN32 Tape API Call - get the PBA
            WsbAffirmNoError(GetTapePosition(m_hTape, TAPE_LOGICAL_POSITION, &uPartition, &uLSB, &uMSB));

            MvrInjectError(L"Inject.CNtTapeIo::GetPosition.GetTapePosition.1");

            pba.LowPart = uLSB;
            pba.HighPart = uMSB;

            curPos = pba.QuadPart;

            WsbTrace(OLESTR("CNtTapeIo::GetPosition - <%d> <%I64u>\n"), uPartition, curPos);

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_GETPOSITION) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::GetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::SetPosition(
    IN UINT64 position)
/*++

Routine Description:

    Mover to the specified physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetPosition"), OLESTR("<%I64u>"), position);

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        MvrInjectError(L"Inject.CNtTapeIo::SetPosition.0");

        //
        // NOTE:  By first checking the current block address with the one we want we 
        //        avoid an expensive seek in the case where the tape is already located at
        //        the desired block address (not all devices know where they are, and seeking
        //        to the current block address is expensive).
        //
        // TODO:  It is faster to just read a few thousand blocks rather than seek to a position that
        //        is a few thousand blocks away. If we're within this threshold we could read from
        //        tape into the bit bucket to advance the tape.
        // 

        WsbAffirmHr(GetPosition(&curPos));
        if (curPos != position ) {

            ULARGE_INTEGER PBA;
            PBA.QuadPart = position;

            try {

                if (0 == position) {
                    WsbAffirmHr(RewindTape());
                }
                else {
                    MvrInjectError(L"Inject.CNtTapeIo::SetPosition.SetTapePosition.1");

                    // ** WIN32 Tape API Call - set the PBA
                    WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_LOGICAL_BLOCK, 1, PBA.LowPart, PBA.HighPart, FALSE));

                    MvrInjectError(L"Inject.CNtTapeIo::SetPosition.SetTapePosition.0");
                
                }

            } WsbCatchAndDo(hr,
                    CWsbStringPtr tmpString;
                    if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_SETPOSITION) != S_OK) {
                        tmpString = L"";
                    }
                    hr = MapTapeError(hr, tmpString);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            curPos = position;
        }

        m_StreamPBA.QuadPart = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}



HRESULT
CNtTapeIo::EnsurePosition(
    IN UINT64 position)
/*++

Routine Description:

    Checks that the tape is positioned at the specified current physical block
    address relative to the current partition.  If it is not an attempt is made 
    to recover to the specified position.

Arguments:

    postion     -  The physical block address to verify.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::EnsurePosition"), OLESTR("<%I64u>"), position);

    UINT64 curPos = 0xffffffffffffffff;

    try {

        // Consistency Check
        WsbAffirmHr(GetPosition(&curPos));
        if (curPos != position) {
            // Houston, we've got a problem here...
            // Most likely a bus reset caused the tape position to change.
            WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA_SET_LOCATION_DETECTED, 0, NULL,
                WsbQuickString(WsbLonglongAsString(position)), 
                WsbQuickString(WsbLonglongAsString(curPos)), NULL);

            // Only recover from complete automatic tape rewinds after a bus reset.
            if (curPos == 0) {
                WsbAffirmHr(SpaceToEndOfData(&curPos));

                // If we still don't line up we've got bigger problems... Note that this 
                // can happen if the device's internal buffer had not been flushed prior 
                // to the bus reset.  (The different tape formats tend to have different 
                // rules governing when the drive buffer is flushed/committed.  DLT and 
                // 4mm tend to commit every couple seconds, but 8mm (at least Exabyte 
                // 8505 8mm tape drives) do not commit until the drive buffer is full.)  
                // If the buffer was not committed prior to bus reset then the data 
                // Remote Storage thinks was written to the tape was never actually 
                // written, and is lost.  In such a case, the 'SpaceToEndOfData()' call 
                // above will only position the tape to the end of the last data actually 
                // committed to the tape, which will not match what we are expecting, so 
                // the following branch will be taken.
                if (curPos != position) {
                    WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA_SET_LOCATION_DETECTED, 0, NULL,
                        WsbQuickString(WsbLonglongAsString(position)), 
                        WsbQuickString(WsbLonglongAsString(curPos)), NULL);
                    WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, 
                        WsbHrAsString(MVR_E_LOGIC_ERROR), NULL);
                    WsbThrow(MVR_E_LOGIC_ERROR);
                }

                WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);
            }
            else {
                WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, 
                        WsbHrAsString(E_ABORT), NULL);
                WsbThrow(E_ABORT);
            }
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::EnsurePosition"), OLESTR("hr = <%ls>"), 
                        WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::SpaceFilemarks(
    IN LONG count,
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Spaces the tape forward or backward by the number of filesmarks specified.

Arguments:

    count       - Specifies the number of filemarks to space over from the current position.
                  A positive count spaces the tape forward, and positions after the last filemark.
                  A negative count spaces the tape backward, and positions to the beginning of
                  the last filemark.  If the count is zero, the tape position is not changed.

    pPostion    - Receives the physical block address after positioning.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SpaceFilemarks"), OLESTR("<%d>"), count);

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::SpaceFilemarks.SetTapePosition.0");

            // ** WIN32 Tape API Call - position to the specified filemark
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_SPACE_FILEMARKS, 0, count, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::SpaceFilemarks.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_SETPOSITIONFILEMARKS) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SpaceFilemarks"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::SpaceToEndOfData(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Positions the tape to the end of data of the current partition.

Arguments:

    pPostion    -  Receives the physical block address at end of data.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SpaceToEndOfData"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::SpaceToEndOfData.SetTapePosition.0");

            // ** WIN32 Tape API Call - position to end of data
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_SPACE_END_OF_DATA, 0, 0, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::SpaceToEndOfData.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_SETPOSITIONTOEND) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SpaceToEndOfData"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::RewindTape(void)
/*++

Routine Description:

    Rewinds the tape to the beginnning of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::RewindTape"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::RewindTape.SetTapePosition.0");

            // ** WIN32 Tape API Call - rewind the tape
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_REWIND, 0, 0, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::RewindTape.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                CWsbStringPtr tmpString;
                if (tmpString.LoadFromRsc(_Module.m_hInst, IDS_MOVER_REWINDTAPE) != S_OK) {
                    tmpString = L"";
                }
                hr = MapTapeError(hr, tmpString);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        WsbAssert(0 == curPos, E_UNEXPECTED);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::RewindTape"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::IsAccessEnabled(void)
{

    HRESULT hr = S_OK;
    //WsbTraceIn(OLESTR("CNtTapeIo::IsAccessEnabled"), OLESTR(""));

    try {

        if (m_pCartridge) {
            // Check that the cartridge is still enable for access
            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = m_pCartridge;
            try {
                WsbAffirmHrOk(pObject->IsEnabled());
            } WsbCatchAndDo(hr, 
                HRESULT reason = E_ABORT;

                m_ValidLabel = FALSE;

                pObject->GetStatusCode(&reason);
                WsbThrow(reason);
            );
        }
    } WsbCatch(hr);

    //WsbTraceOut(OLESTR("CNtTapeIo::IsAccessEnabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}



HRESULT
CNtTapeIo::Lock( void )
/*++

Implements:

    IRmsDrive::Lock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Lock"), OLESTR(""));

    EnterCriticalSection(&m_CriticalSection);

    WsbTraceOut(OLESTR("CRmsDrive::Lock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::Unlock( void )
/*++

Implements:

    IRmsDrive::Unlock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unlock"), OLESTR(""));

    LeaveCriticalSection(&m_CriticalSection);

    WsbTraceOut(OLESTR("CRmsDrive::Unlock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CNtTapeIo::MapTapeError(
    IN HRESULT hrToMap,
    IN WCHAR *pAction)
/*++

Routine Description:

    Maps a WIN32 tape error, specified as an HRESULT, to a MVR error.

Arguments:

    hrToMap     -  WIN32 tape error to map.

Return Value:

    S_OK                            - Success.
    MVR_E_BEGINNING_OF_MEDIA        - The beginning of the tape or a partition was encountered.
    MVR_E_BUS_RESET                 - The I/O bus was reset.
    MVR_E_END_OF_MEDIA              - The physical end of the tape has been reached.
    MVR_S_FILEMARK_DETECTED         - A tape access reached a filemark.
    MVR_S_SETMARK_DETECTED          - A tape access reached the end of a set of files.
    MVR_S_NO_DATA_DETECTED          - No more data is on the tape.
    MVR_E_PARTITION_FAILURE         - Tape could not be partitioned.
    MVR_E_INVALID_BLOCK_LENGTH      - When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
    MVR_E_DEVICE_NOT_PARTITIONED    - Tape partition information could not be found when loading a tape.
    MVR_E_MEDIA_CHANGED             - The media in the drive may have changed.
    MVR_E_NO_MEDIA_IN_DRIVE         - No media in drive.
    MVR_E_UNABLE_TO_LOCK_MEDIA      - Unable to lock the media eject mechanism.
    MVR_E_UNABLE_TO_UNLOAD_MEDIA    - Unable to unload the media.
    MVR_E_WRITE_PROTECT             - The media is write protected.
    MVR_E_CRC                       - Data error (cyclic redundancy check).
    MVR_E_DEVICE_REQUIRES_CLEANING  - The device has indicated that cleaning is required before further operations are attempted.
    MVR_E_SHARING_VIOLATION         - The process cannot access the file because it is being used by another process.
    MVR_E_ERROR_IO_DEVICE           - The request could not be performed because of an I/O device error.                          - Unknown error.
    MVR_E_ERROR_DEVICE_NOT_CONNECTED - The device is not connected.
    MVR_E_ERROR_NOT_READY           - Device is not ready.
    E_ABORT                         - Unknown error, abort.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::MapTapeError"), OLESTR("<%ls>"), WsbHrAsString(hrToMap));

    try {

        // The valid label flag is knocked down when the media may have changed
        // or device parameters (i.e. block size) may have been reset.
        switch ( hrToMap ) {
        case S_OK:
            break;
        case HRESULT_FROM_WIN32( ERROR_BEGINNING_OF_MEDIA ):
            hr = MVR_E_BEGINNING_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_BUS_RESET ):
            hr = MVR_E_BUS_RESET;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_END_OF_MEDIA ):
            hr = MVR_E_END_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_FILEMARK_DETECTED ):     // Maps to Success
            hr = MVR_S_FILEMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SETMARK_DETECTED ):      // Maps to Success
            hr = MVR_S_SETMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_DATA_DETECTED ):      // Maps to Success
            // EOD
            // This happens on SpaceFilemarks() and SetPosition() past end of data.
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_PARTITION_FAILURE ):
            hr = MVR_E_PARTITION_FAILURE;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_BLOCK_LENGTH ):
            hr = MVR_E_INVALID_BLOCK_LENGTH;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_PARTITIONED ):
            hr = MVR_E_DEVICE_NOT_PARTITIONED;
            break;
        case HRESULT_FROM_WIN32( ERROR_MEDIA_CHANGED ):
            hr = MVR_E_MEDIA_CHANGED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_MEDIA_IN_DRIVE ):
            hr = MVR_E_NO_MEDIA_IN_DRIVE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_LOCK_MEDIA ):
            hr = MVR_E_UNABLE_TO_LOCK_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_UNLOAD_MEDIA ):
            hr = MVR_E_UNABLE_TO_UNLOAD_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_WRITE_PROTECT ):
            hr = MVR_E_WRITE_PROTECT;
            break;
        case HRESULT_FROM_WIN32( ERROR_CRC ): 
            // This is may indicate that the drive needs cleaning.
            //
            // 8505: This code returned for SpaceFilemarks or SpaceEOD operation
            //       for which no EOD marker exist on tape.  This happens when
            //       after power cycling device during writes.
            
            //       Verfied by bmd on 3/25/98 using new, bulk erased, and used tape.
            //       Look for new error ERROR_NOT_FOUND to replace ERROR_CRC when
            //       there's a misssing EOD marker.
            //
            // DLT:  See 8500 notes.
            //
            hr = MVR_E_CRC;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_REQUIRES_CLEANING ):
            // This happens on I/O errors that that driver believes may be fixed
            // by cleaning the drive heads.
            hr = MVR_E_DEVICE_REQUIRES_CLEANING;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ):
            // This happens when the CreateFile fails because the device is in use by some other app.
            hr = MVR_E_SHARING_VIOLATION;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_IO_DEVICE ):
            // This happens when the device is turned off during I/O, for example.
            hr = MVR_E_ERROR_IO_DEVICE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_CONNECTED ):
            // This happens when the device is turned off.
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
            // This happens when the SCSI command does not return within the timeout period.  A system error is logged for the SCSI controler (adapter).
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NOT_READY ):
            // This happens when the device is coming ready (i.e. after a bus reset).
            hr = MVR_E_ERROR_NOT_READY;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NOT_FOUND ):
            // See 8500 notes under ERROR_CRC
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        default:
            WsbThrow(hrToMap);
        }

    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_UNKNOWN_DEVICE_ERROR, 0, NULL, pAction, WsbHrAsString(hr), NULL);
            hr = E_ABORT;
        );


    WsbTraceOut(OLESTR("CNtTapeIo::MapTapeError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\mover\server\nttapeio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtTapeIo.h

Abstract:

    Definition of the CNtTapeIo class

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

#if !defined(NtTapeIo_H)
#define NtTapeIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CNtTapeIo

class CNtTapeIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CNtTapeIo,&CLSID_CNtTapeIo>
{
public:
    CNtTapeIo() {}
BEGIN_COM_MAP(CNtTapeIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNtTapeIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CNtTapeIo)
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// CComObjectRoot
public:
    ULONG InternalAddRef(void);
    ULONG InternalRelease(void);
    STDMETHOD( FinalConstruct )(void);
    STDMETHOD( FinalRelease )(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR unused);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        OUT void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = RMS_DEFAULT_BLOCK_SIZE,  // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hTape;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    TAPE_GET_MEDIA_PARAMETERS m_sMediaParameters;   // We store media and drive parameters 
                                                    //   here when we open up the tape device...
    TAPE_GET_DRIVE_PARAMETERS m_sDriveParameters;   //

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*
    ULARGE_INTEGER          m_StreamPBA;            // The PBA for the current Stream.  Used to tell if read ops are aligned with tape.
    ULARGE_INTEGER          m_StreamOffset;         // The Current offset into the data stream
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream

    BYTE *                  m_pStreamBuf;           // Internal stream buffer used to handle I/O for boundary conditions
    ULONG                   m_StreamBufSize;        // Max size of the internal stream buffer
    ULONG                   m_StreamBufUsed;        // The number of bytes of the internal stream buffer containing valid data
    ULONG                   m_StreamBufPosition;    // The current position of the stream pointer.
    ULARGE_INTEGER          m_StreamBufStartPBA;    // The corresponding starting PBA for the internal stream buffer

    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    CRITICAL_SECTION        m_CriticalSection;      // Object sychronization support
    BOOL                    m_bCritSecCreated;      // Indicates whether all CritSec were created successfully (for cleanup)
    static int              s_InstanceCount;        // Counter of the number of object instances.
    // Tape I/O
    HRESULT OpenTape(void);
    HRESULT CloseTape(void);
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);
    HRESULT WriteFilemarks(IN ULONG count);
    HRESULT GetPosition(OUT UINT64 *pPosition);
    HRESULT SetPosition(IN UINT64 position);
    HRESULT EnsurePosition(IN UINT64 position);
    HRESULT SpaceFilemarks(IN LONG count, OUT UINT64 *pPosition);
    HRESULT SpaceToEndOfData(OUT UINT64 *pPosition);
    HRESULT RewindTape(void);
    HRESULT MapTapeError(IN HRESULT hrToMap, IN WCHAR *pAction);

    HRESULT IsAccessEnabled(void);
    HRESULT Lock(void);
    HRESULT Unlock(void);

};

#endif // !defined(NtTapeIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Rms.rc
//
#define IDS_RMSSERVER_DESC              1
#define IDR_RmsServer                   1
#define IDS_RMSLIBRARY_DESC             2
#define IDR_RmsLibrary                  2
#define IDS_RMSDRIVECLASS_DESC          3
#define IDR_RmsDriveClass               3
#define IDS_RMSCARTRIDGE_DESC           4
#define IDR_RmsCartridge                4
#define IDS_RMSDRIVE_DESC               5
#define IDR_RmsDrive                    5
#define IDS_RMSSTORAGESLOT_DESC         6
#define IDR_RmsStorageSlot              6
#define IDS_RMSMEDIUMCHANGER_DESC       7
#define IDR_RmsMediumChanger            7
#define IDS_RMSIEPORT_DESC              8
#define IDR_RmsIEPort                   8
#define IDS_RMSMEDIASET_DESC            9
#define IDR_RmsMediaSet                 9
#define IDS_RMSREQUEST_DESC             10
#define IDR_RmsRequest                  10
#define IDS_RMSPARTITION_DESC           11
#define IDR_RmsPartition                11
#define IDS_RMSCLIENT_DESC              12
#define IDR_RmsClient                   12
#define IDS_RMSNTMS_DESC                13
#define IDR_RmsNTMS                     13
#define IDS_PRODUCT_NAME                102
#define IDS_RMS_ELEMENT_UNKNOWN         200
#define IDS_RMS_ELEMENT_STAGE           201
#define IDS_RMS_ELEMENT_LIBRARY         202
#define IDS_RMS_ELEMENT_SHELF           203
#define IDS_RMS_ELEMENT_OFFSITE         204
#define IDS_RMS_ELEMENT_DRIVE           205
#define IDS_RMS_ELEMENT_CHANGER         206
#define IDS_RMS_ELEMENT_IEPORT          207
#define IDS_RMS_CHANGER_UNKNOWN         300
#define IDS_RMS_CHANGER_AUTOMATIC       301
#define IDS_RMS_CHANGER_MANUAL          302
#define IDS_RMS_PORT_UNKNOWN            400
#define IDS_RMS_PORT_IMPORT             401
#define IDS_RMS_PORT_EXPORT             402
#define IDS_RMS_PORT_IMPORT_EXPORT      403
#define IDS_RMS_SLOT_SELECT_UNKNOWN     500
#define IDS_RMS_SLOT_SELECT_MINMOUNT    501
#define IDS_RMS_SLOT_SELECT_GROUP       502
#define IDS_RMS_SLOT_SELECT_SORTNAME    503
#define IDS_RMS_SLOT_SELECT_SORTBARCODE 504
#define IDS_RMS_SLOT_SELECT_LABEL       505
#define IDS_RMS_CARTRIDGE_STATUS_UNKNOWN 600
#define IDS_RMS_CARTRIDGE_STATUS_PRIVATE 601
#define IDS_RMS_CARTRIDGE_STATUS_SCRATCH 602
#define IDS_RMS_CARTRIDGE_STATUS_CLEANING 603
#define IDS_RMS_ATTRIBUTE_UNKNOWN       700
#define IDS_RMS_ATTRIBUTE_WRITE         701
#define IDS_RMS_ATTRIBUTE_READ          702
#define IDS_RMS_ATTRIBUTE_FULL          704
#define IDS_RMS_ATTRIBUTE_EMPTY         705
#define IDS_RMS_ATTRIBUTE_INUSE         706
#define IDS_RMS_ATTRIBUTE_BAD           707
#define IDS_RMS_DRIVE_SELECT_UNKNOWN    800
#define IDS_RMS_DRIVE_SELECT_RANDOM     801
#define IDS_RMS_DRIVE_SELECT_LRU        802
#define IDS_RMS_DRIVE_SELECT_ROUND_ROBIN 803
#define IDS_RMS_OBJECT_STATE_UNKNOWN    900
#define IDS_RMS_OBJECT_STATE_ENABLED    901
#define IDS_RMS_OBJECT_STATE_DISABLED   902
#define IDS_RMS_OBJECT_STATE_ERROR      903
#define IDS_RMS_MEDIA_UNKNOWN           1000
#define IDS_RMS_MEDIA_8MM               1001
#define IDS_RMS_MEDIA_4MM               1002
#define IDS_RMS_MEDIA_DLT               1003
#define IDS_RMS_MEDIA_OPTICAL_525       1004
#define IDS_RMS_MEDIA_OPTICAL_35        1005
#define IDS_RMS_MEDIA_WORM_525          1006
#define IDS_RMS_MEDIA_CDR               1007
#define IDS_RMS_MEDIA_CDROM             1008
#define IDS_RMS_MEDIA_DVD               1009
#define IDS_RMS_MEDIA_ZIP_100           1010
#define IDS_RMS_MEDIA_JAZ               1011
#define IDS_RMS_MEDIA_FIXED_DISK        1012
#define IDS_RMS_DEVICE_UNKNOWN          1100
#define IDS_RMS_DEVICE_FIXED            1101
#define IDS_RMS_DEVICE_REMOVABE         1102
#define IDS_RMS_DEVICE_TAPE             1103
#define IDS_RMS_DEVICE_CDROM            1104
#define IDS_RMS_DEVICE_WORM             1105
#define IDS_RMS_DEVICE__OPTICAL         1106
#define IDS_RMS_DEVICE_CHANGER          1107
#define IDS_RMS_MODE_UNKNOWN            1200
#define IDS_RMS_MODE_READ               1201
#define IDS_RMS_MODE_READ_WRITE         1202
#define IDS_RMS_MODE_WRITE              1203
#define IDS_RMS_MEDIA_SET_UNKNOWN       1300
#define IDS_RMS_MEDIA_SET_FOLDER        1301
#define IDS_RMS_MEDIA_SET_LIBRARY       1302
#define IDS_RMS_MEDIA_SET_SHELF         1303
#define IDS_RMS_MEDIA_SET_OFFSITE       1304
#define IDS_RMS_MEDIA_SET_NTMS          1305
#define IDS_RMS_DEFAULT_FIXED_DRIVE_LIBRARY_NAME 2000
#define IDS_RMS_DEFAULT_FIXED_DRIVE_MEDIA_SET_NAME 2001
#define IDS_RMS_DEFAULT_OPTICAL_LIBRARY_NAME 2002
#define IDS_RMS_DEFAULT_OPTICAL_MEDIA_SET_NAME 2003
#define IDS_RMS_DEFAULT_TAPE_LIBRARY_NAME 2004
#define IDS_RMS_DEFAULT_TAPE_MEDIA_SET_NAME 2005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        14
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rms.cpp ===
/*++

 

Module Name:

    Rms.cpp

Abstract:

    DLL main for Rms

Author:

    Ran Kalach          [rankala]         14-June-1999

Revision History:

--*/

// Rms.cpp : Implementation of DLL Exports.

// Note: Currently, Rms proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for rmsint.idl by adding the following 
//      files to the Outputs.
//          rmsint_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f rmsps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "RmsServr.h"
#include "RmsLibry.h"
#include "RmsDrCls.h"
#include "RmsCartg.h"
#include "RmsDrive.h"
#include "RmsSSlot.h"
#include "RmsChngr.h"
#include "RmsIPort.h"
#include "RmsMdSet.h"
#include "RmsReqst.h"
#include "RmsPartn.h"
#include "RmsClien.h"
#include "RmsNTMS.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CRmsServer, CRmsServer)
    OBJECT_ENTRY(CLSID_CRmsLibrary, CRmsLibrary)
    OBJECT_ENTRY(CLSID_CRmsDriveClass, CRmsDriveClass)
    OBJECT_ENTRY(CLSID_CRmsCartridge, CRmsCartridge)
    OBJECT_ENTRY(CLSID_CRmsDrive, CRmsDrive)
    OBJECT_ENTRY(CLSID_CRmsStorageSlot, CRmsStorageSlot)
    OBJECT_ENTRY(CLSID_CRmsMediumChanger, CRmsMediumChanger)
    OBJECT_ENTRY(CLSID_CRmsIEPort, CRmsIEPort)
    OBJECT_ENTRY(CLSID_CRmsMediaSet, CRmsMediaSet)
    OBJECT_ENTRY(CLSID_CRmsRequest, CRmsRequest)
    OBJECT_ENTRY(CLSID_CRmsPartition, CRmsPartition)
    OBJECT_ENTRY(CLSID_CRmsClient, CRmsClient)
    OBJECT_ENTRY(CLSID_CRmsNTMS, CRmsNTMS)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    CoInitialize( 0 );
    HRESULT hr = _Module.RegisterServer( FALSE );
    CoUninitialize( );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    CoInitialize( 0 );
    _Module.UnregisterServer();
    CoUninitialize( );
    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmscelmt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCElmt.cpp

Abstract:

    Implementation of CRmsChangerElement

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsCElmt.h"
#include "RmsServr.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRmsChangerElement methods
//


CRmsChangerElement::CRmsChangerElement(
    void
    )
/*++

Routine Description:

    CRmsChangerElement constructor

Arguments:

    None

Return Value:

    None

--*/
{
    m_elementNo = 0;

    m_location.SetLocation(RmsElementUnknown, GUID_NULL, GUID_NULL,
                           0, 0, 0, 0, FALSE);

    m_mediaSupported = RmsMediaUnknown;

    m_isStorage = FALSE;

    m_isOccupied = FALSE;

    m_pCartridge = NULL;

    m_ownerClassId = CLSID_NULL;

    m_getCounter = 0;

    m_putCounter = 0;

    m_resetCounterTimestamp = 0;

    m_lastGetTimestamp = 0;

    m_lastPutTimestamp = 0;

    m_x1 = 0;

    m_x2 = 0;

    m_x3 = 0;
}


HRESULT
CRmsChangerElement::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsChangerElement::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsChangerElement::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pCollectable;
        WsbAssertPointer( pElmt );

        switch ( m_findBy ) {

        case RmsFindByElementNumber:
            {

                LONG elementNo;

                WsbAffirmHr( pElmt->GetElementNo( &elementNo ) );

                if( m_elementNo == elementNo ) {

                    // Element numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr( pElmt->GetMediaSupported( (LONG*) &mediaSupported ) );

                if( m_mediaSupported == mediaSupported ) {

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        default:

            // What default makes sense?
            WsbAssertHr( E_UNEXPECTED );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ) {
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsChangerElement::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsChangerElement::GetSizeMax(
    OUT ULARGE_INTEGER* /*pcbSize*/
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT         hr = E_NOTIMPL;

//    ULARGE_INTEGER  cartridgeLen;
//    ULARGE_INTEGER  locationLen;


//    WsbTraceIn(OLESTR("CRmsChangerElement::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // We need the IRmsCartridge interface to get the value of the object.
//        CComQIPtr<IPersistStream, &IID_IPersistStream> pPersistCartridge = m_pCartridge;
//        WsbAssertPointer( pPersistCartridge );

//        pPersistCartridge->GetSizeMax(&cartridgeLen);

//        m_location.GetSizeMax(&locationLen);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // m_elementNo
//                             locationLen.QuadPart    +      // m_location
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSupported
//                             WsbPersistSizeOf(BOOL)  +      // m_isStorage
//                             WsbPersistSizeOf(BOOL)  +      // m_isOccupied
//                             cartridgeLen.QuadPart   +      // m_pCartridge
//                             WsbPersistSizeOf(CLSID) +      // m_ownerClassId
//                             WsbPersistSizeOf(LONG)  +      // m_getCounter
//                             WsbPersistSizeOf(LONG)  +      // m_putCounter
//                             sizeof(DATE)            +      // m_resetCounterTimestamp
//                             sizeof(DATE)            +      // m_lastGetTimestamp
//                             sizeof(DATE)            +      // m_lastPutTimestamp
//                             WsbPersistSizeOf(LONG)  +      // m_x1
//                             WsbPersistSizeOf(LONG)  +      // m_x2
//                             WsbPersistSizeOf(LONG);        // m_x3

//    } WsbCatch(hr);

//    WsbTraceOut(OLESTR("CRmsChangerElement::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsChangerElement::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsChangerElement::Load"), OLESTR(""));

    try {
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        ULONG     temp;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertPointer(pServer);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_elementNo));

        WsbAffirmHr(m_location.Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_mediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isStorage));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isOccupied));

        GUID cartId;
        WsbAffirmHr(WsbLoadFromStream(pStream, &cartId));
        if (0 != memcmp(&GUID_NULL, &cartId, sizeof(GUID))) {
            hr = pServer->FindCartridgeById(cartId, &m_pCartridge);
            if (S_OK == hr) {
                CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = (IRmsChangerElement*)this;

                if (pDrive) {
                      WsbAffirmHr(m_pCartridge->SetDrive(pDrive));
                }
            } else if (RMS_E_NOT_FOUND == hr) {
                // TODO ???
            } else {
                WsbThrow(hr);
            }
        }

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_getCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_putCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x1));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x2));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x3));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsChangerElement::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsChangerElement::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_elementNo));

        WsbAffirmHr(m_location.Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_mediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isStorage));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isOccupied));

        //  Save the ID (GUID) for the cartridge
        GUID cartId;
        if (!m_pCartridge) {
            cartId = GUID_NULL;
        } else {
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&cartId));
        }
        WsbAffirmHr(WsbSaveToStream(pStream, cartId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_getCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_putCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x1));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x2));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x3));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsChangerElement::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsLibrary>    pLibrary1;
    CComPtr<IRmsLibrary>    pLibrary2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longVal1 = 11111111;
    LONG                    longWork1;

    LONG                    longVal2 = 22222222;
    LONG                    longWork2;

    LONG                    longVal3 = 33333333;
    LONG                    longWork3;

//  DATE                    dateVal1;
//  DATE                    dateWork1;

    CLSID                   clsidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    CLSID                   clsidWork1;

    //  CRmsLocator Fields
    LONG                    locVal1 = 11111111;
    GUID                    locVal2 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    locVal3 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
    LONG                    locVal4 = 44444444;
    LONG                    locVal5 = 55555555;
    LONG                    locVal6 = 66666666;
    LONG                    locVal7 = 77777777;
    BOOL                    locVal8 = TRUE;

    LONG                    locWork1;
    GUID                    locWork2;
    GUID                    locWork3;
    LONG                    locWork4;
    LONG                    locWork5;
    LONG                    locWork6;
    LONG                    locWork7;
    BOOL                    locWork8;


    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsChangerElement::Test"), OLESTR(""));

    try {
        // Get the Library interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsLibrary*) this)->QueryInterface(IID_IRmsLibrary, (void**) &pLibrary1));

            // Test GetElementNo
            m_elementNo = longVal1;

            GetElementNo(&longWork1);

            if(longVal1 == longWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetLocation & GetLocation
            SetLocation( locVal1, locVal2, locVal3, locVal4,
                         locVal5, locVal6, locVal7, locVal8);

            GetLocation( &locWork1, &locWork2, &locWork3, &locWork4,
                         &locWork5, &locWork6, &locWork7, &locWork8);

            if((locVal1 == locWork1) &&
               (locVal2 == locWork2) &&
               (locVal3 == locWork3) &&
               (locVal4 == locWork4) &&
               (locVal5 == locWork5) &&
               (locVal6 == locWork6) &&
               (locVal7 == locWork7) &&
               (locVal8 == locWork8)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = 0; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetIsStorage & IsStorage to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsStorage (TRUE));
                WsbAffirmHr(IsStorage ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsStorage & IsStorage to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsStorage (FALSE));
                WsbAffirmHr(IsStorage ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetIsOccupied & IsOccupied to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsOccupied (TRUE));
                WsbAffirmHr(IsOccupied ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsOccupied & IsOccupied to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsOccupied (FALSE));
                WsbAffirmHr(IsOccupied ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetCartridge & GetCartridge

            // Test SetOwnerClassId & GetOwnerClassId
            SetOwnerClassId(clsidVal1);

            GetOwnerClassId(&clsidWork1);

            if(clsidVal1 == clsidWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetAccessCounters & GetAccessCounters & ResetAccessCounters
            m_getCounter = longVal1;

            m_putCounter = longVal2;

            GetAccessCounters(&longWork1, &longWork2);

            if((longVal1 == longWork1) &&
               (longVal2 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            ResetAccessCounters();

            GetAccessCounters(&longWork1, &longWork2);

            if((0 == longWork1) &&
               (0 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test GetResetCounterTimestamp

            // Test GetLastGetTimestamp

            // Test GetLastPutTimestamp

            // Test SetCoordinates & GetCoordinates
            SetCoordinates(longVal1, longVal2, longVal3);

            GetCoordinates(&longWork1, &longWork2, &longWork3);

            if((longVal1 == longWork1) &&
               (longVal2 == longWork2) &&
               (longVal3 == longWork3)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);


        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


CRmsChangerElement::~CRmsChangerElement(
    void
    )
/*++

Routine Description:

    This is the destructor for the changer element class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    m_pCartridge = NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// IRmsChangerElement implementation
//



STDMETHODIMP
CRmsChangerElement::GetElementNo(
    LONG   *pElementNo
    )
/*++

Implements:

    IRmsChangerElement::GetElementNo

--*/
{
    *pElementNo = m_elementNo;
    return S_OK;
}



STDMETHODIMP
CRmsChangerElement::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Implements:

    IRmsChangerElement::GetLocation

--*/
{
    return m_location.GetLocation(pType, pLibId, pMediaSetId, pPos, pAlt1, pAlt2, pAlt3, pInvert);;
}

STDMETHODIMP
CRmsChangerElement::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert)
/*++

Implements:

    IRmsChangerElement::SetLocation

--*/
{
    m_location.SetLocation( type, libId, mediaSetId, pos,
                            alt1, alt2, alt3, invert );

    // TODO: clean this up: pos, or m_elementNo, not both.
    m_elementNo = pos;

//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetMediaSupported(
    LONG    *pType
    )
/*++

Implements:

    IRmsChangerElement::GetMediaSupported

--*/
{
    *pType = m_mediaSupported;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetMediaSupported(
    LONG    type
    )
/*++

Implements:

    IRmsChangerElement::SetMediaSupported

--*/
{
    m_mediaSupported = (RmsMedia) type;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetIsStorage(
    BOOL    flag
    )
/*++

Implements:

    IRmsChangerElement::SetIsStorage

--*/
{
    m_isStorage = flag;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::IsStorage(
    void
    )
/*++

Implements:

    IRmsChangerElement::IsStorage

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isStorage){
        hr = S_OK;
        }

    return (hr);
}

STDMETHODIMP
CRmsChangerElement::SetIsOccupied(
    BOOL    flag
    )
/*++

Implements:

    IRmsChangerElement::SetIsOccupied

--*/
{
    m_isOccupied = flag;

    if ( FALSE == m_isOccupied ) {

        m_pCartridge = 0;

    }


//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::IsOccupied(
    void
    )
/*++

Implements:

    IRmsChangerElement::IsOccupied

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isOccupied){
    hr = S_OK;
    }

    return (hr);
}

STDMETHODIMP
CRmsChangerElement::GetCartridge(
    IRmsCartridge **ptr)
/*++

Implements:

    IRmsChangerElement::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pCartridge;
        m_pCartridge->AddRef();

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsChangerElement::SetCartridge(
    IRmsCartridge *ptr)
/*++

Implements:

    IRmsChangerElement::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        m_pCartridge = ptr;
        m_isOccupied = TRUE;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsChangerElement::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsChangerElement::GetOwnerClassId

--*/
{
    *pClassId = m_ownerClassId;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsChangerElement::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetAccessCounters(
    LONG    *pGets,
    LONG    *pPuts
    )
/*++

Implements:

    IRmsChangerElement::GetAccessCounters

--*/
{
    *pGets = m_getCounter;
    *pPuts = m_putCounter;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::ResetAccessCounters(
    void
    )
/*++

Implements:

    IRmsChangerElement::ResetAccessCounters

--*/
{
    m_getCounter = 0;
    m_putCounter = 0;
//  m_resetCounterTimestamp = COleDatetime::GetCurrentTime();
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetResetCounterTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetResetCounterTimestamp

--*/
{
    *pDate = m_resetCounterTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetLastGetTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetLastGetTimestamp

--*/
{
    *pDate = m_lastGetTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetLastPutTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetLastPutTimestamp

--*/
{
    *pDate = m_lastPutTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetCoordinates(
    LONG    *pX1,
    LONG    *pX2,
    LONG    *pX3
    )
/*++

Implements:

    IRmsChangerElement::GetCoordinates

--*/
{
    *pX1 = m_x1;
    *pX2 = m_x2;
    *pX3 = m_x3;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetCoordinates(
    LONG  x1,
    LONG  x2,
    LONG  x3
    )
/*++

Implements:

    IRmsChangerElement::SetCoordinates

--*/
{
    m_x1 = x1;
    m_x2 = x2;
    m_x3 = x3;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmscartg.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCartg.cpp

Abstract:

    Implementation of CRmsCartridge

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
#include "RmsCartg.h"
#include "RmsNTMS.h"
#include "RmsServr.h"

int CRmsCartridge::s_InstanceCount = 0;

#define RMS_USE_ACTIVE_COLLECTION 1
////////////////////////////////////////////////////////////////////////////////
//
// Base class implementations
//


STDMETHODIMP
CRmsCartridge::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsCartridge::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsCartridge interface to get the value of the object.
        CComQIPtr<IRmsCartridge, &IID_IRmsCartridge> pCartridge = pCollectable;
        WsbAssertPointer( pCartridge );

        // Get find by option
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                // Get name
                WsbAffirmHr( pCartridge->GetName( &name ) );

                // Compare the names
                result = (USHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByExternalLabel:
            {

                CWsbBstrPtr externalLabel;
                LONG        externalNumber;

                // Get external label
                WsbAffirmHr( pCartridge->GetTagAndNumber(&externalLabel, &externalNumber) );

                // Compare the label
                result = (SHORT)wcscmp( m_externalLabel, externalLabel );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByExternalNumber:
            {

                CWsbBstrPtr externalLabel;
                LONG        externalNumber;

                // Get external number
                WsbAffirmHr( pCartridge->GetTagAndNumber(&externalLabel, &externalNumber) );

                if( m_externalNumber == externalNumber ) {

                    // External numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByScratchMediaCriteria:
            {

                RmsStatus status;
                GUID mediaSetIdToFind, mediaSetId;

                WsbAssertHr(pCartridge->GetStatus((LONG *)&status));
                WsbAssertHr(pCartridge->GetMediaSetId(&mediaSetId));
                WsbAssertHr(GetMediaSetId(&mediaSetIdToFind));

                if ( (RmsStatusScratch == status) && (mediaSetIdToFind == mediaSetId)) {

                    // Status is scratch
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByCartridgeId:
        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ) {
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsCartridge::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}



HRESULT
CRmsCartridge::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::FinalConstruct"), OLESTR("this = %p"),
            static_cast<void *>(this));

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize fields
        m_Name = OLESTR("");
        m_Description = OLESTR("");
        m_externalLabel = OLESTR("");
        m_externalNumber = 0;
        m_sizeofOnMediaId = 0;
        m_typeofOnMediaId = 0;
        m_pOnMediaId = 0;
        m_onMediaLabel = RMS_UNDEFINED_STRING;
        m_status = RmsStatusUnknown;
        m_type   = RmsMediaUnknown;
        m_BlockSize = 0;
        m_isTwoSided = 0;
        m_isMounted = 0;
        m_isInTransit = 0;
        m_isAvailable = 0;
        m_isMountedSerialized = 0;
        m_home.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_location.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_destination.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_mailStop = RMS_UNDEFINED_STRING;
        m_pDrive = 0;
        m_sizeofInfo = 0;
        for (int i = 0; i < RMS_STR_MAX_CARTRIDGE_INFO; i++){
            m_info[i] = 0;
        }

        m_ownerClassId = GUID_NULL;
        m_pParts = 0;
        m_verifierClass = GUID_NULL;
        m_portalClass = GUID_NULL;

        m_pDataCache = NULL;
        m_DataCacheSize = 0;
        m_DataCacheUsed = 0;
        m_DataCacheStartPBA.QuadPart = 0;

        m_ManagedBy = RmsMediaManagerUnknown;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CRmsCartridge::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsCartridge::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsCartridge::FinalRelease(void) 
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::FinalRelease"), OLESTR("this = %p"),
            static_cast<void *>(this));

    try {
        
        if (m_pOnMediaId) {
            WsbFree(m_pOnMediaId);
            m_pOnMediaId = NULL;
            m_sizeofOnMediaId = 0;
            m_typeofOnMediaId = 0;
        }

        if (m_pDataCache) {
            WsbFree(m_pDataCache);
            m_pDataCache = NULL;
            m_DataCacheSize = 0;
            m_DataCacheUsed = 0;
            m_DataCacheStartPBA.QuadPart = 0;
        }

        CWsbObject::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CRmsCartridge::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsCartridge::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


STDMETHODIMP
CRmsCartridge::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::GetClassID"), OLESTR(""));

    try {

        WsbAssertPointer(pClsid);

        *pClsid = CLSID_CRmsCartridge;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;
//    ULONG       externalLabelLen;
//    ULONG       mailStopLen;

//    WsbTraceIn(OLESTR("CRmsCartridge::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);
//        externalLabelLen = SysStringByteLen(m_externalLabel);
//        mailStopLen = SysStringByteLen(m_mailStop);

//        // set up size of CRmsCartridge
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID)        +  // m_cartridgeId
//                             WsbPersistSizeOf(ULONG)       +  // length of m_name
//                             nameLen                       +  // m_name
//                             WsbPersistSizeOf(ULONG)       +  // length of m_externalLabel
//                             externalLabelLen              +  // m_externalLabel
//                             WsbPersistSizeOf(LONG)        +  // m_externalNumber
//                             WsbPersistSizeOf(LONG)        +  // m_status
//                             WsbPersistSizeOf(LONG)        +  // m_type
//                             WsbPersistSizeOf(BOOL)        +  // m_isTwoSided
//                             WsbPersistSizeOf(CRmsLocator) +  // m_home
//                             WsbPersistSizeOf(CRmsLocator) +  // m_location
//                             WsbPersistSizeOf(ULONG)       +  // size of m_mailStop
//                             mailStopLen                   +  // m_mailStop
//                             WsbPersistSizeOf(SHORT)       +  // m_sizeofInfo
//                             RMS_STR_MAX_CARTRIDGE_INFO    +  // m_Info
//                             WsbPersistSizeOf(CLSID)       +  // m_ownerClassId
//                                                              // m_pParts
////                           WsbPersistSizeOf(CComPtr<IWsbIndexedCollection>) +
//                             WsbPersistSizeOf(CLSID)       +  // m_verifierClass
//                             WsbPersistSizeOf(CLSID);         // m_portalClass


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        m_externalLabel.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_externalLabel));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_externalNumber));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_status = (RmsStatus)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BlockSize));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isTwoSided));

        WsbAffirmHr(m_home.Load(pStream));

        WsbAffirmHr(m_location.Load(pStream));

        m_mailStop.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_mailStop));

//      WsbAffirmHr(m_pParts->Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_info[0], MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_verifierClass));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_portalClass));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;



    WsbTraceIn(OLESTR("CRmsCartridge::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbBstrToStream(pStream, m_externalLabel));

        WsbAffirmHr(WsbSaveToStream(pStream, m_externalNumber));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_status));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, m_BlockSize));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isTwoSided));

        WsbAffirmHr(m_home.Save(pStream, clearDirty));

        WsbAffirmHr(m_location.Save(pStream, clearDirty));

        WsbAffirmHr(WsbBstrToStream(pStream, m_mailStop));

//      WsbAffirmHr(m_pParts->Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &m_info [0], MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_verifierClass));

        WsbAffirmHr(WsbSaveToStream(pStream, m_portalClass));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsCartridge::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsCartridge>  pCartridge1;
    CComPtr<IRmsCartridge>  pCartridge2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    passFail;
    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longVal1 = 0x11111111;
    LONG                    longVal2 = 0x22222222;
    LONG                    longVal3 = 0x33333333;
    LONG                    longVal4 = 0x44444444;

    LONG                    longWork0;
    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    guidVal2 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};

    GUID                    guidWork1;
    GUID                    guidWork2;

    BOOL                    boolTrue  = TRUE;
    BOOL                    boolFalse = FALSE;

    BOOL                    boolWork1;


    WsbTraceIn(OLESTR("CRmsCartridge::Test"), OLESTR(""));

    try {
        // Get the Cartridge interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsCartridge*) this)->QueryInterface(IID_IRmsCartridge, (void**) &pCartridge1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetTagAndNumber & GetTagAndNumber
            bstrWork1 = bstrVal2;

            longWork1 = 99;

            SetTagAndNumber(bstrWork1, longWork1);

            GetTagAndNumber(&bstrWork2, &longWork2);

            if ((bstrWork1 == bstrWork2)  && (longWork1 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsTwoSided & IsTwoSided to True
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsTwoSided (TRUE));
                WsbAffirmHr(IsTwoSided ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetTwoSided & IsTwoSided to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsTwoSided (FALSE));
                WsbAffirmHr(IsTwoSided ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetStatus & GetStatus
            for (i = RmsStatusUnknown; i < RmsStatusCleaning; i++){

                longWork1 = i;

                SetStatus (longWork1);

                GetStatus (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetType & GetType
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetType (longWork1);

                GetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetHome & GetHome
            SetHome (RmsMediaOptical, guidVal1, guidVal2, longVal1, longVal2,
                     longVal3, longVal4, boolTrue);

            GetHome (&longWork0, &guidWork1, &guidWork2, &longWork1, &longWork2,
                     &longWork3, &longWork4, &boolWork1);

            passFail = 0;

            if (longWork0 == RmsMediaOptical){
                passFail++;
            }

            if (guidWork1 == guidVal1){
                passFail++;
            }

            if (guidWork2 == guidVal2){
                passFail++;
            }

            if (longWork1 == longVal1){
                passFail++;
            }

            if (longWork2 == longVal2){
                passFail++;
            }

            if (longWork3 == longVal3){
                passFail++;
            }

            if (longWork4 == longVal4){
                passFail++;
            }

            if (boolWork1 == TRUE){
                passFail++;
            }

            if (passFail == 8){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetLocation & GetLocation
            SetLocation (RmsMediaOptical, guidVal1, guidVal2, longVal1, longVal2,
                         longVal3, longVal4, boolTrue);

            GetLocation (&longWork0, &guidWork1, &guidWork2, &longWork1, &longWork2,
                         &longWork3, &longWork4, &boolWork1);

            passFail = 0;

            if (longWork0 == RmsMediaOptical){
                passFail++;
            }

            if (guidWork1 == guidVal1){
                passFail++;
            }

            if (guidWork2 == guidVal2){
                passFail++;
            }

            if (longWork1 == longVal1){
                passFail++;
            }

            if (longWork2 == longVal2){
                passFail++;
            }

            if (longWork3 == longVal3){
                passFail++;
            }

            if (longWork4 == longVal4){
                passFail++;
            }

            if (boolWork1 == TRUE){
                passFail++;
            }

            if (passFail == 8){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMailStop & GetMailStop interface
            SetName(bstrVal1);

            GetName(&bstrWork1);

            if ((bstrWork1 = bstrVal1) == 0){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
////////////////////////////////////////////////////////////////////////////////
//
// IRmsCartridge implementation
//


STDMETHODIMP
CRmsCartridge::GetCartridgeId(
    GUID   *pCartId
    )
/*++

Implements:

    IRmsCartridge::GetCartridgeId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pCartId );

        *pCartId = m_objectId;

        hr = S_OK;
    }
    WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetCartridgeId(
    GUID   cartId
    )
/*++

Implements:

    IRmsCartridge::SetMediaSetId

--*/
{
    m_objectId = cartId;
    m_isDirty = TRUE;

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetMediaSetId(
    GUID   *pMediaSetId
    )
/*++

Implements:

    IRmsCartridge::GetMediaSetId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pMediaSetId );

        *pMediaSetId = m_location.m_mediaSetId;

        hr = S_OK;
    }
    WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetMediaSetId(
    GUID   mediaSetId
    )
/*++

Implements:

    IRmsCartridge::SetMediaSetId

--*/
{
    m_location.m_mediaSetId = mediaSetId;
    m_isDirty = TRUE;

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetName(
    BSTR  *pName
    )
/*++

Implements:

    IRmsCartridge::GetName

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr( m_Name.CopyToBstr(pName) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetName(
    BSTR    name
    )
/*++

Implements:

    IRmsCartridge::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetDescription(
    BSTR  *pDescription
    )
/*++

Implements:

    IRmsCartridge::GetDescription

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pDescription);

        WsbAffirmHr( m_Description.CopyToBstr(pDescription) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetDescription(
    BSTR    description
    )
/*++

Implements:

    IRmsCartridge::SetDescription

--*/
{
    m_Description = description;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsCartridge::GetTagAndNumber(
    BSTR  *pTag,
    LONG  *pNumber
    )
/*++

Implements:

    IRmsCartridge::GetTagAndNumber

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pTag);
        WsbAssertPointer(pNumber);

        WsbAffirmHr( m_externalLabel.CopyToBstr(pTag) );
        *pNumber = m_externalNumber;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetTagAndNumber(
    BSTR    tag,
    LONG    number
    )
/*++

Implements:

    IRmsCartridge::SetTagAndNumber

--*/
{
    m_externalLabel = tag;
    m_externalNumber = number;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsCartridge::GetBarcode(
    BSTR  *pBarcode
    )
/*++

Implements:

    IRmsCartridge::GetBarcode

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pBarcode);

        WsbAffirm(wcslen((WCHAR*)m_externalLabel) > 0, E_FAIL);
        WsbAffirmHr(m_externalLabel.CopyToBstr(pBarcode));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOnMediaIdentifier(
    BYTE *pIdentifier,
    LONG *pSize,
    LONG *pType
    )
/*++

Implements:

    IRmsCartridge::GetOnMediaIdentifier

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pIdentifier );
        WsbAssertPointer( pSize );
        WsbAssertPointer( pType );

        memmove (pIdentifier, m_pOnMediaId, m_sizeofOnMediaId);
        *pSize = m_sizeofOnMediaId;
        *pType = m_typeofOnMediaId;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetOnMediaIdentifier(
    BYTE *pIdentifier,
    LONG size,
    LONG type
    )
/*++

Implements:

    IRmsCartridge::SetOnMediaIdentifier

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pIdentifier );

        CComPtr<IRmsNTMS> pNtms;

        if ( m_pOnMediaId ) {
            WsbFree( m_pOnMediaId );
            m_pOnMediaId = 0;
        }
        m_pOnMediaId = (BYTE *)WsbAlloc( size );
        WsbAffirmPointer(m_pOnMediaId);
        memset(m_pOnMediaId, 0, size);

        memmove (m_pOnMediaId, pIdentifier, size);
        m_sizeofOnMediaId = size;
        m_typeofOnMediaId = type;
        m_isDirty = TRUE;

        if (RmsMediaManagerNTMS == m_ManagedBy) {
            // Now update any external database
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            WsbAffirmHr( pServer->GetNTMS( &pNtms ) );
            WsbAffirmHr( pNtms->UpdateOmidInfo( m_objectId, pIdentifier, size, type ) );
        }

        hr = S_OK;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOnMediaLabel(
    BSTR *pLabel
    )
/*++

Implements:

    IRmsCartridge::GetOnMediaLabel

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pLabel);

        WsbAffirmHr( m_onMediaLabel.CopyToBstr(pLabel) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetOnMediaLabel(
    BSTR label
    )
/*++

Implements:

    IRmsCartridge::SetOnMediaLabel

--*/
{
    m_onMediaLabel = label;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP CRmsCartridge::GetStatus(
    LONG *pStatus
    )
/*++

Implements:

    IRmsCartridge::GetStatus

--*/
{
    *pStatus = m_status;
    return S_OK;
}

STDMETHODIMP CRmsCartridge::SetStatus(
    LONG status
    )
/*++

Implements:

    IRmsCartridge::SetStatus

--*/
{
    m_status = (RmsStatus)status;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetType(
    LONG  *pType
    )
/*++

Implements:

    IRmsCartridge::GetType

--*/
{
    *pType = (LONG) m_type;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::SetType(
    LONG  type
    )
/*++

Implements:

    IRmsCartridge::SetType

--*/
{
    m_type = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsCartridge::GetBlockSize(
    LONG  *pBlockSize
    )
/*++

Implements:

    IRmsCartridge::GetBlockSize

--*/
{
    HRESULT hr = S_OK;

    try {

        if (!m_BlockSize) {
            if (RmsMediaManagerNTMS == m_ManagedBy) {
                LONG blockSize;
                CComPtr<IRmsNTMS> pNtms;
                CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                if (S_OK == pNtms->GetBlockSize(m_objectId, &blockSize)) {
                    m_BlockSize = blockSize;
                }
            }
        }

        *pBlockSize = m_BlockSize;

    } WsbCatch(hr);


    return hr;
}


STDMETHODIMP
CRmsCartridge::SetBlockSize(
    LONG  blockSize
    )
/*++

Implements:

    IRmsCartridge::SetBlockSize

--*/
{
    HRESULT hr = S_OK;

    try {

        if (RmsMediaManagerNTMS == m_ManagedBy) {
            // Update external database
            CComPtr<IRmsNTMS> pNtms;
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            WsbAffirmHr(pServer->GetNTMS(&pNtms));
            WsbAffirmHr(pNtms->SetBlockSize(m_objectId, blockSize));
        }

        m_BlockSize = blockSize;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetIsTwoSided(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetTwoSided

--*/
{
    m_isTwoSided = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::IsTwoSided(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsTwoSided

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isTwoSided ? S_OK : S_FALSE;

    return (hr);
}

STDMETHODIMP
CRmsCartridge::SetIsMounted(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetMounted

--*/
{
    m_isMounted = flag;

    if ( FALSE == m_isMounted ) {

        m_pDrive = 0;

    }

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::IsMounted(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsMounted

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isMounted ? S_OK : S_FALSE;

    return (hr);
}


STDMETHODIMP CRmsCartridge::GetHome(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert
    )
/*++

Implements:

    IRmsCartridge::GetHome

--*/
{
    return m_home.GetLocation(pType,
                              pLibId,
                              pMediaSetId,
                              pPos,
                              pAlt1,
                              pAlt2,
                              pAlt3,
                              pInvert);

}


STDMETHODIMP CRmsCartridge::SetHome(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert
    )
/*++

Implements:

    IRmsCartridge::SetHome

--*/
{
    return m_home.SetLocation(type,
                              libId,
                              mediaSetId,
                              pos,
                              alt1,
                              alt2,
                              alt3,
                              invert);

}


STDMETHODIMP
CRmsCartridge::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Implements:

    IRmsCartridge::GetLocation

--*/
{
    return m_location.GetLocation(pType,
                                  pLibId,
                                  pMediaSetId,
                                  pPos,
                                  pAlt1,
                                  pAlt2,
                                  pAlt3,
                                  pInvert);
}


STDMETHODIMP
CRmsCartridge::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert)
/*++

Implements:

    IRmsCartridge::SetLocation

--*/
{
    return m_location.SetLocation(type,
                                  libId,
                                  mediaSetId,
                                  pos,
                                  alt1,
                                  alt2,
                                  alt3,
                                  invert);

}


STDMETHODIMP
CRmsCartridge::GetMailStop(
    BSTR    *pMailStop
    )
/*++

Implements:

    IRmsCartridge::GetMailStop

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer (pMailStop);

        WsbAffirmHr( m_mailStop.CopyToBstr(pMailStop) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetMailStop(
    BSTR  mailStop
    )
/*++

Implements:

    IRmsCartridge::SetMailStop

--*/
{
    m_mailStop = mailStop;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetDrive(
    IRmsDrive    **ptr
    )
/*++

Implements:

    IRmsCartridge::GetDrive

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        WsbAffirmPointer(m_pDrive);

        *ptr = m_pDrive;
        m_pDrive.p->AddRef();

        hr = S_OK;

    } WsbCatch( hr );

    return(hr);
}


STDMETHODIMP
CRmsCartridge::SetDrive(
    IRmsDrive    *ptr
    )
/*++

Implements:

    IRmsChangerElement::SetCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = ptr;

        WsbAffirmHr( pElmt->SetCartridge( this ) );

        if ( m_pDrive )
            m_pDrive = 0;

        m_pDrive = ptr;

        m_isMounted = TRUE;

        hr = S_OK;

    } WsbCatch( hr );

    return(hr);
}


STDMETHODIMP
CRmsCartridge::GetInfo(
    UCHAR   *pInfo,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsCartridge::GetInfo

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pInfo );
        WsbAssertPointer( pSize );

        memmove (pInfo, m_info, m_sizeofInfo);
        *pSize = m_sizeofInfo;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetInfo(
    UCHAR  *pInfo,
    SHORT   size
    )
/*++

Implements:

    IRmsCartridge::SetInfo

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pInfo );

        memmove (m_info, pInfo, size);
        m_sizeofInfo = size;
        m_isDirty = TRUE;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetOwnerClassId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_ownerClassId;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsCartridge::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetPartitions(
    IWsbIndexedCollection **ptr
    )
/*++

Implements:

    IRmsCartridge::GetPartitions

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        *ptr = m_pParts;
        m_pParts.p->AddRef();

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetVerifierClass(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetVerifierClass

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_verifierClass;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetVerifierClass(
    CLSID   classId
    )
/*++

Implements:

    IRmsCartridge::SetVerifierClass

--*/
{
    m_verifierClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetPortalClass(
    CLSID    *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetPortalClass

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_portalClass;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetPortalClass(
    CLSID  classId
    )
/*++

Implements:

    IRmsCartridge::SetPortalClass

--*/
{
    m_portalClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::LoadDataCache(
    OUT BYTE *pCache,
    IN OUT ULONG *pSize,
    OUT ULONG *pUsed,
    OUT ULARGE_INTEGER *pStartPBA)
/*++

Implements:

    IRmsCartridge::LoadDataCache

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pCache );
        WsbAssertPointer( pSize );
        WsbAssertPointer( pUsed );
        WsbAssertPointer( pStartPBA );


        if (m_pDataCache) {
            // The saved cache size must match the target
            WsbAssert(*pSize == m_DataCacheSize, E_INVALIDARG);

            memmove (pCache, m_pDataCache, m_DataCacheUsed);
            *pSize = m_DataCacheSize;
            *pUsed = m_DataCacheUsed;
            *pStartPBA = m_DataCacheStartPBA;
        }
        else {
            hr = E_FAIL;
        }

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SaveDataCache(
    IN BYTE *pCache,
    IN ULONG size,
    IN ULONG used,
    IN ULARGE_INTEGER startPBA)
/*++

Implements:

    IRmsCartridge::SaveDataCache

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pCache );
        WsbAssert(size > 0, E_INVALIDARG);
        WsbAssert(used <= size, E_INVALIDARG);

        // Check that the current cache is big enough
        // to handle the incomming buffer.
        if (m_pDataCache && used > m_DataCacheSize) {
            WsbFree(m_pDataCache);
            m_pDataCache = NULL;
            m_DataCacheSize = 0;
            m_DataCacheUsed = 0;
            m_DataCacheStartPBA.QuadPart = 0;
        }

        if (!m_pDataCache) {
            m_pDataCache = (BYTE *) WsbAlloc(size);
            WsbAssertPointer(m_pDataCache);
            memset(m_pDataCache, 0, size);
            m_DataCacheSize = size;
        }

        WsbAssert(used <= m_DataCacheSize, E_INVALIDARG);

        memmove (m_pDataCache, pCache, used);
        m_DataCacheUsed = used;
        m_DataCacheStartPBA = startPBA;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetManagedBy(
    OUT LONG *pManagedBy
    )
/*++

Implements:

    IRmsCartridge::GetManagedBy

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pManagedBy );

        *pManagedBy = (LONG) m_ManagedBy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetManagedBy(
    IN LONG managedBy
    )
/*++

Implements:

    IRmsCartridge::SetManagedBy

--*/
{
    m_ManagedBy = (RmsMediaManager) managedBy;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::Mount(
    OUT IRmsDrive **ppDrive,
    IN DWORD dwOptions,
    IN DWORD threadId)
/*++

Implements:

    IRmsCartridge::Mount

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsCartridge::Mount"), OLESTR(""));

    try {

        CComPtr<IRmsDrive> pDrive;

        // first check if the cartridge is already mounted
        if ( S_OK == IsMounted() ) {

            LONG refs;

            WsbAffirmHr( m_pDrive->GetMountReference( &refs ) );

            if ( refs ) {
                // Does media type support concurrent mounts?
                switch ( m_type ) {
                case RmsMedia8mm:
                case RmsMedia4mm:
                case RmsMediaDLT:
                case RmsMediaTape:
                    // Tape doesn't support concurrent access - queue another mount
                    if (RmsMediaManagerNTMS == m_ManagedBy) {

                        CComPtr<IRmsNTMS> pNtms;
                        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                        WsbAffirmHr(pServer->GetNTMS(&pNtms));

                        WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

                        // We've successfully mounted the cartridge, so
                        // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                        CComPtr<IWsbIndexedCollection> pActiveCartridges;
                        WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                        WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                        WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
                    } else {

                        WsbAffirmHr( RMS_E_CARTRIDGE_BUSY );

                    }
                    break;
                case RmsMediaWORM:
                    WsbAssertHr( E_NOTIMPL );
                    break;
                case RmsMediaMO35:
                case RmsMediaCDR:
                case RmsMediaDVD:
                case RmsMediaOptical:
                case RmsMediaDisk:
                case RmsMediaFixed:
                    // Optical media and fixed disks supports concurrent access
                    if (m_isMountedSerialized && (dwOptions & RMS_SERIALIZE_MOUNT)) {
                        // If the media is already mounted for serialized operation, then we need
                        // to serialize the mount despite the media supporting concurrent mounts.
                        // For fixed disk (where we cannot serialize by issuing another RSM mount) -
                        // we fail the mount with RMS_E_CARTRIDGE_BUSY
                        if (RmsMediaManagerNTMS == m_ManagedBy) {

                            CComPtr<IRmsNTMS> pNtms;
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr(pServer->GetNTMS(&pNtms));

                            WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

                            // We've successfully mounted the cartridge, so
                            // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                            CComPtr<IWsbIndexedCollection> pActiveCartridges;
                            WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                            WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                            WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
                        } else {

                            WsbAffirmHr( RMS_E_CARTRIDGE_BUSY );

                        }
                    }
                    break;
                default:
                    WsbAssertHr( E_UNEXPECTED );
                    break;
                }
            }
        }

        if ( S_FALSE == IsMounted() ) {
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

            if (RmsMediaManagerNTMS == m_ManagedBy) {

                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));

                WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

            }
            else {

                LONG type;
                GUID libId, mediaSetId;
                LONG pos, alt1, alt2, alt3;
                BOOL invert;
                WsbAssertHr( m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert ));

                switch ( (RmsElement) type ) {
                case RmsElementStage:
                case RmsElementStorage:
                    {
                        CComPtr<IRmsLibrary> pLib;
                        CComPtr<IWsbIndexedCollection> pDrives;

                        WsbAffirmHr( pServer->FindLibraryById( libId, &pLib ));

                        // Select a drive
                        // TODO: This code will be added to the the library interface as a drive
                        // slection method.  For now, if one is free we use it.

                        WsbAffirmHr( pLib->GetDrives( &pDrives ));

                        CComPtr<IWsbEnum> pEnumDrives;

                        WsbAffirmHr( pDrives->Enum( &pEnumDrives ));
                        WsbAssertPointer( pEnumDrives );

                        hr = pEnumDrives->First( IID_IRmsDrive, (void **)&pDrive );

                        // Search for a drive to mount to
                        while ( S_OK == hr ) {

                            hr = pDrive->SelectForMount();

                            if ( S_OK == hr ) {

                                CComPtr<IWsbIndexedCollection> pChangers;
                                CComPtr<IRmsMediumChanger> pChanger;
                                CComPtr<IWsbEnum> pEnumChangers;

                                WsbAffirmHr( pLib->GetChangers( &pChangers ));
                                WsbAssertHr( pChangers->Enum( &pEnumChangers ));
                                WsbAssertPointer( pEnumChangers );

                                // we'll just use the first changer for the move.
                                WsbAssertHr( pEnumChangers->First( IID_IRmsMediumChanger, (void **)&pChanger ));

                                WsbAffirmHr( pChanger->MoveCartridge( this, pDrive ));

                                WsbAffirmHr( SetIsMounted( TRUE ));

                                WsbAffirmHr( SetDrive( pDrive ));

                                break;

                            }

                            hr = pEnumDrives->Next( IID_IRmsDrive, (void **)&pDrive );
                        }

                    }
                    break;

                case RmsElementShelf:
                case RmsElementOffSite:
                    WsbAssertHr( E_NOTIMPL );
                    break;

                case RmsElementDrive:
                    WsbAssertHr( E_UNEXPECTED );
                    break;

                case RmsElementChanger:
                case RmsElementIEPort:
                    WsbAssertHr( E_NOTIMPL );
                    break;

                } // switch
            }

            if ( S_OK == IsMounted() ) {

                // We've successfully mounted the cartridge, so
                // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                CComPtr<IWsbIndexedCollection> pActiveCartridges;
                WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
            }

        }

        if ( S_OK == IsMounted() ) {

            // Update serialization flag if needed
            if (dwOptions & RMS_SERIALIZE_MOUNT) {
                // This signals to serialize next mount for the same media
                m_isMountedSerialized = TRUE;
            }

            // Final updates
            switch ( m_type ) {

            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:

                // increment the object reference counter.
                *ppDrive = m_pDrive;
                WsbAffirmHr( m_pDrive.p->AddRef() );

                // increment the mount reference counter.
                WsbAffirmHr( m_pDrive->AddMountReference() );

                // update stats
                WsbAffirmHr( updateMountStats( TRUE, TRUE ) );

                hr = S_OK;

                break;

            case RmsMediaWORM:
                WsbAssertHr( E_NOTIMPL );
                break;

            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaOptical:
            case RmsMediaDisk:
            case RmsMediaFixed:

                // increment the object reference counter.
                *ppDrive = m_pDrive;
                WsbAffirmHr( m_pDrive.p->AddRef() );

                // increment the mount reference counter.
                WsbAffirmHr( m_pDrive->AddMountReference() );

                // update stats
                WsbAffirmHr( updateMountStats( TRUE, TRUE ) );

                hr = S_OK;
                
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;

            }
        }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::Mount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}



STDMETHODIMP
CRmsCartridge::Dismount(
    IN DWORD dwOptions
    )
/*++

Implements:

    IRmsCartridge::Dismount

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Dismount"), OLESTR("<%ld>"), dwOptions);

    try {
        // Update stats
        WsbAffirmHr(updateMountStats(FALSE, FALSE));

        // Decrement the mount reference counter.
        //
        // When the reference count for the cartridge goes to zero,
        // and the dismount wait time has expired, we physically
        // move the cartridge back to it's storage location.
        WsbAssert(m_pDrive != 0, RMS_E_CARTRIDGE_NOT_MOUNTED);
        WsbAffirmHr(m_pDrive->ReleaseMountReference(dwOptions));

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::Dismount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    
    return hr;

}


HRESULT
CRmsCartridge::Home(IN DWORD dwOptions)
/*++

Implements:

    IRmsDrive::Home

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Home"), OLESTR(""));

    try {
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        try {
/*

            Tracking DataMovers is only partially implemented.

    
            //
            // Cleanup...
            // Release all DataMovers that reference this cartridge.
            //
            CComPtr<IWsbEnum>               pEnumDataMovers;
            CComPtr<IWsbIndexedCollection>  pDataMovers;
            CComPtr<IRmsCartridge>          pCart;
            CComPtr<IDataMover>             pMover;

            WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));
            WsbAffirmHr(pDataMovers->Enum(&pEnumDataMovers));
            WsbAssertPointer(pEnumDataMovers);
            hr = pEnumDataMovers->First(IID_IDataMover, (void **)&pMover);
            while (S_OK == hr) {
                try {
                    GUID cartIdOfMover = GUID_NULL;
                    GUID cartId = GUID_NULL;

                    WsbAffirmHr(pMover->GetCartridge(&pCart));
                    WsbAffirmPointer(pCart);
                    WsbAffirmHr(pCart->GetCartridgeId(&cartIdOfMover));
                    WsbAffirmHr(GetCartridgeId(&cartId));
                    WsbAssert(cartId != GUID_NULL, E_UNEXPECTED);

                    //
                    // Does this mover reference this cartridge?
                    //
                    if (cartIdOfMover == cartId) {
                        //
                        // Cancel any outstanding I/O, and remove the mover
                        // from the list of active movers.
                        //
                        WsbAffirmHr(pMover->Cancel());
                        WsbAffirmHr(ReleaseDataMover(pMover));
                    }
                } WsbCatch(hr);

                pCart = 0;
                pMover = 0;
                hr = pEnumDataMovers->Next( IID_IDataMover, (void **)&pMover );
            }
            hr = S_OK;

*/
            LONG type;
            GUID libId, mediaSetId;
            LONG pos, alt1, alt2, alt3;
            BOOL invert;

            // We're physically moving the cartridge back to it's storage
            // location.

            WsbAssertHr( m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert ));

            WsbAffirmHr(SetIsMounted(FALSE));

            if (RmsMediaManagerNTMS == m_ManagedBy) {

                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Dismount(this, dwOptions));

            }
            else {

                CComPtr<IRmsLibrary>            pLib;
                CComPtr<IWsbIndexedCollection>  pChangers;
                CComPtr<IRmsMediumChanger>      pChanger;
                CComPtr<IWsbEnum>               pEnumChangers;

                WsbAffirmHr(pServer->FindLibraryById(libId, &pLib));
                WsbAffirmHr(pLib->GetChangers(&pChangers));
                WsbAssertHr(pChangers->Enum( &pEnumChangers));
                WsbAssertPointer(pEnumChangers);

                // we'll just use the first changer for the move.
                WsbAffirmHr(pEnumChangers->First(IID_IRmsMediumChanger, (void **)&pChanger));

                WsbAffirmHr(pChanger->HomeCartridge(this));


            }

        } WsbCatch(hr)

#if RMS_USE_ACTIVE_COLLECTION
        CComPtr<IWsbIndexedCollection>  pActiveCartridges;
        WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
        WsbAffirmHr(pActiveCartridges->RemoveAndRelease((IRmsCartridge *)this));

        ULONG activeCartridges;
        WsbAffirmHr(pActiveCartridges->GetEntries( &activeCartridges));
        WsbTrace(OLESTR("activeCartridges = <%u>\n"), activeCartridges);
#else
        WsbAffirmHr(pServer->SetActiveCartridge(NULL));
#endif

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsCartridge::Home"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsCartridge::updateMountStats(
    IN BOOL bRead,
    IN BOOL bWrite
    )
/*++

Updates storage info for the mounted partition

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsCartridge::updateMountStats"), OLESTR(""));

    try {


        // We have not implemented partitions yet, everything
        // is single sided...  eventually the following need to be added to
        // the correct partition.  Should this be in a separate function?.

        // For now we don't distinguish between reads and writes
        if ( bRead ) m_readMountCounter++;
        if ( bWrite ) m_writeMountCounter++;

        // Update the read/write timestamps
        // if ( bRead ) m_lastReadTimestamp;
        // if ( bWrite ) m_lastWriteTimestamp;

        hr = S_OK;

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::updateMountStats"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsCartridge::CreateDataMover(
    IDataMover **ptr
    )
/*++

Implements:

    IRmsDrive::CreateDataMover

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer(ptr);

        if ( S_OK == IsMounted() ) {

            WsbAssertPointer(m_pDrive );
            WsbAffirmHr(m_pDrive->CreateDataMover(ptr));

        }
        else {

            hr = RMS_E_RESOURCE_UNAVAILABLE;

        }

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsCartridge::ReleaseDataMover(
    IN IDataMover *ptr
    )
/*++

Implements:

    IRmsCartridge::ReleaseDataMover

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);
        WsbAffirmPointer(m_pDrive);

        WsbAffirmHr(m_pDrive->ReleaseDataMover(ptr));

    } WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetIsAvailable(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetIsAvailable

--*/
{
    m_isAvailable = flag;

    return S_OK;
}

STDMETHODIMP
CRmsCartridge::IsAvailable(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsAvailable

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isAvailable ? S_OK : S_FALSE;

    return (hr);
}

STDMETHODIMP
CRmsCartridge::IsFixedBlockSize(void)
/*++

Implements:

    IRmsCartridge::IsFixedBlockSize

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::IsFixedBlockSize"), OLESTR(""));

    try {
        switch ( m_type ) {
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                hr = S_FALSE;
                break;

            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaOptical:
            case RmsMediaDisk:
            case RmsMediaFixed:
                hr = S_OK;
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;
        }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::IsFixedBlockSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmscelmt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCElmt.h

Abstract:

    Declaration of the CRmsChangerElement class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCELMT_
#define _RMSCELMT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsChangerElement

Class Description:

    A CRmsChangerElement represents an element within a library device.  Each
    element can support one or more kinds of media.  An element can be used
    for storage.  Various statistics about an element are kept for an object
    of this type.  These include the number of times a Cartridge has been put
    into the element or taken from (get) the element.  Each element can has
    one owner and is specified by the ClassId of the application that configured
    the element.

    All elements within a library have spacial resolution. This is modeled by a
    triplete (x1, x2, x3) that provides relative physical location to other
    elements.

--*/

class CRmsChangerElement :
    public CComDualImpl<IRmsChangerElement, &IID_IRmsChangerElement, &LIBID_RMSLib>,
    public CRmsComObject
{
public:
    CRmsChangerElement();
    ~CRmsChangerElement();

// CRmsChangerElement
public:

    HRESULT  CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT  GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT  Load(IStream* pStream);
    HRESULT  Save(IStream* pStream, BOOL clearDirty);

    HRESULT  Test(USHORT *pPassed, USHORT *pFailed);

// IRmsChangerElement
public:

    STDMETHOD(GetElementNo)(LONG *pElementNo);

    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(IsStorage)(void);
    STDMETHOD(SetIsStorage)(BOOL flag);

    STDMETHOD(IsOccupied)(void);
    STDMETHOD(SetIsOccupied)(BOOL flag);

    STDMETHOD(GetCartridge)(IRmsCartridge **ptr);
    STDMETHOD(SetCartridge)(IRmsCartridge *ptr);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetAccessCounters)(LONG *pGets, LONG *pPuts);

    STDMETHOD(ResetAccessCounters)(void);

    STDMETHOD(GetResetCounterTimestamp)(DATE *pDate);
    STDMETHOD(GetLastGetTimestamp)(DATE *pDate);
    STDMETHOD(GetLastPutTimestamp)(DATE *pDate);

    STDMETHOD(GetCoordinates)(LONG *pX1, LONG *pX2, LONG *pX3);
    STDMETHOD(SetCoordinates)(LONG x1, LONG x2, LONG x3);

protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_elementNo;            // The element number.
    CRmsLocator     m_location;             // The address of the element.
    RmsMedia        m_mediaSupported;       // The type of media supported by the
                                            //   element, usually one type, but
                                            //   can be a combination of media
                                            //   types for multi-function devices
                                            //   (i.e. drives that support Optical,
                                            //   WORM, and CDR).
    BOOL            m_isStorage;            // If TRUE, the element can be used to
                                            //   store a unit of media.
    BOOL            m_isOccupied;           // If TRUE, the element contains a unit of media.
    IRmsCartridge * m_pCartridge;           // A pointer to the Cartridge object residing
                                            //   within the changer element.  This is not smart
                                            //   pointer, since a cartridge cannot exist only
                                            //   with in the context of a changer element, and
                                            //   eliminates problems associated with deleting
                                            //   with a backward references to other objects...
    CLSID           m_ownerClassId;         // The Class ID for the application that
                                            //   currently owns the element resource.
    LONG            m_getCounter;           // The number of Cartridge-gets from this element.
    LONG            m_putCounter;           // The number of Cartridge-puts to this element.
    DATE            m_resetCounterTimestamp;    // The time the counters were reset.
    DATE            m_lastGetTimestamp;     // The date of last Cartridge-get.
    DATE            m_lastPutTimestamp;     // The date of last Cartridge-put.
    LONG            m_x1;                   // x1, x2, x3 specify a spacial location
    LONG            m_x2;                   //   relative other elements in the library.
    LONG            m_x3;                   //   These are used for micro-optimizations.
};

#endif // _RMSCELMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmscartg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCartg.h

Abstract:

    Declaration of the CRmsCartridge class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCARTG_
#define _RMSCARTG_

#include "resource.h"       // resource symbols

#include "RmsSInfo.h"       // CRmsStorageInfo
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsCartridge

Class Description:

    A CRmsCartridge represents a unit of removalble media.  This can be a tape
    cartridge, removable hard disk, optical platter (of various formats),
    Compact Disk, or DVD Optical Disc. A Cartridge is normally designated as
    either scratch or private.  The Cartrige name or GUID is used by an
    application     when referencing a particular unit of removable media.

    Cartridge information is maintained by the Removable Media Service, and
    the Cartriges's properties are recreated or updated by auditing the contents of
    the Library.

--*/

class CRmsCartridge :
    public CComDualImpl<IRmsCartridge, &IID_IRmsCartridge, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsCartridge,&CLSID_CRmsCartridge>
{
public:
    CRmsCartridge() {}
BEGIN_COM_MAP(CRmsCartridge)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsCartridge)
    COM_INTERFACE_ENTRY(IRmsCartridge)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsCartridge)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsCartridge
public:
    STDMETHOD(GetCartridgeId)(GUID *pCartId);
    STDMETHOD(SetCartridgeId)(GUID cartId);

    STDMETHOD(GetMediaSetId)(GUID *pMediaSetId);
    STDMETHOD(SetMediaSetId)(GUID mediaSetId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetDescription)(BSTR *pDescription);
    STDMETHOD(SetDescription)(BSTR description);

    STDMETHOD(GetTagAndNumber)(BSTR *pTag, LONG *pNumber);
    STDMETHOD(SetTagAndNumber)(BSTR tag, LONG number);

    STDMETHOD(GetBarcode)(BSTR *pBarcode);  // Same as Tag

    // OnMediaIdentifier is used by DataMover
    STDMETHOD(GetOnMediaIdentifier)(BYTE *pIdentifier, LONG *pSize, LONG *pType);
    STDMETHOD(SetOnMediaIdentifier)(BYTE *pIdentifier, LONG size, LONG type);

    // OnMediaLabel is used by DataMover
    STDMETHOD(GetOnMediaLabel)(BSTR *pLabel);
    STDMETHOD(SetOnMediaLabel)(BSTR label);

    STDMETHOD(GetStatus)(LONG *pStatus);
    STDMETHOD(SetStatus)(LONG status);

    STDMETHOD(GetType)(LONG *pType);
    STDMETHOD(SetType)(LONG type);

    STDMETHOD(GetBlockSize)(LONG *pBlockSize);
    STDMETHOD(SetBlockSize)(LONG blockSize);

    STDMETHOD(IsTwoSided)(void);
    STDMETHOD(SetIsTwoSided)(BOOL flag);

    STDMETHOD(IsMounted)(void);
    STDMETHOD(SetIsMounted)(BOOL flag);

    STDMETHOD(IsAvailable)(void);
    STDMETHOD(SetIsAvailable)(BOOL flag);

    STDMETHOD(GetHome)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetHome)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetMailStop)(BSTR *pMailStop);
    STDMETHOD(SetMailStop)(BSTR mailStop);

    STDMETHOD(GetDrive)(IRmsDrive **ptr);
    STDMETHOD(SetDrive)(IRmsDrive *ptr);

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetPartitions)(IWsbIndexedCollection **ptr);

    STDMETHOD(GetVerifierClass)(CLSID *pClassId);
    STDMETHOD(SetVerifierClass)(CLSID classId);

    STDMETHOD(GetPortalClass)(CLSID *pClassId);
    STDMETHOD(SetPortalClass)(CLSID classId);

    STDMETHOD( Mount )( OUT IRmsDrive **ppDrive, IN DWORD dwOptions = RMS_NONE, IN DWORD threadId = 0);
    STDMETHOD( Dismount )( IN DWORD dwOptions = RMS_NONE );
    STDMETHOD( Home )( IN DWORD dwOptions = RMS_NONE );

    STDMETHOD( CreateDataMover )( /*[out]*/ IDataMover **ptr );
    STDMETHOD( ReleaseDataMover )( IN IDataMover *ptr );

    STDMETHOD( LoadDataCache )(OUT BYTE *pCache, IN OUT ULONG *pSize, OUT ULONG *pUsed, OUT ULARGE_INTEGER *pStartPBA);
    STDMETHOD( SaveDataCache )(IN BYTE *pCache, IN ULONG size, IN ULONG used, IN ULARGE_INTEGER startPBA);

    STDMETHOD( GetManagedBy )(OUT LONG *pManagedBy);
    STDMETHOD( SetManagedBy )(IN LONG managedBy);

    STDMETHOD(IsFixedBlockSize)(void);

// CRmsCartridge
private:
    HRESULT updateMountStats( IN BOOL bRead, IN BOOL bWrite );

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = RMS_STR_MAX_CARTRIDGE_INFO    // Size of the application specific
                                                //   information buffer.  Currently
                                                //   fixed in size.
        };
    CWsbBstrPtr     m_externalLabel;        // A string representing bar code or
                                            //   SCSI volume-tag information.
    LONG            m_externalNumber;       // A numeric value representing
                                            //   SCSI volume-tag sequence number.
    LONG            m_sizeofOnMediaId;      // The size of the on media identification buffer.
    LONG            m_typeofOnMediaId;      // The type of the on media identification.
    BYTE           *m_pOnMediaId;           // Raw on media identification buffer.
                                            //
    CWsbBstrPtr     m_onMediaLabel;         // The UNICODE label written on the media.
                                            //
    RmsStatus       m_status;               // Cartridge status (see RmsStatus).
    RmsMedia        m_type;                 // The type of Cartridge (see RmsMedia).
    LONG            m_BlockSize;            // Media block size.
    BOOL            m_isTwoSided;           // TRUE if the Cartridge represents two-sided media
                                            //   Note: Currently nobody sets this value - 
                                            //         this should be fixed if found to be important                    
    BOOL            m_isMounted;            // TRUE if the Cartridge is mounted in a drive.
    BOOL            m_isInTransit;          // TRUE if the Cartridge is in transit between locations.
    BOOL            m_isAvailable;          // TRUE if the Cartridge is not in use by any application
                                            //  (Note: Available here does not ensure online)
    BOOL            m_isMountedSerialized;  // TRUE if the cartridge has been mounted as serialized
    CRmsLocator     m_home;                 // The preferred storage location
                                            //   for the Cartridge (see CRmsLocator).
    CRmsLocator     m_location;             // The current location of the
                                            //   Cartridge (see CRmsLocator).
    CRmsLocator     m_destination;          // The target destination location of the
                                            //   Cartridge (see CRmsLocator).  Valid when
                                            //   m_isInTransit bit is set.
    CWsbBstrPtr     m_mailStop;             // A string describing the shelf (local)
                                            //   or off-site location of a Cartridge.
                                            //   This is displayed when the Cartridge
                                            //   needs to be mounted with human
                                            //   intervention.  [This field is
                                            //   created by the Import/Export dialog.]
    CComPtr<IRmsDrive> m_pDrive;            // The drive in which the cartridge is mounted.
    SHORT           m_sizeofInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_info[MaxInfo];        // Application specific information.
    CLSID           m_ownerClassId;         // The Class ID for the application that
                                            //   owns/created the cartridge resource.
    CComPtr<IWsbIndexedCollection> m_pParts;    // A collection of Partitions.  These
                                            //   represent the partitions on a tape
                                            //   or sides of an optical platter.
    CLSID           m_verifierClass;        // The interface to the on-media
                                            //    ID verification function.
    CLSID           m_portalClass;          // The interface to a site specific import
                                            //   and export storage location
                                            //   specification dialog.

    BYTE *          m_pDataCache;           // Cache used to handle I/O for block boudary conditions
    ULONG           m_DataCacheSize;        // Max size of the cache
    ULONG           m_DataCacheUsed;        // The number of bytes of the cache containing valid data
    ULARGE_INTEGER  m_DataCacheStartPBA;    // The corresponding starting PBA for the cache

    RmsMode         m_MountMode;            // The mount mode specified for the cartridge.

    RmsMediaManager m_ManagedBy;            // The media manager that controls the cartridge.

    static int      s_InstanceCount;        // Counter of the number of object instances.
};

#endif // _RMSCARTG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmschngr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsChngr.cpp

Abstract:

    Implementation of CRmsMediumChanger

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsChngr.h"
#include "RmsServr.h"

////////////////////////////////////////////////////////////////////////////////
//

HRESULT
CRmsMediumChanger::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize fields
        m_isAutomatic = FALSE;

        m_canRotate = FALSE;

        m_operation = RMS_UNDEFINED_STRING;

        m_percentComplete = 0;

        m_handle = INVALID_HANDLE_VALUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CRmsMediumChanger::FinalRelease(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr( ReleaseDevice() );

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsMediumChanger::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsMediumChanger::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // !!!!!
        //
        // IMPORTANT: The collectable coming in may not be a CRmsDrive if the collection
        //            is the unconfigured device list.
        //
        // !!!!!

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
        case RmsFindByDeviceAddress:
        case RmsFindByDeviceName:
        case RmsFindByDeviceType:

            // Do CompareTo for device
            hr = CRmsDevice::CompareTo( pCollectable, &result );
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsMediumChanger::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


STDMETHODIMP
CRmsMediumChanger::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediumChanger::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsMediumChanger;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       inProcessOperation;


    WsbTraceIn(OLESTR("CRmsMediumChanger::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        inProcessOperation = SysStringByteLen(m_operation);

//        // Get size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +       // m_isAutomatic
//                             WsbPersistSizeOf(LONG) +       // m_canRotate
//                             WsbPersistSizeOf(LONG) +       // m_operation length
//                             inProcessOperation;            // m_operation

////                           inProcessOperation +           // m_operation
////                           WsbPersistSizeOf(BYTE);        // m_percentComplete


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediumChanger::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Load(pStream));

        // Load value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isAutomatic));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_canRotate));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_operation));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_percentComplete));

        if ( INVALID_HANDLE_VALUE == m_handle ) {

            WsbAffirmHr( AcquireDevice() );

        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Save(
    IN  IStream *pStream,
    IN  BOOL    clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediumChanger::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Save(pStream, clearDirty));

        // Save value
        WsbAffirmHr(WsbSaveToStream(pStream, m_isAutomatic));

        WsbAffirmHr(WsbSaveToStream(pStream, m_canRotate));

        WsbAffirmHr(WsbBstrToStream(pStream, m_operation));

        WsbAffirmHr(WsbSaveToStream(pStream, m_percentComplete));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Test(
    OUT USHORT  *pPassed,
    OUT USHORT  *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediumChanger>      pChanger1;
    CComPtr<IRmsMediumChanger>      pChanger2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

//  CRmsLocator             locWork1;
//  CRmsLocator             locWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;


    WsbTraceIn(OLESTR("CRmsMediumChanger::Test"), OLESTR(""));

    try {
        // Get the Changer interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediumChanger*) this)->QueryInterface(IID_IRmsMediumChanger, (void**) &pChanger1));

            // Test SetHome & GetHome

            // Test SetAutomatic & IsAutomatic to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetAutomatic (TRUE));
                WsbAffirmHr(IsAutomatic ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetAutomatic & IsAutomatic to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetAutomatic (FALSE));
                WsbAffirmHr(IsAutomatic ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetCanRotate & IsCanRotate to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetCanRotate (TRUE));
                WsbAffirmHr(CanRotate ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetCanRotate & IsCanRotate to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetCanRotate (FALSE));
                WsbAffirmHr(CanRotate ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetOperation & GetOperation interface
            bstrWork1 = bstrVal1;

            SetOperation(bstrWork1);

            GetOperation(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPercentComplete  & GetPercentComplete

            // Test ExportCartridge & ImportCartridge

            // Test DismountCartridge & MountCartridge

            // Test TestReady

            // Test Home

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// IRmsMediumChanger implementation
//


STDMETHODIMP
CRmsMediumChanger::GetHome(
    LONG    *pType,
    LONG    *pPos,
    BOOL    *pInvert
    )
/*++

Implements:

    IRmsMediumChanger::GetHome

--*/
{
    GUID zero = {0,0,0,0,0,0,0,0,0,0,0};
    LONG junk;

    return m_home.GetLocation( pType,
                               &zero,
                               &zero,
                               pPos,
                               &junk,
                               &junk,
                               &junk,
                               pInvert );
}

STDMETHODIMP
CRmsMediumChanger::SetHome(
    LONG    type,
    LONG    pos,
    BOOL    invert
    )
/*++

Implements:

    IRmsMediumChanger::SetHome

--*/
{
    GUID zero = {0,0,0,0,0,0,0,0,0,0,0};
    LONG junk = 0;

    m_isDirty = TRUE;
    return m_home.SetLocation( type, zero, zero, pos, junk, junk, junk, invert );
}

STDMETHODIMP
CRmsMediumChanger::SetAutomatic(
    BOOL    flag
    )
/*++

Implements:

    IRmsMediumChanger::SetAutomatic

--*/
{
    m_isAutomatic = flag;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::IsAutomatic(
    void
    )
/*++

Implements:

    IRmsMediumChanger::IsAutomatic

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isAutomatic){
        hr = S_OK;
        }

    return (hr);
}

STDMETHODIMP
CRmsMediumChanger::SetCanRotate(
    BOOL    flag
    )
/*++

Implements:

    IRmsMediumChanger::SetCanRotate

--*/
{
    m_canRotate = flag;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::CanRotate(
    void
    )
/*++

Implements:

    IRmsMediumChanger::CanRotate

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_canRotate){
        hr = S_OK;
        }

    return (hr);
}


STDMETHODIMP
CRmsMediumChanger::GetOperation(
    BSTR    *pOperation
    )
/*++

Implements:

    IRmsMediumChanger::GetOperation

--*/
{
    WsbAssertPointer ( pOperation );

    m_operation.CopyToBstr( pOperation );
    return S_OK;
}


STDMETHODIMP
CRmsMediumChanger::SetOperation(
    BSTR    pOperation
    )
/*++

Implements:

    IRmsMediumChanger::SetOperation

--*/
{
    m_operation = pOperation;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::GetPercentComplete(
    BYTE  *pPercent
    )
/*++

Implements:

    IRmsMediumChanger::GetPercentComplete

--*/
{
    *pPercent = m_percentComplete;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::SetPercentComplete(
    BYTE  percent
    )
/*++

Implements:

    IRmsMediumChanger::SetPercentComplete

--*/
{
    m_percentComplete = percent;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::TestReady(
    void
    )
/*++

Implements:

    IRmsMediumChanger::TestReady

--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRmsMediumChanger::ImportCartridge(
    IRmsCartridge** /*pCart*/
    )
/*++

Implements:

    IRmsMediumChanger::ImportCartridge

--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRmsMediumChanger::ExportCartridge(
    IRmsCartridge** /*pCart*/
    )
/*++

Implements:

    IRmsMediumChanger::ExportCartridge

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CRmsMediumChanger::MoveCartridge(
    IN IRmsCartridge *pSrcCart,
    IN IUnknown *pDestElmt
    )
/*++

Implements:

    IRmsMediumChanger::MountCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {

        CComPtr<IRmsCartridge> pCart2;
        CComPtr<IRmsDrive> pDrive2;

        GUID libId=GUID_NULL, mediaSetId=GUID_NULL;
        LONG type=0, pos=0, alt1=0, alt2=0, alt3=0;
        BOOL invert=0;

        GUID destLibId=GUID_NULL, destMediaSetId=GUID_NULL;
        LONG destType=0, destPos=0, destAlt1=0, destAlt2=0, destAlt3=0;
        BOOL destInvert=0;

        GUID dest2LibId=GUID_NULL, dest2MediaSetId=GUID_NULL;
        LONG dest2Type=0, dest2Pos=0, dest2Alt1=0, dest2Alt2=0, dest2Alt3=0;
        BOOL dest2Invert=0;

        CHANGER_ELEMENT src, dest, dest2;

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pDestElmt;
        WsbAssertPointer( pElmt );

        // TODO:  assert cartridge has same libId as changer

        // Set up for SOURCE
        
        WsbAffirmHr( pSrcCart->GetLocation( &type, &libId, &mediaSetId,
                                            &pos, &alt1, &alt2, &alt3, &invert ));

        src.ElementAddress = pos;

        // Translate the RmsElement type to something the drive understands.

        // TODO: make this a local method

        switch ( (RmsElement) type ) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            src.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            src.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            src.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            src.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Set up for DESTINATION
        //
        
        WsbAffirmHr( pElmt->GetLocation( &destType, &destLibId, &destMediaSetId,
                                         &destPos, &destAlt1, &destAlt2, &destAlt3, &destInvert ));

        dest.ElementAddress = destPos;

        // Translate the Rms type to something the drive understands.
        switch ( (RmsElement) destType) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            dest.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            dest.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            dest.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            dest.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Do we need to do an exchange or a simple move?
        //

        BOOL destFull;

        hr = pElmt->IsOccupied();

        destFull = ( S_OK == hr ) ? TRUE : FALSE;

        if ( destFull ) {

            //
            // Set up for second destination
            //

            pElmt->GetCartridge( &pCart2 );

            pCart2->GetDrive( &pDrive2 );

            if ( pDrive2 && ( m_parameters.Features0 & CHANGER_PREDISMOUNT_EJECT_REQUIRED ) ) {
                pDrive2->Eject();
            }

            WsbAffirmHr( pCart2->GetHome( &dest2Type, &dest2LibId, &dest2MediaSetId,
                                             &dest2Pos, &dest2Alt1, &dest2Alt2, &dest2Alt3, &dest2Invert ));


            dest2.ElementAddress = dest2Pos;

            // Translate the Rms type to something the drive understands.
            switch ( (RmsElement) dest2Type) {
            case RmsElementUnknown:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementStage:
            case RmsElementStorage:
                dest2.ElementType = ChangerSlot;
                break;

            case RmsElementShelf:
            case RmsElementOffSite:
                // not supported here!
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementDrive:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementChanger:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementIEPort:
                dest2.ElementType = ChangerIEPort;
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;
            }


            WsbAffirmHr( ExchangeMedium( src, dest, dest2, FALSE, FALSE ));

            // Update the Cartridge's Locator
            WsbAffirmHr( pSrcCart->SetLocation( destType, libId, mediaSetId,
                                                destPos, alt1, alt2, alt3, invert ));

            WsbAffirmHr( pCart2->SetLocation( dest2Type, dest2LibId, dest2MediaSetId,
                                                dest2Pos, dest2Alt1, dest2Alt2, dest2Alt3, dest2Invert ));

        }
        else {

            // Call through to the medium changer driver to move the cartridge

            // TODO: handle two sided media.

            WsbAffirmHr( MoveMedium( src, dest, FALSE ));

            // Update the Cartridge's Locator
            WsbAffirmHr( pSrcCart->SetLocation( destType, libId, mediaSetId,
                                                destPos, alt1, alt2, alt3, invert ));

        }

        hr = S_OK;

    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediumChanger::HomeCartridge(
    IN IRmsCartridge *pCart
    )
/*++

Implements:

    IRmsMediumChanger::HomeCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {

        WsbAssertPointer( pCart );

        GUID libId=GUID_NULL, mediaSetId=GUID_NULL;
        LONG type=0, pos=0, alt1=0, alt2=0, alt3=0;
        BOOL invert=0;

        GUID destLibId=GUID_NULL, destMediaSetId=GUID_NULL;
        LONG destType=0, destPos=0, destAlt1=0, destAlt2=0, destAlt3=0;
        BOOL destInvert=0;

        CHANGER_ELEMENT src, dest;

        // TODO:  assert cartridge has same libId as changer

        // Set up for SOURCE
        
        WsbAffirmHr( pCart->GetLocation( &type, &libId, &mediaSetId,
                                         &pos, &alt1, &alt2, &alt3, &invert ));

        src.ElementAddress = pos;

        // Translate the RmsElement type to something the drive understands.

        // TODO: make this a local method

        switch ( (RmsElement) type ) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            src.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            src.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            src.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            src.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Set up for DESTINATION
        //
        
        WsbAffirmHr( pCart->GetHome( &destType, &destLibId, &destMediaSetId,
                                     &destPos, &destAlt1, &destAlt2, &destAlt3, &destInvert ));

        dest.ElementAddress = destPos;

        // Translate the Rms type to something the drive understands.
        switch ( (RmsElement) destType) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            dest.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            dest.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            dest.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            dest.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        WsbAffirmHr( MoveMedium( src, dest, FALSE ));

        // Update the Cartridge's Locator
        WsbAffirmHr( pCart->SetLocation( destType, libId, mediaSetId,
                                            destPos, alt1, alt2, alt3, invert ));

        hr = S_OK;

    }
    WsbCatch(hr);
    
    return hr;

}


STDMETHODIMP
CRmsMediumChanger::Initialize(
    void
    )
/*++

Implements:

    IRmsMediumChanger::Initialize

--*/
{

    // TODO: Break this into some smaller methods for initializing slot, drives, ports, etc.

    HRESULT hr = E_FAIL;

    PREAD_ELEMENT_ADDRESS_INFO pElementInformation = 0;

    try {
        DWORD size;

        WsbAffirmHr(AcquireDevice());

        WsbAffirmHr(Status());

        size = sizeof( CHANGER_PRODUCT_DATA );
        CHANGER_PRODUCT_DATA productData;
        WsbAffirmHr(GetProductData( &size, &productData ));

        // Get device specific parameters.
        size = sizeof( GET_CHANGER_PARAMETERS );
        WsbAffirmHr(GetParameters(&size, &m_parameters));

        // save some of the more common parameters
        m_isAutomatic = TRUE;
        if ( m_parameters.Features0 & CHANGER_MEDIUM_FLIP ) m_canRotate = TRUE;

        // Initialize the changer elements
        BOOL scan = TRUE;
        CHANGER_ELEMENT_LIST list;

        if ( m_parameters.Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED ) scan = TRUE;

        list.NumberOfElements = 1;
        list.Element.ElementType = AllElements;
        list.Element.ElementAddress = 0;

        WsbAffirmHr( InitializeElementStatus( list, scan ) );

        list.NumberOfElements = m_parameters.NumberStorageElements;
        list.Element.ElementType = ChangerSlot;
        list.Element.ElementAddress = 0;

        BOOL tag = ( m_parameters.Features0 & CHANGER_VOLUME_IDENTIFICATION ) ? TRUE : FALSE;

        size = sizeof(READ_ELEMENT_ADDRESS_INFO) + (list.NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS);
        pElementInformation = (PREAD_ELEMENT_ADDRESS_INFO)WsbAlloc( size );
        WsbAffirmPointer(pElementInformation);
        memset(pElementInformation, 0, size);

        WsbAffirmHr( GetElementStatus( list, tag, &size, pElementInformation ));

        // Create storage slot objects for this changer, if required.
        LONG type;
        GUID libId, mediaSetId;
        LONG pos, alt1, alt2, alt3;
        BOOL invert;

        m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert );

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        CComPtr<IWsbIndexedCollection> pCarts;
        CComPtr<IWsbIndexedCollection> pSlots;

        CComPtr<IRmsLibrary>        pLib;
        CComPtr<IRmsStorageSlot>    pSlot;

        WsbAffirmHr( pServer->FindLibraryById( libId, &pLib ));

        WsbAffirmHr( pLib->GetStorageSlots( &pSlots ));
        WsbAffirmHr( pServer->GetCartridges( &pCarts ));

        ULONG count = 0;
        WsbAffirmHr( pSlots->GetEntries( &count ));

        while ( count < pElementInformation->NumberOfElements ) {

            // Add more slots objects to the library
            WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsStorageSlot, 0, CLSCTX_SERVER,
                                                IID_IRmsStorageSlot, (void **)&pSlot ));

            WsbAffirmHr( pSlots->Add( pSlot ));

            pSlot = 0;

            count++;
        }

        // Populate the storage slot objects with information reported by the device

        // TODO:  We need to add lots more asserts of various conditions where the
        //        previous slot information is not consistant with what has been detected.

        PCHANGER_ELEMENT_STATUS pElementStatus;
        CComPtr<IWsbEnum> pEnumSlots;

        WsbAffirmHr( pSlots->Enum( &pEnumSlots ));
        WsbAssertPointer( pEnumSlots );

        hr = pEnumSlots->First( IID_IRmsStorageSlot, (void **)&pSlot );

        for ( ULONG i = 0; i < pElementInformation->NumberOfElements; i++ ) {

            pElementStatus = &pElementInformation->ElementStatus[i];

            WsbAssert( ChangerSlot == pElementStatus->Element.ElementType, E_UNEXPECTED );
            WsbAssert( i == pElementStatus->Element.ElementAddress, E_UNEXPECTED );

            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pSlotElmt = pSlot;

            // Is the unit of media inverted?
            invert = ( ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) &&
                       ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT )    ) ? TRUE : FALSE;
            WsbAffirmHr( pSlotElmt->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));

            // Is the slot Full or Empty?
            BOOL occupied = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_FULL ) ? TRUE : FALSE;
            WsbAffirmHr( pSlotElmt->SetIsOccupied( occupied ));

            // Set the media type supported
            WsbAffirmHr( pSlotElmt->SetMediaSupported( m_mediaSupported ));

            // Set the storage flag
            WsbAffirmHr( pSlotElmt->SetIsStorage( TRUE ));

            // If there is a cartridge present fill in cartridge information
            if ( occupied ) {

                CComPtr<IRmsCartridge> pCart;

                WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                    IID_IRmsCartridge, (void **)&pCart ));


                WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetHome( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                WsbAffirmHr( pCart->SetType( m_mediaSupported ));
                WsbAffirmHr( pSlotElmt->SetCartridge( pCart ));

                // Add cartridge to drive
                WsbAffirmHr( pCarts->Add( pCart ));

                if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_PVOLTAG ) {

                    pElementStatus->PrimaryVolumeID[32] = '\0';  // This nulls the reserved byte
                    pElementStatus->PrimaryVolumeID[33] = '\0';  // This nulls the reserved byte
                    CWsbBstrPtr label( (char *)pElementStatus->PrimaryVolumeID );

                    // Fill in external label information
                    WsbAffirmHr( pCart->SetTagAndNumber( label, 0 ));

                }

            }

            // Get the next slot
            hr = pEnumSlots->Next( IID_IRmsStorageSlot, (void **)&pSlot );
        }




        // Now process drives.



        // Read element status

        list.NumberOfElements = m_parameters.NumberDataTransferElements;
        list.Element.ElementType = ChangerDrive;
        list.Element.ElementAddress = 0;

        if ( m_parameters.Features0 & CHANGER_VOLUME_IDENTIFICATION ) tag = TRUE;

        size = sizeof(READ_ELEMENT_ADDRESS_INFO) + (list.NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS);

        WsbFree( pElementInformation );
        pElementInformation = (PREAD_ELEMENT_ADDRESS_INFO)WsbAlloc( size );
        WsbAffirmPointer(pElementInformation);
        memset(pElementInformation, 0, size);

        WsbAffirmHr( GetElementStatus( list, tag, &size, pElementInformation ));

        CComPtr<IWsbIndexedCollection> pDevices;
        CComPtr<IWsbIndexedCollection> pDrives;
        CComPtr<IRmsDrive> pDrive;
        CComPtr<IRmsDrive> pFindDrive;
        CComPtr<IRmsDevice> pFindDevice;

        WsbAffirmHr( pServer->GetUnconfiguredDevices( &pDevices ));
        WsbAffirmHr( pLib->GetDrives( &pDrives ));

        // For each drive in the element status page, find the drive in the
        // unconfigured list of devices.

        for ( i = 0; i < pElementInformation->NumberOfElements; i++ ) {

            pElementStatus = &pElementInformation->ElementStatus[i];

            WsbAssert( ChangerDrive == pElementStatus->Element.ElementType, E_UNEXPECTED );
            WsbAssert( i == pElementStatus->Element.ElementAddress, E_UNEXPECTED );

            // set up a find template
            WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER,
                               IID_IRmsDrive, (void **)&pFindDrive ));

            CComQIPtr<IRmsDevice, &IID_IRmsDevice> pFindDevice = pFindDrive;
            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pFindObject = pFindDrive;

            BYTE port=0xff, bus=0xff, id=0xff, lun=0xff;

            if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_LUN_VALID )
                lun = pElementStatus->Lun;

            if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_ID_VALID )
                id = pElementStatus->TargetId;

            if ( !(pElementStatus->Flags & (ULONG)ELEMENT_STATUS_NOT_BUS) ) {
                bus = m_bus;
                port = m_port;
            }

            WsbAffirmHr( pFindDevice->SetDeviceAddress( port, bus, id, lun ));

            WsbAffirmHr( pFindObject->SetFindBy( RmsFindByDeviceAddress ));

            // Find the drive

            hr = pDevices->Find( pFindDrive, IID_IRmsDrive, (void **)&pDrive );

            if ( S_OK == hr ) {

                // Add the drive to the library
                WsbAffirmHr( pDrives->Add( pDrive ));

                // Remove the drive form the unconfigured list
                WsbAffirmHr( pDevices->RemoveAndRelease( pDrive ));

                // Fill in more drive information
                CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDrive;

                // Is the unit of media inverted?
                invert = ( ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) &&
                         ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT )    ) ? TRUE : FALSE;
                WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, GUID_NULL, i, 0, 0, 0, invert ));

                // Is the slot Full or Empty?
                BOOL occupied = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_FULL ) ? TRUE : FALSE;
                WsbAffirmHr( pDriveElmt->SetIsOccupied( occupied ));

                // Set the media type supported
                WsbAffirmHr( pDriveElmt->SetMediaSupported( m_mediaSupported ));

                // Set the storage flag
                WsbAffirmHr( pDriveElmt->SetIsStorage( TRUE ));

                // If there is a cartridge present fill in cartridge information
                if ( occupied ) {

                    CComPtr<IRmsCartridge> pCart;

                    WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                        IID_IRmsCartridge, (void **)&pCart ));

                    WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));

                    if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) {


                        try {
                            ULONG pos;
                        
//                                pos =  pElementStatus->SourceElementAddress[1];
//                                pos |=  (pElementStatus->SourceElementAddress[0] << 8);
                            pos =  pElementStatus->SrcElementAddress.ElementAddress;


                            //
                            // TODO:  FIX THIS - This code incorrectly assumes source is a slot!!!
                            //
                            // I'll work on trying to get chuck to return element type and position 
                            // in element status page.
                            //

                            WsbAffirm( pos >= m_parameters.FirstSlotNumber, E_UNEXPECTED );

                            pos = pos - m_parameters.FirstSlotNumber;

                            BOOL invert = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT ) ? TRUE : FALSE;

                            WsbAffirmHr( pCart->SetHome( RmsElementStorage, libId, GUID_NULL, pos, 0, 0, 0, invert ));
                        }
                        WsbCatch(hr);

                    }

                    // TODO: if not ELEMENT_STATUS_SVALID we should set the home location to
                    //       some empty slot.  This handles the case where we we come up with
                    //       unknown media in a drive.


                    WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                    WsbAffirmHr( pCart->SetType( m_mediaSupported ));
                    WsbAffirmHr( pCart->SetDrive( pDrive ));

                    // Add cartridge to drive
                    WsbAffirmHr( pCarts->Add( pCart ));

                    if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_PVOLTAG ) {

                        pElementStatus->PrimaryVolumeID[32] = '\0';  // This nulls the reserved byte
                        pElementStatus->PrimaryVolumeID[33] = '\0';  // This nulls the reserved byte
                        CWsbBstrPtr label( (char *)pElementStatus->PrimaryVolumeID );

                        // Fill in external label information
                        WsbAffirmHr( pCart->SetTagAndNumber( label, 0 ));

                    }

                }

            }

        }

        // All done
        hr = S_OK;

    }
    WsbCatch(hr);

    if ( pElementInformation ) {
        WsbFree( pElementInformation );
    }

    return hr;

}


STDMETHODIMP
CRmsMediumChanger::AcquireDevice(
    void
    )
/*++

Implements:

    IRmsMediumChanger::AcquireDevice

--*/
{

    HRESULT         hr = E_FAIL;
    HANDLE          hChanger = INVALID_HANDLE_VALUE;
    CWsbBstrPtr     name;

    try {
        // Get the device name for this changer
        GetDeviceName( &name );

        // Create a handle
        hChanger = CreateFile( name,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             0,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

        WsbAffirmHandle( hChanger );

        // Save the handle
        m_handle = hChanger;

        // Do any other initialization here

        hr = S_OK;
    }
    WsbCatchAndDo( hr,
                        WsbTrace( OLESTR("\n\n !!!!! ERROR !!!!! Acquire() failed. name=<%ls>\n\n"), name );
                        if ( hChanger != INVALID_HANDLE_VALUE ) {
                            CloseHandle( hChanger );
                        } );

    return hr;

}


STDMETHODIMP
CRmsMediumChanger::ReleaseDevice(
    void
    )
/*++

Implements:

    IRmsMediumChanger::ReleaseDevice

--*/
{
    HRESULT hr = E_FAIL;

    try {

        if ( INVALID_HANDLE_VALUE != m_handle ) {

            WsbAffirmStatus( CloseHandle( m_handle ));
            m_handle = INVALID_HANDLE_VALUE;

        }
        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;

}

////////////////////////////////////////////////////////////////////////////////
//
// IRmsMoveMedia Interface
//

STDMETHODIMP
CRmsMediumChanger::GetParameters(
    IN OUT PDWORD pSize,
    OUT PGET_CHANGER_PARAMETERS pParms
    )
/*++

Implements:

    IRmsMoveMedia::GetParameters

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pParms );
        WsbAssertHandle( m_handle );

        pParms->Size = sizeof(GET_CHANGER_PARAMETERS);

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_PARAMETERS,
                         pParms,
                         sizeof(GET_CHANGER_PARAMETERS),
                         pParms,
                         sizeof(GET_CHANGER_PARAMETERS),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::GetProductData(
    IN OUT PDWORD pSize,
    OUT PCHANGER_PRODUCT_DATA pData
    )
/*++

Implements:

    IRmsMoveMedia::GetProductData

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD   dwReturn;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pData );
        WsbAssertHandle( m_handle );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_PRODUCT_DATA,
                         NULL,
                         0,
                         pData,
                         sizeof(CHANGER_PRODUCT_DATA),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::Status(
    void
    )
/*++

Implements:

    IRmsMoveMedia::Status

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_STATUS,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwReturn,
                         NULL) );
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::SetAccess(
    IN CHANGER_ELEMENT element,
    IN DWORD control
    )
/*++

Implements:

    IRmsMoveMedia::SetAccess

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SET_ACCESS setAccess;

        setAccess.Element = element;
        setAccess.Control = control;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_ACCESS,
                         &setAccess,
                         sizeof(CHANGER_SET_ACCESS),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::GetElementStatus(
    IN CHANGER_ELEMENT_LIST elementList,
    IN BOOL volumeTagInfo,
    IN OUT PDWORD pSize,
    OUT PREAD_ELEMENT_ADDRESS_INFO pElementInformation
    )
/*++

Implements:

    IRmsMoveMedia::GetElementStatus

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        DWORD requiredSize;
        CHANGER_READ_ELEMENT_STATUS readElementStatus;
        PCHANGER_ELEMENT_STATUS pElementStatus = pElementInformation->ElementStatus;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pElementInformation );

        requiredSize = elementList.NumberOfElements * sizeof( CHANGER_ELEMENT_STATUS );
        WsbAssert( *pSize >= requiredSize, E_INVALIDARG );

        readElementStatus.ElementList = elementList;
        readElementStatus.VolumeTagInfo = (BOOLEAN)( volumeTagInfo ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_ELEMENT_STATUS,
                         &readElementStatus,
                         sizeof(CHANGER_READ_ELEMENT_STATUS),
                         pElementStatus,
                         requiredSize,
                         &dwReturn,
                         NULL ));

        pElementInformation->NumberOfElements = dwReturn / sizeof( CHANGER_ELEMENT_STATUS );

        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::InitializeElementStatus(
    IN CHANGER_ELEMENT_LIST elementList,
    IN BOOL barCodeScan
    )
/*++

Implements:

    IRmsMoveMedia::InitializeElementStatus

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus;

        initElementStatus.ElementList = elementList;
        initElementStatus.BarCodeScan = (BOOLEAN)( barCodeScan ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS,
                         &initElementStatus,
                         sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS),
                         NULL,
                         0,
                         &dwReturn,
                         NULL) );
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::ExchangeMedium(
    IN CHANGER_ELEMENT source,
    IN CHANGER_ELEMENT destination1,
    IN CHANGER_ELEMENT destination2,
    IN BOOL flip1,
    IN BOOL flip2
    )
/*++

Implements:

    IRmsMoveMedia::ExchangeMedium

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_EXCHANGE_MEDIUM exchangeMedium;

        exchangeMedium.Transport.ElementType = ChangerTransport;
        exchangeMedium.Transport.ElementAddress = 0; // default arm or thumb
        exchangeMedium.Source = source;
        exchangeMedium.Destination1 = destination1;
        exchangeMedium.Destination2 = destination2;
        exchangeMedium.Flip1 = (BOOLEAN)( flip1 ? TRUE : FALSE );
        exchangeMedium.Flip2 = (BOOLEAN)( flip2 ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_EXCHANGE_MEDIUM,
                         &exchangeMedium,
                         sizeof(CHANGER_EXCHANGE_MEDIUM),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::MoveMedium(
    IN CHANGER_ELEMENT source,
    IN CHANGER_ELEMENT destination,
    IN BOOL flip
    )
/*++

Implements:

    IRmsMoveMedia::MoveMedium

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_MOVE_MEDIUM moveMedium;

        moveMedium.Transport.ElementType = ChangerTransport;
        moveMedium.Transport.ElementAddress = 0; // default arm or thumb
        moveMedium.Source = source;
        moveMedium.Destination = destination;
        moveMedium.Flip = (BOOLEAN)( flip ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_MOVE_MEDIUM,
                         &moveMedium,
                         sizeof(CHANGER_MOVE_MEDIUM),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::Position(
    IN CHANGER_ELEMENT destination,
    IN BOOL flip
    )
/*++

Implements:

    IRmsMoveMedia::Position

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SET_POSITION positon;

        positon.Transport.ElementType = ChangerTransport;
        positon.Transport.ElementAddress = 0; // default arm or thumb
        positon.Destination = destination;
        positon.Flip = (BOOLEAN)( flip ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_POSITION,
                         &positon,
                         sizeof(CHANGER_SET_POSITION),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::RezeroUnit(
    void
    )
/*++

Implements:

    IRmsMoveMedia::RezeroUnit

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_REINITIALIZE_TRANSPORT,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}


/*

HRESULT
CRmsMediumChanger::getDisplay(
    OUT PCHANGER_DISPLAY pDisplay
    )
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_DISPLAY,
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



HRESULT
CRmsMediumChanger::setDisplay(
    IN PCHANGER_DISPLAY pDisplay
    )
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_DISPLAY,
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}
*/



STDMETHODIMP
CRmsMediumChanger::QueryVolumeTag(
    IN CHANGER_ELEMENT startingElement,
    IN DWORD actionCode,
    IN PUCHAR pVolumeIDTemplate,
    OUT PDWORD pNumberOfElementsReturned,
    OUT PREAD_ELEMENT_ADDRESS_INFO pElementInformation
    )
/*++

Implements:

    IRmsMoveMedia::QueryVolumeTag

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SEND_VOLUME_TAG_INFORMATION tagInfo;

        tagInfo.StartingElement = startingElement;
        tagInfo.ActionCode = actionCode;
        memcpy( &tagInfo.VolumeIDTemplate, pVolumeIDTemplate, sizeof(MAX_VOLUME_TEMPLATE_SIZE) );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_QUERY_VOLUME_TAGS,
                         &tagInfo,
                         sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION),
                         pElementInformation,
                         sizeof(READ_ELEMENT_ADDRESS_INFO) + (pElementInformation->NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS),
                         &dwReturn,
                         NULL ));

        *pNumberOfElementsReturned = pElementInformation->NumberOfElements;

        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmschngr.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsChngr.h

Abstract:

    Declaration of the CRmsMediumChanger class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCHNGR_
#define _RMSCHNGR_

#include "resource.h"       // resource symbols

#include "RmsDvice.h"       // CRmsDevice
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsMediumChanger

Class Description:

    A CRmsMediumChanger represents the robotic or human mechanism that moves media
    between the elements of a library.  The state of in-progress move operations
    is maintained with this object to aid recovery.

--*/

class CRmsMediumChanger :
    public CComDualImpl<IRmsMediumChanger, &IID_IRmsMediumChanger, &LIBID_RMSLib>,
    public CRmsDevice,          // inherits CRmsChangerElement
    public CWsbObject,          // inherits CComObjectRoot
    public IRmsMoveMedia,
    public CComCoClass<CRmsMediumChanger,&CLSID_CRmsMediumChanger>
{
public:
    CRmsMediumChanger() {}
BEGIN_COM_MAP(CRmsMediumChanger)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsMediumChanger)
    COM_INTERFACE_ENTRY(IRmsMediumChanger)
    COM_INTERFACE_ENTRY(IRmsMoveMedia)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(IRmsDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsMediumChanger)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)( OUT USHORT *pPassed, OUT USHORT *pFailed);

// IRmsMediumChanger
public:
    STDMETHOD( Initialize )( void );

    STDMETHOD( AcquireDevice )( void );
    STDMETHOD( ReleaseDevice )( void );

    STDMETHOD( GetHome )( LONG *pType, LONG *pPos, BOOL *pInvert );
    STDMETHOD( SetHome )( LONG type, LONG pos, BOOL invert );

    STDMETHOD( SetAutomatic )( BOOL flag );
    STDMETHOD( IsAutomatic )( void );

    STDMETHOD( SetCanRotate )( BOOL flag );
    STDMETHOD( CanRotate )( void );

    STDMETHOD( GetOperation )( BSTR *pOperation );
    STDMETHOD( SetOperation )( BSTR pOperation );

    STDMETHOD( GetPercentComplete )(  BYTE *pPercent );
    STDMETHOD( SetPercentComplete )(  BYTE percent );

    STDMETHOD( TestReady )( void );

    STDMETHOD( ImportCartridge )( IRmsCartridge **pCart );
    STDMETHOD( ExportCartridge )( IRmsCartridge **pCart );
    STDMETHOD( MoveCartridge )( IN IRmsCartridge *pSrcCart, IN IUnknown *pDestElmt );
    STDMETHOD( HomeCartridge )( IN IRmsCartridge *pCart );

// IRmsMoveMedia
public:
    STDMETHOD( GetParameters )( IN OUT PDWORD pSize, OUT PGET_CHANGER_PARAMETERS pParms );
    STDMETHOD( GetProductData )( IN OUT PDWORD pSize, OUT PCHANGER_PRODUCT_DATA pData );
    STDMETHOD( RezeroUnit )( void );
    STDMETHOD( InitializeElementStatus )( IN CHANGER_ELEMENT_LIST elementList, IN BOOL barCodeScan );
    STDMETHOD( Status )( void );
    STDMETHOD( SetAccess )( IN CHANGER_ELEMENT element, IN DWORD control );
    STDMETHOD( GetElementStatus )( IN CHANGER_ELEMENT_LIST elementList,
                                   IN BOOL volumeTagInfo,
                                   IN OUT PDWORD pSize,
                                   OUT PREAD_ELEMENT_ADDRESS_INFO  pElementInformation );
    STDMETHOD( ExchangeMedium )( IN CHANGER_ELEMENT source, IN CHANGER_ELEMENT destination1,
                                    IN CHANGER_ELEMENT destination2, IN BOOL flip1, IN BOOL flip2 );
    STDMETHOD( MoveMedium )( IN CHANGER_ELEMENT source, IN CHANGER_ELEMENT destination, IN BOOL flip );
    STDMETHOD( Position )( IN CHANGER_ELEMENT destination, IN BOOL flip );
//    STDMETHOD( GetDisplay )( OUT PCHANGER_DISPLAY pDisplay );
//    STDMETHOD( SetDisplay )( IN PCHANGER_DISPLAY pDisplay );
    STDMETHOD( QueryVolumeTag )( IN CHANGER_ELEMENT startingElement, IN DWORD actionCode,
                                    IN PUCHAR pVolumeIDTemplate, OUT PDWORD pNumberOfElementsReturned,
                                    OUT PREAD_ELEMENT_ADDRESS_INFO  pElementInformation );

// CRmsServer
private:

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 64                        // Max size of the device identifier.
        };                                  //

    CRmsLocator     m_home;                 // The position to move to in response to
                                            //   to the Home operation.
    BOOL            m_isAutomatic;          // If TRUE, the changer is a robotic device.
    BOOL            m_canRotate;            // If TRUE, the changer can rotate a
                                            //   unit of media.
    CWsbBstrPtr     m_operation;            // A description of the in-progress operation.
    BYTE            m_percentComplete;      // A value between 0-100 that indicates
                                            //   what portion of the operation is complete.
    HANDLE          m_handle;               // The handle to the changer device.  This is used
                                            //   by the IRmsMoveMedia interface.
    GET_CHANGER_PARAMETERS m_parameters;   // Device specific parameters. See NT DDK.
};

#endif // _RMSCHNGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdrcls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrCls.cpp

Abstract:

    Implementation of CRmsDriveClass

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsDrCls.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsDriveClass::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDriveClass::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDriveClassId:
        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch(hr);

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsDriveClass::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsDriveClass::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_type   = RmsMediaUnknown;

        m_capability = RmsModeUnknown;

        m_idleTime = 0;

        m_mountWaitTime = 0;

        m_mountLimit = 0;

        m_queuedRequests = 0;

        m_unloadPauseTime = 0;

        m_driveSelectionPolicy = RmsDriveSelectUnknown;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::GetClassID(
    OUT CLSID  *pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDriveClass::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsDriveClass;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::GetSizeMax(
    OUT ULARGE_INTEGER  *pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;


    WsbTraceIn(OLESTR("CRmsDriveClass::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);

//        // Get maximum size
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID)   +     // m_objectId
//                             WsbPersistSizeOf(LONG)   +     // length of m_name
//                             nameLen +                      // m_name
//                             WsbPersistSizeOf(LONG)   +     // m_type
//                             WsbPersistSizeOf(LONG)   +     // m_capability
//                             WsbPersistSizeOf(LONG)   +     // m_idleTime
//                             WsbPersistSizeOf(LONG)   +     // m_mountWaitTime
//                             WsbPersistSizeOf(LONG)   +     // m_mountLimit
//                             WsbPersistSizeOf(LONG)   +     // m_queuedRequests
//                             WsbPersistSizeOf(LONG)   +     // m_unloadPauseTime
//                             WsbPersistSizeOf(LONG);        // m_driveSelectionPolicy

////                          get m_pDrives length

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Load(
    IN IStream  *pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDriveClass::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_capability = (RmsMode)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_idleTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountWaitTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountLimit));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_queuedRequests));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_unloadPauseTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_driveSelectionPolicy = (RmsDriveSelect)temp;

//      do load of m_pDrives

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Save(
    IN IStream  *pStream,
    IN BOOL     clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDriveClass::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_capability));

        WsbAffirmHr(WsbSaveToStream(pStream, m_idleTime));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mountWaitTime));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mountLimit));

        WsbAffirmHr(WsbSaveToStream(pStream, m_queuedRequests));

        WsbAffirmHr(WsbSaveToStream(pStream, m_unloadPauseTime));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_driveSelectionPolicy));

//      do load of m_pDrives


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsDriveClass> pDriveClass1;
    CComPtr<IRmsDriveClass> pDriveClass2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsDriveClass::Test"), OLESTR(""));

    try {
        // Get the DriveClass interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsDriveClass*) this)->QueryInterface(IID_IRmsDriveClass, (void**) &pDriveClass1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetType & GetType
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetType (longWork1);

                GetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetCapability & GetCapability
            for (i = RmsModeUnknown; i < RmsModeWriteOnly; i++){

                longWork1 = i;

                SetCapability (longWork1);

                GetCapability (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetIdleTime & GetIdleTime
            longWork1 = 99;

            SetIdleTime(longWork1);

            GetIdleTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMountWaitTime & GetMountWaitTime
            longWork1 = 99;

            SetMountWaitTime(longWork1);

            GetMountWaitTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMountLimit & GetMountLimit
            longWork1 = 99;

            SetMountLimit(longWork1);

            GetMountLimit(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetQueuedRequests & GetQueuedRequests
            longWork1 = 99;

            SetQueuedRequests(longWork1);

            GetQueuedRequests(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetUnloadPauseTime & GetUnloadPauseTime
            longWork1 = 99;

            SetUnloadPauseTime(longWork1);

            GetUnloadPauseTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDriveSelectionPolicy & GetDriveSelectionPolicy
            longWork1 = 99;

            SetDriveSelectionPolicy(longWork1);

            GetDriveSelectionPolicy(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsDriveClass::GetDriveClassId(
    GUID *pDriveClassId
    )
/*++

Implements:

    IRmsDriveClass::GetDriveClassId

--*/
{
    *pDriveClassId = m_objectId;
    return S_OK;
}



STDMETHODIMP
CRmsDriveClass::GetName(
    BSTR *pName
    )
/*++

Implements:

    IRmsDriveClass::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetName(
    BSTR name
    )
/*++

Implements:

    IRmsDriveClass::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetType(
    LONG *pType
    )
/*++

Implements:

    IRmsDriveClass::GetType

--*/
{
    *pType = (LONG) m_type;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetType(
    LONG type
    )
/*++

Implements:

    IRmsDriveClass::SetType

--*/
{
    m_type = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetCapability(
    LONG *pCapability
    )
/*++

Implements:

    IRmsDriveClass::GetCapability

--*/
{
    *pCapability = (LONG) m_capability;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetCapability(
    LONG capability
    )
/*++

Implements:

    IRmsDriveClass::SetCapability

--*/
{
    m_capability = (RmsMode) capability;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetIdleTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetIdleTime

--*/
{
    *pTime = m_idleTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetIdleTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetIdleTime

--*/
{
    m_idleTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetMountWaitTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetMountWaittime

--*/
{
    *pTime = m_mountWaitTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetMountWaitTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetMountWaittime

--*/
{
    m_mountWaitTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetMountLimit(
    LONG *pLim
    )
/*++

Implements:

    IRmsDriveClass::GetMountLimit

--*/
{
    *pLim = m_mountLimit;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetMountLimit(
    LONG lim
    )
/*++

Implements:

    IRmsDriveClass::SetMountLimit

--*/
{
    m_mountLimit = lim;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetQueuedRequests(
    LONG *pReqs
    )
/*++

Implements:

    IRmsDriveClass::GetQueuedRequests

--*/
{
    *pReqs = m_queuedRequests;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetQueuedRequests(
    LONG reqs
    )
/*++

Implements:

    IRmsDriveClass::SetQueuedRequests

--*/
{
    m_queuedRequests = reqs;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetUnloadPauseTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetUnloadPauseTime

--*/
{
    *pTime = m_unloadPauseTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetUnloadPauseTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetUnloadPauseTime

--*/
{
    m_unloadPauseTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetDriveSelectionPolicy(
    LONG *pPolicy
    )
/*++

Implements:

    IRmsDriveClass::GetDriveSelectionPolicy

--*/
{
    *pPolicy = (LONG) m_driveSelectionPolicy;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetDriveSelectionPolicy(
    LONG policy
    )
/*++

Implements:

    IRmsDriveClass::SetDriveSelectionPolicy

--*/
{
    m_driveSelectionPolicy = (RmsDriveSelect) policy;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetDrives(
    IWsbIndexedCollection** /*ptr*/
    )
/*++

Implements:

    IRmsDriveClass::GetDrives

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsclien.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsClien.cpp

Abstract:

    Implementation of CRmsClient

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsClien.h"

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsClient::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsClient::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsClient, &IID_IRmsClient> pClient = pCollectable;
        WsbAssertPointer( pClient );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByClassId:
            {

                CLSID   ownerClassId;

                // Get owner class Id
                WsbAffirmHr(pClient->GetOwnerClassId( &ownerClassId ) );

                if ( m_ownerClassId == ownerClassId ) {

                    // Owner ClassId matches
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByName:
            {

                CWsbBstrPtr name;
                CWsbBstrPtr password;

                // Get name
                WsbAffirmHr(pClient->GetName( &name ) );

                if ( m_Name == name ) {

                    // Names match, now try password

                    // Get password
                    WsbAffirmHr(pClient->GetPassword( &password ) );

                    if ( m_password == password ) {

                        // Passwords match
                        hr = S_OK;
                        result = 0;

                    }
                    else {
                        hr = S_FALSE;
                        result = 1;
                    }

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch(hr);

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsClient::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsClient::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize data
        m_ownerClassId = GUID_NULL;

        m_password = RMS_UNDEFINED_STRING;

        m_sizeofInfo = 0;

//      memset(m_info, 0, MaxInfo);

        m_verifierClass = GUID_NULL;

        m_portalClass = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsClient::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsClient::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsClient;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsClient::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;
//    ULONG       passwordLen;

    WsbTraceIn(OLESTR("CRmsClient::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);
//        passwordLen = SysStringByteLen(m_password);

//        // set up maximum size
//        pcbSize->QuadPart  = WsbPersistSizeOf(CLSID) +      // m_ownerClassId
//                             WsbPersistSizeOf(LONG) +       // length of m_name
//                             nameLen +                      // m_name
//                             WsbPersistSizeOf(LONG) +       // length of m_password
//                             nameLen +                      // m_password
////                           WsbPersistSizeOf(SHORT) +      // m_sizeofInfo
////                           MaxInfo +                      // m_info
//                             WsbPersistSizeOf(CLSID) +      // m_sizeofInfo
//                             WsbPersistSizeOf(CLSID);       // m_sizeofInfo


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsClient::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsClient::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_password));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofInfo));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_info));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_verifierClass));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_portalClass));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsClient::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Save value
        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbBstrToStream(pStream, m_password));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofInfo));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_info));

        WsbAffirmHr(WsbSaveToStream(pStream, m_verifierClass));

        WsbAffirmHr(WsbSaveToStream(pStream, m_portalClass));


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsClient>     pClient1;
    CComPtr<IRmsClient>     pClient2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CLSID                   clsidWork1;
    CLSID                   clsidWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;


    WsbTraceIn(OLESTR("CRmsClient::Test"), OLESTR(""));

    try {
        // Get the Client interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsClient*) this)->QueryInterface(IID_IRmsClient, (void**) &pClient1));

            // Test SetOwnerClassId & GetOwnerClassId
            clsidWork1 = CLSID_NULL;

            SetOwnerClassId(clsidWork1);

            GetOwnerClassId(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPassword & GetPassword interface
            bstrWork1 = bstrVal1;

            SetPassword(bstrWork1);

            GetPassword(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetVerifierClass & GetVerifierClass
            clsidWork1 = CLSID_NULL;

            SetVerifierClass(clsidWork1);

            GetVerifierClass(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPortalClass & GetPortalClass
            clsidWork1 = CLSID_NULL;

            SetPortalClass(clsidWork1);

            GetPortalClass(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsClient::GetOwnerClassId

--*/
{
    *pClassId = m_ownerClassId;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsClient::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetName(
    BSTR  *pName
    )
/*++

Implements:

    IRmsClient::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetName(
    BSTR    name
    )
/*++

Implements:

    IRmsClient::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetPassword(
    BSTR  *pPassword
    )
/*++

Implements:

    IRmsClient::GetPassword

--*/
{
    WsbAssertPointer (pPassword);

    m_password. CopyToBstr (pPassword);
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetPassword(
    BSTR    password
    )
/*++

Implements:

    IRmsClient::SetPassword

--*/
{
    m_password = password;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetInfo(
    UCHAR   *pInfo,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsClient::GetInfo

--*/
{
    memmove (pInfo, m_info, m_sizeofInfo);
    *pSize = m_sizeofInfo;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetInfo(
    UCHAR  *pInfo,
    SHORT   size
    )
/*++

Implements:

    IRmsClient::SetInfo

--*/
{
    memmove (m_info, pInfo, size);
    m_sizeofInfo = size;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetVerifierClass(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsClient::GetVerifierClass

--*/
{
    *pClassId = m_verifierClass;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetVerifierClass(
    CLSID   classId
    )
/*++

Implements:

    IRmsClient::GetVerifierClass

--*/
{
    m_verifierClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetPortalClass(
    CLSID    *pClassId
    )
/*++

Implements:

    IRmsClient::GetPortalClass

--*/
{
    *pClassId = m_portalClass;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetPortalClass(
    CLSID  classId
    )
/*++

Implements:

    IRmsClient::SetPortalClass

--*/
{
    m_portalClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsclien.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsClien.h

Abstract:

    Declaration of the CRmsClient class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCLIEN_
#define _RMSCLIEN_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsClient

Class Description:

    A CRmsClient represents information about a registerered
    Rms client application.

--*/

class CRmsClient :
    public CComDualImpl<IRmsClient, &IID_IRmsClient, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsClient,&CLSID_CRmsClient>
{
public:
    CRmsClient() {}
BEGIN_COM_MAP(CRmsClient)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsClient)
    COM_INTERFACE_ENTRY(IRmsClient)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsClient)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsClient
public:
    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD( GetName )( BSTR *pName );
    STDMETHOD( SetName )( BSTR name );

    STDMETHOD( GetPassword )( BSTR *pName );
    STDMETHOD( SetPassword )( BSTR name );

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetVerifierClass)(CLSID *pClassId);
    STDMETHOD(SetVerifierClass)(CLSID classId);

    STDMETHOD(GetPortalClass)(CLSID *pClassId);
    STDMETHOD(SetPortalClass)(CLSID classId);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 128,                      // Size of the application specific
                                            //   infomation buffer.  Currently
                                            //   fixed in size.
        };                                  //
    CLSID           m_ownerClassId;         // The Class ID for the client application.
    CWsbBstrPtr     m_password;             // Client password.
    SHORT           m_sizeofInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_info[MaxInfo];        // Application specific information.
    CLSID           m_verifierClass;        // The interface to the on-media
                                            //    ID verification function.
    CLSID           m_portalClass;          // The interface to a site specific import
                                            //   and export storage location
                                            //   specification dialog.

    };

#endif // _RMSCLIEN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdrcls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrCls.h

Abstract:

    Declaration of the CRmsDriveClass class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDRCLS_
#define _RMSDRCLS_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsDriveClass

Class Description:

    A CRmsDriveClass holds administrative properties associated with a drive, more
    typically a grouping of drives that are of equal performance characteristics,
    and capabilities.  These properties include current mount limits, and Cartridge
    idle time specifications that indicate when an inactive Cartridge should be
    returned to its storage location.

    By default a DriveClass object is created for each type of media supported by
    the drives in a library.  Multi-functions drives will be associated with multiple
    drive classes.

    A DriveClass maintains a collection of drives that are associated with the DriveClass.

--*/

class CRmsDriveClass :
    public CComDualImpl<IRmsDriveClass, &IID_IRmsDriveClass, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsDriveClass,&CLSID_CRmsDriveClass>
{
public:
    CRmsDriveClass() {}
BEGIN_COM_MAP(CRmsDriveClass)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsDriveClass)
    COM_INTERFACE_ENTRY(IRmsDriveClass)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsDriveClass)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsDriveClass
public:
    STDMETHOD(GetDriveClassId)(GUID *pDriveClassId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetType)(LONG *pType);
    STDMETHOD(SetType)(LONG type);

    STDMETHOD(GetCapability)(LONG *pCapability);
    STDMETHOD(SetCapability)(LONG capability);

    STDMETHOD(GetIdleTime)(LONG *pTime);
    STDMETHOD(SetIdleTime)(LONG time);

    STDMETHOD(GetMountWaitTime)(LONG *pTime);
    STDMETHOD(SetMountWaitTime)(LONG time);

    STDMETHOD(GetMountLimit)(LONG *pLim);
    STDMETHOD(SetMountLimit)(LONG lim);

    STDMETHOD(GetQueuedRequests)(LONG *pReqs);
    STDMETHOD(SetQueuedRequests)(LONG reqs);

    STDMETHOD(GetUnloadPauseTime)(LONG *pTime);
    STDMETHOD(SetUnloadPauseTime)(LONG time);

    STDMETHOD(GetDriveSelectionPolicy)(LONG *pPolicy);
    STDMETHOD(SetDriveSelectionPolicy)(LONG policy);

    STDMETHOD(GetDrives)(IWsbIndexedCollection **ptr);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    RmsMedia        m_type;                 // The type of media (only one type per
                                            //   DriveClass) supported by the
                                            //   DriveClass (see RmsMedia).
    RmsMode         m_capability;           // The capability of the drives
                                            //   associated with a DriveClass
                                            //   (see RmsMode).
    LONG            m_idleTime;             // Elapsed milliseconds before an idle
                                            //   Cartridge is returned to its storage
                                            //   location.
    LONG            m_mountWaitTime;        // Elapsed milliseconds to wait before
                                            //   timming out a mount request for
                                            //   drive in a DriveClass.
    LONG            m_mountLimit;           // The max number of parallel mount requests.
    LONG            m_queuedRequests;       // The number of outstanding requests
                                            //   for drive resources in a
                                            //   DriveClass.
    LONG            m_unloadPauseTime;      // Elapsed milliseconds to wait before
                                            //   moving a Cartridge from a drive
                                            //   associated with a DriveClass.
                                            //   This is required for dumb devices.
    RmsDriveSelect  m_driveSelectionPolicy; // The drive selection policy used
                                            //   when selecting drives associated
                                            //   with a DriveClass (see RmsDriveSelect).
    CComPtr<IWsbIndexedCollection>  m_pDrives;  // The drives associates with a DriveClass.
};

#endif // _RMSDRCLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdrive.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrive.cpp

Abstract:

    Implementation of CRmsDrive

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
#include "RmsDrive.h"
#include "RmsServr.h"

int CRmsDrive::s_InstanceCount = 0;

#define RMS_CRITICAL_SECTION 1

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsDrive::CompareTo(
    IN  IUnknown  *pCollectable,
    OUT SHORT     *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDrive::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // !!!!!
        //
        // IMPORTANT: The collectable coming in may not be a CRmsDrive if the collection
        //            is the unconfigured device list.
        //
        // !!!!!

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;

        // Every collectable should be an CRmsComObject
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
        case RmsFindByDeviceAddress:
        case RmsFindByDeviceName:
        case RmsFindByDeviceType:

            // Do CompareTo for device
            hr = CRmsDevice::CompareTo( pCollectable, &result );
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsDrive::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


STDMETHODIMP
CRmsDrive::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FinalConstruct"), OLESTR(""));

    try {
        m_bCritSecCreated = FALSE;
        m_UnloadNowEvent = NULL;
        m_UnloadedEvent = NULL;

        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_MountReference = 0;
        m_UnloadNowTime.dwHighDateTime = 0;
        m_UnloadNowTime.dwLowDateTime = 0;
        m_UnloadThreadHandle = NULL;

        WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 0));
        m_bCritSecCreated = TRUE;

        WsbAffirmHandle(m_UnloadNowEvent = CreateEvent(NULL, FALSE, FALSE, NULL));
        WsbAffirmHandle(m_UnloadedEvent = CreateEvent(NULL, TRUE, TRUE, NULL));


    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CRmsDrive::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsDrive::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::FinalRelease(void) 
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FinalRelease"), OLESTR(""));

    try {
        
        if (m_bCritSecCreated) {
            DeleteCriticalSection(&m_CriticalSection);
        }

        if (m_UnloadNowEvent) {
            CloseHandle(m_UnloadNowEvent);
        }
        if (m_UnloadedEvent) {
            CloseHandle(m_UnloadedEvent);
        }

        CWsbObject::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CRmsDrive::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsDrive::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


STDMETHODIMP
CRmsDrive::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsDrive;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsDrive::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsDrive::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Set up max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG);        // m_MountReference

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDrive::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MountReference));

        // We just reset to zero, one day we could try to reconnect to
        // the process that issued the mount...

        m_MountReference = 0;

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDrive::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_MountReference));


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsDrive>      pDrive1;
    CComPtr<IRmsDrive>      pDrive2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;



    WsbTraceIn(OLESTR("CRmsDrive::Test"), OLESTR(""));

    try {
        // Get the Drive interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsDrive*) this)->QueryInterface(IID_IRmsDrive, (void**) &pDrive1));

            // Test All of MountReference Functions
            ResetMountReference();

            GetMountReference(&longWork1);

            if(longWork1 == 0) {
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            for(i = 1; i < 20; i++){
                AddMountReference();

                GetMountReference(&longWork1);

                if(longWork1 == i){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            for(i = 19; i == 0; i--){
                ReleaseMountReference();

                GetMountReference(&longWork1);

                if(longWork1 == i){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::GetMountReference(
    OUT LONG *pRefs
    )
/*++

Implements:

    IRmsDrive::GetMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetMountReference"), OLESTR(""));

    LONG refs = -999;

    try {
        WsbAssertPointer(pRefs);

        refs = m_MountReference;
        *pRefs = refs;

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsDrive::GetMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}


STDMETHODIMP
CRmsDrive::ResetMountReference(
    void
    )
/*++

Implements:

    IRmsDrive::ResetMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ResetMountReference"), OLESTR(""));

#if RMS_CRITICAL_SECTION
    try {
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference = 0;
        m_isDirty = TRUE;

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    InterlockedExchange( &m_MountReference, 0);
    m_isDirty = TRUE;
#endif


    WsbTraceOut(OLESTR("CRmsDrive::ResetMountReference"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsDrive::AddMountReference(
    void
    )
/*++

Implements:

    IRmsDrive::AddMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::AddMountReference"), OLESTR(""));

    LONG refs = -999;

#if RMS_CRITICAL_SECTION
    try {
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference++;
        m_isDirty = TRUE;
        refs = m_MountReference;

        WsbAffirmStatus(ResetEvent(m_UnloadedEvent));

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    refs = InterlockedIncrement( &m_MountReference );
    m_isDirty = TRUE;
#endif

    WsbTraceOut(OLESTR("CRmsDrive::AddMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}


STDMETHODIMP
CRmsDrive::ReleaseMountReference(
    IN DWORD dwOptions
    )
/*++

Implements:

    IRmsDrive::ReleaseMountReference

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ReleaseMountReference"), OLESTR("<%ld>"), dwOptions);

    // We need to be sure this object doesn't go away until we're done.
    // This happens when we dismount a NTMS managed cartridge.
    CComPtr<IRmsDrive> thisDrive = this;

    LONG refs = -999;

    BOOL bUnloadNow = 
        ( (dwOptions & RMS_DISMOUNT_IMMEDIATE) || (dwOptions & RMS_DISMOUNT_DEFERRED_ONLY) ) ? TRUE : FALSE;

    try {
#if RMS_CRITICAL_SECTION
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference--;
        m_isDirty = TRUE;

        refs = m_MountReference;
#else
        refs = InterlockedDecrement( &m_MountReference );
        m_isDirty = TRUE;
#endif

        // Note:
        //  Even if the caller requests immediate dismount, if the ref count is > 0,
        //  the media is not dismounted (only the ref count is decreased).
        //  This is necessary because positive ref count means that some other component
        //  is also using the media (possible for Optical). The media must be dismounted 
        //  only when this other component is done as well.

        if (refs < 0) {
            //
            // This shouldn't happen under normal conditions... if it does,
            // we quiety reset the the reference count and try to recover.
            //
            WsbLogEvent(E_UNEXPECTED, sizeof(refs), &refs, NULL);

            InterlockedExchange( &m_MountReference, 0);
            refs = 0;

            // If we don't have a cartridge in the drive, there's no point
            // in continueing.
            WsbAffirm(S_OK == IsOccupied(), E_ABORT);
        }

        if (0 == refs) {

            //
            // Deferred Dismount Logic:  We wait the specified time before
            // dismounting the media.  Each dismount request resets the dismount
            // now time.  As long as the media is actively used, it will not be
            // dismounted.
            //

            // Retrieve the DeferredDismountWaitTime parameter

            DWORD size;
            OLECHAR tmpString[256];
            DWORD waitTime = RMS_DEFAULT_DISMOUNT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DISMOUNT_WAIT_TIME, tmpString, 256, &size))) {
                waitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("DismountWaitTime is %d milliseconds.\n"), waitTime);
            }

            if (waitTime > 0 && !bUnloadNow) {

                // convert waitTime to 100-nanosecond units
                waitTime *= 10000;

                FILETIME now;
                GetSystemTimeAsFileTime(&now);

                ULARGE_INTEGER time;

                time.LowPart = now.dwLowDateTime;
                time.HighPart = now.dwHighDateTime;

                time.QuadPart += waitTime;

                m_UnloadNowTime.dwLowDateTime = time.LowPart;
                m_UnloadNowTime.dwHighDateTime = time.HighPart;

                WsbTrace(OLESTR("Target Unload Time = <%ls>\n"),
                    WsbQuickString(WsbFiletimeAsString(FALSE, m_UnloadNowTime)));

                // If we already have an active unload thread we skip this step.
                if (!m_UnloadThreadHandle) {

                    //
                    // Create a thread to wait for dismount
                    //

                    WsbTrace(OLESTR("Starting thread for deferred dismount.\n"));
                    DWORD threadId;
                    WsbAffirmHandle(m_UnloadThreadHandle = CreateThread(NULL, 1024, CRmsDrive::StartUnloadThread, this, 0, &threadId));
                    CloseHandle(m_UnloadThreadHandle);
                }
            }
            else {

                // Dismount the media now

                // Double check that we still have something to dismount

                if (S_OK == IsOccupied()) {

                    // Best effort - home
                    // Fixed drives are always occupied and we shouldn't call Home for their cartridge

                    FlushBuffers();
                    if (RmsDeviceFixedDisk != m_deviceType) {
                        if (S_OK == m_pCartridge->Home(dwOptions)) {
                            SetIsOccupied(FALSE);
                        }
                    }

                }

                // set event that blocks immediate unload
                SetEvent(m_UnloadedEvent);
            }
        }

#if RMS_CRITICAL_SECTION
        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatchAndDo(hr,
            WsbAffirmHr(Unlock());
            // >>>>> LEAVE SINGLE THREADED SECTION
        );
#else
    } WsbCatch(hr)
#endif

    WsbTraceOut(OLESTR("CRmsDrive::ReleaseMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}



STDMETHODIMP
CRmsDrive::SelectForMount(
    void
    )
/*++

Implements:

    IRmsDrive::SelectForMount

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::SelectForMount"), OLESTR(""));

#if RMS_CRITICAL_SECTION
    try {

        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        if (!m_MountReference) {

            m_MountReference++;
            m_isDirty = TRUE;

        } else {
            hr = RMS_E_DRIVE_BUSY;
        }

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    LONG one = 1;
    LONG zero = 0;

    LONG flag = InterlockedCompareExchange( &m_MountReference, one, zero );

    hr = ( flag > 0 ) ? RMS_E_DRIVE_BUSY : S_OK;
#endif

    WsbTraceOut(OLESTR("CRmsDrive::SelectForMount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsDrive::CreateDataMover(
    IDataMover **ptr)
/*++

Implements:

    IRmsDrive::CreateDataMover

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::CreateDataMover"), OLESTR(""));

    try {
        WsbAssertPointer(ptr);

        if (m_isOccupied) {

            switch (m_mediaSupported) {

            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                {
                    //
                    // Create a tape style data mover to the drive
                    //

                    WsbAssertHr(CoCreateInstance(CLSID_CNtTapeIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)ptr));

                }
                break;

            case RmsMediaWORM:
                break;

            case RmsMediaOptical:
            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaDisk:
            case RmsMediaFixed:
                {
                    //
                    // Create a file style data mover to the drive
                    //

                    WsbAssertHr(CoCreateInstance(CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)ptr));

                }
                break;
            default:
                WsbThrow(E_UNEXPECTED);
                break;
            }
        }
        else {
            WsbThrow(RMS_E_RESOURCE_UNAVAILABLE);
        }

        // Initialize the data mover
        WsbAffirmHr((*ptr)->SetDeviceName(m_deviceName));
        WsbAffirmHr((*ptr)->SetCartridge(m_pCartridge));

        // Update stroage info for this cartridge.
        // 
        // IMPORTANT NOTE:  This also needs to touch the physical device
        //                  to make sure the device is ready for I/O.
        //                  If we get device errors here, we must fail the
        //                  mount.

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;

        // marking the FreeSpace to -1 gaurantees it's stale for the
        // following GetLargestFreeSpace() call.
        WsbAffirmHr(pInfo->SetFreeSpace(-1));
        hr = (*ptr)->GetLargestFreeSpace(NULL, NULL);
        if (MVR_E_UNRECOGNIZED_VOLUME == hr) {
            // This is expected if this is an unformatted optical media
            hr = S_OK;
        }
        WsbAffirmHr(hr);

        WsbAssertHrOk(hr);

/*

        Tracking DataMovers is only partially implemented.


        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        CComPtr<IWsbIndexedCollection> pDataMovers;
        WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));
        WsbAffirmHr(pDataMovers->Add((IDataMover *)(*ptr)));
*/

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::CreateDataMover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}


STDMETHODIMP
CRmsDrive::ReleaseDataMover(
    IN IDataMover *ptr)
/*++

Implements:

    IRmsDrive::ReleaseDataMover

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ReleaseDataMover"), OLESTR(""));

    try {
        WsbAssertPointer(ptr);
        WsbThrow(E_NOTIMPL);

/*

        Tracking DataMovers is only partially implemented.


        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        CComPtr<IWsbIndexedCollection>  pDataMovers;
        WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));

        WsbAffirmHr(pDataMovers->RemoveAndRelease((IDataMover *)ptr));

        ULONG activeDataMovers;
        WsbAffirmHr(pDataMovers->GetEntries( &activeDataMovers));
        WsbTrace(OLESTR("activeDataMovers = <%u>\n"), activeDataMovers);
*/

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::ReleaseDataMover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}

STDMETHODIMP
CRmsDrive::Eject(
    void
    )
/*++

Implements:

    IRmsDrive::Eject

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsDrive::Eject"), OLESTR(""));

    HANDLE hDrive = INVALID_HANDLE_VALUE;

    try {

        CWsbBstrPtr drive = "";

        switch ( m_mediaSupported ) {

        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:

            drive = m_deviceName;
            break;

        case RmsMediaWORM:
            break;

        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaCDR:
        case RmsMediaDVD:
        case RmsMediaDisk:
        case RmsMediaFixed:

            // TODO: permanently remove trailing \ from device name ????
            WsbAffirmHr(drive.Realloc(2));
            wcsncpy(drive, m_deviceName, 2);
            drive.Prepend( OLESTR( "\\\\.\\" ) );
            break;

        }

        int retry = 0;

        do {

            hDrive = CreateFile( drive,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 0,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                                 );

            if ( INVALID_HANDLE_VALUE == hDrive )
                Sleep(2000);
            else
                break;

        } while ( retry++ < 10 );

        WsbAssertHandle( hDrive );

        DWORD dwReturn;

        WsbAffirmHr(PrepareTape(hDrive, TAPE_UNLOAD, FALSE));
        WsbAffirmHr(PrepareTape(hDrive, TAPE_UNLOCK, FALSE));

        WsbAssertStatus( DeviceIoControl( hDrive,
                                          IOCTL_STORAGE_EJECT_MEDIA,
                                          NULL,
                                          0,
                                          NULL,
                                          0,
                                          &dwReturn,
                                          NULL ));

        WsbAssertStatus( CloseHandle( hDrive ) );

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
                        if ( INVALID_HANDLE_VALUE != hDrive )
                            CloseHandle( hDrive );
                 );

    WsbTraceOut(OLESTR("CRmsDrive::Eject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}


STDMETHODIMP
CRmsDrive::GetLargestFreeSpace(
    LONGLONG *pFreeSpace,
    LONGLONG *pCapacity
    )
/*++

Implements:

    IRmsDrive::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetLargestFreeSpace"), OLESTR(""));

    try {

        CComPtr<IDataMover> pDataMover;

        WsbAffirmHr(CreateDataMover(&pDataMover));
        WsbAffirmHr(pDataMover->GetLargestFreeSpace(pFreeSpace, pCapacity));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetLargestFreeSpace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::UnloadNow(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::UnloadNow"), OLESTR(""));

    try {

        WsbAffirmHr(Lock());

        WsbAffirmStatus(SetEvent(m_UnloadNowEvent));

        WsbAffirmHr(Unlock());

        switch(WaitForSingleObject(m_UnloadedEvent, INFINITE)) {
        case WAIT_FAILED:
            hr = HRESULT_FROM_WIN32(GetLastError());
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Wait for Single Object returned error: %ls\n"),
                WsbHrAsString(hr));
            WsbAffirmHr(hr);
            break;
        case WAIT_TIMEOUT:
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Awakened by timeout.\n"));
            break;
        default:
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Awakened by external signal.\n"));
            GetSystemTimeAsFileTime(&m_UnloadNowTime);
            break;
                }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsDrive::UnloadNow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



DWORD WINAPI
CRmsDrive::StartUnloadThread(
    IN LPVOID pv)
{
    return(((CRmsDrive*) pv)->Unload());
}


HRESULT
CRmsDrive::Unload(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unload"), OLESTR(""));

    // We need to be sure this object doesn't go away until we're done.
    // This happens when we dismount a NTMS managed cartridge.
    CComPtr<IRmsDrive> thisDrive = this;

    try {

        BOOL waiting = TRUE;
        LARGE_INTEGER delta = {0,0};

        while (waiting) {

            //
            // !!!!! VERY IMPORTANT !!!!
            //
            // no 'break' in this loop, we're entering
            // a critical section!
            //

#if RMS_CRITICAL_SECTION
            // <<<<< ENTER SINGLE THREADED SECTION
            WsbAffirmHr(Lock());
#endif
            WsbTrace(OLESTR("Refs = %d\n"), m_MountReference);

            if (0 == m_MountReference) {

                FILETIME now;
                GetSystemTimeAsFileTime(&now);


                ULARGE_INTEGER time0;
                ULARGE_INTEGER time1;
            
                time0.LowPart = m_UnloadNowTime.dwLowDateTime;
                time0.HighPart = m_UnloadNowTime.dwHighDateTime;

                time1.LowPart = now.dwLowDateTime;
                time1.HighPart = now.dwHighDateTime;


                // time0 is the target time for dismount.
                // When delta goes negative, we've expired our
                // wait time.
                delta.QuadPart = time0.QuadPart-time1.QuadPart;

                // convert delta to 100-ns to milliseconds
                delta.QuadPart /= 10000;

                WsbTrace(OLESTR("Time = <%ls>; Unload Time = <%ls>; delta = %I64d (ms)\n"),
                    WsbQuickString(WsbFiletimeAsString(FALSE, now)),
                    WsbQuickString(WsbFiletimeAsString(FALSE, m_UnloadNowTime)),
                    delta.QuadPart);

                if (delta.QuadPart <= 0) {

                    // Dismount wait time has expired

                    // Double check that we still have something to dismount

                    if (S_OK == IsOccupied()) {

                        // Best effort home
                        // Fixed drives are always occupied and we shouldn't call Home for their cartridge

                        FlushBuffers();
                        if (RmsDeviceFixedDisk != m_deviceType) {
                            if (S_OK == m_pCartridge->Home()) {
                                SetIsOccupied(FALSE);
                            }
                        }

                    }

                    m_UnloadThreadHandle = NULL;
                    waiting = FALSE;

                    SetEvent(m_UnloadedEvent);

                }
            }
            else {
                hr = S_FALSE;

                m_UnloadThreadHandle = NULL;
                waiting = FALSE;
            }

#if RMS_CRITICAL_SECTION
            WsbAffirmHr(Unlock());
            // >>>>> LEAVE SINGLE THREADED SECTION
#endif

            if ( waiting ) {

                switch(WaitForSingleObject(m_UnloadNowEvent, delta.LowPart)) {
                case WAIT_FAILED:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Wait for Single Object returned error: %ls\n"),
                        WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
                    break;
                case WAIT_TIMEOUT:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Awakened by timeout.\n"));
                    break;
                default:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Awakened by external signal.\n"));
                    GetSystemTimeAsFileTime(&m_UnloadNowTime);
                    break;
                }
            }

        } // waiting


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::FlushBuffers( void )
/*++

Implements:

    IRmsDrive::FlushBuffers

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FlushBuffers"), OLESTR("Device=<%ls>"), (WCHAR *) m_deviceName);

    HANDLE hDrive = INVALID_HANDLE_VALUE;

    try {

        // First flush system buffers

        switch (m_mediaSupported) {

        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
        case RmsMediaWORM:
            break;

        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaCDR:
        case RmsMediaDVD:
        case RmsMediaDisk:
            // No need to flush for Optical media - RSM should flush the system buffers before dismounting
            break;

        case RmsMediaFixed:
            {
                // This is special code to flush the file system buffers.

                // Create an exclusive handle
                CWsbStringPtr drive;
                WsbAffirmHr(drive.Alloc(10));
                wcsncat( drive, m_deviceName, 2 );
                drive.Prepend( OLESTR( "\\\\.\\" ) );

                hDrive = CreateFile( drive,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     0,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                     );
                WsbAffirmHandle(hDrive);

                // Flush buffers
                WsbAffirmStatus(FlushFileBuffers(hDrive));

                CloseHandle(hDrive);
                hDrive = INVALID_HANDLE_VALUE;
            }                                              
            break;

        }

    } WsbCatchAndDo(hr,
            if (INVALID_HANDLE_VALUE != hDrive) {
                CloseHandle(hDrive);
            }
        );

    WsbTraceOut(OLESTR("CRmsDrive::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::Lock( void )
/*++

Implements:

    IRmsDrive::Lock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Lock"), OLESTR(""));

    EnterCriticalSection(&m_CriticalSection);

    WsbTraceOut(OLESTR("CRmsDrive::Lock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::Unlock( void )
/*++

Implements:

    IRmsDrive::Unlock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unlock"), OLESTR(""));

    LeaveCriticalSection(&m_CriticalSection);

    WsbTraceOut(OLESTR("CRmsDrive::Unlock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdrive.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrive.h

Abstract:

    Declaration of the CRmsDrive class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDRIVE_
#define _RMSDRIVE_

#include "resource.h"       // resource symbols

#include "RmsDvice.h"       // CRmsDevice

/*++

Class Name:

    CRmsDrive

Class Description:

    A CRmsDrive represents a specific data transfer device: a disk, tape,
    or optical drive.

    Each drive is member of at least one DriveClass.  The DriveClass contains
    additional properties that are associated with a Drive (See CRmsDriveClass).

--*/

class CRmsDrive :
    public CComDualImpl<IRmsDrive, &IID_IRmsDrive, &LIBID_RMSLib>,
    public CRmsDevice,          // inherits CRmsChangerElement
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsDrive,&CLSID_CRmsDrive>
{
public:
    CRmsDrive() {}
BEGIN_COM_MAP(CRmsDrive)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsDrive)
    COM_INTERFACE_ENTRY(IRmsDrive)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(IRmsDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsDrive)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsDrive
public:
    STDMETHOD(GetMountReference)( OUT LONG *pRefs );
    STDMETHOD(ResetMountReference)();
    STDMETHOD(SelectForMount)();
    STDMETHOD(AddMountReference)();
    STDMETHOD(ReleaseMountReference)(IN DWORD dwOptions = RMS_NONE);

    STDMETHOD(CreateDataMover)( OUT IDataMover **ptr );
    STDMETHOD(ReleaseDataMover)( IN IDataMover *ptr );

    STDMETHOD(Eject)(void);

    STDMETHOD(GetLargestFreeSpace)( OUT LONGLONG *freeSpace, OUT LONGLONG *capacity );

    STDMETHOD(UnloadNow)(void);

// CRmsDrive member functions
public:
    HRESULT FlushBuffers(void);
    HRESULT Unload(void);

private:

    enum {                              // Class specific constants:
                                        //
        Version = 1,                    // Class version, this should be
                                        //   incremented each time the
                                        //   the class definition changes.
        };                              //
    LONG            m_MountReference;   // A reference count for the number
                                        //   concurrent mounts for the mounted
                                        //   Cartridge.  When zero the Cartridge
                                        //   can be safely returned to it's
                                        //   storage location.

    FILETIME        m_UnloadNowTime;    // Indicates the time when the media
                                        //   should be dismounted.

    HANDLE          m_UnloadNowEvent;   // When signal the drive will unload immediately.
    HANDLE          m_UnloadedEvent;    // When signal the drive has been unloaded.

    HANDLE          m_UnloadThreadHandle; // The thread handle to the thread that unloads the drive.

    CRITICAL_SECTION m_CriticalSection; // Object sychronization support
    BOOL             m_bCritSecCreated; // Indicates whether all CritSec were created successfully (for cleanup)

    static int      s_InstanceCount;    // Counter of the number of object instances.

    HRESULT Lock(void);
    HRESULT Unlock(void);


// Thread routines
public:
    static DWORD WINAPI StartUnloadThread(IN LPVOID pv);

};

#endif // _RMSDRIVE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdvice.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDvice.cpp

Abstract:

    Implementation of CRmsDevice

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsDvice.h"

/////////////////////////////////////////////////////////////////////////////
//
// IRmsDevice implementation
//


CRmsDevice::CRmsDevice(
    void
    )
/*++

Routine Description:

    CRmsDevice constructor

Arguments:

    None

Return Value:

    None

--*/
{

    // Initialize values
    m_deviceName = RMS_UNDEFINED_STRING;

    m_deviceType = RmsDeviceUnknown;

    m_sizeofDeviceInfo = 0;

    memset(m_deviceInfo, 0, MaxInfo);

    m_port = 0xff;

    m_bus = 0xff;

    m_targetId = 0xff;

    m_lun = 0xff;

}


HRESULT
CRmsDevice::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsDevice::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDevice::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pCollectable;
        WsbAssertPointer( pDevice );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
            {
                //
                // What we really want to do here is compare by
                // a unique device identifier like a serial number.
                //
                // However, since we don't have a serial number for
                // all devices, we'll compare using a best effort
                // strategy using for following criteria:
                //
                // 1) DeviceName, this is unique for fixed drives and
                //    floppy drives, and SCSI devices, but may not
                //    survive accross reboot, and may not be the same
                //    for a device if it's SCSI address is changed.
                //
                //    NOTE: We can't tell if the address was changed
                //          a device.
                //
                //    NOTE: We can't tell if the drive letter was
                //          changed for a fixed drive.
                //
                //  TODO: Add serial number support.
                //

                CWsbBstrPtr name;

                // Get the target device name
                pDevice->GetDeviceName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_deviceName, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByDeviceAddress:
            {

                BYTE port, bus, targetId, lun;

                // Get the target device address
                pDevice->GetDeviceAddress(&port, &bus, &targetId, &lun);

                if( (m_port == port) &&
                    (m_bus  == bus) &&
                    (m_targetId   == targetId) &&
                    (m_lun  == lun)                 ) {

                    // Device addresses match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByDeviceName:
            {

                CWsbBstrPtr name;

                // Get the target device name
                pDevice->GetDeviceName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_deviceName, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByDeviceType:
            {

                RmsDevice type;

                // Get the target device name
                pDevice->GetDeviceType( (LONG *) &type );

                if ( m_deviceType == type ) {

                    // Device types match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        default:

            //
            // Since devices aren't CWsbCollectables, we should
            // never come here.  CRmsDrive, or CRmsChanger will
            // handle the default case.
            //

            WsbAssertHr( E_UNEXPECTED );
            break;
        }

    }
    WsbCatch(hr);

    if (0 != pResult) {
       *pResult = result;
    }

    WsbTraceOut(OLESTR("CRmsDevice::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CRmsDevice::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       deviceNameLen;

    WsbTraceIn(OLESTR("CRmsDevice::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        deviceNameLen = SysStringByteLen(m_deviceName);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // length of m_deviceName
//                             deviceNameLen           +      // m_deviceName
//                             WsbPersistSizeOf(LONG)  +      // m_deviceType
//                             WsbPersistSizeOf(SHORT) +      // m_sizeOfDeviceInfo
//                             MaxInfo                 +      // m_deviceInfo
//                             WsbPersistSizeOf(BYTE)  +      // m_port
//                             WsbPersistSizeOf(BYTE)  +      // m_bus
//                             WsbPersistSizeOf(BYTE)  +      // m_targetId
//                             WsbPersistSizeOf(BYTE);        // m_lun

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsDevice::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDevice::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        m_deviceName.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_deviceName));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_deviceType = (RmsDevice)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofDeviceInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &(m_deviceInfo [0]), MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_port));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bus));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_targetId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_lun));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsDevice::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDevice::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbBstrToStream(pStream, m_deviceName));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_deviceType));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofDeviceInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &(m_deviceInfo [0]), MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_port));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bus));

        WsbAffirmHr(WsbSaveToStream(pStream, m_targetId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_lun));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsDevice::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    passfail = TRUE;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    SHORT                   ucharLenVal1 = 10;
    UCHAR                   ucharVal1[MaxInfo] = {1,2,3,4,5,6,7,8,9,10};

    SHORT                   ucharLenWork1;
    UCHAR                   ucharWork1[MaxInfo];

    BYTE                    byteVal1 = 1;
    BYTE                    byteVal2 = 2;
    BYTE                    byteVal3 = 3;
    BYTE                    byteVal4 = 4;

    BYTE                    byteWork1;
    BYTE                    byteWork2;
    BYTE                    byteWork3;
    BYTE                    byteWork4;


    WsbTraceIn(OLESTR("CRmsDevice::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetDeviceName & GetDeviceName interface
            bstrWork1 = bstrVal1;

            SetDeviceName(bstrWork1);

            GetDeviceName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDeviceInfo & GetDeviceInfo interface
            SetDeviceInfo(ucharVal1, ucharLenVal1);

            GetDeviceInfo(ucharWork1, &ucharLenWork1);

            if (ucharLenVal1 == ucharLenWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            passfail = TRUE;

            for(i = 0; i < ucharLenVal1; i++){
                if(ucharVal1[i] != ucharWork1[i]){
                    passfail = FALSE;
                    break;
                }
            }

            if (passfail == TRUE){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDeviceAddress & GetDeviceAddress
            SetDeviceAddress(byteVal1, byteVal2, byteVal3, byteVal4);

            GetDeviceAddress(&byteWork1, &byteWork2, &byteWork3, &byteWork4);

            if ((byteVal1 == byteWork1) &&
                (byteVal2 == byteWork2) &&
                (byteVal3 == byteWork3) &&
                (byteVal4 == byteWork4)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDevice::GetDeviceName(
    BSTR *pName
    )
/*++

Implements:

    IRmsDevice::GetDeviceName

--*/
{
    WsbAssertPointer (pName);

    m_deviceName. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceName(
    BSTR name
    )
/*++

Implements:

    IRmsDevice::SetDeviceName

--*/
{
    m_deviceName = name;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceType(
    LONG *pType
    )
/*++

Implements:

    IRmsDevice::GetDeviceType

--*/
{
    *pType = m_deviceType;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceType(
    LONG type
    )
/*++

Implements:

    IRmsDevice::SetDeviceType

--*/
{
    m_deviceType = (RmsDevice)type;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceInfo(
    UCHAR   *pId,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsDevice::GetDeviceInfo

--*/
{
    memmove (pId, m_deviceInfo, m_sizeofDeviceInfo);
    *pSize = m_sizeofDeviceInfo;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceInfo(
    UCHAR   *pId,
    SHORT   size
    )
/*++

Implements:

    IRmsDevice::SetDeviceInfo

--*/
{
    memmove (m_deviceInfo, pId, size);
    m_sizeofDeviceInfo = size;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceAddress(
    LPBYTE  pPort,
    LPBYTE  pBus,
    LPBYTE  pId,
    LPBYTE  pLun
    )
/*++

Implements:

    IRmsDevice::GetDeviceAddress

--*/
{
    *pPort = m_port;
    *pBus  = m_bus;
    *pId   = m_targetId;
    *pLun  = m_lun;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceAddress(
    BYTE    port,
    BYTE    bus,
    BYTE    id,
    BYTE    lun
    )
/*++

Implements:

    IRmsDevice::SetDeviceAddress

--*/
{
    m_port          = port;
    m_bus           = bus;
    m_targetId      = id;
    m_lun           = lun;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmslibry.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLibry.cpp

Abstract:

    Implementation of CRmsLibrary

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsLibry.h"
#include "RmsServr.h"

//////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRmsLibrary::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsLibrary::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsLibrary interface to get the value of the object.
        CComQIPtr<IRmsLibrary, &IID_IRmsLibrary> pLibrary = pCollectable;
        WsbAssertPointer( pLibrary );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                // Get the target device name
                pLibrary->GetName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr(pLibrary->GetMediaSupported((LONG*) &mediaSupported));

                if( m_mediaSupported == mediaSupported ){

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else{

                    hr = S_FALSE;
                    result = 1;

                }

            }
            break;

        case RmsFindByDeviceInfo:
            {

                //
                // We're looking for a device in a library.
                // The template has one changer device OR one drive device.
                //

                try {

                    WsbAssertHr( E_UNEXPECTED );  // Dead code now

                    if ( m_maxDrives > 0 ) {

                        CComPtr<IWsbEnum>               pEnumDrives;

                        CComPtr<IWsbIndexedCollection>  pFindDrives;
                        CComPtr<IRmsMediumChanger>      pFindDrive;
                        CComPtr<IWsbIndexedCollection>  pDrives;

                        WsbAffirmHr( pLibrary->GetDrives( &pDrives ) );
                        WsbAssertPointer( pDrives );

                        WsbAffirmHr( m_pDrives->Enum( &pEnumDrives ) );
                        WsbAssertPointer( pEnumDrives );
                        WsbAssertHr( pEnumDrives->First( IID_IRmsDrive, (void **)&pFindDrive ) );
                        WsbAssertPointer( pFindDrive );
                        hr = pDrives->Contains( pFindDrive );
                        result = (SHORT) ( ( S_OK == hr ) ? 0 : 1 );

                    }
                    else if ( m_maxChangers > 0 ) {

                        CComPtr<IWsbEnum>               pEnumChangers;

                        CComPtr<IWsbIndexedCollection>  pFindChangers;
                        CComPtr<IRmsMediumChanger>      pFindChanger;
                        CComPtr<IWsbIndexedCollection>  pChangers;

                        WsbAffirmHr( pLibrary->GetChangers( &pChangers ) );
                        WsbAssertPointer( pChangers );

                        WsbAffirmHr( m_pChangers->Enum( &pEnumChangers ) );
                        WsbAssertPointer( pEnumChangers );
                        WsbAssertHr( pEnumChangers->First( IID_IRmsMediumChanger, (void **)&pFindChanger ) );
                        WsbAssertPointer( pFindChanger );
                        hr = pChangers->Contains( pFindChanger );
                        result = (SHORT)( ( S_OK == hr ) ? 0 : 1 );

                    }
                    else {

                        // has to be one or the other
                        WsbAssertHr( E_UNEXPECTED );

                    }

                }
                WsbCatch( hr );

            }
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsLibrary::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsLibrary::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        m_mediaSupported = RmsMediaUnknown;

        m_maxChangers = 0;

        m_maxDrives = 0;

        m_maxPorts = 0;

        m_maxSlots = 0;

        m_NumUsedSlots = 0;

        m_NumStagingSlots = 0;

        m_NumScratchCarts = 0;

        m_NumUnknownCarts = 0;

        m_isMagazineSupported = FALSE;

        m_maxCleaningMounts = 0;

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pChangers ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDriveClasses ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDrives ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pStorageSlots ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pStagingSlots ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pPorts ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pCleaningCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pScratchCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pMediaSets ));


    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsLibrary::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsLibrary;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsLibrary::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;

    WsbTraceIn(OLESTR("CRmsLibrary::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        nameLen = SysStringByteLen(m_name);

//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID) +       // m_objectId
//                             WsbPersistSizeOf(LONG) +       // m_name length
//                             nameLen +                      // m_name data
//                             WsbPersistSizeOf(LONG) +       // m_mediaSupported
//                             WsbPersistSizeOf(LONG) +       // m_maxChangers
//                             WsbPersistSizeOf(LONG) +       // m_maxDrives
//                             WsbPersistSizeOf(LONG) +       // m_maxPorts
//                             WsbPersistSizeOf(LONG) +       // m_maxSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumUsedSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumStagingSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumScratchCarts
//                             WsbPersistSizeOf(LONG) +       // m_NumUnknownCarts
//                             WsbPersistSizeOf(LONG) +       // m_isMagazineSupported
//                             WsbPersistSizeOf(LONG) +       // m_maxCleaningMounts
//                             WsbPersistSizeOf(LONG);        // m_slotSelectionPolicy

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsLibrary::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::Load"), OLESTR(""));

    try {
        CComPtr<IPersistStream>   pPersistStream;
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_mediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxChangers));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxDrives));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxPorts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumUsedSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumStagingSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumScratchCarts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumUnknownCarts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isMagazineSupported));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxCleaningMounts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_slotSelectionPolicy = (RmsSlotSelect)temp;

        WsbAffirmHr(m_pChangers->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pDriveClasses->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pDrives->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pStorageSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pStagingSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pPorts->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pCleaningCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pScratchCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        GUID mediaSetId;
        CComPtr<IRmsMediaSet> pMediaSet;

        WsbAffirmHr( WsbLoadFromStream(pStream, &mediaSetId) );

        while ( 0 != memcmp(&GUID_NULL, &mediaSetId, sizeof(GUID))) {
            hr = pServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **)&pMediaSet );
            if (S_OK == hr) {

                WsbAffirmHr( m_pMediaSets->Add( pMediaSet ) );

            } else if (RMS_E_NOT_FOUND == hr) {
                WsbThrow(hr);
            } else {
                WsbThrow(hr);
            }
            WsbAffirmHr( WsbLoadFromStream(pStream, &mediaSetId) );
        }

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsLibrary::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        CComPtr<IPersistStream>   pPersistStream;

        WsbAssertPointer( pStream );

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_mediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxChangers));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxDrives));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxPorts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumUsedSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumStagingSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumScratchCarts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumUnknownCarts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isMagazineSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxCleaningMounts));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_slotSelectionPolicy));

        WsbAffirmHr(m_pChangers->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pDriveClasses->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pDrives->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pStorageSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pStagingSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pPorts->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pCleaningCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pScratchCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Save the ID (GUID) for the media sets.
        GUID objectId;
        CComPtr<IRmsComObject> pMediaSet;
        CComPtr<IWsbEnum> pEnum;

        WsbAffirmHr( m_pMediaSets->Enum( &pEnum ) );

        hr = pEnum->First( IID_IRmsComObject, (void **)&pMediaSet );
        while ( S_OK == hr ) {

            WsbAffirmHr( pMediaSet->GetObjectId( &objectId ) );
            WsbAffirmHr( WsbSaveToStream(pStream, objectId) );
            pMediaSet = 0;

            hr = pEnum->Next( IID_IRmsComObject, (void **)&pMediaSet );
        }

        objectId = GUID_NULL;
        WsbAffirmHr( WsbSaveToStream(pStream, objectId) );  // This marks the last one!

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsLibrary::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsLibrary>    pLibrary1;
    CComPtr<IRmsLibrary>    pLibrary2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsLibrary::Test"), OLESTR(""));

    try {
        // Get the Library interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsLibrary*) this)->QueryInterface(IID_IRmsLibrary, (void**) &pLibrary1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = 0; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetMaxChangers & GetMaxChangers
            longWork1 = 99;

            SetMaxChangers(longWork1);

            GetMaxChangers(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxDrives & GetMaxDrives
            longWork1 = 99;

            SetMaxDrives(longWork1);

            GetMaxDrives(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxPorts & GetMaxPorts
            longWork1 = 99;

            SetMaxPorts(longWork1);

            GetMaxPorts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxSlots & GetMaxSlots
            longWork1 = 99;

            SetMaxSlots(longWork1);

            GetMaxSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test GetNumUsedSlots
            m_NumUsedSlots = 99;
            longWork1 = m_NumUsedSlots;

            GetNumUsedSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumStagingSlots & GetNumStagingSlots
            longWork1 = 99;

            SetNumStagingSlots(longWork1);

            GetNumStagingSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumScratchCarts & GetNumScratchCarts
            longWork1 = 99;

            SetNumScratchCarts(longWork1);

            GetNumScratchCarts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumUnknownCarts & GetNumUnknownCarts
            longWork1 = 99;

            SetNumUnknownCarts(longWork1);

            GetNumUnknownCarts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsMagazineSupported & IsMagazineSupported to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsMagazineSupported (TRUE));
                WsbAffirmHr(IsMagazineSupported ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsMagazineSupported & IsMagazineSupported to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsMagazineSupported (FALSE));
                WsbAffirmHr(IsMagazineSupported ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetMaxCleaningMounts & GetMaxCleaningMounts
            longWork1 = 99;

            SetMaxCleaningMounts(longWork1);

            GetMaxCleaningMounts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetSlotSelectionPolicy & GetSlotSelectionPolicy
            for (i = RmsSlotSelectUnknown; i < RmsSlotSelectSortLabel; i++){

                longWork1 = i;

                SetSlotSelectionPolicy (longWork1);

                GetSlotSelectionPolicy (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }


        } WsbCatch(hr);


        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// IRmsLibrary
//


STDMETHODIMP
CRmsLibrary::GetLibraryId(
    GUID    *pLibraryId
    )
/*++

Implements:

    IRmsLibrary::GetLibraryId

--*/
{
    *pLibraryId = m_objectId;
    return (S_OK);
}


STDMETHODIMP
CRmsLibrary::SetLibraryId(
    GUID    objectId
    )
/*++

Implements:

    IRmsLibrary::SetLibraryId

--*/
{
    m_objectId = objectId;
    m_isDirty = TRUE;
    return (S_OK);
}


STDMETHODIMP
CRmsLibrary::GetName(
    BSTR *pName
    )
/*++

Implements:

    IRmsLibrary::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetName(
    BSTR name
    )
/*++

Implements:

    IRmsLibrary::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMediaSupported(
    LONG    *pType
    )
/*++

Implements:

    IRmsLibrary::GetMediaSupported

--*/
{
    *pType = m_mediaSupported;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMediaSupported(
    LONG    type
    )
/*++

Implements:

    IRmsLibrary::SetMediaSupported

--*/
{
    m_mediaSupported = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxChangers(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxChangers

--*/
{
    *pNum = m_maxChangers;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxChangers(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxChangers

--*/
{
    m_maxChangers = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxDrives(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxDrives

--*/
{
    *pNum = m_maxDrives;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxDrives(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxDrives

--*/
{
    m_maxDrives = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxPorts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxPorts

--*/
{
    *pNum = m_maxPorts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxPorts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxPorts

--*/
{
    m_maxPorts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxSlots

--*/
{
    *pNum = m_maxSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxSlots(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxSlots

--*/
{
    m_maxSlots = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumUsedSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumUsedSlots

--*/
{
    *pNum = m_NumUsedSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumStagingSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumStagingSlots

--*/
{
    *pNum = m_NumStagingSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumStagingSlots(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumStagingSlots

--*/
{
    m_NumStagingSlots = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumScratchCarts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::SetNumScratchCarts

--*/
{
    *pNum = m_NumScratchCarts;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumScratchCarts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumScratchCarts

--*/
{
    m_NumScratchCarts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumUnknownCarts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumUnknownCarts

--*/
{
    *pNum = m_NumUnknownCarts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumUnknownCarts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumUnknownCarts

--*/
{
    m_NumUnknownCarts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetIsMagazineSupported(
    BOOL    flag
    )
/*++

Implements:

    IRmsLibrary::SetIsMagazineSupported

--*/
{
    m_isMagazineSupported = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::IsMagazineSupported(
    void
    )
/*++

Implements:

    IRmsLibrary::IsMagazineSupported

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isMagazineSupported){
        hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsLibrary::GetMaxCleaningMounts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxCleaningMounts

--*/
{
    *pNum = m_maxCleaningMounts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxCleaningMounts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxCleanMounts

--*/
{
    m_maxCleaningMounts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetSlotSelectionPolicy(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetSlotSelectionPolicy

--*/
{
    *pNum = m_slotSelectionPolicy;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetSlotSelectionPolicy(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetSlotSelectionPolicy

--*/
{
    m_slotSelectionPolicy = (RmsSlotSelect) num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetChangers(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetChangers

--*/
{
    *ptr = m_pChangers;
    m_pChangers.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetDriveClasses(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetDriveClasses

--*/
{
    *ptr = m_pDriveClasses;
    m_pDriveClasses.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetDrives(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetDrives

--*/
{
    *ptr = m_pDrives;
    m_pDrives.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetStorageSlots(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetStorageSlots

--*/
{
    *ptr = m_pStorageSlots;
    m_pStorageSlots.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetStagingSlots(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetStagingSlots

--*/
{
    *ptr = m_pStagingSlots;
    m_pStagingSlots.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetPorts(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetPorts

--*/
{
    *ptr = m_pPorts;
    m_pPorts.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetCleaningCartridges(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetCleaningCartridges

--*/
{
    *ptr = m_pCleaningCartridges;
    m_pCleaningCartridges.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetScratchCartridges(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetScratchCartridges

--*/
{
    *ptr = m_pScratchCartridges;
    m_pScratchCartridges.p->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMediaSets(
    IWsbIndexedCollection **ptr
    )
/*++

Implements:

    IRmsLibrary::GetMediaSets

--*/
{
    *ptr = m_pMediaSets;
    m_pMediaSets.p->AddRef();
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsLibrary::Audit(
    LONG /*start*/,
    LONG /*count*/,
    BOOL /*verify*/,
    BOOL /*unknownOnly*/,
    BOOL /*mountWait*/,
    LPOVERLAPPED /*pOverlapped*/,
    LONG* /*pRequest*/
    )
/*++

Implements:

    IRmsLibrary::Audit

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmslocat.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLocat.h

Abstract:

    Declaration of the CRmsLocator class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSLOCAT_
#define _RMSLOCAT_

#include "resource.h"       // resource symbols

/*++

Class Name:

    CRmsLocator

Class Description:

    A CRmsLocator specifies a physical location for a cartridge or
    chanager element.

--*/

class CRmsLocator
{
public:
    CRmsLocator();

// CRmsLocator
public:
    HRESULT GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT Load(IStream* pStream);
    HRESULT Save(IStream* pStream, BOOL clearDirty);

    HRESULT CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test(USHORT *pPassed, USHORT *pFailed);

// IRmsLocator
public:
    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

public:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
    };                                      //
    RmsElement      m_type;                 // The type of element this location
                                            //   refers to (i.e. storage, drive).
    GUID            m_libraryId;            // The guid for the Library housing
                                            //   the Cartridge.
    GUID            m_mediaSetId;           // The guid for the MediaSet housing
                                            //   the Cartridge.
    LONG            m_position;             // The ordinal number of the storage location.
    LONG            m_alternate1;           // First alternate position specifier
                                            //   (i.e. building number).
    LONG            m_alternate2;           // Second alternate position specifier
                                            //   (i.e. room number).
    LONG            m_alternate3;           // Third alternate position specifier
                                            //   (i.e. shelf number).
    BOOL            m_invert;               // If TRUE, the medium is inverted in this
                                            //   storage location.
};

#endif // _RMSLOCAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmslibry.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLibry.h

Abstract:

    Declaration of the CRmsLibrary class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSLIBRY_
#define _RMSLIBRY_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsLibrary

Class Description:

    A CRmsLibrary represents the multi-device complex that includes:

        zero or more medium changers,

        zero or more drive classes,

        zero or more drives,

        zero or more storage slots,

        zero or more staging slots,

        zero or more I/E ports,

        zero or more cleaning cartridges,

        zero or more scratch cartridges,

        zero or more media sets.

        But, at least one.

--*/

class CRmsLibrary :
    public CComDualImpl<IRmsLibrary, &IID_IRmsLibrary, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,        // inherits CComObjectRoot
    public CComCoClass<CRmsLibrary,&CLSID_CRmsLibrary>
{
public:
    CRmsLibrary() {}
BEGIN_COM_MAP(CRmsLibrary)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsLibrary)
    COM_INTERFACE_ENTRY(IRmsLibrary)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsLibrary)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsLibrary
public:
    STDMETHOD(GetLibraryId)(GUID *pLibraryId);
    STDMETHOD(SetLibraryId)(GUID libraryId);

    STDMETHOD( GetName )( BSTR *pName );
    STDMETHOD( SetName )( BSTR name );

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(GetMaxChangers)(LONG *pNum);
    STDMETHOD(SetMaxChangers)(LONG num);

    STDMETHOD(GetMaxDrives)(LONG *pNum);
    STDMETHOD(SetMaxDrives)(LONG num);

    STDMETHOD(GetMaxPorts)(LONG *pNum);
    STDMETHOD(SetMaxPorts)(LONG num);

    STDMETHOD(GetMaxSlots)(LONG *pNum);
    STDMETHOD(SetMaxSlots)(LONG num);

    STDMETHOD(GetNumUsedSlots)(LONG *pNum);

    STDMETHOD(GetNumStagingSlots)(LONG *pNum);
    STDMETHOD(SetNumStagingSlots)(LONG num);

    STDMETHOD(GetNumScratchCarts)(LONG *pNum);
    STDMETHOD(SetNumScratchCarts)(LONG num);

    STDMETHOD(GetNumUnknownCarts)(LONG *pNum);
    STDMETHOD(SetNumUnknownCarts)(LONG num);

    STDMETHOD(SetIsMagazineSupported)(BOOL flag);
    STDMETHOD(IsMagazineSupported)(void);

    STDMETHOD(GetMaxCleaningMounts)(LONG *pNum);
    STDMETHOD(SetMaxCleaningMounts)(LONG num);

    STDMETHOD(GetSlotSelectionPolicy)(LONG *pNum);
    STDMETHOD(SetSlotSelectionPolicy)(LONG num);

    STDMETHOD(GetChangers)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetDriveClasses)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetDrives)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetStorageSlots)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetStagingSlots)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetPorts)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetCleaningCartridges)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetScratchCartridges)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetMediaSets)(IWsbIndexedCollection **ptr);

    STDMETHOD( Audit )( LONG start, LONG count, BOOL verify, BOOL unknownOnly, BOOL mountWait, LPOVERLAPPED pOverlapped, LONG *pRequest );


protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    RmsMedia        m_mediaSupported;       // The type of media supported by a
                                            //   a Drive, usually one type, but
                                            //   can be a combination of media
                                            //   types for multi-function devices
                                            //   (i.e. drives that support Optical,
                                            //   WORM, and CDR).
    LONG            m_maxChangers;          // The total number of medium changers contained
                                            //   within the Library.
    LONG            m_maxDrives;            // The total number of drives contained
                                            //   within the Library.
    LONG            m_maxPorts;             // The total number of I/E ports contained
                                            //   within the Library.
    LONG            m_maxSlots;             // The total number of storage slots
                                            //   contained within the library.
    LONG            m_NumUsedSlots;         // The number of occupied storage slots.
    LONG            m_NumStagingSlots;      // The number of slots used for staging area.
    LONG            m_NumScratchCarts;      // The amount of scratch media available.
    LONG            m_NumUnknownCarts;      // The number of units of media
                                            //   having unknown status.
    BOOL            m_isMagazineSupported;  // If TRUE, the library supports magazines.
    LONG            m_maxCleaningMounts;    // The max number of mounts per cleaning
                                            //   cartridge.
    RmsSlotSelect   m_slotSelectionPolicy;  // The storage slot selection policy
                                            //   to use (see RmsSlotSelect).
    CComPtr<IWsbIndexedCollection> m_pChangers;            // The changers associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pDriveClasses;        // The drive classes associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pDrives;              // The drives associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pStorageSlots;        // The storage slots associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pStagingSlots;        // The staging slots associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pPorts;               // The I/E ports associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pCleaningCartridges;  // The cleaning cartridges associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pScratchCartridges;   // The scratch cartridges associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pMediaSets;           // The media sets associated with the Library.
};

#endif // _RMSLIBRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmslocat.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLocat.cpp

Abstract:

    Implementation of CRmsLocator

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsLocat.h"

///////////////////////////////////////////////////////////////////////////////
//


CRmsLocator::CRmsLocator(
    void
    )
/*++

Routine Description:

    CRmsLocator constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize values
    m_type = RmsElementUnknown;

    m_libraryId = GUID_NULL;

    m_mediaSetId = GUID_NULL;

    m_position = 0;

    m_alternate1 = 0;

    m_alternate2 = 0;

    m_alternate3 = 0;

    m_invert = FALSE;
}


HRESULT
CRmsLocator::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsLocator::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsLocator::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CRmsLocator     pLocator;
        RmsElement      type;
        GUID            libraryId;
        GUID            mediaSetId;
        LONG            position;
        LONG            alternate1;
        LONG            alternate2;
        LONG            alternate3;
        BOOL            invert;

        // Get Locator to check
        GetLocation((LONG *) &type, &libraryId, &mediaSetId, &position,
                    &alternate1, &alternate2, &alternate3,
                    &invert);

        // See if we have the location requested
        if ( (m_type       == type       ) &&
             (m_libraryId  == libraryId  ) &&
             (m_mediaSetId == mediaSetId ) &&
             (m_position   == position   ) &&
             (m_alternate1 == alternate1 ) &&
             (m_alternate2 == alternate2 ) &&
             (m_alternate3 == alternate3 ) &&
             (m_invert     == invert     )    ) {

            // Locators match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsLocator::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsLocator::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsLocator::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +           // m_type
//                             WsbPersistSizeOf(GUID) +           // m_libraryId
//                             WsbPersistSizeOf(GUID) +           // m_mediaSetId
//                             WsbPersistSizeOf(LONG) +           // m_position
//                             WsbPersistSizeOf(LONG) +           // m_alternate1
//                             WsbPersistSizeOf(LONG) +           // m_alternate2
//                             WsbPersistSizeOf(LONG) +           // m_alternate3
//                             WsbPersistSizeOf(BOOL);            // m_invert

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsLocator::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsLocator::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsElement)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_libraryId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mediaSetId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_position));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate1));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate2));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate3));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_invert));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsLocator::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsLocator::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, m_libraryId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mediaSetId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_position));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate1));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate2));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate3));

        WsbAffirmHr(WsbSaveToStream(pStream, m_invert));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsLocator::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    guidVal2 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};

    GUID                    guidWork1;
    GUID                    guidWork2;

    LONG                    longVal1 = 11111111;
    LONG                    longVal2 = 22222222;
    LONG                    longVal3 = 33333333;
    LONG                    longVal4 = 44444444;

    LONG                    longWork0;
    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;

    BOOL                    boolWork1;
    BOOL                    boolWork2;


    WsbTraceIn(OLESTR("CRmsLocator::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            boolWork1 = FALSE;

            // Test SetLocation & GetLocation
            for(i = RmsElementUnknown; i < RmsElementIEPort; i++){
                SetLocation(i,
                            guidVal1,
                            guidVal2,
                            longVal1,
                            longVal2,
                            longVal3,
                            longVal4,
                            boolWork1);

                GetLocation(&longWork0,
                            &guidWork1,
                            &guidWork2,
                            &longWork1,
                            &longWork2,
                            &longWork3,
                            &longWork4,
                            &boolWork2);

                if((i == longWork0) &&
                   (guidVal1 == guidWork1) &&
                   (guidVal2 == guidWork2) &&
                   (longVal1 == longWork1) &&
                   (longVal2 == longWork2) &&
                   (longVal3 == longWork3) &&
                   (longVal4 == longWork4) &&
                   (boolWork1 == boolWork2)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }

                if(boolWork1 == TRUE){
                    boolWork1 = FALSE;
                } else {
                    boolWork1 = TRUE;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsLocator::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Routine Description:

    Get location values.

Arguments:

    pType           - pointer to cartridge type
    pLibId          - pointer to library id
    pMediaSetId     - pointer to media set id
    pPos            - pointer to current position
    pAlt1           - pointer to alternate data field 1
    pAlt2           - pointer to alternate data field 2
    pAlt3           - pointer to alternate data field 3
    pInvert         - pointer to invert flag

Return Value:

    S_OK            - successful

--*/
{
    if (pType) {
        *pType = m_type;
    }
    if (pLibId) {
        *pLibId = m_libraryId;
    }
    if (pMediaSetId) {
        *pMediaSetId = m_mediaSetId;
    }
    if (pPos) {
        *pPos = m_position;
    }
    if (pAlt1) {
        *pAlt1 = m_alternate1;
    }
    if (pAlt2) {
        *pAlt2 = m_alternate2;
    }
    if (pAlt3) {
        *pAlt3 = m_alternate3;
    }
    if (pInvert) {
        *pInvert = m_invert;
    }

    return S_OK;
}

STDMETHODIMP
CRmsLocator::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert
    )
/*++

Routine Description:

    Set location values.

Arguments:

    type           - new value of cartridge type
    libId          - new value of library id
    mediaSetId     - new value of media set id
    pos            - new value of current position
    alt1           - new value of alternate data field 1
    alt2           - new value of alternate data field 2
    alt3           - new value of alternate data field 3
    invert         - new value of invert flag

Return Value:

    S_OK            - successful

--*/
{
    m_type = (RmsElement) type;
    m_libraryId = libId;
    m_mediaSetId = mediaSetId;
    m_position = pos;
    m_alternate1 = alt1;
    m_alternate2 = alt2;
    m_alternate3 = alt3;
    m_invert = invert;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsdvice.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDvice.h

Abstract:

    Declaration of the CRmsDevice class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDVICE_
#define _RMSDVICE_

#include "resource.h"       // resource symbols

#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsDevice

Class Description:

    A CRmsDevice represents a physical device connected to a SCSI bus.

--*/

class CRmsDevice :
    public CComDualImpl<IRmsDevice, &IID_IRmsDevice, &LIBID_RMSLib>,
    public CRmsChangerElement   // inherits CRmsComObject
{
public:
    CRmsDevice();

// CRmsDevice
public:

    HRESULT GetSizeMax( ULARGE_INTEGER* pSize );
    HRESULT Load( IStream* pStream );
    HRESULT Save( IStream* pStream, BOOL clearDirty );

    HRESULT CompareTo( IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test( USHORT *pPassed, USHORT *pFailed );

// IRmsDevice
public:

    STDMETHOD( GetDeviceName )( BSTR *pName );
    STDMETHOD( SetDeviceName )( BSTR name );

    STDMETHOD( GetDeviceInfo )( UCHAR *pId, SHORT *pSize );
    STDMETHOD( SetDeviceInfo )( UCHAR *pId, SHORT size );

    STDMETHOD( GetDeviceType )( LONG *pType );
    STDMETHOD( SetDeviceType )( LONG type );

    //STDMETHOD( GetVendorId )( BSTR *pVendorId);
    //STDMETHOD( GetProductId )( BSTR *pProductId);
    //STDMETHOD( GetFirmwareLevel )( BSTR *pFirmwareLevel);
    //STDMETHOD( GetSerialNumber )( UCHAR *pNo, SHORT *pSize );

    STDMETHOD( GetDeviceAddress )( BYTE *pPort, BYTE *pBus, BYTE *pId, BYTE *pLun );
    STDMETHOD( SetDeviceAddress )( BYTE port, BYTE bus, BYTE id, BYTE lun );

protected:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 36                        // Max size of the device identifier.
        };                                  //
    CWsbBstrPtr     m_deviceName;           // The name used to create a handle to
                                            //   the device.
    RmsDevice       m_deviceType;           // The device type that best describes
                                            //   the device.  Some devices are multi-
                                            //   function.
    SHORT           m_sizeofDeviceInfo;     // The size of valid data in the
                                            //   device information buffer.
    UCHAR           m_deviceInfo[MaxInfo];  // An array of bytes which can uniquely
                                            //   identify the device.  Usually
                                            //   this information is returned
                                            //   directly by the device and
                                            //   represents SCSI inquiry information.
//    CWsbBstrPtr     m_SerialNumber;         // The serial number obtained directly
//                                            //   from the device.
    BYTE            m_port;                 // Adapter port number.
    BYTE            m_bus;                  // The path/bus id; the bus number on
                                            //   the port.
    BYTE            m_targetId;             // Target ID.
    BYTE            m_lun;                  // Logical unit number.
};

#endif // _RMSDVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsiport.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsIPort.h

Abstract:

    Declaration of the CRmsIEPort class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSIPORT_
#define _RMSIPORT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsIPort

Class Description:

    A CRmsIPort represents an element in a library through which media are
    imported and/or exported.

--*/

class CRmsIEPort :
    public CComDualImpl<IRmsIEPort, &IID_IRmsIEPort, &LIBID_RMSLib>,
    public CRmsChangerElement,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsIEPort,&CLSID_CRmsIEPort>
{
public:
    CRmsIEPort() {}
BEGIN_COM_MAP(CRmsIEPort)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsIEPort)
    COM_INTERFACE_ENTRY(IRmsIEPort)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsIEPort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsIEPort
public:
    STDMETHOD(GetDescription)(BSTR *pDesc);
    STDMETHOD(SetDescription)(BSTR desc);

    STDMETHOD(SetIsImport)(BOOL flag);
    STDMETHOD(IsImport)(void);

    STDMETHOD(SetIsExport)(BOOL flag);
    STDMETHOD(IsExport)(void);

    STDMETHOD(GetWaitTime)(LONG *pTime);
    STDMETHOD(SetWaitTime)(LONG time);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    CWsbBstrPtr     m_description;          // This is the description used to
                                            //   identify the port to an operator.
    BOOL            m_isImport;             // If TRUE, the portal can be used for importing media.
    BOOL            m_isExport;             // If TRUE, the portal can be used for exporting media.
    LONG            m_waitTime;             // Elapsed milliseconds to wait before
                                            //   timming out an import/export request.
};

#endif // _RMSIPORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsiport.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsIPort.cpp

Abstract:

    Implementation of CRmsIEPort

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsIPort.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsIEPort::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsIEPort::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsIEPort, &IID_IRmsIEPort> pIEPort = pCollectable;
        WsbAssertPointer( pIEPort );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDescription:
            {

                CWsbBstrPtr description;

                // Get description to check
                WsbAffirmHr( pIEPort->GetDescription( &description ) );

                // Compare the names
                result = (SHORT)wcscmp( m_description, description );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsIEPort::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsIEPort::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize
        m_description = RMS_UNDEFINED_STRING;

        m_isImport = FALSE;

        m_isExport = FALSE;

        m_waitTime = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsIEPort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsIEPort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       descriptionLen;


    WsbTraceIn(OLESTR("CRmsIEPort::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        descriptionLen = SysStringByteLen(m_description);

//        // get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)   +     // length of m_description
//                             descriptionLen           +     // m_description
//                             WsbPersistSizeOf(BOOL)   +     // m_isImport
//                             WsbPersistSizeOf(BOOL)   +     // m_isExport
//                             WsbPersistSizeOf(LONG);        // m_waitTime

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsIEPort::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_description));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isImport));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isExport));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_waitTime));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsIEPort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbBstrToStream(pStream, m_description));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isImport));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isExport));

        WsbAffirmHr(WsbSaveToStream(pStream, m_waitTime));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsIEPort>     pIEPort1;
    CComPtr<IRmsIEPort>     pIEPort2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");

    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;



    WsbTraceIn(OLESTR("CRmsIEPort::Test"), OLESTR(""));

    try {
        // Get the IEPort interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsIEPort*) this)->QueryInterface(IID_IRmsIEPort, (void**) &pIEPort1));

            // Test SetDescription & GetDescription interface
            bstrWork1 = bstrVal1;

            SetDescription(bstrWork1);

            GetDescription(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsImport & IsImport to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsImport (TRUE));
                WsbAffirmHr(IsImport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsImport & IsImport to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsImport (FALSE));
                WsbAffirmHr(IsImport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetIsExport & IsExport to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsExport (TRUE));
                WsbAffirmHr(IsExport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsExport & IsExport to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsExport (FALSE));
                WsbAffirmHr(IsExport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetWaitTime & GetWaitTime
            longWork1 = 99;

            SetWaitTime(longWork1);

            GetWaitTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetDescription(
    BSTR    *pDesc
    )
/*++

Implements:

    IRmsIEPort::GetDescription

--*/
{
    WsbAssertPointer (pDesc);

    m_description. CopyToBstr (pDesc);
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetDescription(
    BSTR  desc
    )
/*++

Implements:

    IRmsIEPort::SetDescription

--*/
{
    m_description = desc;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetIsImport(
    BOOL    flag
    )
/*++

Implements:

    IRmsIEPort::SetIsImport

--*/
{
    m_isImport = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::IsImport(
    void
    )
/*++

Implements:

    IRmsIEPort::IsImport

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isImport){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsIEPort::SetIsExport(
    BOOL    flag
    )
/*++

Implements:

    IRmsIEPort::SetIsExport

--*/
{
    m_isExport = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::IsExport(
    void
    )
/*++

Implements:

    IRmsIEPort::IsExport

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isExport){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsIEPort::GetWaitTime(
    LONG    *pTime
    )
/*++

Implements:

    IRmsIEPort::GetWaitTime

--*/
{
    *pTime = m_waitTime;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetWaitTime(
    LONG    time
    )
/*++

Implements:

    IRmsIEPort::SetWaitTime

--*/
{
    m_waitTime = time;
    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsmdset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsMdSet.cpp

Abstract:

    Implementation of CRmsMediaSet

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsServr.h"
#include "RmsMdSet.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsMediaSet::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT hr = E_FAIL;
    SHORT   result = 1;

    WsbTraceIn( OLESTR("CRmsMediaSet::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsMediaSet interface to get the value of the object.
        CComQIPtr<IRmsMediaSet, &IID_IRmsMediaSet> pMediaSet = pCollectable;
        WsbAssertPointer( pMediaSet );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                WsbAffirmHr( pMediaSet->GetName( &name ) );

                // Compare the names
                result = (SHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr(pMediaSet->GetMediaSupported( (LONG*) &mediaSupported ) );

                if ( m_MediaSupported == mediaSupported ) {

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByMediaSetId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }


    WsbTraceOut( OLESTR("CRmsMediaSet::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsMediaSet::FinalConstruct(void)
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values

        m_Name = RMS_UNDEFINED_STRING;

        m_MediaSupported   = RmsMediaUnknown;

        m_SizeOfInfo = 0;

        memset(m_Info, 0, MaxInfo);

        m_OwnerId = CLSID_NULL;

        m_MediaSetType = RmsMediaSetUnknown;

        m_MaxCartridges = 0;

        m_Occupancy = 0;

        m_IsMediaCopySupported = FALSE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsMediaSet::GetClassID"), OLESTR(""));

    try {

        WsbAssertPointer(pClsid);

        *pClsid = CLSID_CRmsMediaSet;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;

    WsbTraceIn(OLESTR("CRmsMediaSet::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // m_objectId
//                             WsbPersistSizeOf(LONG)  +      // length of m_name
//                             nameLen                 +      // m_name
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSupported
//                             WsbPersistSizeOf(SHORT) +      // m_sizeofInfo
//                             MaxInfo                 +      // m_info
//                             WsbPersistSizeOf(CLSID) +      // m_ownerId
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSetType
//                             WsbPersistSizeOf(LONG)  +      // m_maxCartridges
//                             WsbPersistSizeOf(LONG);        // m_occupancy



//    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT hr = S_OK;
    ULONG   ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediaSet::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_MediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SizeOfInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Info [0]), MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_OwnerId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_MediaSetType = (RmsMediaSet)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MaxCartridges));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Occupancy));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_IsMediaCopySupported));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT hr = S_OK;
    ULONG   ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediaSet::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_MediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_SizeOfInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &(m_Info [0]), MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_OwnerId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_MediaSetType));

        WsbAffirmHr(WsbSaveToStream(pStream, m_MaxCartridges));

        WsbAffirmHr(WsbSaveToStream(pStream, m_Occupancy));

        WsbAffirmHr(WsbSaveToStream(pStream, m_IsMediaCopySupported));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed)
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};

    GUID                    guidWork1;
    GUID                    guidWork2;

    CLSID                   clsidWork1;
    CLSID                   clsidWork2;

    LONG                    i;
    LONG                    longWork1;
    LONG                    longWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");

    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsMediaSet::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetMediaSetId & GetMediaSetId
            m_objectId = guidVal1;

            guidWork1 = m_objectId;

            GetMediaSetId(&guidWork2);

            if(guidWork1 == guidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetInfo & GetInfo

            // Test SetOwnerClassId & GetOwnerClassId
            clsidWork1 = CLSID_NULL;

            SetOwnerClassId(clsidWork1);

            GetOwnerClassId(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSetType & GetMediaSetType
            for (i = RmsMediaSetUnknown; i < RmsMediaSetNTMS; i++){

                longWork1 = i;

                SetMediaSetType (longWork1);

                GetMediaSetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetMaxCartridges & GetMaxCartridges
            longWork1 = 99;

            SetMaxCartridges(longWork1);

            GetMaxCartridges(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetOccupancy & GetOccupancy
            longWork1 = 99;

            SetOccupancy(longWork1);

            GetOccupancy(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }



        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSetId(
    OUT GUID *pMediaSetId)
/*++

Implements:

    IRmsMediaSet::GetMediaSetId

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pMediaSetId);

        *pMediaSetId = m_objectId;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsMediaSet::GetName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsMediaSet::GetName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pName);

        m_Name. CopyToBstr (pName);

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetName(
    IN BSTR name)
/*++

Implements:

    IRmsMediaSet::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSupported(
    OUT LONG *pType)
/*++

Implements:

    IRmsMediaSet::GetMediaSupported

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pType);

        *pType = m_MediaSupported;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMediaSupported(
    IN LONG type)
/*++

Implements:

    IRmsMediaSet::SetMediaSupported

--*/
{
    m_MediaSupported = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetInfo(
    OUT UCHAR *pInfo,
    OUT SHORT *pSize)
/*++

Implements:

    IRmsMediaSet::GetInfo

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pInfo);
        WsbAssertPointer (pSize);

        memmove (pInfo, m_Info, m_SizeOfInfo );
        *pSize = m_SizeOfInfo;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetInfo(
    IN UCHAR *pInfo,
    IN SHORT size)
/*++

Implements:

    IRmsMediaSet::SetInfo

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pInfo);

        memmove (m_Info, pInfo, size);
        m_SizeOfInfo = size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetOwnerClassId(
    OUT CLSID *pClassId)
/*++

Implements:

    IRmsMediaSet::GetOwnerClassId

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pClassId);

        *pClassId = m_OwnerId;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetOwnerClassId(
    IN CLSID classId)
/*++

Implements:

    IRmsMediaSet::SetOwnerClassId

--*/
{
    m_OwnerId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSetType(
    OUT LONG *pType)
/*++

Implements:

    IRmsMediaSet::GetMediaSetType

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pType);

        *pType = m_MediaSetType;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMediaSetType(
    IN LONG type)
/*++

Implements:

    IRmsMediaSet::SetMediaSetType

--*/
{
    m_MediaSetType = (RmsMediaSet) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMaxCartridges(
    OUT LONG *pNum)
/*++

Implements:

    IRmsMediaSet::GetMaxCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pNum);

        *pNum = m_MaxCartridges;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMaxCartridges(
    IN LONG num)
/*++

Implements:

    IRmsMediaSet::SetMaxCartridges

--*/
{
    m_MaxCartridges = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetOccupancy(
    OUT LONG *pNum)
/*++

Implements:

    IRmsMediaSet::GetOccupancy

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pNum);

        *pNum = m_Occupancy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetOccupancy(
    IN LONG num)
/*++

Implements:

    IRmsMediaSet::SetOccupancy

--*/
{
    m_Occupancy = num;
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsMediaSet::IsMediaCopySupported(void)
/*++

Implements:

    IRmsMediaSet::IsMediaCopySupported

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::IsMediaCopySupported"), OLESTR(""));

    try {

        if (RmsMediaSetNTMS == m_MediaSetType) {

            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            CComPtr<IRmsNTMS> pNtms;
            WsbAffirmHr(pServer->GetNTMS(&pNtms));
            WsbAffirmPointer(pNtms);

            m_IsMediaCopySupported = (S_OK == pNtms->IsMediaCopySupported(m_objectId)) ? TRUE : FALSE;
            
        }

        hr = ( m_IsMediaCopySupported ) ? S_OK : S_FALSE;

    } WsbCatch(hr)



    WsbTraceOut(OLESTR("CRmsMediaSet::IsMediaCopySupported"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetIsMediaCopySupported(
    IN BOOL flag)
/*++

Implements:

    IRmsMediaSet::SetIsMediaCopySupported

--*/
{
    m_IsMediaCopySupported = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::Allocate(
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN BSTR displayName,
    IN DWORD dwOptions,
    OUT IRmsCartridge **ppCart)
/*++

Implements:

    IRmsMediaSet::Allocate

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::Allocate"), OLESTR("<%ls> <%ls> <0x%08x>"),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&displayName)),
        WsbQuickString(WsbPtrToLonglongAsString(pFreeSpace)),
        dwOptions );

    try {
        WsbAssertPointer(ppCart);

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        switch (m_MediaSetType) {
        case RmsMediaSetLibrary:
            {
                CComPtr<IWsbIndexedCollection>  pCarts;
                CComPtr<IRmsCartridge>          pFindCart;

                // Get the cartridge collection
                WsbAffirmHr(pServer->GetCartridges(&pCarts));

                // Create a cartridge template
                WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER, IID_IRmsCartridge, (void **)&pFindCart));

                // Fill in the find template

                // Using FindByScratchMediaCriteria
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;
                WsbAssertHr(pObject->SetFindBy(RmsFindByScratchMediaCriteria));

                // Scratch selection criteria
                WsbAssertHr(pFindCart->SetStatus(RmsStatusScratch));
                WsbAssertHr(pFindCart->SetLocation(RmsElementUnknown, GUID_NULL, m_objectId, 0, 0, 0, 0, FALSE));

                // Now find the cartridge
                hr = pCarts->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                if (WSB_E_NOTFOUND == hr) {
                    WsbThrow(RMS_E_SCRATCH_NOT_FOUND_FINAL);
                }
                WsbAffirmHr(hr);

                // Set media name and description to display name
                WsbAffirmPointer(*ppCart);
                WsbAffirmHr((*ppCart)->SetName(displayName));
                WsbAffirmHr((*ppCart)->SetDescription(displayName));
            }
            break;
        case RmsMediaSetNTMS:
            {
                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Allocate(m_objectId, prevSideId, pFreeSpace, displayName, dwOptions, ppCart));
            }
            break;
        case RmsMediaSetShelf:
        case RmsMediaSetOffSite:
        case RmsMediaSetFolder:
        case RmsMediaSetUnknown:
        default:
            WsbThrow(E_UNEXPECTED);
            break;
        }

        (void) InterlockedIncrement(&m_Occupancy);

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsMediaSet::Allocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}


STDMETHODIMP
CRmsMediaSet::Deallocate(
        IN IRmsCartridge *pCart)
/*++

Implements:

    IRmsMediaSet::Deallocate

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::Deallocate"), OLESTR(""));

    try {
        WsbAssertPointer (pCart);

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        switch (m_MediaSetType) {
        case RmsMediaSetLibrary:
            {
                WsbAffirmHr(pCart->SetStatus(RmsStatusScratch));
            }
            break;
        case RmsMediaSetNTMS:
            {
                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Deallocate(pCart));
            }
            break;
        case RmsMediaSetShelf:
        case RmsMediaSetOffSite:
        case RmsMediaSetFolder:
        case RmsMediaSetUnknown:
        default:
            WsbThrow(E_UNEXPECTED);
            break;
        }

        (void) InterlockedDecrement(&m_Occupancy);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Deallocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmspartn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsPartn.cpp

Abstract:

    Implementation of CRmsPartition

Author:

    Brian Dodd          [brian]         19-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsPartn.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsPartition::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsPartition::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsPartition interface to get the value of the object.
        CComQIPtr<IRmsPartition, &IID_IRmsPartition> pPartition = pCollectable;
        WsbAssertPointer( pPartition );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByPartitionNumber:
            {
                LONG    partNo;

                WsbAffirmHr( pPartition->GetPartNo( &partNo ) );

                if( m_partNo == partNo ) {

                    // partition numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
                break;
            }

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsPartition::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsPartition::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_partNo = 0;

        m_attributes = RmsAttributesUnknown;

        m_sizeofIdentifier = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsPartition::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsPartition;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsPartition::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart = WsbPersistSizeOf(LONG) +        // m_partNo
//                            WsbPersistSizeOf(LONG) +        // m_attributes
//                            WsbPersistSizeOf(SHORT);        // m_sizeofIdentifier

////                          MaxId;                          // m_pIdentifier


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsPartition::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        // Read value

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_partNo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_attributes = (RmsAttribute)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofIdentifier));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsPartition::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_partNo));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_attributes));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofIdentifier));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IRmsPartition>  pPartition1;
    CComPtr<IRmsPartition>  pPartition2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;
    LONG                    longWork2;

    WsbTraceIn(OLESTR("CRmsPartition::Test"), OLESTR(""));

    try {
        // Get the Partition interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsPartition*) this)->QueryInterface(IID_IRmsPartition, (void**) &pPartition1));

            // Test SetAttributes & GetAttributes
            for (i = RmsAttributesUnknown; i < RmsAttributesVerify; i++){

                longWork1 = i;

                SetAttributes(longWork1);

                GetAttributes(&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetPartNo(
    LONG    *pPartNo
    )
/*++

Implements:

    IRmsPartition::GetPartNo

--*/
{
    *pPartNo = m_partNo;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::GetAttributes (
    LONG    *pAttr
    )
/*++

Implements:

    IRmsPartition::GetAttributes

--*/
{
    *pAttr = (LONG) m_attributes;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::SetAttributes (
    LONG  attr
    )
/*++

Implements:

    IRmsPartition::SetAttributes

--*/
{
    m_attributes = (RmsAttribute) attr;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::GetIdentifier (
    UCHAR   *pIdent,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsPartition::GetIdentifier

--*/
{
    *pSize = m_sizeofIdentifier;
    memmove (pIdent, m_pIdentifier, m_sizeofIdentifier);
    return S_OK;
}


STDMETHODIMP
CRmsPartition::SetIdentifier (
    UCHAR   *pIdent,
    SHORT   size
    )
/*++

Implements:

    IRmsPartition::SetIdentifier

--*/
{
    m_sizeofIdentifier = size;
    memmove (m_pIdentifier, pIdent, size);
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsPartition::GetStorageInfo(
    IRmsStorageInfo** /*ptr*/
    )
/*++

Implements:

    IRmsPartition::GetStorageInfo

--*/
{

    return S_OK;
}


STDMETHODIMP
CRmsPartition::VerifyIdentifier(
    void
    )
/*++

Implements:

    IRmsPartition::VerifyIdentifier

--*/
{

    return S_OK;
}


STDMETHODIMP
CRmsPartition::ReadOnMediaId(
    UCHAR* /*pid*/,
    LONG* /*pSize*/
    )
/*++

Implements:

    IRmsPartition::ReadOnMediaId

--*/
{

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsobjct.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsObjct.h

Abstract:

    Declaration of the CRmsComObject class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSOBJCT_
#define _RMSOBJCT_

#include "resource.h"       // resource symbols

/*++

Class Name:

    CRmsComObject

Class Description:

    A CRmsComObject is the base class for all Rms service COM objects.  This
    object holds state, security, and error information about an Rms object.

--*/

class CRmsComObject :
    public CComDualImpl<IRmsComObject, &IID_IRmsComObject, &LIBID_RMSLib>,
    public ISupportErrorInfo
{
// CRmsComObject
public:
    CRmsComObject();

    HRESULT GetSizeMax(OUT ULARGE_INTEGER* pSize);
    HRESULT Load(IN IStream* pStream);
    HRESULT Save(IN IStream* pStream, IN BOOL clearDirty);

    HRESULT CompareTo( IN IUnknown* pCollectable, OUT SHORT* pResult);

    HRESULT Test(OUT USHORT *pPassed, OUT USHORT *pFailed);

// ISupportsErrorInfo
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(IN REFIID riid);

// IRmsComObject
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);
    STDMETHOD(SetObjectId)(IN GUID objectId);

    STDMETHOD(GetObjectType)(OUT LONG *pType);
    STDMETHOD(SetObjectType)(IN LONG type);

    STDMETHOD(IsEnabled)(void);
    STDMETHOD(Enable)();
    STDMETHOD(Disable)(IN HRESULT reason);

    STDMETHOD(GetState)(OUT LONG *pState);
    STDMETHOD(SetState)(IN LONG state);

    STDMETHOD(GetStatusCode)(OUT HRESULT *pResult);
    STDMETHOD(SetStatusCode)(IN HRESULT result);

    STDMETHOD(GetName)(OUT BSTR *pName);
    STDMETHOD(SetName)(IN BSTR name);

    STDMETHOD(GetDescription)(OUT BSTR *pName);
    STDMETHOD(SetDescription)(IN BSTR name);

    STDMETHOD(GetPermissions)(OUT SECURITY_DESCRIPTOR *lpPermit);
    STDMETHOD(SetPermissions)(IN SECURITY_DESCRIPTOR permit);

    STDMETHOD(GetFindBy)(OUT LONG *pFindBy);
    STDMETHOD(SetFindBy)(IN LONG findBy);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//
protected:
    GUID                    m_objectId;         // Unique ID for this object.
    RmsObject               m_ObjectType;       // The type of object.
    BOOL                    m_IsEnabled;        // TRUE, if the object is enabled for normal
                                                //   processing.
    LONG                    m_State;            // The current operating state of the object.
                                                //   Varies by object type.  See RmsXXXState.
    HRESULT                 m_StatusCode;       // S_OK if the object is enabled for normal
                                                //   processing, otherwise this holds the
                                                //   result code, or reason, associated with
                                                //   the disabled object.  This result is
                                                //   returned whenever normal processing
                                                //   on the object is attempted while object
                                                //   is disabled.
    CWsbBstrPtr             m_Name;             // Name of the object.
    CWsbBstrPtr             m_Description;      // Description for the object.
    SECURITY_DESCRIPTOR     m_Permit;           // Defines security attributes of the object.
    RmsFindBy               m_findBy;           // Defines the type of CompareTo to perform
                                                //   when searching a collection.
////////////////////////////////////////////////////////////////////////////////////////
//
// local methods
//
private:
    HRESULT adviseOfStatusChange(void);
};

#endif // _RMSOBJCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsntms.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsNTMS.cpp

Abstract:

    Implementation of CRmsNTMS

Author:

    Brian Dodd          [brian]         14-May-1997

Revision History:

--*/

#include "stdafx.h"

#include "RmsServr.h"
#include "RmsNTMS.h"

typedef struct RmsNTMSSearchHandle {
    WCHAR       FindName[NTMS_OBJECTNAME_LENGTH];
    NTMS_GUID   FindId;
    DWORD       FindType;
    LPNTMS_GUID Objects;
    DWORD       NumberOfObjects;
    DWORD       MaxObjects;
    DWORD       Next;
    DWORD       LastError;
} RMS_NTMS_SEARCH_HANDLE, *LPRMS_NTMS_SEARCH_HANDLE;

#define ADD_ACE_MASK_BITS 1
#define REMOVE_ACE_MASK_BITS 2

//
// We use application name in RSM interface for media pool name.
//  Media pool name is an identifier of the media pool in RSM, therefore, we cannot allow 
//  this string to be localized. Localizing this string would create another pool after 
//  installing a foreign language MUI.
//
#define REMOTE_STORAGE_APP_NAME     OLESTR("Remote Storage")



/////////////////////////////////////////////////////////////////////////////
// IRmsNTMS implementation

/*
    HINSTANCE       hInstDll;
    typedef DWORD (*FunctionName)( void );
    FunctionName    FunctionNameFn;
    hInstDll = LoadLibrary( "dll" );
    FunctionNameFn = (FunctionName) GetProcAddress( hInstDll, "FunctionName" );
    result = (FunctionNameFn)();
*/


STDMETHODIMP
CRmsNTMS::FinalConstruct(void)
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    WsbTraceIn(OLESTR("CRmsNTMS::FinalConstruct"), OLESTR(""));

    m_pLibGuids = NULL;
    m_dwNofLibs = 0;

    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        WsbAffirmHr( changeState( RmsNtmsStateStarting ));

        m_SessionHandle = INVALID_HANDLE_VALUE;
        m_IsRmsConfiguredForNTMS = FALSE;
        m_IsNTMSRegistered = FALSE;
        m_Name = RMS_NTMS_OBJECT_NAME;
        m_Description = RMS_NTMS_OBJECT_DESCRIPTION;

        if ( S_OK == getNtmsSupportFromRegistry(NULL) ) {
            m_IsRmsConfiguredForNTMS = TRUE;
        }

        HKEY hKeyMachine = 0;
        HKEY hKey        = 0;

        if ( S_OK == WsbOpenRegistryKey(NULL, RMS_NTMS_REGISTRY_STRING, KEY_QUERY_VALUE, &hKeyMachine, &hKey) ) {
            WsbCloseRegistryKey (&hKeyMachine, &hKey);
            m_IsNTMSRegistered = TRUE;
        }

        // Failure precedence.
        WsbAffirm(m_IsRmsConfiguredForNTMS, RMS_E_NOT_CONFIGURED_FOR_NTMS);
        WsbAffirm(m_IsNTMSRegistered, RMS_E_NTMS_NOT_REGISTERED);

        WsbAffirmHr( changeState( RmsNtmsStateStarted ));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
            WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED, 0, NULL, WsbHrAsString(hr), NULL);

            // Always construct!
            hr = S_OK;
        );

    WsbTraceOut(OLESTR("CRmsNTMS::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::FinalRelease(void)
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::FinalRelease"), OLESTR(""));

    try {

        WsbAffirmHr( changeState( RmsNtmsStateStopping ));

        endSession();

        if (m_pLibGuids) {
            WsbFree(m_pLibGuids);
        }

        CComObjectRoot::FinalRelease();

        WsbAffirmHr( changeState( RmsNtmsStateStopped ));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsNTMS::IsInstalled(void)
{
    HRESULT hr = S_OK;

    try {

        if ( !m_IsEnabled ) {

            if ( !m_IsNTMSRegistered ) {
                // check again... NTMS can get registered at anytime.
                HKEY hKeyMachine = 0;
                HKEY hKey        = 0;

                WsbAffirm(S_OK == WsbOpenRegistryKey(NULL, RMS_NTMS_REGISTRY_STRING, KEY_QUERY_VALUE, &hKeyMachine, &hKey), RMS_E_NTMS_NOT_REGISTERED);
                WsbCloseRegistryKey (&hKeyMachine, &hKey);

                m_IsNTMSRegistered = TRUE;

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
                pObject->Enable();

                // now need to initialize
                WsbAffirmHr(InitializeInAnotherThread());
            }

            WsbAffirm(m_IsRmsConfiguredForNTMS, RMS_E_NOT_CONFIGURED_FOR_NTMS);
            WsbAffirm(m_IsNTMSRegistered, RMS_E_NTMS_NOT_REGISTERED);

        }

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsNTMS::Initialize(void)
{
    HRESULT hr = E_FAIL;
    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    WsbTraceIn(OLESTR("CRmsNTMS::Initialize"), OLESTR(""));

    try {

        WsbAffirmHr( changeState( RmsNtmsStateInitializing ));

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        //
        // Create Remote Storage specific NTMS media pools
        //

        WsbAffirmHr( createMediaPools() );

        //
        // Report on other NTMS objects of interest
        //

        HANDLE hFind = NULL;
        NTMS_OBJECTINFORMATION  objectInfo;

        hr = findFirstNtmsObject( NTMS_MEDIA_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_CHANGER, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_CHANGER_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_DRIVE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_DRIVE_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        WsbAffirmHr( changeState( RmsNtmsStateReady ));
        hr = S_OK;

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
            WsbLogEvent( RMS_MESSAGE_NTMS_INITIALIZATION_FAILED, 0, NULL, WsbHrAsString(hr), NULL );
        );


    WsbTraceOut( OLESTR("CRmsNTMS::Initialize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::findFirstNtmsObject(
    IN DWORD objectType,
    IN REFGUID containerId,
    IN WCHAR *objectName,
    IN REFGUID objectId,
    OUT HANDLE *hFindObject,
    OUT LPNTMS_OBJECTINFORMATION pFindObjectData
    )
{

    HRESULT hr = E_FAIL;

    try {
        int maxObjects = 16;  // Initial size of object id array to allocate
        
        LPRMS_NTMS_SEARCH_HANDLE pFind;

        HANDLE hSession = m_SessionHandle;
        DWORD errCode;
        DWORD numberOfObjects = maxObjects;
        LPNTMS_GUID pId = ( containerId == GUID_NULL ) ? NULL : (GUID *)&containerId;
        LPNTMS_GUID  pObjects = NULL;
        NTMS_OBJECTINFORMATION objectInfo;

        WsbAssertPointer( hFindObject );


        if ( INVALID_HANDLE_VALUE == hSession ) {
            WsbThrow( E_UNEXPECTED );
        }

        *hFindObject = NULL;

        memset( &objectInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        pObjects = (LPNTMS_GUID)WsbAlloc( maxObjects*sizeof(NTMS_GUID) );
        WsbAffirmPointer( pObjects );

        // NTMS - enumerate all objects of the given type
        WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
        errCode = EnumerateNtmsObject( hSession, pId, pObjects, &numberOfObjects, objectType, 0 );

        if ( (ERROR_OBJECT_NOT_FOUND == errCode) || (0 == numberOfObjects) ) {  // Don't count on NTMS returning the correct errCode
            WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
        }
        else if ( ERROR_INSUFFICIENT_BUFFER == errCode ) {

            while ( ERROR_INSUFFICIENT_BUFFER == errCode ) {
                // Allocate a new buffer, and retry.
                WsbTrace(OLESTR("CRmsNTMS::findFirstNtmsObject - Reallocating for %d objects @1.\n"), numberOfObjects);
                maxObjects = numberOfObjects;
                LPVOID pTemp = WsbRealloc( pObjects, maxObjects*sizeof(NTMS_GUID) );
                if( !pTemp ) {
                    WsbFree( pObjects );
                    WsbThrow( E_OUTOFMEMORY );
                }
                pObjects = (LPNTMS_GUID)pTemp;

                // NTMS - enumerate all objects of the given type
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                errCode = EnumerateNtmsObject( hSession, pId, pObjects, &numberOfObjects, objectType, 0 );
            }
        }
        WsbAffirmNoError( errCode );

        HANDLE hTemp = (HANDLE)WsbAlloc( sizeof( RMS_NTMS_SEARCH_HANDLE) );
        *hFindObject = hTemp;
        WsbAffirmPointer( *hFindObject );

        pFind = (LPRMS_NTMS_SEARCH_HANDLE)*hFindObject;

        // Initialize the search handle
        if ( objectName ) {
            wcscpy( pFind->FindName, objectName );
        }
        else {
            wcscpy( pFind->FindName, OLESTR("") );
        }

        pFind->FindId           = objectId;
        pFind->FindType         = objectType;
        pFind->Objects          = pObjects;
        pFind->NumberOfObjects  = numberOfObjects;
        pFind->MaxObjects       = maxObjects;
        pFind->Next             = 0;
        pFind->LastError        = NO_ERROR;

        BOOL bFound = FALSE;

        while( pFind->Next < pFind->NumberOfObjects ) {

            objectInfo.dwType = pFind->FindType;
            objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

            // NTMS - Get object information
            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
            errCode = GetNtmsObjectInformation( hSession, &pObjects[pFind->Next++], &objectInfo );
            pFind->LastError = errCode;

            // Media Pools require special handling because they contain other Media Pools
            if ( (NTMS_MEDIA_POOL == pFind->FindType) &&
                (objectInfo.Info.MediaPool.dwNumberOfMediaPools > 0) ) {

                DWORD numberToAdd = objectInfo.Info.MediaPool.dwNumberOfMediaPools;
                do {
                    numberOfObjects = pFind->NumberOfObjects + numberToAdd;

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::findFirstNtmsObject - Reallocating for %d objects @2.\n"), numberOfObjects);
                    maxObjects = numberOfObjects;
                    pObjects = (LPNTMS_GUID)WsbRealloc( pFind->Objects, maxObjects*sizeof(NTMS_GUID) );
                    WsbAffirmAlloc( pObjects );
                    pFind->Objects = pObjects;

                    // NTMS - enumerate all objects of the given type
                    WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                    errCode = EnumerateNtmsObject( hSession,
                        &objectInfo.ObjectGuid, &pObjects[pFind->NumberOfObjects],
                        &numberToAdd, pFind->FindType, 0 );
                } while ( ERROR_INSUFFICIENT_BUFFER == errCode ) ;

                if ( NO_ERROR == errCode ) {
                    pFind->NumberOfObjects += numberToAdd;
                    pFind->MaxObjects = maxObjects;
                }
                else {
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                        OLESTR("EnumerateNtmsObject"),
                        WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                        NULL );
                    WsbAffirmNoError(errCode);
                }
            }

            if ( NO_ERROR == pFind->LastError ) {

                // Now see if it is the one we're looking for

                if ( GUID_NULL != pFind->FindId ) {

                    if ( pFind->FindId == objectInfo.ObjectGuid ) {     // Match the GUID

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }
                }
                else if ( wcslen( pFind->FindName ) > 0 ) {             // Match the Name

                    if ( 0 == wcscmp( pFind->FindName, objectInfo.szName ) ) {

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }

                        break;

                    }

                }
                else {                                                  // Any GUID or Name

                    bFound = TRUE;
                    if ( pFindObjectData != NULL ) {
                        memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                    }
                    break;

                }

            }
            else {
                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                    OLESTR("GetNTMSObjectInformation"),
                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                    NULL );
                WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
            }

        }

        hr = ( bFound ) ? S_OK : RMS_E_NTMS_OBJECT_NOT_FOUND;

    } WsbCatch(hr);

    return hr;
}


HRESULT 
CRmsNTMS::findNextNtmsObject(
    IN HANDLE hFindObject,
    OUT LPNTMS_OBJECTINFORMATION pFindObjectData
    )
{
    HRESULT hr = E_FAIL;

    try {

        HANDLE hSession = m_SessionHandle;
        DWORD errCode;

        LPRMS_NTMS_SEARCH_HANDLE pFind = (LPRMS_NTMS_SEARCH_HANDLE)hFindObject;

        LPNTMS_GUID pObjects = pFind->Objects;

        NTMS_OBJECTINFORMATION objectInfo;

        if ( INVALID_HANDLE_VALUE == hSession ) {
            WsbThrow( E_UNEXPECTED );
        }

        BOOL bFound = FALSE;

        while( pFind->Next < pFind->NumberOfObjects ) {

            objectInfo.dwType = pFind->FindType;
            objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

            // NTMS - get object information of next object
            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
            errCode = GetNtmsObjectInformation( hSession, &pObjects[pFind->Next++], &objectInfo );
            pFind->LastError = errCode;

            // Media Pools require special handling because they contain other Media Pools
            if ( (NTMS_MEDIA_POOL == pFind->FindType) &&
                (objectInfo.Info.MediaPool.dwNumberOfMediaPools > 0) ) {

                DWORD maxObjects;
                DWORD numberOfObjects;
                DWORD numberToAdd = objectInfo.Info.MediaPool.dwNumberOfMediaPools;
                do {
                    numberOfObjects = pFind->NumberOfObjects + numberToAdd;

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::findNextNtmsObject - Reallocating for %d objects.\n"), numberOfObjects);
                    maxObjects = numberOfObjects;
                    pObjects = (LPNTMS_GUID)WsbRealloc( pFind->Objects, maxObjects*sizeof(NTMS_GUID) );
                    WsbAffirmAlloc( pObjects );
                    pFind->Objects = pObjects;

                    // NTMS - enumerate all objects of the given type
                    WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                    errCode = EnumerateNtmsObject( hSession,
                        &objectInfo.ObjectGuid, &pObjects[pFind->NumberOfObjects],
                        &numberToAdd, pFind->FindType, 0 );
                } while ( ERROR_INSUFFICIENT_BUFFER == errCode ) ;

                if ( NO_ERROR == errCode ) {
                    pFind->NumberOfObjects += numberToAdd;
                    pFind->MaxObjects = maxObjects;
                }
                else {
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                        OLESTR("EnumerateNtmsObject"),
                        WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                        NULL );
                    WsbAffirmNoError(errCode);
                }
            }

            if ( NO_ERROR == pFind->LastError ) {

                // Now see if it is the one we're looking for

                if ( GUID_NULL != pFind->FindId ) {

                    if ( pFind->FindId == objectInfo.ObjectGuid ) {     // Match the GUID

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }
                }
                else if ( wcslen( pFind->FindName ) > 0 ) {             // Match the Name

                    if ( 0 == wcscmp( pFind->FindName, objectInfo.szName ) ) {

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }

                }
                else {                                                  // Any GUID or Name

                    bFound = TRUE;
                    if ( pFindObjectData != NULL ) {
                        memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                    }
                    break;

                }

            }
            else {
                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                    OLESTR("GetNTMSObjectInformation"),
                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                    NULL );
                WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
            }
        }

        hr = (bFound) ? S_OK : RMS_E_NTMS_OBJECT_NOT_FOUND;

    } WsbCatch(hr);

    return hr;
}


HRESULT 
CRmsNTMS::findCloseNtmsObject(
    IN HANDLE hFindObject)
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer(hFindObject); // We don't need to assert here... It's possible to call
                                       // findCloseNtmsObject even if nothing was found with
                                       // findFirstNtmsObject.  Skip the free step.
        WsbFree(((LPRMS_NTMS_SEARCH_HANDLE)hFindObject)->Objects);
        WsbFree(hFindObject);

    } WsbCatch(hr);


    return hr;
}


HRESULT 
CRmsNTMS::reportNtmsObjectInformation(
    IN LPNTMS_OBJECTINFORMATION pObjectInfo)
{

    HRESULT hr = S_OK;

    static DWORD lastTypeReported = 0;

    try {
        WsbAssertPointer( pObjectInfo );

        BOOL bHeaders = (lastTypeReported == pObjectInfo->dwType) ? FALSE : TRUE;

        lastTypeReported = pObjectInfo->dwType;

        // Output a header to trace file

        if ( bHeaders ) {
            switch ( pObjectInfo->dwType ) {

            case NTMS_UNKNOWN:
            case NTMS_OBJECT:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_CHANGER:
                break;

            case NTMS_CHANGER_TYPE:
                break;

            case NTMS_COMPUTER:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_DRIVE:
            case NTMS_DRIVE_TYPE:
                break;

            case NTMS_IEDOOR:
            case NTMS_IEPORT:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_LIBRARY:
                break;

            case NTMS_LIBREQUEST:
            case NTMS_LOGICAL_MEDIA:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_MEDIA_POOL:
                WsbTrace( OLESTR("GUID                                   Enabl Type Media Type GUID                        Parent GUID                            A-Pol D-Pol Allocate Physical  Logical Pools Name / Description\n") );
                WsbTrace( OLESTR("====================================== ===== ==== ====================================== ====================================== ===== ===== ======== ======== ======== ===== ========================================\n") );
                break;

            case NTMS_MEDIA_TYPE:

                WsbTrace( OLESTR("GUID                                   Enabl Type Sides RW Name / Description\n") );
                WsbTrace( OLESTR("====================================== ===== ==== ===== == ========================================\n") );
                break;

            case NTMS_PARTITION:
                 break;

            case NTMS_PHYSICAL_MEDIA:
            case NTMS_STORAGESLOT:
            case NTMS_OPREQUEST:
            default:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for object type: %d is not supported\n") );
                break;
            }
        }

        // Convert SYSTEMTIME to FILETIME for output.

        SYSTEMTIME sCreated, sModified;
        FILETIME fCreated, fModified;

        sCreated = pObjectInfo->Created;
        sModified = pObjectInfo->Modified;

        SystemTimeToFileTime(&sCreated, &fCreated);
        SystemTimeToFileTime(&sModified, &fModified);


        switch ( pObjectInfo->dwType ) {

        case NTMS_UNKNOWN:
        case NTMS_OBJECT:
            break;

        case NTMS_CHANGER:

            WsbTrace(OLESTR("Changer %d Information:\n"), pObjectInfo->Info.Changer.Number );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Number.........  %-d\n"), pObjectInfo->Info.Changer.Number );
            WsbTrace(OLESTR("  Changer Type...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Changer.ChangerType) );
            WsbTrace(OLESTR("  Serial Number..  <%-ls>\n"), pObjectInfo->Info.Changer.szSerialNumber );
            WsbTrace(OLESTR("  Revision.......  <%-ls>\n"), pObjectInfo->Info.Changer.szRevision );
            WsbTrace(OLESTR("  Device Name....  <%-ls>\n"), pObjectInfo->Info.Changer.szDeviceName );
            WsbTrace(OLESTR("  SCSI Port......  %-d\n"), pObjectInfo->Info.Changer.ScsiPort );
            WsbTrace(OLESTR("  SCSI Bus.......  %-d\n"), pObjectInfo->Info.Changer.ScsiBus );
            WsbTrace(OLESTR("  SCSI Target....  %-d\n"), pObjectInfo->Info.Changer.ScsiTarget );
            WsbTrace(OLESTR("  SCSI Lun.......  %-d\n"), pObjectInfo->Info.Changer.ScsiLun );
            WsbTrace(OLESTR("  Library.......   %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Changer.Library) );

            break;

        case NTMS_CHANGER_TYPE:
            WsbTrace(OLESTR("Changer Type Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Vendor.........  <%-ls>\n"), pObjectInfo->Info.ChangerType.szVendor );
            WsbTrace(OLESTR("  Product........  <%-ls>\n"), pObjectInfo->Info.ChangerType.szProduct );
            WsbTrace(OLESTR("  Device Type....  %-d\n"), pObjectInfo->Info.ChangerType.DeviceType );
            break;

        case NTMS_COMPUTER:
            break;

        case NTMS_DRIVE:
            WsbTrace(OLESTR("Drive %d Information:\n"), pObjectInfo->Info.Drive.Number );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Number.........  %-d\n"), pObjectInfo->Info.Drive.Number );
            WsbTrace(OLESTR("  State..........  %-d\n"), pObjectInfo->Info.Drive.State );
            WsbTrace(OLESTR("  Drive Type.....  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.DriveType) );
            WsbTrace(OLESTR("  Device Name....  <%-ls>\n"), pObjectInfo->Info.Drive.szDeviceName );
            WsbTrace(OLESTR("  Serial Number..  <%-ls>\n"), pObjectInfo->Info.Drive.szSerialNumber );
            WsbTrace(OLESTR("  Revision.......  <%-ls>\n"), pObjectInfo->Info.Drive.szRevision );
            WsbTrace(OLESTR("  SCSI Port......  %-d\n"), pObjectInfo->Info.Drive.ScsiPort );
            WsbTrace(OLESTR("  SCSI Bus.......  %-d\n"), pObjectInfo->Info.Drive.ScsiBus );
            WsbTrace(OLESTR("  SCSI Target....  %-d\n"), pObjectInfo->Info.Drive.ScsiTarget );
            WsbTrace(OLESTR("  SCSI Lun.......  %-d\n"), pObjectInfo->Info.Drive.ScsiLun );
            WsbTrace(OLESTR("  Mount Count....  %-d\n"), pObjectInfo->Info.Drive.dwMountCount );
            WsbTrace(OLESTR("  Last Cleaned...  %02d/%02d/%02d %02d:%02d:%02d.%03d\n"),
                pObjectInfo->Info.Drive.LastCleanedTs.wMonth,
                pObjectInfo->Info.Drive.LastCleanedTs.wDay,
                pObjectInfo->Info.Drive.LastCleanedTs.wYear,
                pObjectInfo->Info.Drive.LastCleanedTs.wHour,
                pObjectInfo->Info.Drive.LastCleanedTs.wMinute,
                pObjectInfo->Info.Drive.LastCleanedTs.wSecond,
                pObjectInfo->Info.Drive.LastCleanedTs.wMilliseconds );
            WsbTrace(OLESTR("  Partition......  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.SavedPartitionId) );
            WsbTrace(OLESTR("  Library........  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.Library) );
            break;

        case NTMS_DRIVE_TYPE:
            WsbTrace(OLESTR("Drive Type Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Vendor.........  <%-ls>\n"), pObjectInfo->Info.DriveType.szVendor );
            WsbTrace(OLESTR("  Product........  <%-ls>\n"), pObjectInfo->Info.DriveType.szProduct );
            WsbTrace(OLESTR("  Number of Heads  %-d\n"), pObjectInfo->Info.DriveType.NumberOfHeads );
            WsbTrace(OLESTR("  Device Type....  %-d\n"), pObjectInfo->Info.DriveType.DeviceType );
            break;

        case NTMS_IEDOOR:
        case NTMS_IEPORT:
            break;

        case NTMS_LIBRARY:
            WsbTrace(OLESTR("Library Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Library Type...  %-d\n"), pObjectInfo->Info.Library.LibraryType );
            WsbTrace(OLESTR("  CleanerSlot....  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Library.CleanerSlot) );
            WsbTrace(OLESTR("  CleanerSlotD...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Library.CleanerSlotDefault) );
            WsbTrace(OLESTR("  Can Clean......  %-ls\n"), WsbBoolAsString(pObjectInfo->Info.Library.LibrarySupportsDriveCleaning) );
            WsbTrace(OLESTR("  Has Bar Code...  %-ls\n"), WsbBoolAsString(pObjectInfo->Info.Library.BarCodeReaderInstalled) );
            WsbTrace(OLESTR("  Inventory Method %-d\n"), pObjectInfo->Info.Library.InventoryMethod );
            WsbTrace(OLESTR("  Cleans Remaining %-d\n"), pObjectInfo->Info.Library.dwCleanerUsesRemaining );
            WsbTrace(OLESTR("  Drives.........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfDrives,
                pObjectInfo->Info.Library.FirstDriveNumber);
            WsbTrace(OLESTR("  Slots..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfSlots,
                pObjectInfo->Info.Library.FirstSlotNumber);
            WsbTrace(OLESTR("  Doors..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfDoors,
                pObjectInfo->Info.Library.FirstDoorNumber);
            WsbTrace(OLESTR("  Ports..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfPorts,
                pObjectInfo->Info.Library.FirstPortNumber);
            WsbTrace(OLESTR("  Changers.......  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfChangers,
                pObjectInfo->Info.Library.FirstChangerNumber);
            WsbTrace(OLESTR("  Media Count....  %-d\n"), pObjectInfo->Info.Library.dwNumberOfMedia );
            WsbTrace(OLESTR("  Media Types....  %-d\n"), pObjectInfo->Info.Library.dwNumberOfMediaTypes );
            WsbTrace(OLESTR("  Requests.......  %-d\n"), pObjectInfo->Info.Library.dwNumberOfLibRequests );
            break;

        case NTMS_LIBREQUEST:
        case NTMS_LOGICAL_MEDIA:
            break;

        case NTMS_MEDIA_POOL:
            {
                // We need some temporaries since WsbGuidAsString() uses static memory to store string.
                CWsbStringPtr g1 = pObjectInfo->ObjectGuid;
                CWsbStringPtr g2 = pObjectInfo->Info.MediaPool.MediaType;
                CWsbStringPtr g3 = pObjectInfo->Info.MediaPool.Parent;

                WsbTrace( OLESTR("%ls %5ls %4d %ls %ls %5d %5d %8d %8d %8d %5d <%ls> / <%ls>\n"),
                                (WCHAR *)g1,
                                WsbBoolAsString(pObjectInfo->Enabled),
                                pObjectInfo->Info.MediaPool.PoolType,
                                (WCHAR *)g2,
                                (WCHAR *)g3,
                                pObjectInfo->Info.MediaPool.AllocationPolicy,
                                pObjectInfo->Info.MediaPool.DeallocationPolicy,
                                pObjectInfo->Info.MediaPool.dwMaxAllocates,
                                pObjectInfo->Info.MediaPool.dwNumberOfPhysicalMedia,
                                pObjectInfo->Info.MediaPool.dwNumberOfLogicalMedia,
                                pObjectInfo->Info.MediaPool.dwNumberOfMediaPools,
                                pObjectInfo->szName,
                                pObjectInfo->szDescription );
            }
            break;

        case NTMS_MEDIA_TYPE:
            WsbTrace( OLESTR("%ls %5ls %4d %5d %2d <%ls> / <%ls>\n"),
                            WsbGuidAsString(pObjectInfo->ObjectGuid),
                            WsbBoolAsString(pObjectInfo->Enabled),
                            pObjectInfo->Info.MediaType.MediaType,
                            pObjectInfo->Info.MediaType.NumberOfSides,
                            pObjectInfo->Info.MediaType.ReadWriteCharacteristics,
                            pObjectInfo->szName,
                            pObjectInfo->szDescription );
            break;

        case NTMS_PARTITION:
            WsbTrace(OLESTR("Partion Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  PhysicalMedia..  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Partition.PhysicalMedia));
            WsbTrace(OLESTR("  LogicalMedia...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Partition.LogicalMedia));
            WsbTrace(OLESTR("  State..........  %-d\n"), pObjectInfo->Info.Partition.State);
            WsbTrace(OLESTR("  Side...........  %-d\n"), pObjectInfo->Info.Partition.Side);
            WsbTrace(OLESTR("  OmidLabelIdLen   %-d\n"), pObjectInfo->Info.Partition.dwOmidLabelIdLength);
            WsbTrace(OLESTR("  OmidLableId:\n"));
            WsbTraceBuffer(pObjectInfo->Info.Partition.dwOmidLabelIdLength, pObjectInfo->Info.Partition.OmidLabelId);
            WsbTrace(OLESTR("  OmidLabelType..  %-ls\n"), pObjectInfo->Info.Partition.szOmidLabelType);
            WsbTrace(OLESTR("  OmidLabelInfo..  %-ls\n"), pObjectInfo->Info.Partition.szOmidLabelInfo);
            WsbTrace(OLESTR("  MountCount.....  %-d\n"), pObjectInfo->Info.Partition.dwMountCount);
            WsbTrace(OLESTR("  AllocateCount..  %-d\n"), pObjectInfo->Info.Partition.dwAllocateCount);
            WsbTrace(OLESTR("  Capacity.......  %-I64d\n"), pObjectInfo->Info.Partition.Capacity.QuadPart);
            break;

        case NTMS_PHYSICAL_MEDIA:
        case NTMS_STORAGESLOT:
        case NTMS_OPREQUEST:
        default:
            break;
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CRmsNTMS::getNtmsSupportFromRegistry(
    OUT DWORD *pNTMSSupportValue)
/*++

Routine Description:

    Determines if NTMS flag is set in the Registry.

Arguments:

    pNTMSSupportValue   - Receives the actual value of the regstry key value.  Any non-zero
                          values indicates NTMS support.

Return Values:

    S_OK                - NTMS support flag is on.
    S_FALSE             - NTMS support flag is off.

--*/
{
    HRESULT hr = S_OK;
    DWORD val = RMS_DEFAULT_NTMS_SUPPORT;

    WsbTraceIn(OLESTR("CRmsNTMS::getNtmsSupportFromRegistry"), OLESTR(""));

    try {
        DWORD   sizeGot;
        const int cDataSizeToGet = 100;
        OLECHAR dataString[cDataSizeToGet];
        OLECHAR *stopString;

        //
        // Get the value.  If the key doesn't exists, the default value is used.
        //

        try {

            WsbAffirmHrOk(WsbEnsureRegistryKeyExists(NULL, RMS_REGISTRY_STRING));
            WsbAffirmHrOk(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NTMS_SUPPORT,
                dataString, cDataSizeToGet, &sizeGot));
            val = wcstoul(dataString,  &stopString, 10);

        } WsbCatch(hr);

        if (pNTMSSupportValue != NULL) {
            *pNTMSSupportValue = val;
        }

        hr = (val) ? S_OK : S_FALSE;

    } WsbCatchAndDo( hr,
            hr = S_FALSE;
        );


    WsbTraceOut(OLESTR("CRmsNTMS::getNtmsSupportFromRegistry"), OLESTR("hr = <%ls>, val = <%ld>"), WsbHrAsString(hr), val);

    return hr;
}


HRESULT 
CRmsNTMS::beginSession(void)
/*++

Implements:

    CRmsNTMS::beginSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsNTMS::beginSession"), OLESTR("") );

    try {

        WsbAffirmHrOk(IsInstalled());
        WsbAffirmHrOk(endSession());        // clear the old session
        WsbAffirmHrOk(waitUntilReady());    // starts a new session
        //WsbAffirmHrOk(waitForScratchPool());

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::beginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::endSession(void)
/*++

Implements:

    CRmsNTMS::endSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsNTMS::endSession"), OLESTR("") );

    try {

        if ( m_SessionHandle != INVALID_HANDLE_VALUE ) {
            // NTMS - Close session
            WsbTraceAlways(OLESTR("CloseNtmsSession()\n"));
            WsbAffirmNoError(CloseNtmsSession(m_SessionHandle));
        }

    } WsbCatchAndDo(hr,
            switch (HRESULT_CODE(hr)) {
            case ERROR_CONNECTION_UNAVAIL:
            case ERROR_INVALID_HANDLE:
                break;
            default:
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                    OLESTR("CloseNtmsSession"), OLESTR("Undocumented Error: "),
                    WsbHrAsString(hr), NULL);
                break;
            }
        );

    m_SessionHandle = INVALID_HANDLE_VALUE;
    hr = S_OK;

    WsbTraceOut( OLESTR("CRmsNTMS::endSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT
CRmsNTMS::waitUntilReady(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::waitUntilReady"), OLESTR(""));

    try {

        int retry = 360; // number of retries

        // Retrieve the NotificationWaitTime parameter
        DWORD size;
        OLECHAR tmpString[256];
        DWORD notificationWaitTime = RMS_DEFAULT_NOTIFICATION_WAIT_TIME;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NOTIFICATION_WAIT_TIME, tmpString, 256, &size))) {
            notificationWaitTime = wcstol(tmpString, NULL, 10);
            WsbTrace(OLESTR("NotificationWaitTime is %d milliseconds.\n"), notificationWaitTime);
        }


        do {
            // NTMS - Open session
            WsbTraceAlways(OLESTR("OpenNtmsSession()\n"));

            CWsbStringPtr appName;
            WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

            m_SessionHandle = OpenNtmsSession(NULL, (WCHAR *) appName, 0);
            if ( m_SessionHandle != INVALID_HANDLE_VALUE ) {
                break;
            }
            else {
                hr = HRESULT_FROM_WIN32(GetLastError());
                switch (HRESULT_CODE(hr)) {
                case ERROR_NOT_READY:
                    if ( retry > 0 ) {
                        WsbTrace(OLESTR("Waiting for NTMS to come ready - Seconds remaining before timeout: %d\n"), retry*notificationWaitTime/1000);
                        Sleep(notificationWaitTime);
                        hr = S_OK;
                    }
                    else {
                        //
                        // This is the last try, so log the failure.
                        //
                        WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED,
                            0, NULL, WsbHrAsString(hr), NULL);
                        WsbThrow(RMS_E_NTMS_NOT_CONNECTED);
                    }
                    break;

                case ERROR_INVALID_COMPUTERNAME:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NO_NETWORK:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED,
                        0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsSession"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                    break;
                }
            }
        } while( retry-- > 0 ) ;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::waitUntilReady"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::waitForScratchPool(void)
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    HANDLE hNotify = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CRmsNTMS::waitForScratchPool"), OLESTR(""));

    try {

        int retry = 60; // number of retries

        // Retrieve the NotificationWaitTime parameter
        DWORD size;
        OLECHAR tmpString[256];
        DWORD notificationWaitTime = RMS_DEFAULT_NOTIFICATION_WAIT_TIME;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NOTIFICATION_WAIT_TIME, tmpString, 256, &size))) {
            notificationWaitTime = wcstol(tmpString, NULL, 10);
            WsbTrace(OLESTR("NotificationWaitTime is %d milliseconds.\n"), notificationWaitTime);
        }

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbThrow(E_UNEXPECTED);
        }

        HANDLE hSession = m_SessionHandle;

        NTMS_OBJECTINFORMATION objectInfo;
        NTMS_OBJECTINFORMATION scratchInfo;
        NTMS_NOTIFICATIONINFORMATION notifyInfo;
        HANDLE hFind = NULL;

        BOOL bFound = FALSE;

        // TODO: We really should wait around until all libraries are classified.
        DWORD mediaCount = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            mediaCount += objectInfo.Info.Library.dwNumberOfMedia;
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        if ( 0 == mediaCount) {
            WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
        }

        /*
        // First see if there is any media to be classified, if not we don't bother waiting around for
        // nothing to happen.
        hr = findFirstNtmsObject( NTMS_PHYSICAL_MEDIA, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        WsbAffirmHrOk( hr );
        findCloseNtmsObject( hFind );
        */

        // NTMS - Open notification channel
        WsbTraceAlways(OLESTR("OpenNtmsNotification()\n"));
        hNotify = OpenNtmsNotification(hSession, NTMS_MEDIA_POOL);
        if ( INVALID_HANDLE_VALUE == hNotify ) {
            err1 = GetLastError();
            WsbAffirmNoError(err1);
            WsbThrow(E_UNEXPECTED);
        }

        do {
            err2 = NO_ERROR;
            //
            // Count the number of NTMS Scratch pools, and if
            // there are more than one, we return.  If not,
            // we wait until the root level scratch pool object
            // is updated.
            //
            // More that one scratch media pools implies that at
            // least one unit of media was classified.  We don't
            // know until we complete the initialization if it
            // was one of the media types supported by RemoteStorage.
            //
            int count = 0;

            hr = findFirstNtmsObject( NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
            while( S_OK == hr ) {
                if ( NTMS_POOLTYPE_SCRATCH == objectInfo.Info.MediaPool.PoolType ) {
                    count++;
                    if ( count == 1 ) {
                        // Assueme this is the rool pool and one we'll check on for updates
                        // If the assumption is wrong count will end up > 1.
                        memcpy(&scratchInfo, &objectInfo, sizeof(NTMS_OBJECTINFORMATION));
                    }
                }
                hr = findNextNtmsObject( hFind, &objectInfo );
            }
            findCloseNtmsObject( hFind );

            if ( count > 1 ) {
                bFound = TRUE;
                hr = S_OK;
                break; // Normal exit.
            }

            if ( count == 0 ) {
                WsbThrow(E_UNEXPECTED);
            }

            // Just one scratch pool detected... wait until a media-type specific pool
            // is added root scratch pool.  This will show up as an update to the root
            // scratch pool.

            do {

                WsbTrace(OLESTR("Waiting for NTMS scratch pool - Seconds remaining before timeout: %d\n"), retry*notificationWaitTime/1000);

                // NTMS - Wait for notification
                WsbTraceAlways(OLESTR("WaitForNtmsNotification()\n"));
                err2 = WaitForNtmsNotification(hNotify, &notifyInfo, notificationWaitTime);
                if ( NO_ERROR == err2 ) {
                    //
                    // Note: With this notification mechanism, chances
                    //       are slim that we got notified on the object we really
                    //       care about.
                    //
                    WsbTrace(OLESTR("Processing: <%d> %ls\n"), notifyInfo.dwOperation, WsbGuidAsString(notifyInfo.ObjectId));
                    if ( notifyInfo.ObjectId != scratchInfo.ObjectGuid ) {
                        WsbTrace(OLESTR("Wrong object, try again...\n"));
                        continue; // skip this one
                    }
                    else {
                        if ( NTMS_OBJ_UPDATE != notifyInfo.dwOperation ) {
                            WsbTrace(OLESTR("Wrong operation, try again...\n"));
                            continue; // skip this one
                        }
                        else {
                            WsbTrace(OLESTR("Scratch pool update detected.\n"));
                            break;  // A scratch pool may have inserted, go check it out...
                        }
                    }
                }
                else if ( ERROR_TIMEOUT != err2 && ERROR_NO_DATA != err2 ) {
                    WsbAffirmNoError(err2);
                }
                retry--;
            } while( (retry > 0) && (!bFound) );
        } while( (retry > 0) && (!bFound) );

        // NTMS - Close notification channel
        WsbTraceAlways(OLESTR("CloseNtmsNotification()\n"));
        err3 = CloseNtmsNotification(hNotify);
        WsbAffirmNoError(err3);

        if ( !bFound ) {
            hr = RMS_E_RESOURCE_UNAVAILABLE;
        }

    } WsbCatchAndDo(hr,

            if ( hNotify != INVALID_HANDLE_VALUE ) {
                // NTMS - Close notification channel
                WsbTraceAlways(OLESTR("CloseNtmsNotification()\n"));
                err3 = CloseNtmsNotification(hNotify);
            }

            if (err1 != NO_ERROR) {
                // OpenNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            if (err2 != NO_ERROR) {
                // WaitForNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_TIMEOUT:
                case ERROR_NO_DATA:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            if (err3 != NO_ERROR) {
                // CloseNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_DATABASE_FAILURE:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CloseNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CloseNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::waitForScratchPool"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::storageMediaTypeToRmsMedia(
    IN NTMS_MEDIATYPEINFORMATION *pMediaTypeInfo,
    OUT RmsMedia *pTranslatedMediaType)
{
    HRESULT hr = S_OK;

    DWORD size;
    OLECHAR tmpString[256];

    // Media type is the main criteria
    WsbAssertPointer(pMediaTypeInfo);
    STORAGE_MEDIA_TYPE mediaType = (STORAGE_MEDIA_TYPE)(pMediaTypeInfo->MediaType);

    DWORD tapeEnabled = RMS_DEFAULT_TAPE;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_TAPE, tmpString, 256, &size))) {
        // Get the value.
        tapeEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD opticalEnabled = RMS_DEFAULT_OPTICAL;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_OPTICAL, tmpString, 256, &size))) {
        // Get the value.
        opticalEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD dvdEnabled = RMS_DEFAULT_DVD;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DVD, tmpString, 256, &size))) {
        // Get the value.
        dvdEnabled = wcstol(tmpString, NULL, 10);
    }

    switch ( mediaType ) {

    case DDS_4mm:                   // Tape - DAT DDS1,2,... (all vendors) (0x20)
        *pTranslatedMediaType = (tapeEnabled) ? RmsMedia4mm : RmsMediaUnknown; 
        break;

    case MiniQic:                   // Tape - miniQIC Tape
    case Travan:                    // Tape - Travan TR-1,2,3,...
    case QIC:                       // Tape - QIC
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case MP_8mm:                    // Tape - 8mm Exabyte Metal Particle
    case AME_8mm:                   // Tape - 8mm Exabyte Advanced Metal Evap
    case AIT1_8mm:                  // Tape - 8mm Sony AIT1
        *pTranslatedMediaType = (tapeEnabled) ? RmsMedia8mm : RmsMediaUnknown; 
        break;

    case DLT:                       // Tape - DLT Compact IIIxt: IV
        *pTranslatedMediaType = (tapeEnabled) ? RmsMediaDLT : RmsMediaUnknown; 
        break;

    case NCTP:                      // Tape - Philips NCTP
    case IBM_3480:                  // Tape - IBM 3480
    case IBM_3490E:                 // Tape - IBM 3490E
    case IBM_Magstar_3590:          // Tape - IBM Magstar 3590
    case IBM_Magstar_MP:            // Tape - IBM Magstar MP
    case STK_DATA_D3:               // Tape - STK Data D3
    case SONY_DTF:                  // Tape - Sony DTF
    case DV_6mm:                    // Tape - 6mm Digital Video
    case DMI:                       // Tape - Exabyte DMI and compatibles
    case SONY_D2:                   // Tape - Sony D2S and D2L
    case CLEANER_CARTRIDGE:         // Cleaner - All Drive types that support Drive Cleaners
    case CD_ROM:                    // Opt_Disk - CD
    case CD_R:                      // Opt_Disk - CD-Recordable (Write Once)
    case CD_RW:                     // Opt_Disk - CD-Rewriteable
    case DVD_ROM:                   // Opt_Disk - DVD-ROM
    case DVD_R:                     // Opt_Disk - DVD-Recordable (Write Once)
    case MO_5_WO:                   // Opt_Disk - MO 5.25" Write Once
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case DVD_RW:                    // Opt_Disk - DVD-Rewriteable
        *pTranslatedMediaType = (dvdEnabled) ? RmsMediaDVD : RmsMediaUnknown;
        break;

    case MO_5_RW:                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    case MO_3_RW:                   // Opt_Disk - 3.5" Rewriteable MO Disk
    case MO_5_LIMDOW:               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    case PC_5_RW:                   // Opt_Disk - Phase Change 5.25" Rewriteable
    case PD_5_RW:                   // Opt_Disk - PhaseChange Dual Rewriteable
    case PINNACLE_APEX_5_RW:        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    case NIKON_12_RW:               // Opt_Disk - Nikon 12" Rewriteable
        *pTranslatedMediaType = (opticalEnabled) ? RmsMediaOptical : RmsMediaUnknown; 
        break;

    case PC_5_WO:                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    case ABL_5_WO:                  // Opt_Disk - Ablative 5.25" Write Once Optical
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case SONY_12_WO:                // Opt_Disk - Sony 12" Write Once
    case PHILIPS_12_WO:             // Opt_Disk - Philips/LMS 12" Write Once
    case HITACHI_12_WO:             // Opt_Disk - Hitachi 12" Write Once
    case CYGNET_12_WO:              // Opt_Disk - Cygnet/ATG 12" Write Once
    case KODAK_14_WO:               // Opt_Disk - Kodak 14" Write Once
    case MO_NFR_525:                // Opt_Disk - Near Field Recording (Terastor)
    case IOMEGA_ZIP:                // Mag_Disk - Iomega Zip
    case IOMEGA_JAZ:                // Mag_Disk - Iomega Jaz
    case SYQUEST_EZ135:             // Mag_Disk - Syquest EZ135
    case SYQUEST_EZFLYER:           // Mag_Disk - Syquest EzFlyer
    case SYQUEST_SYJET:             // Mag_Disk - Syquest SyJet
    case AVATAR_F2:                 // Mag_Disk - 2.5" Floppy
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case RemovableMedia:    // This is reported on stand-alone optical drives.
    default:
        // Check RSM characteristics for Rewriteable Disk
        if ((pMediaTypeInfo->ReadWriteCharacteristics == NTMS_MEDIARW_REWRITABLE) &&
            (pMediaTypeInfo->DeviceType == FILE_DEVICE_DISK)) {
            *pTranslatedMediaType = (opticalEnabled) ? RmsMediaOptical : RmsMediaUnknown; 
        } else  {
            // Not a rewritable disk and not one of the supported tape types...
            *pTranslatedMediaType = RmsMediaUnknown;
        }
        break;
    }

    if ((*pTranslatedMediaType == RmsMediaUnknown) &&
        (pMediaTypeInfo->DeviceType == FILE_DEVICE_TAPE)) {
        // Check in the Registry whether there are additional tapes that we need to support
        ULONG *pTypes= NULL;
        ULONG uTypes = 0;

        if (SUCCEEDED(WsbGetRegistryValueUlongAsMultiString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_ADDITIONAL_TAPE, &pTypes, &uTypes))) {
            // Compare Registry types to the media type we have
            for (ULONG u=0; u<uTypes; u++) {
                if ((STORAGE_MEDIA_TYPE)(pTypes[u]) == mediaType) {
                    // Support it !!
                    WsbTraceAlways(OLESTR("CRmsNTMS::storageMediaTypeToRmsMedia: Registry asks to support tape type %lu\n"),
                                pTypes[u]);

                    *pTranslatedMediaType = RmsMediaTape;

                    break;
                }
            }
        }

        if (pTypes != NULL) {
            WsbFree(pTypes);
            pTypes = NULL;
        }
    }

    return hr;
}


HRESULT
CRmsNTMS::createMediaPools(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::createMediaPools"), OLESTR(""));

    try {

        HANDLE hSession;
        NTMS_GUID rootPoolId = GUID_NULL;

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        hSession = m_SessionHandle;

        try {

            // NTMS - Create Application Media Pool.
            WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));

            WsbAffirmNoError(CreateNtmsMediaPool(hSession, REMOTE_STORAGE_APP_NAME, NULL, NTMS_OPEN_ALWAYS, NULL, &rootPoolId));

            // Now  set access permissions on the pool: turn off ordinary users access
            WsbAffirmHrOk(setPoolDACL(&rootPoolId, DOMAIN_ALIAS_RID_USERS, REMOVE_ACE_MASK_BITS,NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS));

        } WsbCatchAndDo(hr,
                switch(HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_NAME:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_ALREADY_EXISTS:
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CreateNtmsMediaPool"), OLESTR(""),
                        WsbHrAsString(hr),
                        NULL );
                    break;
                default:
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CreateNtmsMediaPool"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr),
                        NULL );
                    break;
                }
                WsbThrow(hr);
            );

        //
        // Only one of the following should be executed, comment out the other.
        //
        WsbAffirmHr( createMediaPoolForEveryMediaType(rootPoolId) );    // New way                        
        /*
        WsbAffirmHr( replicateScratchMediaPool(rootPoolId) );           // Old way
        */

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::createMediaPools"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



HRESULT
CRmsNTMS::replicateScratchMediaPool(
    IN REFGUID /*rootPoolId*/)
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsNTMS::replicateScratchMediaPool"), OLESTR(""));

    try {

        HANDLE                  hSession;
        DWORD                   errCode;
        NTMS_OBJECTINFORMATION  mediaTypeInfo;
        NTMS_OBJECTINFORMATION  mediaPoolInfo;
        HANDLE                  hFind = NULL;
        NTMS_GUID               poolId = GUID_NULL;


        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        hSession = m_SessionHandle;

        // For each media pool in the scratch pool create an application specific pool.

        hr = findFirstNtmsObject( NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFind, &mediaPoolInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &mediaPoolInfo );
            poolId = GUID_NULL;

            try {

                //  Set up application specific NTMS Media Pools.  One for each compatible type.
                //
                //  To get here we had to already detect a media-type specific scratch pool
                //  in waitForScratchPool()

                if ( NTMS_POOLTYPE_SCRATCH == mediaPoolInfo.Info.MediaPool.PoolType &&
                     0 == mediaPoolInfo.Info.MediaPool.dwNumberOfMediaPools ) {

                    // This is a base level scratch media pool.
                    // Create a similar pool for application specific use.

                    CWsbStringPtr name = REMOTE_STORAGE_APP_NAME;
                    name.Append( OLESTR("\\") );
                    name.Append( mediaPoolInfo.szName );

                    NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

                    // We need more information about the media type.

                    memset( &mediaTypeInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                    mediaTypeInfo.dwType = NTMS_MEDIA_TYPE;
                    mediaTypeInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                    // NTMS - Get Media Pool Information
                    WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                    errCode = GetNtmsObjectInformation( hSession, &mediaTypeId, &mediaTypeInfo );
                    if ( errCode != NO_ERROR ) {

                        WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                            OLESTR("GetNtmsObjectInformation"),
                            WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                            NULL );

                        WsbThrow( E_UNEXPECTED );

                    }

                    // Translate the NTMS media type into something understood by RMS
                    RmsMedia translatedMediaType;
                    storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                    if ( translatedMediaType != RmsMediaUnknown ) {

                        // This something that Remote Storage can deal with

                        CWsbBstrPtr mediaSetName = RMS_UNDEFINED_STRING;
                        CWsbBstrPtr mediaSetDesc = RMS_UNDEFINED_STRING;
                        BOOL mediaSetIsEnabled = FALSE;

                        // NTMS - Create Application Media Pool.
                        WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));
                        errCode = CreateNtmsMediaPool( hSession, (WCHAR *) name, &mediaTypeId, NTMS_CREATE_NEW, NULL, &poolId );

                        if ( ERROR_ALREADY_EXISTS == errCode ) {

                            // We still need the poolId of the existing pool.

                            // NTMS - Create Application Media Pool.
                            WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));
                            errCode = CreateNtmsMediaPool( hSession, (WCHAR *)name, &mediaTypeId, NTMS_OPEN_EXISTING, NULL, &poolId );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("CreateNtmsMediaPool"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );
                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else if ( NO_ERROR == errCode ) {

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbAssert( NTMS_POOLTYPE_APPLICATION == mediaPoolInfo.Info.MediaPool.PoolType, E_UNEXPECTED );

                            // Set media pool parameters

                            // Aallocation/deallocation policy
                            mediaPoolInfo.Info.MediaPool.AllocationPolicy = NTMS_ALLOCATE_FROMSCRATCH;
                            mediaPoolInfo.Info.MediaPool.DeallocationPolicy = 0;

                            // Max number of allocates per media
                            mediaPoolInfo.Info.MediaPool.dwMaxAllocates = 5;// Just a few... we automatically
                                                                            //   deallocate media if there's
                                                                            //   problem with scratch mount
                                                                            //   operation.
                                                                            // NOTE:  This can be overridden using
                                                                            //   the NTMS GUI.

                            // NTMS - Set Media Pool Information.
                            WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                            errCode = SetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("SetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else {

                            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                OLESTR("CreateNtmsMediaPool"),
                                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                NULL );

                            WsbThrow( E_UNEXPECTED );

                        }

                        // Now we have an NTMS media pool for our specific use.  Now expose it
                        // through the RMS interface by creating a CRmsMediaSet.

                        if ( poolId != GUID_NULL ) {
                            CComPtr<IRmsMediaSet> pMediaSet;

                            // Find the RmsMediaSet with the same id, or create a new one.
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr( pServer->CreateObject( poolId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet ) );

                            WsbTrace(OLESTR("CRmsNTMS::replicateScratchMediaPool - type %d CRmsMediaSet created.\n"), translatedMediaType);

                            WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetNTMS ) );
                            WsbAffirmHr( pMediaSet->SetMediaSupported( translatedMediaType ) );

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pMediaSet;
                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - MediaSet: <%ls/%ls>; Enabled: %ls\n"),
                                WsbQuickString(WsbStringAsString(mediaSetName)),
                                WsbQuickString(WsbStringAsString(mediaSetDesc)),
                                WsbQuickString(WsbBoolAsString(mediaSetIsEnabled)));
                            WsbAffirmHr(pObject->SetName(mediaSetName));
                            WsbAffirmHr(pObject->SetDescription(mediaSetDesc));
                            if (!mediaSetIsEnabled) {
                                WsbAffirmHr(pObject->Disable(E_FAIL));
                            }

                            if (S_OK == IsMediaCopySupported(poolId)) {
                                WsbAffirmHr( pMediaSet->SetIsMediaCopySupported(TRUE));
                            }
                            hr = pMediaSet->IsMediaCopySupported();

                            WsbTrace(OLESTR("CRmsNTMS::replicateScratchMediaPool - media copies are %ls.\n"),
                                (S_OK == pMediaSet->IsMediaCopySupported()) ? OLESTR("enabled") : OLESTR("disabled"));

                        }
                    }
                }

            } WsbCatch(hr);

            hr = findNextNtmsObject( hFind, &mediaPoolInfo );
        } // while finding media pools
        findCloseNtmsObject( hFind );

        hr = S_OK;

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::replicateScratchMediaPool"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT
CRmsNTMS::createMediaPoolForEveryMediaType(
    IN REFGUID /*rootPoolId*/)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType"), OLESTR(""));

    try {
        DWORD errCode;

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        HANDLE hFindLib = NULL;
        NTMS_OBJECTINFORMATION libraryInfo;

        BOOL bSupportedLib = FALSE;
        m_dwNofLibs = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY, GUID_NULL, NULL, GUID_NULL, &hFindLib, &libraryInfo);
        while( S_OK == hr ) {
            bSupportedLib = FALSE;

            reportNtmsObjectInformation( &libraryInfo );

            if (libraryInfo.Info.Library.dwNumberOfMediaTypes > 0) {

                HANDLE hFindType = NULL;
                NTMS_OBJECTINFORMATION mediaTypeInfo;

                hr = findFirstNtmsObject( NTMS_MEDIA_TYPE, libraryInfo.ObjectGuid, NULL, GUID_NULL, &hFindType, &mediaTypeInfo);
                while( S_OK == hr ) {
                    //
                    // Create an application Media Pool for each type
                    //

                    NTMS_GUID poolId;

                    // This is a base level scratch media pool.
                    // Create a similar pool for application specific use.

                    CWsbStringPtr name = REMOTE_STORAGE_APP_NAME;
                    name.Append( OLESTR("\\") );
                    name.Append( mediaTypeInfo.szName );

                    NTMS_GUID mediaTypeId = mediaTypeInfo.ObjectGuid;

                    // Translate the NTMS media type into something understood by RMS
                    RmsMedia translatedMediaType;
                    storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                    if ( translatedMediaType != RmsMediaUnknown ) {

                        // This something that Remote Storage can deal with

                        CWsbBstrPtr mediaSetName = RMS_UNDEFINED_STRING;
                        CWsbBstrPtr mediaSetDesc = RMS_UNDEFINED_STRING;
                        BOOL mediaSetIsEnabled = FALSE;

                        // NTMS - Create Application Media Pool.
                        WsbTraceAlways(OLESTR("CreateNtmsMediaPool(<%ls>) - Try New.\n"), (WCHAR *) name);
                        errCode = CreateNtmsMediaPool( hSession, (WCHAR *) name, &mediaTypeId, NTMS_CREATE_NEW, NULL, &poolId );

                        if ( ERROR_ALREADY_EXISTS == errCode ) {
                            WsbTraceAlways(OLESTR("MediaPool <%ls> already exists.\n"), (WCHAR *) name);

                            // We still need the poolId of the existing pool.

                            // NTMS - Create Application Media Pool.
                            WsbTraceAlways(OLESTR("CreateNtmsMediaPool(<%ls>) - Try Existing.\n"), (WCHAR *) name);
                            errCode = CreateNtmsMediaPool( hSession, (WCHAR *)name, &mediaTypeId, NTMS_OPEN_EXISTING, NULL, &poolId );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("CreateNtmsMediaPool"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbTraceAlways(OLESTR("Media Pool %ls detected.\n"), WsbGuidAsString(poolId));

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else if ( NO_ERROR == errCode ) {
                            WsbTraceAlways(OLESTR("MediaPool <%ls> created.\n"), (WCHAR *) name);

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbAssert( NTMS_POOLTYPE_APPLICATION == mediaPoolInfo.Info.MediaPool.PoolType, E_UNEXPECTED );

                            // Set media pool parameters

                            // Aallocation/deallocation policy
                            mediaPoolInfo.Info.MediaPool.AllocationPolicy = NTMS_ALLOCATE_FROMSCRATCH;
                            mediaPoolInfo.Info.MediaPool.DeallocationPolicy = 0;

                            // Max number of allocates per media
                            mediaPoolInfo.Info.MediaPool.dwMaxAllocates = 0;// Unlimited... we automatically
                                                                            //   deallocate media if there's
                                                                            //   problem with scratch mount
                                                                            //   operation.
                                                                            // TODO:  Verify that NTMS always allocates
                                                                            //        media with the lowest allocation
                                                                            //        count.
                                                                            // NOTE:  This can be overridden using
                                                                            //        the NTMS GUI.

                            // NTMS - Set Media Pool Information.
                            WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                            errCode = SetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("SetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;
                        }
                        else {

                            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                OLESTR("CreateNtmsMediaPool"),
                                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                NULL );

                            WsbThrow( E_UNEXPECTED );

                        }

                        // Now  set access permissions on the pool: turn off ordinary users access
                        WsbAffirmHrOk(setPoolDACL(&poolId, DOMAIN_ALIAS_RID_USERS, REMOVE_ACE_MASK_BITS,NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS));


                        // Now we have an NTMS media pool for our specific use.  Now expose it
                        // through the RMS interface by creating a CRmsMediaSet.

                        if ( poolId != GUID_NULL ) {

                            //
                            // Add to CRmsMediaSet collection
                            //

                            CComPtr<IRmsMediaSet> pMediaSet;

                            // Find the CRmsMediaSet with the same id, or create a new one.
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr( pServer->CreateObject( poolId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet ) );

                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - type %d CRmsMediaSet established.\n"), translatedMediaType);

                            WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetNTMS ) );
                            WsbAffirmHr( pMediaSet->SetMediaSupported( translatedMediaType ) );

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pMediaSet;
                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - MediaSet: <%ls/%ls> %ls; Enabled: %ls\n"),
                                WsbQuickString(WsbStringAsString(mediaSetName)),
                                WsbQuickString(WsbStringAsString(mediaSetDesc)),
                                WsbQuickString(WsbGuidAsString(poolId)),
                                WsbQuickString(WsbBoolAsString(mediaSetIsEnabled)));
                            WsbAffirmHr(pObject->SetName(mediaSetName));
                            WsbAffirmHr(pObject->SetDescription(mediaSetDesc));
                            if (!mediaSetIsEnabled) {
                                WsbAffirmHr(pObject->Disable(E_FAIL));
                            }

                            if (S_OK == IsMediaCopySupported(poolId)) {
                                WsbAffirmHr( pMediaSet->SetIsMediaCopySupported(TRUE));
                            }
                            hr = pMediaSet->IsMediaCopySupported();

                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - media copies are %ls.\n"),
                                (S_OK == pMediaSet->IsMediaCopySupported()) ? OLESTR("enabled") : OLESTR("disabled"));

                        }

                        // The library has a supported media type
                        bSupportedLib = TRUE;
                     }
                    hr = findNextNtmsObject( hFindType, &mediaTypeInfo );
                }
                findCloseNtmsObject( hFindType );
            }

            // Check if the library has supported media type
            if (bSupportedLib) {
                // Add library GUI to the libraries list
                //  (Realloc one item each time since we don't expect many items)
                m_dwNofLibs++;
                LPVOID pTemp = WsbRealloc(m_pLibGuids, m_dwNofLibs*sizeof(NTMS_GUID));
                if (!pTemp) {
                    WsbThrow(E_OUTOFMEMORY);
                }
                m_pLibGuids = (LPNTMS_GUID)pTemp;
                m_pLibGuids[m_dwNofLibs-1] = libraryInfo.ObjectGuid;
            }
            
            // Continue library enumeration
            hr = findNextNtmsObject( hFindLib, &libraryInfo );
        }
        findCloseNtmsObject( hFindLib );

        hr = S_OK;

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



STDMETHODIMP 
CRmsNTMS::Allocate(
    IN REFGUID fromMediaSet,
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN BSTR displayName,
    IN DWORD dwOptions,
    OUT IRmsCartridge **ppCartridge)
/*++

Implements:

    IRmsNTMS::Allocate

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;
    DWORD err5 = NO_ERROR;
    DWORD err6 = NO_ERROR;
    DWORD err7 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::Allocate"), OLESTR("<%ls> <%ls> <%ls> <%ls> <0x%08x"),
        WsbGuidAsString(fromMediaSet), WsbGuidAsString(prevSideId), 
        WsbPtrToLonglongAsString(pFreeSpace), WsbStringAsString(displayName), dwOptions);

    try {
        WsbAssert(fromMediaSet != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(ppCartridge);

        // Retrieve the AllocateWaitTime and RequestWaitTime parameters
        DWORD size;
        OLECHAR tmpString[256];
        DWORD allocateWaitTime;
        DWORD requestWaitTime;

        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;

        BOOL bFailOnSize = ( dwOptions & RMS_FAIL_ALLOCATE_ON_SIZE ) ? TRUE : FALSE;

        if (bShortTimeout) {
            allocateWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            requestWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_SHORT_WAIT_TIME, tmpString, 256, &size))) {
                allocateWaitTime = wcstol(tmpString, NULL, 10);
                requestWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("allocateWaitTime (Short) is %d milliseconds.\n"), allocateWaitTime);
                WsbTrace(OLESTR("RequestWaitTime (Short) is %d milliseconds.\n"), requestWaitTime);
            }
        } else {
            allocateWaitTime = RMS_DEFAULT_ALLOCATE_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_ALLOCATE_WAIT_TIME, tmpString, 256, &size))) {
                allocateWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("AllocateWaitTime is %d milliseconds.\n"), allocateWaitTime);
            }
            requestWaitTime = RMS_DEFAULT_REQUEST_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_REQUEST_WAIT_TIME, tmpString, 256, &size))) {
                requestWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("RequestWaitTime is %d milliseconds.\n"), requestWaitTime);
            }
        }

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID setId = fromMediaSet;
            NTMS_GUID partId = GUID_NULL;
            NTMS_GUID *pPartId = NULL;
            NTMS_GUID requestId;

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;
            err4 = NO_ERROR;
            err5 = NO_ERROR;
            err6 = NO_ERROR;
            err7 = NO_ERROR;

            try {

                // Look for a specific media ourselves if:
                //  1. A specific capacity is required                  AND
                //  2. We do not try to allocate a second side
                if (pFreeSpace && (prevSideId == GUID_NULL)) {
                    if (*pFreeSpace > 0) {
                        int retry = 3;  // Give the operator 3 chances to get it right!
                        do {
                            // We need to allocate a unit of media that matches the capacity specified.
                            // However, if fail-on-size is indicated AND free media exists, we need to fail
                            // instead of asking the operator for free media with the required size
                            //
                            // Enumerate the partitions in the scratch pool of the same type as
                            // specified to find a capatible unit of media
                            //
                            BOOL bFreeMediaExists = FALSE;

                            // First find the media type we looking for
                            NTMS_OBJECTINFORMATION mediaPoolInfo;
                            NTMS_OBJECTINFORMATION partitionInfo;
                            HANDLE hFindPool = NULL;
                            HANDLE hFindPart = NULL;
                            BOOL bFound = FALSE;
                            NTMS_GUID scratchPoolId;

                            err1 = NO_ERROR;
                            err2 = NO_ERROR;
                            err3 = NO_ERROR;
                            err4 = NO_ERROR;
                            err5 = NO_ERROR;
                            err6 = NO_ERROR;
                            err7 = NO_ERROR;

                            // First look in our pool for scratch media of the correct size

                            hr = findFirstNtmsObject(NTMS_PARTITION, setId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
                            while(S_OK == hr) {
                                reportNtmsObjectInformation(&partitionInfo);
                                if ((TRUE == partitionInfo.Enabled) &&
                                    (NTMS_READY == partitionInfo.dwOperationalState) &&
                                    (NTMS_PARTSTATE_AVAILABLE == partitionInfo.Info.Partition.State)) {

                                    NTMS_GUID physicalPartMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                                    try {
                                        // Check if the media is online and enabled
                                        NTMS_OBJECTINFORMATION mediaPartInfo;
                                        mediaPartInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                                        mediaPartInfo.dwType = NTMS_PHYSICAL_MEDIA;

                                        // NTMS - Get physical media information
                                        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                                        WsbAffirmNoError( GetNtmsObjectInformation( hSession, &physicalPartMediaId, &mediaPartInfo ) );

                                        // Check location type, if enabled & if all new
                                        if ( (mediaPartInfo.Info.PhysicalMedia.LocationType !=  NTMS_UNKNOWN)
                                            && (mediaPartInfo.Enabled) ) {                                    

                                            // Ensure that ALL sides are not allocated yet
                                            hr = EnsureAllSidesNotAllocated(physicalPartMediaId);

                                            if (S_OK == hr) {

                                                // Check required free space
                                                if (partitionInfo.Info.Partition.Capacity.QuadPart >= *pFreeSpace) {
                                                    // We'll use this unit of media.
                                                    // Save parameterers required for Allocate.
                                                    bFound = TRUE;
                                                    partId = partitionInfo.ObjectGuid;
                                                    pPartId = &partId;
                                                    break;
                                                } else {
                                                    // Track the fact that we found a free media which meets
                                                    //  all criteria besides capacity
                                                    bFreeMediaExists = TRUE;
                                                }
                                            } else if (S_FALSE != hr) {
                                                WsbAffirmHr(hr);
                                            }
                                        }

                                    } WsbCatchAndDo (hr,
                                            WsbTraceAlways(OLESTR("CRmsNTMS::Allocate: Failed to check media <%ls> hr = <%ls>\n"),
                                                WsbGuidAsString(physicalPartMediaId), WsbHrAsString(hr));
                                            hr = S_OK;
                                        )
                                }

                                hr = findNextNtmsObject(hFindPart, &partitionInfo);
                            } // while finding media pools

                            findCloseNtmsObject(hFindPart);
                            hr = S_OK;

                            if (!bFound) {

                                // Now try the Scratch Pool

                                memset(&mediaPoolInfo, 0, sizeof(NTMS_OBJECTINFORMATION));

                                mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                                mediaPoolInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);

                                // NTMS - Get Media Pool Information
                                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_MEDIA_POOL)\n"));
                                err3 = GetNtmsObjectInformation(hSession, &setId, &mediaPoolInfo);
                                WsbAffirmNoError( err3 );

                                // Save the media type for the media pool
                                NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

                                // Find the scratch pool with the same media type
                                hr = findFirstNtmsObject(NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFindPool, &mediaPoolInfo);
                                while(S_OK == hr) {
                                    if ((NTMS_POOLTYPE_SCRATCH == mediaPoolInfo.Info.MediaPool.PoolType) &&
                                        (mediaTypeId == mediaPoolInfo.Info.MediaPool.MediaType)) {
                                        // This is a base level scratch media pool for type we're looking for.
                                        scratchPoolId = mediaPoolInfo.ObjectGuid;

                                        hr = findFirstNtmsObject(NTMS_PARTITION, scratchPoolId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
                                        while(S_OK == hr) {
                                            reportNtmsObjectInformation(&partitionInfo);
                                            if ((TRUE == partitionInfo.Enabled) &&
                                                (NTMS_READY == partitionInfo.dwOperationalState) &&
                                                (NTMS_PARTSTATE_AVAILABLE == partitionInfo.Info.Partition.State)) {

                                                // Check if the media is online and enabled
                                                DWORD errPart = NO_ERROR;
                                                NTMS_OBJECTINFORMATION mediaPartInfo;
                                                NTMS_GUID physicalPartMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                                                mediaPartInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                                                mediaPartInfo.dwType = NTMS_PHYSICAL_MEDIA;

                                                // NTMS - Get physical media information
                                                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                                                errPart = GetNtmsObjectInformation( hSession, &physicalPartMediaId, &mediaPartInfo );

                                                // Ignore error here, just don't use this partition
                                                if (errPart == NO_ERROR) {

                                                    // Check location type and if enabled
                                                    if ( (mediaPartInfo.Info.PhysicalMedia.LocationType !=  NTMS_UNKNOWN)
                                                        && (mediaPartInfo.Enabled) ) {

                                                        // Check required free space
                                                        if (partitionInfo.Info.Partition.Capacity.QuadPart >= *pFreeSpace) {
                                                            // We'll use this unit of media.
                                                            // Save parameterers required for Allocate.
                                                            bFound = TRUE;
                                                            partId = partitionInfo.ObjectGuid;
                                                            pPartId = &partId;
                                                            break;
                                                        } else {
                                                            // Track the fact that we found a free media which meets
                                                            //  all criteria besides capacity
                                                            bFreeMediaExists = TRUE;
                                                        }
                                                    }
                                                } else {
                                                    WsbTraceAlways(OLESTR("CRmsNTMS::Allocate: Failed to get object info for media <%ls> hr = <%ls>\n"),
                                                        WsbGuidAsString(physicalPartMediaId), WsbHrAsString(HRESULT_FROM_WIN32(errPart)));
                                                }
                                            }
                                            hr = findNextNtmsObject(hFindPart, &partitionInfo);
                                        } // while finding media pools
                                        findCloseNtmsObject(hFindPart);
                                        hr = S_OK;
                                        break;
                                    }
                                    hr = findNextNtmsObject(hFindPool, &mediaPoolInfo);
                                } // while finding media pools
                                findCloseNtmsObject(hFindPool);
                                hr = S_OK;
                            }

                            if (bFound) {
                                // Found free media to allocate
                                break;
                            } else if (bFreeMediaExists && bFailOnSize) {
                                // Free media exists, but not with the right capacity - fail 
                                WsbTrace(OLESTR("CRmsNTMS::Allocate: Failing allocate request since there are free media but all with too small capacity\n"));
                                WsbThrow(RMS_E_SCRATCH_NOT_FOUND_TOO_SMALL);
                            } else {
                                // No sufficient free media - submit operator request
                                OLECHAR * messageText = NULL;
                                WCHAR *stringArr[2];
                                WCHAR capString[40];
                                DWORD dwMessageId;

                                WsbShortSizeFormat64(*pFreeSpace, capString);

                                stringArr[0] = mediaPoolInfo.szName;
                                stringArr[1] = capString;

                                // Set which request to sumbit (with or without size specification)
                                if (bFailOnSize) {
                                    dwMessageId = RMS_MESSAGE_SCRATCH_MEDIA_NO_SIZE_REQUEST;
                                } else {
                                    dwMessageId = RMS_MESSAGE_SCRATCH_MEDIA_REQUEST;
                                }

                                if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        LoadLibraryEx( WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE ), 
                                        dwMessageId, MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
                                        (LPTSTR)&messageText, 0, (va_list *)stringArr)) {
                                    WsbTrace(OLESTR("CRmsNTMS::Allocate: FormatMessage failed: %ls\n"),
                                            WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
                                }

                                // NTMS - Submit operator request
                                WsbTraceAlways(OLESTR("SubmitNtmsOperatorRequest()\n"));
                                err5 = SubmitNtmsOperatorRequest(hSession, NTMS_OPREQ_NEWMEDIA, messageText, &scratchPoolId, NULL, &requestId);
                                LocalFree(messageText);
                                WsbAffirmNoError(err5);

                                // NTMS - Wait for operator request
                                WsbTraceAlways(OLESTR("WaitForNtmsOperatorRequest()\n"));
                                err6 = WaitForNtmsOperatorRequest(hSession, &requestId, requestWaitTime);
                                //
                                // !!! NOTE !!!  At the time of this writting WaitForNtmsOperatorRequest
                                // did not return ERROR_TIMEOUT.
                                //
                                if (ERROR_TIMEOUT == err6) {
                                    // Best effort cleanup...
                                    // NTMS - Cancel operator request
                                    WsbTraceAlways(OLESTR("CancelNtmsOperatorRequest()\n"));
                                    err7 = CancelNtmsOperatorRequest(hSession, &requestId);
                                }
                                WsbAffirmNoError(err6);
                            }
                            WsbAssertHrOk(hr);

                            // At this point the operator added a compatable unit of media...
                            // Verify until we're exceed the retry count.
                            retry--;
                        } while (retry > 0);
                        if (0 == retry) {
                            WsbThrow(RMS_E_SCRATCH_NOT_FOUND);
                        }
                    }
                }
                // NTMS - Allocate a unit of scratch media
                WsbTraceAlways(OLESTR("AllocateNtmsMedia()\n"));

                // Set additional allocation settings
                DWORD dwAllocateOptions = 0;
                NTMS_GUID mediaId = prevSideId;
                if (mediaId == GUID_NULL) {
                    dwAllocateOptions |= NTMS_ALLOCATE_NEW;
                } else {
                    // Allocating the second side: mediaId should hold the LMID of the first side
                    dwAllocateOptions |= NTMS_ALLOCATE_NEXT;
                }
                if (dwOptions & RMS_ALLOCATE_NO_BLOCK) {
                    dwAllocateOptions |= NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE;
                    allocateWaitTime = 0;
                }

                err1 = AllocateNtmsMedia( hSession, &setId, pPartId, &mediaId,
                                          dwAllocateOptions, allocateWaitTime, NULL );
                WsbAffirmNoError( err1 );

                // Now get/set the various information fields for the unit of media.

                DWORD sideNo = 2;
                NTMS_GUID side[2];

                // NTMS - Enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err2 = EnumerateNtmsObject(hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0);
                WsbAffirmNoError( err2 );

                NTMS_OBJECTINFORMATION partitionInfo;
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                // NTMS - Get partition information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err3 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err3 );

                NTMS_OBJECTINFORMATION mediaInfo;
                NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

                // NTMS - Get physical media information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                err3 = GetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err3 );

                NTMS_OBJECTINFORMATION logicalMediaInfo;
                logicalMediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                logicalMediaInfo.dwType = NTMS_LOGICAL_MEDIA;

                // NTMS - Get physical media information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LOGICAL_MEDIA)\n"));
                err3 = GetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err3 );

                // Save the capacity for the return arg.
                if (pFreeSpace) {
                    *pFreeSpace = partitionInfo.Info.Partition.Capacity.QuadPart;
                }

                // Set name & description
                CWsbStringPtr mediaDisplayName;

                // Set new physical media name for first side
                // Modify original name for second side
                if ( !(dwAllocateOptions & NTMS_ALLOCATE_NEXT) ) {
                    mediaDisplayName = (WCHAR *)displayName;
                } else {
                    WCHAR *dashPtr = wcsrchr((WCHAR *)displayName, L'-');
                    mediaDisplayName = mediaInfo.szName;
                    if (dashPtr) {
                        WsbAffirmHr(mediaDisplayName.Append(dashPtr));
                    }
                }

                // Set the Name to the displayName, only if there's no bar code.
                if ( NTMS_BARCODESTATE_OK != mediaInfo.Info.PhysicalMedia.BarCodeState) {
                    wcscpy(mediaInfo.szName, mediaDisplayName);
                    wcscpy(partitionInfo.szName, (WCHAR *) displayName);

                    // NTMS doesn't allow dup logical media names.  We set
                    // the name to the mediaId to keep it unique.  The logical
                    // media name is not displayed in the Removable Storage UI.

                    CWsbStringPtr strGuid;
                    WsbAffirmHr(WsbSafeGuidAsString(mediaId, strGuid));
                    wcscpy(logicalMediaInfo.szName, (WCHAR *)strGuid);
                }

                // Set the Description to the displayName
                wcscpy(logicalMediaInfo.szDescription, (WCHAR *) displayName);
                wcscpy(partitionInfo.szDescription, (WCHAR *) displayName);
                wcscpy(mediaInfo.szDescription, (WCHAR *) mediaDisplayName);

                // NTMS - Set partition information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err4 );

                // NTMS - Set physical media information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err4 );

                // NTMS - Set logical media information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err4 );

                WsbAssertHrOk(FindCartridge(mediaId, ppCartridge));
                WsbAssertHr((*ppCartridge)->SetStatus(RmsStatusScratch));

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // AllocateNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                case ERROR_MEDIA_UNAVAILABLE:
                    hr = RMS_E_SCRATCH_NOT_FOUND;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_WRITE_PROTECT:
                    hr = RMS_E_WRITE_PROTECT;
                    break;

                case ERROR_INVALID_MEDIA_POOL:
                    hr = RMS_E_MEDIASET_NOT_FOUND;
                    break;

                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_DEVICE_NOT_AVAILABLE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("AllocateNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("AllocateNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err3 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err4 != NO_ERROR) {
                // SetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_OBJECT_ALREADY_EXISTS:  // bmd: 1/18/99 - Not documented, but NTMS doesn't allow dup logical media names.
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err5 != NO_ERROR) {
                // SubmitNtmsOperatorRequest
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                case ERROR_OBJECT_NOT_FOUND:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SubmitNtmsOperatorRequest"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SubmitNtmsOperatorRequest"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err6 != NO_ERROR) {
                // WaitForNtmsOperatorRequest
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                    hr = RMS_E_TIMEOUT;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_ACCESS_DENIED:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                case ERROR_OBJECT_NOT_FOUND:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsOperatorRequest"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsOperatorRequest"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::Allocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Mount(
    IN IRmsCartridge *pCart,
    IN OUT IRmsDrive **ppDrive,
	IN DWORD dwOptions OPTIONAL,
    IN DWORD threadId OPTIONAL)
/*++

Implements:

    IRmsNTMS::Mount

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;

    BOOL mediaMounted = FALSE;

    BOOL bNoBlock = ( dwOptions & RMS_MOUNT_NO_BLOCK ) ? TRUE : FALSE;

	// declared outside try block so it can be accessible throughout the method
    DWORD       sideNo = 2;
    NTMS_GUID   side[2];
             
    WsbTraceIn( OLESTR("CRmsNTMS::Mount"), OLESTR("") );

    try {
        WsbAssertPointer(pCart);

        CComPtr<IRmsDrive> pDrive;

        // determine the timeout for the operator request
        DWORD size;
        OLECHAR tmpString[256];
        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;
        DWORD mountWaitTime;
        if (bShortTimeout) {
            mountWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_SHORT_WAIT_TIME, tmpString, 256, &size))) {
                mountWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("MountWaitTime (Short) is %d milliseconds.\n"), mountWaitTime);
            }
        } else {
            mountWaitTime = RMS_DEFAULT_MOUNT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_MOUNT_WAIT_TIME, tmpString, 256, &size))) {
                mountWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("MountWaitTime is %d milliseconds.\n"), mountWaitTime);
            }
        }

        NTMS_OBJECTINFORMATION driveInfo;
        memset( &driveInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;            

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                DWORD       count = 1;
                NTMS_GUID   driveId;

                // NTMS - issue mount request
                WsbTraceAlways(OLESTR("MountNtmsMedia()\n"));
				DWORD dwOpt = NTMS_MOUNT_READ | NTMS_MOUNT_WRITE;
				if (bNoBlock) {
					dwOpt |= (NTMS_MOUNT_ERROR_NOT_AVAILABLE | NTMS_MOUNT_ERROR_OFFLINE);
				}
                if (dwOptions & RMS_USE_MOUNT_NO_DEADLOCK) {
                    /*
                    DEADLOCK AVOIDANCE: when RSM support for MountNtmsMediaDA is
                    in, the next line should be uncommented, and the other 2 lines
                    in this 'if' block should be removed. 
                    err2 = MountNtmsMediaDA( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL, &threadId, 1);
                    */
                    UNREFERENCED_PARAMETER(threadId);
                    err2 = MountNtmsMedia( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL);
                } else {
                    err2 = MountNtmsMedia( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL);

                }
                WsbAffirmNoError( err2 );
                mediaMounted = TRUE;

                //
                // We now need two critical pieces of information.  The Device name and
                // the kind of media we just mounted.  This gives use the essential information
                // to create a data mover.  Since we drill through NTMS to get this information
                // we also create cartridge, drive objects.
                //

                driveInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                driveInfo.dwType = NTMS_DRIVE;

                // NTMS - get drive information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_DRIVE)\n"));
                err3 = GetNtmsObjectInformation( hSession, &driveId, &driveInfo );
                WsbAffirmNoError( err3 );
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

        RmsMedia mediaType;
        WsbAffirmHr(pCart->GetType((LONG *)&mediaType));

        // Create Drive
        WsbAssertHr(CoCreateInstance(CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDrive, (void **)&pDrive));

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pDrive;

        WsbAssertHr(pElmt->SetMediaSupported(mediaType));

        CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pDrive;

        WsbAssertHr(pDevice->SetDeviceAddress(
            (BYTE) driveInfo.Info.Drive.ScsiPort,
            (BYTE) driveInfo.Info.Drive.ScsiBus,
            (BYTE) driveInfo.Info.Drive.ScsiTarget,
            (BYTE) driveInfo.Info.Drive.ScsiLun));

        CWsbBstrPtr deviceName = driveInfo.Info.Drive.szDeviceName;

        ////////////////////////////////////////////////////////////////////////////////////////
        // Convert the NTMS device name to something usable.
        //
        switch (mediaType) {
        case RmsMediaOptical:
        case RmsMediaDVD:
        case RmsMediaDisk:
            {
                // We need to convert \\.\PhysicalDriveN to something accessible by the file system.
                WCHAR *szDriveLetter = NULL;
                WCHAR *szVolumeName = NULL;
                err4 = GetVolumesFromDrive( (WCHAR *)deviceName, &szVolumeName, &szDriveLetter );
                if (szVolumeName) {
                    delete [] szVolumeName;    // don't need it for now
                }
                if (NO_ERROR == err4) {
                    if (szDriveLetter) {
                        deviceName = szDriveLetter;
                    } else {
                        WsbTraceAlways(OLESTR("CRmsNTMS::Mount: GetVolumesFromDrive succeeded but output drive is NULL !!\n"));
                        WsbThrow(RMS_E_RESOURCE_UNAVAILABLE);
                    }
                }
                if (szDriveLetter) {
                    delete [] szDriveLetter;
                }
                WsbAffirmNoError( err4 );
                WsbTrace(OLESTR("CRmsNTMS::Mount: device name after convert is %s\n"), (WCHAR *)deviceName);
            }       
            break;

        default:
            break;
        }
        ////////////////////////////////////////////////////////////////////////////////////////

        WsbAssertHr(pDevice->SetDeviceName(deviceName));

        WsbAssertHr(pCart->SetDrive(pDrive));

        // Fill in the return arguments.
        *ppDrive = pDrive;
        pDrive.p->AddRef();

    } WsbCatchAndDo(hr,
            // Process the exception
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // MountNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                    hr = RMS_E_CARTRIDGE_UNAVAILABLE;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
					if (bNoBlock) {
						DWORD errSub = NO_ERROR;

						try	{
							// Since we are not blocking for NTMS to ask the operator
							//	to mount the offline media, we do it ourselves

							// create operator message
						    CWsbBstrPtr cartridgeName = "";
							CWsbBstrPtr cartridgeDesc = "";
                            OLECHAR * messageText = NULL;
                            WCHAR *stringArr[2];

					        cartridgeName.Free();
							WsbAffirmHr(pCart->GetName(&cartridgeName));
					        cartridgeDesc.Free();
							WsbAffirmHr(pCart->GetDescription(&cartridgeDesc));
                            stringArr[0] = (WCHAR *) cartridgeName;
                            stringArr[1] = (WCHAR *) cartridgeDesc;

                            if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      LoadLibraryEx( WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE ), 
                                      RMS_MESSAGE_OFFLINE_MEDIA_REQUEST, MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
                                      (LPTSTR)&messageText, 0, (va_list *)stringArr)) {
								WsbTrace(OLESTR("CRmsNTMS::Mount: FormatMessage failed: %ls\n"),
                                            WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
	                            messageText = NULL;
							}

							NTMS_GUID mediaId = GUID_NULL;
							NTMS_GUID libId = GUID_NULL;
							NTMS_GUID requestId = GUID_NULL;
							WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
							WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

							// Library Id should be gathered here - need to clarify why 
							//	does the GetHome return a null id !!!
//							WsbAffirmHr(pCart->GetHome(NULL, &libId, NULL, NULL, NULL, NULL, NULL, NULL));
//							WsbAssert(libId != GUID_NULL, E_INVALIDARG);

							// submit operator request
							errSub = SubmitNtmsOperatorRequest(m_SessionHandle, NTMS_OPREQ_MOVEMEDIA,
										messageText, &mediaId, &libId, &requestId);
                            LocalFree(messageText);
			                WsbAffirmNoError (errSub);

						}  WsbCatchAndDo(hr,
							// Process the error of the Corrective Action
							if (errSub != NO_ERROR ) {
			                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
									OLESTR("SubmitNtmsOperatorRequest"), OLESTR(""),
									WsbHrAsString(hr), NULL);
							}

							// place back the original mane error
		                    hr = RMS_E_MEDIA_OFFLINE;
						);
					}
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_WRITE_PROTECT:
                    hr = RMS_E_WRITE_PROTECT;
                    break;

                case ERROR_INVALID_STATE:
                case ERROR_INVALID_DRIVE: {
					// when performing NTMS mount in non-blocking mode , this error may 
					//	just mean that a corrective action such as drive cleaning should 
					//	be performed before mounting (note that ONLY when not blocking, 
					//	NTMS can not instruct corrective actions by itself)
					if (bNoBlock) {
						try	{
						    CWsbBstrPtr cartridgeName = "";
							CWsbBstrPtr cartridgeDesc = "";
					        cartridgeName.Free();
							WsbAffirmHr(pCart->GetName(&cartridgeName));
					        cartridgeDesc.Free();
							WsbAffirmHr(pCart->GetDescription(&cartridgeDesc));
					        WsbLogEvent(RMS_MESSAGE_DRIVE_NOT_AVAILABLE, 0, NULL, 
								(WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);

					    } WsbCatch(hr);

						break;
					}
                  }
                case ERROR_RESOURCE_DISABLED: {
					// Check if the the media (cartridge) is disabled - different error should
					//	be returned for media and for other resources (library, drive, etc.)
					
                    HRESULT hrOrg = hr;
					DWORD errSub1 = NO_ERROR;
					DWORD errSub2 = NO_ERROR;
					try	{
						// get physical media information
		                NTMS_OBJECTINFORMATION objectInfo;
		                objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
				        objectInfo.dwType = NTMS_PARTITION;
						WsbAssert(side[0] != GUID_NULL, E_INVALIDARG);
		                errSub1 = GetNtmsObjectInformation( m_SessionHandle, &side[0], &objectInfo );
		                WsbAffirmNoError (errSub1);

		                NTMS_GUID physicalMediaId = objectInfo.Info.Partition.PhysicalMedia;
						WsbAssert(physicalMediaId != GUID_NULL, E_INVALIDARG);
		                objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
		                objectInfo.dwType = NTMS_PHYSICAL_MEDIA;
		                errSub2 = GetNtmsObjectInformation( m_SessionHandle, &physicalMediaId, &objectInfo );
		                WsbAffirmNoError (errSub2);

						// set our dedicated error only if (physical) media is disabled
						if (! objectInfo.Enabled) {
		                    hr = RMS_E_CARTRIDGE_DISABLED;
						}

					}  WsbCatchAndDo(hr,
						// Process the error of the get-info requests
						if (errSub1 != NO_ERROR ) {
		                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
								OLESTR("GetNtmsObjectInformation (Partition)"), OLESTR(""),
								WsbHrAsString(hr), NULL);
						} else if (errSub2 != NO_ERROR ) {
		                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
								OLESTR("GetNtmsObjectInformation (Physical Media)"), OLESTR(""),
								WsbHrAsString(hr), NULL);
						}

						// place back the original mane error
	                    hr = hrOrg;
					);
					break;
				  } 

                case ERROR_ACCESS_DENIED:
                case ERROR_BUSY:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_DRIVE_MEDIA_MISMATCH:
                case ERROR_INVALID_LIBRARY:
                case ERROR_INVALID_MEDIA:
                case ERROR_NOT_ENOUGH_MEMORY: {
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("MountNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                  }
                default: {
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("MountNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                  }
                }
            }
            else if (err3 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            } else if (err4 != NO_ERROR) {
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                    OLESTR("GetVolumesFromDrive"), OLESTR("Unexpected Failure: "),
                    WsbHrAsString(hr), NULL);
            }

            if (mediaMounted) {
                // Something failed after the mount completed, so need to clean up...
                // Dismount the media to release the resource before returning.
                Dismount(pCart, FALSE);
            }
        );

    WsbTraceOut( OLESTR("CRmsNTMS::Mount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Dismount(
    IN IRmsCartridge *pCart, IN DWORD dwOptions)
/*++

Implements:

    IRmsNTMS::Dismount

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::Dismount"), OLESTR("") );

    try {
        WsbAssertPointer(pCart);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            NTMS_GUID side[2];
            DWORD sideNo = 2;

            err1 = NO_ERROR;
            err2 = NO_ERROR;

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - dismount media
                DWORD dwNtmsOptions = 0;
                WsbTraceAlways(OLESTR("DismountNtmsMedia()\n"));
				if (! ( dwOptions & RMS_DISMOUNT_IMMEDIATE )) {
					dwNtmsOptions |= NTMS_DISMOUNT_DEFERRED;
				}
                err2 = DismountNtmsMedia( hSession, &side[0], 1, dwNtmsOptions );
#ifdef DBG
                // TODO: Remove this trap for the unexpected ERROR_ACCESS_DENIED error.
                WsbAssert(err2 != ERROR_ACCESS_DENIED, HRESULT_FROM_WIN32(err2));
#endif
                WsbAffirmNoError( err2 );

                // Since RSM Dismount is asyncronous, we may need to wait some arbitrary time,
                //  in order that when we come back, the media is really dismounted
                if ( (dwOptions & RMS_DISMOUNT_DEFERRED_ONLY) && (!(dwOptions & RMS_DISMOUNT_IMMEDIATE)) ) {
                    CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                    if (S_OK == pServer->IsReady()) {
                        DWORD size;
                        OLECHAR tmpString[256];
                        DWORD waitTime = RMS_DEFAULT_AFTER_DISMOUNT_WAIT_TIME;
                        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_AFTER_DISMOUNT_WAIT_TIME, tmpString, 256, &size))) {
                            waitTime = wcstol(tmpString, NULL, 10);
                            WsbTrace(OLESTR("AfterDismountWaitTime is %d milliseconds.\n"), waitTime);
                        }

                        Sleep(waitTime);
                    }
                }

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);


    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // DismountNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
                    break;

                case ERROR_TIMEOUT:
                case ERROR_INVALID_MEDIA:
                case ERROR_INVALID_LIBRARY:
                case ERROR_DEVICE_NOT_AVAILABLE:
                case ERROR_MEDIA_NOT_AVAILABLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INVALID_STATE:
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DismountNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DismountNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::Dismount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Deallocate(
    IN IRmsCartridge *pCart)
/*++

Implements:

    IRmsNTMS::DeallocateMedia

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::Deallocate"), OLESTR(""));

    try {
        WsbAssertPointer(pCart);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;
            err4 = NO_ERROR;

            NTMS_OBJECTINFORMATION partitionInfo;
            memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

            DWORD sideNo = 2;
            NTMS_GUID side[2];

            try {
                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - get partition information
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err2 );

                // NULL the Description
                wcscpy(partitionInfo.szDescription, L"");

                // NTMS - Set partition information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err3 = SetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err3 );                

                // NTMS - deallocate media
                WsbTraceAlways(OLESTR("DeallocateNtmsMedia()\n"));
                err4 = DeallocateNtmsMedia( hSession, &mediaId, 0 );
                WsbAffirmNoError( err4 );

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);



    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err3 != NO_ERROR) {
                // SetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_OBJECT_ALREADY_EXISTS:  // bmd: 1/18/99 - Not documented, but NTMS doesn't allow dup logical media names.
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err4 != NO_ERROR) {
                // DeallocateNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                //case ERROR_INVALID_PARTITION:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_ACCESS_DENIED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DeallocateNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr),
                        NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DeallocateNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::Deallocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::UpdateOmidInfo(
    IN REFGUID cartId,
    IN BYTE *pBuffer,
    IN LONG size,
    IN LONG type)
/*++

Implements:

    IRmsNTMS::UpdateOmidInfo

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::UpdateOmidInfo"), OLESTR("<%ls> <0x%08x> <%d>"), WsbGuidAsString(cartId), pBuffer, size );

    try {
        WsbAssert(cartId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(pBuffer);
        WsbAssert(size > 0, E_INVALIDARG);

        WsbTraceBuffer(size, pBuffer);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            err1 = NO_ERROR;

            try {

                // NTMS - update on media information.
                WsbTraceAlways(OLESTR("UpdateNtmsOmidInfo()\n"));
                switch((RmsOnMediaIdentifier)type) {
                case RmsOnMediaIdentifierMTF:
                    err1 = UpdateNtmsOmidInfo(hSession, &mediaId, NTMS_OMID_TYPE_RAW_LABEL, size, pBuffer);
                    break;
                case RmsOnMediaIdentifierWIN32:
                    WsbAssert(size == sizeof(NTMS_FILESYSTEM_INFO), E_UNEXPECTED);
                    err1 = UpdateNtmsOmidInfo(hSession, &mediaId, NTMS_OMID_TYPE_FILESYSTEM_INFO, size, pBuffer);
                    break;
                default:
                    WsbThrow(E_UNEXPECTED);
                }
                WsbAffirmNoError( err1 );
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // UpdateNtmsOmidInfo
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                //case ERROR_INVALID_PARTITION:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("UpdateNtmsOmidInfo"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("UpdateNtmsOmidInfo"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::UpdateOmidInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



STDMETHODIMP
CRmsNTMS::GetBlockSize(
    IN REFGUID cartId,
    OUT LONG *pBlockSize
    )
/*++

Implements:

    IRmsNTMS::GetBlockSize

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::GetBlockSize"), OLESTR("<%ls> <x%08x>"), WsbGuidAsString(cartId), pBlockSize);

    try {
        WsbAssertPointer(pBlockSize);

        do {
            hr = S_OK;
            err1 = NO_ERROR;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            DWORD nBlockSize;
            DWORD sizeOfBlockSize = sizeof(DWORD);
            try {

                err1 = GetNtmsObjectAttribute(hSession, &mediaId, NTMS_LOGICAL_MEDIA, OLESTR("BlockSize"), (LPVOID) &nBlockSize, &sizeOfBlockSize);
                WsbAffirmNoError(err1);
                *pBlockSize = (LONG) nBlockSize;
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // GetNtmsObjectAttribute
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:        // Don't log this error.  Attribute doesn't
                    break;                          //  exist for new media.  We skip this error
                                                    //  and let the caller deal with it.

                case ERROR_DATABASE_FAILURE:        // Log these errors.
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_NO_DATA:
                case ERROR_INVALID_PARAMETER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectAttribute"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectAttribute"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::GetBlockSize"), OLESTR("hr = <%ls>, BlockSize = <%d>"), WsbHrAsString(hr), *pBlockSize);

    return hr;
}


STDMETHODIMP
CRmsNTMS::SetBlockSize(
    IN REFGUID cartId,
    IN LONG blockSize
    )
/*++

Implements:

    IRmsNTMS::SetBlockSize

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::SetBlockSize"), OLESTR("<%ls> <%d>"), WsbGuidAsString(cartId), blockSize);

    try {

        do {
            hr = S_OK;
            err1 = NO_ERROR;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            DWORD nBlockSize = blockSize;
            DWORD sizeOfBlockSize = sizeof(DWORD);

            try {

                err1 = SetNtmsObjectAttribute(hSession, &mediaId, NTMS_LOGICAL_MEDIA, OLESTR("BlockSize"), (LPVOID) &nBlockSize, sizeOfBlockSize);
                WsbAffirmNoError(err1);
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // SetNtmsObjectAttribute
                switch (HRESULT_CODE(hr)) {
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_NOT_CONNECTED:
                case ERROR_NO_DATA:
                case ERROR_INVALID_PARAMETER:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_INVALID_NAME:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectAttribute"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectAttribute"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::SetBlockSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::changeState(
    IN LONG newState
    )
/*++

Routine Description:

    Changes the state of the NTMS object.

Arguments:

    None.

Return Values:

    S_OK    - Success.

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::changeState"), OLESTR("<%d>"), newState);

    try {

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        // TODO: Validate the state change
        WsbAffirmHr(pObject->SetState(newState));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::changeState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::ExportDatabase(void)
/*++

Implements:

    CRmsNTMS::ExportDatabase

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::ExportDatabase"), OLESTR(""));

    try {

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
             
            err1 = NO_ERROR;

            try {

                err1 = ExportNtmsDatabase(hSession);
                WsbAffirmNoError(err1);
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // ExportNtmsDatabase
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("ExportNtmsDatabase"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("ExportNtmsDatabase"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::ExportDatabase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsNTMS::FindCartridge(
    IN REFGUID cartId,
    OUT IRmsCartridge **ppCartridge)
/*++

Implements:

    CRmsNTMS::FindCartridge

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::FindCartridge"), OLESTR("<%ls> <0x%08x>"), WsbGuidAsString(cartId), ppCartridge);

    try {
        WsbAssert(cartId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(ppCartridge);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaTypeInfo;
        memset( &mediaTypeInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION libraryInfo;
        memset( &libraryInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION logicalMediaInfo;
        memset( &logicalMediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        RmsMedia translatedMediaType = RmsMediaUnknown;

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;
            DWORD sideNo = 2;
            NTMS_GUID side[2];

            err1 = NO_ERROR;
            err2 = NO_ERROR;

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - get partition information
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err2 );

                // NTMS - get physical media information
                NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;

                mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                err2 = GetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err2);

                // NTMS - get media type information
                NTMS_GUID mediaTypeId = mediaInfo.Info.PhysicalMedia.MediaType;

                mediaTypeInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaTypeInfo.dwType = NTMS_MEDIA_TYPE;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_MEDIA_TYPE)\n"));
                err2 = GetNtmsObjectInformation( hSession, &mediaTypeId, &mediaTypeInfo );
                WsbAffirmNoError( err2 );

                // Translate the NTMS media type into something understood by RMS
                storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                // NTMS - get logical media information
                logicalMediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                logicalMediaInfo.dwType = NTMS_LOGICAL_MEDIA;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LOGICAL_MEDIA)\n"));
                err2 = GetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err2 );

                // NTMS - get library information
                NTMS_GUID libraryId = mediaInfo.Info.PhysicalMedia.CurrentLibrary;

                libraryInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                libraryInfo.dwType = NTMS_LIBRARY;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LIBRARY)\n"));
                err2 = GetNtmsObjectInformation( hSession, &libraryId, &libraryInfo );
                WsbAffirmNoError( err2 );

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running.
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up; handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

        // Create Cartridge
        IRmsCartridge  *pCart = 0;
        WsbAssertHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                     IID_IRmsCartridge, (void **)&pCart));

        // Fill in the object data

        // The media Name is what is displaye by NTMS UI
        CWsbBstrPtr name = mediaInfo.szName;
        WsbAffirmHr(pCart->SetName(name));

        // The partition Description is what is displayed by NTMS UI.
        CWsbBstrPtr desc = partitionInfo.szDescription;
        WsbAffirmHr(pCart->SetDescription(desc));

        WsbAffirmHr(pCart->SetCartridgeId(cartId));

        CWsbBstrPtr barCode = mediaInfo.Info.PhysicalMedia.szBarCode;
        CWsbBstrPtr seqNo = mediaInfo.Info.PhysicalMedia.szSequenceNumber; // Not used
        WsbAffirmHr(pCart->SetTagAndNumber(barCode, 0));

        WsbAffirmHr(pCart->SetType((LONG) translatedMediaType));

        switch (mediaInfo.Info.PhysicalMedia.MediaState) {
            case NTMS_MEDIASTATE_IDLE:
            case NTMS_MEDIASTATE_UNLOADED:
                WsbAffirmHr(pCart->SetIsAvailable(TRUE));
                break;

            default:
                WsbAffirmHr(pCart->SetIsAvailable(FALSE));
                break;
        }        
        
        RmsElement type = RmsElementUnknown;

        if ( NTMS_LIBRARYTYPE_ONLINE == libraryInfo.Info.Library.LibraryType ) {

            switch (mediaInfo.Info.PhysicalMedia.LocationType) {
            case NTMS_STORAGESLOT:
                type = RmsElementStorage;
                break;

            case NTMS_DRIVE:
                type = RmsElementDrive;
                break;

            case NTMS_IEPORT:
                type = RmsElementIEPort;
                break;

            case NTMS_CHANGER:
                type = RmsElementChanger;
                break;

            default:
                type = RmsElementUnknown;
                break;
            }
        }
        else if ( NTMS_LIBRARYTYPE_STANDALONE == libraryInfo.Info.Library.LibraryType ) {

            switch (mediaInfo.Info.PhysicalMedia.LocationType) {
            case NTMS_DRIVE:
                type = RmsElementDrive;
                break;

            default:
                type = RmsElementUnknown;
                break;
            }
        } else {
            type = RmsElementShelf;
        }

        WsbAffirmHr(pCart->SetLocation(type,
           mediaInfo.Info.PhysicalMedia.CurrentLibrary,
           logicalMediaInfo.Info.LogicalMedia.MediaPool,
           0, 0, 0, 0, 0));

        WsbAffirmHr(pCart->SetManagedBy((LONG)RmsMediaManagerNTMS));

        WsbAssertHr(pCart->SetStatus(RmsStatusPrivate));

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObj = pCart;
        if (!mediaInfo.Enabled) {
            WsbAffirmHr(pObj->Disable(RMS_E_CARTRIDGE_DISABLED));
        }

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = pCart;
        WsbAffirmHr(pInfo->SetCapacity(partitionInfo.Info.Partition.Capacity.QuadPart));

        WsbTrace(OLESTR("Cartridge id <name/desc>:   %ls <%ls/%ls>\n"), WsbGuidAsString(cartId), (WCHAR *) name, (WCHAR *) desc);
        WsbTrace(OLESTR("Cartridge <barCode/seqNo>:  <%ls/%ls>\n"), (WCHAR *) barCode, (WCHAR *) seqNo );
        WsbTrace(OLESTR("Cartridge Enabled:          %ls\n"), WsbHrAsString(pObj->IsEnabled()));
        WsbTrace(OLESTR("Cartridge type:             %d\n"), translatedMediaType);
        WsbTrace(OLESTR("Cartridge capacity:         %I64d\n"), partitionInfo.Info.Partition.Capacity.QuadPart);
        WsbTrace(OLESTR("Cartridge domain:           %ls\n"), WsbGuidAsString(logicalMediaInfo.Info.LogicalMedia.MediaPool));

        if (mediaInfo.Info.PhysicalMedia.MediaPool != logicalMediaInfo.Info.LogicalMedia.MediaPool) {
            CWsbStringPtr idPhysical = mediaInfo.Info.PhysicalMedia.CurrentLibrary;
            CWsbStringPtr idLogical = logicalMediaInfo.Info.LogicalMedia.MediaPool;
            WsbTraceAlways(OLESTR("CRmsNTMS::FindCartridge - Media Pool Id mismatch %ls != %ls\n"), idPhysical, idLogical );
        }

        // Fill in the return argument.
        *ppCartridge = pCart;

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::FindCartridge - %ls Not Found.  hr = <%ls>\n"),WsbGuidAsString(cartId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::FindCartridge"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP
CRmsNTMS::Suspend(void)
/*++

Implements:

    CRmsNTMS::Suspend

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::Suspend"), OLESTR(""));

    try {

        WsbAffirmHr(changeState(RmsNtmsStateSuspending));
        WsbAffirmHr(endSession());
        WsbAffirmHr(changeState(RmsNtmsStateSuspended));

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::Suspend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP
CRmsNTMS::Resume(void)
/*++

Implements:

    CRmsNTMS::Resume

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::Resume"), OLESTR(""));

    try {

        WsbAffirmHr(changeState(RmsNtmsStateResuming));
        WsbAffirmHr(beginSession());
        WsbAffirmHr(changeState(RmsNtmsStateReady));

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::InitializeInAnotherThread(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::InitializeInAnotherThread"), OLESTR(""));

    try {

        DWORD threadId;
        HANDLE hThread;
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        WsbAffirmHr( pServer->ChangeState( RmsServerStateInitializing ));
        WsbAffirmHandle(hThread = CreateThread(NULL, 1024, CRmsNTMS::InitializationThread, this, 0, &threadId));
        CloseHandle(hThread);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::InitializeInAnotherThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


DWORD WINAPI
CRmsNTMS::InitializationThread(
    IN LPVOID pv)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::InitializationThread"), OLESTR(""));


    try {
        WsbAssertPointer(pv);
        CRmsNTMS *pNTMS = (CRmsNTMS*)pv;
        WsbAffirmHr(pNTMS->Initialize());
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        WsbAffirmHr( pServer->ChangeState( RmsServerStateReady ));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::InitializationThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
    } 


HRESULT
CRmsNTMS::isReady(void)
{

    HRESULT hr = S_OK;

    try {

        BOOL isEnabled;
        HRESULT status;
        RmsServerState state;

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        WsbAffirmHr( isEnabled = pObject->IsEnabled());
        WsbAffirmHr( pObject->GetState( (LONG *)&state ));
        WsbAffirmHr( pObject->GetStatusCode( &status ));

        if ( S_OK == isEnabled ) {
            if ( RmsServerStateReady == state ) {
                hr = S_OK;
            }
            else {
                if ( S_OK == status ) {
                    WsbThrow(E_UNEXPECTED);
                }
                else {
                    WsbThrow(status);
                }
            }
        }
        else {
            if ( S_OK == status ) {
                WsbThrow(E_UNEXPECTED);
            }
            else {
                WsbThrow(status);
            }
        }

    } WsbCatch(hr);

    return hr;
}



HRESULT
CRmsNTMS::setPoolDACL (
        IN OUT NTMS_GUID *pPoolId,
        IN DWORD subAuthority,
        IN DWORD action,
        IN DWORD mask)

{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::SetPoolDACL"), OLESTR("%ls <%d> <%d> <%d>"), WsbGuidAsString(*pPoolId), subAuthority, action, mask);

    PSID psidAccount = NULL;
    PSECURITY_DESCRIPTOR psdRePoolSd = NULL;

    try {

        SID_IDENTIFIER_AUTHORITY ntauth = SECURITY_NT_AUTHORITY;
        DWORD errCode = NO_ERROR, sizeTry = 5, sizeReturned = 0;
        PACL paclDis = NULL;
        BOOL daclPresent = FALSE, daclDefaulted = FALSE;
        HANDLE hSession = m_SessionHandle;

        WsbAffirmStatus(AllocateAndInitializeSid(&ntauth, 2, SECURITY_BUILTIN_DOMAIN_RID, subAuthority, 0, 0, 0, 0, 0, 0, &psidAccount));

        //Get the security descriptor for the pool
        for (;;) {
            if (psdRePoolSd != NULL) {
				free(psdRePoolSd);
			}
            psdRePoolSd = (PSECURITY_DESCRIPTOR)malloc(sizeTry);
            WsbAffirm(NULL != psdRePoolSd, E_OUTOFMEMORY);

            errCode = GetNtmsObjectSecurity(hSession, pPoolId, NTMS_MEDIA_POOL, DACL_SECURITY_INFORMATION, psdRePoolSd, sizeTry, &sizeReturned);

            if (errCode == ERROR_SUCCESS) {
                break;
            }
            else if (errCode == ERROR_INSUFFICIENT_BUFFER) {
                sizeTry = sizeReturned;
                continue;
            }
			else {
				WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
							OLESTR("GetNtmsObjectSecurity"),
							WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
							NULL );
				WsbAffirmNoError(errCode);
			}
        }

        // Get a pointer to the DACL
        WsbAffirmStatus(GetSecurityDescriptorDacl(psdRePoolSd, &daclPresent, &paclDis, &daclDefaulted));

        // Go through the DACL and change the mask of the ACE that matches the SID
        for (DWORD i = 0;i < paclDis->AceCount; ++i) {

            // Get the ACE and its header
            LPVOID pAce = NULL;
            WsbAffirmStatus(GetAce(paclDis, i, &pAce));
            ACE_HEADER * pAceHeader = (ACE_HEADER*) pAce;
            
            // Ignore non-allowed ACEs - BUG 584785
            if (pAceHeader->AceType != ACCESS_ALLOWED_ACE_TYPE)
                continue;

            // Take out the flags
            ACCESS_ALLOWED_ACE *pAccessAllowedAce = (ACCESS_ALLOWED_ACE *)pAce;
            if (EqualSid(psidAccount, &(pAccessAllowedAce->SidStart))) {
                if (action == ADD_ACE_MASK_BITS) {
                    pAccessAllowedAce->Mask |= mask;
                } else {
                    pAccessAllowedAce->Mask &= ~mask;
                }
            }
        }

        // Set the pool security descriptor
        errCode = SetNtmsObjectSecurity(hSession, pPoolId, NTMS_MEDIA_POOL, DACL_SECURITY_INFORMATION, psdRePoolSd);
        WsbAffirmNoError(errCode);

    }  WsbCatch(hr);

	if (psdRePoolSd) {
		free(psdRePoolSd);
	}

	if (psidAccount) {
		FreeSid(psidAccount);
	}

    WsbTraceOut(OLESTR("CRmsNTMS::SetPoolDACL"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsNTMS::IsMediaCopySupported (
    IN REFGUID mediaPoolId)
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::IsMediaCopySupported"), OLESTR("%ls"), WsbGuidAsString(mediaPoolId));

    try {

        // If we can find two drives that support this media type then
        // the media copy operation is supported.

        // For each drive known to NTMS we need to find what media types
        // it supports.  NTMS doesn't keep media type information for the
        // drive, but assumes homogeneous drives in a library (per HighGound) -
        // so detecting this is a bit convoluted.

        // we'll search through each library and find the media types
        // supported, and count the number of drives in the library.

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        NTMS_OBJECTINFORMATION mediaPoolInfo;
        NTMS_GUID poolId = mediaPoolId;

        memset(&mediaPoolInfo, 0, sizeof(NTMS_OBJECTINFORMATION));

        mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
        mediaPoolInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);

        // NTMS - Get Media Pool Information
        WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
        DWORD errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
        if ( errCode != NO_ERROR ) {

            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                OLESTR("GetNtmsObjectInformation"),
                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                NULL );

            WsbThrow( E_UNEXPECTED );

        }

        NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

        NTMS_OBJECTINFORMATION libInfo;
        HANDLE hFindLib = NULL;
        int driveCount = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY,
            GUID_NULL, NULL, GUID_NULL, &hFindLib, &libInfo);
        while( S_OK == hr ) {
            HANDLE hFindLib2 = NULL;
            // now see if the library in which the drive is contained supported
            // the specified media type

            if ( libInfo.Info.Library.dwNumberOfDrives > 0 ) {
                hr = findFirstNtmsObject( NTMS_MEDIA_TYPE,
                    libInfo.ObjectGuid, NULL, mediaTypeId, &hFindLib2, NULL);
                WsbTrace(OLESTR("Searching <%ls> for media type and drives; hr = %ls (state = %d, enabled = %ls, drives = %d)\n"),
                    libInfo.szName, WsbHrAsString(hr),
                    libInfo.dwOperationalState,
                    WsbBoolAsString(libInfo.Enabled),
                    libInfo.Info.Library.dwNumberOfDrives);
                if ((S_OK == hr) &&
                    ((NTMS_READY == libInfo.dwOperationalState) ||
                     (NTMS_INITIALIZING == libInfo.dwOperationalState)) &&
                    (libInfo.Enabled)) {

                    driveCount += libInfo.Info.Library.dwNumberOfDrives;
                }
                findCloseNtmsObject( hFindLib2 );
            }

            hr = findNextNtmsObject( hFindLib, &libInfo );
        }
        findCloseNtmsObject( hFindLib );

        hr = (driveCount > 1) ? S_OK : S_FALSE;

    }  WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::IsMediaCopySupported"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP 
CRmsNTMS::UpdateDrive(
        IN IRmsDrive *pDrive)
/*++

Implements:

    IRmsNTMS::UpdateDrive

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IRmsComObject>  pObject;
    GUID                    driveId;
    DWORD                   err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::UpdateDrive"), OLESTR(""));

    try	{
		// get drive information
        WsbAffirmHr(pDrive->QueryInterface(IID_IRmsComObject, (void **)&pObject));
        WsbAffirmHr(pObject->GetObjectId(&driveId));

        NTMS_OBJECTINFORMATION objectInfo;
        objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        objectInfo.dwType = NTMS_DRIVE;
		WsbAssert(driveId != GUID_NULL, E_INVALIDARG);
        err1 = GetNtmsObjectInformation( m_SessionHandle, &driveId, &objectInfo );
        WsbAffirmNoError (err1);

        // Note: Currently, the method updates only the enable/disable state of the drive
        //          If required, the method may update more fields
		if (objectInfo.Enabled) {
            WsbAffirmHr(pObject->Enable());
        } else {
            WsbAffirmHr(pObject->Disable(S_OK));
        }

	}  WsbCatchAndDo(hr,
		// Process the error of the get-info request
		if (err1 != NO_ERROR ) {
            if (err1 == ERROR_OBJECT_NOT_FOUND) {
                hr = RMS_E_NTMS_OBJECT_NOT_FOUND;
            }
            WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
				OLESTR("GetNtmsObjectInformation (Drive)"), OLESTR(""),
				WsbHrAsString(hr), NULL);
        }
	);

    WsbTraceOut(OLESTR("CRmsNTMS::UpdateDrive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CRmsNTMS::GetNofAvailableDrives( 
    OUT DWORD* pdwNofDrives 
    )

/*++

Implements:

  IRmsNTMS::GetNofAvailableDrives().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::GetNofAvailableDrives"), OLESTR(""));

    *pdwNofDrives = 0;
    
    // Enumerate over all libraries that HSM uses
    //  (Outside the try block, since we want to continue if a failure occur on a specific library)
    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: Total number of libraries is %lu\n"), m_dwNofLibs);
    for (int j=0; j<(int)m_dwNofLibs; j++) {

        LPNTMS_GUID     pObjects = NULL;
        DWORD           errCode = NO_ERROR;

        // get library id
        GUID libId = m_pLibGuids[j];

        // If object is suspended/suspending, just terminate (without logging an error)
        if ((m_State == RmsNtmsStateSuspended) || (m_State == RmsNtmsStateSuspending)) {
            WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: Object is suspended/suspending - exit\n"));
            break;
        }

        try {

            // Enumerate on all drives in the library
            DWORD       dwNofObjects = 16;  // Initial size of object id array to allocate
            int         nRetry = 0;

            // Allocate according to 
            pObjects = (LPNTMS_GUID)WsbAlloc( dwNofObjects*sizeof(NTMS_GUID) );
            WsbAffirmPointer( pObjects );

            // Enumerate all drives
            do {
                errCode = EnumerateNtmsObject(m_SessionHandle, &libId, pObjects, &dwNofObjects, NTMS_DRIVE, 0);
                WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Total number of drives is %lu\n"),
                                dwNofObjects);
                nRetry++;

                if ( (ERROR_OBJECT_NOT_FOUND == errCode) || (0 == dwNofObjects) ) {  // Don't count on NTMS returning the correct errCode
                    // Not considered as an NTMS error, prevent logging by setting to NO_ERROR
                    errCode = NO_ERROR;
                    WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
                } else if (ERROR_INSUFFICIENT_BUFFER == errCode) {
                    // Don't retry more than 3 times
                    if (3 <= nRetry) {
                        WsbThrow(HRESULT_FROM_WIN32(errCode));
                    }

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: Reallocating buffer\n"));
                    LPVOID pTemp = WsbRealloc( pObjects, dwNofObjects*sizeof(NTMS_GUID) );
                    if (!pTemp) {
                        WsbThrow(E_OUTOFMEMORY);
                    }
                    pObjects = (LPNTMS_GUID)pTemp;
                } else {
                    // Other unexpected error
                    WsbAffirmNoError(errCode);
                }

            } while (ERROR_INSUFFICIENT_BUFFER == errCode);

            // go over all drives, get information and check availablity
            for (int i = 0; i < (int)dwNofObjects; i++) {

                GUID driveId = pObjects[i];
                try {
                    NTMS_OBJECTINFORMATION objectInfo;
                    memset( &objectInfo, 0, sizeof(NTMS_OBJECTINFORMATION) );
                    objectInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);
                    objectInfo.dwType = NTMS_DRIVE;
        		    WsbAssert(driveId != GUID_NULL, E_INVALIDARG);
                    errCode = GetNtmsObjectInformation(m_SessionHandle, &driveId, &objectInfo );
                    WsbAffirmNoError (errCode);

                    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: drive <%ls> enable/disable = %ls\n"),
                            WsbGuidAsString(driveId), WsbBoolAsString(objectInfo.Enabled));
                       
		            if (objectInfo.Enabled) {
                        (*pdwNofDrives)++;
                    }

	            }  WsbCatchAndDo(hr,
		            // Log error and go on to the next drive
        		    if (errCode != NO_ERROR ) {
                        WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
    		    		    OLESTR("GetNtmsObjectInformation (Drive)"), OLESTR(""),
       			    	    WsbHrAsString(hr), NULL);
                    }

                    WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Failed to get info for drive <%ls> hr = <%ls>\n"),
                            WsbGuidAsString(driveId), WsbHrAsString(hr));
                    hr = S_OK;
	            );        
            }

        } WsbCatchAndDo(hr,
            // Log error and go on to the next library
        	if (errCode != NO_ERROR ) {
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
    		        OLESTR("EnumerateNtmsObject (Drive)"), OLESTR(""),
       			    WsbHrAsString(hr), NULL);
            }

            WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Failed to enumerate drives in library <%ls> hr = <%ls>\n"),
                    WsbGuidAsString(libId), WsbHrAsString(hr));
            hr = S_OK;
        );        

        if (pObjects) {
            WsbFree(pObjects);
        }

    }   // of for


    WsbTraceOut(OLESTR("CRmsNTMS::GetNofAvailableDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CRmsNTMS::CheckSecondSide( 
    IN REFGUID firstSideId,
    OUT BOOL *pbValid,
    OUT GUID *pSecondSideId
    )

/*++

Implements:

  IRmsNTMS::CheckSecondSide().

--*/
{
    HRESULT         hr = S_OK;
    DWORD           err1 = NO_ERROR;
    DWORD           err2 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::CheckSecondSide"), OLESTR(""));

    *pbValid = FALSE;
    *pSecondSideId = GUID_NULL;

    try {

        WsbAssert(firstSideId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(pbValid);
        WsbAssertPointer(pSecondSideId);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        HANDLE hSession = m_SessionHandle;
        NTMS_GUID mediaId = firstSideId;
        NTMS_GUID firstSidePartitionId;
        NTMS_GUID side[2];
        DWORD sideNo = 2;


        // NTMS - get Partition from LMID
        WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
        err1 = EnumerateNtmsObject(hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0);
        WsbAffirmNoError(err1);
        firstSidePartitionId = side[0];

        // NTMS - get partition information (using size 0 - LMID relates 1:1 to Partition
        partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        partitionInfo.dwType = NTMS_PARTITION;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
        err2 = GetNtmsObjectInformation(hSession, &firstSidePartitionId, &partitionInfo);
        WsbAffirmNoError(err2);

        // NTMS - get physical media information
        NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;
        mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
        err2 = GetNtmsObjectInformation(hSession, &physicalMediaId, &mediaInfo);
        WsbAffirmNoError(err2);

        // Check whether there are more than one side
        if (mediaInfo.Info.PhysicalMedia.dwNumberOfPartitions > 1) {
            // Enumerate physical meida - expect 2 sides here.
            WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
            sideNo = 2;
            err1 = EnumerateNtmsObject(hSession, &physicalMediaId, side, &sideNo, NTMS_PARTITION, 0);
            WsbAffirmNoError(err1);
            WsbAffirm(sideNo > 1, RMS_E_NOT_FOUND);

            // Look for a side whos partition id is different from first side
            for (DWORD i=0; i<sideNo; i++) {
                if (firstSidePartitionId != side[i]) {
                    *pbValid = TRUE;    // Valid second side found

                    // Get its LMID
                    WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                    err2 = GetNtmsObjectInformation(hSession, &side[i], &partitionInfo);
                    WsbAffirmNoError(err2);

                    *pSecondSideId = partitionInfo.Info.Partition.LogicalMedia;
                }
            }
        } // of if two sides

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::CheckSecondSide - of %ls failed: hr = <%ls>\n"),WsbGuidAsString(firstSideId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );
        
    WsbTraceOut(OLESTR("CRmsNTMS::CheckSecondSide"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsNTMS::EnsureAllSidesNotAllocated(
    IN REFGUID mediaId
    )
{
    HRESULT     hr = S_OK;
    DWORD       err1 = NO_ERROR;
    DWORD       err2 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated"), OLESTR(""));

    try {
        WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );
        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        HANDLE hSession = m_SessionHandle;

        NTMS_GUID physicalMediaId = mediaId;
        mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;
        partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        partitionInfo.dwType = NTMS_PARTITION;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
        err2 = GetNtmsObjectInformation(hSession, &physicalMediaId, &mediaInfo);
        WsbAffirmNoError(err2);

        // Check whether there are more than one side
        if (mediaInfo.Info.PhysicalMedia.dwNumberOfPartitions > 1) {
            // Enumerate physical meida - expect 2 sides here.
            NTMS_GUID side[2];
            DWORD sideNo = 2;
            WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
            err1 = EnumerateNtmsObject(hSession, &physicalMediaId, side, &sideNo, NTMS_PARTITION, 0);
            WsbAffirmNoError(err1);

            // Look for a side which is allocated
            for (DWORD i=0; i<sideNo; i++) {
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation(hSession, &side[i], &partitionInfo);
                WsbAffirmNoError(err2);

                if (GUID_NULL != partitionInfo.Info.Partition.LogicalMedia) {
                    hr = S_FALSE;
                    break;
                }
            }
        } // of if two sides

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated - of %ls failed: hr = <%ls>\n"),WsbGuidAsString(mediaId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );

    WsbTraceOut(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

STDMETHODIMP 
CRmsNTMS::DismountAll(
    IN REFGUID fromMediaSet,
    IN DWORD dwOptions)
/*++

Implements:

    IRmsNTMS::DismountAll

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::DismountAll"), OLESTR("") );

    try {
        WsbAssert(GUID_NULL != fromMediaSet, E_INVALIDARG);

        HANDLE hFindMedia = NULL;
        DWORD err1 = NO_ERROR;
        HANDLE hSession = m_SessionHandle;
        NTMS_OBJECTINFORMATION physicalMediaInfo;
        NTMS_GUID setId = fromMediaSet;
        NTMS_GUID partId = GUID_NULL;

        // Dismount all mounted medias from the given pool

        hr = findFirstNtmsObject(NTMS_PHYSICAL_MEDIA, setId, NULL, GUID_NULL, &hFindMedia, &physicalMediaInfo);
        while(S_OK == hr) {
            switch (physicalMediaInfo.Info.PhysicalMedia.MediaState) {
                case NTMS_MEDIASTATE_LOADED:
                case NTMS_MEDIASTATE_MOUNTED:
                    // Dismount the media
                    try {
                        partId = physicalMediaInfo.Info.PhysicalMedia.MountedPartition;
                        WsbAffirm(GUID_NULL != partId, E_UNEXPECTED);

                        DWORD dwNtmsOptions = 0;
                        WsbTraceAlways(OLESTR("DismountNtmsMedia()\n"));
				        if (! ( dwOptions & RMS_DISMOUNT_IMMEDIATE )) {
					        dwNtmsOptions |= NTMS_DISMOUNT_DEFERRED;
				        }
                        err1 = DismountNtmsMedia(hSession, &partId, 1, dwNtmsOptions);
                        WsbAffirmNoError(err1);

                    } WsbCatchAndDo(hr,
                        if (err1 != NO_ERROR) {
                            WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                                OLESTR("DismountNtmsMedia"), OLESTR(""),
                                WsbHrAsString(hr), NULL);
                        }
                    );

                    break;

                default:
                    // Media is not mounted - skip it
                    break;
            }

            hr = findNextNtmsObject(hFindMedia, &physicalMediaInfo);
       } 

       findCloseNtmsObject(hFindMedia);
       hr = S_OK;

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::DismountAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}

HRESULT
CRmsNTMS::GetMaxMediaCapacity(
    IN REFGUID fromMediaSet,
    OUT LONGLONG *pMaxCapacity
    )
/*++

Implements:

    IRmsNTMS::GetMaxMediaCapacity

Notes:
    
    Traverse all the media in the Remote Storage pool & the free media pool and retruns max capacity

--*/
{
    HRESULT     hr = S_OK;
    DWORD       err1 = NO_ERROR;
    DWORD       err2 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::GetMaxMediaCapacity"), OLESTR(""));

    try {
        WsbAssert(fromMediaSet != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(pMaxCapacity);

        *pMaxCapacity = 0;

        NTMS_GUID setId = fromMediaSet;

        HANDLE hFindPart = NULL;
        NTMS_OBJECTINFORMATION partitionInfo;

        HANDLE hFindPool = NULL;
        NTMS_OBJECTINFORMATION mediaPoolInfo;

        NTMS_GUID scratchPoolId;

        HANDLE hSession = m_SessionHandle;

       // First look in RSS pool for media which are OK for capacity comparison
        hr = findFirstNtmsObject(NTMS_PARTITION, setId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
        while(S_OK == hr) {
            BOOL bCheckState = (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_ALLOCATED) ||
                               (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_AVAILABLE) ||
                               (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_COMPLETE) ||
                               (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_RESERVED);

            if ((TRUE == partitionInfo.Enabled) &&
                (NTMS_READY == partitionInfo.dwOperationalState) &&
                (TRUE == bCheckState)) {

                // Compare capacity to maximum
                if (partitionInfo.Info.Partition.Capacity.QuadPart > *pMaxCapacity) {
                    *pMaxCapacity = partitionInfo.Info.Partition.Capacity.QuadPart;
                }
            }

            hr = findNextNtmsObject(hFindPart, &partitionInfo);
        } 

        findCloseNtmsObject(hFindPart);
        hr = S_OK;

       // Now look in scratch pool for media which are OK for capacity comparison

       // Get and save the media type for the RSS media pool
       memset(&mediaPoolInfo, 0, sizeof(NTMS_OBJECTINFORMATION));
       mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
       mediaPoolInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);

       WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_MEDIA_POOL)\n"));
       WsbAffirmNoError(GetNtmsObjectInformation(hSession, &setId, &mediaPoolInfo));

       NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

       // Find the scratch pool with the same media type
       hr = findFirstNtmsObject(NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFindPool, &mediaPoolInfo);
       while(S_OK == hr) {
           if ((NTMS_POOLTYPE_SCRATCH == mediaPoolInfo.Info.MediaPool.PoolType) &&
               (mediaTypeId == mediaPoolInfo.Info.MediaPool.MediaType)) {

               // This is a base level scratch media pool for type we're looking for.
               scratchPoolId = mediaPoolInfo.ObjectGuid;

               hr = findFirstNtmsObject(NTMS_PARTITION, scratchPoolId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
               while(S_OK == hr) {
                    BOOL bCheckState = (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_ALLOCATED) ||
                                       (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_AVAILABLE) ||
                                       (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_COMPLETE) ||
                                       (partitionInfo.Info.Partition.State == NTMS_PARTSTATE_RESERVED);

                    if ((TRUE == partitionInfo.Enabled) &&
                        (NTMS_READY == partitionInfo.dwOperationalState) &&
                        (TRUE == bCheckState)) {

                        // Compare capacity to maximum
                        if (partitionInfo.Info.Partition.Capacity.QuadPart > *pMaxCapacity) {
                            *pMaxCapacity = partitionInfo.Info.Partition.Capacity.QuadPart;
                        }
                    }

                    hr = findNextNtmsObject(hFindPart, &partitionInfo);
                } 

                findCloseNtmsObject(hFindPart);
                hr = S_OK;

                // Get out - no need to traverse more pools...
                break;
            }

            hr = findNextNtmsObject(hFindPool, &mediaPoolInfo);
        } // while finding media pools

        findCloseNtmsObject(hFindPool);
        hr = S_OK;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsNTMS::GetMaxMediaCapacity"), OLESTR("hr = <%ls>, Max-media-size = %I64d"), 
                    WsbHrAsString(hr), *pMaxCapacity);
    return(hr);
}

STDMETHODIMP 
CRmsNTMS::DisableAndEject(
    IN IRmsCartridge *pCart,
    IN DWORD dwOptions
    )

/*++

Implements:

    IRmsNTMS::DisableAndEject

Notes:
    1) Currently, the operator request to eject media has a format failure as a reason.
    In the future, the dwOptions parameter could be used to specify other operator requests
    or the method may get a partial text for the operator request from the caller

    2) The dwOptions is not used at all for now. In the future, it may be used to speficy
    disable-only, other operator requests, etc.

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::DisableAndEject"), OLESTR(""));

    UNREFERENCED_PARAMETER(dwOptions);

    try {
        WsbAssertPointer(pCart);

        HANDLE      hSession = m_SessionHandle;
        DWORD       sideNo = 2;
        NTMS_GUID   side[2];

        NTMS_GUID mediaId = GUID_NULL;
        WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
        WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

        // Enumerate to get partition id out of a logical media
        WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
        err1 = EnumerateNtmsObject(hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0);
        WsbAffirmNoError(err1);
		WsbAssert(side[0] != GUID_NULL, E_INVALIDARG);

        // Get physical media id
        NTMS_OBJECTINFORMATION partInfo;
        partInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);
        partInfo.dwType = NTMS_PARTITION;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
		err1 = GetNtmsObjectInformation(hSession, &side[0], &partInfo );
		WsbAffirmNoError(err1);
        NTMS_GUID physicalMediaId = partInfo.Info.Partition.PhysicalMedia;
		WsbAssert(physicalMediaId != GUID_NULL, E_INVALIDARG);

        // Disable the media
        WsbTraceAlways(OLESTR("DisableNtmsObject()\n"));
        err1 = DisableNtmsObject(hSession, NTMS_PHYSICAL_MEDIA, &physicalMediaId);

        // Since RSM Disable object is asyncronous, we may need to wait some arbitrary time,
        //  in order that when we come back, the media is really disabled
        if (NO_ERROR == err1) {
            DWORD size;
            OLECHAR tmpString[256];
            DWORD waitTime = RMS_DEFAULT_AFTER_DISABLE_WAIT_TIME;

            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_AFTER_DISABLE_WAIT_TIME, tmpString, 256, &size))) {
                waitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("AfterDisableWaitTime is %d milliseconds.\n"), waitTime);
            }

            Sleep(waitTime);
        }

        // Continue even if there's an error
        if (NO_ERROR != err1) {
            WsbTraceAlways(OLESTR("CRmsNTMS::DisableAndEject: DisableNtmsObject on media %ls failed with error %lu\n"),
                    WsbGuidAsString(physicalMediaId), err1);
        }

        // Try to get the slot number for the operator request. ignore error - slot is set to blank
	    WCHAR slotNumber[16];
        wcscpy(slotNumber, L" ");

        NTMS_OBJECTINFORMATION mediaInfo;
        mediaInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);
        mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
		err1 = GetNtmsObjectInformation(hSession, &physicalMediaId, &mediaInfo);
        if (NO_ERROR == err1) {
            NTMS_GUID homeSlotId = mediaInfo.Info.PhysicalMedia.HomeSlot;

            NTMS_OBJECTINFORMATION slotInfo;
            slotInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);
            slotInfo.dwType = NTMS_STORAGESLOT;

            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
	    	err1 = GetNtmsObjectInformation(hSession, &homeSlotId, &slotInfo);
            if (NO_ERROR == err1) {
                swprintf(slotNumber, L"%lu", slotInfo.Info.StorageSlot.Number);
            } else {
                WsbTraceAlways(OLESTR("CRmsNTMS::DisableAndEject: GetNtmsObjectInformation failed for slot %ls with error %lu\n"),
                        WsbGuidAsString(homeSlotId), err1);
            }

        } else {
            WsbTraceAlways(OLESTR("CRmsNTMS::DisableAndEject: GetNtmsObjectInformation failed for media %ls with error %lu\n"),
                    WsbGuidAsString(physicalMediaId), err1);
        }

        // Get text for the operator request (assume eject due to a format failure for now)
	    CWsbBstrPtr cartridgeName;
        WCHAR *messageText = NULL;
        WCHAR *stringArr[2];

		WsbAffirmHr(pCart->GetName(&cartridgeName));
        stringArr[0] = (WCHAR *)cartridgeName;
        stringArr[1] = (WCHAR *)slotNumber;

        WsbAffirmStatus(FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              LoadLibraryEx( WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE ), 
                              RMS_MESSAGE_EJECT_BAD_MEDIA_REQUEST, MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
                              (LPTSTR)&messageText, 0, (va_list *)stringArr));

        // Submit an operator request to eject the media 
		NTMS_GUID libId = GUID_NULL;
		NTMS_GUID requestId = GUID_NULL;

        WsbTraceAlways(OLESTR("SubmitNtmsOperatorRequest()\n"));
		err1 = SubmitNtmsOperatorRequest(hSession, NTMS_OPREQ_MESSAGE,
                    	messageText, &physicalMediaId, &libId, &requestId);
        LocalFree(messageText);
        WsbAffirmNoError (err1);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsNTMS::DisableAndEject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsmdset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsMdSet.h

Abstract:

    Declaration of the CRmsMediaSet class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSMDSET_
#define _RMSMDSET_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsSInfo.h"       // CRmsStorageInfo

/*++

Class Name:

    CRmsMediaSet

Class Description:

    A CRmsMediaSet is a logical repository for Cartridges.

--*/

class CRmsMediaSet :
    public CComDualImpl<IRmsMediaSet, &IID_IRmsMediaSet, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsMediaSet,&CLSID_CRmsMediaSet>
{
public:
    CRmsMediaSet() {}
BEGIN_COM_MAP(CRmsMediaSet)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsMediaSet)
    COM_INTERFACE_ENTRY(IRmsMediaSet)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsMediaSet)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsMediaSet
public:
    STDMETHOD(GetMediaSetId)(GUID *pMediaSetId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetMediaSetType)(LONG *pType);
    STDMETHOD(SetMediaSetType)(LONG type);

    STDMETHOD(GetMaxCartridges)(LONG *pNum);
    STDMETHOD(SetMaxCartridges)(LONG num);

    STDMETHOD(GetOccupancy)(LONG *pNum);
    STDMETHOD(SetOccupancy)(LONG num);

    STDMETHOD(IsMediaCopySupported)();
    STDMETHOD(SetIsMediaCopySupported)(BOOL flag);

    STDMETHOD(Allocate)(
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN BSTR displayName,
        IN DWORD dwOptions,
        OUT IRmsCartridge **ppCart);

    STDMETHOD(Deallocate)(
        IN IRmsCartridge *pCart);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 128,                      // Size of the application specific
                                            //   infomation buffer.  Currently
                                            //   fixed in size.
        };                                  //
    RmsMedia        m_MediaSupported;       // supported media format(s) for this media set.
                                            //   One or more types are permissible, but
                                            //   not all combinations are sensical.
    SHORT           m_SizeOfInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_Info[MaxInfo];        // Application specific information.
    CLSID           m_OwnerId;              // the registered Class ID of the
                                            //   application that owns/created the
                                            //   MediaSet.
    RmsMediaSet     m_MediaSetType;         // the type of MediaSet.
    LONG            m_MaxCartridges;        // max number of Cartridges allowed in the
                                            //    MediaSet.
    LONG            m_Occupancy;            // number of Cartridges presently in the
                                            //    MediaSet.
    BOOL            m_IsMediaCopySupported; // TRUE, if the media in the MediaSet can be
                                            //    copied.  This requires simultaneous
                                            //    access to two drives.
};

#endif // _RMSMDSET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsreqst.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsReqst.cpp

Abstract:

    Implementation of CRmsRequest

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsReqst.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsRequest::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsRequest::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsRequest interface to get the value of the object.
        CComQIPtr<IRmsRequest, &IID_IRmsRequest> pRequest = pCollectable;
        WsbAssertPointer( pRequest );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByRequestNo:
            {
                LONG    requestNo;

                WsbAffirmHr(pRequest->GetRequestNo(&requestNo));

                if ( m_requestNo == requestNo ) {

                    // request number matches
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
            }
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsRequest::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsRequest::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_requestNo = 0;

        m_requestDescription = RMS_UNDEFINED_STRING;

        m_isDone = FALSE;

        m_operation = RMS_UNDEFINED_STRING;

//      m_percentComplete = 0;

//      m_startTimestamp = 0;

//      m_stopTimestamp = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsRequest::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsRequest;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       requestDescriptionLen;
//    ULONG       operationLen;

    WsbTraceIn(OLESTR("CRmsRequest::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        requestDescriptionLen = SysStringByteLen(m_requestDescription);
//        operationLen = SysStringByteLen(m_operation);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)   +     // m_requestNo
//                             WsbPersistSizeOf(LONG)   +     // length of m_requestDescription
//                             requestDescriptionLen    +     // m_requestDescription
//                             WsbPersistSizeOf(BOOL)   +     // m_isDone
//                             WsbPersistSizeOf(LONG)   +     // length of m_operation
//                             operationLen             +     // m_operation
//                             WsbPersistSizeOf(BYTE)   +     // m_percentComplete
//                             WsbPersistSizeOf(DATE)   +     // m_startTimestamp
//                             WsbPersistSizeOf(DATE);        // m_stopTimestamp

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsRequest::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_requestNo));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_requestDescription));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isDone));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_operation));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_percentComplete));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTimestamp));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_stopTimeStamp));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsRequest::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_requestNo));

        WsbAffirmHr(WsbBstrToStream(pStream, m_requestDescription));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isDone));

        WsbAffirmHr(WsbBstrToStream(pStream, m_operation));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_percentComplete));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_startTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_stopTimeStamp));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsRequest>    pRequest1;
    CComPtr<IRmsRequest>    pRequest2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;


    WsbTraceIn(OLESTR("CRmsRequest::Test"), OLESTR(""));

    try {
        // Get the Request interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsRequest*) this)->QueryInterface(IID_IRmsRequest, (void**) &pRequest1));

            // Test GetRequestNo
            m_requestNo = 99;
            longWork1 = m_requestNo;

            GetRequestNo(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetRequestDescription & GetRequestDescription interface
            bstrWork1 = bstrVal1;

            SetRequestDescription(bstrWork1);

            GetRequestDescription(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsDone & IsDone to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsDone (TRUE));
                WsbAffirmHr(IsDone ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsDone & IsDone to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsDone (FALSE));
                WsbAffirmHr(IsDone ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetOperation & GetOperation interface
            bstrWork1 = bstrVal1;

            SetOperation(bstrWork1);

            GetOperation(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPercentComplete & GetPercentComplete

            // Test GetStartTimestamp

            // Test GetStopTimestamp

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetRequestNo(
    LONG   *pRequestNo
    )
/*++

Implements:

    IRmsRequest::GetRequestNo

--*/
{
    *pRequestNo = m_requestNo;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetRequestDescription(
    BSTR   *pDesc
    )
/*++

Implements:

    IRmsRequest::GetRequestDescription

--*/
{
    WsbAssertPointer (pDesc);

    m_requestDescription. CopyToBstr (pDesc);
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetRequestDescription(
    BSTR   desc

    )
/*++

Implements:

    IRmsRequest::SetRequestDescription

--*/
{
    m_requestDescription = desc;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetIsDone(
    BOOL    flag
    )
/*++

Implements:

    IRmsRequest::SetIsDone

--*/
{
    m_isDone = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::IsDone(
    void
    )
/*++

Implements:

    IRmsRequest::IsDone

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isDone){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsRequest::GetOperation(
    BSTR    *pOperation
    )
/*++

Implements:

    IRmsRequest::GetOperation

--*/
{
    WsbAssertPointer (pOperation);

    m_operation. CopyToBstr (pOperation);
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetOperation(
    BSTR   operation
    )
/*++

Implements:

    IRmsRequest::SetOperation

--*/
{
    m_operation = operation;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetPercentComplete(
    BYTE    *pPercent
    )
/*++

Implements:

    IRmsRequest::GetPercentComplete

--*/
{
    *pPercent = m_percentComplete;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetPercentComplete(
    BYTE    percent
    )
/*++

Implements:

    IRmsRequest::SetPercentComplete

--*/
{
    m_percentComplete = percent;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetStartTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsRequest::GetStartTimestamp

--*/
{
    *pDate = m_startTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetStopTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsRequest::GetStopTimestamp

--*/
{
    *pDate = m_stopTimestamp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsntms.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsNTMS.h

Abstract:

    Declaration of the CRmsNTMS class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSNTMS_
#define _RMSNTMS_

#include "ntmsapi.h"

#include "resource.h"       // main symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsNTMS

Class Description:

    A CRmsNTMS represents...

--*/


class CRmsNTMS :
    public CComDualImpl<IRmsNTMS, &IID_IRmsNTMS, &LIBID_RMSLib>,
    public CRmsComObject,
    public CComObjectRoot,
    public IConnectionPointContainerImpl<CRmsNTMS>,
    public IConnectionPointImpl<CRmsNTMS, &IID_IRmsSinkEveryEvent, CComDynamicUnkArray>,
    public CComCoClass<CRmsNTMS,&CLSID_CRmsNTMS>
{
public:
    CRmsNTMS() {}
BEGIN_COM_MAP(CRmsNTMS)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsNTMS)
    COM_INTERFACE_ENTRY(IRmsNTMS)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsNTMS)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CONNECTION_POINT_MAP(CRmsNTMS)
    CONNECTION_POINT_ENTRY(IID_IRmsSinkEveryEvent)
END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IRmsNTMS
public:
    STDMETHOD(IsInstalled)(void);
    STDMETHOD(Initialize)(void);

    STDMETHOD(Allocate)(
        IN REFGUID fromMediaSet,
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN BSTR displayName,
        IN DWORD dwOptions,
        OUT IRmsCartridge **ppCartridge);

    STDMETHOD(Mount)(
        IN IRmsCartridge *pCart,
        OUT IRmsDrive **ppDrive,
		IN DWORD dwOptions = RMS_NONE,
        IN DWORD threadId = 0);

    STDMETHOD(Dismount)(
        IN IRmsCartridge *pCart, 
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD(Deallocate)(
        IN IRmsCartridge *pCart);

    STDMETHOD(UpdateOmidInfo)(
        IN REFGUID cartId,
        IN BYTE *pBuffer,
        IN LONG size,
        IN LONG type);

    STDMETHOD(GetBlockSize)(
        IN REFGUID cartId,
        OUT LONG *pBlockSize);

    STDMETHOD(SetBlockSize)(
        IN REFGUID cartId,
        IN LONG blockSize);

    STDMETHOD(ExportDatabase)(void);

    STDMETHOD(FindCartridge)(
        IN REFGUID cartId,
        OUT IRmsCartridge **ppCartridge);

    STDMETHOD(Suspend)(void);
    STDMETHOD(Resume)(void);

    STDMETHOD(IsMediaCopySupported)(
        IN REFGUID mediaPoolId);

    STDMETHOD(UpdateDrive)(
        IN IRmsDrive *pDrive);

    STDMETHOD(GetNofAvailableDrives)( 
        OUT DWORD *pdwNofDrives 
    );

    STDMETHOD(CheckSecondSide)( 
        IN REFGUID firstSideId,
        OUT BOOL *pbValid,
        OUT GUID *pSecondSideId
    );

    STDMETHOD(DismountAll)(
        IN REFGUID fromMediaSet,
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD(GetMaxMediaCapacity)(
        IN REFGUID fromMediaSet,
        OUT LONGLONG *pMaxCapacity);

    STDMETHOD(DisableAndEject)(
        IN IRmsCartridge *pCart, 
		IN DWORD dwOptions = RMS_NONE);

// CRmsNTMS - these may go public
private:
    HRESULT findFirstNtmsObject(
        IN DWORD objectType,
        IN REFGUID containerId,
        IN WCHAR *objectName,
        IN REFGUID objectId,
        OUT HANDLE *hFindObject,
        OUT LPNTMS_OBJECTINFORMATION pFindObjectData);

    HRESULT findNextNtmsObject(
        IN HANDLE hFindObject,
        OUT LPNTMS_OBJECTINFORMATION pFindObjectData);

    HRESULT findCloseNtmsObject(
        IN HANDLE hFindObject);

    HRESULT getNtmsSupportFromRegistry(
        OUT DWORD *pNtmsSupport);

    HRESULT reportNtmsObjectInformation(
        IN LPNTMS_OBJECTINFORMATION pObjectInfo);

    HRESULT beginSession(void);
    HRESULT endSession(void);
    HRESULT waitUntilReady(void);
    HRESULT waitForScratchPool(void);
    HRESULT createMediaPools(void);
    HRESULT replicateScratchMediaPool(IN REFGUID rootPoolId);
    HRESULT createMediaPoolForEveryMediaType(IN REFGUID rootPoolId);
    HRESULT isReady(void);
    HRESULT setPoolDACL(
        IN OUT NTMS_GUID *pPoolId,
        IN DWORD subAuthority,
        IN DWORD action,
        IN DWORD mask);

    HRESULT EnsureAllSidesNotAllocated(
        IN REFGUID physicalMediaId);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };
    HANDLE      m_SessionHandle;
    BOOL        m_IsRmsConfiguredForNTMS;
    BOOL        m_IsNTMSRegistered;

    DWORD       m_NotificationWaitTime;     // Milliseconds to wait for an object notification
    DWORD       m_AllocateWaitTime;         // Milliseconds to wait for a media allocation
    DWORD       m_MountWaitTime;            // Milliseconds to wait for a mount
    DWORD       m_RequestWaitTime;          // Milliseconds to wait for a request

    LPNTMS_GUID m_pLibGuids;               // Libraries which may have HSM medias (collected during initialization)
    DWORD       m_dwNofLibs;

    static HRESULT storageMediaTypeToRmsMedia(
        IN NTMS_MEDIATYPEINFORMATION *pMediaTypeInfo,
        OUT RmsMedia *pTranslatedMediaType);

    HRESULT changeState( IN LONG newState );

// Thread routines
public:
    static DWORD WINAPI InitializationThread(
        IN LPVOID pv);

    HRESULT InitializeInAnotherThread(void);

};

#endif // _RMSNTMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsobjct.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsObjct.cpp

Abstract:

    Implementation of CRmsComObject

Author:

    Brian Dodd      [brian]     15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsObjct.h"

/////////////////////////////////////////////////////////////////////////////
//


CRmsComObject::CRmsComObject(void)
/*++

Routine Description:

    CRmsComObject constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Default values
    (void) CoCreateGuid( &m_objectId );

    m_ObjectType    = RmsObjectUnknown;
    m_IsEnabled     = TRUE;
    m_State         = 0;
    m_StatusCode    = S_OK;
    m_Name          = OLESTR("Object");
    m_Description   = OLESTR("");

    memset( &m_Permit, 0, sizeof( SECURITY_DESCRIPTOR ) );

    m_findBy        = RmsFindByUnknown;

}


HRESULT
CRmsComObject::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsComObject::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByObjectId:
        default:
            {
                GUID objectId;

                // Get objectId.
                WsbAffirmHr( pObject->GetObjectId( &objectId ));

                if ( m_objectId == objectId ) {

                    // Object IDs match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
            }
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsComObject::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsComObject::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsComObject::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID) +           // m_objectId
//                             WsbPersistSizeOf(LONG) +           // m_findBy
//                             WsbPersistSizeOf(LONG) +           // m_state
//                             WsbPersistSizeOf(HRESULT);         // m_errCode

////                           WsbPersistSizeOf(SECURITY_DESCRIPTOR); // m_permit

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsComObject::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}


HRESULT
CRmsComObject::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsComObject::Load"), OLESTR(""));

    try {
        WsbAssertPointer( pStream );

        USHORT usTemp;
        ULONG  ulTemp;

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &usTemp));
        m_ObjectType = (RmsObject)usTemp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_IsEnabled));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_State));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ulTemp));
        m_StatusCode = (HRESULT)ulTemp;

        m_Name.Free(); // Clean out any thing previously held
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_Name));
        m_Description.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_Description));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_permit));

        WsbAffirmHr(WsbLoadFromStream(pStream, &usTemp));
        m_findBy = (RmsFindBy)usTemp;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsComObject::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsComObject::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsComObject::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer( pStream );

        // Read value
        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));
        WsbAffirmHr(WsbSaveToStream(pStream, (USHORT) m_ObjectType));
        WsbAffirmHr(WsbSaveToStream(pStream, m_IsEnabled));
        WsbAffirmHr(WsbSaveToStream(pStream, m_State));
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_StatusCode));
        WsbAffirmHr(WsbBstrToStream(pStream, m_Name));
        WsbAffirmHr(WsbBstrToStream(pStream, m_Description));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_permit));

        WsbAffirmHr(WsbSaveToStream(pStream, (USHORT) m_findBy));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsComObject::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsComObject::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed)
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>    pMediaSet1;
    CComPtr<IRmsMediaSet>    pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;
    LONG                    longWork2;

    HRESULT                 hresultVal1 = 11111111;
    HRESULT                 hresultWork1;

//  SECURITY_DESCRIPTOR     permitVal1;
//  SECURITY_DESCRIPTOR     permitWork1;


    WsbTraceIn(OLESTR("CRmsComObject::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetState & GetState
            for (i = RmsStateUnknown; i < RmsStateError; i++){

                longWork1 = i;

                SetState (longWork1);

                GetState (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test GetErrCode
            m_StatusCode = hresultVal1;

            GetStatusCode(&hresultWork1);

            if(hresultVal1 == hresultWork1){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetPermissions & GetPermissions
//          SetPermissions(permitVal1);

//          GetPermissions(&permitWork1);

//          if((permitVal1 == permitWork1)){
//             (*pPassed)++;
//          }  else {
//              (*pFailed)++;
//          }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsComObject::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsComObject::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] =
    {
    &IID_IRmsServer,
    &IID_IRmsLibrary,
    &IID_IRmsDriveClass,
    &IID_IRmsCartridge,
    &IID_IRmsDrive,
    &IID_IRmsStorageSlot,
    &IID_IRmsMediumChanger,
    &IID_IRmsIEPort,
    &IID_IRmsMediaSet,
    &IID_IRmsRequest,
    &IID_IRmsPartition,
    &IID_IRmsComObject,
    &IID_IRmsChangerElement,
    &IID_IRmsDevice,
    &IID_IRmsStorageInfo,
    &IID_IRmsNTMS,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
    if (InlineIsEqualGUID(*arr[i],riid))
        return S_OK;
    }
    return S_FALSE;
}


STDMETHODIMP
CRmsComObject::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_objectId;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsComObject::SetObjectId(
    IN GUID objectId)
/*++

Implements:

    IRmsComObject::SetObjectId

--*/
{
    m_objectId = objectId;
    return S_OK;
}

STDMETHODIMP
CRmsComObject::GetObjectType(
    OUT LONG *pType)
/*++

Implements:

    IRmsComObject::GetObjectType

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pType );

        *pType = m_ObjectType;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsComObject::SetObjectType(
    IN LONG type)
/*++

Implements:

    IRmsComObject::SetObjectType

--*/
{
    m_ObjectType = (RmsObject) type;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::IsEnabled(void)
/*++

Implements:

    IRmsComObject::IsEnabled

--*/
{
    return (m_IsEnabled) ? S_OK : S_FALSE;
}


STDMETHODIMP
CRmsComObject::Enable()
/*++

Implements:

    IRmsComObject::Enable

--*/
{
    HRESULT hr = S_OK;

    try {

        m_IsEnabled = TRUE;
        WsbAffirmHr(SetStatusCode(S_OK));

        // Log an Event
        WsbLogEvent(RMS_MESSAGE_OBJECT_ENABLED, 0, NULL, (WCHAR *)m_Name, NULL );

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::Disable(
    IN HRESULT reason)
/*++

Implements:

    IRmsComObject::Disable

--*/
{
    HRESULT hr = S_OK;

    try {

        m_IsEnabled = FALSE;
        WsbAffirmHr(SetStatusCode(reason));

        // Log an Event
        WsbLogEvent(RMS_MESSAGE_OBJECT_DISABLED, 0, NULL, (WCHAR *)m_Name, WsbHrAsString(reason), NULL );

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetState(
    OUT LONG *pState)
/*++

Implements:

    IRmsComObject::GetState

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pState );

        *pState = m_State;
        WsbTrace(OLESTR("GetState: Object <0x%08x> - Enabled = <%ls>; State = <%d>; StatusCode = <%ls>.\n"),
            this, WsbBoolAsString(m_IsEnabled), m_State, WsbHrAsString(m_StatusCode));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetState(
    IN LONG state)
/*++

Implements:

    IRmsComObject::SetState

--*/
{
    HRESULT hr = S_OK;

    try {

        m_State = state;
        WsbAffirmHr(SetStatusCode(S_OK));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetStatusCode(
    OUT HRESULT *pResult)
/*++

Implements:

    IRmsComObject::GetStatusCode

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pResult );

        *pResult = m_StatusCode;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetStatusCode(
    IN HRESULT result
    )
/*++

Implements:

    IRmsComObject::SetStatusCode

--*/
{
    HRESULT hr = S_OK;

    try {

        m_StatusCode = result;
        WsbAffirmHr(adviseOfStatusChange());

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsComObject::GetName

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pName );

        WsbAffirmHr( m_Name.CopyToBstr(pName) );

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsComObject::SetName(
    IN BSTR name)
/*++

Implements:

    IRmsComObject::SetName

--*/
{
    m_Name = name;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetDescription(
    OUT BSTR *pDesc)
/*++

Implements:

    IRmsComObject::GetDescription

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pDesc );

        WsbAffirmHr( m_Name.CopyToBstr(pDesc) );

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsComObject::SetDescription(
    IN BSTR desc)
/*++

Implements:

    IRmsComObject::SetDescription

--*/
{
    m_Description = desc;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetPermissions(
    OUT SECURITY_DESCRIPTOR *lpPermit)
/*++

Implements:

    IRmsComObject::GetPermissions

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( lpPermit );

        *lpPermit = m_Permit;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetPermissions(
    IN SECURITY_DESCRIPTOR permit)
/*++

Implements:

    IRmsComObject::GetPermissions

--*/
{

    m_Permit = permit;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetFindBy(
    OUT LONG *pFindBy)
/*++

Implements:

    IRmsComObject::GetFindBy

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pFindBy );

        *pFindBy = m_findBy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetFindBy(
    IN LONG findBy)
/*++

Implements:

    IRmsComObject::SetFindBy

--*/
{
    m_findBy = (RmsFindBy) findBy;
    return S_OK;
}


HRESULT
CRmsComObject::adviseOfStatusChange(void)
/*++

Routine Description:

    Notifies of object state changes. 

Arguments:

    None

Return Value:

    S_OK            - Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsComObject::adviseOfStatusChange"), OLESTR(""));

    try {
        CONNECTDATA                         pConnectData;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IEnumConnections>           pConnection;
        CComPtr<IRmsSinkEveryEvent>         pSink;

        WsbTrace(OLESTR("Object <0x%08x> - Enabled = <%ls>; State = <%d>; StatusCode = <%ls>.\n"),
            this, WsbBoolAsString(m_IsEnabled), m_State, WsbHrAsString(m_StatusCode));

        // Tell everyone the new state of the object.
        WsbAffirmHr(((IUnknown*)(IRmsComObject*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IRmsSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IRmsSinkEveryEvent, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessObjectStatusChange( m_IsEnabled, m_State, m_StatusCode ));
            } WsbCatch(hr);

            (pConnectData.pUnk)->Release();
            pSink=0;
        }

    } WsbCatch(hr);

    // We don't care if the sink has problems!
    hr = S_OK;

    WsbTraceOut(OLESTR("CRmsComObject::adviseOfStatusChange"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmspartn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsPartn.h

Abstract:

    Declaration of the CRmsPartition class

Author:

    Brian Dodd          [brian]         19-Nov-1996

Revision History:

--*/

#ifndef _RMSPARTN_
#define _RMSPARTN_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsSInfo.h"       // CRmsStorageInfo

/*++

Class Name:

    CRmsPartition

Class Description:

    A CRmsPartition represents a partition on a tape or a single side of
    a unit of optical media.  This object keeps on-media identification
    information, and various statistics about the Partition including:
    capacity, free space, number of physical mounts issued for the
    particular Partition, and the amount of data read or written for the
    Partition.

--*/

class CRmsPartition :
    public CComDualImpl<IRmsPartition, &IID_IRmsPartition, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsPartition,&CLSID_CRmsPartition>
{
public:
    CRmsPartition() {}
BEGIN_COM_MAP(CRmsPartition)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsPartition)
    COM_INTERFACE_ENTRY(IRmsPartition)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsPartition)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsPartition
public:
    STDMETHOD(GetPartNo)(LONG *pPartNo);

    STDMETHOD(GetAttributes)(LONG *pAttr);
    STDMETHOD(SetAttributes)(LONG attr);

    STDMETHOD(GetIdentifier)(UCHAR *pIdent, SHORT *pSize);
    STDMETHOD(SetIdentifier)(UCHAR *pIdent, SHORT size);

    STDMETHOD(GetStorageInfo)(IRmsStorageInfo **ptr);

    STDMETHOD(VerifyIdentifier)(void);
    STDMETHOD(ReadOnMediaId)(UCHAR *pId, LONG *pSize);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxId = 64,                         // The maximum size of the on-media ID.
                                            //   Note: this restritiction should
                                            //   be eliminated when the DB records
                                            //   are variable length.
        };                                  //
    LONG            m_partNo;               // The partition number or side.
    RmsAttribute    m_attributes;           // Partition attributes (see RmsAttributes).
    SHORT           m_sizeofIdentifier;     // The size of the on-media identifier.
    UCHAR           m_pIdentifier[MaxId];   // The on-media identifier.
};

#endif // _RMSPARTN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsservr.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsServr.h

Abstract:

    Declaration of the CRmsServer class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSERVR_
#define _RMSSERVR_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

//
// Registry entry
//

class CRmsServer :
    public CComDualImpl<IRmsServer, &IID_IRmsServer, &LIBID_RMSLib>,
    public IHsmSystemState,
    public CRmsComObject,
    public CWsbPersistStream,
    public IConnectionPointContainerImpl<CRmsServer>,
    public IConnectionPointImpl<CRmsServer, &IID_IRmsSinkEveryEvent, CComDynamicUnkArray>,
    public CComCoClass<CRmsServer,&CLSID_CRmsServer>
{
public:
    CRmsServer() {}
BEGIN_COM_MAP(CRmsServer)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsServer)
    COM_INTERFACE_ENTRY(IRmsServer)
    COM_INTERFACE_ENTRY(IHsmSystemState)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CRmsServer)
DECLARE_REGISTRY_RESOURCEID(IDR_RmsServer)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CONNECTION_POINT_MAP(CRmsServer)
    CONNECTION_POINT_ENTRY(IID_IRmsSinkEveryEvent)
END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(
        OUT CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(
        OUT ULARGE_INTEGER* pSize);

    STDMETHOD(Load)(
        IN IStream* pStream);

    STDMETHOD(Save)(
        IN IStream* pStream,
        IN BOOL clearDirty);

// IHsmSystemState
public:
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IRmsServer
public:
    STDMETHOD( InitializeInAnotherThread )(void);

    STDMETHOD( Initialize )(void);

    STDMETHOD( SaveAll )(void);

    STDMETHOD( Unload )(void);

    STDMETHOD( GetServerName )(
        OUT BSTR *pName);

    STDMETHOD( GetCartridges )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetActiveCartridges )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetDataMovers )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( SetActiveCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( GetLibraries )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetMediaSets )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetRequests )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetClients )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetUnconfiguredDevices )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( ScanForDevices )(void);

    STDMETHOD( ScanForDrives )(void);

    STDMETHOD( MountScratchCartridge )(
        OUT GUID *pCartId,
        IN REFGUID fromMediaSet,
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN LONG blockingFactor,
        IN BSTR displayName,
        IN OUT IRmsDrive **ppDrive,
        OUT IRmsCartridge **ppCartridge,
        OUT IDataMover **ppDataMover,
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD( MountCartridge )(
        IN REFGUID cartId,
        IN OUT IRmsDrive **ppDrive,
        OUT IRmsCartridge **ppCartridge,
        OUT IDataMover **ppDataMover,
		IN DWORD dwOptions = RMS_NONE,
		IN DWORD threadId  = 0);

    STDMETHOD( DismountCartridge )(
        IN REFGUID cartId,
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD( DuplicateCartridge )(
        IN REFGUID cartId,
        IN REFGUID firstSideId,
        IN OUT GUID *pCopyCartId,
        IN REFGUID copySetId,
        IN BSTR copyName,
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN DWORD options);

    STDMETHOD( RecycleCartridge )(
        IN REFGUID cartId,
        IN DWORD options);

    STDMETHOD( FindLibraryById )(
        IN REFGUID libId,
        OUT IRmsLibrary **ptr);

    STDMETHOD( FindCartridgeById )(
        IN REFGUID cartId,
        OUT IRmsCartridge **ptr);

    STDMETHOD( CreateObject )(
        IN REFGUID objectId,
        IN REFCLSID rclsid,
        IN REFIID riid,
        IN DWORD dwCreate,
        OUT void **ppvObj);

    STDMETHOD( IsNTMSInstalled )(void);

    STDMETHOD( GetNTMS )(
        OUT IRmsNTMS **ptr);

    STDMETHOD( IsReady )(void);

    STDMETHOD( ChangeState )(
        IN LONG newState);

    STDMETHOD( GetNofAvailableDrives ) (
        IN REFGUID fromMediaSet,
        OUT DWORD *pdwNofDrives);

    STDMETHOD( FindCartridgeStatusById )(
        IN REFGUID cartId,
        OUT DWORD *dwStatus);

    STDMETHOD( IsMultipleSidedMedia )(
        IN REFGUID mediaSetId);

    STDMETHOD( CheckSecondSide )( 
        IN REFGUID firstSideId,
        OUT BOOL *pbValid,
        OUT GUID *pSecondSideId);

    STDMETHOD( GetMaxMediaCapacity )(
        IN REFGUID fromMediaSet,
        OUT LONGLONG *pMaxCapacity);


// CRmsServer
private:
    HRESULT resolveUnconfiguredDevices(void);

    HRESULT autoConfigureDevices(void);

    HRESULT processInquiryData(
        IN int portNumber,
        IN UCHAR *pPortScanData);

    HRESULT findDriveLetter(
        IN UCHAR portNo,
        IN UCHAR pathNo,
        IN UCHAR id,
        IN UCHAR lun,
        OUT OLECHAR *driveString);

    HRESULT getDeviceName(
        IN UCHAR portNo, 
        IN UCHAR pathNo,
        IN UCHAR id,
        IN UCHAR lun,
        OUT OLECHAR *deviceName);

    HRESULT getHardDrivesToUseFromRegistry(
        OUT OLECHAR *pDrivesToUse, OUT DWORD *pLen);

    HRESULT enableAsBackupOperator(void);

    HRESULT CheckForMediaFailures(
        IN HRESULT hrFailure,
        IN IRmsCartridge *pCart,
        IN REFGUID prevSideId);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxActive = 8                       // Max number of active cartridges.
    };

    CWsbStringPtr                       m_dbPath;       // The directory where databases are stored.
    LONG                                m_LockReference;// The server lock used for blocking normal access during synchornized operations.
    CWsbBstrPtr                         m_ServerName;   // The name of the computer running the server.
    CComPtr<IWsbIndexedCollection>      m_pCartridges;  // The cartridges known to the server.
    CComPtr<IWsbIndexedCollection>      m_pLibraries;   // The libraries managed by the server.
    CComPtr<IWsbIndexedCollection>      m_pMediaSets;   // The media sets known to the server.
    CComPtr<IWsbIndexedCollection>      m_pRequests;    // The requests associated with the server.
    CComPtr<IWsbIndexedCollection>      m_pClients;     // The clients associated with the server.
    CComPtr<IWsbIndexedCollection>      m_pUnconfiguredDevices;     // The unconfigured devices associated with the server.
    CComPtr<IRmsNTMS>                   m_pNTMS;        // NTMS support.
    ULONG                               m_HardDrivesUsed; // the number of hard drives in use by RMS.
    
    //typedef List<int> LISTINT;

    //LISTINT::iterator i;
    //LISTINT test;                   
    //List<IRmsCartridge *>               m_ListOfActiveCartridges;   // The cartridges already mounted into a drive.
    //List<IRmsCartridge *>::iterator     m_IteratorForListOfActiveCartridges;  // The cartridges already mounted into a drive.
    CComPtr<IWsbIndexedCollection>      m_pActiveCartridges;        // The cartridges already mounted into a drive.
    CComPtr<IWsbIndexedCollection>      m_pDataMovers;              // The active data movers.
    CComPtr<IRmsCartridge>              m_pActiveCartridge ;        // The cartridges already mounted into a drive.

// Thread routines
public:
    static DWORD WINAPI InitializationThread(
        IN LPVOID pv);

};

/////////////////////////////////////////////////////////////////////////////
//
//        g_pServer
//
//  This is made global so that anybody in the context of Rms has
//  quick access to it
//

extern IRmsServer *g_pServer;
extern CRITICAL_SECTION g_CriticalSection;

#endif // _RMSSERVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmssinfo.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSInfo.cpp

Abstract:

    Implementation of CRmsStorageInfo

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsSInfo.h"

extern IUnknown *g_pServer;

/////////////////////////////////////////////////////////////////////////////
//
// IRmsStorageInfo implementation
//


CRmsStorageInfo::CRmsStorageInfo(
    void
    )
/*++

Routine Description:

    CRmsStorageInfo constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize values
    m_readMountCounter = 0;

    m_writeMountCounter = 0;

    m_bytesWrittenCounter = 0;

    m_bytesReadCounter = 0;

    m_capacity = 0;

    m_usedSpace = 0;

    m_largestFreeSpace = -1;

    m_resetCounterTimestamp = 0;

    m_lastReadTimestamp = 0;

    m_lastWriteTimestamp = 0;

    m_createdTimestamp = 0;
}


HRESULT
CRmsStorageInfo::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsStorageInfo::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsStorageInfo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByUnknown:
        default:

            // What default makes sense?
            WsbAssertHr( E_UNEXPECTED );
            break;

        }

    }
    WsbCatch(hr);

    if ( 0 != pResult ) {
       *pResult = result;
    }

    WsbTraceOut(OLESTR("CRmsStorageInfo::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CRmsStorageInfo::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsStorageInfo::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +           // m_readMountCounter
//                             WsbPersistSizeOf(LONG) +           // m_writeMountCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_bytesWrittenCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_bytesReadCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_capacity
//                             WsbPersistSizeOf(LONGLONG) +       // m_usedSpace
//                             WsbPersistSizeOf(LONGLONG) +       // m_largestFreeSpace
//                             WsbPersistSizeOf(DATE)     +       // m_resetCounterTimestamp
//                             WsbPersistSizeOf(DATE)     +       // m_lastReadTimestamp
//                             WsbPersistSizeOf(DATE)     +       // m_lastWriteTimestamp
//                             WsbPersistSizeOf(DATE);            // m_createdTimestamp

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsStorageInfo::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageInfo::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_readMountCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_writeMountCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bytesWrittenCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bytesReadCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_capacity));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usedSpace));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_largestFreeSpace));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsStorageInfo::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageInfo::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_readMountCounter));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_writeMountCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bytesWrittenCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bytesReadCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_capacity));

        WsbAffirmHr(WsbSaveToStream(pStream, m_usedSpace));

        WsbAffirmHr(WsbSaveToStream(pStream, m_largestFreeSpace));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_resetCounterTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_lastReadTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_lastWriteTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_createdTimestamp));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsStorageInfo::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longHiVal1 = 12345;
    LONG                    longLoVal1 = 67890;

    LONG                    longHiWork1;
    LONG                    longLoWork1;

    LONG                    longVal1 = 11111111;
    LONG                    longWork1;

    LONG                    longVal2 = 22222222;
    LONG                    longWork2;

    LONGLONG                longLongVal1 = 1111111111111111;
    LONGLONG                longLongWork1;

    LONG                    cntBase = 100000;
    LONG                    cntIncr = 25;


//  DATE                    dateVal1 = today;
    DATE                    dateVal1 = 0;
//  DATE                    dateWork1;


    WsbTraceIn(OLESTR("CRmsStorageInfo::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test GetMountCounters
            ResetCounters();

            GetMountCounters(&longWork1, &longWork2);

            if((longVal1 == 0) &&
               (longVal2 == 0)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesRead & GetBytesRead
            SetBytesRead(longLongVal1);

            GetBytesRead(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesRead2 & GetBytesRead2
            SetBytesRead2(longHiVal1, longLoVal1);

            GetBytesRead2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test IncrementBytesRead

            for(i = 0; i < 500; i += cntIncr){
                SetBytesRead(cntBase + i);

                IncrementBytesRead(cntIncr);

                GetBytesRead(&longLongWork1);

                if (longLongWork1 == (cntBase + i + cntIncr)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }
            }

            // Test SetBytesWritten & GetBytesWritten
            SetBytesWritten(longLongVal1);

            GetBytesWritten(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesWritten2 & GetBytesWritten2
            SetBytesWritten2(longHiVal1, longLoVal1);

            GetBytesWritten2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test IncrementBytesWritten

            for(i = 0; i < 500; i += cntIncr){
                SetBytesWritten(cntBase + i);

                IncrementBytesWritten(cntIncr);

                GetBytesWritten(&longLongWork1);

                if (longLongWork1 == (cntBase + i + cntIncr)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }
            }

            // Test GetCapacity
            m_capacity = longLongVal1;

            GetCapacity(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetCapacity2
            m_capacity = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetCapacity2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetUsedSpace
            m_usedSpace = longLongVal1;

            GetUsedSpace(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetUsedSpace2
            m_usedSpace = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetUsedSpace2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetLargestFreeSpace
            m_largestFreeSpace = longLongVal1;

            GetLargestFreeSpace(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetLargestFreeSpace2
            m_largestFreeSpace = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetLargestFreeSpace2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

//          Handle all date stamp values

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageInfo::GetMountCounters(
    LONG  *pReads,
    LONG  *pWrites
    )
/*++

Implements:

    IRmsStorageInfo::GetMountcounters

--*/
{
    *pReads  = m_readMountCounter;
    *pWrites = m_writeMountCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesRead2(
    LONG  *pReadHi,
    LONG  *pReadLo
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesRead2

--*/
{
    *pReadHi = (LONG) (m_bytesReadCounter  >> 32);
    *pReadLo = (LONG) (m_bytesReadCounter  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesRead(
    LONGLONG    *pRead
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesRead

--*/
{
    *pRead = m_bytesReadCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesRead2(
    LONG    readHi,
    LONG    readLo
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesRead2

--*/
{
    m_bytesReadCounter = (LONGLONG) (readHi << 32) + (readLo);
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesRead(
    LONGLONG    read
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesRead

--*/
{
    m_bytesReadCounter = read;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::IncrementBytesRead(
    LONG    val
    )
/*++

Implements:

    IRmsStorageInfo::IncrementBytesRead

--*/
{
    m_bytesReadCounter += val;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesWritten2(
    LONG  *pWriteHi,
    LONG  *pWriteLo
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesWritten2

--*/
{
    *pWriteHi = (LONG) (m_bytesWrittenCounter  >> 32);
    *pWriteLo = (LONG) (m_bytesWrittenCounter  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesWritten(
    LONGLONG    *pWritten
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesWritten

--*/
{
    *pWritten = m_bytesWrittenCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesWritten2(
    LONG    writeHi,
    LONG    writeLo
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesWritten2

--*/
{
    m_bytesWrittenCounter = (LONGLONG) (writeHi << 32) + (writeLo);
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesWritten(
    LONGLONG    written
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesWritten

--*/
{
    m_bytesWrittenCounter = written;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::IncrementBytesWritten(
    LONG    val
    )
/*++

Implements:

    IRmsStorageInfo::IncrementBytesWritten

--*/
{
    //WsbTraceIn( OLESTR("CRmsStorageInfo::IncrementBytesWritten"), OLESTR("<%d>"), val );

    m_bytesWrittenCounter += val;
    m_usedSpace +=val;


    if (m_largestFreeSpace > 0) {
        // Decrement written bytes from free space
        m_largestFreeSpace -= val;
        if (m_largestFreeSpace < 0) {
            // Indicates inaccurate calulation of free space...
            WsbTraceAlways(OLESTR("CRmsStorageInfo::IncrementBytesWritten: Negative free space decrementing %ld bytes\n"), val);
            m_largestFreeSpace = 0;
        }

    } else {
        if (m_largestFreeSpace < 0) {
            // Not expected - somebody is trying to start counting free space 
            // without setting an appropriate initial value
            WsbTraceAlways(OLESTR("CRmsStorageInfo::IncrementBytesWritten: Was called before setting initial free space !!\n"), val);
            m_largestFreeSpace = 0;
        }
    }


/***    // Decrement the free space acordingly.
    m_largestFreeSpace *= (m_largestFreeSpace > 0) ? 1 : -1;  // Absolute value
    m_largestFreeSpace -= val;

    // if we go negative here, we simply set the free space to zero;
    // otherwise we set the value negative to indicate an
    // approximation.

    m_largestFreeSpace *= (m_largestFreeSpace > 0) ? -1 : 0;    ***/

    //WsbTrace( OLESTR("FreeSpace=%I64d, UsedSpace=%I64d, BytesWritten=%I64d\n"), m_largestFreeSpace, m_usedSpace, m_bytesWrittenCounter);
    //WsbTraceOut(OLESTR("CRmsStorageInfo::IncrementBytesWritten"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCapacity2(
    LONG  *pCapHi,
    LONG  *pCapLo
    )
/*++

Implements:

    IRmsStorageInfo::GetCapacity2

--*/
{
    *pCapHi = (LONG) (m_capacity  >> 32);
    *pCapLo = (LONG) (m_capacity  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCapacity(
    LONGLONG    *pCap
    )
/*++

Implements:

    IRmsStorageInfo::GetCapacity

--*/
{
    *pCap = m_capacity;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetUsedSpace2(
    LONG  *pFreeHi,
    LONG  *pFreeLo
    )
/*++

Implements:

    IRmsStorageInfo::GetUsedSpace2

--*/
{
    *pFreeHi = (LONG) (m_usedSpace  >> 32);
    *pFreeLo = (LONG) (m_usedSpace  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetUsedSpace(
    LONGLONG    *pFree
    )
/*++

Implements:

    IRmsStorageInfo::GetUsedSpace

--*/
{
    *pFree = m_usedSpace;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLargestFreeSpace2(
    LONG  *pFreeHi,
    LONG  *pFreeLo
    )
/*++

Implements:

    IRmsStorageInfo::GetLargestFreeSpace2

--*/
{
    // Negative numbers indicate last known value for free space.
    *pFreeHi = (LONG) (m_largestFreeSpace  >> 32);
    *pFreeLo = (LONG) (m_largestFreeSpace  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLargestFreeSpace(
    LONGLONG    *pFree
    )
/*++

Implements:

    IRmsStorageInfo::GetLargestFreeSpace

--*/
{
    // Negative numbers indicate last known value for free space.
    *pFree = m_largestFreeSpace;
    return S_OK;
}



STDMETHODIMP
CRmsStorageInfo::SetCapacity(
    IN LONGLONG cap)
/*++

Implements:

    IRmsStorageInfo::SetCapacity

--*/
{
    m_capacity = cap;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetUsedSpace(
    IN LONGLONG used)
/*++

Implements:

    IRmsStorageInfo::SetUsedSpace

--*/
{
    m_usedSpace = used;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetFreeSpace(
    IN LONGLONG free)
/*++

Implements:

    IRmsStorageInfo::SetFreeSpace

--*/
{
    m_largestFreeSpace = free;

    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::ResetCounters(
    void
    )
/*++

Implements:

    IRmsStorageInfo::ResetCounters

--*/
{
    m_readMountCounter = 0;
    m_writeMountCounter = 0;
    m_bytesWrittenCounter = 0;
    m_bytesReadCounter = 0;

//    m_resetCounterTimestamp = COleDateTime::GetCurrentTime();
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetResetCounterTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetResetCounterTimestamp

--*/
{
    *pDate = m_resetCounterTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLastReadTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetLastReadTimestamp

--*/
{
    *pDate = m_lastReadTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLastWriteTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetLastWriteTimestamp

--*/
{
    *pDate = m_lastWriteTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCreatedTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetCreatedTimestamp

--*/
{
    *pDate = m_createdTimestamp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmssslot.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSSlot.h

Abstract:

    Declaration of the CRmsStorageSlot class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSSLOT_
#define _RMSSSLOT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsStorageSlot

Class Description:

    A CRmsStorageSlot represents a specific storage location within a libray.

--*/

class CRmsStorageSlot :
    public CComDualImpl<IRmsStorageSlot, &IID_IRmsStorageSlot, &LIBID_RMSLib>,
    public CRmsChangerElement,  // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsStorageSlot,&CLSID_CRmsStorageSlot>
{
public:
    CRmsStorageSlot() {}
BEGIN_COM_MAP(CRmsStorageSlot)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsStorageSlot)
    COM_INTERFACE_ENTRY(IRmsStorageSlot)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsStorageSlot)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsStorageSlot
public:
    STDMETHOD(SetIsInMagazine)(BOOL flag);
    STDMETHOD(IsInMagazine)(void);

    STDMETHOD(GetMagazineAndCell)(LONG *pMag, LONG *pCell);
    STDMETHOD(SetMagazineAndCell)(LONG mag, LONG cell);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
    };                                      //
    BOOL            m_isInMagazine;         // If TRUE, the slot is contained within
                                            //   a magazine.
    LONG            m_magazineNo;           // The magazine number for this slot.
    LONG            m_cellNo;               // The cell number for this slot.
};

#endif // _RMSSSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmssslot.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSSlot.cpp

Abstract:

    Implementation of CRmsStorageSlot

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsSSlot.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsStorageSlot::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsStorageSlot::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsStorageSlot::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsStorageSlot::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_isInMagazine = FALSE;

        m_magazineNo = 0;

        m_cellNo = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsStorageSlot::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsStorageSlot;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsStorageSlot::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(BOOL)   +     // m_isInMagazine
//                             WsbPersistSizeOf(LONG)   +     // m_magazineNo
//                             WsbPersistSizeOf(LONG);        // m_cellNo
//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageSlot::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isInMagazine));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_magazineNo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_cellNo));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageSlot::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_isInMagazine));

        WsbAffirmHr(WsbSaveToStream(pStream, m_magazineNo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_cellNo));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsStorageSlot>    pStorageSlot1;
    CComPtr<IRmsStorageSlot>    pStorageSlot2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;


    WsbTraceIn(OLESTR("CRmsStorageSlot::Test"), OLESTR(""));

    try {
        // Get the StorageSlot interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsStorageSlot*) this)->QueryInterface(IID_IRmsStorageSlot, (void**) &pStorageSlot1));

            // Test SetIsInMagazine & IsInMagazine to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsInMagazine (TRUE));
                WsbAffirmHr(IsInMagazine ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsInMagazine & IsInMagazine to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsInMagazine (FALSE));
                WsbAffirmHr(IsInMagazine ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetMagazineAndCell & GetMagazineAndCell
            longWork1 = 99;
            longWork2 = 11;

            SetMagazineAndCell(longWork1, longWork2);

            GetMagazineAndCell(&longWork3, &longWork4);

            if((longWork1 == longWork3)  &&  (longWork2  ==  longWork4)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::SetIsInMagazine(
    BOOL    flag
    )
/*++

Implements:

    IRmsStorageSlot::SetIsInMagazine

--*/
{
    m_isInMagazine = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageSlot::IsInMagazine(
    void
    )
/*++

Implements:

    IRmsStorageSlot::IsInMagazine

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isInMagazine){
    hr = S_OK;
    }

    return (hr);
}



STDMETHODIMP
CRmsStorageSlot::GetMagazineAndCell(
    LONG    *pMag,
    LONG    *pCell
    )
/*++

Implements:

    IRmsStorageSlot::GetMagazineAndCell

--*/
{
    *pMag  = m_magazineNo;
    *pCell = m_cellNo;
    return S_OK;
}


STDMETHODIMP
CRmsStorageSlot::SetMagazineAndCell(
    LONG    mag,
    LONG    cell
    )
/*++

Implements:

    IRmsStorageSlot::SetMagazineAndCell

--*/
{
    m_magazineNo = mag;
    m_cellNo     = cell;

    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsreqst.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsReqst.h

Abstract:

    Declaration of the CRmsRequest class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSREQST_
#define _RMSREQST_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsRequest

Class Description:

    A CRmsRequest represents a specific asynchronous job performed by the
    Removable Media Service, like mounting cartridges, checking in and out
    cartridges, and auditing a library.

--*/

class CRmsRequest :
    public CComDualImpl<IRmsRequest, &IID_IRmsRequest, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,         // inherits CComObjectRoot
    public CComCoClass<CRmsRequest,&CLSID_CRmsRequest>
{
public:
    CRmsRequest() {}
BEGIN_COM_MAP(CRmsRequest)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsRequest)
    COM_INTERFACE_ENTRY(IRmsRequest)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsRequest)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsRequest
public:
    STDMETHOD(GetRequestNo)(LONG *pRequestNo);

    STDMETHOD(GetRequestDescription)(BSTR *pDesc);
    STDMETHOD(SetRequestDescription)(BSTR desc);

    STDMETHOD(SetIsDone)(BOOL flag);
    STDMETHOD(IsDone)(void);

    STDMETHOD(GetOperation)(BSTR *pOperation);
    STDMETHOD(SetOperation)(BSTR operation);

    STDMETHOD(GetPercentComplete)( BYTE *pPercent);
    STDMETHOD(SetPercentComplete)( BYTE percent);

    STDMETHOD(GetStartTimestamp)(DATE *pDate);
    STDMETHOD(GetStopTimestamp)(DATE *pDate);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_requestNo;            // A request number.
    CWsbBstrPtr     m_requestDescription;   // A textual description of the request.
    BOOL            m_isDone;               // If TRUE, the request has completed.
    CWsbBstrPtr     m_operation;            // An internal description of the in-progress operation.
    BYTE            m_percentComplete;      // A value between 0-100 that indicates
                                            //   what portion of the operation is complete.
    DATE            m_startTimestamp;       // The time the request was started.
    DATE            m_stopTimestamp;        // The time the request finished.
};

#endif // _RMSREQST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmstmplt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsTmplt.cpp

Abstract:

    Implementation of CRmsTemplate

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsTmplt.h"

/////////////////////////////////////////////////////////////////////////////
// CRmsTemplate Implementation


STDMETHODIMP
CRmsTemplate::InterfaceSupportsErrorInfo(
    REFIID riid
    )
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] =
    {
    &IID_IRmsTemplate,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
    if (InlineIsEqualGUID(*arr[i],riid))
        return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmsservr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsServr.cpp

Abstract:

    Implementation of CRmsServer

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
//#include <stl.h>

//using namespace std ;

//#pragma warning (disable : 4786) 
//using namespace std ;

#include <devioctl.h>
#include <ntddscsi.h>

#include "RmsServr.h"
#include "rsbuild.h"
#include "wsb.h"
#include "ntverp.h"

#define PERSIST_CHECK_VALUE 0x526f6e57

#if 0
#define DebugPrint(a)   {                   \
    CWsbStringPtr out = a;                  \
    out.Prepend(L": ");                     \
    out.Prepend(WsbLongAsString(GetCurrentThreadId()));  \
    OutputDebugString((WCHAR *) out);       \
}
#else
#define DebugPrint(a)
#endif // DBG


//  This is made global so that anybody in the context of the server has
//  quick access to it
IRmsServer *g_pServer = 0;


/////////////////////////////////////////////////////////////////////////////
// CComObjectRoot


HRESULT
CRmsServer::FinalConstruct(void)
/*++

Routine Description:

    This method does some initialization of the object that is necessary
    after construction.

Arguments:

    None.

Return Value:

    S_OK

    Anything returned by CWsbPersistStream::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::FinalConstruct"), OLESTR(""));

    // Zeroing global variable
    g_pServer = 0;

    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    try {
        WsbAssertPointer( pObject );

        CWsbBstrPtr tmpString;

        WsbAssertHr( CWsbPersistStream::FinalConstruct() );

        WsbAffirmHr( ChangeState( RmsServerStateStarting ));

        // Figure out where to store information and initialize trace.

        // Setup the collections
        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pActiveCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDataMovers ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pLibraries ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pMediaSets ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pRequests ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pClients ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pUnconfiguredDevices ));

        // Create NTMS object
        WsbAssertHr(CoCreateInstance( CLSID_CRmsNTMS,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IRmsNTMS,
                                      (void **)&m_pNTMS ));

        // Get the name of the computer on which we running.
        CWsbStringPtr               serverNameString;
        WsbAffirmHr( WsbGetComputerName( serverNameString ));
        m_ServerName = serverNameString;

        m_HardDrivesUsed = 0;

        m_LockReference = 0;

        WsbAffirmHr( ChangeState( RmsServerStateStarted ));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
        );

    WsbTraceOut(OLESTR("CRmsServer::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::FinalRelease(void)
/*++

Routine Description:

    This method does some uninitialization of the object that is necessary
    before destrucruction.

Arguments:

    None.

Return Value:

    S_OK

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::FinalRelease"), OLESTR(""));

    try {
        WsbAffirmHr( ChangeState( RmsServerStateStopping ));

        CWsbPersistStream::FinalRelease();
        WsbAffirmHr( ChangeState( RmsServerStateStopped ));

#ifdef WSB_TRACK_MEMORY
        (void) WsbObjectTracePointers(WSB_OTP_SEQUENCE | WSB_OTP_STATISTICS | WSB_OTP_ALLOCATED);
        (void) WsbObjectTraceTypes();
#endif

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}




STDMETHODIMP 
CRmsServer::InitializeInAnotherThread(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::InitializeInAnotherThread"), OLESTR(""));

    try {

        DWORD threadId;
        HANDLE hThread;
        WsbAffirmHandle(hThread = CreateThread(NULL, 1024, CRmsServer::InitializationThread, this, 0, &threadId));
        CloseHandle(hThread);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::InitializeInAnotherThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



DWORD WINAPI
CRmsServer::InitializationThread(
    IN LPVOID pv)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::InitializationThread"), OLESTR(""));

    HRESULT hrCom = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    try {
        WsbAssertPointer(pv);
        CRmsServer *pServer = (CRmsServer*)pv;
        WsbAffirmHr(pServer->Initialize());
    } WsbCatch(hr);

    if (SUCCEEDED(hrCom)) {
        CoUninitialize();
    }

    WsbTraceOut(OLESTR("CRmsServer::InitializationThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
    } 


STDMETHODIMP 
CRmsServer::Initialize(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::Initialize"), OLESTR(""));

    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    DWORD fixedDriveEnabled = RMS_DEFAULT_FIXED_DRIVE;
    DWORD size;
    OLECHAR tmpString[256];
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FIXED_DRIVE, tmpString, 256, &size))) {
        // Get the value.
        fixedDriveEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD opticalEnabled = RMS_DEFAULT_OPTICAL;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_OPTICAL, tmpString, 256, &size))) {
        // Get the value.
        opticalEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD tapeEnabled = RMS_DEFAULT_TAPE;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_TAPE, tmpString, 256, &size))) {
        // Get the value.
        tapeEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD dvdEnabled = RMS_DEFAULT_DVD;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DVD, tmpString, 256, &size))) {
        // Get the value.
        dvdEnabled = wcstol(tmpString, NULL, 10);
    }

    WsbTraceAlways(OLESTR("Fixed Drive Media Enabled: %ls\n"), WsbBoolAsString((BOOL)fixedDriveEnabled));
    WsbTraceAlways(OLESTR("Optical Media Enabled:     %ls\n"), WsbBoolAsString((BOOL)opticalEnabled));
    WsbTraceAlways(OLESTR("Tape Media Enabled:        %ls\n"), WsbBoolAsString((BOOL)tapeEnabled));
    WsbTraceAlways(OLESTR("DVD Media Enabled:        %ls\n"), WsbBoolAsString((BOOL)dvdEnabled));

    try {
        if (0 == g_pServer) {
            // Set global variable for quick access (if not set yet)
            WsbAffirmHr(((IUnknown*)(IRmsServer *)this)->QueryInterface(IID_IRmsServer, (void**) &g_pServer));

            // We don't want the reference count bumped for this global so release it here.
            g_pServer->Release();
        }

        // initializing
        WsbAssertPointer( pObject );

        CWsbStringPtr tmpString;

        WsbAffirmHr( ChangeState( RmsServerStateInitializing ));

        hr = IsNTMSInstalled();
        if ( S_OK == hr ) {

            try {
                // Perform any initialization required for using NTMS subsystem.
                WsbAffirmHr( m_pNTMS->Initialize() );
            } WsbCatch (hr);
            hr = S_OK;

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );
            }

            // Resolve the devices detected by the scan.
            WsbAffirmHr( resolveUnconfiguredDevices() );

            // Auto configure the remaining devices.
            WsbAffirmHr( autoConfigureDevices() );

            // Try to dismount all of our medias, ignore errors
            HRESULT hrDismountAll = S_OK;
            try {
                CComPtr<IWsbEnum>       pEnumSets;
                CComPtr<IRmsMediaSet>   pMediaSet;
                CComPtr<IRmsComObject>  pObject;
                GUID                    mediaSetId;

                WsbAffirmHr(m_pMediaSets->Enum(&pEnumSets));
                WsbAssertPointer(pEnumSets);
                hrDismountAll = pEnumSets->First(IID_IRmsMediaSet, (void **)&pMediaSet);
                while (S_OK == hrDismountAll) {
                    WsbAffirmHr(pMediaSet->QueryInterface(IID_IRmsComObject, (void**) &pObject));
                    WsbAffirmHr(pObject->GetObjectId(&mediaSetId));
                    WsbAffirmHr(m_pNTMS->DismountAll(mediaSetId));

                    hrDismountAll = pEnumSets->Next(IID_IRmsMediaSet, (void **)&pMediaSet);
                }
                if (hrDismountAll == WSB_E_NOTFOUND) {
                    hrDismountAll = S_OK;
                } else {
                    WsbAffirmHr(hrDismountAll);
                }
            } WsbCatch(hrDismountAll);
        }
        else if ( RMS_E_NOT_CONFIGURED_FOR_NTMS == hr ) {
            hr = S_OK;

            // Scan for devices.
            WsbAffirmHr( ScanForDevices() );

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );
            }

            // Resolve the devices detected by the scan.
            WsbAffirmHr( resolveUnconfiguredDevices() );

            // Auto configure the remaining devices.
            WsbAffirmHr( autoConfigureDevices() );

        }
        else { // Some other NTMS connection failure (NTMS not installed, configured, or running)
            hr = S_OK;

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );

                // Resolve the devices detected by the scan.
                WsbAffirmHr( resolveUnconfiguredDevices() );

                // Auto configure the remaining devices.
                WsbAffirmHr( autoConfigureDevices() );
            }

        }

        // Enable RMS process for backup operations.
        WsbAffirmHr( enableAsBackupOperator() );

        // Save the configuration information.
        WsbAffirmHr( SaveAll() );

        WsbAffirmHr( ChangeState( RmsServerStateReady ));

        WsbTraceAlways(OLESTR("RMS is ready.\n"));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
        );


    WsbTraceOut(OLESTR("CRmsServer::Initialize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsServer::IsNTMSInstalled(void)
{

    return m_pNTMS->IsInstalled();

}


STDMETHODIMP
CRmsServer::GetNTMS(
    OUT IRmsNTMS **ptr)
/*++

Implements:

    IRmsServer::GetNTMS

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        *ptr = m_pNTMS;
        m_pNTMS.p->AddRef();

        hr = S_OK;

    } WsbCatch( hr );

    return hr;
}

//
// Rms no longer save independently its own .col file, but only the NTMS database
//

STDMETHODIMP 
CRmsServer::SaveAll(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::SaveAll"), OLESTR(""));

    static BOOL saving = FALSE;

    try {
        WsbAffirm(!saving, S_FALSE);
        saving = TRUE;

        hr = m_pNTMS->ExportDatabase();

        saving = FALSE;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsServer::Unload(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.
        if (m_pCartridges) {
            WsbAffirmHr(m_pCartridges->RemoveAllAndRelease());
        }
        if (m_pLibraries) {
            WsbAffirmHr(m_pLibraries->RemoveAllAndRelease());
        }
        if (m_pMediaSets) {
            WsbAffirmHr(m_pMediaSets->RemoveAllAndRelease());
        }
        if (m_pRequests) {
            WsbAffirmHr(m_pRequests->RemoveAllAndRelease());
        }
        if (m_pClients) {
            WsbAffirmHr(m_pClients->RemoveAllAndRelease());
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsServer::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}


STDMETHODIMP
CRmsServer::GetSizeMax(
    OUT ULARGE_INTEGER* /*pcbSize*/)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT         hr = E_NOTIMPL;

//  ULONG           serverNameLen;

//  ULARGE_INTEGER  cartridgesLen;
//  ULARGE_INTEGER  librariesLen;
//  ULARGE_INTEGER  mediaSetsLen;
//  ULARGE_INTEGER  requestsLen;
//  ULARGE_INTEGER  clientsLen;
//  ULARGE_INTEGER  unconfiguredDevicesLen;


//  WsbTraceIn(OLESTR("CRmsServer::GetSizeMax"), OLESTR(""));

//  try {
//      WsbAssert(0 != pcbSize, E_POINTER);

//      m_pCartridges-> GetSizeMax (&cartridgesLen);

        // set up size of CRmsServer
//      pcbSize->QuadPart  = WsbPersistSizeOf(ULONG)       +  // length of serverName
//                           cartridgesLen.QuadPart;          // m_pCartridges

//  } WsbCatch(hr);

//  WsbTraceOut(OLESTR("CRmsServer::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}

STDMETHODIMP
CRmsServer::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::Load"), OLESTR(""));

    //
    // Check if the global pointer is already set - if not, update it
    // (Today, Load is the only method that is executed before Initialize)
    //
    if (0 == g_pServer) {
        // Set global variable for quick access (if not set yet)
        WsbAffirmHr(((IUnknown*)(IRmsServer *)this)->QueryInterface(IID_IRmsServer, (void**) &g_pServer));

        // We don't want the reference count bumped for this global so release it here.
        g_pServer->Release();
    }

    //
    // Lock down the server while we are loading.
    //
    InterlockedIncrement( &m_LockReference );

    //
    // The Load reverts the state, which is undesired for the server object.
    // Save away the original status information
    //
    BOOL bTemp = m_IsEnabled;
    LONG lTemp = m_State;
    HRESULT hrTemp = m_StatusCode;

    try {
        WsbAssertPointer(pStream);

        CComPtr<IPersistStream> pPersistStream;

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Load the collections
        WsbAffirmHr(m_pMediaSets->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pLibraries->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pRequests->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pClients->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        //  Check that we got everything
        ULONG check_value;
        WsbAffirmHr(WsbLoadFromStream(pStream, &check_value));
        WsbAffirm(check_value == PERSIST_CHECK_VALUE, E_UNEXPECTED);

    } WsbCatch(hr);


    // Reset the object status information to their original settings.
    m_IsEnabled = bTemp;
    m_State = lTemp;
    m_StatusCode = hrTemp;

    //
    // Unlock the server.
    //
    InterlockedDecrement( &m_LockReference );

    WsbTraceOut(OLESTR("CRmsServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CRmsServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;


    WsbTraceIn(OLESTR("CRmsServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        CComPtr<IPersistStream>   pPersistStream;

        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Save the collections
        WsbAffirmHr(m_pMediaSets->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pLibraries->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pRequests->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pClients->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Put this at the end as a check during load
        ULONG check_value = PERSIST_CHECK_VALUE;
        WsbAffirmHr(WsbSaveToStream(pStream, check_value));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// IRmsServer


STDMETHODIMP
CRmsServer::GetServerName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsServer::GetServerName

--*/
{
    WsbAssertPointer(pName);

    m_ServerName.CopyToBstr(pName);
    return S_OK;
}



STDMETHODIMP
CRmsServer::GetCartridges(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pCartridges;
        m_pCartridges.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetActiveCartridges(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetActiveCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pActiveCartridges;
        m_pActiveCartridges.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetDataMovers(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetDataMovers

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pDataMovers;
        m_pDataMovers.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::SetActiveCartridge(
    IN IRmsCartridge *ptr)
/*++

Implements:

    IRmsServer::SetActiveCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        if (m_pActiveCartridge) {
            m_pActiveCartridge = 0;
        }
        m_pActiveCartridge = ptr;

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetLibraries(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetLibraries

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pLibraries;
        m_pLibraries.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetMediaSets(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetMediaSets

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        // We need to reinit NTMS to account for PNP devices.
        (void) m_pNTMS->Initialize();

        *ptr = m_pMediaSets;
        m_pMediaSets.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetRequests(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetRequests

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pRequests;
        m_pRequests.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetClients(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetClients

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pClients;
        m_pClients.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetUnconfiguredDevices(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetUnconfiguredDevices

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pUnconfiguredDevices;
        m_pUnconfiguredDevices.p->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::ScanForDevices(void)
/*++

Implements:

    IRmsServer::ScanForDevices

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ScanForDevices"), OLESTR(""));

    HANDLE portHandle = INVALID_HANDLE_VALUE;

    LONGLONG trace = 0;

    try {

//        WsbAssertPointer( g_pTrace );

        BOOL        status;
        DWORD       accessMode = GENERIC_READ;
        DWORD       shareMode  = FILE_SHARE_READ;
        UCHAR       portData[2048];
        OLECHAR     string[25];
        ULONG       returned;
        int         portNumber = 0;

//        BOOL     traceTimeStamp;
//        BOOL     traceCount;
//        BOOL     traceThreadId;

//        WsbAssertHr( g_pTrace->GetTraceSettings( &trace )); 
//        WsbAssertHr( g_pTrace->SetTraceOff( WSB_TRACE_BIT_ALL )); 
//        WsbAssertHr( g_pTrace->GetOutputFormat( &traceTimeStamp, &traceCount, &traceThreadId )); 
//        WsbAssertHr( g_pTrace->SetOutputFormat( FALSE, FALSE, FALSE )); 
        WsbTraceAlways( OLESTR("\n\n----- Begin Device Scan ---------------------------------------------------------------\n\n") );

        //
        // Go to each SCSI adapter connected to the system and build
        // out the device list.
        //

        do {

            swprintf( string, OLESTR("\\\\.\\Scsi%d:"), portNumber );

            portHandle = CreateFile( string,
                                     accessMode,
                                     shareMode,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL );

            if ( portHandle == INVALID_HANDLE_VALUE ) {
                break; // we're done
            }

            //
            // Get the inquiry data.
            //

            WsbAffirmStatus( DeviceIoControl( portHandle,
                                      IOCTL_SCSI_GET_INQUIRY_DATA,
                                      NULL,
                                      0,
                                      portData,
                                      sizeof(portData),
                                      &returned,
                                      FALSE ));

            status = CloseHandle( portHandle );
            portHandle = INVALID_HANDLE_VALUE;
            WsbAffirmStatus( status );

            WsbAffirmHrOk( processInquiryData( portNumber, portData ) );

            portNumber++;

        } while ( 1 );


        WsbTraceAlways( OLESTR("\n\n----- End Device Scan -----------------------------------------------------------------\n\n") );
//        WsbAssertHr( g_pTrace->SetOutputFormat( traceTimeStamp, traceCount, traceThreadId )); 
//        WsbAssertHr( g_pTrace->SetTraceOn( trace )); 

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
//        if (g_pTrace) {
//            WsbAssertHr( g_pTrace->SetTraceOn( trace )); 
            WsbTraceAlways( OLESTR("\n\n !!!!! ERROR !!!!! Device Scan Terminated.\n\n") );
//        }
        if ( portHandle != INVALID_HANDLE_VALUE ) {
           CloseHandle( portHandle );
        }
    );


    WsbTraceOut(OLESTR("CRmsServer::ScanForDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsServer::ScanForDrives(void)
/*++

Implements:

    IRmsServer::ScanForDrives

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ScanForDrives"), OLESTR(""));

    try {

        //
        // Build out device objects for various drive types:  fixed drives, removables, and CD-ROM.
        // These are all supported by the system, and have drive letters associated with them.
        //
        // Use best effort to dectect drives.  If anything fails we just go on to the next one.

        // Get the unconfigured device list
        CComPtr<IWsbIndexedCollection> pDevices;
        WsbAssertHr( this->GetUnconfiguredDevices( &pDevices ));

        // Get the drive letters
        const DWORD bufSize = 256; // 26*4 + 1 = 105 is all we really need
        OLECHAR driveLetters[bufSize];
        DWORD len;

        // See if there are drives for us to support
        if ( getHardDrivesToUseFromRegistry( driveLetters, &len ) != S_OK )  {
            len = GetLogicalDriveStrings( bufSize, driveLetters );
        }

        UINT    type;

        // For each drive letter see if it is something managed
        // by RMS.

        m_HardDrivesUsed = 0;
        for ( DWORD i = 0; i < len; i += 4 ) {      // drive letters have the form "A:\"

            try {

                type = GetDriveType( &driveLetters[i] );

                switch ( type ) {

                case DRIVE_REMOVABLE:
                    {
                        WsbTrace( OLESTR("Removable Drive Detected: %C\n"), driveLetters[i] );

                        CComPtr<IRmsDevice> pDevice;
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                        CWsbBstrPtr name = &(driveLetters[i]);

                        WsbAffirmHr( pDevice->SetDeviceName( name ));
                        WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceRemovableDisk ));

                        //
                        // Don't add it if it was already detected in the SCSI device scan
                        //

                        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pDevice;
                        WsbAssertPointer( pObject );
                        WsbAffirmHr( pObject->SetFindBy( RmsFindByDeviceName ));

                        if ( S_OK == pDevices->Contains( pDevice ) ) {
                            break;
                        }

                        WsbAffirmHr( pDevices->Add( pDevice ));
                        pDevice = 0;
                    }
                    break;

                case DRIVE_FIXED:
                    {
                        CWsbBstrPtr name = &(driveLetters[i]);
                        WCHAR volumeName[32];
                        DWORD volumeSerialNumber;
                        DWORD filenameLength;
                        DWORD fileSystemFlags;
                        WCHAR fileSystemName[32];

                        WsbAffirmStatus(GetVolumeInformation( (WCHAR *)name, volumeName, 32,
                            &volumeSerialNumber, &filenameLength, &fileSystemFlags, fileSystemName, 32));

                        WsbTrace( OLESTR("Fixed Drive Detected    : %ls <%ls/%d> [len=%d, flags=0x%08x] %ls\n"),
                            (WCHAR *)name, volumeName, volumeSerialNumber, filenameLength,
                            fileSystemFlags, fileSystemName );

                        //
                        // Use any volume with name starting with RStor, Remote Stor, RemoteStor, RS
                        //
                        if ( (0 == _wcsnicmp(volumeName, L"RS", 2)) ||
                                 (0 == _wcsnicmp(volumeName, L"Remote Stor", 11)) ||
                                 (0 == _wcsnicmp(volumeName, L"RemoteStor", 10))) {
                            CComPtr<IRmsDevice> pDevice;
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                            WsbAffirmHr( pDevice->SetDeviceName( name ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceFixedDisk ));
                            WsbAffirmHr( pDevices->Add( pDevice ));
                            pDevice = 0;
                            m_HardDrivesUsed++;
                            WsbTrace( OLESTR("  %ls added to Collection of unconfigured devices.\n"), (WCHAR *)name );
                        }
                    }
                    break;

                case DRIVE_CDROM:
                    {
                        WsbTrace( OLESTR("CD-ROM Drive Detected   : %C\n"), driveLetters[i] );

                        CComPtr<IRmsDevice> pDevice;
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                        CWsbBstrPtr name = &(driveLetters[i]);

                        WsbAffirmHr( pDevice->SetDeviceName( name ));
                        WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceCDROM ));
                        WsbAffirmHr( pDevices->Add( pDevice ));
                        pDevice = 0;
                    }
                    break;

                case DRIVE_UNKNOWN:
                case DRIVE_REMOTE:
                case DRIVE_RAMDISK:
                default:
                    break;

                } // switch drive types

            } WsbCatchAndDo(hr,
                    hr = S_OK;  // Best effort
                );

        } // for each drive

    } WsbCatchAndDo( hr,
            WsbTraceAlways( OLESTR("\n\n !!!!! ERROR !!!!! Drive Scan Terminated.\n\n") );
            hr = S_OK;  // Best effort
        );


    WsbTraceOut(OLESTR("CRmsServer::ScanForDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsServer::processInquiryData(
    IN int portNumber,
    IN UCHAR *pDataBuffer)
/*++

Routine Description:

    Builds RMS device objects from adapter port scan data.

Arguments:

    portNumber          - The adapter port to be processed.

    pDataBuffer         - The adapter port data.

Return Value:

    S_OK

--*/

{
    HRESULT hr = E_FAIL;


    try {

        PSCSI_ADAPTER_BUS_INFO  adapterInfo;
        PSCSI_INQUIRY_DATA inquiryData;
        OLECHAR deviceString[25];

        CComPtr<IRmsDevice> pDevice;
        CComPtr<IWsbIndexedCollection> pDevices;
        WsbAffirmHr( this->GetUnconfiguredDevices( &pDevices ));

        adapterInfo = (PSCSI_ADAPTER_BUS_INFO) pDataBuffer;

        WsbTraceAlways( OLESTR("Port: %d\n"), portNumber );
        WsbTraceAlways( OLESTR("Bus TID LUN Claimed String                       Inquiry Header          Other\n") );
        WsbTraceAlways( OLESTR("--- --- --- ------- ---------------------------- ----------------------- --------------\n") );

        for ( UCHAR i = 0; i < adapterInfo->NumberOfBuses; i++) {
            inquiryData = (PSCSI_INQUIRY_DATA) (pDataBuffer +
                            adapterInfo->BusData[i].InquiryDataOffset);

            while (adapterInfo->BusData[i].InquiryDataOffset) {
                WsbTraceAlways( OLESTR(" %d   %d  %3d    %s    %.28S "),
                          i,
                          inquiryData->TargetId,
                          inquiryData->Lun,
                          (inquiryData->DeviceClaimed) ? "Y" : "N",
                          &inquiryData->InquiryData[8] );

                for ( UCHAR j = 0; j < 8; j++) {
                    WsbTraceAlways( OLESTR("%02X "), inquiryData->InquiryData[j] );
                }

                WsbTraceAlways( OLESTR("%d %3d "), inquiryData->InquiryDataLength, inquiryData->NextInquiryDataOffset );

                switch ( inquiryData->InquiryData[0] & 0x1f ) {

                case DIRECT_ACCESS_DEVICE:

                    //
                    // Is this a SCSI removable disk?  (Fixed drives are dealt with later in the scan)
                    //

                    if ( (inquiryData->InquiryData[1] & 0x80) && inquiryData->InquiryData[2] & 0x02) {

                        //
                        // The device is a SCSI removable hard drive, So...
                        // Create the Drive object and add it to the collection of unconfigured devices.
                        //

                        try {

                            if ( inquiryData->DeviceClaimed ) {

                                WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                                WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                                WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceRemovableDisk ));
                                WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));


                                //
                                // find drive letter
                                //

                                try {
                                    WsbAffirmHr( findDriveLetter( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ))
                                    WsbTraceAlways( OLESTR("%ls"), deviceString );
                                    WsbAffirmHr( pDevice->SetDeviceName( deviceString ));
                                    WsbAffirmHr(pDevices->Add( pDevice ));
                                }
                                WsbCatch(hr);

                                pDevice = 0;

                            }
                        }
                        WsbCatch(hr);
                    }
                    break;

                case SEQUENTIAL_ACCESS_DEVICE:

                    //
                    // Create the Drive object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceTape ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find tape name
                            //

                            try {
                                WsbAffirmHr( getDeviceName( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ));
                                WsbTraceAlways( OLESTR("%ls"), deviceString );

                                // Create the name to use when creating a handle
                                CWsbBstrPtr name = deviceString;
                                name.Prepend( OLESTR("\\\\.\\") );
                                WsbAffirmHr( pDevice->SetDeviceName( name ));
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);

                            pDevice = 0;

                        }
                    }
                    WsbCatch(hr);
                    break;

                case WRITE_ONCE_READ_MULTIPLE_DEVICE:

                    //
                    // Supported as OPTICAL_DEVICE only
                    //

                    break;

                case READ_ONLY_DIRECT_ACCESS_DEVICE:

                    //
                    // we'll deal with CD-ROM later in the scan...
                    //

                    break;

                case OPTICAL_DEVICE:

                    //
                    // Create the Drive object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceOptical ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find drive letter
                            //

                            try {
                                WsbAffirmHr( findDriveLetter( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ))
                                WsbTraceAlways( OLESTR("%ls"), deviceString );
                                WsbAffirmHr( pDevice->SetDeviceName( deviceString ));                            
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);

                            pDevice = 0;

                        }
                    }
                    WsbCatch(hr);
                    break;

                case MEDIUM_CHANGER:

                    //
                    // Create the Medium Changer object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsMediumChanger, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceChanger ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find library name
                            //

                            try {
                                WsbAffirmHr( getDeviceName( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ));
                                WsbTraceAlways( OLESTR("%ls"), deviceString );

                                // Create the name to use when creating a handle
                                CWsbBstrPtr name = deviceString;
                                name.Prepend( OLESTR("\\\\.\\") );
                                WsbAffirmHr( pDevice->SetDeviceName( name ));
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);
                        }

                        pDevice = 0;

                    }
                    WsbCatch(hr);
                    break;

                } // switch device type

                    WsbTraceAlways( OLESTR("\n") );

                if (inquiryData->NextInquiryDataOffset == 0) {
                    break;
                }

                inquiryData = (PSCSI_INQUIRY_DATA) (pDataBuffer +
                                inquiryData->NextInquiryDataOffset);

            } // for each device

        } // for each bus

        WsbTraceAlways( OLESTR("\n\n") );

        hr = S_OK;

    }
    WsbCatch(hr);

    return hr;
}


HRESULT
CRmsServer::findDriveLetter(
    IN UCHAR portNo,
    IN UCHAR pathNo,
    IN UCHAR id,
    IN UCHAR lun,
    OUT OLECHAR *driveString)
/*++

Routine Description:

    Find associated drive letter for defined parameters.

Arguments:

    portNo          - input port number.
    pathNo          - input path number.
    id              - input id.
    lun             - input logical unit number.
    driveString     - pointer to drive letter string to return.


Return Value:

    S_OK            - Success


--*/
{

    HRESULT         hr = E_FAIL;
    const DWORD     bufSize = 256; // 26*4 + 1 = 105 is all we really need
    OLECHAR         driveLetters[bufSize];
    BOOL            status;
    DWORD           accessMode = 0, // just get some drive properties.
                    shareMode = FILE_SHARE_READ;
    HANDLE          driveHandle = INVALID_HANDLE_VALUE;
    SCSI_ADDRESS    address;
    DWORD           returned;
    OLECHAR         string[25];
    UINT            uiType;

    try {
        // first find which drives are mapped.
        DWORD len = GetLogicalDriveStrings( bufSize, driveLetters );

        for ( DWORD i = 0; (i < len) && (hr != S_OK); i += 4 ) { // drive letters have the form "A:\"

            uiType = GetDriveType( &driveLetters[i] );
            switch ( uiType ) {

            case DRIVE_REMOVABLE:

                //
                // get the SCSI address of the device and see if it's a match.
                //

                swprintf( string, OLESTR("\\\\.\\%C:"), driveLetters[i] );

                driveHandle = CreateFile( string,
                                          accessMode,
                                          shareMode,
                                          NULL,
                                          OPEN_EXISTING,
                                          0,
                                          NULL);

                WsbAffirmHandle( driveHandle );

                //
                // Get the address structure.
                //

                status = DeviceIoControl( driveHandle,
                                                  IOCTL_SCSI_GET_ADDRESS,
                                                  NULL,
                                                  0,
                                                  &address,
                                                  sizeof(SCSI_ADDRESS),
                                                  &returned,
                                                  FALSE );
                if (!status ) {

                    //
                    // asking for the SCSI address is not always a valid request for
                    // all types of drives, so getting an error here means we're
                    // not talking to a SCSI device... so skip it.
                    //

                    break;  // out of switch
                }

                //
                // Let's check the SCSI address and see if we get a match.
                //

                if ( (address.PortNumber == portNo) &&
                     (address.PathId == pathNo)     &&
                     (address.TargetId == id)       &&
                     (address.Lun == lun)) {

                    // its a match...
                    wcscpy( driveString, &driveLetters[i] );
                    hr = S_OK;
                }

                break;  // out of switch

            } // switch

            //
            // Cleanup
            //

            if ( driveHandle != INVALID_HANDLE_VALUE ) {
                status = CloseHandle( driveHandle );
                driveHandle = INVALID_HANDLE_VALUE;
                WsbAffirmStatus( status );
            }

        } // for each drive letter
    } WsbCatchAndDo( hr,
                        if ( driveHandle != INVALID_HANDLE_VALUE ) {
                            CloseHandle(driveHandle);
                        } );

    return hr;
}

HRESULT
CRmsServer::getDeviceName(
    IN UCHAR portNo,
    IN UCHAR pathNo,
    IN UCHAR id,
    IN UCHAR lun,
    OUT OLECHAR *deviceName)
/*++

Routine Description:

    Get device name from selected parameters.

Arguments:

    portNo          - port number.

    pathNo          - path number.

    id              - id.

    lun             - logical unit number.

    deviceName      - pointer to returned device name.


Return Value:

    S_OK            - Success

--*/
{
    HRESULT         hr = S_FALSE;
    OLECHAR         string[256];
    DWORD           len;
    OLECHAR         name[25];

    // just go to the registry and get the DeviceName

    swprintf( string,
              OLESTR("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d"),
              portNo, pathNo, id, lun );


    hr = WsbGetRegistryValueString( NULL,
                                    string,
                                    OLESTR("DeviceName"),
                                    name,
                                    25,
                                    &len );

    if ( S_OK == hr ) {
        wcscpy( deviceName, name );
    }

    return hr;
}


HRESULT
CRmsServer::resolveUnconfiguredDevices(void)
/*++

  This method goes through the unconfigured device list, which is created by
  the ScanForDevices() method, and determines if a device has already been configured.
  If a device is already configured, it is removed from the unconfigured device list.

--*/
{
    HRESULT hr = E_FAIL;
    WsbTraceIn(OLESTR("CRmsServer::resolveUnconfiguredDevices"), OLESTR(""));

    BOOL                                    tracingPlatform = 0;

    try {

        CComPtr<IWsbIndexedCollection>  pDevices;
        CComPtr<IWsbIndexedCollection>  pLibs;
        CComPtr<IRmsDevice>             pDevice;
        CComPtr<IWsbEnum>               pEnumDevices;
        CComPtr<IWsbEnum>               pEnumLibs;
        RmsDevice                       type;
        BOOL                            deviceIsConfigured = FALSE;

//        WsbAssertPointer( g_pTrace );
//        WsbAffirmHr( g_pTrace->GetTraceSetting( WSB_TRACE_BIT_PLATFORM, &tracingPlatform ));

        WsbAssertHr( GetLibraries( &pLibs ) );
        WsbAffirmHr( pLibs->Enum( &pEnumLibs ));
        WsbAssertPointer( pEnumLibs );

        WsbAssertHr( GetUnconfiguredDevices( &pDevices ));
        WsbAffirmHr( pDevices->Enum( &pEnumDevices ));
        WsbAssertPointer( pEnumDevices );

        // start off with the first unconfigured device.
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                CComPtr<IRmsLibrary>    pLib;

                deviceIsConfigured = FALSE;

                //
                // If a device is already in a library, then it is configured and
                // should be removed from the list of unconfigured devices.
                //
                // To test if a device is in a library we simply go to each library
                // and try to find the device.
                //

                WsbAffirmHr( pDevice->GetDeviceType( (LONG *) &type ) );
                WsbTrace(OLESTR("CRmsServer::resolveUnconfiguredDevices: external loop: device type = %ld\n"), (LONG)type);

                CComPtr<IWsbIndexedCollection> pChangers;
                CComPtr<IWsbIndexedCollection> pDrives;

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pDevice;
                WsbAssertPointer( pObject );

                // Set up search method for the changer
                WsbAffirmHr( pObject->SetFindBy( RmsFindByDeviceInfo ));

                // start off with the first library.
                hr = pEnumLibs->First( IID_IRmsLibrary, (void **)&pLib );
                while ( S_OK == hr ) {

                    try {
                        WsbTrace(OLESTR("CRmsServer::resolveUnconfiguredDevices: internal loop: device type = %ld\n"), (LONG)type);

                        switch ( type ) {
                        case RmsDeviceChanger:
                            {
                                CComQIPtr<IRmsMediumChanger, &IID_IRmsMediumChanger> pChanger = pDevice;
                                WsbAffirmHr( pLib->GetChangers( &pChangers ) );
                                WsbAffirmHrOk( pChangers->Contains( pChanger ));
                                deviceIsConfigured = TRUE;
                            }
                            break;

                        default:
                            {
                                CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                                WsbAffirmHr( pLib->GetDrives( &pDrives ) );
                                WsbAffirmHrOk( pDrives->Contains( pDrive ));
                                deviceIsConfigured = TRUE;
                            }
                            break;
                        }

                    }
                    WsbCatch(hr);
                    
                    if ( deviceIsConfigured ) {
                        WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                        break;
                    }

                    pLib = 0;
                    hr = pEnumLibs->Next( IID_IRmsLibrary, (void **)&pLib );
                }

            }
            WsbCatch(hr);

            pDevice = 0;
            if ( deviceIsConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );
        }

//        if ( !tracingPlatform )
//            WsbAffirmHr( g_pTrace->SetTraceOff( WSB_TRACE_BIT_PLATFORM ) );

        hr = S_OK;

    }
    WsbCatch(hr);
//    WsbCatchAndDo( hr,
//            if (g_pTrace) {
//                if ( !tracingPlatform )
//                    g_pTrace->SetTraceOff( WSB_TRACE_BIT_PLATFORM );
//            }        
//        );

    WsbTraceOut(OLESTR("CRmsServer::resolveUnconfiguredDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::autoConfigureDevices(void)
/*++

  This method automatically configures supported devices for RMS.

  The algorythm simply goes through the list of unconfigured devices and adds them
  to the appropriate library.

  Eventually, we need to be smart about when to bypass the auto-config step in favor
  of adminstrative overrides, but for now we'll automatically configure everything we
  can.

--*/
{

    //
    // for each device in the unconfigured list, check if it was previously configured,
    // if it is not add it to a library; otherwise delete it from the list of unconfigured devices.
    //
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsServer::autoConfigureDevices"), OLESTR(""));

    try {

        CComPtr<IWsbIndexedCollection>  pDevices;
        CComPtr<IWsbIndexedCollection>  pLibs;
        CComPtr<IWsbIndexedCollection>  pCarts;
        CComPtr<IRmsDevice>             pDevice;
        CComPtr<IWsbEnum>               pEnumDevices;

        RmsDevice   type;
        BOOL        deviceWasConfigured;

        WsbAssertHr( GetUnconfiguredDevices( &pDevices ));
        WsbAssertHr( GetLibraries( &pLibs ));
        WsbAssertHr( GetCartridges( &pCarts ));

        WsbAffirmHr( pDevices->Enum( &pEnumDevices ));
        WsbAssertPointer( pEnumDevices );

        // first find all the changer devices
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                deviceWasConfigured = FALSE;

                WsbAffirmHr( pDevice->GetDeviceType( (LONG *) &type ));
                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices: first loop: device type = %ld\n"), (LONG)type);

                switch ( type ) {

                case RmsDeviceChanger:
                    {

                        CComPtr<IWsbIndexedCollection>  pChangers;
                        CComPtr<IWsbIndexedCollection>  pDrives;
                        CComPtr<IWsbIndexedCollection>  pMediaSets;
                        CComPtr<IRmsLibrary>            pLib;
                        CComPtr<IRmsMediaSet>           pMediaSet;

                        CComQIPtr<IRmsMediumChanger, &IID_IRmsMediumChanger> pChanger = pDevice;
                        WsbAssertPointer( pChanger );

                        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pChangerElmt = pChanger;
                        WsbAssertPointer( pChanger );

                        // Create a Library object
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                            IID_IRmsLibrary, (void **)&pLib ));

                        // Fill in library info
                        WsbAffirmHr( pLib->SetName( RMS_DEFAULT_OPTICAL_LIBRARY_NAME ));
                        WsbAffirmHr( pLib->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));

                        // Add the library to the server's collection
                        WsbAffirmHr( pLibs->Add( pLib ));

                        // Create a media set
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                            IID_IRmsMediaSet, (void **)&pMediaSet ));

                        // Fill in media set info
                        WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_OPTICAL_MEDIASET_NAME ));
                        WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));
                        WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                        // Add the media set the libary's collection
                        WsbAssertHr( pLib->GetMediaSets( &pMediaSets ));
                        WsbAssertPointer( pMediaSets );
                        WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                        pMediaSets = 0;
                        // Add the media set the server's collection
                        WsbAssertHr( GetMediaSets( &pMediaSets ) );
                        WsbAssertPointer( pMediaSets );
                        WsbAffirmHr( pMediaSets->Add( pMediaSet ));

                        // Add the changer device to the library's collection
                        WsbAffirmHr( pLib->GetChangers( &pChangers ));
                        WsbAssertPointer( pChangers );
                        WsbAffirmHr( pChangers->Add( pChanger ));

                        // Set the changer's element information
                        GUID libId;
                        WsbAffirmHr( pLib->GetLibraryId( &libId ));
                        WsbAffirmHr( pChangerElmt->SetLocation( RmsElementChanger, libId, GUID_NULL, 0, 0, 0, 0, FALSE));
                        WsbAffirmHr( pChangerElmt->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));

                        // Initialize the changer device
                        WsbAffirmHr( pChanger->Initialize() );

                        deviceWasConfigured = TRUE;

                    }
                    break;

                default:
                    break;
                }

            }
            WsbCatch(hr);

            pDevice = 0;
            if ( deviceWasConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );

        }

        // any remaining devices are stand alone drives.
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                deviceWasConfigured = FALSE;

                WsbAffirmHr( hr = pDevice->GetDeviceType( (LONG *) &type ));
                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices: second loop: device type = %ld\n"), (LONG)type);

                switch ( type ) {
                    case RmsDeviceFixedDisk:
                       // find the fixed disk library and add this drive.
                       {

                            CComPtr<IWsbIndexedCollection>  pDrives;
                            CComPtr<IWsbIndexedCollection>  pMediaSets;
                            CComPtr<IRmsLibrary>            pFixedLib;
                            CComPtr<IRmsMediaSet>           pFixedMediaSet;
                            CComPtr<IRmsLibrary>            pFindLib;
                            CComPtr<IRmsCartridge>          pCart;

                            GUID    libId = GUID_NULL;
                            GUID    mediaSetId = GUID_NULL;
                            ULONG   driveNo;

                            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDevice;
                            WsbAssertPointer( pDriveElmt );

                            CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                            WsbAssertPointer( pDrive );

                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                IID_IRmsLibrary, (void **)&pFindLib ));

                            // Set up the find template

                            WsbAffirmHr( pFindLib->SetMediaSupported( RmsMediaFixed ));
                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;
                            WsbAffirmHr( pObject->SetFindBy( RmsFindByMediaSupported ));

                            // Find the library

                            hr = pLibs->Find( pFindLib, IID_IRmsLibrary, (void **)&pFixedLib );

                            if ( WSB_E_NOTFOUND == hr ) {

                                // We don't have a fixed drive library yet, so create one...

                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                    IID_IRmsLibrary, (void **)&pFixedLib ));
                                WsbAffirmHr( pFixedLib->SetName( RMS_DEFAULT_FIXEDDRIVE_LIBRARY_NAME ));
                                WsbAffirmHr( pFixedLib->SetMediaSupported( RmsMediaFixed ));

                                WsbAffirmHr( pLibs->Add( pFixedLib ));

                                CComPtr<IRmsMediaSet> pMediaSet;
                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                                    IID_IRmsMediaSet, (void **)&pMediaSet ));

                                
                                WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_FIXEDDRIVE_MEDIASET_NAME ));
                                WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMediaFixed ));
                                WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                                // Add the media set the libary's collection
                                WsbAssertHr( pFixedLib->GetMediaSets( &pMediaSets ));
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;
                                // Add the media set the server's collection
                                WsbAssertHr( GetMediaSets( &pMediaSets ) );
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                DWORD num;
                                WsbAffirmHr( pMediaSets->GetEntries( &num ));
                                pMediaSets = 0;

                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - type %d CRmsMediaSet created.\n"), RmsMediaFixed);
                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - Number of sets = %d.\n"), num);

                            }

                            // Add the drive to the library
                            WsbAssertHr( pFixedLib->GetDrives( &pDrives ));
                            WsbAffirmHr( pDrives->Add( pDevice ));
                            WsbAffirmHr( pDrives->GetEntries( &driveNo ));

                            // Remove the drive form the unconfigured list
                            WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                            deviceWasConfigured = TRUE;

                            // Get library information
                            WsbAssertHr( pFixedLib->GetMediaSets( &pMediaSets ));

                            WsbAffirmHr( pFixedLib->GetLibraryId( &libId ));

                            WsbAffirmHr( pMediaSets->First( IID_IRmsMediaSet, (void **)&pFixedMediaSet ));
                            WsbAffirmHr( pFixedMediaSet->GetMediaSetId( &mediaSetId ));


                            // Set the location
                            WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));

                            // Set the kind of media supported
                            WsbAffirmHr( pDriveElmt->SetMediaSupported( RmsMediaFixed ));

                            // Create a cartridge for the media in the drive.
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                                IID_IRmsCartridge, (void **)&pCart ));
                            WsbAffirmHr( pCart->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetHome( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                            WsbAffirmHr( pCart->SetType( RmsMediaFixed ));

                            // Add the drive to the Cartridge object.
                            WsbAffirmHr( pCart->SetDrive( pDrive ));

                            // Add the cartridge to the cartridge collection
                            WsbAffirmHr( pCarts->Add( pCart ));

                        }
                        break;

                    case RmsDeviceRemovableDisk:
                        // find manual library and add this stand alone drive.
                        break;

                    case RmsDeviceTape:
                        // find manual tape library and add this stand alone drive.
                        {

                            CComPtr<IWsbIndexedCollection>  pDrives;
                            CComPtr<IWsbIndexedCollection>  pMediaSets;
                            CComPtr<IRmsLibrary>            pTapeLib;
                            CComPtr<IRmsMediaSet>           pTapeMediaSet;
                            CComPtr<IRmsLibrary>            pFindLib;
                            CComPtr<IRmsCartridge>          pCart;

                            GUID    libId = GUID_NULL;
                            GUID    mediaSetId = GUID_NULL;
                            ULONG   driveNo;

                            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDevice;
                            WsbAssertPointer( pDriveElmt );

                            CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                            WsbAssertPointer( pDrive );

                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                IID_IRmsLibrary, (void **)&pFindLib ));

                            // Set up the find template

                            WsbAffirmHr( pFindLib->SetMediaSupported( RmsMedia4mm ));
                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;
                            WsbAffirmHr( pObject->SetFindBy( RmsFindByMediaSupported ));

                            // Find the library

                            hr = pLibs->Find( pFindLib, IID_IRmsLibrary, (void **)&pTapeLib );

                            if ( WSB_E_NOTFOUND == hr ) {

                                // We don't have a manual tape library yet, so create one...

                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                    IID_IRmsLibrary, (void **)&pTapeLib ));
                                WsbAffirmHr( pTapeLib->SetName( RMS_DEFAULT_TAPE_LIBRARY_NAME ));
                                WsbAffirmHr( pTapeLib->SetMediaSupported( RmsMedia4mm ));

                                WsbAffirmHr( pLibs->Add( pTapeLib ));

                                CComPtr<IRmsMediaSet> pMediaSet;
                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                                    IID_IRmsMediaSet, (void **)&pMediaSet ));
                                WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_TAPE_MEDIASET_NAME ));
                                WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMedia4mm ));
                                WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                                // Add the media set the library's collection
                                WsbAssertHr( pTapeLib->GetMediaSets( &pMediaSets ));
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;
                                // Add the media set the server's collection
                                WsbAssertHr( GetMediaSets( &pMediaSets ) );
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;

                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - type %d CRmsMediaSet created.\n"), RmsMedia4mm);

                            }

                            // Add the drive to the library
                            WsbAssertHr( pTapeLib->GetDrives( &pDrives ));
                            WsbAffirmHr( pDrives->Add( pDevice ));
                            WsbAffirmHr( pDrives->GetEntries( &driveNo ));

                            // Remove the drive form the unconfigured list
                            WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                            deviceWasConfigured = TRUE;

                            // Get library information
                            WsbAssertHr( pTapeLib->GetMediaSets( &pMediaSets ));
                            WsbAffirmHr( pTapeLib->GetLibraryId( &libId ));

                            WsbAffirmHr( pMediaSets->First( IID_IRmsMediaSet, (void **)&pTapeMediaSet ));
                            WsbAffirmHr( pTapeMediaSet->GetMediaSetId( &mediaSetId ));

                            // Set the location
                            WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));

                            // Set the kind of media supported
                            WsbAffirmHr( pDriveElmt->SetMediaSupported( RmsMedia4mm ));

                            // Create a cartridge for the media in the drive.
                            // TODO:  it may be empty.
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                           IID_IRmsCartridge, (void **)&pCart ));
                            WsbAffirmHr( pCart->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetHome( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                            WsbAffirmHr( pCart->SetType( RmsMedia4mm ));

                            // Add the drive to the Cartridge object.
                            WsbAffirmHr( pCart->SetDrive( pDrive ));

                            // Add the cartridge to the cartridge collection
                            WsbAffirmHr( pCarts->Add( pCart ));

                        }
                        break;

                    case RmsDeviceCDROM:
                    case RmsDeviceWORM:
                    case RmsDeviceOptical:
                        // find manual library and add this stand alone drive.
                        break;

                    default:
                        break;
                }

            } WsbCatch(hr);

            pDevice = 0;

            if ( deviceWasConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else    
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );

        }

        hr = S_OK;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::autoConfigureDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


// Maximum number of retries for allocating and mounting a scratch piece of media
#define     MAX_RETRIES     2


STDMETHODIMP
CRmsServer::MountScratchCartridge(
    OUT GUID *pCartId,
    IN REFGUID fromMediaSet,
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN LONG blockingFactor,
    IN BSTR displayName,
    IN OUT IRmsDrive **ppDrive,
    OUT IRmsCartridge **ppCartridge,
    OUT IDataMover **ppDataMover,
	IN DWORD dwOptions)
/*++

Implements:

    IRmsServer::MountScratchCartridge

Notes: The default flag for mounting (in dwOptions) is blocking, i.e. waiting for the Mount 
		to finish even if the media is offline, the drive is not ready, etc. Calling with 
		flag set to non-blocking indicates performing the Mount only if everything is 
		available immediately.

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::MountScratchCartridge"), OLESTR("<%ls> <%ls> <%ls>"),
        WsbQuickString(WsbGuidAsString(fromMediaSet)),
        WsbQuickString(WsbPtrToLonglongAsString(pFreeSpace)),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&displayName)));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    GUID cartId = GUID_NULL;
    CWsbBstrPtr label;

    try {
        WsbAssertPointer(pCartId);

       
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);

        WsbAffirmHrOk( IsReady() );

        DWORD retry = 0;
        CComPtr<IRmsDrive>      pDrive;
        CComPtr<IRmsCartridge>  pCart[MAX_RETRIES];
        CComPtr<IDataMover>     pMover;

        // Decrease max-retries to 1 if short-timeout or non-blocking is specified 
        //  or if we want to allocate a specific side
        DWORD maxRetries = MAX_RETRIES;
        BOOL bShortTimeout = ( (dwOptions & RMS_SHORT_TIMEOUT) || (dwOptions & RMS_ALLOCATE_NO_BLOCK) ) ? TRUE : FALSE;
        if (bShortTimeout || (GUID_NULL != prevSideId)) {
            maxRetries = 1;
        }
        WsbTrace(OLESTR("Try to allocate and mount a scratch media %lu times\n"), maxRetries);

        // Get the media set
        CComPtr<IRmsMediaSet>   pMediaSet;
        WsbAffirmHr(CreateObject(fromMediaSet, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));

        try {
            // Allocate from the specified media set
            WsbAffirmHr(pMediaSet->Allocate(prevSideId, pFreeSpace, displayName, dwOptions, &pCart[retry]));

            // We want to try the scratch mount twice, but do not deallocate the first until we
            // grab the second cartridge so we'll get a different cartridge.  If both fail, drop out.
            do {
                //Clear these,in case we're retrying.
                pDrive = NULL;
                pMover = NULL;

                try {

                    cartId = GUID_NULL;
                    cartridgeName = "";
                    cartridgeDesc = "";


                    WsbAffirmHr(pCart[retry]->GetCartridgeId(&cartId));         // for the log message

                    cartridgeName.Free();
                    WsbAffirmHr(pCart[retry]->GetName(&cartridgeName));         // for the log message

                    cartridgeDesc.Free();
                    WsbAffirmHr(pCart[retry]->GetDescription(&cartridgeDesc));  // for the log message

                    // Mount the cartridge.
                    WsbAffirmHr(pCart[retry]->Mount(&pDrive, dwOptions));

                    try {

                        // Set blockingFactor before we create the DataMover (only for a non-fixed block size media)
                        if (blockingFactor > 0) {
                            HRESULT hrBlock = pCart[retry]->IsFixedBlockSize();
                            WsbAffirmHr(hrBlock);
                            if (hrBlock == S_FALSE) {
                                WsbTrace(OLESTR("MountScratchCartridge: Setting block size on scratch media to %ld\n"), blockingFactor);
                                WsbAffirmHr(pCart[retry]->SetBlockSize(blockingFactor));
                            }
                        }

                        // Create a data mover for the application.
                        WsbAffirmHr(pCart[retry]->CreateDataMover(&pMover));

                        // Write out the On Media Label.                                                                 
                        label.Free();
                        WsbAffirmHr(pMover->FormatLabel(displayName, &label));
                        WsbAffirmHr(pMover->WriteLabel(label));

                        // Mark the media private before returning.
                        WsbAffirmHr(pCart[retry]->SetStatus(RmsStatusPrivate));

                        // Since we don't have a DB, we need to persist the current state here.
                        WsbAffirmHr(SaveAll());

                        //
                        // Fill in the return arguments.
                        //

                        WsbAssertHr(pCart[retry]->GetCartridgeId(pCartId));

                        *ppDrive = pDrive;
                        pDrive.p->AddRef();
                        *ppCartridge = pCart[retry];
                        pCart[retry].p->AddRef();
                        *ppDataMover = pMover;
                        pMover.p->AddRef();  
                        

                        // We're done, so break out.
                        break;


                    } WsbCatchAndDo(hr,

                            // Best effort dismount...
					        DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;
	                        pCart[retry]->Dismount(dwDismountOptions);
                            WsbThrow(hr);                     

                        )
  
               

            } WsbCatchAndDo(hr,

                    retry++;

                    // Check the exact error code:
                    // Alllow another retry only if the error may be media-related
                    BOOL bContinue = TRUE;
                    switch (hr) {
                        case RMS_E_SCRATCH_NOT_FOUND:
                        case RMS_E_CANCELLED:
                        case RMS_E_REQUEST_REFUSED:
                        case RMS_E_CARTRIDGE_UNAVAILABLE:   // timeout during Mount
                        case HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_AVAILABLE):
                        case HRESULT_FROM_WIN32(ERROR_INVALID_DRIVE):
                        case HRESULT_FROM_WIN32(ERROR_RESOURCE_DISABLED):   // disabled drives
                        case HRESULT_FROM_WIN32(ERROR_DATABASE_FULL):
                            // Prevent another retry
                            bContinue = FALSE;
                            break;

                        default:
                            break;
                    }

                    // Persist original failure code
                    HRESULT hrFailure = hr;

                    if (bContinue && (retry < maxRetries)) {                       

						WsbLogEvent(RMS_MESSAGE_SCRATCH_MOUNT_RETRY, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, 
                            WsbHrAsString(hr), NULL);
                            							
                        // Allocate from the specified media set						
                        hr = pMediaSet->Allocate(prevSideId, pFreeSpace, displayName, dwOptions, &pCart[retry]);

                        //Check media failures (ignore return value)
                        CheckForMediaFailures(hrFailure, pCart[(retry-1)], prevSideId);

                        // Deallocate the previous retry media set
                        pMediaSet->Deallocate(pCart[(retry-1)]);

                        // Make sure the allocate worked, if not, throw.
                        WsbAffirmHr(hr);
                                                
                    }
                    else {
                        //Check media failures (ignore return value)
                        CheckForMediaFailures(hrFailure, pCart[(retry-1)], prevSideId);

                        // If were on the last retry, deallocate the last media set and E_ABORT
                        pMediaSet->Deallocate(pCart[(retry-1)]);

                        // Abort
                        WsbThrow(hr);

                    }
                )


            } while (retry < maxRetries);

        } WsbCatch(hr)

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_MOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        BOOL bShortTimeout = ( (dwOptions & RMS_SHORT_TIMEOUT) || (dwOptions & RMS_ALLOCATE_NO_BLOCK) ) ? TRUE : FALSE;
        // In case of short-timeout or non-blocking mode or size-too-big error, log message with low severity
        if (bShortTimeout || (RMS_E_SCRATCH_NOT_FOUND_TOO_SMALL == hr)) {
            WsbLogEvent(RMS_MESSAGE_EXPECTED_SCRATCH_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, WsbHrAsString(hr), NULL);
        } else {
            WsbLogEvent(RMS_MESSAGE_SCRATCH_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, WsbHrAsString(hr), NULL);
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::MountScratchCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::MountCartridge(
    IN REFGUID cartId,
    IN OUT IRmsDrive **ppDrive,
    OUT IRmsCartridge **ppCartridge,
    OUT IDataMover **ppDataMover,
	IN  DWORD dwOptions OPTIONAL,
    IN  DWORD threadId OPTIONAL)
/*++

Implements:

    IRmsServer::MountCartridge

Notes: The default flag for mounting (in dwOptions) is blocking, i.e. waiting for the Mount 
		to finish even if the media is offline, the drive is not ready, etc. Calling with 
		flag set to non-blocking indicates performing the Mount only if everything is 
		available immediately.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::MountCartridge"), OLESTR("<%ls>"), WsbGuidAsString(cartId));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {
        WsbAffirmHrOk( IsReady() );

        CComPtr<IRmsDrive>      pDrive;
        CComPtr<IRmsCartridge>  pCart;
        CComPtr<IDataMover>     pMover;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        WsbAffirmHr(pCart->Mount(&pDrive, dwOptions, threadId));

        try {
            WsbAffirmHr(pCart->CreateDataMover(&pMover));

            //
            // Fill in the return arguments.
            //

            *ppDrive = pDrive;
            pDrive.p->AddRef();
            *ppCartridge = pCart;
            pCart.p->AddRef();
            *ppDataMover = pMover;
            pMover.p->AddRef();

        } WsbCatchAndDo(hr,
                // Best effort dismount...
				DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;
                pCart->Dismount(dwDismountOptions);
                WsbThrow(hr);
            )


    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_MOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;
        // In case of short timeout, log message with low severity
        if (bShortTimeout) {
            WsbLogEvent(RMS_MESSAGE_EXPECTED_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
        } else {
            WsbLogEvent(RMS_MESSAGE_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::MountCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::DismountCartridge(
    IN REFGUID cartId, IN DWORD dwOptions)
/*++

Implements:

    IRmsServer::DismountCartridge

Notes: The default flag for dismounting (in dwOptions) is not set for immediate dismount, 
		i.e. delaying the Dismount for a configurable amount of time. Setting the flag
		for immediate dismount indicates performing Dismount immediately with no delay.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::DismountCartridge"), OLESTR("<%ls>"), WsbGuidAsString(cartId));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {

        //
        // Allow dismount when ready or in transition...
        // to handle in-progress duplicate operations.
        //
        HRESULT hrReady = IsReady();
        WsbAffirm((S_OK == hrReady) ||
                  (RMS_E_NOT_READY_SERVER_SUSPENDING == hrReady), hrReady);
   
        CComPtr<IRmsCartridge>  pCart;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        WsbAffirmHr(pCart->Dismount(dwOptions));

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_DISMOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        WsbLogEvent(RMS_MESSAGE_DISMOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CRmsServer::DismountCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;

}

STDMETHODIMP
CRmsServer::DuplicateCartridge(
    IN REFGUID originalCartId,
    IN REFGUID firstSideId,
    IN OUT GUID *pCopyCartId,
    IN REFGUID copySetId,
    IN BSTR copyName,
    OUT LONGLONG *pFreeSpace,
    OUT LONGLONG *pCapacity,
    IN DWORD options)
/*++

Implements:

    IRmsServer::DuplicateCartridge

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::DuplicateCartridge"), OLESTR("<%ls> <%ls> <%ls> <%ls> <%d>"),
        WsbQuickString(WsbGuidAsString(originalCartId)),
        WsbQuickString(WsbPtrToGuidAsString(pCopyCartId)),
        WsbQuickString(WsbGuidAsString(copySetId)),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&copyName)),
        options);

    CComPtr<IDataMover> pMover1;
    CComPtr<IDataMover> pMover2;

    GUID newCartId = GUID_NULL;

    LONGLONG freeSpace = 0;
    LONGLONG capacity = 0;

    try {
        WsbAffirmHrOk( IsReady() );

        WsbAssertPointer( pCopyCartId );

        // Mount the Copy first and then the original
        CComPtr<IRmsDrive>      pDrive1;
        CComPtr<IRmsCartridge>  pCart1;
        CComPtr<IRmsDrive>      pDrive2;
        CComPtr<IRmsCartridge>  pCart2;


        LONG blockSize1=0, blockSize2=0;

        // Serialize mounts for media copies
        DWORD dwMountOptions = RMS_SERIALIZE_MOUNT;

        // mount copy
        if ( *pCopyCartId != GUID_NULL ) {
            WsbAffirmHr(MountCartridge(*pCopyCartId, &pDrive2, &pCart2, &pMover2, dwMountOptions));
        }
        else {
            GUID mediaSetId = copySetId;
            CComPtr<IRmsCartridge>  pCart;

            WsbAffirmHr(FindCartridgeById(originalCartId, &pCart));
            WsbAffirmHr(pCart->GetBlockSize(&blockSize1));
            if ( mediaSetId == GUID_NULL ) {
                WsbAffirmHr(pCart->GetMediaSetId(&mediaSetId));
            }

            //  Get capacity of original media and adjust by fudge factor
            LONGLONG capacity=0;
            CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = pCart;
            WsbAffirmHr(pInfo->GetCapacity(&capacity));

            LONG  fudge = RMS_DEFAULT_MEDIA_COPY_TOLERANCE;
            DWORD size;
            OLECHAR tmpString[256];

            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_MEDIA_COPY_TOLERANCE, tmpString, 256, &size))) {
                // Get the value.
                fudge = wcstol(tmpString, NULL, 10);
            }
            capacity -= (capacity * fudge) / 100;

            WsbAffirmHr(MountScratchCartridge( &newCartId, mediaSetId, firstSideId, &capacity, blockSize1, copyName, &pDrive2, &pCart2, &pMover2, dwMountOptions ));
        }

        // Mount original (in a non-blocking manner)
        dwMountOptions |= RMS_MOUNT_NO_BLOCK;
        WsbAffirmHr(MountCartridge(originalCartId, &pDrive1, &pCart1, &pMover1, dwMountOptions));

        // Verify matching block size (only for a non-fixed block size media)
        HRESULT hrBlock = pCart1->IsFixedBlockSize();
        WsbAffirmHr(hrBlock);
        if (hrBlock == S_FALSE) {
            if (blockSize1 == 0) {
                // didn't get it yet...
                WsbAffirmHr(pCart1->GetBlockSize(&blockSize1));
            }

            WsbAffirmHr(pCart2->GetBlockSize(&blockSize2));
            WsbAssert(blockSize1 == blockSize2, E_UNEXPECTED);
        }

        WsbAffirmHr(pMover1->Duplicate(pMover2, options, NULL, NULL));

        // Now get stats to return to caller.
        WsbAffirmHr(pMover2->GetLargestFreeSpace(&freeSpace, &capacity));

        if (pFreeSpace) {
            *pFreeSpace = freeSpace;
        }

        if (pCapacity) {
            *pCapacity = capacity;
        }

    } WsbCatch(hr)

    if ( pMover1 ) {
        DismountCartridge(originalCartId);
    }
    if ( pMover2 ) {
        // We always perform immediate dismount to the copy media
		//	(We may need to recycle a new copy in case of an error + there's no benefit in a deferred
        //  dismount for the copy-media - we don't expect the copy-media to be needed again soon)
		DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;

        if (newCartId == GUID_NULL) {
            // this is the case of an existing copy
            DismountCartridge(*pCopyCartId, dwDismountOptions);
        } else {
            // this is the case of a scratch copy
            DismountCartridge(newCartId, dwDismountOptions);

            // if mounting of original failed, we always recycle the scratch copy
            if (((options & RMS_DUPLICATE_RECYCLEONERROR) || (pMover1 == NULL)) && (S_OK != hr)) {
                //
                // If we failed and a scratch mount was performed
                // we need to recycle the cartridge since the calling
                // app can't be depended upon to do this.
                //
                RecycleCartridge(newCartId, 0);
            } else {
                *pCopyCartId = newCartId;
            }
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::DuplicateCartridge"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CRmsServer::RecycleCartridge(
    IN REFGUID cartId,
    IN DWORD options)
/*++

Implements:

    IRmsServer::RecycleCartridge

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::RecycleCartridge"), OLESTR("<%ls> <%d>"), WsbGuidAsString(cartId), options);

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {
        //
        // Allow recycle when ready or in transition...
        // to handle in-progress duplicate operations.
        //
        HRESULT hrReady = IsReady();
        WsbAffirm((S_OK == hrReady) ||
                  (RMS_E_NOT_READY_SERVER_SUSPENDING == hrReady), hrReady);

        CComPtr<IRmsCartridge>  pCart;

        GUID                    mediaSetId;
        CComPtr<IRmsMediaSet>   pMediaSet;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        // Now go to the media set to deallocate
        WsbAffirmHr(pCart->GetMediaSetId(&mediaSetId));
        WsbAffirmHr(CreateObject(mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));
        WsbAffirmHr(pMediaSet->Deallocate(pCart));

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_RECYCLED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_RECYCLE_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
    }


    WsbTraceOut(OLESTR("CRmsServer::RecycleCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::FindLibraryById(
    IN REFGUID libId,
    OUT IRmsLibrary **pLib)
/*++

Implements:

    IRmsServer::FindLibraryById

--*/
{

    HRESULT hr = E_FAIL;

    CComPtr<IRmsCartridge> pFindLib;

    try {

        WsbAssertPointer( pLib );

        // Create a cartridge template
        WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                       IID_IRmsLibrary, (void **)&pFindLib ));

        // Fill in the find template
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;

        WsbAffirmHr( pObject->SetObjectId( libId ));
        WsbAffirmHr( pObject->SetFindBy( RmsFindByObjectId ));

        // Find the cartridge
        WsbAffirmHr( m_pLibraries->Find( pFindLib, IID_IRmsLibrary, (void **)pLib ));

        hr = S_OK;

    } WsbCatchAndDo(hr,
            if ( WSB_E_NOTFOUND == hr) hr = RMS_E_LIBRARY_NOT_FOUND;
            WsbTrace(OLESTR("CRmsServer::FindLibraryById - %ls Not Found.  hr = <%ls>\n"),WsbGuidAsString(libId),WsbHrAsString(hr));
        );

    return hr;
}


STDMETHODIMP
CRmsServer::FindCartridgeById(
    IN REFGUID cartId,
    OUT IRmsCartridge **ppCart)
/*++

Implements:

    IRmsServer::FindCartridgeById

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::FindCartridgeById"), OLESTR("%ls"), WsbGuidAsString(cartId));

    try {
        WsbAssertPointer(ppCart);

        //
        // The search algorithms attempts to avoid unnecessary throws that
        // clutter the trace file.  Each media management subsystem is tried.
        //

        // First check the most active cartridge.
        hr = RMS_E_CARTRIDGE_NOT_FOUND;

        if (m_pActiveCartridge) {
            GUID activeId;
            WsbAffirmHr( m_pActiveCartridge->GetCartridgeId(&activeId));
            if (activeId == cartId) {
                *ppCart = m_pActiveCartridge;
                m_pActiveCartridge.p->AddRef();
                hr = S_OK;
            }
        }

        if (hr != S_OK ) {

            //
            // Try native RMS
            //
            try {
                hr = S_OK;

                CComPtr<IRmsCartridge> pFindCart;

                // Create a cartridge template
                WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                              IID_IRmsCartridge, (void **)&pFindCart));

                // Fill in the find template
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;

                WsbAffirmHr( pObject->SetObjectId(cartId));
                WsbAffirmHr( pObject->SetFindBy(RmsFindByObjectId));

                // Try to find the cartridge in the collection of active cartridges.
                hr = m_pActiveCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);

                if (WSB_E_NOTFOUND == hr) {

                    // Find the cartridge in the collection of cartridges
                    hr = m_pCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                    WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);

                    if (WSB_E_NOTFOUND == hr) {
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    }

                }

            } WsbCatch(hr);

        }


        if ( hr != S_OK ) {

            //
            // Try NTMS
            //
            try {
                hr = S_OK;

                hr = IsNTMSInstalled();
                if ( S_OK == hr ) {
                    hr = m_pNTMS->FindCartridge(cartId, ppCart);
                    WsbAffirm(S_OK == hr || RMS_E_CARTRIDGE_NOT_FOUND == hr, hr);
                }
                else {
                    switch(hr) {
                    case RMS_E_NOT_CONFIGURED_FOR_NTMS:
                    case RMS_E_NTMS_NOT_REGISTERED:
                        // Normal errors
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                        break;
                    default:
                        // Unexpected Error!
                        WsbThrow(hr);
                        break;
                    }
                }

            } WsbCatch(hr);

        }

    } WsbCatchAndDo(hr,
            CWsbStringPtr idString = cartId;
            WsbLogEvent(RMS_MESSAGE_CARTRIDGE_NOT_FOUND, 0, NULL, (WCHAR *) idString, WsbHrAsString(hr), NULL);
            hr = RMS_E_CARTRIDGE_NOT_FOUND;
        );


    WsbTraceOut(OLESTR("CRmsServer::FindCartridgeById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsServer::CreateObject(
    IN REFGUID objectId,
    IN REFCLSID rclsid,
    IN REFIID riid,
    IN DWORD dwCreate,
    OUT void **ppvObj)
/*++

Implements:

    IRmsServer::CreateObject

--*/
{

    HRESULT hr = E_FAIL;


    try {

        WsbAssertPointer( ppvObj );
        WsbAssert( NULL == *ppvObj, E_INVALIDARG );

        CComPtr<IWsbIndexedCollection>  pCollection;
        CComPtr<IWsbCollectable>        pCollectable;

        if ( objectId != GUID_NULL ) {

            CComPtr<IRmsComObject> pFindObject;

            // Create an object template
            WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                           IID_IRmsComObject, (void **)&pFindObject ));

            WsbAffirmHr( pFindObject->SetObjectId( objectId ));
            WsbAffirmHr( pFindObject->SetFindBy( RmsFindByObjectId ));

            // The only kinds created must support: IRmsComObject (for the object Id),
            // and IWsbCollectable (to be added to a collection).

            // See if the object is already in a collection.
            try {
                if ( CLSID_CRmsCartridge == rclsid ) {
                    pCollection = m_pCartridges;
                    WsbAffirmHrOk( m_pCartridges->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsLibrary == rclsid ) {
                    pCollection = m_pLibraries;
                    WsbAffirmHrOk( m_pLibraries->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsMediaSet == rclsid ) {
                    pCollection = m_pMediaSets;
                    WsbAffirmHrOk( m_pMediaSets->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsRequest == rclsid ) {
                    pCollection = m_pRequests;
                    WsbAffirmHrOk( m_pRequests->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsClient == rclsid ) {
                    pCollection = m_pClients;
                    WsbAffirmHrOk( m_pClients->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else {
                    WsbThrow( E_UNEXPECTED );
                }

                hr = S_OK;
            } WsbCatch(hr);

        }
        else if ( RmsOpenExisting == dwCreate ) {

            // If we get GUID_NULL, we must going after a default object, and we only support this
            // with existing objects. This is only legal if the default media set registry key exists.

            if ( CLSID_CRmsMediaSet == rclsid ) {

                CWsbBstrPtr defaultMediaSetName = RMS_DEFAULT_MEDIASET;

                DWORD size;
                OLECHAR tmpString[256];
                if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DEFAULT_MEDIASET, tmpString, 256, &size))) {
                    // Get the value.
                    defaultMediaSetName = tmpString;
                }
                else {
                    WsbAssert( objectId != GUID_NULL, E_INVALIDARG );
                }

                CComPtr<IRmsComObject> pFindObject;

                // Create an object template
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IRmsComObject, (void **)&pFindObject ));

                WsbAffirmHr( pFindObject->SetName( defaultMediaSetName ));
                WsbAffirmHr( pFindObject->SetFindBy( RmsFindByName ));

                pCollection = m_pMediaSets;
                WsbAffirmHrOk( m_pMediaSets->Find( pFindObject,
                               IID_IWsbCollectable, (void **) &pCollectable ) );

                WsbTrace(OLESTR("Using Default MediaSet <%ls>.\n"), (WCHAR *) defaultMediaSetName);

                hr = S_OK;
            }
            else {
                WsbThrow( E_INVALIDARG );
            }
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        // If the object wasn't found we create it here, and add it to the appropriate collection.
        switch ( (RmsCreate)dwCreate ) {
        case RmsOpenExisting:
            if ( S_OK == hr ) {
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) ); 
            }
            else {
                WsbThrow( hr );
            }
            break;

        case RmsOpenAlways:
            if ( WSB_E_NOTFOUND == hr ) {
                // Create the object
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IWsbCollectable, (void **) &pCollectable ));

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
                WsbAffirmPointer( pObject );
                WsbAffirmHr( pObject->SetObjectId( objectId ) );

                // Before we add the collection, make sure the interface is supported.
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj )); 
                WsbAffirmPointer( pCollection );
                WsbAffirmHr( pCollection->Add( pCollectable ) );
            }
            else if ( S_OK == hr ) {
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) ); 
            }
            else {
                WsbThrow( hr );
            }
            break;

        case RmsCreateNew:
            if ( WSB_E_NOTFOUND == hr ) {
                // Create the object
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IWsbCollectable, (void **) &pCollectable ));

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
                WsbAffirmPointer( pObject );
                WsbAffirmHr( pObject->SetObjectId( objectId ) );

                // Before we add the collection, make sure the interface is supported.
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) );
                WsbAffirmPointer( pCollection );
                WsbAffirmHr( pCollection->Add( pCollectable ) );
            }
            else if ( S_OK == hr ) {
                WsbThrow( RMS_E_ALREADY_EXISTS );
            }
            else {
                WsbThrow( hr );
            }
            break;

        default:
            WsbThrow( E_UNEXPECTED );
            break;

        }

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
                        if ( WSB_E_NOTFOUND == hr) hr = RMS_E_NOT_FOUND;
                        WsbTrace(OLESTR("!!!!! ERROR !!!!! CRmsServer::CreateObject: %ls; hr = <%ls>\n"),WsbGuidAsString(objectId),WsbHrAsString(hr));
                  );

    return hr;
}


HRESULT
CRmsServer::getHardDrivesToUseFromRegistry(
    OUT OLECHAR *pDrivesToUse,
    OUT DWORD *pLen)
/*++


--*/
{
    HRESULT         hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::GetHardpDrivesToUseFromRegistry"),OLESTR(""));

    try {
        WsbAssert(0 != pDrivesToUse, E_POINTER); 
        WsbAssert(0 != pLen, E_POINTER); 

        DWORD           sizeGot;
        OLECHAR         tmpString[1000];

        *pLen = 0;
        pDrivesToUse[0] = OLECHAR('\0');
        pDrivesToUse[1] = OLECHAR('\0');

        //
        // Get the default value
        //
        WsbAffirmHr(WsbEnsureRegistryKeyExists (NULL, RMS_REGISTRY_STRING));
        WsbAffirmHr(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_HARD_DRIVES_TO_USE, 
                                            tmpString, RMS_DIR_LEN, &sizeGot));
        // We are doing some string manipulation here to match the Win32 call 
        // GetLogicalDriveStrings.  It returns a string of drives separated by 
        // Nulls with a double NULL at the end.  For example:  if we want to use
        // the C and E drives the string should be: C:\<null>E:\<null><null>
        // and len would be 8.
        DWORD myCharCount = 0;
        sizeGot = wcslen(tmpString);
        for (DWORD i = 0; i < sizeGot; i++) {
            swprintf((OLECHAR *)&pDrivesToUse[myCharCount], OLESTR("%c:\\"), tmpString[i]);
            myCharCount = ((i + 1)* 4);
        }
        pDrivesToUse[myCharCount] = OLECHAR('\0');
        if (myCharCount != 0)  {
            *pLen = myCharCount + 1;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::GetHardpDrivesToUseFromRegistry"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsServer::enableAsBackupOperator(void)
/*++

Routine Description:

    This routine enables backup operator privilege for the process.  This is required
    to insure that RMS has full access to all resources on the system, primarily with
    regard to the data mover.

Arguments:

    None.

Return Values:

    S_OK                        - Success.

--*/
{

    HRESULT hr = E_FAIL;

    try {

        HANDLE              pHandle;
        LUID                backupValue;
        HANDLE              tokenHandle;
        TOKEN_PRIVILEGES    newState;
        DWORD               lErr;

        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));
        //
        // adjust backup token privileges
        //
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));
        //
        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        //
        if ( (lErr = GetLastError()) != ERROR_SUCCESS ) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            //
            WsbLogEvent( RMS_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));
        //
        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        //
        if ( (lErr = GetLastError()) != ERROR_SUCCESS ) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            //
            WsbLogEvent( RMS_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                              WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );

        }
        CloseHandle( tokenHandle );

        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;

}


STDMETHODIMP 
CRmsServer::ChangeState(
    IN LONG newState)
/*++

Implements:

    IRmsServer::CreateObject

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::ChangeState"), OLESTR("<%d>"), newState);

    try {

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        switch ((RmsServerState) newState) {
        case RmsServerStateStarting:
        case RmsServerStateStarted:
        case RmsServerStateInitializing:
        case RmsServerStateReady:
        case RmsServerStateStopping:
        case RmsServerStateStopped:
        case RmsServerStateSuspending:
        case RmsServerStateSuspended:
        case RmsServerStateResuming:
            WsbAffirmHr(pObject->SetState(newState));
            break;
        default:
            WsbAssert(0, E_UNEXPECTED);
            break;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::ChangeState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::IsReady(void)
/*++

Implements:

    IRmsServer::IsReady

--*/
{

    HRESULT hr = S_OK;

    try {

        BOOL isEnabled;
        HRESULT status;
        RmsServerState state;

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        WsbAffirm(m_LockReference == 0, RMS_E_NOT_READY_SERVER_LOCKED);

        WsbAffirmHr( isEnabled = pObject->IsEnabled());
        WsbAffirmHr( pObject->GetState( (LONG *)&state ));
        WsbAffirmHr( pObject->GetStatusCode( &status ));

        if ( S_OK == isEnabled ) {
            if ( RmsServerStateReady == state ) {
                hr = S_OK;
            }
            else {
                if ( S_OK == status ) {
                    switch ( state ) {
                    case RmsServerStateStarting:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STARTING);
                        break;
                    case RmsServerStateStarted:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STARTED);
                        break;
                    case RmsServerStateInitializing:
                        WsbThrow(RMS_E_NOT_READY_SERVER_INITIALIZING);
                        break;
                    case RmsServerStateStopping:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STOPPING);
                        break;
                    case RmsServerStateStopped:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STOPPED);
                        break;
                    case RmsServerStateSuspending:
                        WsbThrow(RMS_E_NOT_READY_SERVER_SUSPENDING);
                        break;
                    case RmsServerStateSuspended:
                        WsbThrow(RMS_E_NOT_READY_SERVER_SUSPENDED);
                        break;
                    case RmsServerStateResuming:
                        WsbThrow(RMS_E_NOT_READY_SERVER_RESUMING);
                        break;
                    default:
                        WsbThrow(E_UNEXPECTED);
                        break;
                    }
                }
                else {
                    WsbThrow(status);
                }
            }
        }
        else {
            if ( S_OK == status ) {
                WsbThrow(RMS_E_NOT_READY_SERVER_DISABLED);
            }
            else {
                WsbThrow(status);
            }
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CRmsServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ChangeSysState"), OLESTR("State = %lx"), 
            pSysState->State);
    
    try {
        if ((pSysState->State & HSM_STATE_SHUTDOWN) ||
            (pSysState->State & HSM_STATE_SUSPEND)) {
            //
            // Shutdown or Suspend operations
            //
            // For power mangement support we need to release
            // all device handles, and the NTMS (RSM) session handle.
            //
            // To accomplish this we simply disable each cartridge,
            // then disable NTMS.
            //
            // The fallout from this gets everything in the power ready state.
            //

            WsbAffirmHr(ChangeState(RmsServerStateSuspending));

            //
            // Suspend operations with NMTS.  This will cancel any in-progress mounts.
            //
            WsbAffirmHr(m_pNTMS->Suspend());

            //
            // Disable each of the active cartridges
            //
            CComPtr<IWsbEnum>       pEnumCartridges;
            CComPtr<IWsbEnum>       pEnumDataMovers;
            CComPtr<IRmsComObject>  pObject;
            CComPtr<IRmsCartridge>  pCart;
            CComPtr<IDataMover>     pMover;
            CComPtr<IRmsDrive>      pDrive;

            WsbAffirmHr( m_pActiveCartridges->Enum( &pEnumCartridges ));
            WsbAssertPointer( pEnumCartridges );

            //
            // Disable each cartridge.
            //

            hr = pEnumCartridges->First( IID_IRmsComObject, (void **)&pObject );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pObject->Disable(RMS_E_NOT_READY_SERVER_SUSPENDING));
                } WsbCatch(hr);

                pObject = 0;
                hr = pEnumCartridges->Next( IID_IRmsComObject, (void **)&pObject );
            }
            hr = S_OK;


/*
            Tracking DataMovers is only partially implemented.


            //
            // Cancel I/O requests.
            //

            WsbAffirmHr( m_pDataMovers->Enum( &pEnumDataMovers ));
            WsbAssertPointer( pEnumDataMovers );
            hr = pEnumDataMovers->First( IID_IDataMover, (void **)&pMover );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pMover->Cancel());
                } WsbCatch(hr);

                pMover = 0;
                hr = pEnumDataMovers->Next( IID_IDataMover, (void **)&pMover );
            }
            hr = S_OK;

*/

            //
            // Unload all drives.
            //

            hr = pEnumCartridges->First( IID_IRmsCartridge, (void **)&pCart );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pCart->GetDrive(&pDrive));
                    WsbAffirmHr(pDrive->UnloadNow());
                } WsbCatch(hr);

                pDrive = 0;
                pCart = 0;

                //
                // We use "->This" since the UnloadNow() method will wait
                // until the active cartridge is dismount, and removed
                // from the active cartridge list.
                //
                hr = pEnumCartridges->This( IID_IRmsCartridge, (void **)&pCart );
            }
            hr = S_OK;

            //
            // Suspend operations with NMTS.  This will close the NTMS handle in
            // case it was reopend for dismounts during shutdown.
            //
            WsbAffirmHr(m_pNTMS->Suspend());

            WsbAffirmHr(ChangeState(RmsServerStateSuspended));

        } else if (pSysState->State & HSM_STATE_RESUME) {
            //
            // Resume operations
            //
            WsbAffirmHr(ChangeState(RmsServerStateResuming));

            WsbAffirmHr(m_pNTMS->Resume());

            CComPtr<IWsbEnum>      pEnumCartridges;
            CComPtr<IRmsComObject> pObject;

            WsbAffirmHr( m_pActiveCartridges->Enum( &pEnumCartridges ));
            WsbAssertPointer( pEnumCartridges );

            //
            // Enable each of the active cartridges
            //
            hr = pEnumCartridges->First( IID_IRmsComObject, (void **)&pObject );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pObject->Enable());
                } WsbCatch(hr);

                pObject = 0;
                hr = pEnumCartridges->Next( IID_IRmsComObject, (void **)&pObject );
            }
            hr = S_OK;

            WsbAffirmHr(ChangeState(RmsServerStateReady));

        }
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CRmsServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::GetNofAvailableDrives( 
    IN REFGUID fromMediaSet,
    OUT DWORD* pdwNofDrives 
    )

/*++

Implements:

  IRmsServer::GetNofAvailableDrives().

--*/
{
    HRESULT                         hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::GetNofAvailableDrives"), OLESTR(""));

    try {
        WsbAssertPointer(pdwNofDrives);
        *pdwNofDrives = 0;

        // Get the media set
        CComPtr<IRmsMediaSet>   pMediaSet;
        WsbAffirmHr(CreateObject(fromMediaSet, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));

        // Check if the media set is of fixed drives
        LONG mediaType;
        WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));

        if (RmsMediaFixed == mediaType) {
            // Count fixed drives
            // We take a shortcut here and just use number of drives that were counted
            //  during initialization. (FindCartridgeStatusById can give current state)
            *pdwNofDrives = m_HardDrivesUsed;
        } else {
            // Just use NTMS
            // TEMPORARY - We might want RmsNtms to use media-set info as well,
            //  in order not to count both tape and optical drives on a system that has both
            WsbAffirmHr(m_pNTMS->GetNofAvailableDrives(pdwNofDrives));
        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::GetNofAvailableDrives: Number of enabled drives is %lu\n"), *pdwNofDrives);

    WsbTraceOut(OLESTR("CRmsServer::GetNofAvailableDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::FindCartridgeStatusById( 
    IN REFGUID cartId,
    OUT DWORD* pdwStatus 
    )

/*++

Implements:

  IRmsServer::FindCartridgeStatusById().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IRmsCartridge>          pCart;
    CComPtr<IRmsCartridge>          pFindCart;

    WsbTraceIn(OLESTR("CRmsServer::FindCartridgeStatusById"), OLESTR("cartId = %ls"), WsbGuidAsString(cartId));

    try {
        WsbAssertPointer(pdwStatus);
        *pdwStatus = 0;

        // Try native RMS, Currently this should succeed only if media is a fixed drive
        WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                      IID_IRmsCartridge, (void **)&pFindCart));

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;

        WsbAffirmHr(pObject->SetObjectId(cartId));
        WsbAffirmHr(pObject->SetFindBy(RmsFindByObjectId));

        hr = m_pCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)&pCart);
        WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);
        if (WSB_E_NOTFOUND == hr) {
            hr = RMS_E_CARTRIDGE_NOT_FOUND;
        }

        // Search in RSM 
        if (S_OK != hr) {
            hr = IsNTMSInstalled();
            if (S_OK == hr) {
                hr = m_pNTMS->FindCartridge(cartId, &pCart);
                WsbAffirm(S_OK == hr || RMS_E_CARTRIDGE_NOT_FOUND == hr, hr);
            } else {
                switch(hr) {
                    case RMS_E_NOT_CONFIGURED_FOR_NTMS:
                    case RMS_E_NTMS_NOT_REGISTERED:
                        // Normal errors
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                        break;
                    default:
                        // Unexpected Error!
                        WsbThrow(hr);
                        break;
                }
            }
        }
        
        // if media found...
        if (S_OK == hr) {
            // Check media type
            LONG mediaType;
            WsbAffirmHr(pCart->GetType(&mediaType));

            if (RmsMediaFixed != mediaType) {
                // RSM media

                // set flags
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCart;
                WsbAffirmPointer(pObject);
                if (S_OK == pObject->IsEnabled()) {
                    (*pdwStatus) |= RMS_MEDIA_ENABLED;
                }

                if (S_OK == pCart->IsAvailable()) {
                    (*pdwStatus) |= RMS_MEDIA_AVAILABLE;
                }

                LONG lLocationType;
                GUID Dum1,Dum2;
                LONG lDum3, lDum4, lDum5, lDum6;
                BOOL bDum7;
                WsbAffirmHr(pCart->GetLocation(&lLocationType, &Dum1, &Dum2, &lDum3, &lDum4, 
                                &lDum5, &lDum6, &bDum7));
                switch (lLocationType) {
                    case RmsElementUnknown:
                    case RmsElementShelf:
                    case RmsElementOffSite:
                        // media is offline...
                        break;

                    default:
                        (*pdwStatus) |= RMS_MEDIA_ONLINE;
                        break;
                }

            } else {
                // Fixed drive - just try to access the volume and see if it's still valid
                // If so, set all flags, otherwise, set none
                CComPtr<IRmsDrive>      pDrive;
                CWsbBstrPtr             driveName;
                WCHAR                   fileSystemType[MAX_PATH];

                // Get drive name (volume name for fixed drives) to check
                WsbAffirmHr(pCart->GetDrive(&pDrive));
                CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pDrive;
                WsbAssertPointer(pDevice);
                WsbAffirmHr(pDevice->GetDeviceName(&driveName));

                if (GetVolumeInformation((WCHAR *)driveName, NULL, 0,
                    NULL, NULL, NULL, fileSystemType, MAX_PATH) ) {
                    if (0 == wcscmp(L"NTFS", fileSystemType)) {
                        // Volume is ready for migration - set all flags
                        (*pdwStatus) |= (RMS_MEDIA_ENABLED | RMS_MEDIA_ONLINE | RMS_MEDIA_AVAILABLE);
                    } else {
                        // Not NTFS - don't use that volume
                        WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: Fixed volume %ls is formatted to %ls\n"), 
                            (WCHAR *)driveName, fileSystemType);
                    }
                } else {
                    // Volume is not available - don't use it
                    WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: GetVolumeInformation returned %lu for Fixed volume %ls\n"), 
                        GetLastError(), (WCHAR *)driveName);
                }
            }

        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: Status bits are %lX\n"), *pdwStatus);

    WsbTraceOut(OLESTR("CRmsServer::FindCartridgeStatusById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::IsMultipleSidedMedia(
                IN REFGUID mediaSetId
                )
/*++

Implements:

    IRmsServer::IsMultipleSidedMedia

Notes:

    Currently, optical & DVD media types are reported as multiple sided media
    Tapes and fixed disks would fall in the default - one side media

--*/
{
    HRESULT hr = S_FALSE;
    WsbTraceIn(OLESTR("CRmsServer::IsMultipleSidedMedia"), OLESTR(""));

    try {
        // Multiple sided is currently determined if the media set is optical or not
        // This may change to include other media types of according two other characteristics
        CComPtr<IRmsMediaSet>   pMediaSet;
        LONG                    mediaType;                

        if (mediaSetId != GUID_NULL) {
            // if input media set is non-null, check this data-set. 
            WsbAffirmHr(CreateObject(mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet));
            WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));
            if ((RmsMediaOptical == mediaType) || (RmsMediaDVD == mediaType)) {
                hr = S_OK;
            }
        
        } else {
            // Otherwise, enumerate the collection seeking for any media set that might have two sides
            CComPtr<IWsbEnum>  pEnumSets;

            WsbAffirmHr(m_pMediaSets->Enum(&pEnumSets));
            WsbAssertPointer(pEnumSets);
            hr = pEnumSets->First(IID_IRmsMediaSet, (void **)&pMediaSet);
            while (S_OK == hr) {
                WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));
                if ((RmsMediaOptical == mediaType) || (RmsMediaDVD == mediaType)) {
                    hr = S_OK;
                    break;
                }

                hr = pEnumSets->Next(IID_IRmsMediaSet, (void **)&pMediaSet);
                if (hr == WSB_E_NOTFOUND) {
                    hr = S_FALSE;
                } else {
                    WsbAffirmHr(hr);
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::IsMultipleSidedMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}

HRESULT
CRmsServer::CheckSecondSide( 
    IN REFGUID firstSideId,
    OUT BOOL *pbValid,
    OUT GUID *pSecondSideId
    )
/*++

Implements:

  IRmsServer::CheckSecondSide().

Notes:

  It is not expected that this utility is called on a single sided media.
  If it does, it would return invalid second side for tape and would fail on fixed disks.

--*/
{
    HRESULT  hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::CheckSecondSide"), OLESTR(""));

    try {
        // just use NTMS (RmsServer collections are not used today!)
        WsbAffirmHr(m_pNTMS->CheckSecondSide(firstSideId, pbValid, pSecondSideId));

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::CheckSecondSide: Valid second side: %ls, id=<%ls>\n"), 
        WsbBoolAsString(*pbValid), WsbGuidAsString(*pSecondSideId));

    WsbTraceOut(OLESTR("CRmsServer::CheckSecondSide"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::GetMaxMediaCapacity(
    IN REFGUID fromMediaSet,
    OUT LONGLONG *pMaxCapacity
    )
/*++

Implements:

  IRmsServer::GetMaxMediaCapacity().

--*/
{
    HRESULT  hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::GetMaxMediaCapacity"), OLESTR(""));

    try {
        // just use NTMS 
        WsbAffirmHr(m_pNTMS->GetMaxMediaCapacity(fromMediaSet, pMaxCapacity));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::GetMaxMediaCapacity"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::CheckForMediaFailures(
    IN HRESULT hrFailure,
    IN IRmsCartridge *pCart,
    IN REFGUID prevSideId
    )
/*++

Implements:

  CRmsServer::CheckForMediaFailures().

Notes:

  This method is inetneded to check for media-related errors.
  If such an error is detected, the method calls an NTMS utility function 
  to disbale and eject the media.

  Currently, the method handles only format (of optical media) failure codes, 
  which are suspected as indicating a bad media.

--*/
{
    HRESULT  hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::CheckForMediaFailures"), OLESTR(""));

    try {
        BOOL bSecondSide = (prevSideId != GUID_NULL) ? TRUE : FALSE;

        switch (hrFailure) {

        case WSB_E_BAD_MEDIA:
        case WSB_E_IO_ERROR:
        case WSB_E_FORMAT_FAILED:
            if (! bSecondSide) {
                // Log an appropriate message in Event Viewer
    	        CWsbBstrPtr cartridgeName;
    		    WsbAffirmHr(pCart->GetName(&cartridgeName));

    			WsbLogEvent(RMS_MESSAGE_FORMAT_BAD_MEDIA, 0, NULL, (WCHAR *)cartridgeName, NULL);

                // Call NTMS to disbale and eject
                WsbAffirmHr(m_pNTMS->DisableAndEject(pCart));
            } else {
                // Cannot disbale & eject the media if the first side is already allocated
                // Instead, log a message that advises the user what can be done
                CComPtr<IRmsCartridge>  pFirstSideCart;
    	        CWsbBstrPtr firstSideName;

                WsbAffirmHr(FindCartridgeById(prevSideId, &pFirstSideCart));
    		    WsbAffirmHr(pFirstSideCart->GetName(&firstSideName));

    			WsbLogEvent(RMS_MESSAGE_FORMAT_BAD_SECOND_SIDE_MEDIA, 0, NULL, (WCHAR *)firstSideName, NULL);
            }
            break;

        default:
            // Do nothing
            break;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::CheckForMediaFailures"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmssinfo.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSInfo.h

Abstract:

    Declaration of the CRmsStorageInfo class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSINFO_
#define _RMSSINFO_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsStorageInfo

Class Description:

    A CRmsStorageInfo represents storage information about a Cartridge, Partition, or
    MediaSet.  Various statistics about an element are kept for an object of this
    type.  These include the number of times a Cartridge, or Partition has been put into
    the element or taken from (get) the element.

--*/

class CRmsStorageInfo :
    public CComDualImpl<IRmsStorageInfo, &IID_IRmsStorageInfo, &LIBID_RMSLib>,
    public CRmsComObject
{
public:
    CRmsStorageInfo();

// CRmsStorageInfo
public:

    HRESULT GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT Load(IStream* pStream);
    HRESULT Save(IStream* pStream, BOOL clearDirty);

    HRESULT CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test(USHORT *pPassed, USHORT *pFailed);

// IRmsStorageInfo
public:
    STDMETHOD(GetMountCounters)(LONG *pReads, LONG *pWrites);

    STDMETHOD(GetBytesRead2)(LONG *pReadHi, LONG *pReadLo);
    STDMETHOD(GetBytesRead)(LONGLONG *pRead);
    STDMETHOD(SetBytesRead2)(LONG readHi, LONG readLo);
    STDMETHOD(SetBytesRead)(LONGLONG read);
    STDMETHOD(IncrementBytesRead)(LONG val);

    STDMETHOD(GetBytesWritten2)(LONG *pWriteHi, LONG *pWriteLo);
    STDMETHOD(GetBytesWritten)(LONGLONG *pWritten);
    STDMETHOD(SetBytesWritten2)(LONG writeHi, LONG writeLo);
    STDMETHOD(SetBytesWritten)(LONGLONG written);
    STDMETHOD(IncrementBytesWritten)(LONG val);

    STDMETHOD(GetCapacity2)(LONG *pCapHi, LONG *pCapLo);
    STDMETHOD(GetCapacity)(LONGLONG *pCap);
    STDMETHOD(GetUsedSpace2)(LONG *pUsedHi, LONG *pUsedLo);
    STDMETHOD(GetUsedSpace)(LONGLONG *pUsed);
    STDMETHOD(GetLargestFreeSpace2)(LONG *pFreeHi, LONG *pFreeLo);
    STDMETHOD(GetLargestFreeSpace)(LONGLONG *pFree);

    STDMETHOD(SetCapacity)(IN LONGLONG cap);
    STDMETHOD(SetUsedSpace)(IN LONGLONG used);
    STDMETHOD(SetFreeSpace)(IN LONGLONG free);

    STDMETHOD(ResetCounters)(void);
    // STDMETHOD(ResetAllCounters)(void) = 0;

    STDMETHOD(GetResetCounterTimestamp)(DATE *pDate);
    STDMETHOD(GetLastReadTimestamp)(DATE *pDate);
    STDMETHOD(GetLastWriteTimestamp)(DATE *pDate);
    STDMETHOD(GetCreatedTimestamp)(DATE *pDate);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//

protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_readMountCounter;     // A resetable counter holding
                                            //   the number of times the storage object
                                            //   has been mounted for read access.
    LONG            m_writeMountCounter;    // A resetable counter holding
                                            //   the number of times the storage object
                                            //   has been mounted for write access.
    LONGLONG        m_bytesWrittenCounter;  // Amount of data written to a storage
                                            //   object.
                                            //   Note: For some devices this has to be
                                            //   provided by the application.
    LONGLONG        m_bytesReadCounter;     // Amount of data read from a storage
                                            //   object.
                                            //   Note: For some devices this has to be
                                            //   provided by the application.
    LONGLONG        m_capacity;             // The total capacity, in bytes, of the
                                            //   storage object.  This is a best
                                            //   guess for tape media.  For media, the
                                            //   value is usually provided by the device driver.
    LONGLONG        m_usedSpace;            // A calculated value that represents the
                                            //   effective used space in the storage
                                            //   object, in bytes.  It is not necessarily
                                            //   equal to the difference between the
                                            //   capacity and largest free space.  For
                                            //   example, compressible media can effectively
                                            //   hold significantly more data that non-compressible
                                            //   media.  In this case the free space is a
                                            //   function of both compression ratio of the data
                                            //   and the number of bytes written to the media.
                                            //   Deleted files must be accounted for.
    LONGLONG        m_largestFreeSpace;     // Largest usable free space in the
                                            //   storage object, in bytes.  For media,
                                            //   the value is usually provided
                                            //   by the device driver. Negative numbers
                                            //   indicate last known value for free space.
    DATE            m_resetCounterTimestamp;// The date the counters were reset.
    DATE            m_lastReadTimestamp;    // The date of last access for read.
    DATE            m_lastWriteTimestamp;   // The date of last access of write.
    DATE            m_createdTimestamp;     // The date the storage object was created.
};

#endif // _RMSSINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS    WSB_TRACE_BIT_RMS

#include "Rms.h"

// extern CComPtr<IWsbTrace> g_pTrace; 

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\types\rms\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\rmsint.h
    -del $(PASS0_HEADERDIR)\rmslib.h
    -del $(MIDL_UUIDDIR)\rmsint_i.c
    -del $(MIDL_UUIDDIR)\rmslib_i.c
    -del $(PASS0_SOURCEDIR)\rmsint_p.c
    -del $(PASS0_SOURCEDIR)\dlldata.c
    -del $(TLBDIR)\rmslib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rms\server\rmstmplt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsTmplt.h

Abstract:

    Declaration of the CRmsTemplate class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSTMPLT_
#define _RMSTMPLT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"
/*++

Class Name:

    CRmsTemplate

Class Description:

    A CRmsTemplate represents...

--*/

class CRmsTemplate :
    public CComDualImpl<IRmsTemplate, &IID_IRmsTemplate, &LIBID_RMSLib>,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CRmsTemplate,&CLSID_CRmsTemplate>
{
public:
    CRmsTemplate() {}
BEGIN_COM_MAP(CRmsTemplate)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRmsTemplate)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
    //DECLARE_NOT_AGGREGATABLE(CRmsTemplate)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

DECLARE_REGISTRY_RESOURCEID(IDR_RmsTemplate)

// ISupportsErrorInfo
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRmsTemplate
public:
};

#endif // _RMSTMPLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\types\mover\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\mvrint.h
    -del $(PASS0_HEADERDIR)\mvrlib.h
    -del $(MIDL_UUIDDIR)\mvrint_i.c
    -del $(MIDL_UUIDDIR)\mvrlib_i.c
    -del $(PASS0_SOURCEDIR)\mvrint_p.c
    -del $(PASS0_SOURCEDIR)\dlldata.c
    -del $(MIDL_TLBDIR)\mvrlib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\rstore\rstore.cpp ===
// Restore Remote Storage Engine database from backup directory
//
// Usage: RsTore backup_dir
//         backup_dir  - location of backup directory
//  The database is restored to the current directory

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

#include "esent.h"


//  Local data
WCHAR *backup_dir;
WCHAR *usage = L"RsTore <backup-directory>";

//  Local functions
HRESULT FileCount(WCHAR* Pattern, LONG* pCount);
HRESULT parseCommand(int argc, wchar_t *argv[]);

#define WsbCatch(hr)                    \
    catch(HRESULT catchHr) {            \
        hr = catchHr;                   \
    }


//  FileCount - count files matching the pattern
HRESULT FileCount(WCHAR* Pattern, LONG* pCount)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    HRESULT           hr = S_OK;
    int               nCount = 0;
    int               nSkipped = 0;

    try {
        hFind =  FindFirstFile(Pattern, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            err = GetLastError();
            throw(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                //  Don't count system files (such as "." and "..")
                nSkipped++;
            } else {
                nCount++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                throw(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    *pCount = nCount;
    return(hr);
}

//  parseCommand - Parse the command line
HRESULT parseCommand(int argc, wchar_t *argv[])
{
    HRESULT     hr = E_FAIL;

    try {
        int  i;

        // There should be cmd name + one parameters.
        if (argc != 2) {
            throw (E_FAIL);
        }

        for (i = 1; i < argc; i++) {
            if (WCHAR('-') == argv[i][0]) {
                throw(E_FAIL);

            } else {
                backup_dir = argv[i];
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}


//  wmain - Main function
extern "C"
int _cdecl wmain(int argc, wchar_t *argv[]) 
{
    HRESULT                     hr = S_OK;

    try {
        hr = parseCommand(argc, argv);
        if (!SUCCEEDED(hr)) {
            printf("Command line is incorrect\n%ls\n", usage);
            return -1;
        }

        try {
            PCHAR          cbdir = NULL;
            LONG           count;
            ULONG          size;
            JET_ERR        jstat;
            WCHAR         *pattern;
            
            //
            // Allocate memory for the string
            //
            size = wcslen(backup_dir) + 20;

            pattern = new WCHAR[size];
 
            if (pattern == NULL) {
                throw(E_OUTOFMEMORY);
            }                                     
            //  Check that there's a HSM DB to restore
            wcscpy(pattern, backup_dir);
            wcscat(pattern, L"\\*.jet");

            hr = FileCount(pattern, &count);
        
            delete pattern;
            pattern = 0;

            if (S_OK != hr || count == 0) {
                printf("No Remote Storage databases were found in the given\n");
                printf("directory: %ls\n", static_cast<WCHAR*>(backup_dir));
                printf("Please enter the directory containing the backup files.\n");
                throw(E_FAIL);
            }

            //  Check that the current directory is empty
            pattern = L".\\*";
            hr = FileCount(pattern, &count);
            if (S_OK != hr || count != 0) {
                printf("The current directory is not empty\n");
                printf("The database restore can only be done to an empty directory.\n");
                throw(E_FAIL);
            }

            //  Set the log size to avoid an error JetRestore
            jstat = JetSetSystemParameter(0, 0, JET_paramLogFileSize, 
                    64, NULL);
            if (JET_errSuccess != jstat) {
                printf("JetSetSystemParameter(JET_paramLogFileSize) failed, JET error = %ld\n", (LONG)jstat);
                throw(E_FAIL);
            }

            //  Try the restore
            size_t tempsize = wcstombs(0, backup_dir, 0);
            if (tempsize == (size_t)-1) {
                throw(E_INVALIDARG);
            }
            size = tempsize + 1;
            cbdir = new CHAR[size];
            if (cbdir == NULL) {
                throw(E_OUTOFMEMORY);
            }
            wcstombs(cbdir, backup_dir, size);

            jstat = JetRestore(cbdir, NULL);

            if (JET_errSuccess == jstat) {
                printf("Restore succeeded\n");
                hr = S_OK;
            } else {
                printf("Restore failed, JET error = %ld\n", (LONG)jstat);
                hr = E_FAIL;
            }

            delete cbdir;
            cbdir = 0;
        } WsbCatch(hr);
    
    } WsbCatch(hr);

    if (SUCCEEDED(hr)) {
        return(0);
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

// MIDL Generated proxy stub generates warning c4047 - kill these
#include "dlldata.c"
#pragma warning( disable : 4047 )
#include "wsbint_p.c"
#pragma warning( default : 4047 )

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\types\wsb\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\wsberror.h
    -del $(PASS0_HEADERDIR)\wsbdef.h
    -del $(MIDL_UUIDDIR)\wsbint.h
    -del $(MIDL_UUIDDIR)\wsblib.h
    -del /q $(PASS0_SOURCEDIR)\*
    -del $(MIDL_TLBDIR)\mvrlib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\makefile.inc ===
$(O)\wsb.res: wsb.rgs                \
              wsbguid.rgs            \
              wsbienum.rgs           \
              wsbocltn.rgs           \
              wsbstrg.rgs            \
              wsbtrace.rgs           \
              ..\inc\$(O)\wsblib.tlb \

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wsb.rc
//
#define IDS_WSBCOLLECTABLE_DESC         1
#define IDS_WSBSTRING_DESC              1
#define IDS_WSBCOLLECTION_DESC          2
#define IDS_WSBORDEREDCOLLECTION_DESC   2
#define IDR_CWsbGuid                    2
#define IDS_WSBENUMUNKNOWN_DESC         3
#define IDS_WSBINDEXEDENUM_DESC         3
#define IDR_CWsbIndexedEnum             3
#define IDS_WSBGUID_DESC                4
#define IDR_CWsbOrderedCollection       5
#define IDR_CWsbString                  7
#define IDS_WSBPERSISTABLEBASE_DESC     10
#define IDS_WSBCOLLECTABLEBASE_DESC     11
#define IDR_CWsbTrace                   19
#define IDS_WSBTRACE_DESC               19
#define IDR_Wsb                         21
#define IDS_WSB_DESC                    21
#define IDS_WSB_FT_TYPE_YEAR            101
#define IDS_WSB_FT_TYPE_MONTH           102
#define IDS_WSB_FT_TYPE_WEEK            103
#define IDS_WSB_FT_TYPE_DAY             104
#define IDS_WSB_FT_TYPE_HOUR            105
#define IDS_WSB_FT_TYPE_MINUTE          106
#define IDS_WSB_FT_TYPE_SECOND          107
#define IDS_WSB_BYTES                   110
#define IDS_WSB_ORDERKB                 111
#define IDS_WSB_ORDERMB                 112
#define IDS_WSB_ORDERGB                 113
#define IDS_WSB_ORDERTB                 114
#define IDS_WSB_ORDERPB                 115
#define IDS_WSB_ORDEREB                 116
#define IDS_WSB_ERROR_HEADER            117
#define IDS_WSBPERSISTABLE_DEF_FILE     201
#define IDS_WSBSVC_DESC                 202
#define IDS_PRODUCT_NAME                203

/***
    The range of 1024 - 2047 is reserved for 
    HSM global string identifiers, defined in rsstrdef.h 
***/

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsb.cpp ===
// Wsb.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for Wsb.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          Wsb_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Wsbps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "wsbcltn.h"
#include "wsbenum.h"
#include "wsbguid.h"
#include "wsbstrg.h"
#include "wsbtrc.h"

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CWsbGuid, CWsbGuid)
    OBJECT_ENTRY(CLSID_CWsbIndexedEnum, CWsbIndexedEnum)
    OBJECT_ENTRY(CLSID_CWsbOrderedCollection, CWsbOrderedCollection)
    OBJECT_ENTRY(CLSID_CWsbString, CWsbString)
    OBJECT_ENTRY(CLSID_CWsbTrace, CWsbTrace)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        WsbTraceInit();
        break;

    case DLL_THREAD_DETACH :
        WsbTraceCleanupThread();
        break;

    case DLL_PROCESS_DETACH:
        WsbTraceCleanupThread();
        WsbTraceTerminate();
        _Module.Term();
        break;

    default:
        break;

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
#ifdef _MERGE_PROXYSTUB
    hr = PrxDllRegisterServer();
    if( FAILED( hr ) )
        return hr;
#endif

#if 0
    // Add service entries
    hr = _Module.UpdateRegistryFromResourceS(IDR_Wsb, TRUE);
    if( FAILED( hr ) )
        return hr;
#endif

    hr = WsbRegisterEventLogSource( WSB_LOG_APP, WSB_LOG_SOURCE_NAME,
        WSB_LOG_SVC_CATCOUNT, WSB_LOG_SVC_CATFILE, WSB_LOG_SVC_MSGFILES );
    if( FAILED( hr ) ) return( hr );

    // registers object, typelib and all interfaces in typelib
    CoInitialize( 0 );
    hr = _Module.RegisterServer( FALSE );
    CoUninitialize( );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

#if 0
    // Remove service entries
    _Module.UpdateRegistryFromResourceS(IDR_Wsb, FALSE);
#endif

    WsbUnregisterEventLogSource( WSB_LOG_APP, WSB_LOG_SOURCE_NAME );

    hr =  CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_PLATFORM
#include "wsb.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbbool.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbbool.cpp

Abstract:

    This component is an object representations of the BOOL standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbbool.h"


HRESULT
CWsbBool::CompareToBool(
    IN BOOL value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbBool::CompareToBool

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbBool::CompareToBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    // Compare.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbBool::CompareToBool"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbBool::CompareToIBool(
    IN IWsbBool* pBool,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbBool::CompareToIBool

--*/
{
    HRESULT     hr = E_FAIL;
    BOOL        value;

    WsbTraceIn(OLESTR("CWsbBool::CompareToIBool"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pBool, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pBool->GetBool(&value));
        hr = CompareToBool(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::CompareToIBool"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbBool::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbBool*   pBool;

    WsbTraceIn(OLESTR("CWsbBool::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbBool, (void**) &pBool));

        hr = CompareToIBool(pBool, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbBool::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = FALSE;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbBool::GetBool(
    OUT BOOL* pValue
    )

/*++

Implements:

  IWsbBool::GetBool

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetBool"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetBool"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(m_value));
    
    return(hr);
}


HRESULT
CWsbBool::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbBool;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbBool::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(BOOL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbBool::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(m_value));

    return(hr);
}


HRESULT
CWsbBool::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbBool::SetBool(
    IN BOOL value
    )

/*++

Implements:

  IWsbBool::SetBool

--*/
{
    WsbTraceIn(OLESTR("CWsbBool::SetBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbBool::SetBool"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbBool::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbBool>       pBool1;
    CComPtr<IWsbBool>       pBool2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    BOOL                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbBool::Test"), OLESTR(""));

    try {

        // Get the pBool interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbBool*) this)->QueryInterface(IID_IWsbBool, (void**) &pBool1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pBool1->SetBool(TRUE));
                WsbAffirmHr(pBool1->GetBool(&value));
                WsbAffirm(value == TRUE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbBool, NULL, CLSCTX_ALL, IID_IWsbBool, (void**) &pBool2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool2->GetBool(&value));
                    WsbAffirm(value == FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(TRUE));
                    WsbAffirm(pBool1->IsEqual(pBool2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm(pBool1->IsEqual(pBool2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(FALSE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(FALSE));
                    WsbAffirmHr(pBool2->SetBool(TRUE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pBool2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pBool2->SetBool(TRUE));
                        WsbAffirm(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbBool.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirm(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pBool1->SetBool(FALSE));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbBool.tst"), 0));
                        WsbAffirm(pBool1->CompareToBool(TRUE, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbaccnt.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbAccnt.cpp

Abstract:

    This is the implementation of account helper functions.

Author:

    Rohde Wakefield    [rohde]   10-Apr-1997

Revision History:

--*/


#include "stdafx.h"
#include "lm.h"



HRESULT
WsbGetAccountDomainName(
    OLECHAR * szDomainName,
    DWORD     cSize
    )
/*++

Routine Description:

    This routine is called to find out what domain the current process's
    account belongs to. An array of cSize wide chars is required. 
    This is recommended to be MAX_COMPUTERNAMELENGTH.

Arguments:

    hInst - HINSTANCE of this dll.

    ulReason - Context of the attaching/detaching

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr     = S_OK;
    HANDLE  hToken = 0;

    try {

        if( !OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) ) {
        
            //
            // Ensure failure was because no token existed
            //

            WsbAffirm( GetLastError() == ERROR_NO_TOKEN, E_FAIL );
        
            //
            // attempt to open the process token, since no thread token
            // exists
            //
        
            WsbAffirmStatus( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) );

        }
        
        DWORD dw;
        BYTE buf[ 512 ];
        TOKEN_USER * pTokenUser = (TOKEN_USER*)buf;
        WsbAffirmStatus( GetTokenInformation( hToken, TokenUser, buf, 512, &dw ) );
        
        WCHAR szName[ 256 ];
        DWORD cName = 256; 
        DWORD cDomain = cSize;
        SID_NAME_USE snu;
        WsbAffirmStatus( LookupAccountSid( 0, pTokenUser->User.Sid, szName, &cName, szDomainName, &cDomain, &snu ) );

    } WsbCatch( hr );

    if( hToken ) {

        CloseHandle( hToken );

    }

    return( hr );
}

HRESULT
WsbGetServiceInfo(
    IN  GUID            guidApp,
    OUT OLECHAR **      pszServiceName, OPTIONAL
    OUT OLECHAR **      pszAccountName  OPTIONAL
    )
/*++

Routine Description:

    This function retrieves the name of the service, as well as the
    account a COM service runs under. The returned strings are 
    WsbAlloc'd so they must be freed by the caller.

Arguments:

    guidApp - app id of the service to get the account of.

    pszServiceName - the name of the service.

    pszAccountName - the full account name to set on the account.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;


    try {

        CWsbStringPtr serviceName;
        CWsbStringPtr accountName;

        if( pszServiceName )  *pszServiceName = 0;
        if( pszAccountName )  *pszAccountName = 0;

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( guidApp ) );

        //
        // Get the name of the service
        //

        if( pszServiceName ) {

            serviceName.Realloc( 255 );
            WsbAffirmHr( WsbGetRegistryValueString( 0, regPath, L"LocalService", serviceName, 255, 0 ) );

        }

        //
        // Get the account for it to run under
        //

        if( pszAccountName ) {

            accountName.Realloc( 255 );
            hr = WsbGetRegistryValueString( 0, regPath, L"RunAs", accountName, 255, 0 ) ;

            if( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hr ) {

                WsbGetLocalSystemName( accountName );
                hr = S_OK;

            } else {

                WsbAffirmHr( hr );

            }


        }

        //
        // Wait till end to do final assignments in case error
        // occurs, in which case smart pointers automatically 
        // cleanup for us, and OUT params are not set.
        //

        if( pszServiceName ) serviceName.GiveTo( pszServiceName );
        if( pszAccountName ) accountName.GiveTo( pszAccountName );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
WsbGetComputerName(
    OUT CWsbStringPtr & String
    )
/*++

Routine Description:

    This routine retrieves the name of the computer into a CWsbStringPtr.

Arguments:

    String - String object to fill in with the name.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Force allocation of enough characters and call Win32
        //

        DWORD cbName = MAX_COMPUTERNAME_LENGTH + 1;
        WsbAffirmHr( String.Realloc( cbName ) );
        WsbAffirmStatus( GetComputerName( String, &cbName ) );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
WsbGetLocalSystemName(
    OUT CWsbStringPtr & String
    )
/*++

Routine Description:

    This routine retrieves the name of the account for LocalSystem.

Arguments:

    String - String object to fill in with the name.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // For now, hardcode. May need to lookup name of
        // SECURITY_LOCAL_SYSTEM_RID
        //

        String = L"LocalSystem";

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbbool.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbbool.h

Abstract:

    This component is an object representations of the BOOL standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBBOOL_
#define _WSBBOOL_


/*++

Class Name:
    
    CWsbBool

Class Description:

    An object representations of the BOOL standard type. It
    is both persistable and collectable.

--*/

class CWsbBool : 
    public CWsbObject,
    public IWsbBool,
    public CComCoClass<CWsbBool,&CLSID_CWsbBool>
{
public:
    CWsbBool() {}
BEGIN_COM_MAP(CWsbBool)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbBool)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbBool)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbBool)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbBool
public:
    STDMETHOD(CompareToBool)(BOOL value, SHORT* pResult);
    STDMETHOD(CompareToIBool)(IWsbBool* pBool, SHORT* pResult);
    STDMETHOD(GetBool)(BOOL* pValue);
    STDMETHOD(SetBool)(BOOL value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    BOOL            m_value;
};

#endif // _WSBBOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbcltbl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbcltbl.cpp

Abstract:

    Abstract classes that provide methods that allow the derived objects to
    be stored in collections.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"


HRESULT
CWsbObject::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
     return(CWsbPersistStream::FinalConstruct());
}

    

void
CWsbObject::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbObject::CompareTo(
    IN IUnknown* pObject,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::Compare().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       result = 0;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbObject::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pObject != NULL, E_POINTER);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));

        // Check it's values.
        if (pCollectable == ((IWsbCollectable*) this)) {
            hr = S_OK;
            result = 0;
        } else {
            hr = S_FALSE;
            result = 1;
        }

        // If they want the value back, then return it to them.
        if (0 != pResult) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbObject::CompareTo"), OLESTR("hr = <%ls>, value = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}



HRESULT
CWsbObject::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbObject::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CWsbObject::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


// ************* CWsbCollectable ************


HRESULT
CWsbCollectable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
     return(CWsbPersistable::FinalConstruct());
}

    

void
CWsbCollectable::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    CWsbPersistable::FinalRelease();
}


HRESULT
CWsbCollectable::CompareTo(
    IN IUnknown* pObject,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::Compare().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       result = 0;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbCollectable::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pObject != NULL, E_POINTER);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));

        // Check it's values.
        if (pCollectable == ((IWsbCollectable*) this)) {
            hr = S_OK;
            result = 0;
        } else {
            hr = S_FALSE;
//          if (pCollectable > ((IWsbCollectable*) this)) {
//              result = -1;
//          } else {
                result = 1;
//          }
        }

        // If they want the value back, then return it to them.
        if (0 != pResult) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollectable::CompareTo"), OLESTR("hr = <%ls>, value = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}



HRESULT
CWsbCollectable::IsEqual(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollectable::IsEqual"), OLESTR(""));

    hr = CompareTo(pCollectable, NULL);

    WsbTraceOut(OLESTR("CWsbCollectable::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbbstrg.cpp ===
#include "stdafx.h"

#include "wsb.h"
#include "wsbbstrg.h"

// {C03D4862-70D7-11d1-994F-0060976A546D}
static const GUID BstrPtrGuid = 
{ 0xc03d4862, 0x70d7, 0x11d1, { 0x99, 0x4f, 0x0, 0x60, 0x97, 0x6a, 0x54, 0x6d } };

CWsbBstrPtr::CWsbBstrPtr()
{
    HRESULT     hr = S_OK;

    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);
}

CWsbBstrPtr::CWsbBstrPtr(const CHAR* pChar)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pChar;
}

CWsbBstrPtr::CWsbBstrPtr(const WCHAR* pWchar)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pWchar;
}


CWsbBstrPtr::CWsbBstrPtr(REFGUID rguid)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = rguid;
}

CWsbBstrPtr::CWsbBstrPtr(const CWsbBstrPtr& pString)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pString;
}

CWsbBstrPtr::~CWsbBstrPtr()
{
    WSB_OBJECT_SUB(BstrPtrGuid, this);
    Free();
}

CWsbBstrPtr::operator BSTR()
{
    return(m_pString);
}

WCHAR& CWsbBstrPtr::operator *()
{
    _ASSERTE(0 != m_pString);
    return(*m_pString);
}

WCHAR** CWsbBstrPtr::operator &()
{
    //  This assert only allows the caller to get the address of our pointer
    //  if we don't have anything allocated.
    _ASSERTE(0 == m_pString);
    
    return(&m_pString);
}

WCHAR& CWsbBstrPtr::operator [](const int i)
{
    _ASSERTE(0 != m_pString);
    return(m_pString[i]);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const CHAR* pChar)
{
    HRESULT     hr = S_OK;
    ULONG       length;
    int         count;

    try {
    
        // Are they setting it to something?
        if (0 != pChar) {
        
            // Otherwise, see if our current buffer is big enough.
            //
            // NOTE: With multibyte characters, we may be getting a bigger
            // buffer than we need, but the call to return the accurate
            // size is not ANSI.
            length = strlen(pChar);
            WsbAffirmHr(Realloc(length));
            WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

            // Copy the data (and convert to wide characters)
            count = mbstowcs(m_pString, pChar, length + 1);
            WsbAffirm((count != -1), E_FAIL);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;
    ULONG       length;

    try {
    
        // Are they setting it to something?
        if (0 != pWchar) {
        
            // Otherwise, see if our current buffer is big enough.
            length = wcslen(pWchar);
            WsbAssertHr(Realloc(length));

            // Copy the data (and convert to wide characters)
            wcscpy(m_pString, pWchar);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}


CWsbBstrPtr& CWsbBstrPtr::operator =(REFGUID rguid)
{
    HRESULT hr = S_OK;

    try {
    
        // Otherwise, see if our current buffer is big enough.
        WsbAssertHr(Realloc(WSB_GUID_STRING_SIZE));

        // Copy the data (and convert to wide characters)
        WsbStringFromGuid(rguid, m_pString);

    } WsbCatch(hr);

    return (*this);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const CWsbBstrPtr& pString)
{
    *this = pString.m_pString;

    return(*this);
}

BOOL CWsbBstrPtr::operator !()
{
    return((0 == m_pString) ? TRUE : FALSE);
}

HRESULT CWsbBstrPtr::Alloc(ULONG size)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 == m_pString, E_UNEXPECTED);

//      m_pString = (WCHAR*) SysAllocStringLen(0, size);
        m_pString = (WCHAR*) WsbAllocStringLen(0, size);
        WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

        // Make sure we always have a valid string so bad things don't happen.
        *m_pString = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const CHAR* pChar)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     tmpString = pChar;

    hr = Append(tmpString);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const WCHAR* pWchar)
{
    HRESULT         hr = S_OK;
    ULONG           length = 0;
    ULONG           appendLength;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        appendLength = wcslen(pWchar);
        WsbAffirm(0 != appendLength, S_OK);

        // 
        if (0 != m_pString) {
            length = wcslen(m_pString);
        }

        // Make sure the buffer is big enough.
        WsbAffirmHr(Realloc(length + appendLength));
        
        // Append the string.
        wcscat(m_pString, pWchar);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const CWsbBstrPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Append(pString.m_pString);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(CHAR** ppChar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppChar, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(CHAR** ppChar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    CHAR*       tmpString = 0;

    try {
    

        // Allocate a buffer big enough to hold their string.
        //
        // NOTE: With multibyte characters, we may be getting a bigger
        // buffer than we need, but the call to return the accurate
        // size is not ANSI.
        if (m_pString != 0) {
            length = wcstombs(0, m_pString, 0);
        }

        if (bufferSize == 0) {
            tmpString = (CHAR*) WsbRealloc(*ppChar, (length + 1) * sizeof(CHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppChar == 0) {
                tmpString = (CHAR*) WsbRealloc(*ppChar, (bufferSize + 1) * sizeof(CHAR));
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppChar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            WsbAffirm (-1 != wcstombs(*ppChar, m_pString, length + 1), E_FAIL);
        } else {
            **ppChar = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(WCHAR** ppWchar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppWchar, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(WCHAR** ppWchar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    WCHAR*      tmpString = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            tmpString = (WCHAR*) WsbRealloc(*ppWchar, (length + 1) * sizeof(WCHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (*ppWchar == 0) {
                tmpString = (WCHAR*) WsbRealloc(*ppWchar, (bufferSize + 1) * sizeof(WCHAR));
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppWchar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            wcscpy(*ppWchar, m_pString);
        } else {
            **ppWchar = 0;
        }


    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(GUID * pguid)
{
    HRESULT hr = S_OK;

    hr = WsbGuidFromString(m_pString, pguid);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyToBstr(BSTR* pBstr)
{
    HRESULT     hr = S_OK;

    hr = CopyToBstr(pBstr, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyToBstr(BSTR* pBstr, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            if (0 == *pBstr) {
//              *pBstr = SysAllocString(m_pString);
                *pBstr = WsbAllocString(m_pString);
            } else {
//              WsbAffirm(SysReAllocString(pBstr, m_pString), E_OUTOFMEMORY);
                WsbAffirm(WsbReallocString(pBstr, m_pString), E_OUTOFMEMORY);
            }
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (0 == *pBstr) {
//              *pBstr = SysAllocStringLen(m_pString, bufferSize);
                *pBstr = WsbAllocStringLen(m_pString, bufferSize);
            } else {
//              WsbAffirm(SysReAllocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
                WsbAffirm(WsbReallocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
            }
        }

        WsbAffirm(0 != pBstr, E_OUTOFMEMORY);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId)
{
    HRESULT         hr = S_FALSE;
    CWsbBstrPtr dest;

    try {
    
        WsbAssert(0 != pMatchId, E_POINTER);

        // Initialize the return value.
        *pMatchId = 0;

        // Check each resource string mention and see if it is the same as
        // the string provided.
        for (ULONG testId = startId; (testId < (startId + idsToCheck)) && (*pMatchId == 0); testId++) {

            WsbAffirmHr(dest.LoadFromRsc(_Module.m_hInst, testId));

            if (wcscmp(dest, m_pString) == 0) {
                *pMatchId = testId;
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Free(void)
{
    HRESULT     hr = S_OK;

    try {

        if ((0 != m_pString) && (0 == m_givenSize)) {
//          SysFreeString(m_pString);
            WsbFreeString(m_pString);
            m_pString = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::GetSize(ULONG* pSize)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        if (0 == m_pString) {
            *pSize = 0;
        } else if (0 != m_givenSize) {
            *pSize = m_givenSize;
        } else {
            *pSize = SysStringLen(m_pString);
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::GiveTo(BSTR* pBstr)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pBstr, E_POINTER);

        // Given the our string buffer, and forget about it.
        *pBstr = m_pString;
        m_pString = 0;
        m_givenSize = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::LoadFromRsc(HINSTANCE instance, ULONG id)
{
    HRESULT     hr = S_OK;
    HRSRC       resource;
    ULONG       stringSize;

    try {

        // Find the resource requested. This requires converting the resource
        // identifier into a string.
        //
        // NOTE: Strings are not number individually, but in groups of 16!! This throws
        // off the latter size calculation, and some other strategy might be better
        // here (e.g. load to a fixed size and then allocate again if too small).
        resource = FindResource(instance, MAKEINTRESOURCE((id/16) + 1), RT_STRING);
        WsbAffirm(resource != 0, E_FAIL);

        // How big is the string?
        stringSize = SizeofResource(instance, resource);
        WsbAffirm(0 != stringSize, E_FAIL);
                  
        // Get the right sized buffer.
        WsbAffirmHr(Realloc(stringSize / sizeof(WCHAR)));

        // Load the string into the buffer.
        WsbAffirm(LoadString(instance, id, m_pString, (stringSize / sizeof(WCHAR)) + 1) != 0, E_FAIL);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const CHAR* pChar) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     tmpString = pChar;

    hr = Prepend(tmpString);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const WCHAR* pWchar) {
    HRESULT         hr = S_OK;
    ULONG           length;
    ULONG           prependLength;
    ULONG           i, j;

    try {
   
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        prependLength = wcslen(pWchar);
        WsbAffirm(0 != prependLength, S_OK);

        if (0 != m_pString) {
            length = wcslen(m_pString);
        } else {
            // Prepend code will work as long as we have a null string and not a null pointer...
            // Next Realloc statement will make it happen...
            length = 0;
        }

        WsbAffirmHr(Realloc(length + prependLength));
        
        // First move the existing string down in the buffer.
        for (i = length + 1, j = length + prependLength; i > 0; i--, j--) {
            m_pString[j] = m_pString[i - 1];
        }

        // Now prepend the string (except for the null)
        for (i = 0; i < prependLength; i++) {
            m_pString[i] = pWchar[i];
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const CWsbBstrPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Prepend(pString.m_pString);

    return(hr);
}

HRESULT CWsbBstrPtr::Realloc(ULONG size)
{
    HRESULT     hr = S_OK;
    ULONG       currentSize = 0;
    BOOL        bigEnough = FALSE;
    OLECHAR*    pString;

    try {
        
        // We want to try to get a buffer of the size indicated.
        // If the buffer is already bigger than the size needed, then
        // don't do anything.
        if (0 != m_pString) {
            WsbAffirmHr(GetSize(&currentSize));

            if (currentSize >= size) {
                bigEnough = TRUE;
            }
        }

        // Reallocate the buffer if we need a bigger one.
        if (!bigEnough) {
            
            // If we were given this buffer, then we can't reallocate it.
            WsbAssert(0 == m_givenSize, E_UNEXPECTED);

            // The realloc won't handle it properly if no BSTR has ever been allocated, so
            // use Alloc() in that case.
            if (0 == m_pString) {
                WsbAffirmHr(Alloc(size));       
            } else {

                // According to Bounds checker, Realloc doesn't work the way we expected, so
                // do the steps by hand.
                pString = m_pString;
                m_pString = 0;
                WsbAffirmHr(Alloc(size));       
                wcsncpy(m_pString, pString, currentSize + 1);
//              SysFreeString(pString);
                WsbFreeString(pString);
//              WsbAffirm(SysReAllocStringLen(&m_pString, 0, size + 1), E_OUTOFMEMORY);
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::TakeFrom(BSTR bstr, ULONG bufferSize)
{
    HRESULT         hr = S_OK;

    try {
        
        // Clear out any previously "taken" string.
        if (0 != m_givenSize) {
            m_pString = 0;
            m_givenSize = 0;
        }

        // If the given buffer is null, then we are responsible for allocating it.
        if (0 == bstr) {
            if (0 != bufferSize) {
                WsbAffirmHr(Realloc(bufferSize));
            }
        }
        
        // Otherwise, we need to get rid of any buffer we had and use the one indicated.
        else {
            if (0 != m_pString) {
                WsbAffirmHr(Free());
            }
            m_pString = bstr;

            if (0 != bufferSize) {
                m_givenSize = bufferSize;
            }
        }

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbcltn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbcltn.cpp

Abstract:


    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbcltn.h"



HRESULT
CWsbCollection::Contains(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Contains().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pOut;
    
    WsbTraceIn(OLESTR("CWsbCollection::Contains"), OLESTR(""));

    hr = Find(pCollectable, IID_IWsbCollectable, (void**) &pOut);

    if (hr == WSB_E_NOTFOUND) {
        hr = S_FALSE;
    }
    
    WsbTraceOut(OLESTR("CWsbCollection::Contains"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        m_bCritSecCreated = FALSE;
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());
        m_entries = 0;
        WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_CritSec, 0));
        m_bCritSecCreated = TRUE;
    } WsbCatch(hr);

    return(hr);
}
    

void
CWsbCollection::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    if (m_bCritSecCreated) {
        DeleteCriticalSection(&m_CritSec);
    }
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbCollection::Find(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Find().

--*/
{
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;
    BOOL                        matched = FALSE;

    WsbTraceIn(OLESTR("CWsbCollection::Find"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        WsbAssert(0 != ppElement, E_POINTER);

        WsbAffirmHr(Enum(&pEnum));
        WsbAffirmHr(pEnum->Find(pCollectable, riid, ppElement));
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::Find"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::GetEntries(
    OUT ULONG* pEntries
    )

/*++

Implements:

  IWsbCollection::GetEntries().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::GetEntries"), OLESTR(""));

    try {
        WsbAssert(0 != pEntries, E_POINTER);
        *pEntries = m_entries;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::GetEntries"), OLESTR("hr = <%ls>, entries = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pEntries));

    return(S_OK);
}


HRESULT
CWsbCollection::IsEmpty(
    void
    )

/*++

Implements:

  IWsbCollection::IsEmpty().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbCollection::IsEmpty"), OLESTR(""));

    if (0 != m_entries) {
        hr = S_FALSE;
    }
    
    WsbTraceOut(OLESTR("CWsbCollection::IsEmpty"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::IsLocked(
    void
    )

/*++

Implements:

  IWsbCollection::IsLocked().

--*/
{
    HRESULT     hr = S_OK;
    BOOL        tryEnter = FALSE;
    
    WsbTraceIn(OLESTR("CWsbCollection::IsLocked"), OLESTR(""));
    tryEnter = TryEnterCriticalSection(&m_CritSec);
    if (tryEnter == 0)  {
        //
        // Another thread has the collection locked
        //
        hr = S_OK;
    } else  {
        //
        // We got the lock, so unlock it
        LeaveCriticalSection(&m_CritSec);
        hr = S_FALSE;
    }
    WsbTraceOut(OLESTR("CWsbCollection::IsLocked"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}

HRESULT
CWsbCollection::Lock(
    void
    )

/*++

Implements:

  CComObjectRoot::Lock().

--*/
{
    WsbTrace(OLESTR("CWsbCollection::Lock - waiting for critical section\n"));
    EnterCriticalSection(&m_CritSec);
    WsbTrace(OLESTR("CWsbCollection::Lock - got critical section\n"));
    return(S_OK);
}

HRESULT
CWsbCollection::OccurencesOf(
    IN IUnknown* pCollectable,
    OUT ULONG* pOccurences
    )

/*++

Implements:

  IWsbCollection::OccurrencesOf().

--*/
{
    CComPtr<IWsbCollectable>    pCollectableEnum;
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::OccurencesOf"), OLESTR(""));

    Lock();
    try {


        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAssert(0 != pOccurences, E_POINTER);

        // Initialize the return value.
        *pOccurences = 0;

        // Get an enumerator.
        WsbAffirmHr(Enum(&pEnum));

        // Start at the front of the list.
        for (hr = pEnum->Find(pCollectable, IID_IWsbCollectable, (void**) &pCollectableEnum);
             SUCCEEDED(hr);
             hr = pEnum->FindNext(pCollectable, IID_IWsbCollectable, (void**) &pCollectableEnum)) {
            
            (*pOccurences)++;
            pCollectableEnum = 0;
        }

        // We should always hit the end of the collection, so then
        // change the return code to the appropriate value.
        if (hr == WSB_E_NOTFOUND) {
            if (0 == *pOccurences) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbCollection::OccurencesOf"), OLESTR("hr = <%ls>, occurences = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pOccurences));

    return(hr);
}


HRESULT
CWsbCollection::RemoveAndRelease(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::RemoveAndRelease().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::RemoveAndRelease"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(Remove(pCollectable,  IID_IWsbCollectable, NULL));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::RemoveAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbGuid>   pGuid1;
    CComPtr<IWsbGuid>   pGuid2;
    CComPtr<IWsbGuid>   pGuid3;
    CComPtr<IWsbGuid>   pGuid4;
    ULONG               entries;

    WsbTraceIn(OLESTR("CWsbCollection::Test"), OLESTR(""));

    try {

        // Clear out any entries that might be present.
        hr = S_OK;
        try {
            WsbAssertHr(RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There shouldn't be any entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(0 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // We need some collectable items to exercise the collection.
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid1));
        WsbAssertHr(pGuid1->SetGuid(CLSID_CWsbGuid));
        

        // Add the item to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid1));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 1 entry.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should not be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_FALSE, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Does it think it has the item?
        hr = S_OK;
        try {
            WsbAssertHr(Find(pGuid1, IID_IWsbGuid, (void**) &pGuid2));
            WsbAssert(pGuid1->IsEqual(pGuid2) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        
        // Add some more items
        pGuid2 = 0;
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid2));
        WsbAssertHr(pGuid2->SetGuid(CLSID_CWsbGuid));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid3));
        WsbAssertHr(pGuid3->SetGuid(IID_IWsbGuid));

        // Add the items to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid3));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 3 entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(3 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid1, &entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        
        // Remove one of the two identical items.
        hr = S_OK;
        try {
            WsbAssertHr(Remove(pGuid1, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssertHr(pGuid1->IsEqual(pGuid4));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 2 entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid1, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Can we find an entry?
        hr = S_OK;
        try {
            WsbAssertHr(Find(pGuid3, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssertHr(pGuid4->IsEqual(pGuid3));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Does the collection still contain it?
        hr = S_OK;
        try {
            WsbAssert(Contains(pGuid1) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Remove the last of the two identical items, and verify
        // that it can't be found. Then puit it back.
        hr = S_OK;
        try {
            WsbAssertHr(Remove(pGuid1, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssert(Contains(pGuid1) == S_FALSE, E_FAIL);
            WsbAssertHr(Add(pGuid4));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Try out the persistence stuff.
        {
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;
            CComPtr<IWsbCollection>     pCollect2;

            WsbAssertHr(((IUnknown*)(IWsbCollection*)this)->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IPersistFile, (void**) &pFile2));


            // The item should be dirty.
            hr = S_OK;
            try {
                WsbAssert(pFile1->IsDirty() == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }

                            
            // Save the item, and remember.
            hr = S_OK;
            try {
                WsbAssertHr(pFile1->Save(OLESTR("c:\\WsbTests\\WsbCollection.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // It shouldn't be dirty.
            hr = S_OK;
            try {
                WsbAssert(pFile1->IsDirty() == S_FALSE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Load it back in to another instance.
            hr = S_OK;
            try {
                WsbAssertHr(pFile2->Load(OLESTR("c:\\WsbTests\\WsbCollection.tst"), 0));
                WsbAssertHr(pFile2->QueryInterface(IID_IWsbCollection, (void**) &pCollect2));
                WsbAssert(pCollect2->Contains(pGuid1) == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        }


        // Remove and Release all the items.
        hr = S_OK;
        try {
            WsbAssertHr(RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    
    } WsbCatch(hr);


    // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    WsbTraceOut(OLESTR("CWsbCollection::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}


HRESULT
CWsbCollection::Unlock(
    void
    )

/*++

Implements:

  CComObjectRoot::Unlock().

--*/
{
    LeaveCriticalSection(&m_CritSec);
    WsbTrace(OLESTR("CWsbCollection::Unlock - freed critical section\n"));
    return(S_OK);

}

// Class: CWsbIndexedCollection

HRESULT
CWsbIndexedCollection::Add(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Add().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Add"), OLESTR(""));

    Lock();
    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(AddAt(pCollectable, m_entries));
    } WsbCatch(hr);

    Unlock();
    WsbTraceOut(OLESTR("CWsbIndexedCollection::Add"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Append(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbIndexedCollection::Append().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Append"), OLESTR(""));

    hr = Add(pCollectable);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Append"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Enum(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IWsbCollection::Enum().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pEnum;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Enum"), OLESTR(""));

    try {

        WsbAssert(0 != ppEnum, E_POINTER);

        // Create the instance, initialize it to point to this collection, and
        // return the pointer to the caller.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnum, (void**) &pEnum));
        WsbAffirmHr(pEnum->Init((IWsbCollection*) ((IWsbIndexedCollection*) this)));
        *ppEnum = pEnum;
        (*ppEnum)->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Enum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::EnumUnknown(
    OUT IEnumUnknown** ppEnum
    )

/*++

Implements:

  IWsbCollection::EnumUnknown().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::EnumUnknown"), OLESTR(""));

    try {
        WsbAssert(0 != ppEnum, E_POINTER);

        // Get the IWsbEnum interface, and then query for the IEnumUknown interface.
        WsbAffirmHr(Enum(&pWsbEnum));
        WsbAffirmHr(pWsbEnum->QueryInterface(IID_IEnumUnknown, (void**) ppEnum));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::EnumUnknown"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::First(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::First().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::First"), OLESTR("iid = <%ls>"), WsbGuidAsString(riid));

    try {
        WsbAssert(0 != ppElement, E_POINTER);
        WsbAffirm(m_entries != 0, WSB_E_NOTFOUND);
        WsbAffirmHr(At(0, riid, ppElement));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Index(
    IN IUnknown* pCollectable,
    OUT ULONG* pIndex
    )

/*++

Implements:

  IWsbIndexedCollection::Index().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pOut;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Index"), OLESTR(""));

    try {

        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAssert(0 != pIndex, E_POINTER);

        // Find the first occurence of the item.
        WsbAffirmHr(CopyIfMatches(WSB_COLLECTION_MIN_INDEX, m_entries, pCollectable, 1, IID_IWsbCollectable, (void**) &pOut, NULL, pIndex));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Index"), OLESTR("hr = <%ls>, index = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pIndex));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Last(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Last().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Last"), OLESTR("iid = <%ls>"), WsbGuidAsString(riid));

    try {

        // As long as we have some entires, get the last one.
        WsbAssert(0 != ppElement, E_POINTER);
        WsbAffirm(m_entries != 0, WSB_E_NOTFOUND);
        WsbAffirmHr(At(m_entries - 1, riid, ppElement));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Last"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Prepend(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbIndexedCollection::Prepend().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Prepend"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(AddAt(pCollectable, 0));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Prepend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbIndexedCollection::Remove(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Remove().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       index;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Remove"), OLESTR(""));

    Lock();
    try {
        // Can we find it in our array?
        WsbAffirmHr(Index(pCollectable, &index));

        // Remove it from the specified offset.
        WsbAffirmHr(RemoveAt(index, riid, ppElement));
    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Remove"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::RemoveAllAndRelease(
    void
    )

/*++

Implements:

  IWsbIndexedCollection::RemoveAllAndRelease().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::RemoveAllAndRelease"), OLESTR(""));

    Lock();
    try {

        // Start at the end of the list, and keep removing from the
        // back. For some types of collections, this may not be the most
        // efficient way to remove all the elements.

        if (m_entries > 0) {

            ULONG index = m_entries - 1;

            while (index > 0) {

                WsbAffirmHr(RemoveAt(index, IID_IWsbCollectable, NULL));
                --index;
            }

            WsbAffirmHr(RemoveAt(index, IID_IWsbCollectable, NULL));
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbIndexedCollection::RemoveAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Test"), OLESTR(""));

    try {

        // First run the standard tests for all collections.
        WsbAffirmHr(CWsbCollection::Test(passed, failed));

        // Now do the test that are specific for an indexed collection



        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Test"), OLESTR("hr =<%ls>, testsRun = <%u>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}



// Class:   CWsbOrderedCollection

HRESULT
CWsbOrderedCollection::AddAt(
    IN IUnknown* pCollectable,
    IN ULONG index
    )

/*++

Implements:

  IWsbIndexedCollection::AddAt().

--*/
{
    HRESULT             hr = S_OK;
    IWsbCollectable**   pCollectableNew;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::AddAt"), OLESTR("index = <%lu>"), index);

    Lock();
    try {

        // Are we beyond the end of the collection?
        WsbAffirm(index <= m_entries, WSB_E_OUTOFBOUNDS);
    
        // Is it full?
        if (m_entries >= m_maxEntries) {

            // Could we grow?
            WsbAffirm(((WSB_COLLECTION_MAX_INDEX - m_maxEntries) >= m_growBy), WSB_E_TOOLARGE);

            // Try to allocate a bigger array.
            pCollectableNew = (IWsbCollectable**) WsbRealloc((void*) m_pCollectable, (m_maxEntries + m_growBy) * sizeof(IWsbCollectable*));

            WsbAffirm(pCollectableNew != NULL, E_OUTOFMEMORY);

            m_pCollectable = pCollectableNew;
            m_maxEntries += m_growBy;
        }

        // If we have room, then add it to the collection.
        // First shift any existing entries.
        for (ULONG tmpIndex = m_entries; tmpIndex > index; tmpIndex--) {
            m_pCollectable[tmpIndex] = m_pCollectable[tmpIndex - 1];
        }

        // Now add the new entry.
        m_entries++;
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbCollectable, 
                (void**)&m_pCollectable[index]));
        m_isDirty = TRUE;

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::AddAt"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::At(
    IN ULONG index,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbIndexedCollection::At().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::At"), OLESTR("index = <%lu>, riid = <%ls>"), index, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAffirm(index < m_entries, WSB_E_OUTOFBOUNDS);
        WsbAssert(0 != ppElement, E_POINTER);

        // If they asked for an interface, then try to get the desired
        // interface for the item specified.
        WsbAffirmHr((m_pCollectable[index])->QueryInterface(riid, (void**) ppElement));

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::At"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Copy(
    IN ULONG start,
    IN ULONG stop,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbIndexedCollection::Copy().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       toDo;
    ULONG       copied = 0;
    ULONG       index;
    BOOL        isIncrement = TRUE;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::Copy"), OLESTR("start = <%lu>, stop = <%lu>, riid = <%ls>"), start, stop, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAssert(0 != elements, E_POINTER);
        WsbAssert(0 != pElementsFetched, E_POINTER);
        WsbAffirm(start < m_entries, WSB_E_NOTFOUND);

        // Determine how many elements to copy, and the order in which we are
        // going (increasing vs. decreasing).
        if (start <= stop) {
            toDo = stop - start + 1;
        } else {
            toDo = start - stop + 1;
            isIncrement = FALSE;
        }

        // Iterate over all the items in the range specified, and copy
        // the interface in to the target array.
        for (copied = 0, index = start; ((copied < toDo) && (index < m_entries)); copied++, isIncrement ? index++ : index--) {
            WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
        }

        // Let them know if we didn't fill up the return buffer.
        if (copied < toDo) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    *pElementsFetched = copied;
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Copy"), OLESTR("hr = <%ls>, elementsFetched = <%lu>"), WsbHrAsString(hr), copied);

    return(hr); 
}


HRESULT
CWsbOrderedCollection::CopyIfMatches(
    ULONG start,
    ULONG stop,
    IUnknown* pObject,
    ULONG element,
    REFIID riid,
    void** elements,
    ULONG* pElementsFetched,
    ULONG* pStoppedAt
    )

/*++

Implements:

  IWsbIndexedCollection::CopyIfMatches().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       copied = 0;
    ULONG       index = start;
    ULONG       end = stop;
    BOOL        done = FALSE;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::CopyIfMatches"), OLESTR("start = <%lu>, stop = <%lu>, riid = <%ls>"), start, stop, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAssert(0 != elements, E_POINTER);
        WsbAssert(0 != pStoppedAt, E_POINTER);
        WsbAssert((1 == element) || (0 != pElementsFetched), E_POINTER);
        WsbAssert(0 != element, E_INVALIDARG);

        WsbAffirm(start < m_entries, WSB_E_NOTFOUND);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));
        
        if (start <= stop) {

            // Incrementing.
            if (stop >= m_entries) {
                end = m_entries - 1;
            }
            
            // Continue from here to the end of the range.
            while (!done) {
                if (pCollectable->IsEqual(m_pCollectable[index]) == S_OK) {
                    WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
                    copied++;
                }

                if ((copied < element) && (index < end)) {
                    index++;
                }
                else {
                    done = TRUE;
                }
            }

        } else {

            // Decrementing..
            while (!done) {
                if (m_pCollectable[index]->IsEqual(pCollectable) == S_OK) {
                    WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
                    copied++;
                }

                if ((copied < element) && (index > end)) {
                    index--;
                }
                else {
                    done = TRUE;
                }
            }
        }

        if (0 != pElementsFetched) {
            *pElementsFetched = copied;
        }

        *pStoppedAt = index;

        // If we didn't find anything, then let them know.
        WsbAffirm(0 != copied, WSB_E_NOTFOUND);

        // Let them know if we didn't fill the output buffer,
        // and t=let them know the last index that was checked.
        if (copied < element) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::CopyIfMatches"), OLESTR("hr = <%ls>, elementsFetched = <%lu>, stoppedAt = <%ls>"), WsbHrAsString(hr), copied, WsbPtrToUlongAsString(pStoppedAt));

    return(hr); 
}


HRESULT
CWsbOrderedCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbCollection::FinalConstruct());

        m_pCollectable = NULL;
        m_maxEntries = 0;
        m_growBy = 256;
    } WsbCatch(hr);

    return(hr);
}
    

void
CWsbOrderedCollection::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    if (0 != m_pCollectable) {
        Lock();
        RemoveAllAndRelease();
        WsbFree((void*) m_pCollectable);
        Unlock();
    }

    CWsbCollection::FinalRelease();
}


HRESULT
CWsbOrderedCollection::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbOrderedCollection;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbOrderedCollection::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbOrderedCollection::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = S_OK;
    IPersistStream*     pPersistStream;
    ULARGE_INTEGER      size;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 == pSize, E_POINTER);

        // The size of the header information.
        pSize->QuadPart = 3 * WsbPersistSizeOf(ULONG);
    
        // If we have entries, then add in the size for the maximum number
        // of entries, assuming that they are all the same size.
        if (m_entries != 0) {
            WsbAffirmHr(First(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&size));
            pSize->QuadPart += (m_maxEntries * (size.QuadPart));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbOrderedCollection::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pCollectable;
    ULONG                       entries;
    ULONG                       growBy;
    ULONG                       maxEntries;
    
    WsbTraceIn(OLESTR("CWsbOrderedCollection::Load"), 
            OLESTR("m_entries = %ld, m_maxEntries = %ld, m_growBy = %ld, m_pCollectable = %p"),
            m_entries, m_maxEntries, m_growBy, m_pCollectable);

    Lock();
    try {
        IWsbCollectable**       pTmp;

        // Make sure the collection starts empty
        if (m_entries != 0) {
            WsbAffirmHr(RemoveAllAndRelease());
        }

        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &entries));
        WsbAffirmHr(WsbLoadFromStream(pStream, &maxEntries));
        WsbAffirmHr(WsbLoadFromStream(pStream, &growBy));
        WsbAffirm(entries <= maxEntries, WSB_E_PERSISTENCE_FILE_CORRUPT);

        // Allocate space for the array.
        if (entries > m_maxEntries) {
            pTmp = (IWsbCollectable**) WsbRealloc(m_pCollectable, 
                    maxEntries * sizeof(IWsbCollectable*));
            WsbAffirm(0 != pTmp, E_OUTOFMEMORY);
    
            // Remember our new buffer.
            m_pCollectable = pTmp;
            m_maxEntries = maxEntries;
        }
        m_growBy = growBy;

        // Now do the items in the collection.
        for (ULONG index = 0; (index < entries); index++) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IWsbCollectable, (void**) &pCollectable));
            WsbAffirmHr(Append(pCollectable));
            pCollectable = 0;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Load"), 
            OLESTR("m_entries = %ld, m_maxEntries = %ld, m_growBy = %ld, m_pCollectable = %p"),
            m_entries, m_maxEntries, m_growBy, m_pCollectable);

    return(hr);
}


HRESULT
CWsbOrderedCollection::RemoveAt(
    IN ULONG index,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbIndexedCollection::RemoveAt().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::RemoveAt"), OLESTR("index = <%lu>, riid = <%ls>"), index, WsbGuidAsString(riid));

    Lock();
    try {

        // Make sure that the index is in range.
        WsbAffirm(index < m_entries, WSB_E_OUTOFBOUNDS);

        // If they asked for an interface, then try to get the desired
        // interface for the item specified.
        if (0 != ppElement) {
            WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) ppElement));
        }

        // Remove the item
        m_pCollectable[index]->Release();

        // Now shift all the items in the collection.
        for (ULONG tmpIndex = index; (tmpIndex < (m_entries - 1)); tmpIndex++) {
            m_pCollectable[tmpIndex] = m_pCollectable[tmpIndex + 1];
        }

        m_entries--;
        m_isDirty = TRUE;
            
        // If the collection has really shrunk in size, then we
        // should free up some memory.
        if ((m_maxEntries - m_entries) >= (2 * m_growBy)) {

            // Try to allocate a smaller array.
            IWsbCollectable** pCollectableNew = (IWsbCollectable**) WsbRealloc((void*) m_pCollectable, (m_maxEntries - m_growBy) * sizeof(IWsbCollectable*));

            WsbAffirm(pCollectableNew != NULL, E_OUTOFMEMORY);

            m_pCollectable = pCollectableNew;
            m_maxEntries -= m_growBy;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::RemoveAt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbOrderedCollection::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    Lock();
    try {

        // Check for consistency first
        WsbAffirm(m_entries <= m_maxEntries, WSB_E_INVALID_DATA);

        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_entries));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxEntries));
        WsbAffirmHr(WsbSaveToStream(pStream, m_growBy));

        // Now do the items in the collection.
        if (m_entries > 0) {
            CComPtr<IWsbEnum>       pEnum;
            CComPtr<IPersistStream> pPersistStream;

            // We need to enumerate the items in the collection.
            WsbAffirmHr(Enum(&pEnum));

            for (hr = pEnum->First(IID_IPersistStream, (void**) &pPersistStream);
                 SUCCEEDED(hr);
                 hr = pEnum->Next(IID_IPersistStream, (void**) &pPersistStream)) {
                    
                hr = OleSaveToStream(pPersistStream, pStream);
                pPersistStream = 0;
            }

            WsbAssert(hr == WSB_E_NOTFOUND, hr);
            hr = S_OK;
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbcltn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Wsbcltn.h

Abstract:

    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"
#include "Wsbpstbl.h"

#ifndef _WSBCLTN_
#define _WSBCLTN_


/*++

Class Name:
    
    CWsbCollection 

Class Description:

    A collection of objects.

--*/

class CWsbCollection : 
    public CWsbPersistStream,
    public IWsbCollection,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollection
public:
    STDMETHOD(Contains)(IUnknown* pCollectable);
    STDMETHOD(GetEntries)(ULONG* pEntries);
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(IsEmpty)(void);
    STDMETHOD(IsLocked)(void);
    STDMETHOD(Lock)(void);
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences);
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable);
    STDMETHOD(Unlock)(void);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    ULONG               m_entries;
    CRITICAL_SECTION                m_CritSec;
    BOOL                            m_bCritSecCreated;     
};

#define WSB_FROM_CWSBCOLLECTION \
    STDMETHOD(Contains)(IUnknown* pCollectable) \
        {return(CWsbCollection::Contains(pCollectable));};  \
    STDMETHOD(GetEntries)(ULONG* pEntries) \
        {return(CWsbCollection::GetEntries(pEntries));};    \
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement) \
        {return(CWsbCollection::Find(pCollectable, riid, ppElement));}; \
    STDMETHOD(IsEmpty)(void) \
        {return(CWsbCollection::IsEmpty());};   \
    STDMETHOD(IsLocked)(void) \
        {return(CWsbCollection::IsLocked());};  \
    STDMETHOD(Lock)(void) \
        {return(CWsbCollection::Lock());};  \
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences) \
        {return(CWsbCollection::OccurencesOf(pCollectable, occurences));};  \
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable) \
        {return(CWsbCollection::RemoveAndRelease(pCollectable));};  \
    STDMETHOD(Unlock)(void) \
        {return(CWsbCollection::Unlock());};    \



/*++

Class Name:
    
    CWsbIndexedCollection 

Class Description:

    A indexed collection of objects.

--*/

class CWsbIndexedCollection : 
    public IWsbIndexedCollection,
    public CWsbCollection
{
// IWsbCollection
public:
    WSB_FROM_CWSBCOLLECTION;

// IWsbIndexedCollection
public:
    STDMETHOD(Add)(IUnknown* pCollectable);
    STDMETHOD(Append)(IUnknown* pCollectable);

    STDMETHOD(First)(REFIID riid, void** ppElement);
    STDMETHOD(Index)(IUnknown* pCollectable, ULONG* index);
    STDMETHOD(Last)(REFIID riid, void** ppElement);
    STDMETHOD(Prepend)(IUnknown* pCollectable);
    STDMETHOD(Remove)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(RemoveAllAndRelease)(void);

    STDMETHOD(Enum)(IWsbEnum** ppEnum);
    STDMETHOD(EnumUnknown)(IEnumUnknown** ppEnum);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);
};



/*++

Class Name:
    
    CWsbOrderedCollection 

Class Description:

    An ordered collection of objects.

--*/

class CWsbOrderedCollection : 
    public CWsbIndexedCollection,
    public CComCoClass<CWsbOrderedCollection,&CLSID_CWsbOrderedCollection>
{
public:
    CWsbOrderedCollection() {}
BEGIN_COM_MAP(CWsbOrderedCollection)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollection, IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbOrderedCollection)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbIndexedCollection
    STDMETHOD(AddAt)(IUnknown* pCollectable, ULONG index);
    STDMETHOD(At)(ULONG index, REFIID riid, void** ppElement);
    STDMETHOD(Copy)(ULONG start, ULONG stop, REFIID riid, void** rgElement, ULONG* pElementFetched);
    STDMETHOD(CopyIfMatches)(ULONG start, ULONG stop, IUnknown* pCollectable, ULONG element, REFIID riid, void** rgElement, ULONG* pElementFetched, ULONG* pStoppedAt);
    STDMETHOD(RemoveAt)(ULONG index, REFIID riid, void** ppElement);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed) {
        return(CWsbIndexedCollection::Test(passed, failed));
    };

protected:
    ULONG               m_maxEntries;
    ULONG               m_growBy;
    IWsbCollectable**   m_pCollectable;
};

#endif // _WSBCLTN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbcore.cpp ===
#include "StdAfx.h"
#include "resource.h"
#include "errno.h"
#include "aclapi.h"

#include "Wsb.h"

#include "rpfilt.h"

// File/Directory

// Create a directory and all the parent directories necessary for this directory to
// exist.
HRESULT WsbCreateAllDirectories(OLECHAR* path) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     win32Path;
    CWsbBstrPtr     parentPath;

    try {

        // Convert the path to the win32 style path (to handle long file names), and
        // then try to create the directory.
        WsbAffirmHr(WsbGetWin32PathAsBstr(path, &win32Path));
        if (CreateDirectory(win32Path, 0) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // There are 4 possibilities:
        //      1) it worked (we are done)
        //      2) the directory already exists (we are done)
        //      3) the directory doesn't exist, so try again after creating the parent
        //      4) some other error occurred, so quit
        if (FAILED(hr)) {

            if ((HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr) || (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)) {
                hr = S_OK;
            } else if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)) {

                // Create the parent directory and try again.
                WsbAffirmHr(WsbCreateAllDirectoriesForFile(path));

                if (CreateDirectory(win32Path, 0) == 0) {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    if ((HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)) {
                        hr = S_OK;
                    }
                } else {
                    hr = S_OK;
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}

// Create a all the parent directories necessary for this file to exist.
HRESULT WsbCreateAllDirectoriesForFile(OLECHAR* path) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     parentPath;
    OLECHAR*        slashPtr = 0;
    OLECHAR*        pathStart = 0;

    try {

        // Find out where the relative portion of the path starts, since we don't need to try
        // to create the root directory.
        parentPath = path;
        if ((parentPath[0] == L'\\') && (parentPath[1] == L'\\')) {
            pathStart = wcschr(&parentPath[2], L'\\');
            WsbAffirm(pathStart != 0, E_INVALIDARG);
            pathStart = wcschr(++pathStart, L'\\');
            WsbAffirm(pathStart != 0, E_INVALIDARG);
        } else if (parentPath[1] == L':') {
            pathStart = &parentPath[2];
        } else {
            WsbAssert(FALSE, E_INVALIDARG);
        }

        WsbAffirm(*pathStart != 0, E_INVALIDARG);

        // Create the path to the parent directory and use the create all to create it.
        slashPtr = wcsrchr(pathStart, L'\\');
        if ((slashPtr != 0) && (slashPtr != pathStart)) {
            *slashPtr = 0;

            WsbAffirmHr(WsbCreateAllDirectories(parentPath));
        }

    } WsbCatch(hr);

    return(hr);
}

// Convert a normal path (UNC or drive letter) to the internal format that is needed by
// win32 to deal with long paths and special characters.
HRESULT WsbGetWin32PathAsBstr(OLECHAR* path, BSTR* pWin32Path)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     win32Path;

    try {

        WsbAssert(0 != pWin32Path, E_POINTER);

        // Is it a UNC or a drive letter base path?
        if ((path[0] == L'\\') && (path[1] == L'\\')) {
            
            // UNC Paths must be preceeded with '\\?\UNC', but the then should only be
            // followed by one '\' not two. 
            win32Path = L"\\\\?\\UNC";
            WsbAffirmHr(win32Path.Append(&path[1]));

        } else if (path[1] == L':') {

            // Drive letter based paths need to be preceeded by \\?\.
            win32Path = L"\\\\?\\";
            WsbAffirmHr(win32Path.Append(path));
        } else {
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(win32Path.CopyToBstr(pWin32Path));

    } WsbCatch(hr);

    return(hr);
}

// Convert the internal format that is needed by win32 to deal with long paths and
// special characters to a normal path (UNC or drive letter).
HRESULT WsbGetPathFromWin32AsBstr(OLECHAR* win32Path, BSTR* pPath)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     path;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Is it a UNC or a drive letter base path?
        if (_wcsnicmp(win32Path, L"\\\\?\\", 4) == 0) {
            path = &win32Path[4];
        } else if (_wcsnicmp(win32Path, L"\\\\?\\UNC", 7) == 0) {
            path = "\\";
            WsbAffirmHr(path.Append(&path[7]));
        } else {
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(path.CopyToBstr(pPath));

    } WsbCatch(hr);

    return(hr);
}

// String & Buffer Copy
HRESULT WsbGetComBuffer(OLECHAR** pDest, ULONG requestedSize, ULONG neededSize, BOOL* pWasAllocated) {
    HRESULT     hr = S_OK;
    
    // If they didn't give us a buffer, then let them know that we
    // had to allocate one for them.
    if (pWasAllocated != NULL) {
        if (*pDest == NULL) {
            *pWasAllocated = TRUE;
        }
        else {
            *pWasAllocated = FALSE;
        }
    }

    // If they gave us the size they wanted (or have) for the
    // buffer, then it better be big enough.
    if (requestedSize != 0) {
        if (requestedSize < neededSize) {
            hr = E_INVALIDARG;
        }
        else if (*pDest == NULL) {
            *pDest = (OLECHAR*)WsbAlloc(requestedSize);

            if (*pDest == NULL) {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // If we control the size of the buffer, then make sure it is
    // the right size.
    //
    // NOTE: This may move the buffer!
    else {
        LPVOID pTemp = WsbRealloc(*pDest, neededSize);
        if (pTemp == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            *pDest = (OLECHAR *) pTemp;
        }
    }

    return(hr);
}


HRESULT WsbAllocAndCopyComString(OLECHAR** pszDest, OLECHAR* szSrc, ULONG bufferSize) {
    return(WsbAllocAndCopyComString2(pszDest, szSrc, bufferSize, TRUE));
}


HRESULT WsbAllocAndCopyComString2(OLECHAR** pszDest, OLECHAR* szSrc, ULONG bufferSize, BOOL bInOrder) {
    HRESULT     hr = S_OK;
    ULONG       ulStringSize;
    BOOL        bWasAllocated;
    BOOL        bCopyFailed = FALSE;

    // Determine how big a buffer we need to store the string.
    // NOTE: If we given a NULL pointer, then assume a "" will
    // be created.
    if (szSrc == NULL) {
        ulStringSize = sizeof(OLECHAR);
    }
    else {
        ulStringSize = (wcslen(szSrc) + 1) * sizeof(OLECHAR);
    }


    // Make sure that we have a buffer that we can use, and also
    // remember if we created it (so that we can free it on failure).
    hr = WsbGetComBuffer(pszDest, bufferSize, ulStringSize, &bWasAllocated);

    // If we have a valid buffer, then copy the string.
    if (SUCCEEDED(hr)) {

        if (szSrc == NULL) {
            *pszDest[0] = 0;
        }

        else if (bInOrder) {
            if (wcscpy(*pszDest, szSrc) != *pszDest) {
                bCopyFailed = TRUE;
            }
        }
        else {
            int     i,j;

            for (i = 0, j = (ulStringSize / sizeof(OLECHAR)) - 2; j >= 0; i++, j--) {
                (*pszDest)[i] = szSrc[j];
            }
            (*pszDest)[i] = OLECHAR( '\0' );
        }

        if (bCopyFailed) {
                
            // If the copy failed then free the buffer and
            // return an error.
            if (bWasAllocated) {
                WsbFree(*pszDest);
                *pszDest = NULL;
            }

            hr = E_FAIL;
        }
    }
    
    return(hr);
}


HRESULT WsbLoadComString(HINSTANCE hInstance, UINT uID, OLECHAR** pszDest, ULONG bufferSize) {
    HRESULT     hr = S_OK;
    HRSRC       hResource;
    ULONG       ulStringSize;
    BOOL        bWasAllocated = FALSE;

    // Find the resource requested. This requires converting the resource
    // identifier into a string.
    //
    // NOTE: Strings are not number individually, but in groups of 16!! This throws
    // off the latter size calculation, and some other strategy might be better
    // here (e.g. load to a fixed size and then allocate again if too small).
    hResource = FindResource(hInstance, MAKEINTRESOURCE((uID/16) + 1), RT_STRING);
    if (hResource == NULL) {
        hr = E_FAIL;
    }
    else {

        // How big is the string?
        ulStringSize = SizeofResource(hInstance, hResource);
        if (ulStringSize == 0) {
            hr = E_FAIL;
        }
        else {
              
            // Get the right sized buffer.
            hr = WsbGetComBuffer(pszDest, bufferSize, ulStringSize, &bWasAllocated);
            if (SUCCEEDED(hr)) {

                // Load the string into the buffer.
                if (LoadString(hInstance, uID, (LPTSTR) *pszDest, ulStringSize) == 0) {
                    
                    // If we couldn't load the string, then free the buffer that
                    // if we allocated it.
                    if (bWasAllocated)  {
                        WsbFree(*pszDest);
                    }
                    hr = E_FAIL;
                }
            }
        }
    }

    return(hr);
}


HRESULT WsbMatchComString(OLECHAR* szEnd, UINT uId, USHORT usChecks, UINT* uIdMatch) {
    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    OLECHAR*    szDest = NULL;

    // Initialize the return value.
    *uIdMatch = 0;

    // Check each resource string mention and see if it is the same as
    // the string provided.
    for (UINT uIdTest = uId; ((uIdTest < (uId + usChecks)) && (hr == S_FALSE)); uIdTest++) {

        hr2 = WsbLoadComString(_Module.m_hInst, uIdTest, &szDest, 0);

        if (SUCCEEDED(hr2)) {
            if (wcscmp(szDest, szEnd) == 0) {
                *uIdMatch = uIdTest;
            }
        }
        else {
            hr =hr2;
        }
    }

    // If we allocated a buffer, then we need to free it.
    if (szDest != NULL) {
        WsbFree(szDest);
    }

    return(hr);
}



// Type Conversion
void WsbLLtoHL(LONGLONG ll, LONG* pHigh, LONG* pLow) {

    *pHigh = (DWORD) (ll >> 32);
    *pLow = (DWORD) (ll & 0x00000000ffffffff);
}

LONGLONG WsbHLtoLL(LONG high, LONG low) {
    LONGLONG        ll;

    ll = ((LONGLONG) high) << 32;
    ll += (LONGLONG) (ULONG) low;

    return(ll);         
}

FILETIME WsbLLtoFT(LONGLONG ll) {
    FILETIME        ft;

    WsbLLtoHL(ll, (LONG*) &ft.dwHighDateTime, (LONG*) &ft.dwLowDateTime);

    return(ft);         
}


LONGLONG WsbFTtoLL(FILETIME ft) {
    LONGLONG        ll;

    ll = WsbHLtoLL((LONG) ft.dwHighDateTime, (LONG) ft.dwLowDateTime);

    return(ll);         
}


HRESULT WsbFTtoWCS(BOOL isRelative, FILETIME ft, OLECHAR** pszA, ULONG bufferSize) {
    SYSTEMTIME      st;
    HRESULT         hr = S_OK;
    BOOL            bWasAllocated = FALSE;
    LONGLONG        llIn = WsbFTtoLL(ft);

    WsbTraceIn(OLESTR("WsbFTtoWCS"), OLESTR("isRelative = %ls, ft = %I64x"),
            WsbQuickString(WsbBoolAsString(isRelative)), ft);

    // If this is a relative time, then FT is just ticks.
    if (isRelative) {
        LONGLONG    llTicks=0;
        UINT        uId=0;

        // Try to find a scale that works (i.e. the largest one with
        // no remainder.
        if (llIn  == 0) {
            llTicks = 0;
            uId = IDS_WSB_FT_TYPE_SECOND;
        } 

        else if ((llIn % WSB_FT_TICKS_PER_YEAR) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_YEAR;
            uId = IDS_WSB_FT_TYPE_YEAR;
        }

        else if ((llIn % WSB_FT_TICKS_PER_MONTH) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_MONTH;
            uId = IDS_WSB_FT_TYPE_MONTH;
        }

        else if ((llIn % WSB_FT_TICKS_PER_DAY) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_DAY;
            uId = IDS_WSB_FT_TYPE_DAY;
        }

        else if ((llIn % WSB_FT_TICKS_PER_HOUR) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_HOUR;
            uId = IDS_WSB_FT_TYPE_HOUR;
        }

        else if ((llIn % WSB_FT_TICKS_PER_MINUTE) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_MINUTE;
            uId = IDS_WSB_FT_TYPE_MINUTE;
        }

        else if ((llIn % WSB_FT_TICKS_PER_SECOND) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_SECOND;
            uId = IDS_WSB_FT_TYPE_SECOND;
        }

        else {
            hr = E_INVALIDARG;
        }

        // If we found a scale, then form the proper string.
        if (SUCCEEDED(hr)) {
            OLECHAR*    szTmp1 = NULL;
            OLECHAR*    szTmp2 = NULL;

            // Get the string corresponding to the time period selected.
            hr = WsbLoadComString(_Module.m_hInst, uId, &szTmp1, 0);

            if (SUCCEEDED(hr)) {
                hr = WsbLLtoWCS(llTicks, &szTmp2, 0);

                if (SUCCEEDED(hr)) {
                    hr = WsbGetComBuffer(pszA, bufferSize, (wcslen(szTmp1) + wcslen(szTmp2) + 2) * sizeof(OLECHAR), NULL);
            
                    if (SUCCEEDED(hr)) {
                        swprintf( *pszA, OLESTR("%ls %ls"), szTmp2, szTmp1);
                    }

                    WsbFree(szTmp2);
                }

                WsbFree(szTmp1);
            }
        }
    }

    // Otherwise it is absolute and converts to a specific date and time.
    else {
    
        // Convert the filetime to a system time.
        if (!FileTimeToSystemTime(&ft, &st)) {
            hr = E_FAIL;
        }

        else {

            // Get a buffer for the time string.
            hr = WsbGetComBuffer(pszA, bufferSize, WSB_FT_TO_WCS_ABS_STRLEN * sizeof(OLECHAR), &bWasAllocated);

            if (SUCCEEDED(hr)) {
                // Print the time in the buffer according to the standard
                // format mm/dd/yy @ hh:mm:ss.
                swprintf( *pszA, OLESTR("%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
            }
        }
    }

    WsbTraceOut(OLESTR("WsbFTtoWCS"), OLESTR("pszA = %ls"), *pszA);

    return(hr);
}


HRESULT WsbLLtoWCS(LONGLONG ll, OLECHAR** pszA, ULONG bufferSize) {
    OLECHAR     szTmp[80];
    HRESULT     hr = S_OK;
    int         i = 0;
    LONGLONG    value = ll;
    BOOL        bIsNegative = FALSE;

    // First check to see if ll is negative
    if (value < 0) {
        bIsNegative = TRUE;
        value *= -1;
    }

    // This builds the string in reverse, but we'll change the order
    // again we we copy it to a buffer.
    do {
        szTmp[i++] = (OLECHAR) ('0' + (value % 10));
        value /= 10;
    } while (value > 0);
    
    // Add the negative symbol is negative just before terminating NULL
    if (bIsNegative) {
        szTmp[i] = OLECHAR('-');
        i++;
    }

    // Add a terminating NULL
    szTmp[i] = OLECHAR( '\0' );

    // Now vopy the string into the target buffer.
    hr = WsbAllocAndCopyComString2(pszA, szTmp, bufferSize, FALSE);

    return(hr);
}


HRESULT WsbWCStoFT(OLECHAR* szA, BOOL* pisRelative, FILETIME* pft) {
    HRESULT     hr = S_OK;
    OLECHAR*    szEnd;

    // Is this an absolute time (i.e. a date and time) or a relative
    // time (e.g. 6 days, ...). This is determined by seeing a / in the
    // string, which should only be present in absolute times.  (Input
    // format expected for an absolute time is either "mm/dd/yyyy hh:mm:ss"
    // or "mm/dd/yyyy".  If no time is input for an absolute time (i.e.,
    // the "mm/dd/yyyy" format), then the current local time will be
    // filled in for the user.
    // Note that no millisecond info is to be included, since we supply
    // a 'ticks' field as a separate parameter whenever we work at the 
    // millisecond/fraction of millisecond level.)
    szEnd = wcschr(szA, '/');

    // Is it a relative time (i.e. no '/')?
    if (szEnd == NULL) {
        LONGLONG    llValue;

        *pisRelative = TRUE;

        // The first token should be a number, so convert the string to
        // a number.
        llValue = wcstoul(szA, &szEnd, 10);

        if (errno == ERANGE) {
            hr = E_INVALIDARG;
        }

        else {
            UINT        uId;

            // The second token should be a type (i.e. second, hour, minute, ...).
            hr = WsbMatchComString(szEnd, IDS_WSB_FT_TYPE_YEAR, WSB_FT_TYPES_MAX, &uId);
            if (S_OK == hr) {

                switch (uId) {
                case IDS_WSB_FT_TYPE_YEAR:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_YEAR);
                    break;

                case IDS_WSB_FT_TYPE_MONTH:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_MONTH);
                    break;

                case IDS_WSB_FT_TYPE_WEEK:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_WEEK);
                    break;

                case IDS_WSB_FT_TYPE_DAY:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_DAY);
                    break;

                case IDS_WSB_FT_TYPE_HOUR:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_HOUR);
                    break;

                case IDS_WSB_FT_TYPE_MINUTE:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_MINUTE);
                    break;

                case IDS_WSB_FT_TYPE_SECOND:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_SECOND);
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }
            }
        }
    }

    // It is an absolute time.
    else {
        SYSTEMTIME      st;
        BOOL            timeWasInput = TRUE;
        OLECHAR*    szSearchString;
    
        // The first number should represent the month.
        st.wMonth = (USHORT) wcstoul(szA, &szEnd, 10);
        // test resultant month within range, and that the format of the input
        // absolute date/time is valid (i.e., the character which stopped the
        // above conversion is the slash between the month and day digits)
        if ((st.wMonth < 1) || (st.wMonth > 12) || (*szEnd != ((OLECHAR) '/'))) {
            hr = E_INVALIDARG;
        }

        // The next number should represent the day.
        if (SUCCEEDED(hr)) {
            // set szSearchString to 1 character beyond the character that
            // stopped the above 'wcstoul' conversion
            szSearchString = szEnd + 1;
            st.wDay = (USHORT) wcstoul(szSearchString, &szEnd, 10);
            if ((st.wDay < 1) || (st.wDay > 31) || (*szEnd != ((OLECHAR) '/'))) {
                hr = E_INVALIDARG;
            }
        }

        // The next number should represent the year.
        if (SUCCEEDED(hr)) {
            szSearchString = szEnd + 1;
            st.wYear = (USHORT) wcstoul(szSearchString, &szEnd, 10);
            // test resultant year equal to at least 1601, since NT records
            // time and date starting from 12:00am, January 1, 1601.  This
            // test also is used to enforce that a 4 digit year was entered.
            if ((st.wYear < 1601) || (*szEnd != ((OLECHAR) ' '))) {
                if (( st.wYear >= 1601 ) && ( szEnd[0] == 0 )) {
                    SYSTEMTIME  now;
                    GetLocalTime ( &now );
                    st.wHour = now.wHour;
                    st.wMinute = now.wMinute;
                    st.wSecond = now.wSecond;
                    timeWasInput = FALSE;
                }
                else {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the hour.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wHour = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wHour > 23) || (*szEnd != ((OLECHAR) ':'))) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the minutes.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wMinute = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wMinute > 59) || (*szEnd != ((OLECHAR) ':'))) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the seconds.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wSecond = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wSecond > 59) || (szEnd[0] != 0)) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // NOTE: Although the SYSTEMTIME structure contains a milliseconds field, 
        // it can only express milliseconds as whole numbers, so this function
        // does not support any way to specify the number of milliseconds.  If
        // millisecond/fraction of milliseconds are necessary, after this function 
        // returns add in the NT-supported 'number of 100 nanosecond 'ticks'' to 
        // the FILETIME result output by this function.  The number of 
        // ticks is used to represent both milliseconds and fractions thereof.

        // initialize the millisecond field before converting SystemTime to FileTime
        st.wMilliseconds = 0;

        
        // If we properly converted the string, then convert the
        // system time into a file time.
        if (SUCCEEDED(hr)) {
            if ( SystemTimeToFileTime(&st, pft) == FALSE) {
                hr = E_FAIL;
            }
        }
    }

    return(hr);
}



HRESULT WsbWCStoLL(OLECHAR* szA, LONGLONG* pll) {
    HRESULT     hr = S_OK;
    LONGLONG    llFactor = 1;
    size_t      ulLength = wcslen(szA);

    // It is an error not to have any digits.
    if (ulLength == 0) {
        hr = E_INVALIDARG;
    }

    else {
        int     i;
    
        // Step through character by character.
        for (i = ulLength, *pll = 0; ((i > 0) && (SUCCEEDED(hr))); i--) {
            if (iswalpha(szA[i-1])) {
                (*pll) += llFactor * ((LONGLONG) (szA[i-1] - ((OLECHAR) '0')));
                llFactor *= 10;
            }
            else {
                hr = E_INVALIDARG;
            }
        }
    }

    return(hr);
}

HRESULT WsbDatetoFT(DATE date, LONG ticks, FILETIME* pFt)
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      st;

    try {

        WsbAssert(0 != pFt, E_POINTER);

        // Do the basic date conversion
        WsbAffirmHr(VariantTimeToSystemTime(date, &st));
        WsbAffirmStatus(SystemTimeToFileTime(&st, pFt));

        // Variant DATE field only tracks time and date down to seconds.
        // FILETIMEs are kept using a 64 bit value specifying the number
        // of 100-nanosecond intervals that have elapsed since 12:00am
        // January 1, 1601.  Since our 'ticks' value represents milliseconds
        // and fractions of milliseconds using the same 100-nanosecond interval 
        // units, to add in milliseconds add in the ticks.  But since FILETIME 
        // is actually a structure of 2 DWORDs, we must use some conversions.

        LONGLONG FTasLL;
        FTasLL = WsbFTtoLL ( *pFt );

        FTasLL += (LONGLONG) ticks;

        *pFt = WsbLLtoFT ( FTasLL );

    } WsbCatch(hr);
 
    return(hr);
}

HRESULT WsbFTtoDate(FILETIME ft, DATE* pDate, LONG* pTicks)
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      st;
    FILETIME        ft2;

    try {
        
        WsbAssert(0 != pDate, E_POINTER);
        WsbAssert(0 != pTicks, E_POINTER);

        // Do the basic time conversion.
        WsbAffirmStatus(FileTimeToSystemTime(&ft, &st));
        WsbAffirmStatus(SystemTimeToVariantTime(&st, pDate));

        // Now convert back what we have and figure out how many ticks got lost.
        WsbAffirmHr(WsbDatetoFT(*pDate, 0, &ft2));
        *pTicks = (LONG) (WsbFTtoLL(ft) - WsbFTtoLL(ft2));

    } WsbCatch(hr)

    return(hr);
}


HRESULT WsbLocalDateTicktoUTCFT(DATE date, LONG ticks, FILETIME* pFT)
{
    // This routine converts a VARIANT DATE field (expressed in local time)
    // and a 'number of 100 nanosecond intervals' ticks field to a FILETIME
    // in UTC format.  This is the format that file timestamps are kept in.
    // The result of this call is suitable for use in setting a file's timestamp.

    HRESULT         hr = S_OK;
    FILETIME        localFTHolder;

    try {

        WsbAssert(0 != pFT, E_POINTER);

        // Do the basic date conversion which yields a FILETIME in local time
        WsbAffirmHr(WsbDatetoFT(date, ticks, &localFTHolder));

        // Now convert the local time to UTC format FILETIME
        WsbAffirmStatus(LocalFileTimeToFileTime(&localFTHolder, pFT));

    } WsbCatch(hr);
 
    return(hr);
}


HRESULT WsbUTCFTtoLocalDateTick(FILETIME ft, DATE* pDate, LONG* pTicks)
{
    // This routine converts a FILETIME field (expressed in UTC format - which 
    // is the format file timestamps are stored in) to a VARIANT DATE field
    // (expressed in local time) and a Ticks field.  The Ticks field represents
    // a 'number of 100 nanosecond intervals' which represents the 'milliseconds
    // and fractions of a millisecond' that was contained in the UTC formatted
    // FILETIME.

    HRESULT         hr = S_OK;
    FILETIME        localFT;

    try {
        
        WsbAssert(0 != pDate, E_POINTER);
        WsbAssert(0 != pTicks, E_POINTER);

        // First convert the UTC format FILETIME to one in Local Time
        WsbAffirmStatus(FileTimeToLocalFileTime(&ft, &localFT));
        
        // Do the basic time conversion.
        WsbAffirmHr(WsbFTtoDate(localFT, pDate, pTicks));

    } WsbCatch(hr)

    return(hr);
}


HRESULT WsbDateToString(DATE date, OLECHAR** string) {
    
    // NOTE: the caller owns the memory occupied by 'string' when this
    // helper function returns.  Since 'string''s buffer is allocated
    // by WsbAlloc/Realloc(), memory needs to be freed via
    // WsbFree()
    
    HRESULT     hr = S_OK;
    SYSTEMTIME  systime;
    BOOL        wasBufferAllocated;

    try {
        // convert the VARIANT Date to a system time
        WsbAffirmHr ( VariantTimeToSystemTime ( date, &systime ) );

        // create a COM buffer (meaning it was allocated with 
        // WsbAlloc/Realloc()) to hold the date/time string which this method 
        // will return.  The buffer, passed back as 'string', will need to be freed 
        // with WsbFree() by the caller.  Note that passing a 'requested size' 
        // (2nd arg) of zero forces a realloc of the 'string' buffer.
        WsbAffirmHr ( WsbGetComBuffer ( string, 0, 
                        (WSB_VDATE_TO_WCS_ABS_STRLEN * sizeof (OLECHAR)),
                        &wasBufferAllocated ) );

        // load the buffer with the date and time using the standard
        // format:  mm/dd/yyyy hh:mm:ss.  Note that milliseconds are 
        // not represented since a VARIANT Date field can only track 
        // time to second granularity.
        swprintf ( *string, L"%2.2d/%2.2d/%2.4d %2.2d:%2.2d:%2.2d",
                    systime.wMonth, systime.wDay, systime.wYear,
                    systime.wHour, systime.wMinute, systime.wSecond );

    } WsbCatch ( hr )

    return ( hr );
}


HRESULT WsbStringToDate(OLECHAR* string, DATE* date) 
{
    HRESULT     conversionHR = S_OK;
    BOOL        isRelative;
    FILETIME    holdFT;
    SYSTEMTIME  holdST;

    try {
        // convert input wide char string to a FILETIME.  Throw hr as
        // exception if not successful.
        WsbAffirmHr ( WsbWCStoFT ( string, &isRelative, &holdFT ) );

        // convert FILETIME result from above to SYSTEMTIME.  If this 
        // Boolean call fails, get Last Error, convert to hr and throw it.
        WsbAffirmStatus ( FileTimeToSystemTime ( &holdFT, &holdST ) );

        // finally, convert SYSTEMTIME result from above to VARIANT Date
        WsbAffirmHr ( SystemTimeToVariantTime ( &holdST, date ) );

    } WsbCatch ( conversionHR )

    return ( conversionHR );
}


// Filetime Manipulations
FILETIME WsbFtSubFt(FILETIME ft1, FILETIME ft2)
{
    return(WsbLLtoFT(WsbFTtoLL(ft1) - WsbFTtoLL(ft2)));
}

SHORT WsbCompareFileTimes(FILETIME ft1, FILETIME ft2, BOOL isRelative, BOOL isNewer)
{
    SHORT       result = 0;
    LONGLONG    ll1;
    LONGLONG    ll2;
    LONGLONG    tmp;
    FILETIME    ftNow;
    LONGLONG    llNow;

    WsbTraceIn(OLESTR("WsbCompareFileTimes"), OLESTR("ft1 = %ls, ft2 = %ls, isRelative = %ls, isNewer = %ls"),
            WsbQuickString(WsbFiletimeAsString(FALSE, ft1)),
            WsbQuickString(WsbFiletimeAsString(isRelative, ft2)),
            WsbQuickString(WsbBoolAsString(isRelative)), WsbQuickString(WsbBoolAsString(isRelative)));

    ll1 = WsbFTtoLL(ft1);
    ll2 = WsbFTtoLL(ft2);

    if (isRelative) {
        
        GetSystemTimeAsFileTime(&ftNow);
        WsbTrace(OLESTR("WsbCompareFileTimes: ftNow = %ls\n"),
                WsbFiletimeAsString(FALSE, ftNow));
        llNow = WsbFTtoLL(ftNow);

        if (isNewer) {
            tmp = ll1 - llNow;
        } else {
            tmp = llNow - ll1;
        }

        if (tmp > ll2) {
            result = 1;
        } if (tmp < ll2) {
            result = -1;
        }
    }
    
    else {

        if (ll1 > ll2) {
            result = 1;
        } if (ll1 < ll2) {
            result = -1;
        }

        if (!isNewer) {
            result *= -1;
        }
    }

    WsbTraceOut(OLESTR("WsbCompareFileTimes"), OLESTR("result = %hd"), result);
    return(result);
}

// GUID Manipulations
int WsbCompareGuid(REFGUID guid1, REFGUID guid2)
{
    return(memcmp(&guid1, &guid2, sizeof(GUID)));
}

HRESULT WsbStringFromGuid(REFGUID rguid, OLECHAR* sz)
{
    int returnCount = StringFromGUID2(rguid, sz, WSB_GUID_STRING_SIZE);

    return ( ( returnCount > 0) ? S_OK : E_FAIL );
}

HRESULT WsbGuidFromString(const OLECHAR* sz, GUID * pguid)
{
    return CLSIDFromString((OLECHAR*)sz, pguid);
}

HRESULT WsbGetServiceId(OLECHAR* serviceName, GUID* pGuid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // if the SettingId value is there then we tell caller there is none 
        // clean up the registry ?????
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot) == S_OK) {
            // if the Id is there remove it first
            if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) == S_OK) {
                WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("Id") ) );
            }
            // Remove the SettingId value last
            WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );
            *pGuid = GUID_NULL ;
            WsbThrow( WSB_E_NOTFOUND );

        // if it is not there we return GUID_NULL
        } else if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            *pGuid = GUID_NULL ;
            WsbThrow( WSB_E_NOTFOUND );

        // verify that the Id value is really there
        } else {
            WsbAffirmHr(IIDFromString(outString, (IID *)pGuid));
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT WsbSetServiceId(OLECHAR* serviceName, GUID guid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // If the Id string is not there then set it
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(guid, strGuid));
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            // if there is a SettingId then we have something wrong in here so throw an error
            if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot) == S_OK) {
                WsbThrow( WSB_E_INVALID_DATA );
            }
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), strGuid ) );
        } else {
            // ID already exists so set it and blast the SettingId 
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), strGuid));
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), strGuid));
            WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );
        }

    } WsbCatch(hr);

    return(hr);
}
HRESULT WsbCreateServiceId(OLECHAR* serviceName, GUID* pGuid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            WsbAffirmHr(CoCreateGuid(pGuid));
            CWsbStringPtr strGuid;
            WsbAffirmHr(WsbSafeGuidAsString(*pGuid, strGuid));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), strGuid));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), strGuid));
        } else {
            WsbThrow( WSB_E_INVALID_DATA );
        }

    } WsbCatch(hr);

    return(hr);
}
HRESULT WsbConfirmServiceId(OLECHAR* serviceName, GUID guidConfirm )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;
    GUID                guid;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // verify that the Id value is really there
        WsbAffirmHr( WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) ) ;
        WsbAffirmHr( IIDFromString( outString, (IID *)&guid ) );
        WsbAffirm( guid == guidConfirm, WSB_E_INVALID_DATA );

        // verify that the SettingId value is really there and the same
        WsbAffirmHr( WsbGetRegistryValueString( NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot ) ) ;
        WsbAffirmHr( IIDFromString( outString, (IID *)&guid ) );
        WsbAffirm( guid == guidConfirm, WSB_E_INVALID_DATA );

        // remove the flag value
        WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbGetMetaDataPath(OUT CWsbStringPtr & Path)
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    
    try {

        // Find out where they have NT installed, and make sure that our subdirectory exists.
        WsbAffirmHr(Path.Alloc(256));
        //
        // Use the relocatable meta-data path if it's available,
        // otherwise default to the %SystemRoot%\System32\RemoteStorage
        //
        hr = WsbCheckIfRegistryKeyExists(NULL, WSB_CONTROL_REGISTRY_KEY);
        if (hr == S_OK) {
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CONTROL_REGISTRY_KEY, WSB_METADATA_REGISTRY_VALUE, Path, 256, &sizeGot));

        } else {
            WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, Path, 256, &sizeGot));
            WsbAffirmHr(Path.Append(OLESTR("\\system32\\RemoteStorage")));
        }
    } WsbCatchAndDo(hr,
                    Path.Free();
                   );

    return(hr);
}


HRESULT WsbGetServiceTraceDefaults(OLECHAR* serviceName, OLECHAR* traceFile, IUnknown* pUnk)
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       pathString;
    CWsbStringPtr       outString;
    CWsbStringPtr       rsPath;
    CWsbStringPtr       tmpString;
    CComPtr<IWsbTrace>  pTrace;
    OLECHAR*            lastSlash;
    
    PSID pSystemSID = NULL;
    PSID pAdminSID = NULL;
    PSID pBackupOpSID = NULL;
    PACL pACL = NULL;
#define     METADATA_DIR_NUM_ACE      3
    EXPLICIT_ACCESS ea[METADATA_DIR_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

    try {

        WsbAssertPointer(serviceName);

        WsbAffirmHr(WsbGetMetaDataPath(rsPath));

        // Create metadata directory
        tmpString = rsPath;
        WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
        if (! CreateDirectory(tmpString, 0)) {
            // Directory already exists is expected
            DWORD status = GetLastError();
            if ((status == ERROR_ALREADY_EXISTS) || (status == ERROR_FILE_EXISTS)) {
                status = NO_ERROR;
            }
            WsbAffirmNoError(status);
        }

        // Set strong ACL on the RSS metadata directory
        // Note: In order to handle the upgrade case as well, we need to set the ACL even if
        // the directory exists. Another option would be:
        //  1. Set it here only if directory doesn't exist
        //  2. Then set ACL in CHsmServer::Load or in the Setup-upgrade code  where there is 
        //     a dedicated code for the Win2K upgrade case

        // Prepare security attribute for admin only access:
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * METADATA_DIR_NUM_ACE);

        // Create a SID for the local system account
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        // Create a SID for the Administrators group.
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &pAdminSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[1].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[1].Trustee.pMultipleTrustee = NULL;
        ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

        // Create a SID for the BackupOp group.
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_BACKUP_OPS,
                             0, 0, 0, 0, 0, 0,
                             &pBackupOpSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the BackupOps group read access to the directory
        ea[2].grfAccessPermissions = (FILE_GENERIC_READ | FILE_TRAVERSE);
        ea[2].grfAccessMode = SET_ACCESS;
        ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[2].Trustee.pMultipleTrustee = NULL;
        ea[2].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[2].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[2].Trustee.ptstrName  = (LPTSTR) pBackupOpSID;

        // Create a new ACL that contains the ACEs.
        WsbAffirmNoError( SetEntriesInAcl(METADATA_DIR_NUM_ACE, ea, NULL, &pACL));

        // Set the ACL on the directory
        WsbAffirmWin32(SetNamedSecurityInfo(tmpString, SE_FILE_OBJECT, 
                            (DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION), 
                            NULL, NULL, pACL, NULL) );

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));

        WsbAffirmHr(outString.Alloc(256));

        // We also want to put the path where the trce file should go.
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("WsbTraceFileName"), outString, 256, &sizeGot) != S_OK) {
            outString = rsPath;
            WsbAffirmHr(outString.Append(OLESTR("\\Trace\\")));
            WsbAffirmHr(outString.Append(traceFile));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("WsbTraceFileName"), outString));
        }

        // Try a little to make sure the trace directory exists.
        lastSlash = wcsrchr(outString, L'\\');
        if ((0 != lastSlash) && (lastSlash != outString)) {
            *lastSlash = 0;
            CreateDirectory(outString, 0);
        }

        // Turn tracing on, if requested.
        if (0 != pUnk) {
            WsbAffirmHr(pUnk->QueryInterface(IID_IWsbTrace, (void**) &pTrace));
            WsbAffirmHr(pTrace->SetRegistryEntry(tmpString));
            WsbAffirmHr(pTrace->LoadFromRegistry());
        }

    } WsbCatch(hr);

    // Cleanup security allocations
    if (pSystemSID) 
        FreeSid(pSystemSID);
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pBackupOpSID) 
        FreeSid(pBackupOpSID);
    if (pACL) 
        LocalFree(pACL);

    return(hr);
}

HRESULT
WsbRegisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName,
    IN  DWORD         CategoryCount,
    IN  const WCHAR * CategoryMsgFile OPTIONAL,
    IN  const WCHAR * MsgFiles
    )

/*++

Routine Description:

    Registers the given event source in the event log.
    
    We have to do the event log registration outside the rgs
    files since event log viewer insists on REG_EXPAND_SZ type
    values (which cannot be done via rgs).

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

--*/

{

    CWsbStringPtr rpPath;
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr   regPath;
        DWORD types = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;

        //
        // Everything goes into HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogName>\<SourceName>
        //
        regPath.Printf(  OLESTR("%ls\\%ls\\%ls"), WSB_LOG_BASE, LogName, SourceName );
        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, regPath ) );


        //
        // See if we have Categories within this source. Register if so
        //
        if( CategoryCount ) {

            WsbAffirmHr( WsbSetRegistryValueDWORD(  0, regPath, WSB_LOG_CAT_COUNT, CategoryCount ) );
            WsbAffirmHr( WsbSetRegistryValueString( 0, regPath, WSB_LOG_CAT_FILE,  CategoryMsgFile, REG_EXPAND_SZ ) );

        }

        //
        // Register the message source and types of events
        //
        WsbAffirmHr( WsbSetRegistryValueString( 0, regPath, WSB_LOG_MESSAGE_FILE, MsgFiles, REG_EXPAND_SZ ) );
        WsbAffirmHr( WsbSetRegistryValueDWORD(  0, regPath, WSB_LOG_TYPES,        types ) );

    } WsbCatch( hr );

    return ( hr );
}

HRESULT
WsbUnregisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName
    )

/*++

Routine Description:

    Registers the given event source in the event log.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

--*/

{

    CWsbStringPtr rpPath;
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr   regPath;

        //
        // Everything goes into HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogName>\<SourceName>
        //
        regPath.Printf(  OLESTR("%ls\\%ls\\%ls"), WSB_LOG_BASE, LogName, SourceName );

        //
        // Some of these may not exist, so don't check return value
        //
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_CAT_COUNT );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_CAT_FILE );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_MESSAGE_FILE );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_TYPES );

        regPath.Printf(  OLESTR("%ls\\%ls"), WSB_LOG_BASE, LogName );
        WsbAffirmHr( WsbRemoveRegistryKey( 0, regPath, SourceName ) );

    } WsbCatch( hr );

    return ( hr );
}

HRESULT
WsbRegisterRsFilter (
    BOOL bDisplay
    )

/*++

Routine Description:

    Registers the RsFilter for use by the system.
    We assume that the filter is already in the system32\driver directory.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

    ERROR_SERVICE_EXISTS - service already exists

    ERROR_DUP_NAME - The display name already exists in teh SCM as a service name or a display name
--*/

{

    CWsbStringPtr rpPath;
    CWsbStringPtr rpDescription;
    SC_HANDLE hService;
    SC_HANDLE hSCM = NULL;
    HRESULT hr = S_OK;
    DWORD rpTag = 0;

    try {
        rpPath.Printf( OLESTR("%%SystemRoot%%\\System32\\drivers\\%ls%ls"), TEXT(RSFILTER_APPNAME), TEXT(RSFILTER_EXTENSION) );

        //
        // First make sure not already installed
        //
        hSCM = OpenSCManager( 0, 0, GENERIC_READ | GENERIC_WRITE );
        WsbAffirmPointer( hSCM );


        //
        // and install it
        //
            
        hService = CreateService(
                        hSCM,                       // SCManager database
                        TEXT(RSFILTER_SERVICENAME), // Service name
                        TEXT(RSFILTER_DISPLAYNAME), // Display name
                        SERVICE_ALL_ACCESS,         // desired access
                        SERVICE_FILE_SYSTEM_DRIVER, // service type
                        SERVICE_BOOT_START,         // start type
                        SERVICE_ERROR_NORMAL,       // error control type
                        rpPath,                     // Executable location 
                        TEXT(RSFILTER_GROUP),       // group
                        &rpTag,                     // Set tag to zero so we are loaded first in the filter group.
                        TEXT(RSFILTER_DEPENDENCIES),
                        NULL,
                        NULL);
            
        WsbAffirmStatus( 0 != hService );


        rpDescription.LoadFromRsc(_Module.m_hInst, IDS_WSBSVC_DESC );
        SERVICE_DESCRIPTION svcDesc;
        svcDesc.lpDescription = rpDescription;
        ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, &svcDesc );

        CloseServiceHandle( hService );

        //
        // Add event logging entries
        //
        WsbAffirmHr( WsbRegisterEventLogSource(
            WSB_LOG_SYS, WSB_LOG_FILTER_NAME, 0, 0, TEXT(RSFILTER_FULLPATH) ) );

        //
        // Make sure params Key exists
        //
        CWsbStringPtr regPath;
        regPath.Printf( OLESTR("%ls\\%ls\\Parameters"), WSB_SVC_BASE, TEXT(RSFILTER_SERVICENAME) );
        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, regPath ) );
        

    } WsbCatchAndDo( hr,

            // If the caller wants error messages then give a message
            if ( bDisplay ) MessageBox(NULL, WsbHrAsString( hr ), WSB_FACILITY_PLATFORM_NAME, MB_OK);

        );

    if( hSCM ) {

        CloseServiceHandle( hSCM );
        hSCM = NULL;

    }

    return ( hr );
}

HRESULT
WsbUnregisterRsFilter (
    BOOL bDisplay
    )

/*++

Routine Description:

    Registers the RsFilter for use by the system.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

    ERROR_SERVICE_EXISTS - service already exists

    ERROR_DUP_NAME - The display name already exists in teh SCM as a service name or a display name
--*/

{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    HRESULT   hr = S_OK;

    try {
        //
        // First connect with the Service Control Manager
        //
        hSCM = OpenSCManager( 0, 0, GENERIC_READ | GENERIC_WRITE );
        WsbAffirmPointer( hSCM );

        //
        // Open the service
        //
        hService = OpenService( hSCM, TEXT(RSFILTER_SERVICENAME), SERVICE_ALL_ACCESS );
        //
        // if the handle is NULL then there is a problem and need to call GetLastError to get error code
        //
        WsbAffirmStatus( 0 != hService );

        //
        // Delete the service - if it does not work then return the error
        //
        WsbAffirmStatus( DeleteService( hService ) );

        //
        // Remove the registry values
        //
        WsbAffirmHr( WsbUnregisterEventLogSource( WSB_LOG_SYS, WSB_LOG_FILTER_NAME ) );
        
    } WsbCatchAndDo( hr, 
            // If the caller wants error messages then give a message
            if ( bDisplay ) MessageBox(NULL, WsbHrAsString( hr ), WSB_FACILITY_PLATFORM_NAME, MB_OK);
        );

    if ( hService ){
        CloseServiceHandle( hService );
        hService = NULL;
    }
        
    if( hSCM ) {
        CloseServiceHandle( hSCM );
        hSCM = NULL;
    }

    return ( hr );
}

STDAPI
DllRegisterRsFilter (
    void
    )
{
    return( WsbRegisterRsFilter( FALSE ) ) ;
}

STDAPI
DllUnregisterRsFilter (
    void
    )
{
    return( WsbUnregisterRsFilter( FALSE ) ) ;
}

HRESULT
WsbCheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
{
    HRESULT hr = S_OK;
    
    PSID   psid = 0;

    HANDLE hToken = NULL;

    try  {

        //
        // Set up the SID to check against
        //
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
        switch( AccessType ) {
        
        case WSB_ACCESS_TYPE_ADMINISTRATOR:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_OPERATOR:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_SYSTEM_OPS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_USER:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_USERS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_ALL:
            WsbThrow( S_OK );
            break;

        default:
            WsbThrow( E_INVALIDARG );

        }

        //
        // Check for membership
        //
        BOOL pMember = FALSE;
        if (! CheckTokenMembership( 0, psid, &pMember ) ) {
            // Check if this is an impersonation level problem, if so,
            // get the thread impersonation token and try again
            DWORD dwErr1 = GetLastError();
            if (dwErr1 == ERROR_BAD_IMPERSONATION_LEVEL) {
                // Get thread token
                HANDLE hThread = GetCurrentThread(); // No need to call CloseHandle here
                WsbAffirmStatus(OpenThreadToken(hThread, TOKEN_QUERY, TRUE, &hToken));
                WsbAffirmStatus( CheckTokenMembership( hToken, psid, &pMember ) );
            } else {
                // Other error - throw
                WsbAffirmNoError(dwErr1);
            }
        }

        if( !pMember ) {

            WsbThrow( E_ACCESSDENIED );
   
        }
        
    } WsbCatch( hr );
    
    if( psid )   FreeSid( psid );

    if (hToken != NULL)
        CloseHandle(hToken);

    return( hr );
}


HRESULT
CWsbSecurityDescriptor::AllowRid(
    DWORD Rid,
    DWORD dwAccessMask
    )
{
    HRESULT hr = S_OK;
    PSID pSid = 0;
    PACL newACL = 0;

    try {

        //
        // First, create the SID from Rid
        //
        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        WsbAffirmStatus( AllocateAndInitializeSid(
               &sia,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               Rid,
               0, 0, 0, 0, 0, 0,
               &pSid
               ) );

        //
        // Construct new ACL
        //
        ACL_SIZE_INFORMATION aclSizeInfo;
        int   aclSize;
        PACL  oldACL;

        aclSizeInfo.AclBytesInUse = 0;
        oldACL = m_pDACL;
        if( oldACL ) {

            WsbAffirmStatus(GetAclInformation( oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

        }

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( pSid ) - sizeof(DWORD);

        WsbAffirmAlloc(  newACL = (PACL)( new BYTE[aclSize] ) );
        WsbAffirmStatus( InitializeAcl( newACL, aclSize, ACL_REVISION ) );
        WsbAffirmHr(     CopyACL( newACL, oldACL ) );

        WsbAffirmStatus( AddAccessAllowedAce( newACL, ACL_REVISION2, dwAccessMask, pSid ) );

        //
        // Swap over to new ACL
        //
        m_pDACL = newACL;
        newACL  = 0;

        if( oldACL ) {

            delete( oldACL );

        }

        //
        // Update the security descriptor
        //
        WsbAffirmStatus(SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE ));

    } WsbCatch( hr );

    if( pSid )   FreeSid( pSid );
    if( newACL ) delete( newACL );
    return( hr );
}

HRESULT
WsbGetResourceString(
    ULONG id,
    WCHAR **ppString
    )
{
    HRESULT hr = S_OK;
    
    try  {
        WsbAssert(ppString != 0, E_INVALIDARG);

        *ppString = NULL;

        // Let our srting class to do the work...
        CWsbStringPtr loader;
        WsbAffirmHr(loader.LoadFromRsc(_Module.m_hInst, id));

        *ppString = *(&loader);
        *(&loader) = NULL;
        
    } WsbCatch( hr );
    

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbenum.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbenum.cpp

Abstract:

    These classes provides enumerators (iterators) for the collection classes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbenum.h"


HRESULT
CWsbIndexedEnum::Clone(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IWsbEnum::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IWsbEnum)"), OLESTR(""));

    try {

        // Create a new enumeration instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnum, (void**) &pWsbEnum));

        // It should reference the same collection.
        WsbAffirmHr(pWsbEnum->Init((IWsbCollection*) m_pCollection));

        // It should reference the same item in the collection.
        WsbAffirmHr(pWsbEnum->SkipTo(m_currentIndex));

        *ppEnum = pWsbEnum;
        pWsbEnum.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IWbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Clone(
    OUT IWsbEnumEx** ppEnum
    )

/*++

Implements:

  IWsbEnumEx::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnumEx> pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IWsbEnumEx)"), OLESTR(""));

    try {

        // Create a new enumeration instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnumEx, (void**) &pWsbEnum));

        // It should reference the same collection.
        WsbAffirmHr(pWsbEnum->Init((IWsbCollection*) m_pCollection));

        // It should reference the same item in the collection.
        WsbAffirmHr(pWsbEnum->SkipTo(m_currentIndex));

        *ppEnum = pWsbEnum;
        pWsbEnum.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IWbEnumEx)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbIndexedEnum::Clone(
    OUT IEnumUnknown** ppEnum
    )

/*++

Implements:

  IEnumUknown::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IEnumUnknown)"), OLESTR(""));

    try {

        // This does the major part of the work.
        WsbAffirmHr(Clone(&pWsbEnum));
        
        // Now get them the interace that they wanted.
        WsbAffirmHr(pWsbEnum->QueryInterface(IID_IEnumUnknown, (void**) ppEnum));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IEnumUnknown)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
#pragma optimize("g", off)


HRESULT
CWsbIndexedEnum::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());
        m_currentIndex = 0;
    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)
    

HRESULT
CWsbIndexedEnum::Find(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Find

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Find(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        hr = m_pCollection->CopyIfMatches(WSB_COLLECTION_MIN_INDEX, WSB_COLLECTION_MAX_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Find(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Find(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Find

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Find(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        hr = m_pCollection->CopyIfMatches(WSB_COLLECTION_MIN_INDEX, WSB_COLLECTION_MAX_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Find(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindNext(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::FindNext

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);
        
        hr = m_pCollection->CopyIfMatches(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindNext(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::FindNext

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);
        
        hr = m_pCollection->CopyIfMatches(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindPrevious(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::FindPrevious

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MIN_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        hr = m_pCollection->CopyIfMatches(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindPrevious(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::FindPrevious

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MIN_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        hr = m_pCollection->CopyIfMatches(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::First(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::First

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched = 0;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::First(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // Since we aren't doing any addition to the number of elements, the
        // Copy command does all the range checking that we need.
        WsbAffirmHr(m_pCollection->Copy(WSB_COLLECTION_MIN_INDEX, 0, riid, ppElement, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::First(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::First(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::First

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched = 0;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::First(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert((0 != pElementsFetched), E_POINTER);


        // Since we aren't doing any addition to the number of elements, the
        // Copy command does all the range checking that we need.
        WsbAffirmHr(m_pCollection->Copy(WSB_COLLECTION_MIN_INDEX, element - 1, riid, elements, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = fetched - 1;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::First(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), fetched);

    return(hr);
}


HRESULT
CWsbIndexedEnum::Init(
    IN IWsbCollection* pCollection
    )

/*++

Implements:

  IWsbEnum::Init

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Init"), OLESTR(""));

    try {

        WsbAssert(0 != pCollection, E_POINTER);

        // Only let them initialize the enumeration once.
        WsbAssert(m_pCollection == 0, S_FALSE);
    
        // Since this enum is for indexed collections, get an indexed
        // interface to it.
        WsbAffirmHr(pCollection->QueryInterface(IID_IWsbIndexedCollection, (void**) &m_pCollection));   

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
};
    

HRESULT
CWsbIndexedEnum::Last(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Last

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Last(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // We must have some entries.
        WsbAffirm(entries != 0, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(entries - 1, entries - 1, riid, ppElement, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = entries - fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Last(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Last(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Last

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Last(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssertPointer(pElementsFetched);

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // We must have some entries.
        WsbAffirm(entries != 0, WSB_E_NOTFOUND);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if (element > entries) {
            WsbAffirmHr(m_pCollection->Copy(entries - 1, WSB_COLLECTION_MIN_INDEX, riid, elements, &fetched));

            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(entries - 1, entries - element, riid, elements, &fetched));
        }

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = entries - fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Last(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN ULONG element,
    OUT IUnknown** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IEnumUknown::Next

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IEnumUnknown)"), OLESTR("element = <%lu>"), element);

    hr = Next(element, IID_IUnknown, (void**) elements, pElementsFetched);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IEnumUnknown)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Next

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, m_currentIndex + 1, riid, ppElement, &fetched));

        m_currentIndex += fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Next

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert(0 != element, E_INVALIDARG);
        WsbAssertPointer(pElementsFetched);

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if ((WSB_COLLECTION_MAX_INDEX - m_currentIndex) < element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, m_currentIndex + element, riid, elements, &fetched));
        }

        m_currentIndex += fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Previous(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Previous

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Previous(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(m_currentIndex != WSB_COLLECTION_MIN_INDEX, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, m_currentIndex - 1, riid, ppElement, &fetched));

        m_currentIndex -= fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Previous(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Previous(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    IN ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnum::Previous

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Previous(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssertPointer(pElementsFetched);

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(m_currentIndex != WSB_COLLECTION_MIN_INDEX, WSB_E_NOTFOUND);

        // If they have asked for more elements than are before us in the
        // collection, then don't let the index wrap around.
        if (m_currentIndex < element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, m_currentIndex - element, riid, elements, &fetched));
        }

        m_currentIndex -= fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Previous(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Reset(
    void
    )

/*++

Implements:

  IEnumUnknown::Reset

--*/
{
    HRESULT     hr = S_OK;
  
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Reset"), OLESTR(""));
    
    hr = SkipToFirst();
    
    WsbTraceOut(OLESTR("CWsbIndexedEnum::Reset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(S_OK);
}


HRESULT
CWsbIndexedEnum::Skip(
    IN ULONG element
    )

/*++

Implements:

  IEnumUnknown::Skip

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Skip"), OLESTR("element = <%lu>"), element);
    
    hr = SkipNext(element);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Skip"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipNext(
    IN ULONG element
    )

/*++

Implements:

  IWsbEnum::SkipNext

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipNext"), OLESTR("element = <%lu>"), element);
    
    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // Are we already at the end of the list, or have they requested
        // to go beyond the end of the list?
        else if ((m_currentIndex >= (entries - 1)) ||
                 ((entries - m_currentIndex) < element)) {
            hr = S_FALSE;
            m_currentIndex = entries - 1;
        }

        // They asked for something legal.
        else {
            m_currentIndex += element;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipNext"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipPrevious(
    IN ULONG element
    )

/*++

Implements:

  IWsbEnum::SkipPrevious

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipPrevious"), OLESTR("element = <%lu>"), element);
    
    // If we are already at the beginning of the list, then you can't go any
    // further.
    if (m_currentIndex == WSB_COLLECTION_MIN_INDEX) {
        hr = S_FALSE;
    }

    // If they have asked for more elements than could be represented by
    // then index, then don't let the index wrap around.
    else if (m_currentIndex < element) {
        m_currentIndex = WSB_COLLECTION_MIN_INDEX;
 
        // Let them know that they didn't get all the items they requested.
        hr = S_FALSE;
    }

    // They asked for something legal.
    else {
        m_currentIndex -= element;
    }

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipPrevious"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipTo(
    IN ULONG index
    )

/*++

Implements:

  IWsbEnum::SkipTo

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToIndex"), OLESTR("index = <%lu>"), index);

    try {
        
        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // They asked for something beyond the end of the collection, so
        // put them at the end of the collection and let them now there
        // was a problem.
        else if (index > (entries - 1)) {
            hr = S_FALSE;
            m_currentIndex = entries - 1;
        }

        // They asked for something legal.
        else {
            m_currentIndex = index;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipToFirst(
    void
    )

/*++

Implements:

  IWsbEnum::SkipToFirst

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToFirst"), OLESTR(""));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
        }

        m_currentIndex = WSB_COLLECTION_MIN_INDEX;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToFirst"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipToLast(
    void
    )

/*++

Implements:

  IWsbEnum::SkipToLast

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToLast"), OLESTR(""));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // They asked for something legal.
        else {
            m_currentIndex = entries - 1;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToLast"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::This(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::This

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::This(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        WsbAssert(0 != ppElement, E_POINTER);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex, m_currentIndex, riid, ppElement, &fetched));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::This(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::This(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnum::This

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::This(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert(0 != element, E_INVALIDARG);
        WsbAssertPointer(elements);
        WsbAssertPointer(pElementsFetched);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if ((WSB_COLLECTION_MAX_INDEX - m_currentIndex) <= element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex, WSB_COLLECTION_MAX_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex, m_currentIndex + element - 1, riid, elements, &fetched));
        }

        *pElementsFetched = fetched - 1;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::This(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbenum.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbenum.h

Abstract:

    These classes provides enumerators (iterators) for the collection classes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#if !defined WSBENUM_INCL
#define WSBENUM_INCL

class CWsbIndexedEnum : 
    public IEnumUnknown,
    public IWsbEnum,
    public IWsbEnumEx,
    public CComObjectRoot,
    public CComCoClass<CWsbIndexedEnum,&CLSID_CWsbIndexedEnum>
{
public:
    CWsbIndexedEnum() {}
BEGIN_COM_MAP(CWsbIndexedEnum)
    COM_INTERFACE_ENTRY(IWsbEnum)
    COM_INTERFACE_ENTRY(IWsbEnumEx)
    COM_INTERFACE_ENTRY(IEnumUnknown)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbIndexedEnum)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbEnum
public:
    STDMETHOD(First)(REFIID riid, void** ppElement);
    STDMETHOD(Next)(REFIID riid, void** ppElement);
    STDMETHOD(This)(REFIID riid, void** ppElement);
    STDMETHOD(Previous)(REFIID riid, void** ppElement);
    STDMETHOD(Last)(REFIID riid, void** ppElement);
    
    STDMETHOD(FindNext)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElements);
    STDMETHOD(FindPrevious)(IUnknown* pCollectable, REFIID riid, void** ppElement);

    STDMETHOD(SkipToFirst)(void);
    STDMETHOD(SkipNext)(ULONG element);
    STDMETHOD(SkipTo)(ULONG index);
    STDMETHOD(SkipPrevious)(ULONG element);
    STDMETHOD(SkipToLast)(void);

    STDMETHOD(Init)(IWsbCollection* pCollection);
    STDMETHOD(Clone)(IWsbEnum** ppEnum);
    
// IWsbEnumEx
public:
    STDMETHOD(First)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Next)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(This)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Previous)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Last)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    
    STDMETHOD(FindNext)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);
    STDMETHOD(Find)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);
    STDMETHOD(FindPrevious)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);

    STDMETHOD(Clone)(IWsbEnumEx** ppEnum);
    
// IEnumUnknown
public:
    STDMETHOD(Next)(ULONG element, IUnknown** elements, ULONG* pElementsFetched);
    STDMETHOD(Skip)(ULONG element);
    STDMETHOD(Clone)(IEnumUnknown** ppEnum);

// Shared
public:
    STDMETHOD(Reset)(void);

protected:
    CComPtr<IWsbIndexedCollection>      m_pCollection;
    ULONG                               m_currentIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbfile.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbfile.cpp

Abstract:

    This file implements the common Wsb routines dealing with file operations.

Author:

    Christopher J. Timmes    [ctimmes@avail.com]   23 Jun 1997

Revision History:

    Christopher J. Timmes    [ctimmes@avail.com]   21 July 1997

        - modified function WsbCalcCRCofFile().  Added NT system calls 
          NTQueryInformationFile and NTSetInformationFile so as to preserve the 
          input file's timestamp.  Until this change this function updated the 
          file's Date Last Accessed.

    Christopher J. Timmes    [ctimmes@avail.com]   05 August 1997

        - modified function WsbCalcCRCofFile().  Added doFileRead() function, an 
          extra 'mode' parameter and supporting code to enable WsbCalcCRCofFile() 
          to support 4 different combinations (modes) of file open and read:
          a normal open and sync read, a 'no recall' open and sync read, a 'norecall'
          open and async read, and a 'norecall' open and memory-mapped 'read'.

   Shawn L. Kaczmarek        15 September 1997

      - First set of modifications to 'back out' the file IO wrapper to the CRC
        routine. The tsterror.h is now 'out' as well.

    Shawn L. Kaczmarek          16 Sept 1997

        Moved WsbCalcCRCofFile() and doFileRead() to the item commander class
      in hsmivrfy.cpp ( hsmicmdr.h ). These methods provided the file IO wrappers
      for the CRC method which is retained in here. The CRC look up table is 
      externed with an instantiation in the RsCommon.dll.

    Shawn L. Kaczmarek          17 Sept 1997

        Removed a doFileRead() prototype that remained from prior 'move out' of
      functions.

--*/


#include "stdafx.h"                         // req'd first: common includes
                                            // (including wsb.h, rqd for this)
                                            // (wsb.h includes wsbfile,h, this file's hdr)

// 32-bit CRC table values (256 entries)
unsigned long crc_32_tab[] =
{ /* CRC polynomial 0xedb88320 */
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};



HRESULT
WsbCRCReadFile   (
    IN BYTE* pchCurrent,
    IN OUT ULONG* oldcrc32
    )

/*

Routine Description:

    This routine exists so that any read excpetions triggered by accessing invalid memory
    can be properly caught.
*/ 

{
    HRESULT     hr = S_OK;

    // This call can caused an invalid page to be accessed, so it needs to
    // be done within an exception handling block. It uses different exception handling,
    // so it can not be used in a function with normal try - catch blocks.

    __try {

        // call CRC algorythm, pass in current byte and present CRC value
        CALC_CRC( *pchCurrent, *oldcrc32);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());    \
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbfmt.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbfmt.cpp

Abstract:

    This module implements file-system formatting support routines 

Author:

    Ravisankar Pudipeddi [ravisp] 19, January 2000

Revision History:

--*/


#include <stdafx.h>
extern "C" {
#include <ntdddisk.h>
#include <fmifs.h>
}
#include <wsbfmt.h>


#define MAX_FS_NAME_SIZE      256
#define MAX_PARAMS  20
#define INVALID_KEY 0

typedef struct _FORMAT_PARAMS {
    PWSTR volumeSpec;
    PWSTR label;
    PWSTR fsName;
    LONG  fsType;
    ULONG fsflags;
    ULONG allocationUnitSize; // Cluster size in Bytes
    HRESULT result;
    ULONG   threadId; 
    PFMIFS_ENABLECOMP_ROUTINE compressRoutine;
    PFMIFS_FORMAT_ROUTINE formatRoutine;
    PFMIFS_FORMATEX2_ROUTINE formatRoutineEx;
    BOOLEAN quick;
    BOOLEAN force;
    BOOLEAN cancel;
} FORMAT_PARAMS, *PFORMAT_PARAMS;

typedef struct _FM_ENTRY {
    ULONG key;
    PFORMAT_PARAMS val;
} FM_ENTRY, *PFM_ENTRY;

static  FM_ENTRY formatParamsTable[MAX_PARAMS];
static  PFMIFS_FORMATEX2_ROUTINE FormatRoutineEx = NULL; 
static  PFMIFS_FORMAT_ROUTINE   FormatRoutine = NULL;
static  PFMIFS_SETLABEL_ROUTINE LabelRoutine  = NULL;
static  PFMIFS_ENABLECOMP_ROUTINE  CompressRoutine = NULL;
static  HINSTANCE      IfsDllHandle = NULL;

void MountFileSystem(PWSTR volumeSpec);


HRESULT GetFormatParam(IN ULONG key, OUT PFORMAT_PARAMS *fp)
/*++

Routine Description:

    Returns the format parameter structure indexed by the
    supplied key

Arguments:

    key     - key indexing the format params 
    fp      - pointer to format params returned in this var.

Return Value:
    S_OK if found
    S_FALSE if not

--*/
{
    HRESULT hr = S_FALSE;
    ULONG i;

    WsbTraceIn(OLESTR("GetFormatParam"), OLESTR(""));

    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == key) {
            hr = S_OK;
            *fp = formatParamsTable[i].val;
            break;
        }
    }

    WsbTraceOut(OLESTR("GetFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT SetFormatParam(IN ULONG key, IN PFORMAT_PARAMS fp)
/*++

Routine Description:
    
    Finds a free slot and stores the supplied format params,
    indexed by the key

Arguments:
        key - key indexing the format params
        fp  - pointer to format params

Return Value:

    S_OK            - Found a slot and stored the format params
    E_OUTOFMEMORY   - Couldn't find a slot: too many formats in progress

--*/
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG i;

    WsbTraceIn(OLESTR("SetFormatParam"), OLESTR(""));
    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == INVALID_KEY) {
            hr = S_OK;
            formatParamsTable[i].val = fp;
            formatParamsTable[i].key = key;
            break;
        }
    }

    WsbTraceOut(OLESTR("SetFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT DeleteFormatParam(IN ULONG key) 
/*++

Routine Description:


    Locates the format params indexed by the key, deletes all allocated structures
    and frees up the slot

Arguments:

    key - key indexing the format params

Return Value:


    S_OK   - if format params found and deleted
    E_FAIL - if not
--*/
{
    PFORMAT_PARAMS formatParams;
    HRESULT hr = E_FAIL;
    ULONG i;

    WsbTraceIn(OLESTR("DeleteFormatParam"), OLESTR(""));
    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == key) {
            hr = S_OK;
            formatParams = formatParamsTable[i].val;
            if (formatParams) {
                if (formatParams->volumeSpec) {
                    delete [] formatParams->volumeSpec;
                }
                if (formatParams->label) {
                    delete [] formatParams->label;
                }
                if (formatParams->fsName) {
                    delete [] formatParams->fsName;
                }
            }
            formatParamsTable[i].key = INVALID_KEY;
            formatParamsTable[i].val = NULL;
            break;
        }
    }

    WsbTraceOut(OLESTR("DeleteFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}



BOOL
LoadIfsDll(void)
/*++

Routine Description:

    Loads the FMIFS DLL and stores the handle to it in IfsDllHandle
    Also sets the FormatXXX, LabelXXX, CompressXXX routines 

Arguments:

    None

Return Value:

    TRUE  if dll was loaded successfully
    FALSE if not

--*/
{
    BOOL retVal = TRUE;

    WsbTraceIn(OLESTR("LoadIfsDll"), OLESTR(""));

    if (IfsDllHandle != NULL) {

        // Library is already loaded and the routines needed
        // have been located.

        retVal = TRUE;
        goto exit;
    }

    IfsDllHandle = LoadLibrary(L"fmifs.dll");
    if (IfsDllHandle == (HANDLE)NULL) {
        // FMIFS not available.
        retVal = FALSE;
        goto exit;
    }

    // Library is loaded.  Locate the two routines needed

    FormatRoutineEx = (PFMIFS_FORMATEX2_ROUTINE) GetProcAddress(IfsDllHandle, "FormatEx2");
    FormatRoutine = (PFMIFS_FORMAT_ROUTINE) GetProcAddress(IfsDllHandle, "Format");
    LabelRoutine  = (PFMIFS_SETLABEL_ROUTINE) GetProcAddress(IfsDllHandle, "SetLabel");
    CompressRoutine = (PFMIFS_ENABLECOMP_ROUTINE) GetProcAddress(IfsDllHandle, 
                                                                 "EnableVolumeCompression");
    if (!FormatRoutine || !LabelRoutine || !FormatRoutineEx) {

        // Couldn't find something, so shut down all access 
        // to the library by ensuring FormatRoutine is NULL
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        FormatRoutineEx = NULL;
        LabelRoutine = NULL;
        retVal = FALSE;
    }

exit:

    WsbTraceOut(OLESTR("LoadIfsDll"), OLESTR("result = <%ls>"), WsbBoolAsString(retVal));

    return retVal;
}



void
UnloadIfsDll(void)
/*++

Routine Description:

    Unloads the FMIFS dll

Arguments:

    none

Return Value:

    TRUE if unloaded

--*/
{
    WsbTraceIn(OLESTR("UnloadIfsDll"), OLESTR(""));
    if (IfsDllHandle != (HANDLE) NULL) {
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        FormatRoutineEx = NULL;
        IfsDllHandle  = NULL;
        LabelRoutine  = NULL;
    }
    WsbTraceOut(OLESTR("UnloadIfsDll"), OLESTR(""));
}

BOOL
FmIfsCallback(IN FMIFS_PACKET_TYPE    PacketType,
              IN ULONG                PacketLength,
              IN PVOID                PacketData)
/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format 

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.

--*/
{
    BOOL         ret = TRUE;
    WCHAR        driveName[256];
    PFORMAT_PARAMS  formatParams;

    UNREFERENCED_PARAMETER(PacketLength);

    WsbTraceIn(OLESTR("FmIfsCallback"), OLESTR(""));

    if (GetFormatParam(GetCurrentThreadId(), &formatParams) != S_OK) {
        formatParams->result = E_FAIL;
        goto exit; 
    }
    //
    // Cancel if needed
    //
    if (formatParams->cancel) {
        formatParams->result = E_ABORT;
    } else {

        switch (PacketType) {
        case FmIfsPercentCompleted:
            if (((PFMIFS_PERCENT_COMPLETE_INFORMATION)
                 PacketData)->PercentCompleted % 10 == 0) {
                WsbTrace(L"FmIfsPercentCompleted: %d%%\n",
                        ((PFMIFS_PERCENT_COMPLETE_INFORMATION)
                         PacketData)->PercentCompleted);
            }
            break;

        case FmIfsFormatReport:
            WsbTrace(OLESTR("Format total kB: %d  available kB %d\n"),
                    ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesTotalDiskSpace,
                    ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesAvailable);
            break;

        case FmIfsIncompatibleFileSystem:
            formatParams->result = WSB_E_INCOMPATIBLE_FILE_SYSTEM;
            break;

        case FmIfsInsertDisk:
            break;

        case FmIfsFormattingDestination:
            break;

        case FmIfsIncompatibleMedia:
            formatParams->result = WSB_E_BAD_MEDIA;
            break;

        case FmIfsAccessDenied:
            formatParams->result = E_ACCESSDENIED;
            break;

        case FmIfsMediaWriteProtected:
            formatParams->result = WSB_E_WRITE_PROTECTED;
            break;

        case FmIfsCantLock:
            formatParams->result = WSB_E_CANT_LOCK;
            break;

        case FmIfsBadLabel:
            formatParams->result = WSB_E_BAD_LABEL;
            break;

        case FmIfsCantQuickFormat:
            formatParams->result = WSB_E_CANT_QUICK_FORMAT;
            break;

        case FmIfsIoError:
            formatParams->result = WSB_E_IO_ERROR;
            break;

        case FmIfsVolumeTooSmall:
            formatParams->result = WSB_E_VOLUME_TOO_SMALL;
            break;

        case FmIfsVolumeTooBig:
            formatParams->result = WSB_E_VOLUME_TOO_BIG;
            break;

        case FmIfsClusterSizeTooSmall:
            formatParams->result = E_FAIL;
            break;

        case FmIfsClusterSizeTooBig:
            formatParams->result = E_FAIL;
            break;

        case FmIfsClustersCountBeyond32bits:
            formatParams->result = E_FAIL;
            break;

        case FmIfsFinished:

            if (formatParams->result == S_OK) {
                ret = ((PFMIFS_FINISHED_INFORMATION) PacketData)->Success;
                if (ret) {
                    MountFileSystem(formatParams->volumeSpec);
                    WsbTrace(OLESTR("Format finished for %S filesystem on %S label %S\n"),
                            formatParams->fsName, formatParams->volumeSpec, formatParams->label );
                    if ((formatParams->compressRoutine != NULL) && !wcscmp(formatParams->fsName , L"NTFS") && (formatParams->fsflags & WSBFMT_ENABLE_VOLUME_COMPRESSION)) {
                        swprintf(driveName, L"%s\\", formatParams->volumeSpec);
                            (formatParams->compressRoutine)(driveName, COMPRESSION_FORMAT_DEFAULT);                         
                    }
                } else {
                   WsbTrace(OLESTR("Format finished failure with ret = %d\n"),ret);
                   formatParams->result = WSB_E_FORMAT_FAILED;
                }
                ret = FALSE;
            }
            break;

        default:
            break;
        }
    }
    
exit:

    if (formatParams->result != S_OK) {
        ret = FALSE;
    }

    WsbTraceOut(OLESTR("FmIfsCallback"), OLESTR("result = <%ls>"), WsbBoolAsString(ret));
    return ret;
}



void
MountFileSystem(PWSTR mountPoint)
/*++

Routine Description:


  Ensures a filesystem  is mounted at the given root:
  a) Opens the mount point and closes it.
  b) Does a FindFirstFile on the mount point
 
  The latter may sound redundant but is not because if we create the first
  FAT32 filesystem then just opening and closing is not enough
 

Arguments:

    mountPoint -  path name to the root of filesystem to be mounted

Return Value:
        
    none

--*/
{
    WCHAR buffer[1024];
    HANDLE handle;
    WIN32_FIND_DATA fileData;

    WsbTraceIn(OLESTR("MountFileSystem"), OLESTR(""));

    handle = CreateFile(mountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    0, OPEN_EXISTING, 0, 0);
    if (handle != INVALID_HANDLE_VALUE)
        CloseHandle(handle);
    swprintf(buffer,L"%s\\*.*",mountPoint);
    /*
     * Go ahead and try to find the first file, this will make sure that
     * the file system is mounted
     */
    handle = FindFirstFile(buffer, &fileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose(handle);
    }
    WsbTraceOut(OLESTR("MountFileSystem"), OLESTR(""));
}


void
FormatVolume(IN PFORMAT_PARAMS params)
/*++

Routine Description:

    This routine format the volume described by params

Arguments:

    params - pointer to the FORMAT_PARAMS describing the volume,
             file system to be formatted to, quick/force etc.

Return Value:

    None. 
    params->result contains the result of this operation

--*/
{
    FMIFS_FORMATEX2_PARAM exParam;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("FormatVolume"), OLESTR(""));
    /*
     * Get the object corresponding to the storage Id and
     * and notify all clients that the region has changed
     * i.e. there is a format in progress on that region
     */
     memset(&exParam, 0, sizeof(exParam));
     exParam.Major = 1;
     exParam.Minor = 0;
     if (params->quick) {
        exParam.Flags |= FMIFS_FORMAT_QUICK;
     }
     if (params->force) {
        exParam.Flags |= FMIFS_FORMAT_FORCE;
     }
     exParam.LabelString = params->label;
     exParam.ClusterSize = params->allocationUnitSize;
     (params->formatRoutineEx)(params->volumeSpec,
                               FmMediaUnknown,
                               params->fsName,
                               &exParam,
                              (FMIFS_CALLBACK)&FmIfsCallback);

    if (params->result == NULL) {
        /* Format is successful so we lock unlock the filesystem */
        MountFileSystem(params->volumeSpec);
    }
    DeleteFormatParam(params->threadId);
    WsbTraceOut(OLESTR("FormatVolume"), OLESTR(""));
}


HRESULT
FormatPartition(IN PWSTR volumeSpec, 
                IN LONG fsType, 
                IN PWSTR label,
                IN ULONG fsflags, 
                IN BOOLEAN quick, 
                IN BOOLEAN force,
                IN ULONG allocationUnitSize)
/*++

Routine Description:


    Entry point for formatting a volume. 
    No defaults are assumed and all parameters need to be supplied

Arguments:

    volumeSpec  - Drive letter or name of volume
    fsType      - One of FSTYPE_FAT, FSTYPE_FAT32, FSTYE_NTFS
    label       - Volume label to be assigned to the partition/volume
    fsflags     - Flags describing desired characteristics
    quick       - If TRUE, a quick format is attempted
    force       - If TRUE a force format is done
    allocationUnitSize - 
                 cluster size   

Return Value:

    Result of the operation

--*/
{
    FORMAT_PARAMS   params;

    WsbTraceIn(OLESTR("FormatPartition"), OLESTR(""));

    if (fsType > 0 && !LoadIfsDll()) // fsType is +ve for FAT, FAT32 and NTFS which are supported by fmifs
    {
        // could not load the Dll
        WsbTrace(OLESTR("Can't load fmifs.dll\n"));
        return E_FAIL;
    }

    params.volumeSpec = new WCHAR[wcslen(volumeSpec) + 1];
    if (params.volumeSpec == NULL) {
        return E_OUTOFMEMORY;
    }

    params.label = new WCHAR[wcslen(label) + 1];
    if (params.label == NULL) {
        delete [] params.volumeSpec;
        return E_OUTOFMEMORY;
    }
    params.fsName = new WCHAR[MAX_FS_NAME_SIZE];
    if (params.fsName == NULL) {
        delete [] params.volumeSpec;
        delete [] params.label;
        return E_OUTOFMEMORY;
    }

    if (fsType > 0) {
        wcscpy(params.fsName, (fsType == FSTYPE_FAT ? L"FAT" :
                               (fsType == FSTYPE_FAT32 ? L"FAT32" : L"NTFS")));
    }

    wcscpy(params.volumeSpec, volumeSpec);
    wcscpy(params.label, label);
    params.fsType = fsType;
    params.fsflags = fsflags;
    params.allocationUnitSize = allocationUnitSize;
    params.quick = quick;
    params.force = force;
    params.result = S_OK;
    params.cancel = FALSE;
    params.formatRoutine = FormatRoutine;
    params.formatRoutineEx = FormatRoutineEx;
    params.compressRoutine = CompressRoutine;
    params.threadId = GetCurrentThreadId();

    if (SetFormatParam(params.threadId, &params) != S_OK) {
            delete [] params.label;
            delete [] params.volumeSpec;
            delete [] params.fsName;
            return E_OUTOFMEMORY;
    };

    FormatVolume(&params);

    WsbTraceOut(OLESTR("FormatPartition"), OLESTR("result = <%ls>"), WsbHrAsString(params.result));
    return params.result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbguid.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbguid.cpp

Abstract:

    This component is an object representations of the GUID standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbguid.h"


HRESULT
CWsbGuid::CompareToGuid(
    IN GUID value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbGuid::CompareToGuid

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbGuid::CompareToGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    // Compare.
    result = WsbSign( memcmp(&m_value, &value, sizeof(GUID)) );

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbGuid::CompareToGuid"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbGuid::CompareToIGuid(
    IN IWsbGuid* pGuid,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbGuid::CompareToIGuid

--*/
{
    HRESULT     hr = E_FAIL;
    GUID        value;

    WsbTraceIn(OLESTR("CWsbGuid::CompareToIGuid"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pGuid, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pGuid->GetGuid(&value));
        hr = CompareToGuid(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::CompareToIGuid"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbGuid::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbGuid*   pGuid;

    WsbTraceIn(OLESTR("CWsbGuid::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbGuid interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbGuid, (void**) &pGuid));

        hr = CompareToIGuid(pGuid, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbGuid::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = GUID_NULL;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbGuid::GetGuid(
    OUT GUID* pValue
    )

/*++

Implements:

  IWsbGuid::GetGuid

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetGuid"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetGuid"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(m_value));
    
    return(hr);
}


HRESULT
CWsbGuid::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbGuid;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbGuid::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(GUID);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbGuid::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(m_value));

    return(hr);
}


HRESULT
CWsbGuid::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbGuid::SetGuid(
    IN GUID value
    )

/*++

Implements:

  IWsbGuid::SetGuid

--*/
{
    WsbTraceIn(OLESTR("CWsbGuid::SetGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbGuid::SetGuid"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbGuid::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbGuid>       pGuid1;
    CComPtr<IWsbGuid>       pGuid2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    GUID                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbGuid::Test"), OLESTR(""));

    try {

        // Get the pGuid interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbGuid*) this)->QueryInterface(IID_IWsbGuid, (void**) &pGuid1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                WsbAffirmHr(pGuid1->GetGuid(&value));
                WsbAssert(value == CLSID_CWsbGuid, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid2->GetGuid(&value));
                    WsbAssert(value == GUID_NULL, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert(pGuid1->IsEqual(pGuid2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(IID_IWsbGuid));
                    WsbAssert(pGuid1->IsEqual(pGuid2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(IID_IWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(IID_IWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef GUID_PERSIST_FILE
// TODO? Open the file and convert to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pGuid2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbGuid.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pGuid1->SetGuid(IID_IWsbGuid));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbGuid.tst"), 0));
                        WsbAssert(pGuid1->CompareToGuid(CLSID_CWsbGuid, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbllong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbllong.h

Abstract:

    This component is an object representations of the LONGLONG standard type. It
    is both a persistable and collectable.

Author:

    Ron White   [ronw]   21-Jan-97

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBLONGLONG_
#define _WSBLONGLONG_


/*++

Class Name:
    
    CWsbLonglong

Class Description:

    An object representations of the LONGLONG standard type. It
    is both persistable and collectable.

--*/
class CWsbLonglong : 
    public CWsbObject,
    public IWsbLonglong,
    public CComCoClass<CWsbLonglong,&CLSID_CWsbLonglong>
{
public:
    CWsbLonglong() {}
BEGIN_COM_MAP(CWsbLonglong)
    COM_INTERFACE_ENTRY(IWsbLonglong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbLonglong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbLonglong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbLonglong
public:
    STDMETHOD(CompareToLonglong)(LONGLONG value, SHORT* pResult);
    STDMETHOD(CompareToILonglong)(IWsbLonglong* pValue, SHORT* pResult);
    STDMETHOD(GetLonglong)(LONGLONG* pValue);
    STDMETHOD(SetLonglong)(LONGLONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    LONGLONG            m_value;
};

#endif // _WSBLONGLONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbguid.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbguid.h

Abstract:

    This component is an object representations of the GUID standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBGUID_
#define _WSBGUID_


/*++

Class Name:
    
    CWsbGuid

Class Description:

    An object representations of the GUID standard type. It
    is both persistable and collectable.

--*/
class CWsbGuid : 
    public CWsbObject,
    public IWsbGuid,
    public CComCoClass<CWsbGuid,&CLSID_CWsbGuid>
{
public:
    CWsbGuid() {}
BEGIN_COM_MAP(CWsbGuid)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbGuid)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbGuid)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbGuid)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbGuid
public:
    STDMETHOD(CompareToGuid)(GUID value, SHORT* pResult);
    STDMETHOD(CompareToIGuid)(IWsbGuid* pGuid, SHORT* pResult);
    STDMETHOD(GetGuid)(GUID* pValue);
    STDMETHOD(SetGuid)(GUID value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    GUID            m_value;
};

#endif // _WSBGUID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsblong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsblong.h

Abstract:

    This component is an object representations of the LONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsb.h"
#include "wsbcltbl.h"

#ifndef _WSBLONG_
#define _WSBLONG_


/*++

Class Name:
    
    CWsbLong

Class Description:

    An object representations of the LONG standard type. It
    is both persistable and collectable.

--*/

class CWsbLong : 
    public CWsbObject,
    public IWsbLong,
    public CComCoClass<CWsbLong,&CLSID_CWsbLong>
{
public:
    CWsbLong() {}
BEGIN_COM_MAP(CWsbLong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbLong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbLong)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbLong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbLong
public:
    STDMETHOD(CompareToLong)(LONG value, SHORT* pResult);
    STDMETHOD(CompareToILong)(IWsbLong* pLong, SHORT* pResult);
    STDMETHOD(GetLong)(LONG* pValue);
    STDMETHOD(SetLong)(LONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    LONG            m_value;
};

#endif // _WSBLONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbllong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbllong.cpp

Abstract:

    This component is an object representations of the LONGLONG standard type. It
    is both a persistable and collectable.

Author:

    Ron White   [ronw]   21-Jan-97

Revision History:

--*/

#include "stdafx.h"

#include "wsbllong.h"


HRESULT
CWsbLonglong::CompareToLonglong(
    IN LONGLONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLonglong::CompareToLonglong

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareToLonglong"), 
            OLESTR("m_value = <%ls>, value = <%ls>"), 
            WsbLonglongAsString(m_value), WsbLonglongAsString(value));

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbLonglong::CompareToLonglong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbLonglong::CompareToILonglong(
    IN IWsbLonglong* pLonglong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLonglong::CompareToILonglong

--*/
{
    HRESULT     hr = E_FAIL;
    LONGLONG        value;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareToILonglong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pLonglong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pLonglong->GetLonglong(&value));
        hr = CompareToLonglong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::CompareToILonglong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLonglong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbLonglong*   pLonglong;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbLonglong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbLonglong, (void**) &pLonglong));

        hr = CompareToILonglong(pLonglong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLonglong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = 0;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbLonglong::GetLonglong(
    OUT LONGLONG* pValue
    )

/*++

Implements:

  IWsbLonglong::GetLonglong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetLonglong"), OLESTR("m_value = <%ls>"),
            WsbLonglongAsString(m_value));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetLonglong"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbLonglong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbLonglong;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(LONGLONG);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbLonglong::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::SetLonglong(
    IN LONGLONG value
    )

/*++

Implements:

  IWsbLonglong::SetLonglong

--*/
{
    WsbTraceIn(OLESTR("CWsbLonglong::SetLonglong"), OLESTR("value = <%ls>"),
            WsbLonglongAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbLonglong::SetLonglong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbLonglong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbLonglong>   pLonglong1;
    CComPtr<IWsbLonglong>   pLonglong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    LONGLONG                value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbLonglong::Test"), OLESTR(""));

    try {

        // Get the pLonglong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbLonglong*) this)->QueryInterface(IID_IWsbLonglong, (void**) &pLonglong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pLonglong1->SetLonglong(0xefffffff));
                WsbAffirmHr(pLonglong1->GetLonglong(&value));
                WsbAssert(value == 0xefffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbLonglong, NULL, CLSCTX_ALL, IID_IWsbLonglong, (void**) &pLonglong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong2->GetLonglong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-767));
                    WsbAffirmHr(pLonglong2->SetLonglong(-767));
                    WsbAssert(pLonglong1->IsEqual(pLonglong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(767));
                    WsbAffirmHr(pLonglong2->SetLonglong(-767));
                    WsbAssert(pLonglong1->IsEqual(pLonglong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-900));
                    WsbAffirmHr(pLonglong2->SetLonglong(-900));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-900));
                    WsbAffirmHr(pLonglong2->SetLonglong(-400));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(75000));
                    WsbAffirmHr(pLonglong2->SetLonglong(20000));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pLonglong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLonglong2->SetLonglong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbLonglong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLonglong1->SetLonglong(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbLonglong.tst"), 0));
                        WsbAssert(pLonglong1->CompareToLonglong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbport.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbPort.cpp

Abstract:

    Macros, functions, and classes to support portability.

Author:

    Ron White   [ronw]   19-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbport.h"


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    BOOL*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a BOOL value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array.

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(BOOL)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(1 == WSB_BYTE_SIZE_BOOL, E_UNEXPECTED);

        if (*pBytes) {
            *pValue = TRUE;
        } else {
            *pValue = FALSE;
        }
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_BOOL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    GUID*   pValue,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a GUID value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 16 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(GUID)"), OLESTR(""));

    try {
        ULONG lsize;
        ULONG tsize;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &pValue->Data1, &lsize));
        tsize = lsize;
        WsbAffirmHr(WsbConvertFromBytes(pBytes + tsize, &pValue->Data2, &lsize));
        tsize += lsize;
        WsbAffirmHr(WsbConvertFromBytes(pBytes + tsize, &pValue->Data3, &lsize));
        tsize += lsize;
        memcpy(pValue->Data4, pBytes + tsize, 8);
        tsize += 8;
        if (pSize) {
            *pSize = tsize;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    LONG*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a LONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 4 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(LONG)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_LONG, E_UNEXPECTED);

        *pValue = (pBytes[0] << 24) | (pBytes[1] << 16) |
                (pBytes[2] << 8) | pBytes[3];
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_LONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    LONGLONG* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a LONGLONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(LONGLONG)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
        LONGLONG    ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        ll = (LONGLONG) ul;
        *pValue = ll << 32;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        ll = (LONGLONG) ul;
        *pValue |= ll;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    ULONGLONG* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a ULONGLONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULONGLONG)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
        LONGLONG    ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        ll = (ULONGLONG) ul;
        *pValue = ll << 32;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        ll = (ULONGLONG) ul;
        *pValue |= ll;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    DATE*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a DATE value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(DATE)"), OLESTR(""));

    try {
        LONGLONG  ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(WSB_BYTE_SIZE_DATE == WSB_BYTE_SIZE_LONGLONG, E_UNEXPECTED);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ll, NULL));
        *pValue = (DATE) ll;

        if (pSize) {
            *pSize = WSB_BYTE_SIZE_DATE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    FILETIME* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a FILETIME value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(FILETIME)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        pValue->dwHighDateTime = ul;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pValue->dwLowDateTime = ul;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    SHORT*  pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a SHORT value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 2 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(SHORT)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_SHORT, E_UNEXPECTED);

        *pValue = (SHORT)( (pBytes[0] << 8) | pBytes[1] );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_SHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    ULARGE_INTEGER* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a ULARGE_INTEGER value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULARGE_INTEGER)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        pValue->HighPart = ul;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pValue->LowPart = ul;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    ULONG*  pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a ULONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 4 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULONG)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_ULONG, E_UNEXPECTED);

        *pValue = (pBytes[0] << 24) | (pBytes[1] << 16) |
                (pBytes[2] << 8) | pBytes[3];
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_ULONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    USHORT* pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a USHORT value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 2 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(USHORT)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_USHORT, E_UNEXPECTED);

        *pValue = (USHORT)( ( pBytes[0] << 8 ) | pBytes[1] );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_USHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    BOOL    value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a BOOL value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array.

    value  - The BOOL value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(BOOL)"), OLESTR("value = <%s>"), 
            WsbBoolAsString(value));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(1 == WSB_BYTE_SIZE_BOOL, E_UNEXPECTED);

        if (value) {
            *pBytes = 1;
        } else {
            *pBytes = 0;
        }
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_BOOL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    GUID    value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a GUID value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 16 bytes long).

    value  - The GUID value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(GUID)"), OLESTR("value = <%s>"), 
            WsbGuidAsString(value));

    try {
        ULONG lsize;
        ULONG tsize;
    
        WsbAssert(0 != pBytes, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(pBytes, value.Data1, &lsize));
        tsize = lsize;
        WsbAffirmHr(WsbConvertToBytes(pBytes + tsize, value.Data2, &lsize));
        tsize += lsize;
        WsbAffirmHr(WsbConvertToBytes(pBytes + tsize, value.Data3, &lsize));
        tsize += lsize;
        memcpy(pBytes + tsize, value.Data4, 8);
        tsize += 8;
        if (pSize) {
            *pSize = tsize;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    LONG   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a LONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 4 bytes long).

    value  - The LONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(LONG)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_LONG, E_UNEXPECTED);

        pBytes[0] = ((UCHAR)(value >> 24));
        pBytes[1] = ((UCHAR)((value >> 16) & 0xFF));
        pBytes[2] = ((UCHAR)((value >> 8) & 0xFF));
        pBytes[3] = ((UCHAR)(value & 0xFF));
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_LONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    LONGLONG value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a LONGLONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The LONGLONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(LONGLONG)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULONGLONG value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULONGLONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The LONGLONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULONGLONG)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    DATE    value,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a DATE value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The DATE value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(DATE)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(WSB_BYTE_SIZE_DATE == WSB_BYTE_SIZE_LONGLONG, E_UNEXPECTED);

        // Needs to modified after WsbDate functions.
        WsbAffirmHr(WsbConvertToBytes(pBytes, (LONGLONG) value, NULL));

        if (pSize) {
            *pSize = WSB_BYTE_SIZE_DATE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    FILETIME value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a FILETIME value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The FILETIME value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(FILETIME)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
    
        WsbAssert(0 != pBytes, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(pBytes, value.dwHighDateTime, &size));
        total += size;
        pBytes += size;
        WsbAffirmHr(WsbConvertToBytes(pBytes, value.dwLowDateTime, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    SHORT   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a SHORT value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 2 bytes long).

    value  - The SHORT value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(SHORT)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_SHORT, E_UNEXPECTED);

        pBytes[0] = (UCHAR)( (value >> 8) & 0xFF);
        pBytes[1] = (UCHAR)( value & 0xFF );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_SHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULARGE_INTEGER value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULARGE_INTEGER value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The ULARGE_INTEGER value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULARGE_INTEGER)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value.QuadPart >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value.QuadPart & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULONG   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 4 bytes long).

    value  - The ULONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULONG)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_ULONG, E_UNEXPECTED);

        pBytes[0] = ((UCHAR)(value >> 24));
        pBytes[1] = ((UCHAR)((value >> 16) & 0xFF));
        pBytes[2] = ((UCHAR)((value >> 8) & 0xFF));
        pBytes[3] = ((UCHAR)(value & 0xFF));
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_ULONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    USHORT  value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a USHORT value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 2 bytes long).

    value  - The USHORT value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(USHORT)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_USHORT, E_UNEXPECTED);

        pBytes[0] = (UCHAR)( ( value >> 8 ) & 0xFF );
        pBytes[1] = (UCHAR)( value & 0xFF );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_USHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbOlestrFromBytes(
    UCHAR*    pBytes,
    OLECHAR*  pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a OLECHAR string from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array.

    pValue - Pointer to the returned string.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbOlestrFromBytes(OLECHAR)"), OLESTR(""));

    try {
        ULONG size = 0;

        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == 2, E_FAIL);
        while (TRUE) {
            OLECHAR wc;

            wc = (OLECHAR)( (*pBytes++) << 8 );
            wc |= *pBytes++;
            size += 2;
            *pValue++ = wc;
            if (wc == 0) break;
        }
        if (pSize) {
            *pSize = size;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbOlestrFromBytes(OLECHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbOlestrToBytes(
    UCHAR*   pBytes,
    OLECHAR* pValue,
    ULONG*   pSize
    )

/*++


Routine Description:

    Convert a OLECHAR sring to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must long enough).

    pValue - The OLECHAR string to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbOlestrToBytes(OLECHAR)"), OLESTR("value = <%S>"), pValue);

    try {
        ULONG size = 0;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == 2, E_FAIL);

        while (TRUE) {
            OLECHAR wc;

            wc = *pValue++;
            *pBytes++ = (UCHAR)( ( wc >> 8 ) & 0xFF );
            *pBytes++ = (UCHAR)( wc & 0xFF );
            size += 2;
            if (wc == 0) break;
        }
        if (pSize) {
            *pSize = size;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbOlestrToBytes(OLECHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbhash.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Wsbhash.cpp

Abstract:

    Some functions for hashing text strings and creating DB keys from
    file path names.

    NOTE: Since no one needed this code by the time I got it done, it
    hasn't been tested!

Author:

    Ron White   [ronw]   25-Apr-1997

Revision History:

--*/

#include "stdafx.h"

// This pseudorandom permutation table (used by the SimpleHash function below)
// is taken from the article referenced in the comments for that function.
static UCHAR perm_table[] = {
      1,  87,  49,  12, 176, 178, 102, 166, 121, 193,   6,  84, 249, 230,  44, 163,
     14, 197, 213, 181, 161,  85, 218,  80,  64, 239,  24, 226, 236, 142,  38, 200,
    110, 177, 104, 103, 141, 253, 255,  50,  77, 101,  81,  18,  45,  96,  31, 222,
     25, 107, 190,  70,  86, 237, 240,  34,  72, 242,  20, 214, 244, 227, 149, 235,
     97, 234,  57,  22,  60, 250,  82, 175, 208,   5, 127, 199, 111,  62, 135, 248,
    174, 169, 211,  58,  66, 154, 106, 195, 245, 171,  17, 187, 182, 179,   0, 243,
    132,  56, 148,  75, 128, 133, 158, 100, 130, 126,  91,  13, 153, 246, 216, 219,
    119,  68, 223,  78,  83,  88, 201,  99, 122,  11,  92,  32, 136, 114,  52,  10,
    138,  30,  48, 183, 156,  35,  61,  26, 143,  74, 251,  94, 129, 162,  63, 152,
    170,   7, 115, 167, 241, 206,   3, 150,  55,  59, 151, 220,  90,  53,  23, 131,
    125, 173,  15, 238,  79,  95,  89,  16, 105, 137, 225, 224, 217, 160,  37, 123,
    118,  73,   2, 157,  46, 116,   9, 145, 134, 228, 207, 212, 202, 215,  69, 229,
     27, 188,  67, 124, 168, 252,  42,   4,  29, 108,  21, 247,  19, 205,  39, 203,
    233,  40, 186, 147, 198, 192, 155,  33, 164, 191,  98, 204, 165, 180, 117,  76,
    140,  36, 210, 172,  41,  54, 159,   8, 185, 232, 113, 196, 231,  47, 146, 120,
     51,  65,  28, 144, 254, 221,  93, 189, 194, 139, 112,  43,  71, 109, 184, 209
};

//  Local functions
static HRESULT ProgressiveHash(WCHAR* pWstring, ULONG nChars, UCHAR* pKey, 
        ULONG keySize, ULONG* pKeyCount);
static UCHAR SimpleHash(UCHAR* pString, ULONG count);


//  ProgressiveHash - hash a wide-character string into a byte key of a given
//  maximum size.  The string is limited to 32K characters (64K bytes) and the
//  key size must be at least 16. 
//
//  The algorithm starts out merely XORing the two bytes of each character into a
//  single byte in the key.  If it must use the last 15 bytes of the key, it begins
//  using the SimpleHash function to hash progressively larger (doubling) chuncks
//  of the string into a single byte.
//
//  This method is used to try and preserve as much information about short strings
//  as possible; to preserve, to some extent, the sort order of strings; and to
//  compress long strings into a reasonably sized key. It is assumed (perhaps
//  incorrectly) that many of the characters will be ANSI characters an so the
//  XOR of the bytes in the initial part of the string won't lose any information.

static HRESULT ProgressiveHash(WCHAR* pWstring, ULONG nChars, UCHAR* pKey, 
        ULONG keySize, ULONG* pKeyCount)
{
    HRESULT hr = S_OK;

    try {
        ULONG   chunk;           // Current chunk size
        ULONG   headSize;
        ULONG   keyIndex = 0;    // Current index into the key
        UCHAR*  pBytes;          // Byte pointer into the string
        ULONG   remains;         // Bytes remaining in the string

        //  Check arguments
        WsbAffirm(NULL != pWstring, E_POINTER);
        WsbAffirm(NULL != pKey, E_POINTER);
        remains = nChars * 2;
        WsbAffirm(65536 >= remains, E_INVALIDARG);
        WsbAffirm(15 < keySize, E_INVALIDARG);

        //  Do the non-progressive part
        pBytes = (UCHAR*)pWstring;
        headSize = keySize - 15;
        while (remains > 0 && keyIndex < headSize) {
            pKey[keyIndex++] = (UCHAR) ( *pBytes ^ *(pBytes + 1) );
            pBytes += 2;
            remains -= 2;
        }

        //  Do the progressive part
        chunk = 4;
        while (remains > 0) {
            if (chunk > remains) {
                chunk = remains;
            }
            pKey[keyIndex++] = SimpleHash(pBytes, chunk);
            pBytes += chunk;
            remains -= chunk;
            chunk *= 2;
        }

        if (NULL != pKeyCount) {
            *pKeyCount = keyIndex;
        }
    } WsbCatch(hr);

    return(hr);
}


//  SimpleHash - hash a string of bytes into a single byte.
//
//  This algorithm and the permutation table come from the article "Fast Hashing
//  of Variable-Length Text Strings" in the June 1990 (33, 6) issue of Communications
//  of the ACM (CACM).
//  NOTE: For a hash value larger than one byte, the article suggests hashing the
//  original string with this function to get one byte, adding 1 (mod 256) to the
//  first byte of the string and hashing the new string with this function to get
//  the second byte, etc.

static UCHAR SimpleHash(UCHAR* pString, ULONG count)
{
    int h = 0;

    for (ULONG i = 0; i < count; i++) {
        h = perm_table[h ^ pString[i]];
    }
    return((UCHAR)h);
}

//  SquashFilepath - compress a file path name into a (possibly) shorter key.
//
//  This function splits the key into a path part (about 3/4 of the initial
//  bytes of the key) and a file name part (the rest of the key).  For each
//  part it uses the ProgressiveHash function to compress the substring.

//  This function attempts to preserve enough information in the key that keys
//  will be sorted in approximately the same order as the original path names
//  and it is unlikely (though not impossible) that two different paths would
//  result in the same key.  Both of these are dependent on the size of the key.
//  A reasonable size is probably 128 bytes, which gives 96 bytes for the path
//  and 32 bytes for the file name.  A key size of 64 or less will fail because
//  the file name part will be too small for the Progressive Hash function.

HRESULT SquashFilepath(WCHAR* pWstring, UCHAR* pKey, ULONG keySize)
{
    HRESULT hr = S_OK;

    try {
        ULONG  keyIndex;
        ULONG  nChars;
        WCHAR* pFilename;
        ULONG  pathKeySize;

        //  Check arguments
        WsbAffirm(NULL != pWstring, E_POINTER);
        WsbAffirm(NULL != pKey, E_POINTER);
        WsbAffirm(60 < keySize, E_INVALIDARG);

        //  Calculate some initial values
        pFilename = wcsrchr(pWstring, WCHAR('\\'));
        if (NULL == pFilename) {
            nChars = 0;
            pFilename = pWstring;
        } else {
            nChars = (ULONG)(pFilename - pWstring);
            pFilename++;
        }
        pathKeySize = (keySize / 4) * 3;

        //  Compress the path
        if (0 < nChars) {
            WsbAffirmHr(ProgressiveHash(pWstring, nChars, pKey, pathKeySize,
                    &keyIndex));
        } else {
            keyIndex = 0;
        }

        //  Fill the rest of the path part of the key with zeros
        for ( ; keyIndex < pathKeySize; keyIndex++) {
            pKey[keyIndex] = 0;
        }

        //  Compress the file name
        nChars = wcslen(pFilename);
        if (0 < nChars) {
            WsbAffirmHr(ProgressiveHash(pFilename, nChars, &pKey[keyIndex],
                    keySize - pathKeySize, &keyIndex));
            keyIndex += pathKeySize;
        }

        //  Fill the rest of the file name part of the key with zeros
        for ( ; keyIndex < keySize; keyIndex++) {
            pKey[keyIndex] = 0;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsblong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsblong.cpp

Abstract:

    This component is an object representations of the LONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsblong.h"


HRESULT
CWsbLong::CompareToLong(
    IN LONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLong::CompareToLong

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbLong::CompareToLong"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbLong::CompareToLong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbLong::CompareToILong(
    IN IWsbLong* pLong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLong::CompareToILong

--*/
{
    HRESULT     hr = E_FAIL;
    LONG        value;

    WsbTraceIn(OLESTR("CWsbLong::CompareToILong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pLong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pLong->GetLong(&value));
        hr = CompareToLong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::CompareToILong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbLong*   pLong;

    WsbTraceIn(OLESTR("CWsbLong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbLong, (void**) &pLong));
        hr = CompareToILong(pLong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbLong::GetLong(
    OUT LONG* pValue
    )

/*++

Implements:

  IWsbLong::GetLong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetLong"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetLong"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbLong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbLong;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbLong::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(LONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbLong::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbLong::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLong::SetLong(
    LONG value
    )

/*++

Implements:

  IWsbLong::SetLong

--*/
{
    WsbTraceIn(OLESTR("CWsbLong::SetLong"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbLong::SetLong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbLong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbLong>       pLong1;
    CComPtr<IWsbLong>       pLong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    LONG                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbLong::Test"), OLESTR(""));

    try {

        // Get the pLong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbLong*) this)->QueryInterface(IID_IWsbLong, (void**) &pLong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pLong1->SetLong(0xefffffff));
                WsbAffirmHr(pLong1->GetLong(&value));
                WsbAssert(value == 0xefffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, IID_IWsbLong, (void**) &pLong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong2->GetLong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-767));
                    WsbAffirmHr(pLong2->SetLong(-767));
                    WsbAssert(pLong1->IsEqual(pLong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(767));
                    WsbAffirmHr(pLong2->SetLong(-767));
                    WsbAssert(pLong1->IsEqual(pLong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-900));
                    WsbAffirmHr(pLong2->SetLong(-900));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-900));
                    WsbAffirmHr(pLong2->SetLong(-400));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(75000));
                    WsbAffirmHr(pLong2->SetLong(20000));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pLong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLong2->SetLong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbLong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLong1->SetLong(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbLong.tst"), 0));
                        WsbAssert(pLong1->CompareToLong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\wsb\wsbpstbl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbpstbl.cpp

Abstract:

    Abstract classes that provides persistence methods.


Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"

#include "wsbport.h"
#include "wsbpstbl.h"
#include "wsbtrak.h"

#define BYTE_SIZE           64          // Larger than largest BYTE_SIZE_*
#define PERSIST_CHECK_VALUE 0x456D5377  // ASCII: "EmSw" (Eastman Software)

//  Local functions
static BOOL WsbFileExists(OLECHAR* pFileName);


// ******** CWsbPersistStream ************

#pragma optimize("g", off)

HRESULT
CWsbPersistStream::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        // Initialize some member data.
        m_isDirty       = TRUE;

        //  Add class to object table
        GUID guid;
        if (S_OK != GetClassID(&guid)) {
            guid = GUID_NULL;
        }
        WSB_OBJECT_ADD(guid, this);

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)


void
CWsbPersistStream::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    //  Subtract class from object table
    GUID guid;
    if (S_OK != GetClassID(&guid)) {
        guid = GUID_NULL;
    }
    WSB_OBJECT_SUB(guid, this);

    CComObjectRoot::FinalRelease();
}

#if defined(WSB_TRACK_MEMORY)
ULONG
CWsbPersistStream::InternalAddRef(
    )
{
    WsbTraceIn( L"CWsbPersistStream::InternalAddRef", L"this = %p", 
            static_cast<void *>(this) );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CWsbPersistStream::InternalAddRef", L"retval = %lu", retval);
    return( retval );
}

ULONG
CWsbPersistStream::InternalRelease(
    )
{
    WsbTraceIn( L"CWsbPersistStream::InternalRelease", L"this = %p", 
            static_cast<void *>(this) );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CWsbPersistStream::InternalRelease", L"retval = %lu", retval);
    return( retval );
}
#endif


HRESULT
CWsbPersistStream::IsDirty(
    void
    )

/*++

Implements:

  IPersistStream::IsDirty().

--*/
{
    HRESULT     hr = S_FALSE;

    WsbTraceIn(OLESTR("CWsbPersistStream::IsDirty"), OLESTR(""));
    
    if (m_isDirty) {
        hr = S_OK;
    }
    
    WsbTraceOut(OLESTR("CWsbPersistStream::IsDirty"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbPersistStream::SetIsDirty(
    IN BOOL isDirty
    )

/*++

Implements:

  IWsbPersistable::SetIsDirty().

--*/
{
    WsbTraceIn(OLESTR("CWsbPersistable::SetIsDirty"), OLESTR("isDirty = <%ls>"), WsbBoolAsString(isDirty));

    m_isDirty = isDirty;

    WsbTraceOut(OLESTR("CWsbPersistable::SetIsDirty"), OLESTR(""));

    return(S_OK);
}



// ******** CWsbPersistable ************


HRESULT
CWsbPersistable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());

        // Initialize some member data.
        m_persistState          = WSB_PERSIST_STATE_UNINIT;

    } WsbCatch(hr);

    return(hr);
}


void
CWsbPersistable::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT     hr = S_OK;
    
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbPersistable::GetCurFile(
    OUT OLECHAR** pFileName
    )

/*++

Implements:

  IPersistFile::GetCurFile().

--*/
{
    HRESULT     hr = S_OK;

    // Make sure that the string is returned into newly allocated
    // memory (or not at all).
    *pFileName = NULL;
    
    try {
        ULONG  Size;

        WsbAffirm(m_persistState != WSB_PERSIST_STATE_UNINIT, E_UNEXPECTED);

        // Retrieve the actual name if one is specifed or the default name
        // if one has not been specified.
        WsbAffirmHr(m_persistFileName.GetSize(&Size));
        if (Size > 0) {
            WsbAffirmHr(WsbAllocAndCopyComString(pFileName, m_persistFileName, 0));
        } else {
            WsbAffirmHr(GetDefaultFileName(pFileName, 0));
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CWsbPersistable::GetDefaultFileName(
    OUT OLECHAR** pFileName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbPersistable::GetDefaultFileName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::GetDefaultFileName"), OLESTR("bufferSize = <%lu>"), bufferSize);
   
    try {
        ULONG  Size;

        // If we haven't read the default in from the resource file, then
        // do so now.
        WsbAffirmHr(m_persistDefaultName.GetSize(&Size));
        if (Size == 0) {
            WsbAffirmHr(m_persistDefaultName.LoadFromRsc(_Module.m_hInst, IDS_WSBPERSISTABLE_DEF_FILE));
        }

        WsbAffirmHr(WsbAllocAndCopyComString(pFileName, m_persistDefaultName, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::GetDefaultFileName"), OLESTR("hr = <%ls>, FileName = <%ls>"), WsbHrAsString(hr), pFileName);
    
    return(hr);
}


HRESULT
CWsbPersistable::Load(
    IN LPCOLESTR fileName,
    IN DWORD mode
    )

/*++

Implements:

  IPersistFile::Load().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IStream>                pStream;
    CLSID                           clsid;
    CLSID                           clsidFile;
    CComPtr<IRunningObjectTable>    pROT;
    CComPtr<IMoniker>               pMoniker;

    WsbTraceIn(OLESTR("CWsbPersistable::Load"), OLESTR("fileName = <%ls>, mode = <%lx>> m_persistState = <%d>"), 
                    fileName, mode, m_persistState);

    try {
        CComPtr<IPersistStream> pIPersistStream;

        WsbAffirm(m_persistState == WSB_PERSIST_STATE_UNINIT,  E_UNEXPECTED);
        WsbAffirm(fileName,  E_UNEXPECTED);
     
        // Open a storage on the file where the data is stored.
        if (0 == mode) {
            WsbAffirmHr(StgOpenStorageEx(fileName, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
        }
        else {
            WsbAffirmHr(StgOpenStorageEx(fileName, mode, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
        }

        // Get the IPersistStream interface.
        WsbAffirmHr(((IUnknown*)(IWsbPersistable*) this)->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream));

        // Open a stream.
        WsbAffirmHr(m_persistStorage->OpenStream(WSB_PERSIST_DEFAULT_STREAM_NAME, NULL, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0, &pStream));
            
        // Load the object using the IPersistStream::Load() method, checking
        // to make sure the CLSID is correct.
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(ReadClassStm(pStream, &clsidFile));
        WsbAffirm(clsid == clsidFile, WSB_E_STREAM_ERROR);
        
        WsbAffirmHr(pIPersistStream->Load(pStream));

        //  Check that we got everything by reading a special ULONG
        //  that should be at the end
        ULONG check_value;
        WsbAffirmHr(WsbLoadFromStream(pStream, &check_value));
        WsbAffirm(check_value == PERSIST_CHECK_VALUE, WSB_E_PERSISTENCE_FILE_CORRUPT);

        // We are now in the normal state.
        m_persistFileName = fileName;
        m_persistState = WSB_PERSIST_STATE_NORMAL;

        m_persistStream = pStream;
    
    } WsbCatchAndDo(hr,
        //
        // Set the storage pointer to null on an error to make sure the file is closed.
        //
        m_persistStorage = NULL;

    );

    WsbTraceOut(OLESTR("CWsbPersistable::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbPersistable::ReleaseFile(
    void
    )

/*++

Implements:

  IWsbPersistable::ReleaseFile().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::ReleaseFile"), OLESTR(""));
   
    try {
        WsbAffirm(m_persistState != WSB_PERSIST_STATE_UNINIT, E_UNEXPECTED);

        // Try to make sure changes are committed
        if (m_persistStream) {
            m_persistStream->Commit(STGC_DEFAULT);
        }
        if (m_persistStorage) {
            m_persistStorage->Commit(STGC_DEFAULT);
        }
        
        // Release the resources that we have been holding open.
        m_persistStream = NULL;
        m_persistStorage = NULL;
        m_persistFileName.Free();

        m_persistState = WSB_PERSIST_STATE_RELEASED;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::ReleaseFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT CWsbPersistable::Save(
    IN LPCOLESTR fileName,
    IN BOOL remember
    )

/*++

Implements:

  IPersistFile::Save().

--*/
{
    HRESULT             hr = S_OK;
    OLECHAR*            name;
    BOOL                create = FALSE;
    CComPtr<IStream>    pStream;
    CLSID               clsid;
    
    WsbTraceIn(OLESTR("CWsbPersistable::Save"), OLESTR("fileName = <%ls>, remember = <%ls>"), WsbPtrToStringAsString((OLECHAR**) &fileName), WsbBoolAsString(remember));

    try {
        CComPtr<IPersistStream> pIPersistStream;
    
        // Make sure that we are in the right state.
        WsbAffirm(((m_persistState == WSB_PERSIST_STATE_UNINIT) ||
                    (m_persistState == WSB_PERSIST_STATE_NORMAL) ||
                    (m_persistState == WSB_PERSIST_STATE_RELEASED)),
                  E_UNEXPECTED);

        WsbAssert((m_persistState == WSB_PERSIST_STATE_NORMAL) || (0 != fileName), E_POINTER);

        // If they supplied a name use it,
        if ((m_persistState == WSB_PERSIST_STATE_UNINIT) ||
                (m_persistState == WSB_PERSIST_STATE_RELEASED)) {
            
            // We need to create a new file based on the name
            // that they gave us.
            name = (OLECHAR*) fileName;
            create = TRUE;
        } else {

            // If they gave a name and it is different than what we have
            // stored, then we need to create a new file.
            if ((0 != fileName) && (_wcsicmp(m_persistFileName, fileName) != 0)) {
                name = (OLECHAR*) fileName;
                create = TRUE;
            }
          
            // Otherwise, use the stored name.
            else {
                name = m_persistFileName;
            }
        }

        // We should now have a file name and know whether to open or
        // create a file.
        if (create) {
            WsbAffirmHr(StgCreateStorageEx(name, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
            WsbAffirmHr(m_persistStorage->CreateStream(WSB_PERSIST_DEFAULT_STREAM_NAME, STGM_DIRECT | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 
                    0, 0, &pStream));
        } else {
            LARGE_INTEGER       llOffset;
                
            pStream = m_persistStream;

            llOffset.QuadPart = 0;
            WsbAffirmHr(pStream->Seek(llOffset, STREAM_SEEK_SET, NULL));
        }

        // Get the IPersistStream interface.
        WsbAffirmHr(((IUnknown*)(IWsbPersistable*) this)->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream));

        // Write out the class id, and then Save the data using IPersistStream method.
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(WriteClassStm(pStream, clsid));
        WsbAffirmHr(pIPersistStream->Save(pStream, remember));

        //  Put a special ULONG value at the end as a check during load
        ULONG check_value = PERSIST_CHECK_VALUE;
        WsbAffirmHr(WsbSaveToStream(pStream, check_value));
        //
        // Commit the stream right now, as ReleaseFile will not commit it
        // if we close the stream
        //
        WsbAffirmHr(pStream->Commit(STGC_DEFAULT));

        // Should we remember the file that was specified as the new
        // current file?
        if (remember) {
            m_persistState = WSB_PERSIST_STATE_NOSCRIBBLE;

            // If we created a new file, then remember it's name.
            if (create) {
                m_persistFileName = fileName;
            }

            // We need to make sure that we don't have anything open on this
            // file.
            m_persistStream = NULL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbPersistable::SaveCompleted(
    IN LPCOLESTR fileName
    )

/*++

Implements:

  IPersistFile::SaveCompleted().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IStream>    pStream;

    WsbTraceIn(OLESTR("CWsbPersistable::SaveCompleted"), OLESTR("fileName = <%ls>"), fileName);

    try {

        // Are we doing any other kind of persistance, are we doing storage
        // persistence, but are in the wrong state, or are the parameters
        // wrong.
        WsbAffirm(m_persistState == WSB_PERSIST_STATE_NOSCRIBBLE, E_UNEXPECTED);

        // Save off the name that was given to us, and only another save to
        // begin.
        if (fileName != NULL) {
            m_persistFileName = fileName;
        }

        // Open a storage to the file where the data is stored.
        WsbAffirmHr(StgOpenStorageEx(m_persistFileName, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));

        // Open a stream.
        WsbAffirmHr(m_persistStorage->OpenStream(WSB_PERSIST_DEFAULT_STREAM_NAME, NULL, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStream));
     
        // Save it all off.
        m_persistState = WSB_PERSIST_STATE_NORMAL;

        m_persistStream = pStream;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::SaveCompleted"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbPersistable::SetDefaultFileName(
    IN OLECHAR* fileName
    )

/*++

Implements:

  IWsbPersistable::SetDefaultFileName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::SetDefaultFileName"), OLESTR("fileName = <%ls>"), fileName);
    
    m_persistDefaultName = fileName;
    
    WsbTraceOut(OLESTR("CWsbPersistable::SetDefaultFileName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}



// Standard Type Helper Functions

HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT BOOL* pValue
    )

/*++

Routine Description:

  Loads a BOOL value from the specified stream and sets
  pValue to value of the BOOL.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a BOOL that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(BOOL)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(BOOL)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToBoolAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT LONG* pValue
    )

/*++

Routine Description:

  Loads a LONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a LONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(LONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(LONG)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToLongAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT GUID* pValue
    )

/*++

Routine Description:

  Loads a GUID value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a GUID that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(GUID)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(GUID)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT SHORT* pValue
    )

/*++

Routine Description:

  Loads a SHORT value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a SHORT that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(SHORT)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(SHORT)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN  IStream*    pStream,
    OUT BYTE*       pValue
    )

/*++

Routine Description:

  Loads a BYTE value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream    - The stream from which the value will be read.

  pValue     - A pointer to a BYTE that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(BYTE)"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) pValue, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(BYTE)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToByteAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN  IStream*    pStream,
    OUT UCHAR*      pValue,
    IN  ULONG       bufferSize
    )

/*++

Routine Description:

  Loads a UCHAR array value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream    - The stream from which the value will be read.

  pValue     - A pointer to a BYTE that will be set to the value.

  bufferSize - number of bytes to load

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(UCHAR)"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = bufferSize;
        WsbAffirmHr(pStream->Read((void*) pValue, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(UCHAR)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr));

    return(hr);

}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT OLECHAR** pValue,
    IN ULONG ulBufferSize
    )

/*++

Routine Description:

  Loads a STRING value from the specified stream and sets
  pValue to the string.

Arguments:

  pStream   - The stream from which the string will be read.

  pValue    - A pointer to a STRING that will be set to the string
                read in..

  ulBufferSize - Size of buffer pValue points to or zero allow
                alloc/realloc of the  buffer.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbLoadFromStream(STRING)"), OLESTR(""));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Get the length of the string (in bytes).
        WsbAffirmHr(WsbLoadFromStream(pStream, &size));
       
        if (size != 0) {
          // Allocate a buffer to hold the string.
          WsbAffirmHr(WsbGetComBuffer(pValue, ulBufferSize, size, NULL));
          pc = *pValue;
      
          // Now read in the proper number of wide chars.
          nchar = size / sizeof(USHORT);
          for (ULONG i = 0; i < nchar; i++) {
              WsbAffirmHr(WsbLoadFromStream(pStream, &wc));
              *pc++ = wc;
          }
        } else {
          // Allocate a buffer to hold the string.
          WsbAffirmHr(WsbGetComBuffer(pValue, ulBufferSize, sizeof(OLECHAR), NULL));
          *(*pValue) = 0;
        }         
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(STRING)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULONG* pValue
    )

/*++

Routine Description:

  Loads a ULONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULONG)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT USHORT* pValue
    )

/*++

Routine Description:

  Loads a USHORT value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a USHORT that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(USHORT)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(USHORT)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToUshortAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT LONGLONG* pValue
    )

/*++

Routine Description:

  Loads a LONGLONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a LONGLONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(LONGLONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULONGLONG* pValue
    )

/*++

Routine Description:

  Loads a ULONGLONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULONGLONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULONGLONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT DATE* pValue
    )

/*++

Routine Description:

  Loads a DATE value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a DATE that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(DATE)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

//  WsbTraceOut(OLESTR("WsbLoadFromStream(DATE)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToLongAsString(pValue));

    // Modify next statement after WsbDate functions written to be like the one above.
    WsbTraceOut(OLESTR("WsbLoadFromStream(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT FILETIME* pValue
    )

/*++

Routine Description:

  Loads a FILETIME value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a FILETIME that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(FILETIME)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULARGE_INTEGER* pValue
    )

/*++

Routine Description:

  Loads a ULARGE_INTEGER value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULARGE_INTEGER that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULARGE_INTEGER)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN BOOL value
    )

/*++

Routine Description:

  Saves a BOOL value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the BOOL to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(BOOL)"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN GUID value
    )

/*++

Routine Description:

  Saves a GUID value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the GUID to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(GUID)"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    LONG value
    )

/*++

Routine Description:

  Saves a LONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the LONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(LONG)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    SHORT value
    )

/*++

Routine Description:

  Saves a SHORT value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the SHORT to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(SHORT)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream*    pStream,
    BYTE        value
    )

/*++

Routine Description:

  Saves a BYTE value to the specified stream.

Arguments:

  pStream    - The stream to which the value will be written.

  value      - The value of the BYTE to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(BYTE)"), OLESTR("value = <%ld>"), value);

    try {

        WsbAssert(0 != pStream, E_POINTER);

        size = WsbByteSize(value);
        WsbAffirmHr(pStream->Write((void*) &value, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(BYTE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream*    pStream,
    UCHAR*      value,
    ULONG       bufferSize
    )

/*++

Routine Description:

  Saves a UCHAR array to the specified stream.

Arguments:

  pStream    - The stream to which the value will be written.

  value      - The pointer to value of the UCHAR array to be written.

  bufferSize - Size of array to save (in bytes).

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(UCHAR)"), OLESTR("value = <%ld>"), value);

    try {
    
        WsbAssert(0 != pStream, E_POINTER);

//      WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));

        size = bufferSize;
        WsbAffirmHr(pStream->Write((void*) value, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(UCHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN OLECHAR* value
    )

/*++

Routine Description:

  Saves a OLECHAR string to the specified stream.

Arguments:

  pStream   - The stream to which the string will be written.

  value     - The string to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or value was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbSaveToStream(STRING)"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;
    
        WsbAssert(0 != pStream, E_POINTER);
//      WsbAssert(0 != value, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Save the length of the string (in bytes).
        if (value) {
            nchar = wcslen(value) + 1;
        } else {
            nchar = 0;
        }
        size = nchar * sizeof(USHORT);
        WsbAffirmHr(WsbSaveToStream(pStream, size));
                
        // Now write out the proper number of wide chars
        pc = value;
        for (ULONG i = 0; i < nchar; i++) {
            wc = *pc++;
            WsbAffirmHr(WsbSaveToStream(pStream, wc));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(STRING)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULONG value
    )

/*++

Routine Description:

  Saves a ULONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULONG)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    USHORT value
    )

/*++

Routine Description:

  Saves a USHORT value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the USHORT to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(USHORT)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    LONGLONG value
    )

/*++

Routine Description:

  Saves a LONGLONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the LONGLONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(LONGLONG)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULONGLONG value
    )

/*++

Routine Description:

  Saves a ULONGLONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULONGLONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULONGLONG)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    DATE    value
    )

/*++

Routine Description:

  Saves a DATE value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the DATE to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    // Modify next statement to return date after WsbDate functions written.
    WsbTraceIn(OLESTR("WsbSaveToStream(DATE)"), OLESTR("value = <%f>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
WsbSaveToStream(
    IStream* pStream,
    FILETIME value
    )

/*++

Routine Description:

  Saves a FILETIME value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the FILETIME to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(FILETIME)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbBstrFromStream(
    IN IStream* pStream,
    OUT BSTR* pValue
    )

/*++

Routine Description:

  Loads a BSTR value from the specified stream.

Arguments:

  pStream   - The stream from which the BSTR will be read.

  pValue    - A pointer to a BSTR.  If *pValue is NULL, this
                function will allocate the BSTR; if it already
                points to a BSTR that is too short, the BSTR
                will be reallocated.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbBstrFromStream"), OLESTR(""));

    try {
        ULONG               bchar;
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Get the length of the string (in bytes).
        WsbAffirmHr(WsbLoadFromStream(pStream, &size));
                
        // (Re)allocate a buffer to hold the string.
        nchar = size / sizeof(USHORT);
        bchar = nchar - 1;
        if (*pValue) {
            if (bchar != SysStringLen(*pValue)) {
                WsbAffirm(WsbReallocStringLen(pValue, NULL, bchar), 
                        WSB_E_RESOURCE_UNAVAILABLE);
            }
        } else {
            *pValue = WsbAllocStringLen(NULL, bchar);
            WsbAffirm(*pValue, WSB_E_RESOURCE_UNAVAILABLE);
        }

        // Now read in the proper number of wide chars.
        pc = *pValue;
        for (ULONG i = 0; i < nchar; i++) {
            WsbAffirmHr(WsbLoadFromStream(pStream, &wc));
            *pc++ = wc;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbBstrFromStream"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pValue));

    return(hr);
}


HRESULT
WsbBstrToStream(
    IN IStream* pStream,
    IN BSTR value
    )

/*++

Routine Description:

  Saves a BSTR to the specified stream.

Arguments:

  pStream   - The stream to which the BSTR will be written.

  value     - The BSTR to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbBstrToStream"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;
    
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != value, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Save the length of the string (in bytes).
        nchar = SysStringLen(value) + 1;
        size = nchar * sizeof(USHORT);
        WsbAffirmHr(WsbSaveToStream(pStream, size));
                
        // Now write out the proper number of wide chars
        pc = value;
        for (ULONG i = 0; i < nchar; i++) {
            wc = *pc++;
            WsbAffirmHr(WsbSaveToStream(pStream, wc));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbBstrToStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULARGE_INTEGER value
    )

/*++

Routine Description:

  Saves a ULARGE_INTEGER value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULARGE_INTEER to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULARGE_INTEGER)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


static HRESULT 
WsbMakeBackupName(
    OLECHAR*  pSaveName,
    OLECHAR*  pExtension,
    OLECHAR** ppBackupName
)

/*++

Routine Description:

  Converts a Save file name to a backup file name.

Arguments:

  pSaveName     - Orginal file name.

  pExtension    - The file extension to substitute.

  ppBackupName  - Pointer to pointer to new backup file name.

Return Value:

  S_OK      - Success
  E_...     - Some error.

--*/
{
    HRESULT        hr = S_OK;

    try {
        size_t        len;
        CWsbStringPtr NewName;
        OLECHAR*      pC;

        //  It sure would be nice to have a general function for parsing
        //  file names!

        //  Find the file extension (if any)
        NewName = pSaveName;
        if (NewName == NULL) {
            WsbThrow(E_OUTOFMEMORY);
        }
        len = wcslen(NewName);
        pC = wcsrchr(NewName, OLECHAR('.'));
        if (pC && (size_t)((pC - (OLECHAR*)NewName) + 4) >= len) {
            *pC = 0;
        }

        //  Put on new file extension
        NewName.Append(pExtension);

        //  Give the buffer to the output parameter
        NewName.GiveTo(ppBackupName);
    } WsbCatch(hr);

    return(hr);
}


HRESULT   
WsbPrintfToStream(
    IStream* pStream, 
    OLECHAR* fmtString, 
    ...
)

/*++

Routine Description:

    Print printf-style format string and arguments to a stream.

Arguments:

    pStream     - The stream to which the value will be written.

    fmtString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    S_OK        - Success.

--*/

{
    HRESULT     hr = S_OK;
    
    try {
        ULONG         bytesWritten;
        ULONG         nBytes;
        ULONG         nChars=0;
        CWsbStringPtr tmpString;
        va_list       vaList;

        va_start(vaList, fmtString);
        WsbAffirmHr(tmpString.VPrintf(fmtString, vaList));
        va_end(vaList);
        WsbAffirmHr(tmpString.GetLen(&nChars));
        nBytes = nChars * sizeof(WCHAR);
        if (0 < nBytes) {
            WsbAffirmHr(pStream->Write(static_cast<WCHAR *>(tmpString), 
                nBytes, &bytesWritten));
            WsbAffirm(bytesWritten == nBytes, E_FAIL);
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
WsbSafeCreate(
    OLECHAR*      pFileName,
    IPersistFile* pIPFile
    )

/*++

Routine Description:
   Makes sure there are no database files found and then creates the database files.

Arguments:

  pFileName - Name of the file containing the persisted data
  pIPFile   - Pointer to the objects IPersistFile interface.

Return Value:

  S_OK                          - Success
  WSB_E_DATABASE_ALREADY_EXISTS - The databases already exist and cannot be created.
  E_...                         - Some other error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pNewName = NULL;


    WsbTraceIn(OLESTR("WsbSafeCreate"), OLESTR("<%ls>"), pFileName);

    try {
        CComPtr<IWsbPersistable> pIWsbPersist;
        BOOL                     fileThere = FALSE;

        //  Save the file name passed as the default file name
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->SetDefaultFileName(pFileName));
        
        //
        // Check to see if the file exists.  If so, life is BAD.
        // If not, then see if the new or backup files exist
        // and use them
        //
        //  Make sure the Save file exists
        if (!WsbFileExists(pFileName)) {
            //
            // The file doesn't exist.  See if the new copy is there
            //
            //  Create name for new (temporary) file
            //
            WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".new"), &pNewName));

            //  See if the new file exists
            if (!WsbFileExists(pNewName)) {
                //
                // Don't have the new file, look for the backup file
                //
                WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));
                if (WsbFileExists(pBackupName)) {
                    //
                    // Backup is there - complain
                    //
                    hr = WSB_E_DATABASE_ALREADY_EXISTS;
                }
            } else  {
                //
                // New is there - complain
                //
                hr = WSB_E_DATABASE_ALREADY_EXISTS;
            }                
        } else  {
            //
            // The file exists so complain
            //
            hr = WSB_E_DATABASE_ALREADY_EXISTS;
            WsbThrow( hr );
        }
        
        //
        // If we haven't thrown then it is OK to create the files
        //
        hr = pIPFile->Save( pFileName, TRUE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFECREATE_SAVE_FAILED, 0, NULL, pFileName, NULL);
            WsbThrow(hr);
        }

        //  Release the file
        WsbAffirmHr(pIWsbPersist->ReleaseFile());
        
    } WsbCatch(hr);

    if (pBackupName) {
        WsbFree(pBackupName);
    }
    if (pNewName) {
        WsbFree(pNewName);
    }

    WsbTraceOut(OLESTR("WsbSafeCreate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSafeLoad(
    OLECHAR*      pFileName,
    IPersistFile* pIPFile,
    BOOL          UseBackup
    )

/*++

Routine Description:
   Loads data from the specified file name.  Works in conjunction with WsbSafeSave
   to best recover from disaster situations.

Arguments:

  pFileName - Name of the file containing the persisted data
  pIPFile   - Pointer to the objects IPersistFile interface.
  UseBackup - Load data from backup file instead of normal file
              NOTE: (this is not used anymore)

Return Value:

  S_OK              - Success
  WSB_E_NOTFOUND    - The databases could not be found
  E_...             - Some other error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pLoadName = NULL;
    BOOL           usingBackup = FALSE;
    BOOL           TracePersistence = FALSE;

    UNREFERENCED_PARAMETER(UseBackup);

    //  Turn tracing off during save if it's not wanted
    if (g_pWsbTrace) {
        g_pWsbTrace->GetTraceSetting(WSB_TRACE_BIT_PERSISTENCE, &TracePersistence);
    }
    if (!TracePersistence) {
        WsbTraceThreadOff();
    }
    WsbTraceIn(OLESTR("WsbSafeLoad"), OLESTR("File = <%ls>, UseBackup = %ls"), 
            pFileName, WsbBoolAsString(UseBackup));

    try {
        HRESULT                  hrLoad;
        BOOL                     fileThere = FALSE;
        CComPtr<IWsbPersistable> pIWsbPersist;

        //  Save the file name passed as the default file name
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->SetDefaultFileName(pFileName));

        //
        // Create the backup file name
        //
        WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));

        //
        // Check if the .col exists
        //
    